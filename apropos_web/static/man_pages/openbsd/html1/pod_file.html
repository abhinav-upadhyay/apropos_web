<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
MKTABLES(1)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
MKTABLES(1)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
MKTABLES(1)</td>
</tr>
</tbody>
</table>
<div class="subsection">
<h2>Legal &quot;\\p{}&quot; and &quot;\\P{}&quot; constructs that match no characters</h2> Unicode has some property-value pairs that currently don't match anything. This happens generally either because they are obsolete, or they exist for symmetry with other forms, but no language has yet been encoded that uses them.  In this version of Unicode, the following match zero code points:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
$zero_matches</div>
<div class="spacer">
</div>
END<br/>
    }<div class="spacer">
</div>
<br/>
    # Generate list of properties that we don't accept, grouped by the reasons<br/>
    # why.  This is so only put out the 'why' once, and then list all the<br/>
    # properties that have that reason under it.<br/>
<br/>
    my %why_list;   # The keys are the reasons; the values are lists of<br/>
                    # properties that have the key as their reason<br/>
<br/>
    # For each property, add it to the list that are suppressed for its reason<br/>
    # The sort will cause the alphabetically first properties to be added to<br/>
    # each list first, so each list will be sorted.<br/>
    foreach my $property (sort keys %why_suppressed) {<br/>
        push @{$why_list{$why_suppressed{$property}}}, $property;<br/>
    }<br/>
<br/>
    # For each reason (sorted by the first property that has that reason)...<br/>
    my @bad_re_properties;<br/>
    foreach my $why (sort { $why_list{$a}-&gt;[0] cmp $why_list{$b}-&gt;[0] }<br/>
                     keys %why_list)<br/>
    {<br/>
        # Add to the output, all the properties that have that reason.<br/>
        my $has_item = 0;   # Flag if actually output anything.<br/>
        foreach my $name (@{$why_list{$why}}) {<br/>
<br/>
            # Split compound names into $property and $table components<br/>
            my $property = $name;<br/>
            my $table;<br/>
            if ($property =~ / (.*) = (.*) /x) {<br/>
                $property = $1;<br/>
                $table = $2;<br/>
            }<br/>
<br/>
            # This release of Unicode may not have a property that is<br/>
            # suppressed, so don't reference a non-existent one.<br/>
            $property = property_ref($property);<br/>
            next if ! defined $property;<br/>
<br/>
            # And since this list is only for match tables, don't list the<br/>
            # ones that don't have match tables.<br/>
            next if ! $property-&gt;to_create_match_tables;<br/>
<br/>
            # Find any abbreviation, and turn it into a compound name if this<br/>
            # is a property=value pair.<br/>
            my $short_name = $property-&gt;name;<br/>
            $short_name .= '=' . $property-&gt;table($table)-&gt;name if $table;<br/>
<br/>
            # Start with an empty line.<br/>
            push @bad_re_properties, &quot;\n\n&quot; unless $has_item;<br/>
<br/>
            # And add the property as an item for the reason.<br/>
            push @bad_re_properties, &quot;\n=item I&lt;$name&gt; ($short_name)\n&quot;;<br/>
            $has_item = 1;<br/>
        }<br/>
<br/>
        # And add the reason under the list of properties, if such a list<br/>
        # actually got generated.  Note that the header got added<br/>
        # unconditionally before.  But pod ignores extra blank lines, so no<br/>
        # harm.<br/>
        push @bad_re_properties, &quot;\n$why\n&quot; if $has_item;<br/>
<br/>
    } # End of looping through each reason.<br/>
<br/>
    if (! @bad_re_properties) {<br/>
        push @bad_re_properties,<br/>
                &quot;*** This installation accepts ALL non-Unihan properties ***&quot;;<br/>
    }<br/>
    else {<br/>
        # Add =over only if non-empty to avoid an empty =over/=back section,<br/>
        # which is considered bad form.<br/>
        unshift @bad_re_properties, &quot;\n=over 4\n&quot;;<br/>
        push @bad_re_properties, &quot;\n=back\n&quot;;<br/>
    }<br/>
<br/>
    # Similiarly, generate a list of files that we don't use, grouped by the<br/>
    # reasons why.  First, create a hash whose keys are the reasons, and whose<br/>
    # values are anonymous arrays of all the files that share that reason.<br/>
    my %grouped_by_reason;<br/>
    foreach my $file (keys %ignored_files) {<br/>
        push @{$grouped_by_reason{$ignored_files{$file}}}, $file;<br/>
    }<br/>
    foreach my $file (keys %skipped_files) {<br/>
        push @{$grouped_by_reason{$skipped_files{$file}}}, $file;<br/>
    }<br/>
<br/>
    # Then, sort each group.<br/>
    foreach my $group (keys %grouped_by_reason) {<br/>
        @{$grouped_by_reason{$group}} = sort { lc $a cmp lc $b }<br/>
                                        @{$grouped_by_reason{$group}} ;<br/>
    }<br/>
<br/>
    # Finally, create the output text.  For each reason (sorted by the<br/>
    # alphabetically first file that has that reason)...<br/>
    my @unused_files;<br/>
    foreach my $reason (sort { lc $grouped_by_reason{$a}-&gt;[0]<br/>
                               cmp lc $grouped_by_reason{$b}-&gt;[0]<br/>
                              }<br/>
                         keys %grouped_by_reason)<br/>
    {<br/>
        # Add all the files that have that reason to the output.  Start<br/>
        # with an empty line.<br/>
        push @unused_files, &quot;\n\n&quot;;<br/>
        push @unused_files, map { &quot;\n=item F&lt;$_&gt; \n&quot; }<br/>
                            @{$grouped_by_reason{$reason}};<br/>
        # And add the reason under the list of files<br/>
        push @unused_files, &quot;\n$reason\n&quot;;<br/>
    }<br/>
<br/>
    # Similarly, create the output text for the UCD section of the pod<br/>
    my @ucd_pod;<br/>
    foreach my $key (keys %ucd_pod) {<br/>
        next unless $ucd_pod{$key}-&gt;{'output_this'};<br/>
        push @ucd_pod, format_pod_line($indent_info_column,<br/>
                                       $ucd_pod{$key}-&gt;{'name'},<br/>
                                       $ucd_pod{$key}-&gt;{'info'},<br/>
                                       $ucd_pod{$key}-&gt;{'status'},<br/>
                                      );<br/>
    }<br/>
<br/>
    # Sort alphabetically, and fold for output<br/>
    @ucd_pod = sort { lc substr($a, 2) cmp lc substr($b, 2) } @ucd_pod;<br/>
    my $ucd_pod = simple_fold(\@ucd_pod,<br/>
                           ' ',<br/>
                           $indent_info_column,<br/>
                           $automatic_pod_indent);<br/>
    $ucd_pod =  format_pod_line($indent_info_column, 'NAME', '  INFO')<br/>
                . &quot;\n&quot;<br/>
                . $ucd_pod;<br/>
    local $&quot; = &quot;&quot;;<br/>
<br/>
    # Everything is ready to assemble.<br/>
    my @OUT = &lt;&lt; &quot;END&quot;;<br/>
=begin comment<br/>
<div class="spacer">
</div>
$HEADER<div class="spacer">
</div>
To change this file, edit $0 instead.</div>
<div class="section">
<h1>NAME</h1> $pod_file - Index of Unicode Version $string_version character properties in Perl</div>
<div class="section">
<h1>DESCRIPTION</h1> This document provides information about the portion of the Unicode database that deals with character properties, that is the portion that is defined on single code points.  (&quot;Other information in the Unicode data base&quot; below briefly mentions other data that Unicode provides.)<div class="spacer">
</div>
Perl can provide access to all non-provisional Unicode character properties, though not all are enabled by default.  The omitted ones are the Unihan properties (accessible via the CPAN module Unicode::Unihan) and certain deprecated or Unicode-internal properties.  (An installation may choose to recompile Perl's tables to change this.  See &quot;Unicode character properties that are NOT accepted by Perl&quot;.)<div class="spacer">
</div>
For most purposes, access to Unicode properties from the Perl core is through regular expression matches, as described in the next section. For some special purposes, and to access the properties that are not suitable for regular expression matching, all the Unicode character properties that Perl handles are accessible via the standard Unicode::UCD module, as described in the section &quot;Properties accessible through Unicode::UCD&quot;.<div class="spacer">
</div>
Perl also provides some additional extensions and short-cut synonyms for Unicode properties.<div class="spacer">
</div>
This document merely lists all available properties and does not attempt to explain what each property really means.  There is a brief description of each Perl extension; see &quot;Other Properties&quot; in perlunicode for more information on these.  There is some detail about Blocks, Scripts, General_Category, and Bidi_Class in perlunicode, but to find out about the intricacies of the official Unicode properties, refer to the Unicode standard.  A good starting place is $unicode_reference_url.<div class="spacer">
</div>
Note that you can define your own properties; see &quot;User-Defined Character Properties&quot; in perlunicode.</div>
<div class="section">
<h1>Properties accessible through &quot;\\p{}&quot; and &quot;\\P{}&quot;</h1> The Perl regular expression &quot;\\p{}&quot; and &quot;\\P{}&quot; constructs give access to most of the Unicode character properties.  The table below shows all these constructs, both single and compound forms.<div class="spacer">
</div>
<b>Compound forms</b> consist of two components, separated by an equals sign or a colon.  The first component is the property name, and the second component is the particular value of the property to match against, for example, &quot;\\p{Script: Greek}&quot; and &quot;\\p{Script=Greek}&quot; both mean to match characters whose Script property value is Greek.<div class="spacer">
</div>
<b>Single forms</b>, like &quot;\\p{Greek}&quot;, are mostly Perl-defined shortcuts for their equivalent compound forms.  The table shows these equivalences.  (In our example, &quot;\\p{Greek}&quot; is a just a shortcut for &quot;\\p{Script=Greek}&quot;.) There are also a few Perl-defined single forms that are not shortcuts for a compound form.  One such is &quot;\\p{Word}&quot;.  These are also listed in the table.<div class="spacer">
</div>
In parsing these constructs, Perl always ignores Upper/lower case differences everywhere within the {braces}.  Thus &quot;\\p{Greek}&quot; means the same thing as &quot;\\p{greek}&quot;.  But note that changing the case of the &quot;p&quot; or &quot;P&quot; before the left brace completely changes the meaning of the construct, from &quot;match&quot; (for &quot;\\p{}&quot;) to &quot;doesn't match&quot; (for &quot;\\P{}&quot;).  Casing in this document is for improved legibility.<div class="spacer">
</div>
Also, white space, hyphens, and underscores are normally ignored everywhere between the {braces}, and hence can be freely added or removed even if the &quot;/x&quot; modifier hasn't been specified on the regular expression. But in the table below $a_bold_stricter at the beginning of an entry means that tighter (stricter) rules are used for that entry:<div style="margin-left: 4.00ex;">
<dl>
<dt>
Single form (&quot;\\p{name}&quot;) tighter rules:</dt>
<dd>
White space, hyphens, and underscores ARE significant except for:<div style="margin-left: 4.00ex;">
<dl>
<dt>
&#8226;</dt>
<dd>
white space adjacent to a non-word character</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
underscores separating digits in numbers</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">
&#160;</div>
That means, for example, that you can freely add or remove white space adjacent to (but within) the braces without affecting the meaning.</div>
</dd>
</dl>
<dl>
<dt>
Compound form (&quot;\\p{name=value}&quot; or &quot;\\p{name:value}&quot;) tighter rules:</dt>
<dd>
The tighter rules given above for the single form apply to everything to the right of the colon or equals; the looser rules still apply to everything to the left.<div style="height: 1.00em;">
&#160;</div>
That means, for example, that you can freely add or remove white space adjacent to (but within) the braces and the colon or equal sign.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
</div>
<div class="spacer">
</div>
Some properties are considered obsolete by Unicode, but still available. There are several varieties of obsolescence:<div style="margin-left: 4.00ex;">
<dl>
<dt>
Stabilized</dt>
<dd>
A property may be stabilized.  Such a determination does not indicate that the property should or should not be used; instead it is a declaration that the property will not be maintained nor extended for newly encoded characters.  Such properties are marked with $a_bold_stabilized in the table.</dd>
</dl>
<dl>
<dt>
Deprecated</dt>
<dd>
A property may be deprecated, perhaps because its original intent has been replaced by another property, or because its specification was somehow defective.  This means that its use is strongly discouraged, so much so that a warning will be issued if used, unless the regular expression is in the scope of a &quot;no&#160;warnings&#160;'deprecated'&quot; statement.  $A_bold_deprecated flags each such entry in the table, and the entry there for the longest, most descriptive version of the property will give the reason it is deprecated, and perhaps advice.  Perl may issue such a warning, even for properties that aren't officially deprecated by Unicode, when there used to be characters or code points that were matched by them, but no longer.  This is to warn you that your program may not work like it did on earlier Unicode releases.<div style="height: 1.00em;">
&#160;</div>
A deprecated property may be made unavailable in a future Perl version, so it is best to move away from them.<div style="height: 1.00em;">
&#160;</div>
A deprecated property may also be stabilized, but this fact is not shown.</dd>
</dl>
<dl>
<dt>
Obsolete</dt>
<dd>
Properties marked with $a_bold_obsolete in the table are considered (plain) obsolete.  Generally this designation is given to properties that Unicode once used for internal purposes (but not any longer).</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">
&#160;</div>
Some Perl extensions are present for backwards compatibility and are discouraged from being used, but are not obsolete.  $A_bold_discouraged flags each such entry in the table.  Future Unicode versions may force some of these extensions to be removed without warning, replaced by another property with the same name that means something different.  Use the equivalent shown instead.</div>
<div class="spacer">
</div>
@block_warning<div class="spacer">
</div>
The table below has two columns.  The left column contains the &quot;\\p{}&quot; constructs to look up, possibly preceded by the flags mentioned above; and the right column contains information about them, like a description, or synonyms.  The table shows both the single and compound forms for each property that has them.  If the left column is a short name for a property, the right column will give its longer, more descriptive name; and if the left column is the longest name, the right column will show any equivalent shortest name, in both single and compound forms if applicable.<div class="spacer">
</div>
If braces are not needed to specify a property (e.g., &quot;\\pL&quot;), the left column contains both forms, with and without braces.<div class="spacer">
</div>
The right column will also caution you if a property means something different than what might normally be expected.<div class="spacer">
</div>
All single forms are Perl extensions; a few compound forms are as well, and are noted as such.<div class="spacer">
</div>
Numbers in (parentheses) indicate the total number of Unicode code points matched by the property.  For emphasis, those properties that match no code points at all are listed as well in a separate section following the table.<div class="spacer">
</div>
Most properties match the same code points regardless of whether &quot;/i&quot; case-insensitive matching is specified or not.  But a few properties are affected.  These are shown with the notation &quot;(/i=&#160; <i>other_property</i>)&quot; in the second column.  Under case-insensitive matching they match the same code pode points as the property  <i>other_property</i>.<div class="spacer">
</div>
There is no description given for most non-Perl defined properties (See $unicode_reference_url for that).<div class="spacer">
</div>
For compactness, '<b>*</b>' is used as a wildcard instead of showing all possible combinations.  For example, entries like:<div class="spacer">
</div>
<br/>
 \\p{Gc: *}                                  \\p{General_Category: *}<br/>
<div class="spacer">
</div>
mean that 'Gc' is a synonym for 'General_Category', and anything that is valid for the latter is also valid for the former.  Similarly,<div class="spacer">
</div>
<br/>
 \\p{Is_*}                                   \\p{*}<br/>
<div class="spacer">
</div>
means that if and only if, for example, &quot;\\p{Foo}&quot; exists, then &quot;\\p{Is_Foo}&quot; and &quot;\\p{IsFoo}&quot; are also valid and all mean the same thing. And similarly, &quot;\\p{Foo=Bar}&quot; means the same as &quot;\\p{Is_Foo=Bar}&quot; and &quot;\\p{IsFoo=Bar}&quot;.  &quot;*&quot; here is restricted to something not beginning with an underscore.<div class="spacer">
</div>
Also, in binary properties, 'Yes', 'T', and 'True' are all synonyms for 'Y'. And 'No', 'F', and 'False' are all synonyms for 'N'.  The table shows 'Y*' and 'N*' to indicate this, and doesn't have separate entries for the other possibilities.  Note that not all properties which have values 'Yes' and 'No' are binary, and they have all their values spelled out without using this wild card, and a &quot;NOT&quot; clause in their description that highlights their not being binary.  These also require the compound form to match them, whereas true binary properties have both single and compound forms available.<div class="spacer">
</div>
Note that all non-essential underscores are removed in the display of the short names below.<div class="spacer">
</div>
<b>Legend summary:</b><dl>
<dt>
&#8226;</dt>
<dd>
<b>*</b> is a wild-card</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
<b>(\\d+)</b> in the info column gives the number of Unicode code points matched by this property.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
<b></b><b>$DEPRECATED</b><b></b> means this is deprecated.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
<b></b><b>$OBSOLETE</b><b></b> means this is obsolete.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
<b></b><b>$STABILIZED</b><b></b> means this is stabilized.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
<b></b><b>$STRICTER</b><b></b> means tighter (stricter) name matching applies.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
<b></b><b>$DISCOURAGED</b><b></b> means use of this form is discouraged, and may not be stable.</dd>
</dl>
<div class="spacer">
</div>
$formatted_properties<div class="spacer">
</div>
$zero_matches</div>
<div class="section">
<h1>Properties accessible through Unicode::UCD</h1> All the Unicode character properties mentioned above (except for those marked as for internal use by Perl) are also accessible by &quot; <i>prop_invlist()</i>&quot; in Unicode::UCD.<div class="spacer">
</div>
Due to their nature, not all Unicode character properties are suitable for regular expression matches, nor &quot;prop_invlist()&quot;.  The remaining non-provisional, non-internal ones are accessible via &quot; <i>prop_invmap()</i>&quot; in Unicode::UCD (except for those that this Perl installation hasn't included; see below for which those are).<div class="spacer">
</div>
For compatibility with other parts of Perl, all the single forms given in the table in the section above are recognized.  BUT, there are some ambiguities between some Perl extensions and the Unicode properties, all of which are silently resolved in favor of the official Unicode property.  To avoid surprises, you should only use &quot;prop_invmap()&quot; for forms listed in the table below, which omits the non-recommended ones.  The affected forms are the Perl single form equivalents of Unicode properties, such as &quot;\\p{sc}&quot; being a single-form equivalent of &quot;\\p{gc=sc}&quot;, which is treated by &quot;prop_invmap()&quot; as the &quot;Script&quot; property, whose short name is &quot;sc&quot;.  The table indicates the current ambiguities in the INFO column, beginning with the word &quot;NOT&quot;.<div class="spacer">
</div>
The standard Unicode properties listed below are documented in $unicode_reference_url; Perl_Decimal_Digit is documented in &quot; <i>prop_invmap()</i>&quot; in Unicode::UCD.  The other Perl extensions are in &quot;Other Properties&quot; in perlunicode;<div class="spacer">
</div>
The first column in the table is a name for the property; the second column is an alternative name, if any, plus possibly some annotations.  The alternative name is the property's full name, unless that would simply repeat the first column, in which case the second column indicates the property's short name (if different).  The annotations are given only in the entry for the full name.  If a property is obsolete, etc, the entry will be flagged with the same characters used in the table in the section above, like  <b></b><b>$DEPRECATED</b><b></b> or <b></b><b>$STABILIZED</b><b></b>.<div class="spacer">
</div>
$ucd_pod</div>
<div class="section">
<h1>Properties accessible through other means</h1> Certain properties are accessible also via core function calls.  These are:<div class="spacer">
</div>
<br/>
 Lowercase_Mapping          lc() and lcfirst()<br/>
 Titlecase_Mapping          ucfirst()<br/>
 Uppercase_Mapping          uc()<br/>
<div class="spacer">
</div>
Also, Case_Folding is accessible through the &quot;/i&quot; modifier in regular expressions, the &quot;\\F&quot; transliteration escape, and the &quot;fc&quot; operator.<div class="spacer">
</div>
And, the Name and Name_Aliases properties are accessible through the &quot;\\N{}&quot; interpolation in double-quoted strings and regular expressions; and functions &quot;charnames::viacode()&quot;, &quot;charnames::vianame()&quot;, and &quot;charnames::string_vianame()&quot; (which require a &quot;use charnames ();&quot; to be specified.<div class="spacer">
</div>
Finally, most properties related to decomposition are accessible via Unicode::Normalize.</div>
<div class="section">
<h1>Unicode character properties that are NOT accepted by Perl</h1> Perl will generate an error for a few character properties in Unicode when used in a regular expression.  The non-Unihan ones are listed below, with the reasons they are not accepted, perhaps with work-arounds.  The short names for the properties are listed enclosed in (parentheses). As described after the list, an installation can change the defaults and choose to accept any of these.  The list is machine generated based on the choices made for the installation that generated this document.<div class="spacer">
</div>
@bad_re_properties<div class="spacer">
</div>
An installation can choose to allow any of these to be matched by downloading the Unicode database from &lt;http://www.unicode.org/Public/&gt; to &quot;\$Config{privlib}&quot;/ <i>unicore/</i> in the Perl source tree, changing the controlling lists contained in the program &quot;\$Config{privlib}&quot;/ <i>unicore/mktables</i> and then re-compiling and installing. (&quot;\%Config&quot; is available from the Config module).</div>
<div class="section">
<h1>Other information in the Unicode data base</h1> The Unicode data base is delivered in two different formats.  The XML version is valid for more modern Unicode releases.  The other version is a collection of files.  The two are intended to give equivalent information.  Perl uses the older form; this allows you to recompile Perl to use early Unicode releases.<div class="spacer">
</div>
The only non-character property that Perl currently supports is Named Sequences, in which a sequence of code points is given a name and generally treated as a single entity.  (Perl supports these via the &quot;\\N{...}&quot; double-quotish construct, &quot;charnames::string_vianame(name)&quot; in charnames, and &quot; <i>namedseq()</i>&quot; in Unicode::UCD.<div class="spacer">
</div>
Below is a list of the files in the Unicode data base that Perl doesn't currently use, along with very brief descriptions of their purposes. Some of the names of the files have been shortened from those that Unicode uses, in order to allow them to be distinguishable from similarly named files on file systems for which only the first 8 characters of a name are significant.<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
@unused_files</div>
</div>
<div class="section">
<h1>SEE ALSO</h1> $unicode_reference_url<div class="spacer">
</div>
perlrecharclass<div class="spacer">
</div>
perlunicode<div class="spacer">
</div>
END<div class="spacer">
</div>
<br/>
    # And write it.  The 0 means no utf8.<br/>
    main::write([ $pod_directory, &quot;$pod_file.pod&quot; ], 0, \@OUT);<br/>
    return;<br/>
}<br/>
<div class="spacer">
</div>
sub make_Heavy () {<br/>
    # Create and write Heavy.pl, which passes info about the tables to<br/>
    # utf8_heavy.pl<div class="spacer">
</div>
<br/>
    # Stringify structures for output<br/>
    my $loose_property_name_of<br/>
                           = simple_dumper(\%loose_property_name_of, ' ' x 4);<br/>
    chomp $loose_property_name_of;<br/>
<br/>
    my $stricter_to_file_of = simple_dumper(\%stricter_to_file_of, ' ' x 4);<br/>
    chomp $stricter_to_file_of;<br/>
<br/>
    my $inline_definitions = simple_dumper(\@inline_definitions, &quot; &quot; x 4);<br/>
    chomp $inline_definitions;<br/>
<br/>
    my $loose_to_file_of = simple_dumper(\%loose_to_file_of, ' ' x 4);<br/>
    chomp $loose_to_file_of;<br/>
<br/>
    my $nv_floating_to_rational<br/>
                           = simple_dumper(\%nv_floating_to_rational, ' ' x 4);<br/>
    chomp $nv_floating_to_rational;<br/>
<br/>
    my $why_deprecated = simple_dumper(\%utf8::why_deprecated, ' ' x 4);<br/>
    chomp $why_deprecated;<br/>
<br/>
    # We set the key to the file when we associated files with tables, but we<br/>
    # couldn't do the same for the value then, as we might not have the file<br/>
    # for the alternate table figured out at that time.<br/>
    foreach my $cased (keys %caseless_equivalent_to) {<br/>
        my @path = $caseless_equivalent_to{$cased}-&gt;file_path;<br/>
        my $path;<br/>
        if ($path[0] eq &quot;#&quot;) {  # Pseudo-directory '#'<br/>
            $path = join '/', @path;<br/>
        }<br/>
        else {  # Gets rid of lib/<br/>
            $path = join '/', @path[1, -1];<br/>
        }<br/>
        $caseless_equivalent_to{$cased} = $path;<br/>
    }<br/>
    my $caseless_equivalent_to<br/>
                           = simple_dumper(\%caseless_equivalent_to, ' ' x 4);<br/>
    chomp $caseless_equivalent_to;<br/>
<br/>
    my $loose_property_to_file_of<br/>
                        = simple_dumper(\%loose_property_to_file_of, ' ' x 4);<br/>
    chomp $loose_property_to_file_of;<br/>
<br/>
    my $file_to_swash_name = simple_dumper(\%file_to_swash_name, ' ' x 4);<br/>
    chomp $file_to_swash_name;<br/>
<br/>
    my @heavy = &lt;&lt;END;<br/>
$HEADER<br/>
$INTERNAL_ONLY_HEADER<br/>
<div class="spacer">
</div>
# This file is for the use of utf8_heavy.pl and Unicode::UCD<div class="spacer">
</div>
# Maps Unicode (not Perl single-form extensions) property names in loose # standard form to their corresponding standard names \%utf8::loose_property_name_of = ( $loose_property_name_of );<div class="spacer">
</div>
# Gives the definitions (in the form of inversion lists) for those properties # whose definitions aren't kept in files \@utf8::inline_definitions = ( $inline_definitions );<div class="spacer">
</div>
# Maps property, table to file for those using stricter matching.  For paths # whose directory is '#', the file is in the form of a numeric index into # \@inline_definitions \%utf8::stricter_to_file_of = ( $stricter_to_file_of );<div class="spacer">
</div>
# Maps property, table to file for those using loose matching.  For paths # whose directory is '#', the file is in the form of a numeric index into # \@inline_definitions \%utf8::loose_to_file_of = ( $loose_to_file_of );<div class="spacer">
</div>
# Maps floating point to fractional form \%utf8::nv_floating_to_rational = ( $nv_floating_to_rational );<div class="spacer">
</div>
# If a floating point number doesn't have enough digits in it to get this # close to a fraction, it isn't considered to be that fraction even if all the # digits it does have match. \$utf8::max_floating_slop = $MAX_FLOATING_SLOP;<div class="spacer">
</div>
# Deprecated tables to generate a warning for.  The key is the file containing # the table, so as to avoid duplication, as many property names can map to the # file, but we only need one entry for all of them. \%utf8::why_deprecated = ( $why_deprecated );<div class="spacer">
</div>
# A few properties have different behavior under /i matching.  This maps # those to substitute files to use under /i. \%utf8::caseless_equivalent = ( $caseless_equivalent_to );<div class="spacer">
</div>
# Property names to mapping files \%utf8::loose_property_to_file_of = ( $loose_property_to_file_of );<div class="spacer">
</div>
# Files to the swash names within them. \%utf8::file_to_swash_name = ( $file_to_swash_name );<div class="spacer">
</div>
1; END<div class="spacer">
</div>
<br/>
    main::write(&quot;Heavy.pl&quot;, 0, \@heavy);  # The 0 means no utf8.<br/>
    return;<br/>
}<br/>
<div class="spacer">
</div>
sub make_Name_pm () {<br/>
    # Create and write Name.pm, which contains subroutines and data to use in<br/>
    # conjunction with Name.pl<div class="spacer">
</div>
<br/>
    # Maybe there's nothing to do.<br/>
    return unless $has_hangul_syllables || @code_points_ending_in_code_point;<br/>
<br/>
    my @name = &lt;&lt;END;<br/>
$HEADER<br/>
$INTERNAL_ONLY_HEADER<br/>
END<br/>
<br/>
    # Convert these structures to output format.<br/>
    my $code_points_ending_in_code_point =<br/>
        main::simple_dumper(\@code_points_ending_in_code_point,<br/>
                            ' ' x 8);<br/>
    my $names = main::simple_dumper(\%names_ending_in_code_point,<br/>
                                    ' ' x 8);<br/>
    my $loose_names = main::simple_dumper(\%loose_names_ending_in_code_point,<br/>
                                    ' ' x 8);<br/>
<br/>
    # Do the same with the Hangul names,<br/>
    my $jamo;<br/>
    my $jamo_l;<br/>
    my $jamo_v;<br/>
    my $jamo_t;<br/>
    my $jamo_re;<br/>
    if ($has_hangul_syllables) {<br/>
<br/>
        # Construct a regular expression of all the possible<br/>
        # combinations of the Hangul syllables.<br/>
        my @L_re;   # Leading consonants<br/>
        for my $i ($LBase .. $LBase + $LCount - 1) {<br/>
            push @L_re, $Jamo{$i}<br/>
        }<br/>
        my @V_re;   # Middle vowels<br/>
        for my $i ($VBase .. $VBase + $VCount - 1) {<br/>
            push @V_re, $Jamo{$i}<br/>
        }<br/>
        my @T_re;   # Trailing consonants<br/>
        for my $i ($TBase + 1 .. $TBase + $TCount - 1) {<br/>
            push @T_re, $Jamo{$i}<br/>
        }<br/>
<br/>
        # The whole re is made up of the L V T combination.<br/>
        $jamo_re = '('<br/>
                    . join ('|', sort @L_re)<br/>
                    . ')('<br/>
                    . join ('|', sort @V_re)<br/>
                    . ')('<br/>
                    . join ('|', sort @T_re)<br/>
                    . ')?';<br/>
<br/>
        # These hashes needed by the algorithm were generated<br/>
        # during reading of the Jamo.txt file<br/>
        $jamo = main::simple_dumper(\%Jamo, ' ' x 8);<br/>
        $jamo_l = main::simple_dumper(\%Jamo_L, ' ' x 8);<br/>
        $jamo_v = main::simple_dumper(\%Jamo_V, ' ' x 8);<br/>
        $jamo_t = main::simple_dumper(\%Jamo_T, ' ' x 8);<br/>
    }<br/>
<br/>
    push @name, &lt;&lt;END;<br/>
<div class="spacer">
</div>
package charnames;<div class="spacer">
</div>
# This module contains machine-generated tables and code for the # algorithmically-determinable Unicode character names.  The following # routines can be used to translate between name and code point and vice versa<div class="spacer">
</div>
{ # Closure<div class="spacer">
</div>
<br/>
    # Matches legal code point.  4-6 hex numbers, If there are 6, the first<br/>
    # two must be 10; if there are 5, the first must not be a 0.  Written this<br/>
    # way to decrease backtracking.  The first regex allows the code point to<br/>
    # be at the end of a word, but to work properly, the word shouldn't end<br/>
    # with a valid hex character.  The second one won't match a code point at<br/>
    # the end of a word, and doesn't have the run-on issue<br/>
    my \$run_on_code_point_re = qr/$run_on_code_point_re/;<br/>
    my \$code_point_re = qr/$code_point_re/;<br/>
<br/>
    # In the following hash, the keys are the bases of names which include<br/>
    # the code point in the name, like CJK UNIFIED IDEOGRAPH-4E01.  The value<br/>
    # of each key is another hash which is used to get the low and high ends<br/>
    # for each range of code points that apply to the name.<br/>
    my %names_ending_in_code_point = (<br/>
$names<br/>
    );<br/>
<br/>
    # The following hash is a copy of the previous one, except is for loose<br/>
    # matching, so each name has blanks and dashes squeezed out<br/>
    my %loose_names_ending_in_code_point = (<br/>
$loose_names<br/>
    );<br/>
<br/>
    # And the following array gives the inverse mapping from code points to<br/>
    # names.  Lowest code points are first<br/>
    my \@code_points_ending_in_code_point = (<br/>
$code_points_ending_in_code_point<br/>
    );<br/>
END<br/>
    # Earlier releases didn't have Jamos.  No sense outputting<br/>
    # them unless will be used.<br/>
    if ($has_hangul_syllables) {<br/>
        push @name, &lt;&lt;END;<br/>
<br/>
    # Convert from code point to Jamo short name for use in composing Hangul<br/>
    # syllable names<br/>
    my %Jamo = (<br/>
$jamo<br/>
    );<br/>
<br/>
    # Leading consonant (can be null)<br/>
    my %Jamo_L = (<br/>
$jamo_l<br/>
    );<br/>
<br/>
    # Vowel<br/>
    my %Jamo_V = (<br/>
$jamo_v<br/>
    );<br/>
<br/>
    # Optional trailing consonant<br/>
    my %Jamo_T = (<br/>
$jamo_t<br/>
    );<br/>
<br/>
    # Computed re that splits up a Hangul name into LVT or LV syllables<br/>
    my \$syllable_re = qr/$jamo_re/;<br/>
<br/>
    my \$HANGUL_SYLLABLE = &quot;HANGUL SYLLABLE &quot;;<br/>
    my \$loose_HANGUL_SYLLABLE = &quot;HANGULSYLLABLE&quot;;<br/>
<br/>
    # These constants names and values were taken from the Unicode standard,<br/>
    # version 5.1, section 3.12.  They are used in conjunction with Hangul<br/>
    # syllables<br/>
    my \$SBase = $SBase_string;<br/>
    my \$LBase = $LBase_string;<br/>
    my \$VBase = $VBase_string;<br/>
    my \$TBase = $TBase_string;<br/>
    my \$SCount = $SCount;<br/>
    my \$LCount = $LCount;<br/>
    my \$VCount = $VCount;<br/>
    my \$TCount = $TCount;<br/>
    my \$NCount = \$VCount * \$TCount;<br/>
END<br/>
    } # End of has Jamos<br/>
<br/>
    push @name, &lt;&lt; 'END';<br/>
<br/>
    sub name_to_code_point_special {<br/>
        my ($name, $loose) = @_;<br/>
<br/>
        # Returns undef if not one of the specially handled names; otherwise<br/>
        # returns the code point equivalent to the input name<br/>
        # $loose is non-zero if to use loose matching, 'name' in that case<br/>
        # must be input as upper case with all blanks and dashes squeezed out.<br/>
END<br/>
    if ($has_hangul_syllables) {<br/>
        push @name, &lt;&lt; 'END';<br/>
<br/>
        if ((! $loose &amp;&amp; $name =~ s/$HANGUL_SYLLABLE//)<br/>
            || ($loose &amp;&amp; $name =~ s/$loose_HANGUL_SYLLABLE//))<br/>
        {<br/>
            return if $name !~ qr/^$syllable_re$/;<br/>
            my $L = $Jamo_L{$1};<br/>
            my $V = $Jamo_V{$2};<br/>
            my $T = (defined $3) ? $Jamo_T{$3} : 0;<br/>
            return ($L * $VCount + $V) * $TCount + $T + $SBase;<br/>
        }<br/>
END<br/>
    }<br/>
    push @name, &lt;&lt; 'END';<br/>
<br/>
        # Name must end in 'code_point' for this to handle.<br/>
        return if (($loose &amp;&amp; $name !~ /^ (.*?) ($run_on_code_point_re) $/x)<br/>
                   || (! $loose &amp;&amp; $name !~ /^ (.*) ($code_point_re) $/x));<br/>
<br/>
        my $base = $1;<br/>
        my $code_point = CORE::hex $2;<br/>
        my $names_ref;<br/>
<br/>
        if ($loose) {<br/>
            $names_ref = \%loose_names_ending_in_code_point;<br/>
        }<br/>
        else {<br/>
            return if $base !~ s/-$//;<br/>
            $names_ref = \%names_ending_in_code_point;<br/>
        }<br/>
<br/>
        # Name must be one of the ones which has the code point in it.<br/>
        return if ! $names_ref-&gt;{$base};<br/>
<br/>
        # Look through the list of ranges that apply to this name to see if<br/>
        # the code point is in one of them.<br/>
        for (my $i = 0; $i &lt; scalar @{$names_ref-&gt;{$base}{'low'}}; $i++) {<br/>
            return if $names_ref-&gt;{$base}{'low'}-&gt;[$i] &gt; $code_point;<br/>
            next if $names_ref-&gt;{$base}{'high'}-&gt;[$i] &lt; $code_point;<br/>
<br/>
            # Here, the code point is in the range.<br/>
            return $code_point;<br/>
        }<br/>
<br/>
        # Here, looked like the name had a code point number in it, but<br/>
        # did not match one of the valid ones.<br/>
        return;<br/>
    }<br/>
<br/>
    sub code_point_to_name_special {<br/>
        my $code_point = shift;<br/>
<br/>
        # Returns the name of a code point if algorithmically determinable;<br/>
        # undef if not<br/>
END<br/>
    if ($has_hangul_syllables) {<br/>
        push @name, &lt;&lt; 'END';<br/>
<br/>
        # If in the Hangul range, calculate the name based on Unicode's<br/>
        # algorithm<br/>
        if ($code_point &gt;= $SBase &amp;&amp; $code_point &lt;= $SBase + $SCount -1) {<br/>
            use integer;<br/>
            my $SIndex = $code_point - $SBase;<br/>
            my $L = $LBase + $SIndex / $NCount;<br/>
            my $V = $VBase + ($SIndex % $NCount) / $TCount;<br/>
            my $T = $TBase + $SIndex % $TCount;<br/>
            $name = &quot;$HANGUL_SYLLABLE$Jamo{$L}$Jamo{$V}&quot;;<br/>
            $name .= $Jamo{$T} if $T != $TBase;<br/>
            return $name;<br/>
        }<br/>
END<br/>
    }<br/>
    push @name, &lt;&lt; 'END';<br/>
<br/>
        # Look through list of these code points for one in range.<br/>
        foreach my $hash (@code_points_ending_in_code_point) {<br/>
            return if $code_point &lt; $hash-&gt;{'low'};<br/>
            if ($code_point &lt;= $hash-&gt;{'high'}) {<br/>
                return sprintf(&quot;%s-%04X&quot;, $hash-&gt;{'name'}, $code_point);<br/>
            }<br/>
        }<br/>
        return;            # None found<br/>
    }<br/>
} # End closure<br/>
<div class="spacer">
</div>
1; END<div class="spacer">
</div>
<br/>
    main::write(&quot;Name.pm&quot;, 0, \@name);  # The 0 means no utf8.<br/>
    return;<br/>
}<br/>
<div class="spacer">
</div>
sub make_UCD () {<br/>
    # Create and write UCD.pl, which passes info about the tables to<br/>
    # Unicode::UCD<div class="spacer">
</div>
<br/>
    # Create a mapping from each alias of Perl single-form extensions to all<br/>
    # its equivalent aliases, for quick look-up.<br/>
    my %perlprop_to_aliases;<br/>
    foreach my $table ($perl-&gt;tables) {<br/>
<br/>
        # First create the list of the aliases of each extension<br/>
        my @aliases_list;    # List of legal aliases for this extension<br/>
<br/>
        my $table_name = $table-&gt;name;<br/>
        my $standard_table_name = standardize($table_name);<br/>
        my $table_full_name = $table-&gt;full_name;<br/>
        my $standard_table_full_name = standardize($table_full_name);<br/>
<br/>
        # Make sure that the list has both the short and full names<br/>
        push @aliases_list, $table_name, $table_full_name;<br/>
<br/>
        my $found_ucd = 0;  # ? Did we actually get an alias that should be<br/>
                            # output for this table<br/>
<br/>
        # Go through all the aliases (including the two just added), and add<br/>
        # any new unique ones to the list<br/>
        foreach my $alias ($table-&gt;aliases) {<br/>
<br/>
            # Skip non-legal names<br/>
            next unless $alias-&gt;ok_as_filename;<br/>
            next unless $alias-&gt;ucd;<br/>
<br/>
            $found_ucd = 1;     # have at least one legal name<br/>
<br/>
            my $name = $alias-&gt;name;<br/>
            my $standard = standardize($name);<br/>
<br/>
            # Don't repeat a name that is equivalent to one already on the<br/>
            # list<br/>
            next if $standard eq $standard_table_name;<br/>
            next if $standard eq $standard_table_full_name;<br/>
<br/>
            push @aliases_list, $name;<br/>
        }<br/>
<br/>
        # If there were no legal names, don't output anything.<br/>
        next unless $found_ucd;<br/>
<br/>
        # To conserve memory in the program reading these in, omit full names<br/>
        # that are identical to the short name, when those are the only two<br/>
        # aliases for the property.<br/>
        if (@aliases_list == 2 &amp;&amp; $aliases_list[0] eq $aliases_list[1]) {<br/>
            pop @aliases_list;<br/>
        }<br/>
<br/>
        # Here, @aliases_list is the list of all the aliases that this<br/>
        # extension legally has.  Now can create a map to it from each legal<br/>
        # standardized alias<br/>
        foreach my $alias ($table-&gt;aliases) {<br/>
            next unless $alias-&gt;ucd;<br/>
            next unless $alias-&gt;ok_as_filename;<br/>
            push @{$perlprop_to_aliases{standardize($alias-&gt;name)}},<br/>
                 @aliases_list;<br/>
        }<br/>
    }<br/>
<br/>
    # Make a list of all combinations of properties/values that are suppressed.<br/>
    my @suppressed;<br/>
    if (! $debug_skip) {    # This tends to fail in this debug mode<br/>
        foreach my $property_name (keys %why_suppressed) {<br/>
<br/>
            # Just the value<br/>
            my $value_name = $1 if $property_name =~ s/ = ( .* ) //x;<br/>
<br/>
            # The hash may contain properties not in this release of Unicode<br/>
            next unless defined (my $property = property_ref($property_name));<br/>
<br/>
            # Find all combinations<br/>
            foreach my $prop_alias ($property-&gt;aliases) {<br/>
                my $prop_alias_name = standardize($prop_alias-&gt;name);<br/>
<br/>
                # If no =value, there's just one combination possibe for this<br/>
                if (! $value_name) {<br/>
<br/>
                    # The property may be suppressed, but there may be a proxy<br/>
                    # for it, so it shouldn't be listed as suppressed<br/>
                    next if $prop_alias-&gt;ucd;<br/>
                    push @suppressed, $prop_alias_name;<br/>
                }<br/>
                else {  # Otherwise<br/>
                    foreach my $value_alias<br/>
                                    ($property-&gt;table($value_name)-&gt;aliases)<br/>
                    {<br/>
                        next if $value_alias-&gt;ucd;<br/>
<br/>
                        push @suppressed, &quot;$prop_alias_name=&quot;<br/>
                                        .  standardize($value_alias-&gt;name);<br/>
                    }<br/>
                }<br/>
            }<br/>
        }<br/>
    }<br/>
    @suppressed = sort @suppressed; # So doesn't change between runs of this<br/>
                                    # program<br/>
<br/>
    # Convert the structure below (designed for Name.pm) to a form that UCD<br/>
    # wants, so it doesn't have to modify it at all; i.e. so that it includes<br/>
    # an element for the Hangul syllables in the appropriate place, and<br/>
    # otherwise changes the name to include the &quot;-&lt;code point&gt;&quot; suffix.<br/>
    my @algorithm_names;<br/>
    my $done_hangul = 0;<br/>
<br/>
    # Copy it linearly.<br/>
    for my $i (0 .. @code_points_ending_in_code_point - 1) {<br/>
<br/>
        # Insert the hanguls in the correct place.<br/>
        if (! $done_hangul<br/>
            &amp;&amp; $code_points_ending_in_code_point[$i]-&gt;{'low'} &gt; $SBase)<br/>
        {<br/>
            $done_hangul = 1;<br/>
            push @algorithm_names, { low =&gt; $SBase,<br/>
                                     high =&gt; $SBase + $SCount - 1,<br/>
                                     name =&gt; '&lt;hangul syllable&gt;',<br/>
                                    };<br/>
        }<br/>
<br/>
        # Copy the current entry, modified.<br/>
        push @algorithm_names, {<br/>
            low =&gt; $code_points_ending_in_code_point[$i]-&gt;{'low'},<br/>
            high =&gt; $code_points_ending_in_code_point[$i]-&gt;{'high'},<br/>
            name =&gt;<br/>
               &quot;$code_points_ending_in_code_point[$i]-&gt;{'name'}-&lt;code point&gt;&quot;,<br/>
        };<br/>
    }<br/>
<br/>
    # Serialize these structures for output.<br/>
    my $loose_to_standard_value<br/>
                          = simple_dumper(\%loose_to_standard_value, ' ' x 4);<br/>
    chomp $loose_to_standard_value;<br/>
<br/>
    my $string_property_loose_to_name<br/>
                    = simple_dumper(\%string_property_loose_to_name, ' ' x 4);<br/>
    chomp $string_property_loose_to_name;<br/>
<br/>
    my $perlprop_to_aliases = simple_dumper(\%perlprop_to_aliases, ' ' x 4);<br/>
    chomp $perlprop_to_aliases;<br/>
<br/>
    my $prop_aliases = simple_dumper(\%prop_aliases, ' ' x 4);<br/>
    chomp $prop_aliases;<br/>
<br/>
    my $prop_value_aliases = simple_dumper(\%prop_value_aliases, ' ' x 4);<br/>
    chomp $prop_value_aliases;<br/>
<br/>
    my $suppressed = (@suppressed) ? simple_dumper(\@suppressed, ' ' x 4) : &quot;&quot;;<br/>
    chomp $suppressed;<br/>
<br/>
    my $algorithm_names = simple_dumper(\@algorithm_names, ' ' x 4);<br/>
    chomp $algorithm_names;<br/>
<br/>
    my $ambiguous_names = simple_dumper(\%ambiguous_names, ' ' x 4);<br/>
    chomp $ambiguous_names;<br/>
<br/>
    my $loose_defaults = simple_dumper(\%loose_defaults, ' ' x 4);<br/>
    chomp $loose_defaults;<br/>
<br/>
    my @ucd = &lt;&lt;END;<br/>
$HEADER<br/>
$INTERNAL_ONLY_HEADER<br/>
<div class="spacer">
</div>
# This file is for the use of Unicode::UCD<div class="spacer">
</div>
# Highest legal Unicode code point \$Unicode::UCD::MAX_UNICODE_CODEPOINT = 0x$MAX_UNICODE_CODEPOINT_STRING;<div class="spacer">
</div>
# Hangul syllables \$Unicode::UCD::HANGUL_BEGIN = $SBase_string; \$Unicode::UCD::HANGUL_COUNT = $SCount;<div class="spacer">
</div>
# Keys are all the possible &quot;prop=value&quot; combinations, in loose form; values # are the standard loose name for the 'value' part of the key \%Unicode::UCD::loose_to_standard_value = ( $loose_to_standard_value );<div class="spacer">
</div>
# String property loose names to standard loose name \%Unicode::UCD::string_property_loose_to_name = ( $string_property_loose_to_name );<div class="spacer">
</div>
# Keys are Perl extensions in loose form; values are each one's list of # aliases \%Unicode::UCD::loose_perlprop_to_name = ( $perlprop_to_aliases );<div class="spacer">
</div>
# Keys are standard property name; values are each one's aliases \%Unicode::UCD::prop_aliases = ( $prop_aliases );<div class="spacer">
</div>
# Keys of top level are standard property name; values are keys to another # hash,  Each one is one of the property's values, in standard form.  The # values are that prop-val's aliases.  If only one specified, the short and # long alias are identical. \%Unicode::UCD::prop_value_aliases = ( $prop_value_aliases );<div class="spacer">
</div>
# Ordered (by code point ordinal) list of the ranges of code points whose # names are algorithmically determined.  Each range entry is an anonymous hash # of the start and end points and a template for the names within it. \@Unicode::UCD::algorithmic_named_code_points = ( $algorithm_names );<div class="spacer">
</div>
# The properties that as-is have two meanings, and which must be disambiguated \%Unicode::UCD::ambiguous_names = ( $ambiguous_names );<div class="spacer">
</div>
# Keys are the prop-val combinations which are the default values for the # given property, expressed in standard loose form \%Unicode::UCD::loose_defaults = ( $loose_defaults );<div class="spacer">
</div>
# All combinations of names that are suppressed. # This is actually for UCD.t, so it knows which properties shouldn't have # entries.  If it got any bigger, would probably want to put it in its own # file to use memory only when it was needed, in testing. \@Unicode::UCD::suppressed_properties = ( $suppressed );<div class="spacer">
</div>
1; END<div class="spacer">
</div>
<br/>
    main::write(&quot;UCD.pl&quot;, 0, \@ucd);  # The 0 means no utf8.<br/>
    return;<br/>
}<br/>
<div class="spacer">
</div>
sub <i>write_all_tables()</i> {<br/>
    # Write out all the tables generated by this program to files, as well as<br/>
    # the supporting data structures, pod file, and .t file.<div class="spacer">
</div>
<br/>
    my @writables;              # List of tables that actually get written<br/>
    my %match_tables_to_write;  # Used to collapse identical match tables<br/>
                                # into one file.  Each key is a hash function<br/>
                                # result to partition tables into buckets.<br/>
                                # Each value is an array of the tables that<br/>
                                # fit in the bucket.<br/>
<br/>
    # For each property ...<br/>
    # (sort so that if there is an immutable file name, it has precedence, so<br/>
    # some other property can't come in and take over its file name.  (We<br/>
    # don't care if both defined, as they had better be different anyway.)<br/>
    # We also sort by the property's name.  This is just for repeatability of<br/>
    # the outputs between runs of this program, but does not affect<br/>
    # correctness.<br/>
    PROPERTY:<br/>
    foreach my $property (sort { return -1 if defined $a-&gt;file;<br/>
                                 return 1 if defined $b-&gt;file;<br/>
                                 return $a-&gt;name cmp $b-&gt;name;<br/>
                                }<br/>
                                  property_ref('*'))<br/>
    {<br/>
        my $type = $property-&gt;type;<br/>
<br/>
        # And for each table for that property, starting with the mapping<br/>
        # table for it ...<br/>
        TABLE:<br/>
        foreach my $table($property,<br/>
<br/>
                        # and all the match tables for it (if any), sorted so<br/>
                        # the ones with the shortest associated file name come<br/>
                        # first.  The length sorting prevents problems of a<br/>
                        # longer file taking a name that might have to be used<br/>
                        # by a shorter one.  The alphabetic sorting prevents<br/>
                        # differences between releases<br/>
                        sort {  my $ext_a = $a-&gt;external_name;<br/>
                                return 1 if ! defined $ext_a;<br/>
                                my $ext_b = $b-&gt;external_name;<br/>
                                return -1 if ! defined $ext_b;<br/>
<br/>
                                # But return the non-complement table before<br/>
                                # the complement one, as the latter is defined<br/>
                                # in terms of the former, and needs to have<br/>
                                # the information for the former available.<br/>
                                return 1 if $a-&gt;complement != 0;<br/>
                                return -1 if $b-&gt;complement != 0;<br/>
<br/>
                                # Similarly, return a subservient table after<br/>
                                # a leader<br/>
                                return 1 if $a-&gt;leader != $a;<br/>
                                return -1 if $b-&gt;leader != $b;<br/>
<br/>
                                my $cmp = length $ext_a &lt;=&gt; length $ext_b;<br/>
<br/>
                                # Return result if lengths not equal<br/>
                                return $cmp if $cmp;<br/>
<br/>
                                # Alphabetic if lengths equal<br/>
                                return $ext_a cmp $ext_b<br/>
                        } $property-&gt;tables<br/>
                    )<br/>
        {<br/>
<br/>
            # Here we have a table associated with a property.  It could be<br/>
            # the map table (done first for each property), or one of the<br/>
            # other tables.  Determine which type.<br/>
            my $is_property = $table-&gt;isa('Property');<br/>
<br/>
            my $name = $table-&gt;name;<br/>
            my $complete_name = $table-&gt;complete_name;<br/>
<br/>
            # See if should suppress the table if is empty, but warn if it<br/>
            # contains something.<br/>
            my $suppress_if_empty_warn_if_not<br/>
                    = $why_suppress_if_empty_warn_if_not{$complete_name} || 0;<br/>
<br/>
            # Calculate if this table should have any code points associated<br/>
            # with it or not.<br/>
            my $expected_empty =<br/>
<br/>
                # $perl should be empty, as well as properties that we just<br/>
                # don't do anything with<br/>
                ($is_property<br/>
                    &amp;&amp; ($table == $perl<br/>
                        || grep { $complete_name eq $_ }<br/>
                                                    @unimplemented_properties<br/>
                    )<br/>
                )<br/>
<br/>
                # Match tables in properties we skipped populating should be<br/>
                # empty<br/>
                || (! $is_property &amp;&amp; ! $property-&gt;to_create_match_tables)<br/>
<br/>
                # Tables and properties that are expected to have no code<br/>
                # points should be empty<br/>
                || $suppress_if_empty_warn_if_not<br/>
            ;<br/>
<br/>
            # Set a boolean if this table is the complement of an empty binary<br/>
            # table<br/>
            my $is_complement_of_empty_binary =<br/>
                $type == $BINARY &amp;&amp;<br/>
                (($table == $property-&gt;table('Y')<br/>
                    &amp;&amp; $property-&gt;table('N')-&gt;is_empty)<br/>
                || ($table == $property-&gt;table('N')<br/>
                    &amp;&amp; $property-&gt;table('Y')-&gt;is_empty));<br/>
<br/>
            if ($table-&gt;is_empty) {<br/>
<br/>
                if ($suppress_if_empty_warn_if_not) {<br/>
                    $table-&gt;set_fate($SUPPRESSED,<br/>
                                     $suppress_if_empty_warn_if_not);<br/>
                }<br/>
<br/>
                # Suppress (by skipping them) expected empty tables.<br/>
                next TABLE if $expected_empty;<br/>
<br/>
                # And setup to later output a warning for those that aren't<br/>
                # known to be allowed to be empty.  Don't do the warning if<br/>
                # this table is a child of another one to avoid duplicating<br/>
                # the warning that should come from the parent one.<br/>
                if (($table == $property || $table-&gt;parent == $table)<br/>
                    &amp;&amp; $table-&gt;fate != $SUPPRESSED<br/>
                    &amp;&amp; $table-&gt;fate != $MAP_PROXIED<br/>
                    &amp;&amp; ! grep { $complete_name =~ /^$_$/ }<br/>
                                                    @tables_that_may_be_empty)<br/>
                {<br/>
                    push @unhandled_properties, &quot;$table&quot;;<br/>
                }<br/>
<br/>
                # The old way of expressing an empty match list was to<br/>
                # complement the list that matches everything.  The new way is<br/>
                # to create an empty inversion list, but this doesn't work for<br/>
                # annotating, so use the old way then.<br/>
                $table-&gt;set_complement($All) if $annotate<br/>
                                                &amp;&amp; $table != $property;<br/>
            }<br/>
            elsif ($expected_empty) {<br/>
                my $because = &quot;&quot;;<br/>
                if ($suppress_if_empty_warn_if_not) {<br/>
                    $because = &quot; because $suppress_if_empty_warn_if_not&quot;;<br/>
                }<br/>
<br/>
                Carp::my_carp(&quot;Not expecting property $table$because.  Generating file for it anyway.&quot;);<br/>
            }<br/>
<br/>
            # Some tables should match everything<br/>
            my $expected_full =<br/>
                ($table-&gt;fate == $SUPPRESSED)<br/>
                ? 0<br/>
                : ($is_property)<br/>
                  ? # All these types of map tables will be full because<br/>
                    # they will have been populated with defaults<br/>
                    ($type == $ENUM || $type == $FORCED_BINARY)<br/>
<br/>
                  : # A match table should match everything if its method<br/>
                    # shows it should<br/>
                    ($table-&gt;matches_all<br/>
<br/>
                    # The complement of an empty binary table will match<br/>
                    # everything<br/>
                    || $is_complement_of_empty_binary<br/>
                    )<br/>
            ;<br/>
<br/>
            my $count = $table-&gt;count;<br/>
            if ($expected_full) {<br/>
                if ($count != $MAX_WORKING_CODEPOINTS) {<br/>
                    Carp::my_carp(&quot;$table matches only &quot;<br/>
                    . clarify_number($count)<br/>
                    . &quot; Unicode code points but should match &quot;<br/>
                    . clarify_number($MAX_WORKING_CODEPOINTS)<br/>
                    . &quot; (off by &quot;<br/>
                    .  clarify_number(abs($MAX_WORKING_CODEPOINTS - $count))<br/>
                    . &quot;).  Proceeding anyway.&quot;);<br/>
                }<br/>
<br/>
                # Here is expected to be full.  If it is because it is the<br/>
                # complement of an (empty) binary table that is to be<br/>
                # suppressed, then suppress this one as well.<br/>
                if ($is_complement_of_empty_binary) {<br/>
                    my $opposing_name = ($name eq 'Y') ? 'N' : 'Y';<br/>
                    my $opposing = $property-&gt;table($opposing_name);<br/>
                    my $opposing_status = $opposing-&gt;status;<br/>
                    if ($opposing_status) {<br/>
                        $table-&gt;set_status($opposing_status,<br/>
                                           $opposing-&gt;status_info);<br/>
                    }<br/>
                }<br/>
            }<br/>
            elsif ($count == $MAX_UNICODE_CODEPOINTS<br/>
                   &amp;&amp; $name ne &quot;Any&quot;<br/>
                   &amp;&amp; ($table == $property || $table-&gt;leader == $table)<br/>
                   &amp;&amp; $table-&gt;property-&gt;status ne $NORMAL)<br/>
            {<br/>
                    Carp::my_carp(&quot;$table unexpectedly matches all Unicode code points.  Proceeding anyway.&quot;);<br/>
            }<br/>
<br/>
            if ($table-&gt;fate &gt;= $SUPPRESSED) {<br/>
                if (! $is_property) {<br/>
                    my @children = $table-&gt;children;<br/>
                    foreach my $child (@children) {<br/>
                        if ($child-&gt;fate &lt; $SUPPRESSED) {<br/>
                            Carp::my_carp_bug(&quot;'$table' is suppressed and has a child '$child' which isn't&quot;);<br/>
                        }<br/>
                    }<br/>
                }<br/>
                next TABLE;<br/>
<br/>
            }<br/>
<br/>
            if (! $is_property) {<br/>
<br/>
                make_ucd_table_pod_entries($table) if $table-&gt;property == $perl;<br/>
<br/>
                # Several things need to be done just once for each related<br/>
                # group of match tables.  Do them on the parent.<br/>
                if ($table-&gt;parent == $table) {<br/>
<br/>
                    # Add an entry in the pod file for the table; it also does<br/>
                    # the children.<br/>
                    make_re_pod_entries($table) if defined $pod_directory;<br/>
<br/>
                    # See if the the table matches identical code points with<br/>
                    # something that has already been output.  In that case,<br/>
                    # no need to have two files with the same code points in<br/>
                    # them.  We use the table's hash() method to store these<br/>
                    # in buckets, so that it is quite likely that if two<br/>
                    # tables are in the same bucket they will be identical, so<br/>
                    # don't have to compare tables frequently.  The tables<br/>
                    # have to have the same status to share a file, so add<br/>
                    # this to the bucket hash.  (The reason for this latter is<br/>
                    # that Heavy.pl associates a status with a file.)<br/>
                    # We don't check tables that are inverses of others, as it<br/>
                    # would lead to some coding complications, and checking<br/>
                    # all the regular ones should find everything.<br/>
                    if ($table-&gt;complement == 0) {<br/>
                        my $hash = $table-&gt;hash . ';' . $table-&gt;status;<br/>
<br/>
                        # Look at each table that is in the same bucket as<br/>
                        # this one would be.<br/>
                        foreach my $comparison<br/>
                                            (@{$match_tables_to_write{$hash}})<br/>
                        {<br/>
                            if ($table-&gt;matches_identically_to($comparison)) {<br/>
                                $table-&gt;set_equivalent_to($comparison,<br/>
                                                                Related =&gt; 0);<br/>
                                next TABLE;<br/>
                            }<br/>
                        }<br/>
<br/>
                        # Here, not equivalent, add this table to the bucket.<br/>
                        push @{$match_tables_to_write{$hash}}, $table;<br/>
                    }<br/>
                }<br/>
            }<br/>
            else {<br/>
<br/>
                # Here is the property itself.<br/>
                # Don't write out or make references to the $perl property<br/>
                next if $table == $perl;<br/>
<br/>
                make_ucd_table_pod_entries($table);<br/>
<br/>
                # There is a mapping stored of the various synonyms to the<br/>
                # standardized name of the property for utf8_heavy.pl.<br/>
                # Also, the pod file contains entries of the form:<br/>
                # \p{alias: *}         \p{full: *}<br/>
                # rather than show every possible combination of things.<br/>
<br/>
                my @property_aliases = $property-&gt;aliases;<br/>
<br/>
                my $full_property_name = $property-&gt;full_name;<br/>
                my $property_name = $property-&gt;name;<br/>
                my $standard_property_name = standardize($property_name);<br/>
                my $standard_property_full_name<br/>
                                        = standardize($full_property_name);<br/>
<br/>
                # We also create for Unicode::UCD a list of aliases for<br/>
                # the property.  The list starts with the property name;<br/>
                # then its full name.  Legacy properties are not listed in<br/>
                # Unicode::UCD.<br/>
                my @property_list;<br/>
                my @standard_list;<br/>
                if ( $property-&gt;fate &lt;= $MAP_PROXIED) {<br/>
                    @property_list = ($property_name, $full_property_name);<br/>
                    @standard_list = ($standard_property_name,<br/>
                                        $standard_property_full_name);<br/>
                }<br/>
<br/>
                # For each synonym ...<br/>
                for my $i (0 .. @property_aliases - 1)  {<br/>
                    my $alias = $property_aliases[$i];<br/>
                    my $alias_name = $alias-&gt;name;<br/>
                    my $alias_standard = standardize($alias_name);<br/>
<br/>
<br/>
                    # Add other aliases to the list of property aliases<br/>
                    if ($property-&gt;fate &lt;= $MAP_PROXIED<br/>
                        &amp;&amp; ! grep { $alias_standard eq $_ } @standard_list)<br/>
                    {<br/>
                        push @property_list, $alias_name;<br/>
                        push @standard_list, $alias_standard;<br/>
                    }<br/>
<br/>
                    # For utf8_heavy, set the mapping of the alias to the<br/>
                    # property<br/>
                    if ($type == $STRING) {<br/>
                        if ($property-&gt;fate &lt;= $MAP_PROXIED) {<br/>
                            $string_property_loose_to_name{$alias_standard}<br/>
                                            = $standard_property_name;<br/>
                        }<br/>
                    }<br/>
                    else {<br/>
                        if (exists ($loose_property_name_of{$alias_standard}))<br/>
                        {<br/>
                            Carp::my_carp(&quot;There already is a property with the same standard name as $alias_name: $loose_property_name_of{$alias_standard}.  Old name is retained&quot;);<br/>
                        }<br/>
                        else {<br/>
                            $loose_property_name_of{$alias_standard}<br/>
                                                = $standard_property_name;<br/>
                        }<br/>
<br/>
                        # Now for the re pod entry for this alias.  Skip if not<br/>
                        # outputting a pod; skip the first one, which is the<br/>
                        # full name so won't have an entry like: '\p{full: *}<br/>
                        # \p{full: *}', and skip if don't want an entry for<br/>
                        # this one.<br/>
                        next if $i == 0<br/>
                                || ! defined $pod_directory<br/>
                                || ! $alias-&gt;make_re_pod_entry;<br/>
<br/>
                        my $rhs = &quot;\\p{$full_property_name: *}&quot;;<br/>
                        if ($property != $perl &amp;&amp; $table-&gt;perl_extension) {<br/>
                            $rhs .= ' (Perl extension)';<br/>
                        }<br/>
                        push @match_properties,<br/>
                            format_pod_line($indent_info_column,<br/>
                                        '\p{' . $alias-&gt;name . ': *}',<br/>
                                        $rhs,<br/>
                                        $alias-&gt;status);<br/>
                    }<br/>
                }<br/>
<br/>
                # The list of all possible names is attached to each alias, so<br/>
                # lookup is easy<br/>
                if (@property_list) {<br/>
                    push @{$prop_aliases{$standard_list[0]}}, @property_list;<br/>
                }<br/>
<br/>
                if ($property-&gt;fate &lt;= $MAP_PROXIED) {<br/>
<br/>
                    # Similarly, we create for Unicode::UCD a list of<br/>
                    # property-value aliases.<br/>
<br/>
                    my $property_full_name = $property-&gt;full_name;<br/>
<br/>
                    # Look at each table in the property...<br/>
                    foreach my $table ($property-&gt;tables) {<br/>
                        my @values_list;<br/>
                        my $table_full_name = $table-&gt;full_name;<br/>
                        my $standard_table_full_name<br/>
                                              = standardize($table_full_name);<br/>
                        my $table_name = $table-&gt;name;<br/>
                        my $standard_table_name = standardize($table_name);<br/>
<br/>
                        # The list starts with the table name and its full<br/>
                        # name.<br/>
                        push @values_list, $table_name, $table_full_name;<br/>
<br/>
                        # We add to the table each unique alias that isn't<br/>
                        # discouraged from use.<br/>
                        foreach my $alias ($table-&gt;aliases) {<br/>
                            next if $alias-&gt;status<br/>
                                 &amp;&amp; $alias-&gt;status eq $DISCOURAGED;<br/>
                            my $name = $alias-&gt;name;<br/>
                            my $standard = standardize($name);<br/>
                            next if $standard eq $standard_table_name;<br/>
                            next if $standard eq $standard_table_full_name;<br/>
                            push @values_list, $name;<br/>
                        }<br/>
<br/>
                        # Here @values_list is a list of all the aliases for<br/>
                        # the table.  That is, all the property-values given<br/>
                        # by this table.  By agreement with Unicode::UCD,<br/>
                        # if the name and full name are identical, and there<br/>
                        # are no other names, drop the duplcate entry to save<br/>
                        # memory.<br/>
                        if (@values_list == 2<br/>
                            &amp;&amp; $values_list[0] eq $values_list[1])<br/>
                        {<br/>
                            pop @values_list<br/>
                        }<br/>
<br/>
                        # To save memory, unlike the similar list for property<br/>
                        # aliases above, only the standard forms hve the list.<br/>
                        # This forces an extra step of converting from input<br/>
                        # name to standard name, but the savings are<br/>
                        # considerable.  (There is only marginal savings if we<br/>
                        # did this with the property aliases.)<br/>
                        push @{$prop_value_aliases{$standard_property_name}{$standard_table_name}}, @values_list;<br/>
                    }<br/>
                }<br/>
<br/>
                # Don't write out a mapping file if not desired.<br/>
                next if ! $property-&gt;to_output_map;<br/>
            }<br/>
<br/>
            # Here, we know we want to write out the table, but don't do it<br/>
            # yet because there may be other tables that come along and will<br/>
            # want to share the file, and the file's comments will change to<br/>
            # mention them.  So save for later.<br/>
            push @writables, $table;<br/>
<br/>
        } # End of looping through the property and all its tables.<br/>
    } # End of looping through all properties.<br/>
<br/>
    # Now have all the tables that will have files written for them.  Do it.<br/>
    foreach my $table (@writables) {<br/>
        my @directory;<br/>
        my $filename;<br/>
        my $property = $table-&gt;property;<br/>
        my $is_property = ($table == $property);<br/>
<br/>
        # For very short tables, instead of writing them out to actual files,<br/>
        # we in-line their inversion list definitions into Heavy.pl.  The<br/>
        # definition replaces the file name, and the special pseudo-directory<br/>
        # '#' is used to signal this.  This significantly cuts down the number<br/>
        # of files written at little extra cost to the hashes in Heavy.pl.<br/>
        # And it means, no run-time files to read to get the definitions.<br/>
        if (! $is_property<br/>
            &amp;&amp; ! $annotate  # For annotation, we want to explicitly show<br/>
                            # everything, so keep in files<br/>
            &amp;&amp; $table-&gt;ranges &lt;= 3)<br/>
        {<br/>
            my @ranges = $table-&gt;ranges;<br/>
            my $count = @ranges;<br/>
            if ($count == 0) {  # 0th index reserved for 0-length lists<br/>
                $filename = 0;<br/>
            }<br/>
            elsif ($table-&gt;leader != $table) {<br/>
<br/>
                # Here, is a table that is equivalent to another; code<br/>
                # in register_file_for_name() causes its leader's definition<br/>
                # to be used<br/>
<br/>
                next;<br/>
            }<br/>
            else {  # No equivalent table so far.<br/>
<br/>
                # Build up its definition range-by-range.<br/>
                my $definition = &quot;&quot;;<br/>
                while (defined (my $range = shift @ranges)) {<br/>
                    my $end = $range-&gt;end;<br/>
                    if ($end &lt; $MAX_WORKING_CODEPOINT) {<br/>
                        $count++;<br/>
                        $end = &quot;\n&quot; . ($end + 1);<br/>
                    }<br/>
                    else {  # Extends to infinity, hence no 'end'<br/>
                        $end = &quot;&quot;;<br/>
                    }<br/>
                    $definition .= &quot;\n&quot; . $range-&gt;start . $end;<br/>
                }<br/>
                $definition = &quot;V$count&quot; . $definition;<br/>
                $filename = @inline_definitions;<br/>
                push @inline_definitions, $definition;<br/>
            }<br/>
            @directory = &quot;#&quot;;<br/>
            register_file_for_name($table, \@directory, $filename);<br/>
            next;<br/>
        }<br/>
<br/>
        if (! $is_property) {<br/>
            # Match tables for the property go in lib/$subdirectory, which is<br/>
            # the property's name.  Don't use the standard file name for this,<br/>
            # as may get an unfamiliar alias<br/>
            @directory = ($matches_directory, $property-&gt;external_name);<br/>
        }<br/>
        else {<br/>
<br/>
            @directory = $table-&gt;directory;<br/>
            $filename = $table-&gt;file;<br/>
        }<br/>
<br/>
        # Use specified filename if available, or default to property's<br/>
        # shortest name.  We need an 8.3 safe filename (which means &quot;an 8<br/>
        # safe&quot; filename, since after the dot is only 'pl', which is &lt; 3)<br/>
        # The 2nd parameter is if the filename shouldn't be changed, and<br/>
        # it shouldn't iff there is a hard-coded name for this table.<br/>
        $filename = construct_filename(<br/>
                                $filename || $table-&gt;external_name,<br/>
                                ! $filename,    # mutable if no filename<br/>
                                \@directory);<br/>
<br/>
        register_file_for_name($table, \@directory, $filename);<br/>
<br/>
        # Only need to write one file when shared by more than one<br/>
        # property<br/>
        next if ! $is_property<br/>
                &amp;&amp; ($table-&gt;leader != $table || $table-&gt;complement != 0);<br/>
<br/>
        # Construct a nice comment to add to the file<br/>
        $table-&gt;set_final_comment;<br/>
<br/>
        $table-&gt;write;<br/>
    }<br/>
<br/>
<br/>
    # Write out the pod file<br/>
    make_pod;<br/>
<br/>
    # And Heavy.pl, Name.pm, UCD.pl<br/>
    make_Heavy;<br/>
    make_Name_pm;<br/>
    make_UCD;<br/>
<br/>
    make_property_test_script() if $make_test_script;<br/>
    make_normalization_test_script() if $make_norm_test_script;<br/>
    return;<br/>
}<br/>
<div class="spacer">
</div>
my @white_space_separators = ( # This used only for making the test script.<br/>
                            &quot;&quot;,<br/>
                            ' ',<br/>
                            &quot;\t&quot;,<br/>
                            '   '<br/>
                        );<div class="spacer">
</div>
sub generate_separator($) {<br/>
    # This used only for making the test script.  It generates the colon or<br/>
    # equal separator between the property and property value, with random<br/>
    # white space surrounding the separator<div class="spacer">
</div>
<br/>
    my $lhs = shift;<br/>
<br/>
    return &quot;&quot; if $lhs eq &quot;&quot;;  # No separator if there's only one (the r) side<br/>
<br/>
    # Choose space before and after randomly<br/>
    my $spaces_before =$white_space_separators[rand(@white_space_separators)];<br/>
    my $spaces_after = $white_space_separators[rand(@white_space_separators)];<br/>
<br/>
    # And return the whole complex, half the time using a colon, half the<br/>
    # equals<br/>
    return $spaces_before<br/>
            . (rand() &lt; 0.5) ? '=' : ':'<br/>
            . $spaces_after;<br/>
}<br/>
<div class="spacer">
</div>
sub generate_tests($$$$$) {<br/>
    # This used only for making the test script.  It generates test cases that<br/>
    # are expected to compile successfully in perl.  Note that the lhs and<br/>
    # rhs are assumed to already be as randomized as the caller wants.<div class="spacer">
</div>
<br/>
    my $lhs = shift;           # The property: what's to the left of the colon<br/>
                               #  or equals separator<br/>
    my $rhs = shift;           # The property value; what's to the right<br/>
    my $valid_code = shift;    # A code point that's known to be in the<br/>
                               # table given by lhs=rhs; undef if table is<br/>
                               # empty<br/>
    my $invalid_code = shift;  # A code point known to not be in the table;<br/>
                               # undef if the table is all code points<br/>
    my $warning = shift;<br/>
<br/>
    # Get the colon or equal<br/>
    my $separator = generate_separator($lhs);<br/>
<br/>
    # The whole 'property=value'<br/>
    my $name = &quot;$lhs$separator$rhs&quot;;<br/>
<br/>
    my @output;<br/>
    # Create a complete set of tests, with complements.<br/>
    if (defined $valid_code) {<br/>
        push @output, &lt;&lt;&quot;EOC&quot;<br/>
Expect(1, $valid_code, '\\p{$name}', $warning);<br/>
Expect(0, $valid_code, '\\p{^$name}', $warning);<br/>
Expect(0, $valid_code, '\\P{$name}', $warning);<br/>
Expect(1, $valid_code, '\\P{^$name}', $warning);<br/>
EOC<br/>
    }<br/>
    if (defined $invalid_code) {<br/>
        push @output, &lt;&lt;&quot;EOC&quot;<br/>
Expect(0, $invalid_code, '\\p{$name}', $warning);<br/>
Expect(1, $invalid_code, '\\p{^$name}', $warning);<br/>
Expect(1, $invalid_code, '\\P{$name}', $warning);<br/>
Expect(0, $invalid_code, '\\P{^$name}', $warning);<br/>
EOC<br/>
    }<br/>
    return @output;<br/>
}<br/>
<div class="spacer">
</div>
sub generate_error($$$) {<br/>
    # This used only for making the test script.  It generates test cases that<br/>
    # are expected to not only not match, but to be syntax or similar errors<div class="spacer">
</div>
<br/>
    my $lhs = shift;                # The property: what's to the left of the<br/>
                                    # colon or equals separator<br/>
    my $rhs = shift;                # The property value; what's to the right<br/>
    my $already_in_error = shift;   # Boolean; if true it's known that the<br/>
                                # unmodified lhs and rhs will cause an error.<br/>
                                # This routine should not force another one<br/>
    # Get the colon or equal<br/>
    my $separator = generate_separator($lhs);<br/>
<br/>
    # Since this is an error only, don't bother to randomly decide whether to<br/>
    # put the error on the left or right side; and assume that the rhs is<br/>
    # loosely matched, again for convenience rather than rigor.<br/>
    $rhs = randomize_loose_name($rhs, 'ERROR') unless $already_in_error;<br/>
<br/>
    my $property = $lhs . $separator . $rhs;<br/>
<br/>
    return &lt;&lt;&quot;EOC&quot;;<br/>
Error('\\p{$property}');<br/>
Error('\\P{$property}');<br/>
EOC<br/>
}<br/>
<div class="spacer">
</div>
# These are used only for making the test script # XXX Maybe should also have a bad strict seps, which includes underscore.<div class="spacer">
</div>
my @good_loose_seps = (<br/>
            &quot; &quot;,<br/>
            &quot;-&quot;,<br/>
            &quot;\t&quot;,<br/>
            &quot;&quot;,<br/>
            &quot;_&quot;,<br/>
           ); my @bad_loose_seps = (<br/>
           &quot;/a/&quot;,<br/>
           ':=',<br/>
          );<div class="spacer">
</div>
sub randomize_stricter_name {<br/>
    # This used only for making the test script.  Take the input name and<br/>
    # return a randomized, but valid version of it under the stricter matching<br/>
    # rules.<div class="spacer">
</div>
<br/>
    my $name = shift;<br/>
    Carp::carp_extra_args(\@_) if main::DEBUG &amp;&amp; @_;<br/>
<br/>
    # If the name looks like a number (integer, floating, or rational), do<br/>
    # some extra work<br/>
    if ($name =~ qr{ ^ ( -? ) (\d+ ( ( [./] ) \d+ )? ) $ }x) {<br/>
        my $sign = $1;<br/>
        my $number = $2;<br/>
        my $separator = $3;<br/>
<br/>
        # If there isn't a sign, part of the time add a plus<br/>
        # Note: Not testing having any denominator having a minus sign<br/>
        if (! $sign) {<br/>
            $sign = '+' if rand() &lt;= .3;<br/>
        }<br/>
<br/>
        # And add 0 or more leading zeros.<br/>
        $name = $sign . ('0' x int rand(10)) . $number;<br/>
<br/>
        if (defined $separator) {<br/>
            my $extra_zeros = '0' x int rand(10);<br/>
<br/>
            if ($separator eq '.') {<br/>
<br/>
                # Similarly, add 0 or more trailing zeros after a decimal<br/>
                # point<br/>
                $name .= $extra_zeros;<br/>
            }<br/>
            else {<br/>
<br/>
                # Or, leading zeros before the denominator<br/>
                $name =~ s,/,/$extra_zeros,;<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    # For legibility of the test, only change the case of whole sections at a<br/>
    # time.  To do this, first split into sections.  The split returns the<br/>
    # delimiters<br/>
    my @sections;<br/>
    for my $section (split / ( [ - + \s _ . ]+ ) /x, $name) {<br/>
        trace $section if main::DEBUG &amp;&amp; $to_trace;<br/>
<br/>
        if (length $section &gt; 1 &amp;&amp; $section !~ /\D/) {<br/>
<br/>
            # If the section is a sequence of digits, about half the time<br/>
            # randomly add underscores between some of them.<br/>
            if (rand() &gt; .5) {<br/>
<br/>
                # Figure out how many underscores to add.  max is 1 less than<br/>
                # the number of digits.  (But add 1 at the end to make sure<br/>
                # result isn't 0, and compensate earlier by subtracting 2<br/>
                # instead of 1)<br/>
                my $num_underscores = int rand(length($section) - 2) + 1;<br/>
<br/>
                # And add them evenly throughout, for convenience, not rigor<br/>
                use integer;<br/>
                my $spacing = (length($section) - 1)/ $num_underscores;<br/>
                my $temp = $section;<br/>
                $section = &quot;&quot;;<br/>
                for my $i (1 .. $num_underscores) {<br/>
                    $section .= substr($temp, 0, $spacing, &quot;&quot;) . '_';<br/>
                }<br/>
                $section .= $temp;<br/>
            }<br/>
            push @sections, $section;<br/>
        }<br/>
        else {<br/>
<br/>
            # Here not a sequence of digits.  Change the case of the section<br/>
            # randomly<br/>
            my $switch = int rand(4);<br/>
            if ($switch == 0) {<br/>
                push @sections, uc $section;<br/>
            }<br/>
            elsif ($switch == 1) {<br/>
                push @sections, lc $section;<br/>
            }<br/>
            elsif ($switch == 2) {<br/>
                push @sections, ucfirst $section;<br/>
            }<br/>
            else {<br/>
                push @sections, $section;<br/>
            }<br/>
        }<br/>
    }<br/>
    trace &quot;returning&quot;, join &quot;&quot;, @sections if main::DEBUG &amp;&amp; $to_trace;<br/>
    return join &quot;&quot;, @sections;<br/>
}<br/>
<div class="spacer">
</div>
sub randomize_loose_name($;$) {<br/>
    # This used only for making the test script<div class="spacer">
</div>
<br/>
    my $name = shift;<br/>
    my $want_error = shift;  # if true, make an error<br/>
    Carp::carp_extra_args(\@_) if main::DEBUG &amp;&amp; @_;<br/>
<br/>
    $name = randomize_stricter_name($name);<br/>
<br/>
    my @parts;<br/>
    push @parts, $good_loose_seps[rand(@good_loose_seps)];<br/>
<br/>
    # Preserve trailing ones for the sake of not stripping the underscore from<br/>
    # 'L_'<br/>
    for my $part (split /[-\s_]+ (?= . )/, $name) {<br/>
        if (@parts) {<br/>
            if ($want_error and rand() &lt; 0.3) {<br/>
                push @parts, $bad_loose_seps[rand(@bad_loose_seps)];<br/>
                $want_error = 0;<br/>
            }<br/>
            else {<br/>
                push @parts, $good_loose_seps[rand(@good_loose_seps)];<br/>
            }<br/>
        }<br/>
        push @parts, $part;<br/>
    }<br/>
    my $new = join(&quot;&quot;, @parts);<br/>
    trace &quot;$name =&gt; $new&quot; if main::DEBUG &amp;&amp; $to_trace;<br/>
<br/>
    if ($want_error) {<br/>
        if (rand() &gt;= 0.5) {<br/>
            $new .= $bad_loose_seps[rand(@bad_loose_seps)];<br/>
        }<br/>
        else {<br/>
            $new = $bad_loose_seps[rand(@bad_loose_seps)] . $new;<br/>
        }<br/>
    }<br/>
    return $new;<br/>
}<br/>
<div class="spacer">
</div>
# Used to make sure don't generate duplicate test cases. my %test_generated;<div class="spacer">
</div>
sub <i>make_property_test_script()</i> {<br/>
    # This used only for making the test script<br/>
    # this written directly -- it's huge.<div class="spacer">
</div>
<br/>
    print &quot;Making test script\n&quot; if $verbosity &gt;= $PROGRESS;<br/>
<br/>
    # This uses randomness to test different possibilities without testing all<br/>
    # possibilities.  To ensure repeatability, set the seed to 0.  But if<br/>
    # tests are added, it will perturb all later ones in the .t file<br/>
    srand 0;<br/>
<br/>
    $t_path = 'TestProp.pl' unless defined $t_path; # the traditional name<br/>
<br/>
    # Keep going down an order of magnitude<br/>
    # until find that adding this quantity to<br/>
    # 1 remains 1; but put an upper limit on<br/>
    # this so in case this algorithm doesn't<br/>
    # work properly on some platform, that we<br/>
    # won't loop forever.<br/>
    my $digits = 0;<br/>
    my $min_floating_slop = 1;<br/>
    while (1+ $min_floating_slop != 1<br/>
            &amp;&amp; $digits++ &lt; 50)<br/>
    {<br/>
        my $next = $min_floating_slop / 10;<br/>
        last if $next == 0; # If underflows,<br/>
                            # use previous one<br/>
        $min_floating_slop = $next;<br/>
    }<br/>
<br/>
    # It doesn't matter whether the elements of this array contain single lines<br/>
    # or multiple lines. main::write doesn't count the lines.<br/>
    my @output;<br/>
<br/>
    # Sort these so get results in same order on different runs of this<br/>
    # program<br/>
    foreach my $property (sort { $a-&gt;name cmp $b-&gt;name } property_ref('*')) {<br/>
        foreach my $table (sort { $a-&gt;name cmp $b-&gt;name } $property-&gt;tables) {<br/>
<br/>
            # Find code points that match, and don't match this table.<br/>
            my $valid = $table-&gt;get_valid_code_point;<br/>
            my $invalid = $table-&gt;get_invalid_code_point;<br/>
            my $warning = ($table-&gt;status eq $DEPRECATED)<br/>
                            ? &quot;'deprecated'&quot;<br/>
                            : '&quot;&quot;';<br/>
<br/>
            # Test each possible combination of the property's aliases with<br/>
            # the table's.  If this gets to be too many, could do what is done<br/>
            # in the set_final_comment() for Tables<br/>
            my @table_aliases = $table-&gt;aliases;<br/>
            my @property_aliases = $table-&gt;property-&gt;aliases;<br/>
<br/>
            # Every property can be optionally be prefixed by 'Is_', so test<br/>
            # that those work, by creating such a new alias for each<br/>
            # pre-existing one.<br/>
            push @property_aliases, map { Alias-&gt;new(&quot;Is_&quot; . $_-&gt;name,<br/>
                                                    $_-&gt;loose_match,<br/>
                                                    $_-&gt;make_re_pod_entry,<br/>
                                                    $_-&gt;ok_as_filename,<br/>
                                                    $_-&gt;status,<br/>
                                                    $_-&gt;ucd,<br/>
                                                    )<br/>
                                         } @property_aliases;<br/>
            my $max = max(scalar @table_aliases, scalar @property_aliases);<br/>
            for my $j (0 .. $max - 1) {<br/>
<br/>
                # The current alias for property is the next one on the list,<br/>
                # or if beyond the end, start over.  Similarly for table<br/>
                my $property_name<br/>
                            = $property_aliases[$j % @property_aliases]-&gt;name;<br/>
<br/>
                $property_name = &quot;&quot; if $table-&gt;property == $perl;<br/>
                my $table_alias = $table_aliases[$j % @table_aliases];<br/>
                my $table_name = $table_alias-&gt;name;<br/>
                my $loose_match = $table_alias-&gt;loose_match;<br/>
<br/>
                # If the table doesn't have a file, any test for it is<br/>
                # already guaranteed to be in error<br/>
                my $already_error = ! $table-&gt;file_path;<br/>
<br/>
                # Generate error cases for this alias.<br/>
                push @output, generate_error($property_name,<br/>
                                             $table_name,<br/>
                                             $already_error);<br/>
<br/>
                # If the table is guaranteed to always generate an error,<br/>
                # quit now without generating success cases.<br/>
                next if $already_error;<br/>
<br/>
                # Now for the success cases.<br/>
                my $random;<br/>
                if ($loose_match) {<br/>
<br/>
                    # For loose matching, create an extra test case for the<br/>
                    # standard name.<br/>
                    my $standard = standardize($table_name);<br/>
<br/>
                    # $test_name should be a unique combination for each test<br/>
                    # case; used just to avoid duplicate tests<br/>
                    my $test_name = &quot;$property_name=$standard&quot;;<br/>
<br/>
                    # Don't output duplicate test cases.<br/>
                    if (! exists $test_generated{$test_name}) {<br/>
                        $test_generated{$test_name} = 1;<br/>
                        push @output, generate_tests($property_name,<br/>
                                                     $standard,<br/>
                                                     $valid,<br/>
                                                     $invalid,<br/>
                                                     $warning,<br/>
                                                 );<br/>
                    }<br/>
                    $random = randomize_loose_name($table_name)<br/>
                }<br/>
                else { # Stricter match<br/>
                    $random = randomize_stricter_name($table_name);<br/>
                }<br/>
<br/>
                # Now for the main test case for this alias.<br/>
                my $test_name = &quot;$property_name=$random&quot;;<br/>
                if (! exists $test_generated{$test_name}) {<br/>
                    $test_generated{$test_name} = 1;<br/>
                    push @output, generate_tests($property_name,<br/>
                                                 $random,<br/>
                                                 $valid,<br/>
                                                 $invalid,<br/>
                                                 $warning,<br/>
                                             );<br/>
<br/>
                    # If the name is a rational number, add tests for the<br/>
                    # floating point equivalent.<br/>
                    if ($table_name =~ qr{/}) {<br/>
<br/>
                        # Calculate the float, and find just the fraction.<br/>
                        my $float = eval $table_name;<br/>
                        my ($whole, $fraction)<br/>
                                            = $float =~ / (.*) \. (.*) /x;<br/>
<br/>
                        # Starting with one digit after the decimal point,<br/>
                        # create a test for each possible precision (number of<br/>
                        # digits past the decimal point) until well beyond the<br/>
                        # native number found on this machine.  (If we started<br/>
                        # with 0 digits, it would be an integer, which could<br/>
                        # well match an unrelated table)<br/>
                        PLACE:<br/>
                        for my $i (1 .. $min_floating_slop + 3) {<br/>
                            my $table_name = sprintf(&quot;%.*f&quot;, $i, $float);<br/>
                            if ($i &lt; $MIN_FRACTION_LENGTH) {<br/>
<br/>
                                # If the test case has fewer digits than the<br/>
                                # minimum acceptable precision, it shouldn't<br/>
                                # succeed, so we expect an error for it.<br/>
                                # E.g., 2/3 = .7 at one decimal point, and we<br/>
                                # shouldn't say it matches .7.  We should make<br/>
                                # it be .667 at least before agreeing that the<br/>
                                # intent was to match 2/3.  But at the<br/>
                                # less-than- acceptable level of precision, it<br/>
                                # might actually match an unrelated number.<br/>
                                # So don't generate a test case if this<br/>
                                # conflating is possible.  In our example, we<br/>
                                # don't want 2/3 matching 7/10, if there is<br/>
                                # a 7/10 code point.<br/>
                                for my $existing<br/>
                                        (keys %nv_floating_to_rational)<br/>
                                {<br/>
                                    next PLACE<br/>
                                        if abs($table_name - $existing)<br/>
                                                &lt; $MAX_FLOATING_SLOP;<br/>
                                }<br/>
                                push @output, generate_error($property_name,<br/>
                                                             $table_name,<br/>
                                                             1   # 1 =&gt; already an error<br/>
                                              );<br/>
                            }<br/>
                            else {<br/>
<br/>
                                # Here the number of digits exceeds the<br/>
                                # minimum we think is needed.  So generate a<br/>
                                # success test case for it.<br/>
                                push @output, generate_tests($property_name,<br/>
                                                             $table_name,<br/>
                                                             $valid,<br/>
                                                             $invalid,<br/>
                                                             $warning,<br/>
                                             );<br/>
                            }<br/>
                        }<br/>
                    }<br/>
                }<br/>
            }<br/>
        }<br/>
    }<br/>
<br/>
    &amp;write($t_path,<br/>
           0,           # Not utf8;<br/>
           [&lt;DATA&gt;,<br/>
            @output,<br/>
            (map {&quot;Test_X('$_');\n&quot;} @backslash_X_tests),<br/>
            &quot;Finished();\n&quot;]);<br/>
    return;<br/>
}<br/>
<div class="spacer">
</div>
sub <i>make_normalization_test_script()</i> {<br/>
    print &quot;Making normalization test script\n&quot; if $verbosity &gt;= $PROGRESS;<div class="spacer">
</div>
<br/>
    my $n_path = 'TestNorm.pl';<br/>
<br/>
    unshift @normalization_tests, &lt;&lt;'END';<br/>
use utf8;<br/>
use Test::More;<br/>
<div class="spacer">
</div>
sub ord_string {    # Convert packed ords to printable string<br/>
    use charnames ();<br/>
    return &quot;'&quot; . join(&quot;&quot;, map { '\N{' . charnames::viacode($_) . '}' }<br/>
                                                unpack &quot;U*&quot;, shift) .  &quot;'&quot;;<br/>
    #return &quot;'&quot; . join(&quot; &quot;, map { sprintf &quot;%04X&quot;, $_ } unpack &quot;U*&quot;, shift) .  &quot;'&quot;; }<div class="spacer">
</div>
sub Test_N {<br/>
    my ($source, $nfc, $nfd, $nfkc, $nfkd) = @_;<br/>
    my $display_source = ord_string($source);<br/>
    my $display_nfc = ord_string($nfc);<br/>
    my $display_nfd = ord_string($nfd);<br/>
    my $display_nfkc = ord_string($nfkc);<br/>
    my $display_nfkd = ord_string($nfkd);<div class="spacer">
</div>
<br/>
    use Unicode::Normalize;<br/>
    #    NFC<br/>
    #      nfc ==  toNFC(source) ==  toNFC(nfc) ==  toNFC(nfd)<br/>
    #      nfkc ==  toNFC(nfkc) ==  toNFC(nfkd)<br/>
    #<br/>
    #    NFD<br/>
    #      nfd ==  toNFD(source) ==  toNFD(nfc) ==  toNFD(nfd)<br/>
    #      nfkd ==  toNFD(nfkc) ==  toNFD(nfkd)<br/>
    #<br/>
    #    NFKC<br/>
    #      nfkc == toNFKC(source) == toNFKC(nfc) == toNFKC(nfd) ==<br/>
    #      toNFKC(nfkc) == toNFKC(nfkd)<br/>
    #<br/>
    #    NFKD<br/>
    #      nfkd == toNFKD(source) == toNFKD(nfc) == toNFKD(nfd) ==<br/>
    #      toNFKD(nfkc) == toNFKD(nfkd)<br/>
<br/>
    is(NFC($source), $nfc, &quot;NFC($display_source) eq $display_nfc&quot;);<br/>
    is(NFC($nfc), $nfc, &quot;NFC($display_nfc) eq $display_nfc&quot;);<br/>
    is(NFC($nfd), $nfc, &quot;NFC($display_nfd) eq $display_nfc&quot;);<br/>
    is(NFC($nfkc), $nfkc, &quot;NFC($display_nfkc) eq $display_nfkc&quot;);<br/>
    is(NFC($nfkd), $nfkc, &quot;NFC($display_nfkd) eq $display_nfkc&quot;);<br/>
<br/>
    is(NFD($source), $nfd, &quot;NFD($display_source) eq $display_nfd&quot;);<br/>
    is(NFD($nfc), $nfd, &quot;NFD($display_nfc) eq $display_nfd&quot;);<br/>
    is(NFD($nfd), $nfd, &quot;NFD($display_nfd) eq $display_nfd&quot;);<br/>
    is(NFD($nfkc), $nfkd, &quot;NFD($display_nfkc) eq $display_nfkd&quot;);<br/>
    is(NFD($nfkd), $nfkd, &quot;NFD($display_nfkd) eq $display_nfkd&quot;);<br/>
<br/>
    is(NFKC($source), $nfkc, &quot;NFKC($display_source) eq $display_nfkc&quot;);<br/>
    is(NFKC($nfc), $nfkc, &quot;NFKC($display_nfc) eq $display_nfkc&quot;);<br/>
    is(NFKC($nfd), $nfkc, &quot;NFKC($display_nfd) eq $display_nfkc&quot;);<br/>
    is(NFKC($nfkc), $nfkc, &quot;NFKC($display_nfkc) eq $display_nfkc&quot;);<br/>
    is(NFKC($nfkd), $nfkc, &quot;NFKC($display_nfkd) eq $display_nfkc&quot;);<br/>
<br/>
    is(NFKD($source), $nfkd, &quot;NFKD($display_source) eq $display_nfkd&quot;);<br/>
    is(NFKD($nfc), $nfkd, &quot;NFKD($display_nfc) eq $display_nfkd&quot;);<br/>
    is(NFKD($nfd), $nfkd, &quot;NFKD($display_nfd) eq $display_nfkd&quot;);<br/>
    is(NFKD($nfkc), $nfkd, &quot;NFKD($display_nfkc) eq $display_nfkd&quot;);<br/>
    is(NFKD($nfkd), $nfkd, &quot;NFKD($display_nfkd) eq $display_nfkd&quot;);<br/>
}<br/>
END<br/>
<br/>
    &amp;write($n_path,<br/>
           1,           # Is utf8;<br/>
           [<br/>
            @normalization_tests,<br/>
            'done_testing();'<br/>
            ]);<br/>
    return;<br/>
}<br/>
<div class="spacer">
</div>
# This is a list of the input files and how to handle them.  The files are # processed in their order in this list.  Some reordering is possible if # desired, but the v0 files should be first, and the extracted before the # others except DAge.txt (as data in an extracted file can be over-ridden by # the non-extracted.  Some other files depend on data derived from an earlier # file, like UnicodeData requires data from Jamo, and the case changing and # folding requires data from Unicode.  Mostly, it is safest to order by first # version releases in (except the Jamo).  DAge.txt is read before the # extracted ones because of the rarely used feature $compare_versions.  In the # unlikely event that there were ever an extracted file that contained the Age # property information, it would have to go in front of DAge. # # The version strings allow the program to know whether to expect a file or # not, but if a file exists in the directory, it will be processed, even if it # is in a version earlier than expected, so you can copy files from a later # release into an earlier release's directory. my @input_file_objects = (<br/>
    Input_file-&gt;new('PropertyAliases.txt', v0,<br/>
                    Handler =&gt; \&amp;process_PropertyAliases,<br/>
                    ),<br/>
    Input_file-&gt;new(undef, v0,  # No file associated with this<br/>
                    Progress_Message =&gt; 'Finishing property setup',<br/>
                    Handler =&gt; \&amp;finish_property_setup,<br/>
                    ),<br/>
    Input_file-&gt;new('PropValueAliases.txt', v0,<br/>
                     Handler =&gt; \&amp;process_PropValueAliases,<br/>
                     Has_Missings_Defaults =&gt; $NOT_IGNORED,<br/>
                     ),<br/>
    Input_file-&gt;new('DAge.txt', v3.2.0,<br/>
                    Has_Missings_Defaults =&gt; $NOT_IGNORED,<br/>
                    Property =&gt; 'Age'<br/>
                    ),<br/>
    Input_file-&gt;new(&quot;${EXTRACTED}DGeneralCategory.txt&quot;, v3.1.0,<br/>
                    Property =&gt; 'General_Category',<br/>
                    ),<br/>
    Input_file-&gt;new(&quot;${EXTRACTED}DCombiningClass.txt&quot;, v3.1.0,<br/>
                    Property =&gt; 'Canonical_Combining_Class',<br/>
                    Has_Missings_Defaults =&gt; $NOT_IGNORED,<br/>
                    ),<br/>
    Input_file-&gt;new(&quot;${EXTRACTED}DNumType.txt&quot;, v3.1.0,<br/>
                    Property =&gt; 'Numeric_Type',<br/>
                    Has_Missings_Defaults =&gt; $NOT_IGNORED,<br/>
                    ),<br/>
    Input_file-&gt;new(&quot;${EXTRACTED}DEastAsianWidth.txt&quot;, v3.1.0,<br/>
                    Property =&gt; 'East_Asian_Width',<br/>
                    Has_Missings_Defaults =&gt; $NOT_IGNORED,<br/>
                    ),<br/>
    Input_file-&gt;new(&quot;${EXTRACTED}DLineBreak.txt&quot;, v3.1.0,<br/>
                    Property =&gt; 'Line_Break',<br/>
                    Has_Missings_Defaults =&gt; $NOT_IGNORED,<br/>
                    ),<br/>
    Input_file-&gt;new(&quot;${EXTRACTED}DBidiClass.txt&quot;, v3.1.1,<br/>
                    Property =&gt; 'Bidi_Class',<br/>
                    Has_Missings_Defaults =&gt; $NOT_IGNORED,<br/>
                    ),<br/>
    Input_file-&gt;new(&quot;${EXTRACTED}DDecompositionType.txt&quot;, v3.1.0,<br/>
                    Property =&gt; 'Decomposition_Type',<br/>
                    Has_Missings_Defaults =&gt; $NOT_IGNORED,<br/>
                    ),<br/>
    Input_file-&gt;new(&quot;${EXTRACTED}DBinaryProperties.txt&quot;, v3.1.0),<br/>
    Input_file-&gt;new(&quot;${EXTRACTED}DNumValues.txt&quot;, v3.1.0,<br/>
                    Property =&gt; 'Numeric_Value',<br/>
                    Each_Line_Handler =&gt; \&amp;filter_numeric_value_line,<br/>
                    Has_Missings_Defaults =&gt; $NOT_IGNORED,<br/>
                    ),<br/>
    Input_file-&gt;new(&quot;${EXTRACTED}DJoinGroup.txt&quot;, v3.1.0,<br/>
                    Property =&gt; 'Joining_Group',<br/>
                    Has_Missings_Defaults =&gt; $NOT_IGNORED,<br/>
                    ),<div class="spacer">
</div>
<br/>
    Input_file-&gt;new(&quot;${EXTRACTED}DJoinType.txt&quot;, v3.1.0,<br/>
                    Property =&gt; 'Joining_Type',<br/>
                    Has_Missings_Defaults =&gt; $NOT_IGNORED,<br/>
                    ),<br/>
    Input_file-&gt;new('Jamo.txt', v2.0.0,<br/>
                    Property =&gt; 'Jamo_Short_Name',<br/>
                    Each_Line_Handler =&gt; \&amp;filter_jamo_line,<br/>
                    ),<br/>
    Input_file-&gt;new('UnicodeData.txt', v1.1.5,<br/>
                    Pre_Handler =&gt; \&amp;setup_UnicodeData,<br/>
<br/>
                    # We clean up this file for some early versions.<br/>
                    Each_Line_Handler =&gt; [ (($v_version lt v2.0.0 )<br/>
                                            ? \&amp;filter_v1_ucd<br/>
                                            : ($v_version eq v2.1.5)<br/>
                                                ? \&amp;filter_v2_1_5_ucd<br/>
<br/>
                                                # And for 5.14 Perls with 6.0,<br/>
                                                # have to also make changes<br/>
                                                : ($v_version ge v6.0.0<br/>
                                                   &amp;&amp; $^V lt v5.17.0)<br/>
                                                    ? \&amp;filter_v6_ucd<br/>
                                                    : undef),<br/>
<br/>
                                            # Early versions did not have the<br/>
                                            # proper Unicode_1 names for the<br/>
                                            # controls<br/>
                                            (($v_version lt v3.0.0)<br/>
                                            ? \&amp;filter_early_U1_names<br/>
                                            : undef),<br/>
<br/>
                                            # Early versions did not correctly<br/>
                                            # use the later method for giving<br/>
                                            # decimal digit values<br/>
                                            (($v_version le v3.2.0)<br/>
                                            ? \&amp;filter_bad_Nd_ucd<br/>
                                            : undef),<br/>
<br/>
                                            # And the main filter<br/>
                                            \&amp;filter_UnicodeData_line,<br/>
                                         ],<br/>
                    EOF_Handler =&gt; \&amp;EOF_UnicodeData,<br/>
                    ),<br/>
    Input_file-&gt;new('ArabicShaping.txt', v2.0.0,<br/>
                    Each_Line_Handler =&gt;<br/>
                        ($v_version lt 4.1.0)<br/>
                                    ? \&amp;filter_old_style_arabic_shaping<br/>
                                    : undef,<br/>
                    # The first field after the range is a &quot;schematic name&quot;<br/>
                    # not used by Perl<br/>
                    Properties =&gt; [ '&lt;ignored&gt;', 'Joining_Type', 'Joining_Group' ],<br/>
                    Has_Missings_Defaults =&gt; $NOT_IGNORED,<br/>
                    ),<br/>
    Input_file-&gt;new('Blocks.txt', v2.0.0,<br/>
                    Property =&gt; 'Block',<br/>
                    Has_Missings_Defaults =&gt; $NOT_IGNORED,<br/>
                    Each_Line_Handler =&gt; \&amp;filter_blocks_lines<br/>
                    ),<br/>
    Input_file-&gt;new('PropList.txt', v2.0.0,<br/>
                    Each_Line_Handler =&gt; (($v_version lt v3.1.0)<br/>
                                            ? \&amp;filter_old_style_proplist<br/>
                                            : undef),<br/>
                    ),<br/>
    Input_file-&gt;new('Unihan.txt', v2.0.0,<br/>
                    Pre_Handler =&gt; \&amp;setup_unihan,<br/>
                    Optional =&gt; 1,<br/>
                    Each_Line_Handler =&gt; \&amp;filter_unihan_line,<br/>
                        ),<br/>
    Input_file-&gt;new('SpecialCasing.txt', v2.1.8,<br/>
                    Each_Line_Handler =&gt; ($v_version eq 2.1.8)<br/>
                                         ? \&amp;filter_2_1_8_special_casing_line<br/>
                                         : \&amp;filter_special_casing_line,<br/>
                    Pre_Handler =&gt; \&amp;setup_special_casing,<br/>
                    Has_Missings_Defaults =&gt; $IGNORED,<br/>
                    ),<br/>
    Input_file-&gt;new(<br/>
                    'LineBreak.txt', v3.0.0,<br/>
                    Has_Missings_Defaults =&gt; $NOT_IGNORED,<br/>
                    Property =&gt; 'Line_Break',<br/>
                    # Early versions had problematic syntax<br/>
                    Each_Line_Handler =&gt; (($v_version lt v3.1.0)<br/>
                                        ? \&amp;filter_early_ea_lb<br/>
                                        : undef),<br/>
                    ),<br/>
    Input_file-&gt;new('EastAsianWidth.txt', v3.0.0,<br/>
                    Property =&gt; 'East_Asian_Width',<br/>
                    Has_Missings_Defaults =&gt; $NOT_IGNORED,<br/>
                    # Early versions had problematic syntax<br/>
                    Each_Line_Handler =&gt; (($v_version lt v3.1.0)<br/>
                                        ? \&amp;filter_early_ea_lb<br/>
                                        : undef),<br/>
                    ),<br/>
    Input_file-&gt;new('CompositionExclusions.txt', v3.0.0,<br/>
                    Property =&gt; 'Composition_Exclusion',<br/>
                    ),<br/>
    Input_file-&gt;new('BidiMirroring.txt', v3.0.1,<br/>
                    Property =&gt; 'Bidi_Mirroring_Glyph',<br/>
                    Has_Missings_Defaults =&gt; ($v_version lt v6.2.0)<br/>
                                              ? $NO_DEFAULTS<br/>
                                              # Is &lt;none&gt; which doesn't mean<br/>
                                              # anything to us, we will use the<br/>
                                              # null string<br/>
                                              : $IGNORED,<br/>
<br/>
                    ),<br/>
    Input_file-&gt;new(&quot;NormTest.txt&quot;, v3.0.0,<br/>
                     Handler =&gt; \&amp;process_NormalizationsTest,<br/>
                     Skip =&gt; ($make_norm_test_script) ? 0 : 'Validation Tests',<br/>
                    ),<br/>
    Input_file-&gt;new('CaseFolding.txt', v3.0.1,<br/>
                    Pre_Handler =&gt; \&amp;setup_case_folding,<br/>
                    Each_Line_Handler =&gt;<br/>
                        [ ($v_version lt v3.1.0)<br/>
                                 ? \&amp;filter_old_style_case_folding<br/>
                                 : undef,<br/>
                           \&amp;filter_case_folding_line<br/>
                        ],<br/>
                    Has_Missings_Defaults =&gt; $IGNORED,<br/>
                    ),<br/>
    Input_file-&gt;new('DCoreProperties.txt', v3.1.0,<br/>
                    # 5.2 changed this file<br/>
                    Has_Missings_Defaults =&gt; (($v_version ge v5.2.0)<br/>
                                            ? $NOT_IGNORED<br/>
                                            : $NO_DEFAULTS),<br/>
                    ),<br/>
    Input_file-&gt;new('Scripts.txt', v3.1.0,<br/>
                    Property =&gt; 'Script',<br/>
                    Has_Missings_Defaults =&gt; $NOT_IGNORED,<br/>
                    ),<br/>
    Input_file-&gt;new('DNormalizationProps.txt', v3.1.0,<br/>
                    Has_Missings_Defaults =&gt; $NOT_IGNORED,<br/>
                    Each_Line_Handler =&gt; (($v_version lt v4.0.1)<br/>
                                      ? \&amp;filter_old_style_normalization_lines<br/>
                                      : undef),<br/>
                    ),<br/>
    Input_file-&gt;new('HangulSyllableType.txt', v0,<br/>
                    Has_Missings_Defaults =&gt; $NOT_IGNORED,<br/>
                    Property =&gt; 'Hangul_Syllable_Type',<br/>
                    Pre_Handler =&gt; ($v_version lt v4.0.0)<br/>
                                   ? \&amp;generate_hst<br/>
                                   : undef,<br/>
                    ),<br/>
    Input_file-&gt;new(&quot;$AUXILIARY/WordBreakProperty.txt&quot;, v4.1.0,<br/>
                    Property =&gt; 'Word_Break',<br/>
                    Has_Missings_Defaults =&gt; $NOT_IGNORED,<br/>
                    ),<br/>
    Input_file-&gt;new(&quot;$AUXILIARY/GraphemeBreakProperty.txt&quot;, v0,<br/>
                    Property =&gt; 'Grapheme_Cluster_Break',<br/>
                    Has_Missings_Defaults =&gt; $NOT_IGNORED,<br/>
                    Pre_Handler =&gt; ($v_version lt v4.1.0)<br/>
                                   ? \&amp;generate_GCB<br/>
                                   : undef,<br/>
                    ),<br/>
    Input_file-&gt;new(&quot;$AUXILIARY/GCBTest.txt&quot;, v4.1.0,<br/>
                    Handler =&gt; \&amp;process_GCB_test,<br/>
                    ),<br/>
    Input_file-&gt;new(&quot;$AUXILIARY/LBTest.txt&quot;, v4.1.0,<br/>
                    Skip =&gt; 'Validation Tests',<br/>
                    ),<br/>
    Input_file-&gt;new(&quot;$AUXILIARY/SBTest.txt&quot;, v4.1.0,<br/>
                    Skip =&gt; 'Validation Tests',<br/>
                    ),<br/>
    Input_file-&gt;new(&quot;$AUXILIARY/WBTest.txt&quot;, v4.1.0,<br/>
                    Skip =&gt; 'Validation Tests',<br/>
                    ),<br/>
    Input_file-&gt;new(&quot;$AUXILIARY/SentenceBreakProperty.txt&quot;, v4.1.0,<br/>
                    Property =&gt; 'Sentence_Break',<br/>
                    Has_Missings_Defaults =&gt; $NOT_IGNORED,<br/>
                    ),<br/>
    Input_file-&gt;new('NamedSequences.txt', v4.1.0,<br/>
                    Handler =&gt; \&amp;process_NamedSequences<br/>
                    ),<br/>
    Input_file-&gt;new('NameAliases.txt', v0,<br/>
                    Property =&gt; 'Name_Alias',<br/>
                    Pre_Handler =&gt; ($v_version le v6.0.0)<br/>
                                   ? \&amp;setup_early_name_alias<br/>
                                   : undef,<br/>
                    Each_Line_Handler =&gt; ($v_version le v6.0.0)<br/>
                                   ? \&amp;filter_early_version_name_alias_line<br/>
                                   : \&amp;filter_later_version_name_alias_line,<br/>
                    ),<br/>
    Input_file-&gt;new(&quot;BidiTest.txt&quot;, v5.2.0,<br/>
                    Skip =&gt; 'Validation Tests',<br/>
                    ),<br/>
    Input_file-&gt;new('UnihanIndicesDictionary.txt', v5.2.0,<br/>
                    Optional =&gt; 1,<br/>
                    Each_Line_Handler =&gt; \&amp;filter_unihan_line,<br/>
                    ),<br/>
    Input_file-&gt;new('UnihanDataDictionaryLike.txt', v5.2.0,<br/>
                    Optional =&gt; 1,<br/>
                    Each_Line_Handler =&gt; \&amp;filter_unihan_line,<br/>
                    ),<br/>
    Input_file-&gt;new('UnihanIRGSources.txt', v5.2.0,<br/>
                    Optional =&gt; 1,<br/>
                    Pre_Handler =&gt; \&amp;setup_unihan,<br/>
                    Each_Line_Handler =&gt; \&amp;filter_unihan_line,<br/>
                    ),<br/>
    Input_file-&gt;new('UnihanNumericValues.txt', v5.2.0,<br/>
                    Optional =&gt; 1,<br/>
                    Each_Line_Handler =&gt; \&amp;filter_unihan_line,<br/>
                    ),<br/>
    Input_file-&gt;new('UnihanOtherMappings.txt', v5.2.0,<br/>
                    Optional =&gt; 1,<br/>
                    Each_Line_Handler =&gt; \&amp;filter_unihan_line,<br/>
                    ),<br/>
    Input_file-&gt;new('UnihanRadicalStrokeCounts.txt', v5.2.0,<br/>
                    Optional =&gt; 1,<br/>
                    Each_Line_Handler =&gt; \&amp;filter_unihan_line,<br/>
                    ),<br/>
    Input_file-&gt;new('UnihanReadings.txt', v5.2.0,<br/>
                    Optional =&gt; 1,<br/>
                    Each_Line_Handler =&gt; \&amp;filter_unihan_line,<br/>
                    ),<br/>
    Input_file-&gt;new('UnihanVariants.txt', v5.2.0,<br/>
                    Optional =&gt; 1,<br/>
                    Each_Line_Handler =&gt; \&amp;filter_unihan_line,<br/>
                    ),<br/>
    Input_file-&gt;new('ScriptExtensions.txt', v6.0.0,<br/>
                    Property =&gt; 'Script_Extensions',<br/>
                    Pre_Handler =&gt; \&amp;setup_script_extensions,<br/>
                    Each_Line_Handler =&gt; \&amp;filter_script_extensions_line,<br/>
                    Has_Missings_Defaults =&gt; (($v_version le v6.0.0)<br/>
                                            ? $NO_DEFAULTS<br/>
                                            : $IGNORED),<br/>
                    ),<br/>
    # The two Indic files are actually available starting in v6.0.0, but their<br/>
    # property values are missing from PropValueAliases.txt in that release,<br/>
    # so that further work would have to be done to get them to work properly<br/>
    # for that release.<br/>
    Input_file-&gt;new('IndicMatraCategory.txt', v6.1.0,<br/>
                    Property =&gt; 'Indic_Matra_Category',<br/>
                    Has_Missings_Defaults =&gt; $NOT_IGNORED,<br/>
                    Skip =&gt; &quot;Provisional; for the analysis and processing of Indic scripts&quot;,<br/>
                    ),<br/>
    Input_file-&gt;new('IndicSyllabicCategory.txt', v6.1.0,<br/>
                    Property =&gt; 'Indic_Syllabic_Category',<br/>
                    Has_Missings_Defaults =&gt; $NOT_IGNORED,<br/>
                    Skip =&gt; &quot;Provisional; for the analysis and processing of Indic scripts&quot;,<br/>
                    ),<br/>
    Input_file-&gt;new('BidiBrackets.txt', v6.3.0,<br/>
                    Properties =&gt; [ 'Bidi_Paired_Bracket', 'Bidi_Paired_Bracket_Type' ],<br/>
                    Has_Missings_Defaults =&gt; $NO_DEFAULTS,<br/>
                    ),<br/>
    Input_file-&gt;new(&quot;BidiCharacterTest.txt&quot;, v6.3.0,<br/>
                    Skip =&gt; 'Validation Tests',<br/>
                    ),<br/>
);<br/>
<div class="spacer">
</div>
# End of all the preliminaries. # Do it...<div class="spacer">
</div>
if ($compare_versions) {<br/>
    Carp::my_carp(&lt;&lt;END Warning.  \$compare_versions is set.  Output is not suitable for production END<br/>
    ); }<div class="spacer">
</div>
# Put into %potential_files a list of all the files in the directory structure # that could be inputs to this program, excluding those that we should ignore. # Use absolute file names because it makes it easier across machine types. my @ignored_files_full_names = map { File::Spec-&gt;rel2abs(<br/>
                                     internal_file_to_platform($_))<br/>
                                } keys %ignored_files; File::Find::find({<br/>
    wanted=&gt;sub {<br/>
        return unless /\.txt$/i;  # Some platforms change the name's case<br/>
        my $full = lc(File::Spec-&gt;rel2abs($_));<br/>
        $potential_files{$full} = 1<br/>
                    if ! grep { $full eq lc($_) } @ignored_files_full_names;<br/>
        return;<br/>
    } }, File::Spec-&gt; <i>curdir()</i>);<div class="spacer">
</div>
my @mktables_list_output_files; my $old_start_time = 0; my $old_options = &quot;&quot;;<div class="spacer">
</div>
if (! -e $file_list) {<br/>
    print &quot;'$file_list' doesn't exist, so forcing rebuild.\n&quot; if $verbosity &gt;= $VERBOSE;<br/>
    $write_unchanged_files = 1; } elsif ($write_unchanged_files) {<br/>
    print &quot;Not checking file list '$file_list'.\n&quot; if $verbosity &gt;= $VERBOSE; } else {<br/>
    print &quot;Reading file list '$file_list'\n&quot; if $verbosity &gt;= $VERBOSE;<br/>
    my $file_handle;<br/>
    if (! open $file_handle, &quot;&lt;&quot;, $file_list) {<br/>
        Carp::my_carp(&quot;Failed to open '$file_list'; turning on -globlist option instead: $!&quot;);<br/>
        $glob_list = 1;<br/>
    }<br/>
    else {<br/>
        my @input;<div class="spacer">
</div>
<br/>
        # Read and parse mktables.lst, placing the results from the first part<br/>
        # into @input, and the second part into @mktables_list_output_files<br/>
        for my $list ( \@input, \@mktables_list_output_files ) {<br/>
            while (&lt;$file_handle&gt;) {<br/>
                s/^ \s+ | \s+ $//xg;<br/>
                if (/^ \s* \# \s* Autogenerated\ starting\ on\ (\d+)/x) {<br/>
                    $old_start_time = $1;<br/>
                    next;<br/>
                }<br/>
                if (/^ \s* \# \s* From\ options\ (.+) /x) {<br/>
                    $old_options = $1;<br/>
                    next;<br/>
                }<br/>
                next if /^ \s* (?: \# .* )? $/x;<br/>
                last if /^ =+ $/x;<br/>
                my ( $file ) = split /\t/;<br/>
                push @$list, $file;<br/>
            }<br/>
            @$list = uniques(@$list);<br/>
            next;<br/>
        }<br/>
<br/>
        # Look through all the input files<br/>
        foreach my $input (@input) {<br/>
            next if $input eq 'version'; # Already have checked this.<br/>
<br/>
            # Ignore if doesn't exist.  The checking about whether we care or<br/>
            # not is done via the Input_file object.<br/>
            next if ! file_exists($input);<br/>
<br/>
            # The paths are stored with relative names, and with '/' as the<br/>
            # delimiter; convert to absolute on this machine<br/>
            my $full = lc(File::Spec-&gt;rel2abs(internal_file_to_platform($input)));<br/>
            $potential_files{lc $full} = 1<br/>
                if ! grep { lc($full) eq lc($_) } @ignored_files_full_names;<br/>
        }<br/>
    }<br/>
<br/>
    close $file_handle;<br/>
}<br/>
<div class="spacer">
</div>
if ($glob_list) {<div class="spacer">
</div>
<br/>
    # Here wants to process all .txt files in the directory structure.<br/>
    # Convert them to full path names.  They are stored in the platform's<br/>
    # relative style<br/>
    my @known_files;<br/>
    foreach my $object (@input_file_objects) {<br/>
        my $file = $object-&gt;file;<br/>
        next unless defined $file;<br/>
        push @known_files, File::Spec-&gt;rel2abs($file);<br/>
    }<br/>
<br/>
    my @unknown_input_files;<br/>
    foreach my $file (keys %potential_files) {  # The keys are stored in lc<br/>
        next if grep { $file eq lc($_) } @known_files;<br/>
<br/>
        # Here, the file is unknown to us.  Get relative path name<br/>
        $file = File::Spec-&gt;abs2rel($file);<br/>
        push @unknown_input_files, $file;<br/>
<br/>
        # What will happen is we create a data structure for it, and add it to<br/>
        # the list of input files to process.  First get the subdirectories<br/>
        # into an array<br/>
        my (undef, $directories, undef) = File::Spec-&gt;splitpath($file);<br/>
        $directories =~ s;/$;;;     # Can have extraneous trailing '/'<br/>
        my @directories = File::Spec-&gt;splitdir($directories);<br/>
<br/>
        # If the file isn't extracted (meaning none of the directories is the<br/>
        # extracted one), just add it to the end of the list of inputs.<br/>
        if (! grep { $EXTRACTED_DIR eq $_ } @directories) {<br/>
            push @input_file_objects, Input_file-&gt;new($file, v0);<br/>
        }<br/>
        else {<br/>
<br/>
            # Here, the file is extracted.  It needs to go ahead of most other<br/>
            # processing.  Search for the first input file that isn't a<br/>
            # special required property (that is, find one whose first_release<br/>
            # is non-0), and isn't extracted.  Also, the Age property file is<br/>
            # processed before the extracted ones, just in case<br/>
            # $compare_versions is set.<br/>
            for (my $i = 0; $i &lt; @input_file_objects; $i++) {<br/>
                if ($input_file_objects[$i]-&gt;first_released ne v0<br/>
                    &amp;&amp; lc($input_file_objects[$i]-&gt;file) ne 'dage.txt'<br/>
                    &amp;&amp; $input_file_objects[$i]-&gt;file !~ /$EXTRACTED_DIR/i)<br/>
                {<br/>
                    splice @input_file_objects, $i, 0,<br/>
                                                Input_file-&gt;new($file, v0);<br/>
                    last;<br/>
                }<br/>
            }<br/>
<br/>
        }<br/>
    }<br/>
    if (@unknown_input_files) {<br/>
        print STDERR simple_fold(join_lines(&lt;&lt;END<br/>
<div class="spacer">
</div>
The following files are unknown as to how to handle.  Assuming they are typical property files.  You'll know by later error messages if it worked or not: END<br/>
        ) . &quot; &quot; . join(&quot;, &quot;, @unknown_input_files) . &quot;\n\n&quot;);<br/>
    } } # End of looking through directory structure for more .txt files.<div class="spacer">
</div>
# Create the list of input files from the objects we have defined, plus # version my @input_files = qw(version Makefile); foreach my $object (@input_file_objects) {<br/>
    my $file = $object-&gt;file;<br/>
    next if ! defined $file;    # Not all objects have files<br/>
    next if $object-&gt;optional &amp;&amp; ! -e $file;<br/>
    push @input_files,  $file; }<div class="spacer">
</div>
if ( $verbosity &gt;= $VERBOSE ) {<br/>
    print &quot;Expecting &quot;.scalar( @input_files ).&quot; input files. &quot;,<br/>
         &quot;Checking &quot;.scalar( @mktables_list_output_files ).&quot; output files.\n&quot;; }<div class="spacer">
</div>
# We set $most_recent to be the most recently changed input file, including # this program itself (done much earlier in this file) foreach my $in (@input_files) {<br/>
    next unless -e $in;        # Keep going even if missing a file<br/>
    my $mod_time = (stat $in)[9];<br/>
    $most_recent = $mod_time if $mod_time &gt; $most_recent;<div class="spacer">
</div>
<br/>
    # See that the input files have distinct names, to warn someone if they<br/>
    # are adding a new one<br/>
    if ($make_list) {<br/>
        my ($volume, $directories, $file ) = File::Spec-&gt;splitpath($in);<br/>
        $directories =~ s;/$;;;     # Can have extraneous trailing '/'<br/>
        my @directories = File::Spec-&gt;splitdir($directories);<br/>
        my $base = $file =~ s/\.txt$//;<br/>
        construct_filename($file, 'mutable', \@directories);<br/>
    }<br/>
}<br/>
<div class="spacer">
</div>
# We use 'Makefile' just to see if it has changed since the last time we # rebuilt.  Now discard it. @input_files = grep { $_ ne 'Makefile' } @input_files;<div class="spacer">
</div>
my $rebuild = $write_unchanged_files    # Rebuild: if unconditional rebuild<br/>
              || ! scalar @mktables_list_output_files  # or if no outputs known<br/>
              || $old_start_time &lt; $most_recent        # or out-of-date<br/>
              || $old_options ne $command_line_arguments; # or with different<br/>
                                                          # options<div class="spacer">
</div>
# Now we check to see if any output files are older than youngest, if # they are, we need to continue on, otherwise we can presumably bail. if (! $rebuild) {<br/>
    foreach my $out (@mktables_list_output_files) {<br/>
        if ( ! file_exists($out)) {<br/>
            print &quot;'$out' is missing.\n&quot; if $verbosity &gt;= $VERBOSE;<br/>
            $rebuild = 1;<br/>
            last;<br/>
         }<br/>
        #local $to_trace = 1 if main::DEBUG;<br/>
        trace $most_recent, (stat $out)[9] if main::DEBUG &amp;&amp; $to_trace;<br/>
        if ( (stat $out)[9] &lt;= $most_recent ) {<br/>
            #trace &quot;$out:  most recent mod time: &quot;, (stat $out)[9], &quot;, youngest: $most_recent\n&quot; if main::DEBUG &amp;&amp; $to_trace;<br/>
            print &quot;'$out' is too old.\n&quot; if $verbosity &gt;= $VERBOSE;<br/>
            $rebuild = 1;<br/>
            last;<br/>
        }<br/>
    } } if (! $rebuild) {<br/>
    print &quot;Files seem to be ok, not bothering to rebuild.  Add '-w' option to force build\n&quot;;<br/>
    <i>exit</i>(0); } print &quot;Must rebuild tables.\n&quot; if $verbosity &gt;= $VERBOSE;<div class="spacer">
</div>
# Ready to do the major processing.  First create the perl pseudo-property. $perl = Property-&gt;new('perl', Type =&gt; $NON_STRING, Perl_Extension =&gt; 1);<div class="spacer">
</div>
# Process each input file foreach my $file (@input_file_objects) {<br/>
    $file-&gt;run; }<div class="spacer">
</div>
# Finish the table generation.<div class="spacer">
</div>
print &quot;Finishing processing Unicode properties\n&quot; if $verbosity &gt;= $PROGRESS;  <i>finish_Unicode()</i>;<div class="spacer">
</div>
print &quot;Compiling Perl properties\n&quot; if $verbosity &gt;= $PROGRESS;  <i>compile_perl()</i>;<div class="spacer">
</div>
print &quot;Creating Perl synonyms\n&quot; if $verbosity &gt;= $PROGRESS;  <i>add_perl_synonyms()</i>;<div class="spacer">
</div>
print &quot;Writing tables\n&quot; if $verbosity &gt;= $PROGRESS;  <i>write_all_tables()</i>;<div class="spacer">
</div>
# Write mktables.lst if ( $file_list and $make_list ) {<div class="spacer">
</div>
<br/>
    print &quot;Updating '$file_list'\n&quot; if $verbosity &gt;= $PROGRESS;<br/>
    foreach my $file (@input_files, @files_actually_output) {<br/>
        my (undef, $directories, $file) = File::Spec-&gt;splitpath($file);<br/>
        my @directories = File::Spec-&gt;splitdir($directories);<br/>
        $file = join '/', @directories, $file;<br/>
    }<br/>
<br/>
    my $ofh;<br/>
    if (! open $ofh,&quot;&gt;&quot;,$file_list) {<br/>
        Carp::my_carp(&quot;Can't write to '$file_list'.  Skipping: $!&quot;);<br/>
        return<br/>
    }<br/>
    else {<br/>
        my $localtime = localtime $start_time;<br/>
        print $ofh &lt;&lt;&quot;END&quot;;<br/>
#<br/>
# $file_list -- File list for $0.<br/>
#<br/>
#   Autogenerated starting on $start_time ($localtime)<br/>
#   From options $command_line_arguments<br/>
#<br/>
# - First section is input files<br/>
#   ($0 itself is not listed but is automatically considered an input)<br/>
# - Section separator is /^=+\$/<br/>
# - Second section is a list of output files.<br/>
# - Lines matching /^\\s*#/ are treated as comments<br/>
#   which along with blank lines are ignored.<br/>
#<br/>
<div class="spacer">
</div>
# Input files:<div class="spacer">
</div>
END<br/>
        print $ofh &quot;$_\n&quot; for sort(@input_files);<br/>
        print $ofh &quot;\n=================================\n# Output files:\n\n&quot;;<br/>
        print $ofh &quot;$_\n&quot; for sort @files_actually_output;<br/>
        print $ofh &quot;\n# &quot;,scalar(@input_files),&quot; input files\n&quot;,<br/>
                &quot;# &quot;,scalar(@files_actually_output)+1,&quot; output files\n\n&quot;,<br/>
                &quot;# End list\n&quot;;<br/>
        close $ofh<br/>
            or Carp::my_carp(&quot;Failed to close $ofh: $!&quot;);<div class="spacer">
</div>
<br/>
        print &quot;Filelist has &quot;,scalar(@input_files),&quot; input files and &quot;,<br/>
            scalar(@files_actually_output)+1,&quot; output files\n&quot;<br/>
            if $verbosity &gt;= $VERBOSE;<br/>
    }<br/>
}<br/>
<div class="spacer">
</div>
# Output these warnings unless -q explicitly specified. if ($verbosity &gt;= $NORMAL_VERBOSITY &amp;&amp; ! $debug_skip) {<br/>
    if (@unhandled_properties) {<br/>
        print &quot;\nProperties and tables that unexpectedly have no code points\n&quot;;<br/>
        foreach my $property (sort @unhandled_properties) {<br/>
            print $property, &quot;\n&quot;;<br/>
        }<br/>
    }<div class="spacer">
</div>
<br/>
    if (%potential_files) {<br/>
        print &quot;\nInput files that are not considered:\n&quot;;<br/>
        foreach my $file (sort keys %potential_files) {<br/>
            print File::Spec-&gt;abs2rel($file), &quot;\n&quot;;<br/>
        }<br/>
    }<br/>
    print &quot;\nAll done\n&quot; if $verbosity &gt;= $VERBOSE;<br/>
}<br/>
exit(0);<br/>
<div class="spacer">
</div>
# TRAILING CODE IS USED BY <i>make_property_test_script()</i> __DATA__<div class="spacer">
</div>
use strict; use warnings;<div class="spacer">
</div>
# If run outside the normal test suite on an ASCII platform, you can # just create a  <i>latin1_to_native()</i> function that just returns its # inputs, because that's the only function used from test.pl require &quot;test.pl&quot;;<div class="spacer">
</div>
# Test qr/\X/ and the \p{} regular expression constructs.  This file is # constructed by mktables from the tables it generates, so if mktables is # buggy, this won't necessarily catch those bugs.  Tests are generated for all # feasible properties; a few aren't currently feasible; see #  <i>is_code_point_usable()</i> in mktables for details.<div class="spacer">
</div>
# Standard test packages are not used because this manipulates SIG_WARN.  It # exits 0 if every non-skipped test succeeded; -1 if any failed.<div class="spacer">
</div>
my $Tests = 0; my $Fails = 0;<div class="spacer">
</div>
sub Expect($$$$) {<br/>
    my $expected = shift;<br/>
    my $ord = shift;<br/>
    my $regex  = shift;<br/>
    my $warning_type = shift;   # Type of warning message, like 'deprecated'<br/>
                                # or empty if none<br/>
    my $line   = (caller)[2];<div class="spacer">
</div>
<br/>
    # Convert the code point to hex form<br/>
    my $string = sprintf &quot;\&quot;\\x{%04X}\&quot;&quot;, $ord;<br/>
<br/>
    my @tests = &quot;&quot;;<br/>
<br/>
    # The first time through, use all warnings.  If the input should generate<br/>
    # a warning, add another time through with them turned off<br/>
    push @tests, &quot;no warnings '$warning_type';&quot; if $warning_type;<br/>
<br/>
    foreach my $no_warnings (@tests) {<br/>
<br/>
        # Store any warning messages instead of outputting them<br/>
        local $SIG{__WARN__} = $SIG{__WARN__};<br/>
        my $warning_message;<br/>
        $SIG{__WARN__} = sub { $warning_message = $_[0] };<br/>
<br/>
        $Tests++;<br/>
<br/>
        # A string eval is needed because of the 'no warnings'.<br/>
        # Assumes no parens in the regular expression<br/>
        my $result = eval &quot;$no_warnings<br/>
                            my \$RegObj = qr($regex);<br/>
                            $string =~ \$RegObj ? 1 : 0&quot;;<br/>
        if (not defined $result) {<br/>
            print &quot;not ok $Tests - couldn't compile /$regex/; line $line: $@\n&quot;;<br/>
            $Fails++;<br/>
        }<br/>
        elsif ($result ^ $expected) {<br/>
            print &quot;not ok $Tests - expected $expected but got $result for $string =~ qr/$regex/; line $line\n&quot;;<br/>
            $Fails++;<br/>
        }<br/>
        elsif ($warning_message) {<br/>
            if (! $warning_type || ($warning_type &amp;&amp; $no_warnings)) {<br/>
                print &quot;not ok $Tests - for qr/$regex/ did not expect warning message '$warning_message'; line $line\n&quot;;<br/>
                $Fails++;<br/>
            }<br/>
            else {<br/>
                print &quot;ok $Tests - expected and got a warning message for qr/$regex/; line $line\n&quot;;<br/>
            }<br/>
        }<br/>
        elsif ($warning_type &amp;&amp; ! $no_warnings) {<br/>
            print &quot;not ok $Tests - for qr/$regex/ expected a $warning_type warning message, but got none; line $line\n&quot;;<br/>
            $Fails++;<br/>
        }<br/>
        else {<br/>
            print &quot;ok $Tests - got $result for $string =~ qr/$regex/; line $line\n&quot;;<br/>
        }<br/>
    }<br/>
    return;<br/>
}<br/>
<div class="spacer">
</div>
sub Error($) {<br/>
    my $regex  = shift;<br/>
    $Tests++;<br/>
    if (eval { 'x' =~ qr/$regex/; 1 }) {<br/>
        $Fails++;<br/>
        my $line = (caller)[2];<br/>
        print &quot;not ok $Tests - re compiled ok, but expected error for qr/$regex/; line $line: $@\n&quot;;<br/>
    }<br/>
    else {<br/>
        my $line = (caller)[2];<br/>
        print &quot;ok $Tests - got and expected error for qr/$regex/; line $line\n&quot;;<br/>
    }<br/>
    return; }<div class="spacer">
</div>
# GCBTest.txt character that separates grapheme clusters my $breakable_utf8 = my $breakable = chr(utf8::unicode_to_native(0xF7)); utf8::upgrade($breakable_utf8);<div class="spacer">
</div>
# GCBTest.txt character that indicates that the adjoining code points are part # of the same grapheme cluster my $nobreak_utf8 = my $nobreak = chr(utf8::unicode_to_native(0xD7)); utf8::upgrade($nobreak_utf8);<div class="spacer">
</div>
sub Test_X($) {<br/>
    # Test qr/\X/ matches.  The input is a line from auxiliary/GCBTest.txt<br/>
    # Each such line is a sequence of code points given by their hex numbers,<br/>
    # separated by the two characters defined just before this subroutine that<br/>
    # indicate that either there can or cannot be a break between the adjacent<br/>
    # code points.  If there isn't a break, that means the sequence forms an<br/>
    # extended grapheme cluster, which means that \X should match the whole<br/>
    # thing.  If there is a break, \X should stop there.  This is all<br/>
    # converted by this routine into a match:<br/>
    #   $string =~ /(\X)/,<br/>
    # Each \X should match the next cluster; and that is what is checked.<div class="spacer">
</div>
<br/>
    my $template = shift;<br/>
<br/>
    my $line   = (caller)[2];<br/>
<br/>
    # The line contains characters above the ASCII range, but in Latin1.  It<br/>
    # may or may not be in utf8, and if it is, it may or may not know it.  So,<br/>
    # convert these characters to 8 bits.  If knows is in utf8, simply<br/>
    # downgrade.<br/>
    if (utf8::is_utf8($template)) {<br/>
        utf8::downgrade($template);<br/>
    } else {<br/>
<br/>
        # Otherwise, if it is in utf8, but doesn't know it, the next lines<br/>
        # convert the two problematic characters to their 8-bit equivalents.<br/>
        # If it isn't in utf8, they don't harm anything.<br/>
        use bytes;<br/>
        $template =~ s/$nobreak_utf8/$nobreak/g;<br/>
        $template =~ s/$breakable_utf8/$breakable/g;<br/>
    }<br/>
<br/>
    # Get rid of the leading and trailing breakables<br/>
    $template =~ s/^ \s* $breakable \s* //x;<br/>
    $template =~ s/ \s* $breakable \s* $ //x;<br/>
<br/>
    # And no-breaks become just a space.<br/>
    $template =~ s/ \s* $nobreak \s* / /xg;<br/>
<br/>
    # Split the input into segments that are breakable between them.<br/>
    my @segments = split /\s*$breakable\s*/, $template;<br/>
<br/>
    my $string = &quot;&quot;;<br/>
    my $display_string = &quot;&quot;;<br/>
    my @should_match;<br/>
    my @should_display;<br/>
<br/>
    # Convert the code point sequence in each segment into a Perl string of<br/>
    # characters<br/>
    foreach my $segment (@segments) {<br/>
        my @code_points = split /\s+/, $segment;<br/>
        my $this_string = &quot;&quot;;<br/>
        my $this_display = &quot;&quot;;<br/>
        foreach my $code_point (@code_points) {<br/>
            $this_string .= latin1_to_native(chr(hex $code_point));<br/>
            $this_display .= &quot;\\x{$code_point}&quot;;<br/>
        }<br/>
<br/>
        # The next cluster should match the string in this segment.<br/>
        push @should_match, $this_string;<br/>
        push @should_display, $this_display;<br/>
        $string .= $this_string;<br/>
        $display_string .= $this_display;<br/>
    }<br/>
<br/>
    # If a string can be represented in both non-ut8 and utf8, test both cases<br/>
    UPGRADE:<br/>
    for my $to_upgrade (0 .. 1) {<br/>
<br/>
        if ($to_upgrade) {<br/>
<br/>
            # If already in utf8, would just be a repeat<br/>
            next UPGRADE if utf8::is_utf8($string);<br/>
<br/>
            utf8::upgrade($string);<br/>
        }<br/>
<br/>
        # Finally, do the \X match.<br/>
        my @matches = $string =~ /(\X)/g;<br/>
<br/>
        # Look through each matched cluster to verify that it matches what we<br/>
        # expect.<br/>
        my $min = (@matches &lt; @should_match) ? @matches : @should_match;<br/>
        for my $i (0 .. $min - 1) {<br/>
            $Tests++;<br/>
            if ($matches[$i] eq $should_match[$i]) {<br/>
                print &quot;ok $Tests - &quot;;<br/>
                if ($i == 0) {<br/>
                    print &quot;In \&quot;$display_string\&quot; =~ /(\\X)/g, \\X #1&quot;;<br/>
                } else {<br/>
                    print &quot;And \\X #&quot;, $i + 1,<br/>
                }<br/>
                print &quot; correctly matched $should_display[$i]; line $line\n&quot;;<br/>
            } else {<br/>
                $matches[$i] = join(&quot;&quot;, map { sprintf &quot;\\x{%04X}&quot;, $_ }<br/>
                                                    unpack(&quot;U*&quot;, $matches[$i]));<br/>
                print &quot;not ok $Tests - In \&quot;$display_string\&quot; =~ /(\\X)/g, \\X #&quot;,<br/>
                    $i + 1,<br/>
                    &quot; should have matched $should_display[$i]&quot;,<br/>
                    &quot; but instead matched $matches[$i]&quot;,<br/>
                    &quot;.  Abandoning rest of line $line\n&quot;;<br/>
                next UPGRADE;<br/>
            }<br/>
        }<br/>
<br/>
        # And the number of matches should equal the number of expected matches.<br/>
        $Tests++;<br/>
        if (@matches == @should_match) {<br/>
            print &quot;ok $Tests - Nothing was left over; line $line\n&quot;;<br/>
        } else {<br/>
            print &quot;not ok $Tests - There were &quot;, scalar @should_match, &quot; \\X matches expected, but got &quot;, scalar @matches, &quot; instead; line $line\n&quot;;<br/>
        }<br/>
    }<br/>
<br/>
    return;<br/>
}<br/>
<div class="spacer">
</div>
sub <i>Finished()</i> {<br/>
    print &quot;1..$Tests\n&quot;;<br/>
    exit($Fails ? -1 : 0); }<div class="spacer">
</div>
Error('\p{Script=InGreek}');    # Bug #69018 Test_X(&quot;1100 $nobreak 1161&quot;);  # Bug #70940 Expect(0, 0x2028, '\p{Print}', &quot;&quot;); # Bug # 71722 Expect(0, 0x2029, '\p{Print}', &quot;&quot;); # Bug # 71722 Expect(1, 0xFF10, '\p{XDigit}', &quot;&quot;); # Bug # 71726</div>
<table class="foot">
<tr>
<td class="foot-date">
2014-11-17</td>
<td class="foot-os">
perl v5.20.2</td>
</tr>
</table>
</div>
</body>
</html>

