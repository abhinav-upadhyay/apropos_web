<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
PCAP_OPEN_LIVE(3)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">pcap_open_live</b>, <b class="name">pcap_open_offline</b>, <b class="name">pcap_dump_open</b>, <b class="name">pcap_dump_fopen</b>, <b class="name">pcap_lookupdev</b>, <b class="name">pcap_lookupnet</b>, <b class="name">pcap_dispatch</b>, <b class="name">pcap_loop</b>, <b class="name">pcap_dump</b>, <b class="name">pcap_inject</b>, <b class="name">pcap_sendpacket</b>, <b class="name">pcap_compile</b>, <b class="name">pcap_setfilter</b>, <b class="name">pcap_freecode</b>, <b class="name">pcap_next</b>, <b class="name">pcap_next_ex</b>, <b class="name">pcap_setdirection</b>, <b class="name">pcap_datalink</b>, <b class="name">pcap_snapshot</b>, <b class="name">pcap_is_swapped</b>, <b class="name">pcap_major_version</b>, <b class="name">pcap_minor_version</b>, <b class="name">pcap_stats</b>, <b class="name">pcap_file</b>, <b class="name">pcap_fileno</b>, <b class="name">pcap_get_selectable_fd</b>, <b class="name">pcap_perror</b>, <b class="name">pcap_geterr</b>, <b class="name">pcap_strerror</b>, <b class="name">pcap_close</b>, <b class="name">pcap_dump_file</b>, <b class="name">pcap_dump_ftell</b>, <b class="name">pcap_dump_flush</b>, <b class="name">pcap_dump_close</b>, <b class="name">pcap_breakloop</b>, <b class="name">pcap_findalldevs</b>, <b class="name">pcap_freealldevs</b>, <b class="name">pcap_getnonblock</b>, <b class="name">pcap_setnonblock</b>, <b class="name">pcap_set_datalink</b>, <b class="name">pcap_list_datalinks</b>, <b class="name">pcap_free_datalinks</b>, <b class="name">pcap_open_dead</b>, <b class="name">pcap_fopen_offline</b>, <b class="name">pcap_lib_version</b>, <b class="name">pcap_datalink_val_to_name</b>, <b class="name">pcap_datalink_val_to_description</b>, <b class="name">pcap_datalink_name_to_val</b>, <b class="name">pcap_create</b>, <b class="name">pcap_set_snaplen</b>, <b class="name">pcap_set_promisc</b>, <b class="name">pcap_can_set_rfmon</b>, <b class="name">pcap_set_rfmon</b>, <b class="name">pcap_set_timeout</b>, <b class="name">pcap_set_buffer_size</b>, <b class="name">pcap_activate</b>, <b class="name">pcap_statustostr</b>, <b class="name">pcap_offline_filter</b> &#8212; <span class="desc">Packet Capture library</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">pcap.h</a>&gt;</b><div class="spacer">
</div>
<i class="ftype">pcap_t *</i><br/>
<b class="fname">pcap_open_live</b>(<i class="farg" style="white-space:nowrap;">const char *source</i>, <i class="farg" style="white-space:nowrap;">int snaplen</i>, <i class="farg" style="white-space:nowrap;">int promisc</i>, <i class="farg" style="white-space:nowrap;">int to_ms</i>, <i class="farg" style="white-space:nowrap;">char *errbuf</i>);<div class="spacer">
</div>
<i class="ftype">pcap_t *</i><br/>
<b class="fname">pcap_open_offline</b>(<i class="farg" style="white-space:nowrap;">char *fname</i>, <i class="farg" style="white-space:nowrap;">char *errbuf</i>);<div class="spacer">
</div>
<i class="ftype">pcap_dumper_t *</i><br/>
<b class="fname">pcap_dump_open</b>(<i class="farg" style="white-space:nowrap;">pcap_t *p</i>, <i class="farg" style="white-space:nowrap;">char *fname</i>);<div class="spacer">
</div>
<i class="ftype">pcap_dumper_t *</i><br/>
<b class="fname">pcap_dump_fopen</b>(<i class="farg" style="white-space:nowrap;">pcap_t *p</i>, <i class="farg" style="white-space:nowrap;">FILE *f</i>);<div class="spacer">
</div>
<i class="ftype">char *</i><br/>
<b class="fname">pcap_lookupdev</b>(<i class="farg" style="white-space:nowrap;">char *errbuf</i>);<div class="spacer">
</div>
<i class="ftype">uint</i><br/>
<b class="fname">pcap_lookupnet</b>(<i class="farg" style="white-space:nowrap;">const char *device</i>, <i class="farg" style="white-space:nowrap;">bpf_u_int32 *netp</i>, <i class="farg" style="white-space:nowrap;">bpf_u_int32 *maskp</i>, <i class="farg" style="white-space:nowrap;">char *errbuf</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">pcap_dispatch</b>(<i class="farg" style="white-space:nowrap;">pcap_t *p</i>, <i class="farg" style="white-space:nowrap;">int cnt</i>, <i class="farg" style="white-space:nowrap;">pcap_handler callback</i>, <i class="farg" style="white-space:nowrap;">u_char *user</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">pcap_loop</b>(<i class="farg" style="white-space:nowrap;">pcap_t *p</i>, <i class="farg" style="white-space:nowrap;">int cnt</i>, <i class="farg" style="white-space:nowrap;">pcap_handler callback</i>, <i class="farg" style="white-space:nowrap;">u_char *user</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">pcap_dump</b>(<i class="farg" style="white-space:nowrap;">u_char *user</i>, <i class="farg" style="white-space:nowrap;">const struct pcap_pkthdr *h</i>, <i class="farg" style="white-space:nowrap;">const u_char *sp</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">pcap_inject</b>(<i class="farg" style="white-space:nowrap;">pcap_t *p</i>, <i class="farg" style="white-space:nowrap;">const void *buf</i>, <i class="farg" style="white-space:nowrap;">size_t len</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">pcap_sendpacket</b>(<i class="farg" style="white-space:nowrap;">pcap_t *p</i>, <i class="farg" style="white-space:nowrap;">const u_char *buf</i>, <i class="farg" style="white-space:nowrap;">int size</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">pcap_compile</b>(<i class="farg" style="white-space:nowrap;">pcap_t *p</i>, <i class="farg" style="white-space:nowrap;">struct bpf_program *program</i>, <i class="farg" style="white-space:nowrap;">char *buf</i>, <i class="farg" style="white-space:nowrap;">int optimize</i>, <i class="farg" style="white-space:nowrap;">bpf_u_int32 netmask</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">pcap_setfilter</b>(<i class="farg" style="white-space:nowrap;">pcap_t *p</i>, <i class="farg" style="white-space:nowrap;">struct bpf_program *fp</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">pcap_freecode</b>(<i class="farg" style="white-space:nowrap;">struct bpf_program *program</i>);<div class="spacer">
</div>
<i class="ftype">u_char *</i><br/>
<b class="fname">pcap_next</b>(<i class="farg" style="white-space:nowrap;">pcap_t *p</i>, <i class="farg" style="white-space:nowrap;">struct pcap_pkthdr *h</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">pcap_next_ex</b>(<i class="farg" style="white-space:nowrap;">pcap_t *p</i>, <i class="farg" style="white-space:nowrap;">struct pcap_pkthdr **pkt_header</i>, <i class="farg" style="white-space:nowrap;">const u_char **pkt_data</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">pcap_setdirection</b>(<i class="farg" style="white-space:nowrap;">pcap_t *p</i>, <i class="farg" style="white-space:nowrap;">pcap_direction_t d</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">pcap_datalink</b>(<i class="farg" style="white-space:nowrap;">pcap_t *p</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">pcap_snapshot</b>(<i class="farg" style="white-space:nowrap;">pcap_t *p</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">pcap_is_swapped</b>(<i class="farg" style="white-space:nowrap;">pcap_t *p</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">pcap_major_version</b>(<i class="farg" style="white-space:nowrap;">pcap_t *p</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">pcap_minor_version</b>(<i class="farg" style="white-space:nowrap;">pcap_t *p</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">pcap_stats</b>(<i class="farg" style="white-space:nowrap;">pcap_t *p</i>, <i class="farg" style="white-space:nowrap;">struct pcap_stat *ps</i>);<div class="spacer">
</div>
<i class="ftype">FILE *</i><br/>
<b class="fname">pcap_file</b>(<i class="farg" style="white-space:nowrap;">pcap_t *p</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">pcap_fileno</b>(<i class="farg" style="white-space:nowrap;">pcap_t *p</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">pcap_get_selectable_fd</b>(<i class="farg" style="white-space:nowrap;">pcap_t *p</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">pcap_perror</b>(<i class="farg" style="white-space:nowrap;">pcap_t *p</i>, <i class="farg" style="white-space:nowrap;">char *prefix</i>);<div class="spacer">
</div>
<i class="ftype">char *</i><br/>
<b class="fname">pcap_geterr</b>(<i class="farg" style="white-space:nowrap;">pcap_t *p</i>);<div class="spacer">
</div>
<i class="ftype">char *</i><br/>
<b class="fname">pcap_strerror</b>(<i class="farg" style="white-space:nowrap;">int errnum</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">pcap_close</b>(<i class="farg" style="white-space:nowrap;">pcap_t *p</i>);<div class="spacer">
</div>
<i class="ftype">FILE *</i><br/>
<b class="fname">pcap_dump_file</b>(<i class="farg" style="white-space:nowrap;">pcap_dumper_t *p</i>);<div class="spacer">
</div>
<i class="ftype">long</i><br/>
<b class="fname">pcap_dump_ftell</b>(<i class="farg" style="white-space:nowrap;">pcap_dumper_t *p</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">pcap_dump_flush</b>(<i class="farg" style="white-space:nowrap;">pcap_dumper_t *p</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">pcap_dump_close</b>(<i class="farg" style="white-space:nowrap;">pcap_dumper_t *p</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">pcap_breakloop</b>(<i class="farg" style="white-space:nowrap;">pcap_t *p</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">pcap_findalldevs</b>(<i class="farg" style="white-space:nowrap;">pcap_if_t **alldevsp</i>, <i class="farg" style="white-space:nowrap;">char *errbuf</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">pcap_freealldevs</b>(<i class="farg" style="white-space:nowrap;">pcap_if_t *alldevs</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">pcap_getnonblock</b>(<i class="farg" style="white-space:nowrap;">pcap_t *p</i>, <i class="farg" style="white-space:nowrap;">char *errbuf</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">pcap_setnonblock</b>(<i class="farg" style="white-space:nowrap;">pcap_t *p</i>, <i class="farg" style="white-space:nowrap;">int nonblock</i>, <i class="farg" style="white-space:nowrap;">char *errbuf</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">pcap_set_datalink</b>(<i class="farg" style="white-space:nowrap;">pcap_t *p</i>, <i class="farg" style="white-space:nowrap;">int dlt</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">pcap_list_datalinks</b>(<i class="farg" style="white-space:nowrap;">pcap_t *p</i>, <i class="farg" style="white-space:nowrap;">int **dlt_buffer</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">pcap_free_datalinks</b>(<i class="farg" style="white-space:nowrap;">int *dlt_list</i>);<div class="spacer">
</div>
<i class="ftype">pcap_t</i><br/>
<b class="fname">pcap_open_dead</b>(<i class="farg" style="white-space:nowrap;">int linktype</i>, <i class="farg" style="white-space:nowrap;">int snaplen</i>);<div class="spacer">
</div>
<i class="ftype">pcap_t</i><br/>
<b class="fname">pcap_fopen_offline</b>(<i class="farg" style="white-space:nowrap;">FILE *fp</i>, <i class="farg" style="white-space:nowrap;">char *errbuf</i>);<div class="spacer">
</div>
<i class="ftype">const char *</i><br/>
<b class="fname">pcap_lib_version</b>(<i class="farg" style="white-space:nowrap;">void</i>);<div class="spacer">
</div>
<i class="ftype">const char *</i><br/>
<b class="fname">pcap_datalink_val_to_name</b>(<i class="farg" style="white-space:nowrap;">int dlt</i>);<div class="spacer">
</div>
<i class="ftype">const char *</i><br/>
<b class="fname">pcap_datalink_val_to_description</b>(<i class="farg" style="white-space:nowrap;">int dlt</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">pcap_datalink_name_to_val</b>(<i class="farg" style="white-space:nowrap;">const char *name</i>);<div class="spacer">
</div>
<i class="ftype">pcap_t *</i><br/>
<b class="fname">pcap_create</b>(<i class="farg" style="white-space:nowrap;">const char *device</i>, <i class="farg" style="white-space:nowrap;">char *errbuf</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">pcap_set_snaplen</b>(<i class="farg" style="white-space:nowrap;">pcap_t *p</i>, <i class="farg" style="white-space:nowrap;">int snaplen</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">pcap_set_promisc</b>(<i class="farg" style="white-space:nowrap;">pcap_t *p</i>, <i class="farg" style="white-space:nowrap;">int promisc</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">pcap_can_set_rfmon</b>(<i class="farg" style="white-space:nowrap;">pcap_t *p</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">pcap_set_rfmon</b>(<i class="farg" style="white-space:nowrap;">pcap_t *p</i>, <i class="farg" style="white-space:nowrap;">int rfmon</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">pcap_set_timeout</b>(<i class="farg" style="white-space:nowrap;">pcap_t *p</i>, <i class="farg" style="white-space:nowrap;">int timeout_ms</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">pcap_set_buffer_size</b>(<i class="farg" style="white-space:nowrap;">pcap_t *p</i>, <i class="farg" style="white-space:nowrap;">int buffer_size</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">pcap_activate</b>(<i class="farg" style="white-space:nowrap;">pcap_t *p</i>);<div class="spacer">
</div>
<i class="ftype">const char *</i><br/>
<b class="fname">pcap_statustostr</b>(<i class="farg" style="white-space:nowrap;">int errnum</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">pcap_offline_filter</b>(<i class="farg" style="white-space:nowrap;">const struct bpf_program *</i>, <i class="farg" style="white-space:nowrap;">const struct pcap_pkthdr *</i>, <i class="farg" style="white-space:nowrap;">const u_char *</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> <b class="name">pcap_open_live</b> provides a high level interface to packet capture systems. All packets on the network, even those destined for other hosts, are accessible through this mechanism.<div class="spacer">
</div>
Note that <i class="farg">errbuf</i> in <b class="fname">pcap_open_live</b>(), <b class="fname">pcap_open_offline</b>(), <b class="fname">pcap_findalldevs</b>(), <b class="fname">pcap_lookupdev</b>(), <b class="fname">pcap_lookupnet</b>(), <b class="fname">pcap_getnonblock</b>(), <b class="fname">pcap_setnonblock</b>(), <b class="fname">pcap_fopen_offline</b>(), and <b class="fname">pcap_create</b>() is assumed to be able to hold at least <span class="define">PCAP_ERRBUF_SIZE</span> chars.<div class="spacer">
</div>
<b class="fname">pcap_open_live</b>() is used to obtain a packet capture descriptor to look at packets on the network. <i class="farg">source</i> is a string that specifies the network device to open. <i class="farg">snaplen</i> specifies the maximum number of bytes to capture from one packet. <i class="farg">promisc</i> specifies if the interface is to be put into promiscuous mode. (Note that even if this parameter is false, the interface could well be in promiscuous mode for some other reason.) <i class="farg">to_ms</i> specifies the read timeout in milliseconds. <i class="farg">errbuf</i> is used to return error text and is only set when <b class="fname">pcap_open_live</b>() fails and returns <span class="define">NULL</span>.<div class="spacer">
</div>
<b class="fname">pcap_open_offline</b>() is called to open a &#8220;savefile&#8221; for reading. <i class="farg">fname</i> specifies the name of the file to open. The file has the same format as those used by <a class="link-man" href="../html8/tcpdump.html">tcpdump(8)</a>. The name &#8216;<code class="lit">-</code>&#8217; is a synonym for <span class="define">stdin</span>. <i class="farg">errbuf</i> is used to return error text and is only set when <b class="fname">pcap_open_offline</b>() fails and returns <span class="define">NULL</span>.<div class="spacer">
</div>
<b class="fname">pcap_dump_open</b>() is called to open a &#8220;savefile&#8221; for writing. The name &#8216;<code class="lit">-</code>&#8217; is a synonym for <span class="define">stdout</span>. <span class="define">NULL</span> is returned on failure. <i class="farg">p</i> is a <i class="farg">pcap</i> struct as returned by <b class="fname">pcap_open_offline</b>() or <b class="fname">pcap_open_live</b>(). <i class="farg">fname</i> specifies the name of the file to open. If <span class="define">NULL</span> is returned, <b class="fname">pcap_geterr</b>() can be used to get the error text.<div class="spacer">
</div>
<b class="fname">pcap_dump_fopen</b>() allows the use of savefile functions on the already-opened stream <i class="farg">f</i>.<div class="spacer">
</div>
<b class="fname">pcap_lookupdev</b>() returns a pointer to a network device suitable for use with <b class="fname">pcap_open_live</b>() and <b class="fname">pcap_lookupnet</b>(). If there is an error, <span class="define">NULL</span> is returned and <i class="farg">errbuf</i> is filled in with an appropriate error message.<div class="spacer">
</div>
<b class="fname">pcap_lookupnet</b>() is used to determine the network number and mask associated with the network device <i class="farg">device</i>. Both <i class="farg">netp</i> and <i class="farg">maskp</i> are <i class="farg">bpf_u_int32</i> pointers. A return of -1 indicates an error in which case <i class="farg">errbuf</i> is filled in with an appropriate error message.<div class="spacer">
</div>
<b class="fname">pcap_dispatch</b>() is used to collect and process packets. <i class="farg">cnt</i> specifies the maximum number of packets to process before returning. A <i class="farg">cnt</i> of -1 processes all the packets received in one buffer. A <i class="farg">cnt</i> of 0 processes all packets until an error occurs, EOF is reached, or the read times out (when doing live reads and a non-zero read timeout is specified). <i class="farg">callback</i> specifies a routine to be called with three arguments: a <i class="farg">u_char</i> pointer which is passed in from <b class="fname">pcap_dispatch</b>(), a pointer to the <i class="farg">pcap_pkthdr</i> struct (which precedes the actual network headers and data), and a <i class="farg">u_char</i> pointer to the packet data. The number of packets read is returned. Zero is returned when EOF is reached in a savefile. A return of -1 indicates an error in which case <b class="fname">pcap_perror</b>() or <b class="fname">pcap_geterr</b>() may be used to display the error text.<div class="spacer">
</div>
<b class="fname">pcap_dump</b>() outputs a packet to the savefile opened with <b class="fname">pcap_dump_open</b>(). Note that its calling arguments are suitable for use with <b class="fname">pcap_dispatch</b>().<div class="spacer">
</div>
<b class="fname">pcap_inject</b>() uses <a class="link-man" href="../html2/write.html">write(2)</a> to inject a raw packet through the network interface. It returns the number of bytes written or -1 on failure.<div class="spacer">
</div>
<b class="fname">pcap_sendpacket</b>() is an alternate interface for packet injection (provided for compatibility). It returns 0 on success or -1 on failure.<div class="spacer">
</div>
<b class="fname">pcap_compile</b>() is used to compile the string <i class="farg">buf</i> into a filter program. <i class="farg">program</i> is a pointer to a <i class="farg">bpf_program</i> struct and is filled in by <b class="fname">pcap_compile</b>(). <i class="farg">optimize</i> controls whether optimization on the resulting code is performed. <i class="farg">netmask</i> specifies the netmask of the local net.<div class="spacer">
</div>
<b class="fname">pcap_setfilter</b>() is used to specify a filter program. <i class="farg">fp</i> is a pointer to an array of <i class="farg">bpf_program</i> struct, usually the result of a call to <b class="fname">pcap_compile</b>(). -1 is returned on failure; 0 is returned on success.<div class="spacer">
</div>
<b class="fname">pcap_freecode</b>() is used to free up allocated memory pointed to by a <i class="farg">bpf_program</i> struct generated by <b class="fname">pcap_compile</b>() when that BPF program is no longer needed, for example after it has been made the filter program for a pcap structure by a call to <b class="fname">pcap_setfilter</b>().<div class="spacer">
</div>
<b class="fname">pcap_loop</b>() is similar to <b class="fname">pcap_dispatch</b>() except it keeps reading packets until <i class="farg">cnt</i> packets are processed or an error occurs. It does <span class="emph">not</span> return when live read timeouts occur. Rather, specifying a non-zero read timeout to <b class="fname">pcap_open_live</b>() and then calling <b class="fname">pcap_loop</b>() allows the reception and processing of any packets that arrive when the timeout occurs. A negative <i class="farg">cnt</i> causes <b class="fname">pcap_loop</b>() to loop forever (or at least until an error occurs). <b class="fname">pcap_loop</b>() may be terminated early through an explicit call to <b class="fname">pcap_breakloop</b>(). In this case, the return value of <b class="fname">pcap_loop</b>() will be -2.<div class="spacer">
</div>
<b class="fname">pcap_next</b>() returns a <i class="farg">u_char</i> pointer to the next packet.<div class="spacer">
</div>
<b class="fname">pcap_next_ex</b>() reads the next packet and returns a success/failure indication: a return value of 1 indicates success, 0 means that the timeout was exceeded on a live capture, -1 indicates that an error occurred whilst reading the packet and -2 is returned when there are no more packets to read in a savefile.<div class="spacer">
</div>
<b class="fname">pcap_datalink</b>() returns the link layer type, e.g., DLT_EN10MB.<div class="spacer">
</div>
<b class="fname">pcap_snapshot</b>() returns the snapshot length specified when <b class="fname">pcap_open_live</b>() was called.<div class="spacer">
</div>
<b class="fname">pcap_is_swapped</b>() returns true if the current savefile uses a different byte order than the current system.<div class="spacer">
</div>
<b class="fname">pcap_major_version</b>() returns the major number of the version of the pcap used to write the savefile.<div class="spacer">
</div>
<b class="fname">pcap_minor_version</b>() returns the minor number of the version of the pcap used to write the savefile.<div class="spacer">
</div>
<b class="fname">pcap_file</b>() returns the stream associated with the savefile.<div class="spacer">
</div>
<b class="fname">pcap_stats</b>() returns 0 and fills in a <i class="farg">pcap_stat</i> struct. The values represent packet statistics from the start of the run to the time of the call. If there is an error or the underlying packet capture doesn't support packet statistics, -1 is returned and the error text can be obtained with <b class="fname">pcap_perror</b>() or <b class="fname">pcap_geterr</b>().<div class="spacer">
</div>
<b class="fname">pcap_fileno</b>() and <b class="fname">pcap_get_selectable_fd</b>() return the file descriptor number of the savefile.<div class="spacer">
</div>
<b class="fname">pcap_perror</b>() prints the text of the last pcap library error on <span class="define">stderr</span>, prefixed by <i class="farg">prefix</i>.<div class="spacer">
</div>
<b class="fname">pcap_geterr</b>() returns the error text pertaining to the last pcap library error.<div class="spacer">
</div>
<b class="fname">pcap_strerror</b>() is provided in case <a class="link-man" href="../html3/strerror.html">strerror(3)</a> isn't available.<div class="spacer">
</div>
<b class="fname">pcap_close</b>() closes the files associated with <i class="farg">p</i> and deallocates resources.<div class="spacer">
</div>
<b class="fname">pcap_dump_file</b>() returns the stream associated with a savefile.<div class="spacer">
</div>
<b class="fname">pcap_dump_ftell</b>() returns the current file offset within a savefile.<div class="spacer">
</div>
<b class="fname">pcap_dump_flush</b>() ensures that any buffered data has been written to a savefile.<div class="spacer">
</div>
<b class="fname">pcap_dump_close</b>() closes the savefile.<div class="spacer">
</div>
<b class="fname">pcap_findalldevs</b>() constructs a linked list of network devices that are suitable for opening with <b class="fname">pcap_open_live</b>().<div class="spacer">
</div>
<b class="fname">pcap_freealldevs</b>() frees a list of interfaces built by <b class="fname">pcap_findalldevs</b>().<div class="spacer">
</div>
<b class="fname">pcap_getnonblock</b>() returns 1 if the capture file descriptor is in non-blocking mode, 0 if it is in blocking mode, or -1 on error.<div class="spacer">
</div>
<b class="fname">pcap_setnonblock</b>() sets or resets non-blocking mode on a capture file descriptor.<div class="spacer">
</div>
<b class="fname">pcap_set_datalink</b>() sets the datalink type on a live capture device that supports multiple datalink types.<div class="spacer">
</div>
<b class="fname">pcap_setdirection</b>() is used to limit the direction that packets must be flowing in order to be captured.<div class="spacer">
</div>
<b class="fname">pcap_list_datalinks</b>() returns an array of the supported datalink types for an opened live capture device as a -1 terminated array. It is the caller's responsibility to free this list with <b class="fname">pcap_free_datalinks</b>(), which frees the list of link-layer header types pointed to by <span class="define">dlt_list</span>.<div class="spacer">
</div>
<b class="fname">pcap_breakloop</b>() safely breaks out of a <b class="fname">pcap_loop</b>(). This function sets an internal flag and is safe to be called from inside a signal handler.<div class="spacer">
</div>
<b class="fname">pcap_open_dead</b>() is used for creating a pcap_t structure to use when calling the other functions in libpcap. It is typically used when just using libpcap for compiling BPF code.<div class="spacer">
</div>
<b class="fname">pcap_fopen_offline</b>() may be used to read dumped data from an existing open stream <i class="farg">fp</i>.<div class="spacer">
</div>
<b class="fname">pcap_lib_version</b>() returns a string describing the version of libpcap.<div class="spacer">
</div>
<b class="fname">pcap_datalink_val_to_name</b>() and <b class="fname">pcap_datalink_val_to_description</b>() look up the name or description of a datalink type by number. These functions return <span class="define">NULL</span> if the specified datalink type is not known. <b class="fname">pcap_datalink_name_to_val</b>() finds the datalink number for a given datalink name. Returns -1 if the name is not known.<div class="spacer">
</div>
<b class="fname">pcap_create</b>() is used to create a packet capture handle to look at packets on the network. The returned handle must be activated with <b class="fname">pcap_activate</b>() before packets can be captured with it; options for the capture, such as promiscuous mode, can be set on the handle before activating it.<div class="spacer">
</div>
<b class="fname">pcap_set_snaplen</b>() sets the snapshot length to be used on a capture handle when the handle is activated to <i class="farg">snaplen</i>.<div class="spacer">
</div>
<b class="fname">pcap_set_promisc</b>() sets whether promiscuous mode should be set on a capture handle when the handle is activated. If <i class="farg">promisc</i> is non-zero, promiscuous mode will be set, otherwise it will not be set.<div class="spacer">
</div>
<b class="fname">pcap_can_set_rfmon</b>() checks whether monitor mode could be set on a capture handle when the handle is activated.<div class="spacer">
</div>
<b class="fname">pcap_set_rfmon</b>() sets whether monitor mode should be set on a capture handle when the handle is activated. If <i class="farg">rfmon</i> is non-zero, monitor mode will be set, otherwise it will not be set.<div class="spacer">
</div>
<b class="fname">pcap_set_timeout</b>() sets the read timeout that will be used on a capture handle when the handle is activated to <i class="farg">to_ms</i>, which is in units of milliseconds.<div class="spacer">
</div>
<b class="fname">pcap_set_buffer_size</b>() sets the buffer size that will be used on a capture handle when the handle is activated to <i class="farg">buffer_size</i>, which is in units of bytes.<div class="spacer">
</div>
<b class="fname">pcap_activate</b>() is used to activate a packet capture handle to look at packets on the network, with the options that were set on the handle being in effect.<div class="spacer">
</div>
<b class="fname">pcap_statustostr</b>() converts a PCAP_ERROR_ or PCAP_WARNING_ value returned by a libpcap routine to an error string.<div class="spacer">
</div>
<b class="fname">pcap_offline_filter</b>() checks whether a filter matches a packet.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html3/pcap-filter.html">pcap-filter(3)</a>, <a class="link-man" href="../html8/tcpdump.html">tcpdump(8)</a></div>
<div class="section">
<h1 id="x415554484f5253">AUTHORS</h1> <span class="author">Van Jacobson</span>, <span class="author">Craig Leres</span>, and <span class="author">Steven McCanne</span>, all of the Lawrence Berkeley National Laboratory, University of California, Berkeley, CA.</div>
</div>
</body>
</html>

