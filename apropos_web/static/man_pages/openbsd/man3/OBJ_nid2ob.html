<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
OBJ_NID2OBJ(3)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
OBJ_NID2OBJ(3)</td>
<td class="head-vol">
OpenSSL</td>
<td class="head-rtitle">
OBJ_NID2OBJ(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> OBJ_nid2obj, OBJ_nid2ln, OBJ_nid2sn, OBJ_obj2nid, OBJ_txt2nid, OBJ_ln2nid, OBJ_sn2nid, OBJ_cmp, OBJ_dup, OBJ_txt2obj, OBJ_obj2txt, OBJ_create, OBJ_cleanup - ASN1 object utility functions</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
 #include &lt;openssl/objects.h&gt;<br/>
<br/>
 ASN1_OBJECT * OBJ_nid2obj(int n);<br/>
 const char *  OBJ_nid2ln(int n);<br/>
 const char *  OBJ_nid2sn(int n);<br/>
<br/>
 int OBJ_obj2nid(const ASN1_OBJECT *o);<br/>
 int OBJ_ln2nid(const char *ln);<br/>
 int OBJ_sn2nid(const char *sn);<br/>
<br/>
 int OBJ_txt2nid(const char *s);<br/>
<br/>
 ASN1_OBJECT * OBJ_txt2obj(const char *s, int no_name);<br/>
 int OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int no_name);<br/>
<br/>
 int OBJ_cmp(const ASN1_OBJECT *a,const ASN1_OBJECT *b);<br/>
 ASN1_OBJECT * OBJ_dup(const ASN1_OBJECT *o);<br/>
<br/>
 int OBJ_create(const char *oid,const char *sn,const char *ln);<br/>
 void OBJ_cleanup(void);<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> The ASN1 object utility functions process ASN1_OBJECT structures which are a representation of the ASN1 OBJECT IDENTIFIER (OID) type.<div class="spacer">
</div>
<i>OBJ_nid2obj()</i>, <i>OBJ_nid2ln()</i> and <i>OBJ_nid2sn()</i> convert the NID <b>n</b> to an ASN1_OBJECT structure, its long name and its short name respectively, or  <b>NULL</b> is an error occurred.<div class="spacer">
</div>
<i>OBJ_obj2nid()</i>, <i>OBJ_ln2nid()</i>, <i>OBJ_sn2nid()</i> return the corresponding NID for the object  <b>o</b>, the long name &lt;ln&gt; or the short name &lt;sn&gt; respectively or NID_undef if an error occurred.<div class="spacer">
</div>
<i>OBJ_txt2nid()</i> returns NID corresponding to text string &lt;s&gt;. <b>s</b> can be a long name, a short name or the numerical representation of an object.<div class="spacer">
</div>
<i>OBJ_txt2obj()</i> converts the text string <b>s</b> into an ASN1_OBJECT structure. If  <b>no_name</b> is 0 then long names and short names will be interpreted as well as numerical forms. If  <b>no_name</b> is 1 only the numerical form is acceptable.<div class="spacer">
</div>
<i>OBJ_obj2txt()</i> converts the <b>ASN1_OBJECT</b> <b>a</b> into a textual representation. The representation is written as a null terminated string to  <b>buf</b> at most  <b>buf_len</b> bytes are written, truncating the result if necessary. The total amount of space required is returned. If  <b>no_name</b> is 0 then if the object has a long or short name then that will be used, otherwise the numerical form will be used. If  <b>no_name</b> is 1 then the numerical form will always be used.<div class="spacer">
</div>
<i>OBJ_cmp()</i> compares <b>a</b> to <b>b</b>. If the two are identical 0 is returned.<div class="spacer">
</div>
<i>OBJ_dup()</i> returns a copy of <b>o</b>.<div class="spacer">
</div>
<i>OBJ_create()</i> adds a new object to the internal table. <b>oid</b> is the numerical form of the object,  <b>sn</b> the short name and <b>ln</b> the long name. A new NID is returned for the created object.<div class="spacer">
</div>
<i>OBJ_cleanup()</i> cleans up OpenSSLs internal object table: this should be called before an application exits if any new objects were added using  <i>OBJ_create()</i>.</div>
<div class="section">
<h1>NOTES</h1> Objects in OpenSSL can have a short name, a long name and a numerical identifier (NID) associated with them. A standard set of objects is represented in an internal table. The appropriate values are defined in the header file  <b>objects.h</b>.<div class="spacer">
</div>
For example the OID for commonName has the following definitions:<div class="spacer">
</div>
<br/>
 #define SN_commonName                   &quot;CN&quot;<br/>
 #define LN_commonName                   &quot;commonName&quot;<br/>
 #define NID_commonName                  13<br/>
<div class="spacer">
</div>
New objects can be added by calling <i>OBJ_create()</i>.<div class="spacer">
</div>
Table objects have certain advantages over other objects: for example their NIDs can be used in a C language switch statement. They are also static constant structures which are shared: that is there is only a single constant structure for each table object.<div class="spacer">
</div>
Objects which are not in the table have the NID value NID_undef.<div class="spacer">
</div>
Objects do not need to be in the internal tables to be processed, the functions  <i>OBJ_txt2obj()</i> and <i>OBJ_obj2txt()</i> can process the numerical form of an OID.</div>
<div class="section">
<h1>EXAMPLES</h1> Create an object for  <b>commonName</b>:<div class="spacer">
</div>
<br/>
 ASN1_OBJECT *o;<br/>
 o = OBJ_nid2obj(NID_commonName);<br/>
<div class="spacer">
</div>
Check if an object is <b>commonName</b><div class="spacer">
</div>
<br/>
 if (OBJ_obj2nid(obj) == NID_commonName)<br/>
        /* Do something */<br/>
<div class="spacer">
</div>
Create a new NID and initialize an object from it:<div class="spacer">
</div>
<br/>
 int new_nid;<br/>
 ASN1_OBJECT *obj;<br/>
 new_nid = OBJ_create(&quot;1.2.3.4&quot;, &quot;NewOID&quot;, &quot;New Object Identifier&quot;);<br/>
<br/>
 obj = OBJ_nid2obj(new_nid);<br/>
<div class="spacer">
</div>
Create a new object directly:<div class="spacer">
</div>
<br/>
 obj = OBJ_txt2obj(&quot;1.2.3.4&quot;, 1);<br/>
</div>
<div class="section">
<h1>BUGS</h1>  <i>OBJ_obj2txt()</i> is awkward and messy to use: it doesn't follow the convention of other OpenSSL functions where the buffer can be set to  <b>NULL</b> to determine the amount of data that should be written. Instead  <b>buf</b> must point to a valid buffer and <b>buf_len</b> should be set to a positive value. A buffer length of 80 should be more than enough to handle any OID encountered in practice.</div>
<div class="section">
<h1>RETURN VALUES</h1>  <i>OBJ_nid2obj()</i> returns an <b>ASN1_OBJECT</b> structure or <b>NULL</b> is an error occurred.<div class="spacer">
</div>
<i>OBJ_nid2ln()</i> and <i>OBJ_nid2sn()</i> returns a valid string or <b>NULL</b> on error.<div class="spacer">
</div>
<i>OBJ_obj2nid()</i>, <i>OBJ_ln2nid()</i>, <i>OBJ_sn2nid()</i> and <i>OBJ_txt2nid()</i> return a NID or  <b>NID_undef</b> on error.</div>
<div class="section">
<h1>SEE ALSO</h1>  <i>ERR_get_error</i>(3)</div>
<table class="foot">
<tr>
<td class="foot-date">
2015-09-22</td>
<td class="foot-os">
OpenBSD 6.0</td>
</tr>
</table>
</div>
</body>
</html>

