<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
LH_NEW(3)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">lh_new</b>, <b class="name">lh_free</b>, <b class="name">lh_insert</b>, <b class="name">lh_delete</b>, <b class="name">lh_retrieve</b>, <b class="name">lh_doall</b>, <b class="name">lh_doall_arg</b>, <b class="name">lh_error</b> &#8212; <span class="desc">dynamic hash table</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">openssl/lhash.h</a>&gt;</b><div class="spacer">
</div>
<b class="fname">DECLARE_LHASH_OF</b>(<i class="farg" style="white-space:nowrap;">&lt;type&gt;</i>);<div class="spacer">
</div>
<i class="ftype">LHASH *</i><br/>
<b class="fname">lh_&lt;type&gt;_new</b>(<i class="farg" style="white-space:nowrap;">void</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">lh_&lt;type&gt;_free</b>(<i class="farg">LHASH_OF(&lt;type&gt;) *table</i>);<div class="spacer">
</div>
<i class="ftype">&lt;type&gt; *</i><br/>
<b class="fname">lh_&lt;type&gt;_insert</b>(<i class="farg">LHASH_OF(&lt;type&gt;) *table</i>, <i class="farg">&lt;type&gt; *data</i>);<div class="spacer">
</div>
<i class="ftype">&lt;type&gt; *</i><br/>
<b class="fname">lh_&lt;type&gt;_delete</b>(<i class="farg">LHASH_OF(&lt;type&gt;) *table</i>, <i class="farg">&lt;type&gt; *data</i>);<div class="spacer">
</div>
<i class="ftype">&lt;type&gt; *</i><br/>
<b class="fname">lh_&lt;type&gt;_retrieve</b>(<i class="farg">LHASH_OF&lt;type&gt;) *table</i>, <i class="farg">&lt;type&gt; *data</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">lh_&lt;type&gt;_doall</b>(<i class="farg">LHASH_OF(&lt;type&gt;) *table</i>, <i class="farg">LHASH_DOALL_FN_TYPE func</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">lh_&lt;type&gt;_doall_arg</b>(<i class="farg">LHASH_OF(&lt;type&gt;) *table</i>, <i class="farg">LHASH_DOALL_ARG_FN_TYPE func</i>, <i class="farg">&lt;type2&gt;</i>, <i class="farg">&lt;type2&gt; *arg</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">lh_&lt;type&gt;_error</b>(<i class="farg">LHASH_OF(&lt;type&gt;) *table</i>);<div class="spacer">
</div>
<i class="ftype">typedef int</i><br/>
<b class="fname">(*LHASH_COMP_FN_TYPE)</b>(<i class="farg">const void *</i>, <i class="farg">const void *</i>);<div class="spacer">
</div>
<i class="ftype">typedef unsigned long</i><br/>
<b class="fname">(*LHASH_HASH_FN_TYPE)</b>(<i class="farg">const void *</i>);<div class="spacer">
</div>
<i class="ftype">typedef void</i><br/>
<b class="fname">(*LHASH_DOALL_FN_TYPE)</b>(<i class="farg">const void *</i>);<div class="spacer">
</div>
<i class="ftype">typedef void</i><br/>
<b class="fname">(*LHASH_DOALL_ARG_FN_TYPE)</b>(<i class="farg">const void *</i>, <i class="farg">const void *</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> This library implements type-checked dynamic hash tables. The hash table entries can be arbitrary structures. Usually they consist of key and value fields.<div class="spacer">
</div>
<b class="fname">lh_&lt;type&gt;_new</b>() creates a new <span class="type">LHASH_OF(&lt;type&gt;)</span> structure to store arbitrary data entries, and provides the hash and compare callbacks to be used in organising the table's entries. The hash callback takes a pointer to a table entry as its argument and returns an unsigned long hash value for its key field. The hash value is normally truncated to a power of 2, so make sure that your hash function returns well mixed low order bits. The compare callback takes two arguments (pointers to two hash table entries), and returns 0 if their keys are equal, non-zero otherwise. If your hash table will contain items of some particular type and the hash and compare callbacks hash and compare these types, then the <b class="fname">DECLARE_LHASH_HASH_FN</b>() and <b class="fname">IMPLEMENT_LHASH_COMP_FN</b>() macros can be used to create callback wrappers of the prototypes required by <b class="fname">lh_&lt;type&gt;_new</b>(). These provide per-variable casts before calling the type-specific callbacks written by the application author. These macros, as well as those used for the doall callbacks, are defined as;<div class="spacer">
</div>
<pre style="margin-left: 2.00ex;" class="lit display">
#define	DECLARE_LHASH_HASH_FN(name, o_type) \ 
	unsigned long name##_LHASH_HASH(const void *); 
#define	IMPLEMENT_LHASH_HASH_FN(name, o_type) \ 
	unsigned long name##_LHASH_HASH(const void *arg) { \ 
		const o_type *a = arg; \ 
		return name##_hash(a); } 
#define	LHASH_HASH_FN(name) name##_LHASH_HASH 
 
#define	DECLARE_LHASH_COMP_FN(name, o_type) \ 
	int name##_LHASH_COMP(const void *, const void *); 
#define	IMPLEMENT_LHASH_COMP_FN(name, o_type) \ 
	int name##_LHASH_COMP(const void *arg1, const void *arg2) { \ 
		const o_type *a = arg1;		    \ 
		const o_type *b = arg2; \ 
		return name##_cmp(a,b); } 
#define	LHASH_COMP_FN(name) name##_LHASH_COMP 
 
#define	DECLARE_LHASH_DOALL_FN(name, o_type) \ 
	void name##_LHASH_DOALL(void *); 
#define	IMPLEMENT_LHASH_DOALL_FN(name, o_type) \ 
	void name##_LHASH_DOALL(void *arg) { \ 
		o_type *a = arg; \ 
		name##_doall(a); } 
#define	LHASH_DOALL_FN(name) name##_LHASH_DOALL 
 
#define	DECLARE_LHASH_DOALL_ARG_FN(name, o_type, a_type) \ 
	void name##_LHASH_DOALL_ARG(void *, void *); 
#define	IMPLEMENT_LHASH_DOALL_ARG_FN(name, o_type, a_type) \ 
	void name##_LHASH_DOALL_ARG(void *arg1, void *arg2) { \ 
		o_type *a = arg1; \ 
		a_type *b = arg2; \ 
		name##_doall_arg(a, b); } 
#define	LHASH_DOALL_ARG_FN(name) name##_LHASH_DOALL_ARG</pre>
<div class="spacer">
</div>
An example of a hash table storing (pointers to) structures of type 'STUFF' could be defined as follows;<div class="spacer">
</div>
<pre style="margin-left: 2.00ex;" class="lit display">
/* Calculate the hash value of 'tohash' (implemented elsewhere) */ 
unsigned long STUFF_hash(const STUFF *tohash); 
/* Order 'arg1' and 'arg2' (implemented elsewhere) */ 
int stuff_cmp(const STUFF *arg1, const STUFF *arg2); 
/* Create type-safe wrapper functions for use in the LHASH internals */ 
static IMPLEMENT_LHASH_HASH_FN(stuff, STUFF); 
static IMPLEMENT_LHASH_COMP_FN(stuff, STUFF); 
/* ... */ 
int main(int argc, char *argv[]) { 
        /* Create the new hash table using the hash/compare wrappers */ 
        LHASH_OF(STUFF) *hashtable = 
	    lh_STUFF_new(LHASH_HASH_FN(STUFF_hash), 
        	LHASH_COMP_FN(STUFF_cmp)); 
	/* ... */ 
}</pre>
<div class="spacer">
</div>
<b class="fname">lh_&lt;type&gt;_free</b>() frees the <span class="type">LHASH_OF(&lt;type&gt;)</span> structure <i class="farg">table</i>. Allocated hash table entries will not be freed; consider using <b class="fname">lh_&lt;type&gt;_doall</b>() to deallocate any remaining entries in the hash table (see below).<div class="spacer">
</div>
<b class="fname">lh_&lt;type&gt;_insert</b>() inserts the structure pointed to by <i class="farg">data</i> into <i class="farg">table</i>. If there already is an entry with the same key, the old value is replaced. Note that <b class="fname">lh_&lt;type&gt;_insert</b>() stores pointers, the data are not copied.<div class="spacer">
</div>
<b class="fname">lh_&lt;type&gt;_delete</b>() deletes an entry from <i class="farg">table</i>.<div class="spacer">
</div>
<b class="fname">lh_&lt;type&gt;_retrieve</b>() looks up an entry in <i class="farg">table</i>. Normally, <i class="farg">data</i> is a structure with the key field(s) set; the function will return a pointer to a fully populated structure.<div class="spacer">
</div>
<b class="fname">lh_&lt;type&gt;_doall</b>() will, for every entry in the hash table, call <i class="farg">func</i> with the data item as its parameter. For <b class="fname">lh_&lt;type&gt;_doall</b>() and <b class="fname">lh_&lt;type&gt;_doall_arg</b>(), function pointer casting should be avoided in the callbacks (see <i class="link-sec"><a class="link-sec" href="#x4e4f544553">NOTES</a></i>) &#8212; instead use the declare/implement macros to create type-checked wrappers that cast variables prior to calling your type-specific callbacks. An example of this is illustrated here where the callback is used to cleanup resources for items in the hash table prior to the hashtable itself being deallocated:<div class="spacer">
</div>
<pre style="margin-left: 2.00ex;" class="lit display">
/* Clean up resources belonging to 'a' (this is implemented elsewhere) */ 
void STUFF_cleanup_doall(STUFF *a); 
/* Implement a prototype-compatible wrapper for &quot;STUFF_cleanup&quot; */ 
IMPLEMENT_LHASH_DOALL_FN(STUFF_cleanup, STUFF) 
	/* ... then later in the code ... */ 
/* So to run &quot;STUFF_cleanup&quot; against all items in a hash table ... */ 
lh_STUFF_doall(hashtable, LHASH_DOALL_FN(STUFF_cleanup)); 
/* Then the hash table itself can be deallocated */ 
lh_STUFF_free(hashtable);</pre>
<div class="spacer">
</div>
When doing this, be careful if you delete entries from the hash table in your callbacks: the table may decrease in size, moving the item that you are currently on down lower in the hash table &#8212; this could cause some entries to be skipped during the iteration. The second best solution to this problem is to set hash-&gt;down_load=0 before you start (which will stop the hash table ever decreasing in size). The best solution is probably to avoid deleting items from the hash table inside a doall callback!<div class="spacer">
</div>
<b class="fname">lh_&lt;type&gt;_doall_arg</b>() is the same as <b class="fname">lh_&lt;type&gt;_doall</b>() except that <i class="farg">func</i> will be called with <i class="farg">arg</i> as the second argument and <i class="farg">func</i> should be of type <span class="type">LHASH_DOALL_ARG_FN_TYPE</span> (a callback prototype that is passed both the table entry and an extra argument). As with <b class="fname">lh_&lt;type&gt;_doall</b>(), you can instead choose to declare your callback with a prototype matching the types you are dealing with and use the declare/implement macros to create compatible wrappers that cast variables before calling your type-specific callbacks. An example of this is demonstrated here (printing all hash table entries to a BIO that is provided by the caller):<div class="spacer">
</div>
<pre style="margin-left: 2.00ex;" class="lit display">
/* Print item 'a' to 'output_bio' (this is implemented elsewhere) */ 
void STUFF_print_doall_arg(const STUFF *a, BIO *output_bio); 
/* Implement a prototype-compatible wrapper for &quot;STUFF_print&quot; */ 
static IMPLEMENT_LHASH_DOALL_ARG_FN(STUFF, const STUFF, BIO) 
	/* ... then later in the code ... */ 
/* Print out the entire hashtable to a particular BIO */ 
lh_STUFF_doall_arg(hashtable, LHASH_DOALL_ARG_FN(STUFF_print), BIO, 
	logging_bio);</pre>
<div class="spacer">
</div>
<b class="fname">lh_&lt;type&gt;_error</b>() can be used to determine if an error occurred in the last operation. <b class="fname">lh_&lt;type&gt;_error</b>() is a macro.</div>
<div class="section">
<h1 id="x52455455524e2056414c554553">RETURN VALUES</h1> <b class="fname">lh_&lt;type&gt;_new</b>() returns <span class="define">NULL</span> on error, otherwise a pointer to the new <span class="type">LHASH</span> structure.<div class="spacer">
</div>
When a hash table entry is replaced, <b class="fname">lh_&lt;type&gt;_insert</b>() returns the value being replaced. <span class="define">NULL</span> is returned on normal operation and on error.<div class="spacer">
</div>
<b class="fname">lh_&lt;type&gt;_delete</b>() returns the entry being deleted. <span class="define">NULL</span> is returned if there is no such value in the hash table.<div class="spacer">
</div>
<b class="fname">lh_&lt;type&gt;_retrieve</b>() returns the hash table entry if it has been found, or <span class="define">NULL</span> otherwise.<div class="spacer">
</div>
<b class="fname">lh_&lt;type&gt;_error</b>() returns 1 if an error occurred in the last operation, or 0 otherwise.<div class="spacer">
</div>
<b class="fname">lh_&lt;type&gt;_free</b>(), <b class="fname">lh_&lt;type&gt;_doall</b>(), and <b class="fname">lh_&lt;type&gt;_doall_arg</b>() return no values.</div>
<div class="section">
<h1 id="x4e4f544553">NOTES</h1> The various LHASH macros and callback types exist to make it possible to write type-checked code without resorting to function-prototype casting &#8212; an evil that makes application code much harder to audit/verify and also opens the window of opportunity for stack corruption and other hard-to-find bugs. It also, apparently, violates ANSI-C.<div class="spacer">
</div>
The LHASH code regards table entries as constant data. As such, it internally represents <b class="fname">lh_&lt;type&gt;_insert</b>()'ed items with a <span class="type">const void *</span> pointer type. This is why callbacks such as those used by <b class="fname">lh_&lt;type&gt;_doall</b>() and <b class="fname">lh_&lt;type&gt;_doall_arg</b>() declare their prototypes with &quot;const&quot;, even for the parameters that pass back the table items' data pointers &#8212; for consistency, user-provided data is &quot;const&quot; at all times as far as the LHASH code is concerned. However, as callers are themselves providing these pointers, they can choose whether they too should be treating all such parameters as constant.<div class="spacer">
</div>
As an example, a hash table may be maintained by code that, for reasons of encapsulation, has only &quot;const&quot; access to the data being indexed in the hash table (i.e. it is returned as &quot;const&quot; from elsewhere in their code) &#8212; in this case the LHASH prototypes are appropriate as-is. Conversely, if the caller is responsible for the life-time of the data in question, then they may well wish to make modifications to table item passed back in the <b class="fname">lh_&lt;type&gt;_doall</b>() or <b class="fname">lh_&lt;type&gt;_doall_arg</b>() callbacks (see the &quot;STUFF_cleanup&quot; example above). If so, the caller can either cast the &quot;const&quot; away (if they're providing the raw callbacks themselves) or use the macros to declare/implement the wrapper functions without &quot;const&quot; types.<div class="spacer">
</div>
Callers that only have &quot;const&quot; access to data they are indexing in a table, yet declare callbacks without constant types (or cast the &quot;const&quot; away themselves), are therefore creating their own risks/bugs without being encouraged to do so by the API. On a related note, those auditing code should pay special attention to any instances of DECLARE/IMPLEMENT_LHASH_DOALL_[ARG_]_FN macros that provide types without any &quot;const&quot; qualifiers.</div>
<div class="section">
<h1 id="x494e5445524e414c53">INTERNALS</h1> The following description is based on the SSLeay documentation:<div class="spacer">
</div>
The lhash library implements a hash table described in the <span class="emph">Communications of the ACM</span> in 1991. What makes this hash table different is that as the table fills, the hash table is increased (or decreased) in size via <a class="link-man" href="../html3/OPENSSL_realloc.html">OPENSSL_realloc(3)</a>. When a 'resize' is done, instead of all hashes being redistributed over twice as many 'buckets', one bucket is split. So when an 'expand' is done, there is only a minimal cost to redistribute some values. Subsequent inserts will cause more single 'bucket' redistributions but there will never be a sudden large cost due to redistributing all the 'buckets'.<div class="spacer">
</div>
The state for a particular hash table is kept in the <span class="type">LHASH</span> structure. The decision to increase or decrease the hash table size is made depending on the 'load' of the hash table. The load is the number of items in the hash table divided by the size of the hash table. The default values are as follows. If (hash-&gt;up_load &lt; load) =&gt; expand. if (hash-&gt;down_load &gt; load) =&gt; contract. The <i class="farg">up_load</i> has a default value of 1 and <i class="farg">down_load</i> has a default value of 2. These numbers can be modified by the application by just playing with the <i class="farg">up_load</i> and <i class="farg">down_load</i> variables. The 'load' is kept in a form which is multiplied by 256. So hash-&gt;up_load=8*256 will cause a load of 8 to be set.<div class="spacer">
</div>
If you are interested in performance the field to watch is <i class="farg">num_comp_calls</i>. The hash library keeps track of the 'hash' value for each item so when a lookup is done, the 'hashes' are compared, if there is a match, then a full compare is done, and hash-&gt;num_comp_calls is incremented. If num_comp_calls is not equal to num_delete plus num_retrieve it means that your hash function is generating hashes that are the same for different values. It is probably worth changing your hash function if this is the case because even if your hash table has 10 items in a 'bucket', it can be searched with 10 <span class="type">unsigned long</span> compares and 10 linked list traverses. This will be much less expensive that 10 calls to your compare function.<div class="spacer">
</div>
<b class="fname">lh_strhash</b>() is a demo string hashing function:<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">unsigned long lh_strhash(const char *c);</code></div>
</blockquote>
<div class="spacer">
</div>
Since the LHASH routines would normally be passed structures, this routine would not normally be passed to <b class="fname">lh_&lt;type&gt;_new</b>(), rather it would be used in the function passed to <b class="fname">lh_&lt;type&gt;_new</b>().</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html3/lh_stats.html">lh_stats(3)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The lhash library is available in all versions of SSLeay and OpenSSL. <b class="fname">lh_&lt;type&gt;_error</b>() was added in SSLeay 0.9.1b.<div class="spacer">
</div>
In OpenSSL 0.9.7, all lhash functions that were passed function pointers were changed for better type safety, and the function types <span class="type">LHASH_COMP_FN_TYPE</span>, <span class="type">LHASH_HASH_FN_TYPE</span>, <span class="type">LHASH_DOALL_FN_TYPE</span>, and <span class="type">LHASH_DOALL_ARG_FN_TYPE</span> became available.<div class="spacer">
</div>
In OpenSSL 1.0.0, the lhash interface was revamped for even better type checking.</div>
<div class="section">
<h1 id="x42554753">BUGS</h1> <b class="fname">lh_&lt;type&gt;_insert</b>() returns <span class="define">NULL</span> both for success and error.</div>
</div>
</body>
</html>

