<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
CRYPTO_SET_LOCKING_CALLBACK(3)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">CRYPTO_THREADID_set_callback</b>, <b class="name">CRYPTO_THREADID_get_callback</b>, <b class="name">CRYPTO_THREADID_current</b>, <b class="name">CRYPTO_THREADID_cmp</b>, <b class="name">CRYPTO_THREADID_cpy</b>, <b class="name">CRYPTO_THREADID_hash</b>, <b class="name">CRYPTO_set_locking_callback</b>, <b class="name">CRYPTO_num_locks</b>, <b class="name">CRYPTO_set_dynlock_create_callback</b>, <b class="name">CRYPTO_set_dynlock_lock_callback</b>, <b class="name">CRYPTO_set_dynlock_destroy_callback</b>, <b class="name">CRYPTO_get_new_dynlockid</b>, <b class="name">CRYPTO_destroy_dynlockid</b>, <b class="name">CRYPTO_lock</b>, <b class="name">CRYPTO_w_lock</b>, <b class="name">CRYPTO_w_unlock</b>, <b class="name">CRYPTO_r_lock</b>, <b class="name">CRYPTO_r_unlock</b>, <b class="name">CRYPTO_add</b>, <b class="name">CRYPTO_add_lock</b>, <b class="name">CRYPTO_set_id_callback</b> &#8212; <span class="desc">OpenSSL thread support</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">openssl/crypto.h</a>&gt;</b><div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
/* Don't use this structure directly. */ 
typedef struct crypto_threadid_st { 
	void *ptr; 
	unsigned long val; 
} CRYPTO_THREADID; 
/* Only use CRYPTO_THREADID_set_[numeric|pointer]() within callbacks */</pre>
<div class="spacer">
</div>
<br/>
<i class="ftype">void</i><br/>
<b class="fname">CRYPTO_THREADID_set_numeric</b>(<i class="farg">CRYPTO_THREADID *id</i>, <i class="farg">unsigned long val</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">CRYPTO_THREADID_set_pointer</b>(<i class="farg">CRYPTO_THREADID *id</i>, <i class="farg">void *ptr</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">CRYPTO_THREADID_set_callback</b>(<i class="farg">void (*threadid_func)(CRYPTO_THREADID *)</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">(*CRYPTO_THREADID_get_callback(void))</b>(<i class="farg">CRYPTO_THREADID *</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">CRYPTO_THREADID_current</b>(<i class="farg">CRYPTO_THREADID *id</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">CRYPTO_THREADID_cmp</b>(<i class="farg">const CRYPTO_THREADID *a</i>, <i class="farg">const CRYPTO_THREADID *b</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">CRYPTO_THREADID_cpy</b>(<i class="farg">CRYPTO_THREADID *dest</i>, <i class="farg">const CRYPTO_THREADID *src</i>);<div class="spacer">
</div>
<i class="ftype">unsigned long</i><br/>
<b class="fname">CRYPTO_THREADID_hash</b>(<i class="farg">const CRYPTO_THREADID *id</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">CRYPTO_num_locks</b>(<i class="farg">void</i>);<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
/* struct CRYPTO_dynlock_value needs to be defined by the user */ 
struct CRYPTO_dynlock_value;</pre>
<div class="spacer">
</div>
<br/>
<i class="ftype">void</i><br/>
<b class="fname">CRYPTO_set_dynlock_create_callback</b>(<i class="farg">struct CRYPTO_dynlock_value *</i>, <i class="farg">(*dyn_create_function)(char *file, int line)</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">CRYPTO_set_dynlock_lock_callback</b>(<i class="farg">void (*dyn_lock_function)(int mode, struct CRYPTO_dynlock_value *l, const char *file, int line)</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">CRYPTO_set_dynlock_destroy_callback</b>(<i class="farg">void (*dyn_destroy_function)(struct CRYPTO_dynlock_value *l, const char *file, int line)</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">CRYPTO_get_new_dynlockid</b>(<i class="farg">void</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">CRYPTO_destroy_dynlockid</b>(<i class="farg">int i</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">CRYPTO_lock</b>(<i class="farg">int mode</i>, <i class="farg">int n</i>, <i class="farg">const char *file</i>, <i class="farg">int line</i>);<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
#define	CRYPTO_w_lock(type) \ 
	CRYPTO_lock(CRYPTO_LOCK|CRYPTO_WRITE, type, __FILE__, __LINE__) 
#define	CRYPTO_w_unlock(type) \ 
	CRYPTO_lock(CRYPTO_UNLOCK|CRYPTO_WRITE, type, __FILE__, __LINE__) 
#define	CRYPTO_r_lock(type) \ 
	CRYPTO_lock(CRYPTO_LOCK|CRYPTO_READ, type, __FILE__, __LINE__) 
#define	CRYPTO_r_unlock(type) \ 
	CRYPTO_lock(CRYPTO_UNLOCK|CRYPTO_READ, type, __FILE__, __LINE__) 
#define	CRYPTO_add(addr,amount,type) \ 
	CRYPTO_add_lock(addr, amount, type, __FILE__, __LINE__)</pre>
</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> OpenSSL can safely be used in multi-threaded applications provided that at least two callback functions are set, <b class="fname">locking_function</b>() and <b class="fname">threadid_func</b>().<div class="spacer">
</div>
<b class="fname">locking_function</b>(<i class="farg">int mode</i>, <i class="farg">int n</i>, <i class="farg">const char *file</i>, <i class="farg">int line</i>); is needed to perform locking on shared data structures. Note that OpenSSL uses a number of global data structures that will be implicitly shared whenever multiple threads use OpenSSL. Multi-threaded applications will crash at random if it is not set.<div class="spacer">
</div>
<b class="fname">locking_function</b>() must be able to handle up to <b class="fname">CRYPTO_num_locks</b>() different mutex locks. It sets the <i class="farg">n</i>-th lock if <i class="farg">mode</i> includes <span class="define">CRYPTO_LOCK</span>, and releases it otherwise.<div class="spacer">
</div>
<i class="farg">file</i> and <i class="farg">line</i> are the file number of the function setting the lock. They can be useful for debugging.<div class="spacer">
</div>
<b class="fname">threadid_func</b>(<i class="farg">CRYPTO_THREADID *id</i>); is needed to record the currently-executing thread's identifier into <i class="farg">id</i>. The implementation of this callback should not fill in <i class="farg">id</i> directly, but should use <b class="fname">CRYPTO_THREADID_set_numeric</b>() if thread IDs are numeric, or <b class="fname">CRYPTO_THREADID_set_pointer</b>() if they are pointer-based. If the application does not register such a callback using <b class="fname">CRYPTO_THREADID_set_callback</b>(), then a default implementation is used - on Windows and BeOS this uses the system's default thread identifying APIs, and on all other platforms it uses the address of <b class="var">errno</b>. The latter is satisfactory for thread-safety if and only if the platform has a thread-local error number facility.<div class="spacer">
</div>
Once <b class="fname">threadid_func</b>() is registered, or if the built-in default implementation is to be used,<ul style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-bul">
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">CRYPTO_THREADID_current</b>() records the currently-executing thread ID into the given <i class="farg">id</i> object.</li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">CRYPTO_THREADID_cmp</b>() compares two thread IDs (returning zero for equality, i.e. the same semantics as <a class="link-man" href="../html3/memcmp.html">memcmp(3)</a>).</li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">CRYPTO_THREADID_cpy</b>() duplicates a thread ID value.</li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">CRYPTO_THREADID_hash</b>() returns a numeric value usable as a hash-table key. This is usually the exact numeric or pointer-based thread ID used internally, however this also handles the unusual case where pointers are larger than <span class="type">long</span> variables and the platform's thread IDs are pointer-based &#8212; in this case, mixing is done to attempt to produce a unique numeric value even though it is not as wide as the platform's true thread IDs.</li>
</ul>
<div class="spacer">
</div>
Additionally, OpenSSL supports dynamic locks, and sometimes, some parts of OpenSSL need it for better performance. To enable this, the following is required:<ul style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-bul">
<li class="list-bul" style="margin-top: 1.00em;">
Three additional callback functions, <b class="fname">dyn_create_function</b>(), <b class="fname">dyn_lock_function</b>(), and <b class="fname">dyn_destroy_function</b>().</li>
<li class="list-bul" style="margin-top: 1.00em;">
A structure defined with the data that each lock needs to handle.</li>
</ul>
<div class="spacer">
</div>
<span class="type">struct CRYPTO_dynlock_value</span> has to be defined to contain whatever structure is needed to handle locks.<div class="spacer">
</div>
<b class="fname">dyn_create_function</b>(<i class="farg">const char *file</i>, <i class="farg">int line</i>); is needed to create a lock. Multi-threaded applications might crash at random if it is not set.<div class="spacer">
</div>
<b class="fname">dyn_lock_function</b>(<i class="farg">int mode</i>, <i class="farg">CRYPTO_dynlock *l</i>, <i class="farg">const char *file</i>, <i class="farg">int line</i>); is needed to perform locking off dynamic lock numbered n. Multi-threaded applications might crash at random if it is not set.<div class="spacer">
</div>
<b class="fname">dyn_destroy_function</b>(<i class="farg">CRYPTO_dynlock *l</i>, <i class="farg">const char *file</i>, <i class="farg">int line</i>); is needed to destroy the lock <i class="farg">l</i>. Multi-threaded applications might crash at random if it is not set.<div class="spacer">
</div>
<b class="fname">CRYPTO_get_new_dynlockid</b>() is used to create locks. It will call <b class="fname">dyn_create_function</b>() for the actual creation.<div class="spacer">
</div>
<b class="fname">CRYPTO_destroy_dynlockid</b>() is used to destroy locks. It will call <b class="fname">dyn_destroy_function</b>() for the actual destruction.<div class="spacer">
</div>
<b class="fname">CRYPTO_lock</b>() is used to lock and unlock the locks. <i class="farg">mode</i> is a bitfield describing what should be done with the lock. <i class="farg">n</i> is the number of the lock as returned from <b class="fname">CRYPTO_get_new_dynlockid</b>(). <i class="farg">mode</i> can be combined from the following values. These values are pairwise exclusive, with undefined behaviour if misused (for example, <span class="define">CRYPTO_READ</span> and <span class="define">CRYPTO_WRITE</span> should not be used together):<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
CRYPTO_LOCK	0x01 
CRYPTO_UNLOCK	0x02 
CRYPTO_READ	0x04 
CRYPTO_WRITE	0x08</pre>
</div>
<div class="section">
<h1 id="x52455455524e2056414c554553">RETURN VALUES</h1> <b class="fname">CRYPTO_num_locks</b>() returns the required number of locks.<div class="spacer">
</div>
<b class="fname">CRYPTO_get_new_dynlockid</b>() returns the index to the newly created lock.<div class="spacer">
</div>
The other functions return no values.</div>
<div class="section">
<h1 id="x4e4f544553">NOTES</h1> You can find out if OpenSSL was configured with thread support:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
#define OPENSSL_THREAD_DEFINES 
#include &lt;openssl/opensslconf.h&gt; 
#if defined(OPENSSL_THREADS) 
	/* thread support enabled */ 
#else 
	/* no thread support */ 
#endif</pre>
<div class="spacer">
</div>
Also, dynamic locks are currently not used internally by OpenSSL, but may do so in the future.</div>
<div class="section">
<h1 id="x4558414d504c4553">EXAMPLES</h1> <i class="file">crypto/threads/mttest.c</i> shows examples of the callback functions on Solaris, Irix and Win32.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html3/crypto.html">crypto(3)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> <b class="fname">CRYPTO_set_locking_callback</b>() is available in all versions of SSLeay and OpenSSL. <b class="fname">CRYPTO_num_locks</b>() was added in OpenSSL 0.9.4. All functions dealing with dynamic locks were added in OpenSSL 0.9.5b-dev. <span class="type">CRYPTO_THREADID</span> and associated functions were introduced in OpenSSL 1.0.0 to replace (actually, deprecate) the previous <b class="fname">CRYPTO_set_id_callback</b>(), <b class="fname">CRYPTO_get_id_callback</b>(), and <b class="fname">CRYPTO_thread_id</b>() functions which assumed thread IDs to always be represented by <span class="type">unsigned long</span>.</div>
</div>
</body>
</html>

