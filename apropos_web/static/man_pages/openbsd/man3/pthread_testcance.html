<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
PTHREAD_TESTCANCEL(3)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">pthread_setcancelstate</b>, <b class="name">pthread_setcanceltype</b>, <b class="name">pthread_testcancel</b> &#8212; <span class="desc">set cancelability state</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">pthread.h</a>&gt;</b><div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">pthread_setcancelstate</b>(<i class="farg" style="white-space:nowrap;">int state</i>, <i class="farg" style="white-space:nowrap;">int *oldstate</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">pthread_setcanceltype</b>(<i class="farg" style="white-space:nowrap;">int type</i>, <i class="farg" style="white-space:nowrap;">int *oldtype</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">pthread_testcancel</b>(<i class="farg" style="white-space:nowrap;">void</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <b class="fname">pthread_setcancelstate</b>() function atomically both sets the calling thread's cancelability state to the indicated <i class="farg">state</i> and, if <i class="farg">oldstate</i> is not <span class="define">NULL</span>, returns the previous cancelability state at the location referenced by <i class="farg">oldstate</i>. Legal values for <i class="farg">state</i> are <span class="define">PTHREAD_CANCEL_ENABLE</span> and <span class="define">PTHREAD_CANCEL_DISABLE</span>.<div class="spacer">
</div>
The <b class="fname">pthread_setcanceltype</b>() function atomically both sets the calling thread's cancelability type to the indicated <i class="farg">type</i> and, if <i class="farg">oldtype</i> is not <span class="define">NULL</span>, returns the previous cancelability type at the location referenced by <i class="farg">oldtype</i>. Legal values for <i class="farg">type</i> are <span class="define">PTHREAD_CANCEL_DEFERRED</span> and <span class="define">PTHREAD_CANCEL_ASYNCHRONOUS</span>.<div class="spacer">
</div>
The cancelability state and type of any newly created threads, including the thread in which <b class="fname">main</b>() was first invoked, are <span class="define">PTHREAD_CANCEL_ENABLE</span> and <span class="define">PTHREAD_CANCEL_DEFERRED</span> respectively.<div class="spacer">
</div>
The <b class="fname">pthread_testcancel</b>() function creates a cancellation point in the calling thread. The <b class="fname">pthread_testcancel</b>() function has no effect if cancelability is disabled.<div class="subsection">
<h2 id="x43616e63656c6162696c69747920537461746573">Cancelability States</h2> The cancelability state of a thread determines the action taken upon receipt of a cancellation request. The thread may control cancellation in a number of ways.<div class="spacer">
</div>
Each thread maintains its own &#8220;cancelability state&#8221; which may be encoded in two bits:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-hang">
<dt class="list-hang" style="margin-top: 1.00em;">
<span class="emph">Cancelability Enable</span></dt>
<dd class="list-hang">
When cancelability is <span class="define">PTHREAD_CANCEL_DISABLE</span>, cancellation requests against the target thread are held pending.</dd>
<dt class="list-hang" style="margin-top: 1.00em;">
<span class="emph">Cancelability Type</span></dt>
<dd class="list-hang">
When cancelability is enabled and the cancelability type is <span class="define">PTHREAD_CANCEL_ASYNCHRONOUS</span>, new or pending cancellation requests may be acted upon at any time. When cancelability is enabled and the cancelability type is <span class="define">PTHREAD_CANCEL_DEFERRED</span>, cancellation requests are held pending until a cancellation point (see below) is reached. If cancelability is disabled, the setting of the cancelability type has no immediate effect as all cancellation requests are held pending; however, once cancelability is enabled again the new type will be in effect.</dd>
</dl>
</div>
<div class="subsection">
<h2 id="x43616e63656c6c6174696f6e20506f696e7473">Cancellation Points</h2> Cancellation points will occur when a thread is executing the following base interfaces: <b class="fname">accept</b>(), <b class="fname">close</b>(), <b class="fname">connect</b>(), <b class="fname">creat</b>(), <b class="fname">fcntl</b>(<i class="farg">F_SETLKW</i>), <b class="fname">fdatasync</b>(), <b class="fname">fsync</b>(), <b class="fname">lockf</b>(), <b class="fname">msgrcv</b>(), <b class="fname">msgsnd</b>(), <b class="fname">msync</b>(), <b class="fname">nanosleep</b>(), <b class="fname">open</b>(), <b class="fname">openat</b>(), <b class="fname">pause</b>(), <b class="fname">poll</b>(), <b class="fname">pread</b>(), <b class="fname">pthread_cond_timedwait</b>(), <b class="fname">pthread_cond_wait</b>(), <b class="fname">pthread_join</b>(), <b class="fname">pthread_testcancel</b>(), <b class="fname">pwrite</b>(), <b class="fname">read</b>(), <b class="fname">readv</b>(), <b class="fname">recv</b>(), <b class="fname">recvfrom</b>(), <b class="fname">recvmsg</b>(), <b class="fname">select</b>(), <b class="fname">sem_timedwait</b>(), <b class="fname">sem_wait</b>(), <b class="fname">send</b>(), <b class="fname">sendmsg</b>(), <b class="fname">sendto</b>(), <b class="fname">sigsuspend</b>(), <b class="fname">sigwait</b>(), <b class="fname">sleep</b>(), <b class="fname">system</b>(), <b class="fname">tcdrain</b>(), <b class="fname">wait</b>(), <b class="fname">waitpid</b>(), <b class="fname">write</b>(), <b class="fname">writev</b>().<div class="spacer">
</div>
In addition, cancellation points will occur when a thread is executing the following extension interfaces: <b class="fname">accept4</b>(), <b class="fname">closefrom</b>(), <b class="fname">ppoll</b>(), <b class="fname">preadv</b>(), <b class="fname">pwritev</b>(), <b class="fname">wait3</b>(), <b class="fname">wait4</b>().</div>
</div>
<div class="section">
<h1 id="x52455455524e2056414c554553">RETURN VALUES</h1> If successful, the <b class="fname">pthread_setcancelstate</b>() and <b class="fname">pthread_setcanceltype</b>() functions will return zero. Otherwise, an error number shall be returned to indicate the error.<div class="spacer">
</div>
The <b class="fname">pthread_setcancelstate</b>() and <b class="fname">pthread_setcanceltype</b>() functions are used to control the points at which a thread may be asynchronously cancelled. For cancellation control to be usable in modular fashion, some rules must be followed.<div class="spacer">
</div>
For purposes of this discussion, consider an object to be a generalization of a procedure. It is a set of procedures and global variables written as a unit and called by clients not known by the object. Objects may depend on other objects.<div class="spacer">
</div>
First, cancelability should only be disabled on entry to an object, never explicitly enabled. On exit from an object, the cancelability state should always be restored to its value on entry to the object.<div class="spacer">
</div>
This follows from a modularity argument: if the client of an object (or the client of an object that uses that object) has disabled cancelability, it is because the client doesn't want to have to worry about how to clean up if the thread is cancelled while executing some sequence of actions. If an object is called in such a state and it enables cancelability and a cancellation request is pending for that thread, then the thread will be cancelled, contrary to the wish of the client that disabled.<div class="spacer">
</div>
Second, the cancelability type may be explicitly set to either <span class="emph">deferred</span> or <span class="emph">asynchronous</span> upon entry to an object. But as with the cancelability state, on exit from an object that cancelability type should always be restored to its value on entry to the object.<div class="spacer">
</div>
Finally, only functions that are cancel-safe may be called from a thread that is asynchronously cancelable.</div>
<div class="section">
<h1 id="x4552524f5253">ERRORS</h1> The function <b class="fname">pthread_setcancelstate</b>() may fail with:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
[<span class="errno">EINVAL</span>]</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
The specified state is not <span class="define">PTHREAD_CANCEL_ENABLE</span> or <span class="define">PTHREAD_CANCEL_DISABLE</span>.</dd>
</dl>
<div class="spacer">
</div>
The function <b class="fname">pthread_setcanceltype</b>() may fail with:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
[<span class="errno">EINVAL</span>]</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
The specified state is not <span class="define">PTHREAD_CANCEL_DEFERRED</span> or <span class="define">PTHREAD_CANCEL_ASYNCHRONOUS</span>.</dd>
</dl>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html3/pthread_cancel.html">pthread_cancel(3)</a></div>
<div class="section">
<h1 id="x5354414e4441524453">STANDARDS</h1> <b class="fname">pthread_testcancel</b>() conforms to ISO/IEC 9945-1:1996 (&#8220;POSIX.1&#8221;)</div>
</div>
</body>
</html>

