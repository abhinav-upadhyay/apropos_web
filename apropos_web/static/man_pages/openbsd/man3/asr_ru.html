<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
ASR_RUN(3)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">asr_run</b>, <b class="name">asr_run_sync</b>, <b class="name">asr_abort</b>, <b class="name">res_send_async</b>, <b class="name">res_query_async</b>, <b class="name">res_search_async</b>, <b class="name">getrrsetbyname_async</b>, <b class="name">gethostbyname_async</b>, <b class="name">gethostbyname2_async</b>, <b class="name">gethostbyaddr_async</b>, <b class="name">getnetbyname_async</b>, <b class="name">getnetbyaddr_async</b>, <b class="name">getaddrinfo_async</b>, <b class="name">getnameinfo_async</b> &#8212; <span class="desc">asynchronous resolver functions</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/types.h</a>&gt;</b><br/>
<b class="includes">#include &lt;<a class="link-includes">sys/socket.h</a>&gt;</b><br/>
<b class="includes">#include &lt;<a class="link-includes">netdb.h</a>&gt;</b><br/>
<b class="includes">#include &lt;<a class="link-includes">asr.h</a>&gt;</b><div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">asr_run</b>(<i class="farg" style="white-space:nowrap;">struct asr_query *aq</i>, <i class="farg" style="white-space:nowrap;">struct asr_result *ar</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">asr_run_sync</b>(<i class="farg" style="white-space:nowrap;">struct asr_query *aq</i>, <i class="farg" style="white-space:nowrap;">struct asr_result *ar</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">asr_abort</b>(<i class="farg" style="white-space:nowrap;">struct asr_query *aq</i>);<div class="spacer">
</div>
<i class="ftype">struct asr_query *</i><br/>
<b class="fname">res_send_async</b>(<i class="farg" style="white-space:nowrap;">const unsigned char *pkt</i>, <i class="farg" style="white-space:nowrap;">int pktlen</i>, <i class="farg" style="white-space:nowrap;">void *asr</i>);<div class="spacer">
</div>
<i class="ftype">struct asr_query *</i><br/>
<b class="fname">res_query_async</b>(<i class="farg" style="white-space:nowrap;">const char *name</i>, <i class="farg" style="white-space:nowrap;">int class</i>, <i class="farg" style="white-space:nowrap;">int type</i>, <i class="farg" style="white-space:nowrap;">void *asr</i>);<div class="spacer">
</div>
<i class="ftype">struct asr_query *</i><br/>
<b class="fname">res_search_async</b>(<i class="farg" style="white-space:nowrap;">const char *name</i>, <i class="farg" style="white-space:nowrap;">int class</i>, <i class="farg" style="white-space:nowrap;">int type</i>, <i class="farg" style="white-space:nowrap;">void *asr</i>);<div class="spacer">
</div>
<i class="ftype">struct asr_query *</i><br/>
<b class="fname">getrrsetbyname_async</b>(<i class="farg" style="white-space:nowrap;">const char *hostname</i>, <i class="farg" style="white-space:nowrap;">unsigned int rdclass</i>, <i class="farg" style="white-space:nowrap;">unsigned int rdtype</i>, <i class="farg" style="white-space:nowrap;">unsigned int flags</i>, <i class="farg" style="white-space:nowrap;">void *asr</i>);<div class="spacer">
</div>
<i class="ftype">struct asr_query *</i><br/>
<b class="fname">gethostbyname_async</b>(<i class="farg" style="white-space:nowrap;">const char *name</i>, <i class="farg" style="white-space:nowrap;">void *asr</i>);<div class="spacer">
</div>
<i class="ftype">struct asr_query *</i><br/>
<b class="fname">gethostbyname2_async</b>(<i class="farg" style="white-space:nowrap;">const char *name</i>, <i class="farg" style="white-space:nowrap;">int af</i>, <i class="farg" style="white-space:nowrap;">void *asr</i>);<div class="spacer">
</div>
<i class="ftype">struct asr_query *</i><br/>
<b class="fname">gethostbyaddr_async</b>(<i class="farg" style="white-space:nowrap;">const void *addr</i>, <i class="farg" style="white-space:nowrap;">socklen_t len</i>, <i class="farg" style="white-space:nowrap;">int af</i>, <i class="farg" style="white-space:nowrap;">void *asr</i>);<div class="spacer">
</div>
<i class="ftype">struct asr_query *</i><br/>
<b class="fname">getnetbyname_async</b>(<i class="farg" style="white-space:nowrap;">const char *name</i>, <i class="farg" style="white-space:nowrap;">void *asr</i>);<div class="spacer">
</div>
<i class="ftype">struct asr_query *</i><br/>
<b class="fname">getnetbyaddr_async</b>(<i class="farg" style="white-space:nowrap;">in_addr_t net</i>, <i class="farg" style="white-space:nowrap;">int type</i>, <i class="farg" style="white-space:nowrap;">void *asr</i>);<div class="spacer">
</div>
<i class="ftype">struct asr_query *</i><br/>
<b class="fname">getaddrinfo_async</b>(<i class="farg" style="white-space:nowrap;">const char *hostname</i>, <i class="farg" style="white-space:nowrap;">const char *servname</i>, <i class="farg" style="white-space:nowrap;">const struct addrinfo *hints</i>, <i class="farg" style="white-space:nowrap;">void *asr</i>);<div class="spacer">
</div>
<i class="ftype">struct asr_query *</i><br/>
<b class="fname">getnameinfo_async</b>(<i class="farg" style="white-space:nowrap;">const struct sockaddr *sa</i>, <i class="farg" style="white-space:nowrap;">socklen_t salen</i>, <i class="farg" style="white-space:nowrap;">char *host</i>, <i class="farg" style="white-space:nowrap;">size_t hostlen</i>, <i class="farg" style="white-space:nowrap;">char *serv</i>, <i class="farg" style="white-space:nowrap;">size_t servlen</i>, <i class="farg" style="white-space:nowrap;">int flags</i>, <i class="farg" style="white-space:nowrap;">void *asr</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <b class="name">asr</b> functions provide a simple interface for asynchronous address resolution and nameserver querying. They should be used in place of the classical resolver functions of libc when blocking is not desirable.<div class="spacer">
</div>
The principle of operation is as follows: All async requests are made against an <b class="name">asr</b> context which basically defines a list of sources to query and a strategy to do so. The user creates a query through one of the dedicated functions, and gets a handle representing the internal query. A query is a state-machine that can be run to try to fulfill a particular request. This is done by calling in a generic API that performs the state transitions until it needs to give the control back to the user, either because a result is available, or because the next transition implies a blocking call (a file descriptor needs to be read from or written to). The user is responsible for dealing with the situation: either get the result, or wait until the fd conditions are met, and then call back into the resolving machinery when it is ready to proceed.<div class="spacer">
</div>
The <b class="fname">asr_run</b>() function drives the resolving process. It runs the asynchronous query represented by the <i class="farg">aq</i> handle until a result is available, or until it cannot continue without blocking. The results are returned to the user through the <i class="farg">ar</i> parameter, which must be a valid pointer to user allocated memory. <i class="farg">ar</i> is defined as:<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
struct asr_result { 
 
	/* Fields set if the query is not done yet (asr_run returns 0) */ 
	int	 ar_cond;	/* ASR_WANT_READ or ASR_WANT_WRITE */ 
	int	 ar_fd;		/* the fd waiting for io condition */ 
	int	 ar_timeout;	/* time to wait for in milliseconds */ 
 
	/* Error fields.  Depends on the query type. */ 
	int	 ar_errno; 
	int	 ar_h_errno; 
	int	 ar_gai_errno; 
	int	 ar_rrset_errno; 
 
	/* Result for res_*_async() calls */ 
	int	 ar_count;	/* number of answers in the dns reply */ 
	int	 ar_rcode;	/* response code in the dns reply */ 
	void	*ar_data;	/* raw reply packet (must be freed) */ 
	int	 ar_datalen;	/* reply packet length */ 
	struct sockaddr_storage ar_ns; /* nameserver that responded */ 
 
	/* Result for other calls. Must be freed properly. */ 
	struct addrinfo	 *ar_addrinfo; 
	struct rrsetinfo *ar_rrsetinfo; 
	struct hostent	 *ar_hostent; 
	struct netent	 *ar_netent; 
};</pre>
<div class="spacer">
</div>
The function returns one of the following values:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
0</dt>
<dd class="list-tag" style="margin-left: 2.00ex;">
The query cannot be processed further until a specific condition on a file descriptor becomes true. The following members of the <i class="farg">ar</i> structure are filled:<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="farg">ar_cond</i></dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
one of ASR_WANT_READ or ASR_WANT_WRITE,</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="farg">ar_fd</i></dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
the file descriptor waiting for an IO operation,</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="farg">ar_timeout</i></dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
the amount of time to wait for in milliseconds.</dd>
</dl>
<div class="spacer">
</div>
The caller is expected to call <b class="fname">asr_run</b>() again once the condition holds or the timeout expires.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
1</dt>
<dd class="list-tag" style="margin-left: 2.00ex;">
The query is completed. The members relevant to the actual async query type are set accordingly, including error conditions. In any case, the query is cleared and its handle is invalidated.</dd>
</dl>
<div class="spacer">
</div>
Note that although the query itself may fail (the error being properly reported in the <i class="farg">ar</i> structure), the <b class="fname">asr_run</b>() function itself cannot fail and it always preserves errno.<div class="spacer">
</div>
The <b class="fname">asr_run_sync</b>() function is a wrapper around <b class="fname">asr_run</b>() that handles the read/write conditions, thus falling back to a blocking interface. It only returns 1. It also preserves errno.<div class="spacer">
</div>
The <b class="fname">asr_abort</b>() function clears a running query. It can be called when the query is waiting on a file descriptor. Note that a completed query is already cleared when <b class="fname">asr_run</b>() returns, so <b class="fname">asr_abort</b>() must not be called in this case.<div class="spacer">
</div>
The remaining functions are used to initiate different kinds of query on the <i class="farg">asr</i> resolver context. The specific operational details for each of them are described below. All functions return a handle to an internal query, or NULL if they could not allocate the necessary resources to initiate the query. All other errors (especially invalid parameters) are reported when calling <b class="fname">asr_run</b>(). They usually have the same interface as an existing resolver function, with an additional <i class="arg">asr</i> argument, which specifies the context to use for this request. For now, the argument must always be NULL, which will use the default context for the current thread.<div class="spacer">
</div>
The <b class="fname">res_send_async</b>(), <b class="fname">res_query_async</b>() and <b class="fname">res_search_async</b>() functions are asynchronous versions of the standard libc resolver routines. Their interface is very similar, except that the response buffer is always allocated internally. The return value is found upon completion in the <i class="farg">ar_datalen</i> member of the response structure. In addition, the <i class="farg">ar_ns</i> structure contains the address of the DNS server that sent the response, <i class="farg">ar_rcode</i> contains the code returned by the server in the DNS response packet, and <i class="farg">ar_count</i> contains the number of answers in the packet. If a response is received it is placed in a newly allocated buffer and returned as <i class="farg">ar_data</i> member. This buffer must be freed by the caller. On error, the <i class="farg">ar_errno</i> and <i class="farg">ar_h_errno</i> members are set accordingly.<div class="spacer">
</div>
The <b class="fname">getrrsetbyname_async</b>() function is an asynchronous version of <a class="link-man" href="../html3/getrrsetbyname.html">getrrsetbyname(3)</a>. Upon completion, the return code is found in <i class="farg">ar_rrset_errno</i> and the address to the newly allocated result set is set in <i class="farg">ar_rrsetinfo</i>. As for the blocking function, it must be freed by calling <a class="link-man" href="../html3/freerrset.html">freerrset(3)</a>.<div class="spacer">
</div>
The <b class="fname">gethostbyname_async</b>(), <b class="fname">gethostbyname2_async</b>() and <b class="fname">gethostbyaddr_async</b>() functions provide an asynchronous version of the network host entry functions. Upon completion, <i class="arg">ar_h_errno</i> is set and the resulting hostent address, if found, is set in the <i class="arg">ar_hostent</i> field. Note that unlike their blocking counterparts, these functions always return a pointer to newly allocated memory, which must be released by the caller using <a class="link-man" href="../html3/free.html">free(3)</a>.<div class="spacer">
</div>
Similarly, the <b class="fname">getnetbyname_async</b>() and <b class="fname">getnetbyaddr_async</b>() functions provide an asynchronous version of the network entry functions. Upon completion, <i class="arg">ar_h_errno</i> is set and the resulting netent address, if found, is set in the <i class="arg">ar_netent</i> field. The memory there is also allocated for the request, and it must be freed by <a class="link-man" href="../html3/free.html">free(3)</a>.<div class="spacer">
</div>
The <b class="fname">getaddrinfo_async</b>() function is an asynchronous version of the <a class="link-man" href="../html3/getaddrinfo.html">getaddrinfo(3)</a> call. It provides a chain of addrinfo structures with all valid combinations of socket address for the given <i class="farg">hostname</i>, <i class="farg">servname</i> and <i class="farg">hints</i>. Those three parameters have the same meaning as for the blocking counterpart. Upon completion the return code is set in <i class="farg">ar_gai_errno</i>. The <i class="farg">ar_errno</i> member may also be set. On success, the <i class="farg">ar_addrinfo</i> member points to a newly allocated list of addrinfo. This list must be freed with <a class="link-man" href="../html3/freeaddrinfo.html">freeaddrinfo(3)</a>.</div>
<div class="section">
<h1 id="x574f524b494e4720574954482054485245414453">WORKING WITH THREADS</h1> This implementation of the asynchronous resolver interface is thread-safe and lock-free internally, but the following restriction applies: Two different threads must not create queries on the same context or run queries originating from the same context at the same time. If they want to do that, all calls must be protected by a mutex around that context.<div class="spacer">
</div>
It is generally not a problem since the main point of the asynchronous resolver is to multiplex queries within a single thread of control, so sharing a resolver among threads is not useful.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html3/getaddrinfo.html">getaddrinfo(3)</a>, <a class="link-man" href="../html3/gethostbyname.html">gethostbyname(3)</a>, <a class="link-man" href="../html3/getnameinfo.html">getnameinfo(3)</a>, <a class="link-man" href="../html3/getnetbyname.html">getnetbyname(3)</a>, <a class="link-man" href="../html3/getrrsetbyname.html">getrrsetbyname(3)</a>, <a class="link-man" href="../html3/res_send.html">res_send(3)</a>, <a class="link-man" href="../html5/resolv.conf.html">resolv.conf(5)</a></div>
<div class="section">
<h1 id="x43415645415453">CAVEATS</h1> This DNS resolver implementation doesn't support the EDNS0 protocol extension yet.</div>
</div>
</body>
</html>

