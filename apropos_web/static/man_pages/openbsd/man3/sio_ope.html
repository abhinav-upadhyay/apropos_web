<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
SIO_OPEN(3)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">sio_open</b>, <b class="name">sio_close</b>, <b class="name">sio_setpar</b>, <b class="name">sio_getpar</b>, <b class="name">sio_getcap</b>, <b class="name">sio_start</b>, <b class="name">sio_stop</b>, <b class="name">sio_read</b>, <b class="name">sio_write</b>, <b class="name">sio_onmove</b>, <b class="name">sio_nfds</b>, <b class="name">sio_pollfd</b>, <b class="name">sio_revents</b>, <b class="name">sio_eof</b>, <b class="name">sio_setvol</b>, <b class="name">sio_onvol</b>, <b class="name">sio_initpar</b> &#8212; <span class="desc">sndio interface to audio devices</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sndio.h</a>&gt;</b><div class="spacer">
</div>
<i class="ftype">struct sio_hdl *</i><br/>
<b class="fname">sio_open</b>(<i class="farg" style="white-space:nowrap;">const char *name</i>, <i class="farg" style="white-space:nowrap;">unsigned int mode</i>, <i class="farg" style="white-space:nowrap;">int nbio_flag</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">sio_close</b>(<i class="farg" style="white-space:nowrap;">struct sio_hdl *hdl</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">sio_setpar</b>(<i class="farg" style="white-space:nowrap;">struct sio_hdl *hdl</i>, <i class="farg" style="white-space:nowrap;">struct sio_par *par</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">sio_getpar</b>(<i class="farg" style="white-space:nowrap;">struct sio_hdl *hdl</i>, <i class="farg" style="white-space:nowrap;">struct sio_par *par</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">sio_getcap</b>(<i class="farg" style="white-space:nowrap;">struct sio_hdl *hdl</i>, <i class="farg" style="white-space:nowrap;">struct sio_cap *cap</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">sio_start</b>(<i class="farg" style="white-space:nowrap;">struct sio_hdl *hdl</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">sio_stop</b>(<i class="farg" style="white-space:nowrap;">struct sio_hdl *hdl</i>);<div class="spacer">
</div>
<i class="ftype">size_t</i><br/>
<b class="fname">sio_read</b>(<i class="farg" style="white-space:nowrap;">struct sio_hdl *hdl</i>, <i class="farg" style="white-space:nowrap;">void *addr</i>, <i class="farg" style="white-space:nowrap;">size_t nbytes</i>);<div class="spacer">
</div>
<i class="ftype">size_t</i><br/>
<b class="fname">sio_write</b>(<i class="farg" style="white-space:nowrap;">struct sio_hdl *hdl</i>, <i class="farg" style="white-space:nowrap;">const void *addr</i>, <i class="farg" style="white-space:nowrap;">size_t nbytes</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">sio_onmove</b>(<i class="farg" style="white-space:nowrap;">struct sio_hdl *hdl</i>, <i class="farg" style="white-space:nowrap;">void (*cb)(void *arg, int delta)</i>, <i class="farg" style="white-space:nowrap;">void *arg</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">sio_nfds</b>(<i class="farg" style="white-space:nowrap;">struct sio_hdl *hdl</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">sio_pollfd</b>(<i class="farg" style="white-space:nowrap;">struct sio_hdl *hdl</i>, <i class="farg" style="white-space:nowrap;">struct pollfd *pfd</i>, <i class="farg" style="white-space:nowrap;">int events</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">sio_revents</b>(<i class="farg" style="white-space:nowrap;">struct sio_hdl *hdl</i>, <i class="farg" style="white-space:nowrap;">struct pollfd *pfd</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">sio_eof</b>(<i class="farg" style="white-space:nowrap;">struct sio_hdl *hdl</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">sio_setvol</b>(<i class="farg" style="white-space:nowrap;">struct sio_hdl *hdl</i>, <i class="farg" style="white-space:nowrap;">unsigned int vol</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">sio_onvol</b>(<i class="farg" style="white-space:nowrap;">struct sio_hdl *hdl</i>, <i class="farg" style="white-space:nowrap;">void (*cb)(void *arg, unsigned int vol)</i>, <i class="farg" style="white-space:nowrap;">void *arg</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">sio_initpar</b>(<i class="farg" style="white-space:nowrap;">struct sio_par *par</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <b class="name">sndio</b> library allows user processes to access <a class="link-man" href="../html4/audio.html">audio(4)</a> hardware and the <a class="link-man" href="../html8/sndiod.html">sndiod(8)</a> audio server in a uniform way.<div class="subsection">
<h2 id="x4f70656e696e6720616e6420636c6f73696e6720616e20617564696f20646576696365">Opening and closing an audio device</h2> First the application must call the <b class="fname">sio_open</b>() function to obtain a handle to the device; later it will be passed as the <i class="farg">hdl</i> argument of most other functions. The <i class="farg">name</i> parameter gives the device string discussed in <a class="link-man" href="../html7/sndio.html">sndio(7)</a>. In most cases it should be set to <span class="define">SIO_DEVANY</span> to allow the user to select it using the <span class="env">AUDIODEVICE</span> environment variable.<div class="spacer">
</div>
The following values of the <i class="farg">mode</i> parameter are supported:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIO_PLAY</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Play-only mode: data written will be played by the device.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIO_REC</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Record-only mode: samples are recorded by the device and must be read.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIO_PLAY</span> | <span class="define">SIO_REC</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
The device plays and records synchronously; this means that the n-th recorded sample was physically sampled exactly when the n-th played sample was actually played.</dd>
</dl>
<div class="spacer">
</div>
If the <i class="farg">nbio_flag</i> argument is true (i.e. non-zero), then the <b class="fname">sio_read</b>() and <b class="fname">sio_write</b>() functions (see below) will be non-blocking.<div class="spacer">
</div>
The <b class="fname">sio_close</b>() function stops the device as if <b class="fname">sio_stop</b>() is called and frees the handle. Thus, no samples submitted with <b class="fname">sio_write</b>() are discarded.</div>
<div class="subsection">
<h2 id="x4e65676f74696174696e6720617564696f20706172616d6574657273">Negotiating audio parameters</h2> Audio samples are interleaved. A frame consists of one sample for each channel. For example, a 16-bit stereo encoding has two samples per frame and, two bytes per sample (thus 4 bytes per frame).<div class="spacer">
</div>
The set of parameters of the device that can be controlled is given by the following structure:<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
struct sio_par { 
	unsigned int bits;	/* bits per sample */ 
	unsigned int bps;	/* bytes per sample */ 
	unsigned int sig;	/* 1 = signed, 0 = unsigned int */ 
	unsigned int le;	/* 1 = LE, 0 = BE byte order */ 
	unsigned int msb;	/* 1 = MSB, 0 = LSB aligned */ 
	unsigned int rchan;	/* number channels for recording */ 
	unsigned int pchan;	/* number channels for playback */ 
	unsigned int rate;	/* frames per second */ 
	unsigned int appbufsz;	/* minimum buffer size without xruns */ 
	unsigned int bufsz;	/* end-to-end buffer size (read-only) */ 
	unsigned int round;	/* optimal buffer size divisor */ 
#define SIO_IGNORE	0	/* pause during xrun */ 
#define SIO_SYNC	1	/* resync after xrun */ 
#define SIO_ERROR	2	/* terminate on xrun */ 
	unsigned int xrun;	/* what to do on overrun/underrun */ 
};</pre>
<div class="spacer">
</div>
The parameters are as follows:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">bits</b></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
Number of bits per sample: must be between 1 and 32.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">bps</b></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
Bytes per samples; if specified, it must be large enough to hold all bits. By default it's set to the smallest power of two large enough to hold <b class="var">bits</b>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">sig</b></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
If set (i.e. non-zero) then the samples are signed, else unsigned.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">le</b></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
If set, then the byte order is little endian, else big endian; it's meaningful only if <b class="var">bps</b> &gt; 1.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">msb</b></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
If set, then the <b class="var">bits</b> are aligned in the packet to the most significant bit (i.e. lower bits are padded), else to the least significant bit (i.e. higher bits are padded); it's meaningful only if <b class="var">bits</b> &lt; <b class="var">bps</b> * 8.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">rchan</b></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
The number of recorded channels; meaningful only if <span class="define">SIO_REC</span> mode was selected.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">pchan</b></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
The number of played channels; meaningful only if <span class="define">SIO_PLAY</span> mode was selected.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">rate</b></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
The sampling frequency in Hz.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">bufsz</b></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
The maximum number of frames that may be buffered. This parameter takes into account any buffers, and can be used for latency calculations. It is read-only.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">appbufsz</b></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
Size of the buffer in frames the application must maintain non-empty (on the play end) or non-full (on the record end) by calling <b class="fname">sio_write</b>() or <b class="fname">sio_read</b>() fast enough to avoid overrun or underrun conditions. The audio subsystem may use additional buffering, thus this parameter cannot be used for latency calculations.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">round</b></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
Optimal number of frames that the application buffers should be a multiple of, to get best performance. Applications can use this parameter to round their block size.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">xrun</b></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
The action when the client doesn't accept recorded data or doesn't provide data to play fast enough; it can be set to one of the <span class="define">SIO_IGNORE</span>, <span class="define">SIO_SYNC</span>, or <span class="define">SIO_ERROR</span> constants.</dd>
</dl>
<div class="spacer">
</div>
The following approach is recommended to negotiate device parameters:<ul style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-bul">
<li class="list-bul" style="margin-top: 1.00em;">
Initialize a <span class="type">sio_par</span> structure using <b class="fname">sio_initpar</b>() and fill it with the desired parameters. Then call <b class="fname">sio_setpar</b>() to request the device to use them. Parameters left unset in the <span class="type">sio_par</span> structure will be set to device-specific defaults.</li>
<li class="list-bul" style="margin-top: 1.00em;">
Call <b class="fname">sio_getpar</b>() to retrieve the actual parameters of the device and check that they are usable. If they are not, then fail or set up a conversion layer. Sometimes the rate set can be slightly different to what was requested. A difference of about 0.5% is not audible and should be ignored.</li>
</ul>
<div class="spacer">
</div>
Parameters cannot be changed after <b class="fname">sio_start</b>() has been called, <b class="fname">sio_stop</b>() must be called before parameters can be changed.<div class="spacer">
</div>
If the device is exposed by the <a class="link-man" href="../html8/sndiod.html">sndiod(8)</a> server, which is the default configuration, a transparent emulation layer will automatically be set up, and in this case any combination of rate, encoding and numbers of channels is supported.<div class="spacer">
</div>
To ease filling the <span class="type">sio_par</span> structure, the following macros can be used:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIO_BPS</span>(<i class="farg">bits</i>)</dt>
<dd class="list-tag" style="margin-left: 13.00ex;">
Return the smallest value for <b class="var">bps</b> that is a power of two and that is large enough to hold <i class="farg">bits</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIO_LE_NATIVE</span></dt>
<dd class="list-tag" style="margin-left: 13.00ex;">
Can be used to set the <b class="var">le</b> parameter when native byte order is required.</dd>
</dl>
</div>
<div class="subsection">
<h2 id="x47657474696e6720646576696365206361706162696c6974696573">Getting device capabilities</h2> There's no way to get an exhaustive list of all parameter combinations the device supports. Applications that need to have a set of working parameter combinations in advance can use the <b class="fname">sio_getcap</b>() function.<div class="spacer">
</div>
The <span class="type">sio_cap</span> structure contains the list of parameter configurations. Each configuration contains multiple parameter sets. The application must examine all configurations, and choose its parameter set from <span class="emph">one</span> of the configurations. Parameters of different configurations <span class="emph">are not</span> usable together.<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
struct sio_cap { 
	struct sio_enc {		/* allowed encodings */ 
		unsigned int bits; 
		unsigned int bps; 
		unsigned int sig; 
		unsigned int le; 
		unsigned int msb; 
	} enc[SIO_NENC]; 
	unsigned int rchan[SIO_NCHAN];	/* allowed rchans */ 
	unsigned int pchan[SIO_NCHAN];	/* allowed pchans */ 
	unsigned int rate[SIO_NRATE];	/* allowed rates */ 
	unsigned int nconf;		/* num. of confs[] */ 
	struct sio_conf { 
		unsigned int enc;	/* bitmask of enc[] indexes */ 
		unsigned int rchan;	/* bitmask of rchan[] indexes */ 
		unsigned int pchan;	/* bitmask of pchan[] indexes */ 
		unsigned int rate;	/* bitmask of rate[] indexes */ 
	} confs[SIO_NCONF]; 
};</pre>
<div class="spacer">
</div>
The parameters are as follows:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">enc</b>[<span class="define">SIO_NENC</span>]</dt>
<dd class="list-tag" style="margin-left: 16.00ex;">
Array of supported encodings. The tuple of <b class="var">bits</b>, <b class="var">bps</b>, <b class="var">sig</b>, <b class="var">le</b>, and <b class="var">msb</b> parameters are usable in the corresponding parameters of the <span class="type">sio_par</span> structure.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">rchan</b>[<span class="define">SIO_NCHAN</span>]</dt>
<dd class="list-tag" style="margin-left: 16.00ex;">
Array of supported channel numbers for recording usable in the <span class="type">sio_par</span> structure.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">pchan</b>[<span class="define">SIO_NCHAN</span>]</dt>
<dd class="list-tag" style="margin-left: 16.00ex;">
Array of supported channel numbers for playback usable in the <span class="type">sio_par</span> structure.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">rate</b>[<span class="define">SIO_NRATE</span>]</dt>
<dd class="list-tag" style="margin-left: 16.00ex;">
Array of supported sample rates usable in the <span class="type">sio_par</span> structure.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">nconf</b></dt>
<dd class="list-tag" style="margin-left: 16.00ex;">
Number of different configurations available, i.e. number of filled elements of the <b class="var">confs[]</b> array.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">confs</b>[<span class="define">SIO_NCONF</span>]</dt>
<dd class="list-tag" style="margin-left: 16.00ex;">
Array of available configurations. Each configuration contains bitmasks indicating which elements of the above parameter arrays are valid for the given configuration. For instance, if the second bit of <b class="var">rate</b> is set, in the <span class="type">sio_conf</span> structure, then the second element of the <b class="var">rate</b>[<span class="define">SIO_NRATE</span>] array of the <span class="type">sio_cap</span> structure is valid for this configuration.</dd>
</dl>
</div>
<div class="subsection">
<h2 id="x5374617274696e6720616e642073746f7070696e672074686520646576696365">Starting and stopping the device</h2> The <b class="fname">sio_start</b>() function puts the device in a waiting state: the device will wait for playback data to be provided (using the <b class="fname">sio_write</b>() function). Once enough data is queued to ensure that play buffers will not underrun, actual playback is started automatically. If record mode only is selected, then recording starts immediately. In full-duplex mode, playback and recording will start synchronously as soon as enough data to play is available.<div class="spacer">
</div>
The <b class="fname">sio_stop</b>() function puts the audio subsystem in the same state as before <b class="fname">sio_start</b>() is called. It stops recording, drains the play buffer and then stops playback. If samples to play are queued but playback hasn't started yet then playback is forced immediately; playback will actually stop once the buffer is drained. In no case are samples in the play buffer discarded.</div>
<div class="subsection">
<h2 id="x506c6179696e6720616e64207265636f7264696e67">Playing and recording</h2> When record mode is selected, the <b class="fname">sio_read</b>() function must be called to retrieve recorded data; it must be called often enough to ensure that internal buffers will not overrun. It will store at most <i class="farg">nbytes</i> bytes at the <i class="farg">addr</i> location and return the number of bytes stored. Unless the <i class="farg">nbio_flag</i> flag is set, it will block until data becomes available and will return zero only on error.<div class="spacer">
</div>
Similarly, when play mode is selected, the <b class="fname">sio_write</b>() function must be called to provide data to play. Unless the <i class="farg">nbio_flag</i> is set, <b class="fname">sio_write</b>() will block until the requested amount of data is written.</div>
<div class="subsection">
<h2 id="x4e6f6e1e626c6f636b696e67206d6f6465206f7065726174696f6e">Non-blocking mode operation</h2> If the <i class="farg">nbio_flag</i> is set on <b class="fname">sio_open</b>(), then the <b class="fname">sio_read</b>() and <b class="fname">sio_write</b>() functions will never block; if no data is available, they will return zero immediately.<div class="spacer">
</div>
The <a class="link-man" href="../html2/poll.html">poll(2)</a> system call can be used to check if data can be read from or written to the device. The <b class="fname">sio_pollfd</b>() function fills the array <i class="farg">pfd</i> of <span class="type">pollfd</span> structures, used by <a class="link-man" href="../html2/poll.html">poll(2)</a>, with <i class="farg">events</i>; the latter is a bit-mask of <span class="define">POLLIN</span> and <span class="define">POLLOUT</span> constants; refer to <a class="link-man" href="../html2/poll.html">poll(2)</a> for more details. <b class="fname">sio_pollfd</b>() returns the number of <span class="type">pollfd</span> structures filled. The <b class="fname">sio_revents</b>() function returns the bit-mask set by <a class="link-man" href="../html2/poll.html">poll(2)</a> in the <i class="farg">pfd</i> array of <span class="type">pollfd</span> structures. If <span class="define">POLLIN</span> is set, recorded samples are available in the device buffer and can be read with <b class="fname">sio_read</b>(). If <span class="define">POLLOUT</span> is set, space is available in the device buffer and new samples to play can be submitted with <b class="fname">sio_write</b>(). <span class="define">POLLHUP</span> may be set if an error occurs, even if it is not selected with <b class="fname">sio_pollfd</b>().<div class="spacer">
</div>
The <b class="fname">sio_nfds</b>() function returns the number of <span class="type">pollfd</span> structures the caller must preallocate in order to be sure that <b class="fname">sio_pollfd</b>() will never overrun.</div>
<div class="subsection">
<h2 id="x53796e6368726f6e697a696e67206e6f6e1e617564696f206576656e747320746f2074686520617564696f2073747265616d20696e207265616c1e74696d65">Synchronizing non-audio events to the audio stream in real-time</h2> In order to perform actions at precise positions of the audio stream, such as displaying video in sync with the audio stream, the application must be notified in real-time of the exact position in the stream the hardware is processing.<div class="spacer">
</div>
The <b class="fname">sio_onmove</b>() function can be used to register the <b class="fname">cb</b>() callback function called at regular time intervals. The <i class="farg">delta</i> argument contains the number of frames the hardware played and/or recorded since the last call of <b class="fname">cb</b>(). It is called by <b class="fname">sio_read</b>(), <b class="fname">sio_write</b>(), and <b class="fname">sio_revents</b>(). When the first sample is played and/or recorded, right after the device starts, the callback is invoked with a zero <i class="farg">delta</i> argument. The value of the <i class="farg">arg</i> pointer is passed to the callback and can contain anything.<div class="spacer">
</div>
If desired, the application can maintain the current position by starting from zero (when <b class="fname">sio_start</b>() is called) and adding to the current position <i class="farg">delta</i> every time <b class="fname">cb</b>() is called.</div>
<div class="subsection">
<h2 id="x4d6561737572696e6720746865206c6174656e637920616e642062756666657273207573616765">Measuring the latency and buffers usage</h2> The playback latency is the delay it will take for the frame just written to become audible, expressed in number of frames. The exact playback latency can be obtained by subtracting the current position from the number of frames written. Once playback is actually started (first sample audible) the latency will never exceed the <b class="var">bufsz</b> parameter (see the sections above). There's a phase during which <b class="fname">sio_write</b>() only queues data; once there's enough data, actual playback starts. During this phase talking about latency is meaningless.<div class="spacer">
</div>
In any cases, at most <b class="var">bufsz</b> frames are buffered. This value takes into account all buffers. The number of frames stored is equal to the number of frames written minus the current position.<div class="spacer">
</div>
The recording latency is obtained similarly, by subtracting the number of frames read from the current position.<div class="spacer">
</div>
Note that <b class="fname">sio_write</b>() might block even if there is buffer space left; using the buffer usage to guess if <b class="fname">sio_write</b>() would block is false and leads to unreliable programs &#8211; consider using <a class="link-man" href="../html2/poll.html">poll(2)</a> for this.</div>
<div class="subsection">
<h2 id="x48616e646c696e6720627566666572206f76657272756e7320616e6420756e64657272756e73">Handling buffer overruns and underruns</h2> When the application cannot accept recorded data fast enough, the record buffer (of size <b class="var">appbufsz</b>) might overrun; in this case recorded data is lost. Similarly if the application cannot provide data to play fast enough, the play buffer underruns and silence is played instead. Depending on the <b class="var">xrun</b> parameter of the <span class="type">sio_par</span> structure, the audio subsystem will behave as follows:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIO_IGNORE</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
The devices pauses during overruns and underruns, thus the current position (obtained through <b class="fname">sio_onmove</b>()) stops being incremented. Once the overrun and/or underrun condition is gone, the device resumes; play and record are always kept in sync. With this mode, the application cannot notice underruns and/or overruns and shouldn't care about them.<div class="spacer">
</div>
This mode is the default. It's suitable for applications, like audio players and telephony, where time is not important and overruns or underruns are not short.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIO_SYNC</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
If the play buffer underruns, then silence is played, but in order to reach the right position in time, the same amount of written samples will be discarded once the application is unblocked. Similarly, if the record buffer overruns, then samples are discarded, but the same amount of silence will be returned later. The current position (obtained through <b class="fname">sio_onmove</b>()) is still incremented. When the play buffer underruns the play latency might become negative; when the record buffer overruns, the record latency might become larger than <b class="var">bufsz</b>.<div class="spacer">
</div>
This mode is suitable for applications, like music production, where time is important and where underruns or overruns are short and rare.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIO_ERROR</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
With this mode, on the first play buffer underrun or record buffer overrun, playback and/or recording is terminated and no other function than <b class="fname">sio_close</b>() will succeed.<div class="spacer">
</div>
This mode is mostly useful for testing.</dd>
</dl>
</div>
<div class="subsection">
<h2 id="x436f6e74726f6c6c696e672074686520766f6c756d65">Controlling the volume</h2> The <b class="fname">sio_setvol</b>() function can be used to set playback attenuation. The <i class="farg">vol</i> parameter takes a value between 0 (maximum attenuation) and <span class="define">SIO_MAXVOL</span> (no attenuation). It specifies the weight the audio subsystem will give to this stream. It is not meant to control hardware parameters like speaker gain; the <a class="link-man" href="../html1/mixerctl.html">mixerctl(1)</a> interface should be used for that purpose instead.<div class="spacer">
</div>
An application can use the <b class="fname">sio_onvol</b>() function to register a callback function that will be called each time the volume is changed, including when <b class="fname">sio_setvol</b>() is used. The callback is always invoked when <b class="fname">sio_onvol</b>() is called in order to provide the initial volume. An application can safely assume that once <b class="fname">sio_onvol</b>() has returned a non-zero value, the callback has been invoked and thus the current volume is available. If there's no volume setting available, <b class="fname">sio_onvol</b>() returns 0 and the callback is never invoked and calls to <b class="fname">sio_setvol</b>() are ignored.<div class="spacer">
</div>
The <b class="fname">sio_onvol</b>() function can be called with a NULL argument to check whether a volume knob is available.</div>
<div class="subsection">
<h2 id="x4572726f722068616e646c696e67">Error handling</h2> Errors related to the audio subsystem (like hardware errors, dropped connections) and programming errors (e.g. call to <b class="fname">sio_read</b>() on a play-only stream) are considered fatal. Once an error occurs, all functions taking a <i class="farg">sio_hdl</i> argument, except <b class="fname">sio_close</b>() and <b class="fname">sio_eof</b>(), stop working (i.e. always return 0).<div class="spacer">
</div>
The <b class="fname">sio_eof</b>() function can be used at any stage; it returns 0 if there's no pending error, and a non-zero value if there's an error.</div>
<div class="subsection">
<h2>Use with <a class="link-man" href="../html2/pledge.html">pledge(2)</a></h2> If the <b class="name">sndio</b> library is used in combination with <a class="link-man" href="../html2/pledge.html">pledge(2)</a>, then the <b class="fname">sio_open</b>() function needs the <b class="var">stdio</b>, <b class="var">rpath</b>, <b class="var">wpath</b>, <b class="var">cpath</b>, <b class="var">inet</b>, <b class="var">unix</b>, <b class="var">dns</b>, and <b class="var">audio</b> <a class="link-man" href="../html2/pledge.html">pledge(2)</a> promises.<ul style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-bul">
<li class="list-bul" style="margin-top: 1.00em;">
<b class="var">rpath</b>, <b class="var">wpath</b>, and <b class="var">cpath</b> are needed to read, write or create the authentication cookie <i class="file">~/.aucat_cookie</i>.</li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="var">rpath</b>, <b class="var">wpath</b>, and <b class="var">audio</b> are needed when the device is a local raw device.</li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="var">unix</b> is needed when the device is a local <a class="link-man" href="../html8/sndiod.html">sndiod(8)</a> sub-device.</li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="var">inet</b> and <b class="var">dns</b> are needed when the device is a remote <a class="link-man" href="../html8/sndiod.html">sndiod(8)</a> sub-device.</li>
</ul>
<div class="spacer">
</div>
Once no further calls to <b class="fname">sio_open</b>() will be made, all these <a class="link-man" href="../html2/pledge.html">pledge(2)</a> promises may be dropped, except for the <b class="var">audio</b> promise.</div>
</div>
<div class="section">
<h1 id="x52455455524e2056414c554553">RETURN VALUES</h1> The <b class="fname">sio_open</b>() function returns the newly created handle on success or NULL on failure. The <b class="fname">sio_setpar</b>(), <b class="fname">sio_getpar</b>(), <b class="fname">sio_getcap</b>(), <b class="fname">sio_start</b>(), <b class="fname">sio_stop</b>(), <b class="fname">sio_pollfd</b>(), and <b class="fname">sio_setvol</b>() functions return 1 on success and 0 on failure. The <b class="fname">sio_read</b>() and <b class="fname">sio_write</b>() functions return the number of bytes transferred.</div>
<div class="section">
<h1 id="x454e5649524f4e4d454e54">ENVIRONMENT</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="env">AUDIODEVICE</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
Device to use if <b class="fname">sio_open</b>() is called with <span class="define">SIO_DEVANY</span> as the <i class="farg">name</i> argument.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="env">SNDIO_DEBUG</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
The debug level: may be a value between 0 and 2.</dd>
</dl>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html2/pledge.html">pledge(2)</a>, <a class="link-man" href="../html4/audio.html">audio(4)</a>, <a class="link-man" href="../html7/sndio.html">sndio(7)</a>, <a class="link-man" href="../html8/sndiod.html">sndiod(8)</a>, <a class="link-man" href="../html9/audio.html">audio(9)</a></div>
<div class="section">
<h1 id="x42554753">BUGS</h1> The <a class="link-man" href="../html4/audio.html">audio(4)</a> driver doesn't drain playback buffers, thus if sndio is used to directly access an <a class="link-man" href="../html4/audio.html">audio(4)</a> device, the <b class="fname">sio_stop</b>() function will stop playback immediately.<div class="spacer">
</div>
If the application doesn't consume recorded data fast enough then &#8220;control messages&#8221; from the <a class="link-man" href="../html8/sndiod.html">sndiod(8)</a> server are delayed and consequently <b class="fname">sio_onmove</b>() callback or volume changes may be delayed.<div class="spacer">
</div>
The <b class="fname">sio_open</b>(), <b class="fname">sio_setpar</b>(), <b class="fname">sio_getpar</b>(), <b class="fname">sio_getcap</b>(), <b class="fname">sio_start</b>(), and <b class="fname">sio_stop</b>() functions may block for a very short period of time, thus they should be avoided in code sections where blocking is not desirable.</div>
</div>
</body>
</html>

