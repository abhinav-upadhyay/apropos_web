<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
EVBUFFER_NEW(3)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">evbuffer_new</b>, <b class="name">evbuffer_free</b>, <b class="name">evbuffer_setcb</b>, <b class="name">evbuffer_expand</b>, <b class="name">evbuffer_add</b>, <b class="name">evbuffer_add_buffer</b>, <b class="name">evbuffer_add_printf</b>, <b class="name">evbuffer_add_vprintf</b>, <b class="name">evbuffer_drain</b>, <b class="name">evbuffer_remove</b>, <b class="name">evbuffer_write</b>, <b class="name">evbuffer_read</b>, <b class="name">evbuffer_find</b>, <b class="name">evbuffer_readline</b>, <b class="name">evbuffer_readln</b> &#8212; <span class="desc">libevent utility API for buffered input/output</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">event.h</a>&gt;</b><div class="spacer">
</div>
<i class="ftype">struct evbuffer *</i><br/>
<b class="fname">evbuffer_new</b>(<i class="farg" style="white-space:nowrap;">void</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">evbuffer_free</b>(<i class="farg" style="white-space:nowrap;">struct evbuffer *buf</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">evbuffer_setcb</b>(<i class="farg">struct evbuffer *buf</i>, <i class="farg">void (*cb)(struct evbuffer *, size_t, size_t, void *)</i>, <i class="farg">void *cbarg</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">evbuffer_expand</b>(<i class="farg" style="white-space:nowrap;">struct evbuffer *buf</i>, <i class="farg" style="white-space:nowrap;">size_t datlen</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">evbuffer_add</b>(<i class="farg" style="white-space:nowrap;">struct evbuffer *buf</i>, <i class="farg" style="white-space:nowrap;">const void *data</i>, <i class="farg" style="white-space:nowrap;">size_t size</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">evbuffer_add_buffer</b>(<i class="farg" style="white-space:nowrap;">struct evbuffer *dst</i>, <i class="farg" style="white-space:nowrap;">struct evbuffer *src</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">evbuffer_add_printf</b>(<i class="farg" style="white-space:nowrap;">struct evbuffer *buf</i>, <i class="farg" style="white-space:nowrap;">const char *fmt</i>, <i class="farg" style="white-space:nowrap;">...</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">evbuffer_add_vprintf</b>(<i class="farg" style="white-space:nowrap;">struct evbuffer *buf</i>, <i class="farg" style="white-space:nowrap;">const char *fmt</i>, <i class="farg" style="white-space:nowrap;">va_list ap</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">evbuffer_drain</b>(<i class="farg" style="white-space:nowrap;">struct evbuffer *buf</i>, <i class="farg" style="white-space:nowrap;">size_t size</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">evbuffer_remove</b>(<i class="farg" style="white-space:nowrap;">struct evbuffer *buf</i>, <i class="farg" style="white-space:nowrap;">void *data</i>, <i class="farg" style="white-space:nowrap;">size_t datlen</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">evbuffer_write</b>(<i class="farg" style="white-space:nowrap;">struct evbuffer *buf</i>, <i class="farg" style="white-space:nowrap;">int fd</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">evbuffer_read</b>(<i class="farg" style="white-space:nowrap;">struct evbuffer *buf</i>, <i class="farg" style="white-space:nowrap;">int fd</i>, <i class="farg" style="white-space:nowrap;">int size</i>);<div class="spacer">
</div>
<i class="ftype">u_char *</i><br/>
<b class="fname">evbuffer_find</b>(<i class="farg" style="white-space:nowrap;">struct evbuffer *buf</i>, <i class="farg" style="white-space:nowrap;">const u_char *data</i>, <i class="farg" style="white-space:nowrap;">size_t size</i>);<div class="spacer">
</div>
<i class="ftype">char *</i><br/>
<b class="fname">evbuffer_readline</b>(<i class="farg" style="white-space:nowrap;">struct evbuffer *buf</i>);<div class="spacer">
</div>
<i class="ftype">char *</i><br/>
<b class="fname">evbuffer_readln</b>(<i class="farg">struct evbuffer *buf</i>, <i class="farg">size_t *read_out</i>, <i class="farg">enum evbuffer_eol_style eol_style</i>);<div class="spacer">
</div>
<i class="ftype">size_t</i><br/>
<b class="fname">EVBUFFER_LENGTH</b>(<i class="farg" style="white-space:nowrap;">const struct evbuffer *buf</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The evbuffer API provides an implementation of buffering for use with libevent.<div class="spacer">
</div>
<b class="fname">evbuffer_new</b>() allocates and initialises a new evbuffer structure.<div class="spacer">
</div>
<b class="fname">evbuffer_free</b>() deallocates the evbuffer structure <i class="farg">buf</i> and any referenced storage.<div class="spacer">
</div>
<b class="fname">evbuffer_setcb</b>() sets the callback <i class="farg">cb</i> to be invoked with argument <i class="farg">cbarg</i> when the data in evbuffer <i class="farg">buf</i> is modified.<div class="spacer">
</div>
<b class="fname">evbuffer_expand</b>() expands the available space in <i class="farg">buf</i> to at least <i class="farg">datlen</i> bytes.<div class="spacer">
</div>
<b class="fname">evbuffer_add</b>() appends a copy of <i class="farg">size</i> bytes from buffer <i class="farg">data</i> to the end of the evbuffer <i class="farg">buf</i>.<div class="spacer">
</div>
<b class="fname">evbuffer_add_buffer</b>() moves the data off the <i class="farg">src</i> evbuffer and appends it to <i class="farg">dst</i>.<div class="spacer">
</div>
<b class="fname">evbuffer_add_printf</b>() appends a <a class="link-man" href="../html3/printf.html">printf(3)</a> style formatted string specified by <i class="farg">fmt</i> to the end of <i class="farg">buf</i>.<div class="spacer">
</div>
<b class="fname">evbuffer_add_vprintf</b>() appends a <a class="link-man" href="../html3/vprintf.html">vprintf(3)</a> style formatted string specified by <i class="farg">fmt</i> with a va_list <i class="farg">ap</i> to the end of <i class="farg">buf</i>.<div class="spacer">
</div>
<b class="fname">evbuffer_drain</b>() deletes <i class="farg">size</i> bytes from the beginning of the evbuffer <i class="farg">buf</i>.<div class="spacer">
</div>
<b class="fname">evbuffer_remove</b>() reads and drains up to <i class="farg">datlen</i> bytes from the beginning of the evbuffer <i class="farg">buf</i> into <i class="farg">data</i>.<div class="spacer">
</div>
<b class="fname">evbuffer_write</b>() writes and drains the contents of evbuffer <i class="farg">buf</i> to the file descriptor <i class="farg">fd</i>.<div class="spacer">
</div>
<b class="fname">evbuffer_read</b>() appends up to <i class="farg">size</i> bytes on to the end of the evbuffer <i class="farg">buf</i> by reading from the file descriptor <i class="farg">fd</i>.<div class="spacer">
</div>
<b class="fname">evbuffer_find</b>() finds the <i class="farg">size</i> length string <i class="farg">data</i> in the evbuffer <i class="farg">buf</i>.<div class="spacer">
</div>
<b class="fname">evbuffer_readline</b>() reads and drains a single line from the evbuffer <i class="farg">buf</i>. A line is delimited by &quot;\n&quot;, &quot;\r&quot;, &quot;\r\n&quot;, or &quot;\n\r&quot;. It is the responsibility of the caller to free the returned line with <a class="link-man" href="../html3/free.html">free(3)</a>.<div class="spacer">
</div>
<b class="fname">evbuffer_readln</b>() reads and drains a single line from the evbuffer <i class="farg">buf</i>. The length of the line will be stored in <i class="farg">read_out</i> on success. It is the responsibility of the caller to free the returned line with <a class="link-man" href="../html3/free.html">free(3)</a>. The line delimiter is specified as one of the following:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">EVBUFFER_EOL_ANY</span></dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Any sequence of newline or carriage return characters.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">EVBUFFER_EOL_CRLF</span></dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A new line optionally preceded by a carriage return.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">EVBUFFER_EOL_CRLF_STRICT</span></dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A carriage return followed by a new line character.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">EVBUFFER_EOL_LF</span></dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A new line character.</dd>
</dl>
<div class="spacer">
</div>
<b class="fname">EVBUFFER_LENGTH</b>() reports how many bytes are stored in the evbuffer <i class="farg">buf</i>.</div>
<div class="section">
<h1 id="x52455455524e2056414c554553">RETURN VALUES</h1> <b class="fname">evbuffer_new</b>() returns a pointer to a newly allocated buffer on success, or <span class="define">NULL</span> on failure and sets <b class="var">errno</b> to indicate the failure.<div class="spacer">
</div>
<b class="fname">evbuffer_expand</b>(), <b class="fname">evbuffer_add</b>(), and <b class="fname">evbuffer_add_buffer</b>() return 0 on success, or -1 on failure and set <b class="var">errno</b> to indicate the failure.<div class="spacer">
</div>
<b class="fname">evbuffer_add_printf</b>() and <b class="fname">evbuffer_add_vprintf</b>() return the number of bytes added on success, or -1 on failure.<div class="spacer">
</div>
<b class="fname">evbuffer_remove</b>() returns the number of bytes read.<div class="spacer">
</div>
<b class="fname">evbuffer_write</b>() returns the number of bytes written and drained on success, or -1 on failure and sets <b class="var">errno</b> to indicate the failure.<div class="spacer">
</div>
<b class="fname">evbuffer_read</b>() returns the number of bytes appended to the evbuffer on success, 0 on an end of file condition, or -1 on failure and sets <b class="var">errno</b> to indicate the failure.<div class="spacer">
</div>
<b class="fname">evbuffer_find</b>() returns a pointer to the start of the string within the evbuffer on success, or <span class="define">NULL</span> on failure.<div class="spacer">
</div>
<b class="fname">evbuffer_readline</b>() and <b class="fname">evbuffer_readln</b>() return a pointer to the line on success, or <span class="define">NULL</span> on failure.<div class="spacer">
</div>
<b class="fname">EVBUFFER_LENGTH</b>() returns the number of bytes available in the evbuffer.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html2/errno.html">errno(2)</a>, <a class="link-man" href="../html3/event.html">event(3)</a>, <a class="link-man" href="../html3/free.html">free(3)</a>, <a class="link-man" href="../html3/printf.html">printf(3)</a></div>
<div class="section">
<h1 id="x415554484f5253">AUTHORS</h1> The <b class="name">event</b> library was written by <span class="author">Niels Provos</span>.</div>
</div>
</body>
</html>

