<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
FGETLN(3)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">fgetln</b> &#8212; <span class="desc">get a line from a stream</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">stdio.h</a>&gt;</b><div class="spacer">
</div>
<i class="ftype">char *</i><br/>
<b class="fname">fgetln</b>(<i class="farg" style="white-space:nowrap;">FILE *stream</i>, <i class="farg" style="white-space:nowrap;">size_t *len</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <b class="fname">fgetln</b>() function returns a pointer to the next line from the stream referenced by <i class="farg">stream</i>. This line is <span class="emph">not</span> a C string as it does not end with a terminating NUL character. The length of the line, including the final newline, is stored in the memory location to which <i class="farg">len</i> points and is guaranteed to be greater than 0 upon successful completion. (Note, however, that if the last line in the stream does not end in a newline, the returned text will not contain a newline.)</div>
<div class="section">
<h1 id="x52455455524e2056414c554553">RETURN VALUES</h1> Upon successful completion a pointer is returned; this pointer becomes invalid after the next I/O operation on <i class="farg">stream</i> (whether successful or not) or as soon as the stream is closed. Otherwise, <span class="define">NULL</span> is returned.<div class="spacer">
</div>
The <b class="fname">fgetln</b>() function does not distinguish between end-of-file and error; the routines <a class="link-man" href="../html3/feof.html">feof(3)</a> and <a class="link-man" href="../html3/ferror.html">ferror(3)</a> must be used to determine which occurred. If an error occurs, the global variable <b class="var">errno</b> is set to indicate the error. The end-of-file condition is remembered, even on a terminal, and all subsequent attempts to read will return <span class="define">NULL</span> until the condition is cleared with <a class="link-man" href="../html3/clearerr.html">clearerr(3)</a>.<div class="spacer">
</div>
The text to which the returned pointer points may be modified, provided that no changes are made beyond the returned size. These changes are lost as soon as the pointer becomes invalid.</div>
<div class="section">
<h1 id="x4552524f5253">ERRORS</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
[<span class="errno">EBADF</span>]</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
The argument <i class="farg">stream</i> is not a stream open for reading.</dd>
</dl>
<div class="spacer">
</div>
The <b class="fname">fgetln</b>() function may also fail and set <b class="var">errno</b> for any of the errors specified for the routines <a class="link-man" href="../html3/fflush.html">fflush(3)</a>, <a class="link-man" href="../html3/malloc.html">malloc(3)</a>, <a class="link-man" href="../html2/read.html">read(2)</a>, <a class="link-man" href="../html2/stat.html">stat(2)</a>, or <a class="link-man" href="../html3/realloc.html">realloc(3)</a>.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html3/ferror.html">ferror(3)</a>, <a class="link-man" href="../html3/fgets.html">fgets(3)</a>, <a class="link-man" href="../html3/fopen.html">fopen(3)</a>, <a class="link-man" href="../html3/fparseln.html">fparseln(3)</a>, <a class="link-man" href="../html3/putc.html">putc(3)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The <b class="fname">fgetln</b>() function first appeared in <span class="unix">4.4BSD</span>.</div>
<div class="section">
<h1 id="x43415645415453">CAVEATS</h1> Since the returned buffer is not a C string (it is not NUL terminated), a common practice is to replace the newline character with &#8216;\0&#8217;. However, if the last line in a file does not contain a newline, the returned text won't contain a newline either. The following code demonstrates how to deal with this problem by allocating a temporary buffer:<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
	char *buf, *lbuf; 
	size_t len; 
 
	lbuf = NULL; 
	while ((buf = fgetln(fp, &amp;len))) { 
		if (buf[len - 1] == '\n') 
			buf[len - 1] = '\0'; 
		else { 
			/* EOF without EOL, copy and add the NUL */ 
			if ((lbuf = malloc(len + 1)) == NULL) 
				err(1, NULL); 
			memcpy(lbuf, buf, len); 
			lbuf[len] = '\0'; 
			buf = lbuf; 
		} 
		printf(&quot;%s\n&quot;, buf); 
	} 
	free(lbuf);</pre>
</div>
</div>
</body>
</html>

