<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
EC_POINT_ADD(3)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
EC_POINT_ADD(3)</td>
<td class="head-vol">
OpenSSL</td>
<td class="head-rtitle">
EC_POINT_ADD(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> EC_POINT_add, EC_POINT_dbl, EC_POINT_invert, EC_POINT_is_at_infinity, EC_POINT_is_on_curve, EC_POINT_cmp, EC_POINT_make_affine, EC_POINTs_make_affine, EC_POINTs_mul, EC_POINT_mul, EC_GROUP_precompute_mult, EC_GROUP_have_precompute_mult - Functions for performing mathematical operations and tests on EC_POINT objects.</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
 #include &lt;openssl/ec.h&gt;<br/>
 #include &lt;openssl/bn.h&gt;<br/>
<br/>
 int EC_POINT_add(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a, const EC_POINT *b, BN_CTX *ctx);<br/>
 int EC_POINT_dbl(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a, BN_CTX *ctx);<br/>
 int EC_POINT_invert(const EC_GROUP *group, EC_POINT *a, BN_CTX *ctx);<br/>
 int EC_POINT_is_at_infinity(const EC_GROUP *group, const EC_POINT *p);<br/>
 int EC_POINT_is_on_curve(const EC_GROUP *group, const EC_POINT *point, BN_CTX *ctx);<br/>
 int EC_POINT_cmp(const EC_GROUP *group, const EC_POINT *a, const EC_POINT *b, BN_CTX *ctx);<br/>
 int EC_POINT_make_affine(const EC_GROUP *group, EC_POINT *point, BN_CTX *ctx);<br/>
 int EC_POINTs_make_affine(const EC_GROUP *group, size_t num, EC_POINT *points[], BN_CTX *ctx);<br/>
 int EC_POINTs_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *n, size_t num, const EC_POINT *p[], const BIGNUM *m[], BN_CTX *ctx);<br/>
 int EC_POINT_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *n, const EC_POINT *q, const BIGNUM *m, BN_CTX *ctx);<br/>
 int EC_GROUP_precompute_mult(EC_GROUP *group, BN_CTX *ctx);<br/>
 int EC_GROUP_have_precompute_mult(const EC_GROUP *group);<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> EC_POINT_add adds the two points  <b>a</b> and <b>b</b> and places the result in <b>r</b>. Similarly EC_POINT_dbl doubles the point <b>a</b> and places the result in  <b>r</b>. In both cases it is valid for <b>r</b> to be one of <b>a</b> or <b>b</b>.<div class="spacer">
</div>
EC_POINT_invert calculates the inverse of the supplied point <b>a</b>. The result is placed back in <b>a</b>.<div class="spacer">
</div>
The function EC_POINT_is_at_infinity tests whether the supplied point is at infinity or not.<div class="spacer">
</div>
EC_POINT_is_on_curve tests whether the supplied point is on the curve or not.<div class="spacer">
</div>
EC_POINT_cmp compares the two supplied points and tests whether or not they are equal.<div class="spacer">
</div>
The functions EC_POINT_make_affine and EC_POINTs_make_affine force the internal representation of the EC_POINT(s) into the affine co-ordinate system. In the case of EC_POINTs_make_affine the value  <b>num</b> provides the number of points in the array <b>points</b> to be forced.<div class="spacer">
</div>
EC_POINT_mul calculates the value generator * <b>n</b> + <b>q</b> * <b>m</b> and stores the result in <b>r</b>. The value <b>n</b> may be NULL in which case the result is just <b>q</b> * <b>m</b>.<div class="spacer">
</div>
EC_POINTs_mul calculates the value generator * <b>n</b> + <b>q[0]</b> * <b>m[0]</b> + ... + <b>q[num-1]</b> * <b>m[num-1]</b>. As for EC_POINT_mul the value  <b>n</b> may be NULL.<div class="spacer">
</div>
The function EC_GROUP_precompute_mult stores multiples of the generator for faster point multiplication, whilst EC_GROUP_have_precompute_mult tests whether precomputation has already been done. See  <i>EC_GROUP_copy</i>(3) for information about the generator.</div>
<div class="section">
<h1>RETURN VALUES</h1> The following functions return 1 on success or 0 on error: EC_POINT_add, EC_POINT_dbl, EC_POINT_invert, EC_POINT_make_affine, EC_POINTs_make_affine, EC_POINTs_make_affine, EC_POINT_mul, EC_POINTs_mul and EC_GROUP_precompute_mult.<div class="spacer">
</div>
EC_POINT_is_at_infinity returns 1 if the point is at infinity, or 0 otherwise.<div class="spacer">
</div>
EC_POINT_is_on_curve returns 1 if the point is on the curve, 0 if not, or -1 on error.<div class="spacer">
</div>
EC_POINT_cmp returns 1 if the points are not equal, 0 if they are, or -1 on error.<div class="spacer">
</div>
EC_GROUP_have_precompute_mult return 1 if a precomputation has been done, or 0 if not.</div>
<div class="section">
<h1>SEE ALSO</h1>  <i>crypto</i>(3), <i>ec</i>(3), <i>EC_GROUP_new</i>(3), <i>EC_GROUP_copy</i>(3),  <i>EC_POINT_new</i>(3), <i>EC_KEY_new</i>(3),  <i>EC_GFp_simple_method</i>(3), <i>d2i_ECPKParameters</i>(3)</div>
<table class="foot">
<tr>
<td class="foot-date">
2014-07-11</td>
<td class="foot-os">
OpenBSD 6.0</td>
</tr>
</table>
</div>
</body>
</html>

