<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
SSL_CTX_SET_GENERATE_SESSION_ID(3)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">SSL_CTX_set_generate_session_id</b>, <b class="name">SSL_set_generate_session_id</b>, <b class="name">SSL_has_matching_session_id</b> &#8212; <span class="desc">manipulate generation of SSL session IDs (server only)</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">openssl/ssl.h</a>&gt;</b><div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
 typedef int (*GEN_SESSION_CB)(const SSL *ssl, unsigned char *id, 
                               unsigned int *id_len);</pre>
<br/>
<i class="ftype">int</i><br/>
<b class="fname">SSL_CTX_set_generate_session_id</b>(<i class="farg" style="white-space:nowrap;">SSL_CTX *ctx</i>, <i class="farg" style="white-space:nowrap;">GEN_SESSION_CB cb</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">SSL_set_generate_session_id</b>(<i class="farg" style="white-space:nowrap;">SSL *ssl</i>, <i class="farg" style="white-space:nowrap;">GEN_SESSION_CB</i>, <i class="farg" style="white-space:nowrap;">cb);</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">SSL_has_matching_session_id</b>(<i class="farg">const SSL *ssl</i>, <i class="farg">const unsigned char *id</i>, <i class="farg">unsigned int id_len</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> <b class="fname">SSL_CTX_set_generate_session_id</b>() sets the callback function for generating new session ids for SSL/TLS sessions for <i class="farg">ctx</i> to be <i class="farg">cb</i>.<div class="spacer">
</div>
<b class="fname">SSL_set_generate_session_id</b>() sets the callback function for generating new session ids for SSL/TLS sessions for <i class="farg">ssl</i> to be <i class="farg">cb</i>.<div class="spacer">
</div>
<b class="fname">SSL_has_matching_session_id</b>() checks, whether a session with id <i class="farg">id</i> (of length <i class="farg">id_len</i>) is already contained in the internal session cache of the parent context of <i class="farg">ssl</i>.</div>
<div class="section">
<h1 id="x4e4f544553">NOTES</h1> When a new session is established between client and server, the server generates a session id. The session id is an arbitrary sequence of bytes. The length of the session id is 16 bytes for SSLv2 sessions and between 1 and 32 bytes for SSLv3/TLSv1. The session id is not security critical but must be unique for the server. Additionally, the session id is transmitted in the clear when reusing the session so it must not contain sensitive information.<div class="spacer">
</div>
Without a callback being set, an OpenSSL server will generate a unique session id from pseudo random numbers of the maximum possible length. Using the callback function, the session id can be changed to contain additional information like, e.g., a host id in order to improve load balancing or external caching techniques.<div class="spacer">
</div>
The callback function receives a pointer to the memory location to put <i class="farg">id</i> into and a pointer to the maximum allowed length <i class="farg">id_len</i>. The buffer at location <i class="farg">id</i> is only guaranteed to have the size <i class="farg">id_len</i>. The callback is only allowed to generate a shorter id and reduce <i class="farg">id_len</i>; the callback <span class="emph">must never</span> increase <i class="farg">id_len</i> or write to the location <i class="farg">id</i> exceeding the given limit.<div class="spacer">
</div>
If a SSLv2 session id is generated and <i class="farg">id_len</i> is reduced, it will be restored after the callback has finished and the session id will be padded with 0x00. It is not recommended to change the <i class="farg">id_len</i> for SSLv2 sessions. The callback can use the <a class="link-man" href="../html3/SSL_get_version.html">SSL_get_version(3)</a> function to check whether the session is of type SSLv2.<div class="spacer">
</div>
The location <i class="farg">id</i> is filled with 0x00 before the callback is called, so the callback may only fill part of the possible length and leave <i class="farg">id_len</i> untouched while maintaining reproducibility.<div class="spacer">
</div>
Since the sessions must be distinguished, session ids must be unique. Without the callback a random number is used, so that the probability of generating the same session id is extremely small (2^128 possible ids for an SSLv2 session, 2^256 for SSLv3/TLSv1). In order to ensure the uniqueness of the generated session id, the callback must call <b class="fname">SSL_has_matching_session_id</b>() and generate another id if a conflict occurs. If an id conflict is not resolved, the handshake will fail. If the application codes, e.g., a unique host id, a unique process number, and a unique sequence number into the session id, uniqueness could easily be achieved without randomness added (it should however be taken care that no confidential information is leaked this way). If the application cannot guarantee uniqueness, it is recommended to use the maximum <i class="farg">id_len</i> and fill in the bytes not used to code special information with random data to avoid collisions.<div class="spacer">
</div>
<b class="fname">SSL_has_matching_session_id</b>() will only query the internal session cache, not the external one. Since the session id is generated before the handshake is completed, it is not immediately added to the cache. If another thread is using the same internal session cache, a race condition can occur in that another thread generates the same session id. Collisions can also occur when using an external session cache, since the external cache is not tested with <b class="fname">SSL_has_matching_session_id</b>() and the same race condition applies.<div class="spacer">
</div>
When calling <b class="fname">SSL_has_matching_session_id</b>() for an SSLv2 session with reduced <i class="farg">id_len</i>, the match operation will be performed using the fixed length required and with a 0x00 padded id.<div class="spacer">
</div>
The callback must return 0 if it cannot generate a session id for whatever reason and return 1 on success.</div>
<div class="section">
<h1 id="x52455455524e2056414c554553">RETURN VALUES</h1> <b class="fname">SSL_CTX_set_generate_session_id</b>() and <b class="fname">SSL_set_generate_session_id</b>() always return 1.<div class="spacer">
</div>
<b class="fname">SSL_has_matching_session_id</b>() returns 1 if another session with the same id is already in the cache.</div>
<div class="section">
<h1 id="x4558414d504c4553">EXAMPLES</h1> The callback function listed will generate a session id with the server id given, and will fill the rest with pseudo random bytes:<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
const char session_id_prefix = &quot;www-18&quot;; 
 
#define MAX_SESSION_ID_ATTEMPTS 10 
static int 
generate_session_id(const SSL *ssl, unsigned char *id, 
    unsigned int *id_len) 
{ 
	unsigned int count = 0; 
	const char *version; 
 
	version = SSL_get_version(ssl); 
	if (!strcmp(version, &quot;SSLv2&quot;)) { 
		/* we must not change id_len */ 
		; 
	} 
 
	do { 
		RAND_pseudo_bytes(id, *id_len); 
		/* 
		 * Prefix the session_id with the required prefix. NB: If 
		 * our prefix is too long, clip it &#8211; but there will be 
		 * worse effects anyway, e.g., the server could only 
		 * possibly create one session ID (the prefix!) so all 
		 * future session negotiations will fail due to conflicts. 
		 */ 
		memcpy(id, session_id_prefix, 
		    (strlen(session_id_prefix) &lt; *id_len) ? 
		    strlen(session_id_prefix) : *id_len); 
	} while (SSL_has_matching_session_id(ssl, id, *id_len) &amp;&amp; 
	    (++count &lt; MAX_SESSION_ID_ATTEMPTS)); 
 
	if (count &gt;= MAX_SESSION_ID_ATTEMPTS) 
		return 0; 
	return 1; 
}</pre>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html3/ssl.html">ssl(3)</a>, <a class="link-man" href="../html3/SSL_get_version.html">SSL_get_version(3)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> <b class="fname">SSL_CTX_set_generate_session_id</b>(), <b class="fname">SSL_set_generate_session_id</b>() and <b class="fname">SSL_has_matching_session_id</b>() were introduced in OpenSSL 0.9.7.</div>
</div>
</body>
</html>

