<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
MALLOC(3)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">malloc</b>, <b class="name">calloc</b>, <b class="name">reallocarray</b>, <b class="name">realloc</b>, <b class="name">free</b> &#8212; <span class="desc">memory allocation and deallocation</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">stdlib.h</a>&gt;</b><div class="spacer">
</div>
<i class="ftype">void *</i><br/>
<b class="fname">malloc</b>(<i class="farg" style="white-space:nowrap;">size_t size</i>);<div class="spacer">
</div>
<i class="ftype">void *</i><br/>
<b class="fname">calloc</b>(<i class="farg" style="white-space:nowrap;">size_t nmemb</i>, <i class="farg" style="white-space:nowrap;">size_t size</i>);<div class="spacer">
</div>
<i class="ftype">void *</i><br/>
<b class="fname">reallocarray</b>(<i class="farg" style="white-space:nowrap;">void *ptr</i>, <i class="farg" style="white-space:nowrap;">size_t nmemb</i>, <i class="farg" style="white-space:nowrap;">size_t size</i>);<div class="spacer">
</div>
<i class="ftype">void *</i><br/>
<b class="fname">realloc</b>(<i class="farg" style="white-space:nowrap;">void *ptr</i>, <i class="farg" style="white-space:nowrap;">size_t size</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">free</b>(<i class="farg" style="white-space:nowrap;">void *ptr</i>);<div class="spacer">
</div>
<span class="type">char *malloc_options</span>;</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <b class="fname">malloc</b>() function allocates uninitialized space for an object of the specified <i class="farg">size</i>. <b class="fname">malloc</b>() maintains multiple lists of free blocks according to size, allocating space from the appropriate list. The allocated space is suitably aligned (after possible pointer coercion) for storage of any type of object. If the space is of <span class="emph">pagesize</span> or larger, the memory returned will be page-aligned.<div class="spacer">
</div>
The <b class="fname">calloc</b>() function allocates space for an array of <i class="farg">nmemb</i> objects, each of the specified <i class="farg">size</i>. The space is initialized to zero.<div class="spacer">
</div>
The <b class="fname">realloc</b>() function changes the size of the object pointed to by <i class="farg">ptr</i> to <i class="farg">size</i> bytes and returns a pointer to the (possibly moved) object. The contents of the object are unchanged up to the lesser of the new and old sizes. If the new size is larger, the value of the newly allocated portion of the object is indeterminate and uninitialized. If the space cannot be allocated, the object pointed to by <i class="farg">ptr</i> is unchanged. If <i class="farg">ptr</i> is <span class="define">NULL</span>, <b class="fname">realloc</b>() behaves like <b class="fname">malloc</b>() and allocates a new object.<div class="spacer">
</div>
The <b class="fname">reallocarray</b>() function is similar to <b class="fname">realloc</b>() except it operates on <i class="farg">nmemb</i> members of size <i class="farg">size</i> and checks for integer overflow in the calculation <i class="farg">nmemb</i> * <i class="farg">size</i>.<div class="spacer">
</div>
The <b class="fname">free</b>() function causes the space pointed to by <i class="farg">ptr</i> to be either placed on a list of free pages to make it available for future allocation or, if required, to be returned to the kernel using <a class="link-man" href="../html2/munmap.html">munmap(2)</a>. If <i class="farg">ptr</i> is a <span class="define">NULL</span> pointer, no action occurs. If <i class="farg">ptr</i> was previously freed by <b class="fname">free</b>(), <b class="fname">realloc</b>(), or <b class="fname">reallocarray</b>(), the behavior is undefined and the double free is a security concern.</div>
<div class="section">
<h1 id="x52455455524e2056414c554553">RETURN VALUES</h1> Upon successful completion, the functions <b class="fname">malloc</b>(), <b class="fname">calloc</b>(), <b class="fname">realloc</b>(), and <b class="fname">reallocarray</b>() return a pointer to the allocated space; otherwise, a <span class="define">NULL</span> pointer is returned and <b class="var">errno</b> is set to <span class="errno">ENOMEM</span>.<div class="spacer">
</div>
If <i class="farg">size</i> or <i class="farg">nmemb</i> is equal to 0, a unique pointer to an access protected, zero sized object is returned. Access via this pointer will generate a <span class="define">SIGSEGV</span> exception.<div class="spacer">
</div>
If multiplying <i class="farg">nmemb</i> and <i class="farg">size</i> results in integer overflow, <b class="fname">calloc</b>() and <b class="fname">reallocarray</b>() return <span class="define">NULL</span> and set <b class="var">errno</b> to <span class="errno">ENOMEM</span>.</div>
<div class="section">
<h1 id="x4944494f4d53">IDIOMS</h1> Consider <b class="fname">calloc</b>() or the extension <b class="fname">reallocarray</b>() when there is multiplication in the <i class="farg">size</i> argument of <b class="fname">malloc</b>() or <b class="fname">realloc</b>(). For example, avoid this common idiom as it may lead to integer overflow:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
if ((p = malloc(num * size)) == NULL) 
	err(1, NULL);</pre>
<div class="spacer">
</div>
A drop-in replacement is the <span class="unix">OpenBSD</span> extension <b class="fname">reallocarray</b>():<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
if ((p = reallocarray(NULL, num, size)) == NULL) 
	err(1, NULL);</pre>
<div class="spacer">
</div>
Alternatively, <b class="fname">calloc</b>() may be used at the cost of initialization overhead.<div class="spacer">
</div>
When using <b class="fname">realloc</b>(), be careful to avoid the following idiom:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
size += 50; 
if ((p = realloc(p, size)) == NULL) 
	return (NULL);</pre>
<div class="spacer">
</div>
Do not adjust the variable describing how much memory has been allocated until the allocation has been successful. This can cause aberrant program behavior if the incorrect size value is used. In most cases, the above sample will also result in a leak of memory. As stated earlier, a return value of <span class="define">NULL</span> indicates that the old object still remains allocated. Better code looks like this:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
newsize = size + 50; 
if ((newp = realloc(p, newsize)) == NULL) { 
	free(p); 
	p = NULL; 
	size = 0; 
	return (NULL); 
} 
p = newp; 
size = newsize;</pre>
<div class="spacer">
</div>
As with <b class="fname">malloc</b>(), it is important to ensure the new size value will not overflow; i.e. avoid allocations like the following:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
if ((newp = realloc(p, num * size)) == NULL) { 
	...</pre>
<div class="spacer">
</div>
Instead, use <b class="fname">reallocarray</b>():<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
if ((newp = reallocarray(p, num, size)) == NULL) { 
	...</pre>
<div class="spacer">
</div>
Calling <b class="fname">realloc</b>() with a <span class="define">NULL</span> <i class="farg">ptr</i> is equivalent to calling <b class="fname">malloc</b>(). Instead of this idiom:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
if (p == NULL) 
	newp = malloc(newsize); 
else 
	newp = realloc(p, newsize);</pre>
<div class="spacer">
</div>
Use the following:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
newp = realloc(p, newsize);</pre>
</div>
<div class="section">
<h1 id="x454e5649524f4e4d454e54">ENVIRONMENT</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="env">MALLOC_OPTIONS</span></dt>
<dd class="list-tag" style="margin-left: 16.00ex;">
String of flags documented in <a class="link-man" href="../html5/malloc.conf.html">malloc.conf(5)</a>.</dd>
</dl>
</div>
<div class="section">
<h1 id="x46494c4553">FILES</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="file">/etc/malloc.conf</i></dt>
<dd class="list-tag" style="margin-left: 16.00ex;">
Symbolic link to filename containing option flags.</dd>
</dl>
</div>
<div class="section">
<h1 id="x4558414d504c4553">EXAMPLES</h1> If <b class="fname">malloc</b>() must be used with multiplication, be sure to test for overflow:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
size_t num, size; 
... 
 
/* Check for size_t overflow */ 
if (size &amp;&amp; num &gt; SIZE_MAX / size) 
	errc(1, EOVERFLOW, &quot;overflow&quot;); 
 
if ((p = malloc(size * num)) == NULL) 
	err(1, NULL);</pre>
<div class="spacer">
</div>
The above test is not sufficient in all cases. For example, multiplying ints requires a different set of checks:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
int num, size; 
... 
 
/* Avoid invalid requests */ 
if (size &lt; 0 || num &lt; 0) 
	errc(1, EOVERFLOW, &quot;overflow&quot;); 
 
/* Check for signed int overflow */ 
if (size &amp;&amp; num &gt; INT_MAX / size) 
	errc(1, EOVERFLOW, &quot;overflow&quot;); 
 
if ((p = malloc(size * num)) == NULL) 
	err(1, NULL);</pre>
<div class="spacer">
</div>
Assuming the implementation checks for integer overflow as <span class="unix">OpenBSD</span> does, it is much easier to use <b class="fname">calloc</b>() or <b class="fname">reallocarray</b>().<div class="spacer">
</div>
The above examples could be simplified to:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
if ((p = reallocarray(NULL, num, size)) == NULL) 
	err(1, NULL);</pre>
<div class="spacer">
</div>
or at the cost of initialization:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
if ((p = calloc(num, size)) == NULL) 
	err(1, NULL);</pre>
</div>
<div class="section">
<h1 id="x444941474e4f5354494353">DIAGNOSTICS</h1> If <b class="fname">malloc</b>(), <b class="fname">calloc</b>(), <b class="fname">realloc</b>(), <b class="fname">reallocarray</b>(), or <b class="fname">free</b>() detect an error condition, a message will be printed to file descriptor 2 (not using stdio). Errors will result in the process being aborted.<div class="spacer">
</div>
Here is a brief description of the error messages and what they mean:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
&#8220;out of memory&#8221;</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
If the <b class="flag">X</b> option is specified it is an error for <b class="fname">malloc</b>(), <b class="fname">calloc</b>(), <b class="fname">realloc</b>(), or <b class="fname">reallocarray</b>() to return <span class="define">NULL</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#8220;malloc init mmap failed&#8221;</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This is a rather weird condition that is most likely to indicate a seriously overloaded system or a ulimit restriction.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#8220;bogus pointer (double free?)&#8221;</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
An attempt to <b class="fname">free</b>(), <b class="fname">realloc</b>(), or <b class="fname">reallocarray</b>() an unallocated pointer was made.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#8220;chunk is already free&#8221;</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
There was an attempt to free a chunk that had already been freed.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#8220;use after free&#8221;</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
A chunk has been modified after it was freed.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#8220;modified chunk-pointer&#8221;</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The pointer passed to <b class="fname">free</b>(), <b class="fname">realloc</b>(), or <b class="fname">reallocarray</b>() has been modified.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#8220;recursive call&#8221;</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
An attempt was made to call recursively into these functions, i.e., from a signal handler. This behavior is not supported. In particular, signal handlers should <span class="emph">not</span> use any of the <b class="fname">malloc</b>() functions nor utilize any other functions which may call <b class="fname">malloc</b>() (e.g., <a class="link-man" href="../html3/stdio.html">stdio(3)</a> routines).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#8220;unknown char in MALLOC_OPTIONS&#8221;</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
We found something we didn't understand.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#8220;malloc cache overflow/underflow&#8221;</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The internal malloc page cache has been corrupted.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#8220;malloc free slot lost&#8221;</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The internal malloc page cache has been corrupted.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#8220;guard size&#8221;</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
An inconsistent guard size was detected.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
any other error</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<b class="fname">malloc</b>() detected an internal error; consult sources and/or wizards.</dd>
</dl>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html2/brk.html">brk(2)</a>, <a class="link-man" href="../html2/mmap.html">mmap(2)</a>, <a class="link-man" href="../html2/munmap.html">munmap(2)</a>, <a class="link-man" href="../html3/alloca.html">alloca(3)</a>, <a class="link-man" href="../html3/getpagesize.html">getpagesize(3)</a>, <a class="link-man" href="../html3/posix_memalign.html">posix_memalign(3)</a>, <a class="link-man" href="../html3/sysconf.html">sysconf(3)</a>, <a class="link-man" href="../html5/malloc.conf.html">malloc.conf(5)</a></div>
<div class="section">
<h1 id="x5354414e4441524453">STANDARDS</h1> The <b class="fname">malloc</b>(), <b class="fname">calloc</b>(), <b class="fname">realloc</b>(), and <b class="fname">free</b>() functions conform to ANSI X3.159-1989 (&#8220;ANSI&#160;C89&#8221;).<div class="spacer">
</div>
If <i class="farg">size</i> or <i class="farg">nmemb</i> are 0, the return value is implementation defined; other conforming implementations may return <span class="define">NULL</span> in this case.<div class="spacer">
</div>
The <span class="env">MALLOC_OPTIONS</span> environment variable, the file <i class="file">/etc/malloc.conf</i>, and the <i class="link-sec"><a class="link-sec" href="#x444941474e4f5354494353">DIAGNOSTICS</a></i> output are extensions to the standard.</div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> A <b class="fname">free</b>() internal kernel function and a predecessor to <b class="fname">malloc</b>(), <b class="fname">alloc</b>(), first appeared in Version&#160;1 AT&amp;T UNIX. C library functions <b class="fname">alloc</b>() and <b class="fname">free</b>() appeared in Version&#160;6 AT&amp;T UNIX. The functions <b class="fname">malloc</b>(), <b class="fname">calloc</b>(), and <b class="fname">realloc</b>() first appeared in Version&#160;7 AT&amp;T UNIX.<div class="spacer">
</div>
A new implementation by Chris Kingsley was introduced in <span class="unix">4.2BSD</span>, followed by a complete rewrite by Poul-Henning Kamp which appeared in <span class="unix">FreeBSD&#160;2.2</span> and was included in <span class="unix">OpenBSD&#160;2.0</span>. These implementations were all <a class="link-man" href="../html2/sbrk.html">sbrk(2)</a> based. In <span class="unix">OpenBSD&#160;3.8</span>, Thierry Deval rewrote <b class="name">malloc</b> to use the <a class="link-man" href="../html2/mmap.html">mmap(2)</a> system call, making the page addresses returned by <b class="name">malloc</b> random. A rewrite by Otto Moerbeek introducing a new central data structure and more randomization appeared in <span class="unix">OpenBSD&#160;4.4</span>.<div class="spacer">
</div>
The <b class="fname">reallocarray</b>() function appeared in <span class="unix">OpenBSD&#160;5.6</span>.</div>
<div class="section">
<h1 id="x43415645415453">CAVEATS</h1> When using <b class="fname">malloc</b>(), be wary of signed integer and <span class="type">size_t</span> overflow especially when there is multiplication in the <i class="farg">size</i> argument.<div class="spacer">
</div>
Signed integer overflow will cause undefined behavior which compilers typically handle by wrapping back around to negative numbers. Depending on the input, this can result in allocating more or less memory than intended.<div class="spacer">
</div>
An unsigned overflow has defined behavior which will wrap back around and return less memory than intended.<div class="spacer">
</div>
A signed or unsigned integer overflow is a <span class="emph">security</span> risk if less memory is returned than intended. Subsequent code may corrupt the heap by writing beyond the memory that was allocated. An attacker may be able to leverage this heap corruption to execute arbitrary code.<div class="spacer">
</div>
Consider using <b class="fname">calloc</b>() or <b class="fname">reallocarray</b>() instead of using multiplication in <b class="fname">malloc</b>() and <b class="fname">realloc</b>() to avoid these problems on <span class="unix">OpenBSD</span>.</div>
</div>
</body>
</html>

