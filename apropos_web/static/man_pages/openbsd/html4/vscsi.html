<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
VSCSI(4)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">vscsi</b> &#8212; <span class="desc">virtual SCSI controller</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="config">vscsi0 at root</b><div class="spacer">
</div>
<br/>
<b class="includes">#include &lt;<a class="link-includes">sys/types.h</a>&gt;</b><br/>
<b class="includes">#include &lt;<a class="link-includes">sys/ioctl.h</a>&gt;</b><br/>
<b class="includes">#include &lt;<a class="link-includes">scsi/scsi_all.h</a>&gt;</b><br/>
<b class="includes">#include &lt;<a class="link-includes">dev/vscsivar.h</a>&gt;</b></div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <b class="name">vscsi</b> device takes commands from the kernel SCSI midlayer and makes them available to userland for handling. Using this interface it is possible to implement virtual SCSI devices that are usable by the kernel.<div class="spacer">
</div>
The following <a class="link-man" href="../html2/ioctl.html">ioctl(2)</a> commands are provided to allow userland to dequeue SCSI commands and reply to them:<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
VSCSI_I2T <i class="farg">struct vscsi_ioc_i2t *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Dequeue a SCSI command. If no SCSI commands are available to dequeue, <a class="link-man" href="../html2/ioctl.html">ioctl(2)</a> will fail and set <b class="var">errno</b> to <span class="define">EAGAIN</span>.<div class="spacer">
</div>
When one or more SCSI commands are available to dequeue, <a class="link-man" href="../html2/select.html">select(2)</a> will indicate the descriptor as ready to read.<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
struct vscsi_ioc_i2t { 
	int			tag; 
 
	u_int			target; 
	u_int			lun; 
 
	struct scsi_generic	cmd; 
	size_t			cmdlen; 
 
	size_t			datalen; 
	int			direction; 
#define VSCSI_DIR_NONE		0 
#define VSCSI_DIR_READ		1 
#define VSCSI_DIR_WRITE		2 
};</pre>
<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
VSCSI_DATA_READ <i class="farg">struct vscsi_ioc_data *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
VSCSI_DATA_WRITE <i class="farg">struct vscsi_ioc_data *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Read or write data in response to a SCSI command identified by tag.<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
struct vscsi_ioc_data { 
	int			tag; 
 
	void *			data; 
	size_t			datalen; 
};</pre>
<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
VSCSI_T2I <i class="farg">struct vscsi_ioc_t2i *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Signal completion of a SCSI command identified by tag.<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
struct vscsi_ioc_t2i { 
	int			tag; 
 
	int			status; 
#define VSCSI_STAT_DONE		0 
#define VSCSI_STAT_SENSE	1 
#define VSCSI_STAT_RESET	2 
#define VSCSI_STAT_ERR		3 
	struct scsi_sense_data	sense; 
};</pre>
<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
VSCSI_REQPROBE <i class="farg">struct vscsi_ioc_devevent *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
VSCSI_REQDETACH <i class="farg">struct vscsi_ioc_devevent *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Request a probe or a detach of the device at the addresses specified by the target and lun fields.<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
struct vscsi_ioc_devevent { 
	u_int			target; 
	u_int			lun; 
};</pre>
</dd>
</dl>
</div>
<div class="section">
<h1 id="x46494c4553">FILES</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
/dev/vscsi0</dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
</dd>
</dl>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html2/ioctl.html">ioctl(2)</a>, <a class="link-man" href="../html4/intro.html">intro(4)</a>, <a class="link-man" href="../html4/scsi.html">scsi(4)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The <b class="name">vscsi</b> driver first appeared in <span class="unix">OpenBSD&#160;4.5</span>.</div>
<div class="section">
<h1 id="x415554484f5253">AUTHORS</h1> <span class="author">David Gwynne</span> &lt;<a class="link-mail" href="mailto:dlg@openbsd.org">dlg@openbsd.org</a>&gt;.</div>
</div>
</body>
</html>

