<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
VIDEO(4)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">video</b> &#8212; <span class="desc">device-independent video driver layer</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="config">video* at uvideo?</b><div class="spacer">
</div>
<br/>
<b class="includes">#include &lt;<a class="link-includes">sys/types.h</a>&gt;</b><br/>
<b class="includes">#include &lt;<a class="link-includes">sys/ioctl.h</a>&gt;</b><br/>
<b class="includes">#include &lt;<a class="link-includes">sys/videoio.h</a>&gt;</b></div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <b class="name">video</b> driver provides support for various video devices. It provides a uniform programming interface layer above different underlying video hardware drivers. The <b class="name">video</b> driver uses the V4L2 (Video for Linux Two) API which is widely used by video applications. Therefore this document mainly describes the V4L2 API parts which are supported by the <b class="name">video</b> driver.</div>
<div class="section">
<h1 id="x494f43544c53">IOCTLS</h1> The following <a class="link-man" href="../html2/ioctl.html">ioctl(2)</a> commands are supported:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">VIDIOC_QUERYCAP</span> <i class="farg">struct v4l2_capability *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Query device capabilities.<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
struct v4l2_capability { 
	u_int8_t	driver[16]; 
	u_int8_t	card[32]; 
	u_int8_t	bus_info[32]; 
	u_int32_t	version; 
	u_int32_t	capabilities; 
	u_int32_t	device_caps; 
	u_int32_t	reserved[3]; 
};</pre>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">VIDIOC_ENUM_FMT</span> <i class="farg">struct v4l2_fmtdesc *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Enumerate image formats.<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
struct v4l2_fmtdesc { 
	u_int32_t	index; 
	u_int32_t	type; 
	u_int32_t	flags; 
	u_int8_t	description[32]; 
	u_int32_t	pixelformat; 
	u_int32_t	reserved[4]; 
};</pre>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">VIDIOC_S_FMT</span> <i class="farg">struct v4l2_format *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Set the data format.<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
struct v4l2_format { 
	u_int32_t	type; 
	union { 
		struct v4l2_pix_format		pix; 
		struct v4l2_pix_format_mplane	pix_mp; 
		struct v4l2_window		win; 
		struct v4l2_vbi_format		vbi; 
		struct v4l2_sliced_vbi_format	sliced; 
		struct v4l2_sdr_format		sdr; 
		u_int8_t			raw_data[200]; 
        } fmt; 
};</pre>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">VIDIOC_G_FMT</span> <i class="farg">struct v4l2_format *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Get the data format.<div class="spacer">
</div>
Same structure as for <span class="define">VIDIOC_S_FMT</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">VIDIOC_ENUMINPUT</span> <i class="farg">struct v4l2_input *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Enumerate video inputs.<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
struct v4l2_input { 
	u_int32_t	index; 
	u_int8_t	name[32]; 
	u_int32_t	type; 
	u_int32_t	audioset; 
	u_int32_t	tuner; 
	v4l2_std_id	std; 
	u_int32_t	status; 
	u_int32_t	capabilities; 
	u_int32_t	reserved[3]; 
};</pre>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">VIDIOC_G_INPUT</span> <i class="farg">int *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Get the current video input.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">VIDIOC_S_INPUT</span> <i class="farg">int *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Select the current video input.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">VIDIOC_REQBUFS</span> <i class="farg">struct v4l2_requestbuffers *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Initiate memory mapping or user pointer I/O.<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
struct v4l2_requestbuffers { 
	u_int32_t	count; 
	u_int32_t	type; 
	u_int32_t	memory; 
	u_int32_t	reserved[2]; 
};</pre>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">VIDIOC_QUERYBUF</span> <i class="farg">struct v4l2_buffer *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Query the status of a buffer.<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
struct v4l2_buffer { 
	u_int32_t		index; 
	u_int32_t		type; 
	u_int32_t		bytesused; 
	u_int32_t		flags; 
	u_int32_t		field; 
	struct timeval		timestamp; 
	struct v4l2_timecode	timecode; 
	u_int32_t		sequence; 
	u_int32_t		memory; 
	union { 
		u_int32_t		offset; 
		unsigned long		userptr; 
		struct v4l2_plane	*planes; 
		int32_t			fd; 
	} m; 
	u_int32_t		length; 
	u_int32_t		reserved2; 
	u_int32_t		reserved; 
};</pre>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">VIDIOC_QBUF</span> <i class="farg">struct v4l2_buffer *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Add a buffer to the queue.<div class="spacer">
</div>
Same structure as for <span class="define">VIDIOC_QUERYBUF</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">VIDIOC_DQBUF</span> <i class="farg">struct v4l2_buffer *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Remove a buffer from the queue.<div class="spacer">
</div>
Same structure as for <span class="define">VIDIOC_QUERYBUF</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">VIDIOC_STREAMON</span> <i class="farg">int *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Start video stream.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">VIDIOC_STREAMOFF</span> <i class="farg">int *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Stop video stream.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">VIDIOC_TRY_FMT</span> <i class="farg">struct v4l2_format *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Try a data format.<div class="spacer">
</div>
Same structure as for <span class="define">VIDIOC_S_FMT</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">VIDIOC_ENUM_FRAMEINTERVALS</span> <i class="farg">struct v4l2_frmivalenum *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Enumerate frame intervals.<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
struct v4l2_frmivalemun { 
	u_int32_t		index; 
	u_int32_t		pixel_format; 
	u_int32_t		width; 
	u_int32_t		height; 
	u_int32_t		type; 
	union { 
		struct v4l2_fract		discrete; 
		struct v4l2_frmival_stepwise	stepwise; 
	}; 
	u_int32_t		reserved[2]; 
}; 
 
struct v4l2_frmival_stepwise { 
	struct v4l2_fract min; 
	struct v4l2_fract max; 
	struct v4l2_fract step; 
};</pre>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">VIDIOC_S_PARM</span> <i class="farg">struct v4l2_streamparm *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Set streaming parameters.<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
struct v4l2_streamparm { 
	u_int32_t	type; 
	union { 
		struct v4l2_captureparm	capture; 
		struct v4l2_outputparm	output; 
		u_int8_t		raw_data[200]; 
	} parm; 
}; 
 
struct v4l2_captureparm	{ 
	u_int32_t	capability; 
	u_int32_t	capturemode; 
	struct v4l2_fract	timeperframe; 
	u_int32_t	extendedmode; 
	u_int32_t	readbuffers; 
	u_int32_t	reserved[4]; 
}; 
 
struct v4l2_outputparm	{ 
	u_int32_t	capability; 
	u_int32_t	outputmode; 
	struct v4l2_fract	timeperframe; 
	u_int32_t	extendedmode; 
	u_int32_t	writebuffers; 
	u_int32_t	reserved[4]; 
};</pre>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">VIDIOC_G_PARM</span> <i class="farg">struct v4l2_streamparm *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Get the streaming parameters.<div class="spacer">
</div>
Same structures as for <span class="define">VIDIOC_S_PARM</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">VIDIOC_QUERYCTRL</span> <i class="farg">struct v4l2_queryctrl *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Enumerate control items.<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
struct v4l2_queryctrl { 
	u_int32_t	id; 
	u_int32_t	type; 
	u_int8_t	name[32]; 
	int32_t		minimum; 
	int32_t		maximum; 
	int32_t		step; 
	int32_t		default_value; 
	u_int32_t	flags; 
	u_int32_t	reserved[2]; 
};</pre>
</dd>
</dl>
<div class="spacer">
</div>
Command independent enumerations are:<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
enum v4l2_buf_type { 
	V4L2_BUF_TYPE_VIDEO_CAPTURE = 1, 
	V4L2_BUF_TYPE_VIDEO_OUTPUT = 2, 
	V4L2_BUF_TYPE_VIDEO_OVERLAY = 3, 
	V4L2_BUF_TYPE_VBI_CAPTURE = 4, 
	V4L2_BUF_TYPE_VBI_OUTPUT = 5, 
	V4L2_BUF_TYPE_SLICED_VBI_CAPTURE = 6, 
	V4L2_BUF_TYPE_SLICED_VBI_OUTPUT = 7, 
	V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY = 8, 
	V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE = 9, 
	V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE = 10, 
	V4L2_BUF_TYPE_SDR_CAPTURE = 11, 
	V4L2_BUF_TYPE_SDR_OUTPUT = 12, 
	V4L2_BUF_TYPE_PRIVATE = 0x80, 
}; 
 
enum v4l2_memory { 
	V4L2_MEMORY_MMAP = 1, 
	V4L2_MEMORY_USERPTR = 2, 
	V4L2_MEMORY_OVERLAY = 3, 
	V4L2_MEMORY_DMABUF = 4, 
}; 
 
enum v4l2_ctrl_type { 
	V4L2_CTRL_TYPE_INTEGER = 1, 
	V4L2_CTRL_TYPE_BOOLEAN = 2, 
	V4L2_CTRL_TYPE_MENU = 3, 
	V4L2_CTRL_TYPE_BUTTON = 4, 
	V4L2_CTRL_TYPE_INTEGER64 = 5, 
	V4L2_CTRL_TYPE_CTRL_CLASS = 6, 
	V4L2_CTRL_TYPE_STRING = 7, 
	V4L2_CTRL_TYPE_BITMASK = 8, 
	V4L2_CTRL_TYPE_INTEGER_MENU = 9, 
	V4L2_CTRL_COMPOUND_TYPES = 0x0100, 
	V4L2_CTRL_TYPE_U8 = 0x0100, 
	V4L2_CTRL_TYPE_U16 = 0x0101, 
	V4L2_CTRL_TYPE_U32 = 0x0102, 
}; 
 
enum v4l2_frmivaltypes { 
	V4L2_FRMIVAL_TYPE_DISCRETE = 1, 
	V4L2_FRMIVAL_TYPE_CONTINUOUS = 2, 
	V4L2_FRMIVAL_TYPE_STEPWISE = 3, 
};</pre>
<div class="spacer">
</div>
Command independent structures are:<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
struct v4l2_pix_format { 
	u_int32_t	width; 
	u_int32_t	height; 
	u_int32_t	pixelformat; 
	u_int32_t	field; 
	u_int32_t	bytesperline; 
	u_int32_t	sizeimage; 
	u_int32_t	colorspace; 
	u_int32_t	priv; 
	u_int32_t	flags; 
	u_int32_t	ycbcr_enc; 
	u_int32_t	quantization; 
	u_int32_t	xfer_func; 
}; 
 
struct v4l2_window { 
	struct v4l2_rect	w; 
	u_int32_t		field; 
	u_int32_t		chromakey; 
	struct v4l2_clip	__user *clips; 
	u_int32_t		clipcount; 
	void			__user *bitmap; 
	u_int8_t		global_alpha; 
}; 
 
struct v4l2_vbi_format { 
	u_int32_t		sampling_rate; 
	u_int32_t		offset; 
	u_int32_t		samples_per_line; 
	u_int32_t		sample_format; 
	int32_t			start[2]; 
	u_int32_t		count[2]; 
	u_int32_t		flags; 
	u_int32_t		reserved[2]; 
}; 
 
struct v4l2_sliced_vbi_format { 
	u_int16_t	service_set; 
	u_int16_t	service_lines[2][24]; 
	u_int32_t	io_size; 
	u_int32_t	reserved[2]; 
}; 
 
struct v4l2_fract { 
	u_int32_t	numerator; 
	u_int32_t	denominator; 
};</pre>
<div class="spacer">
</div>
Command independent typedefs are:<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
typedef u_int64_t	v4l2_std_id;</pre>
</div>
<div class="section">
<h1 id="x52454144">READ</h1> Video data can be accessed via the <a class="link-man" href="../html2/read.html">read(2)</a> system call. The main iteration for userland applications occurs as follow:<div class="spacer">
</div>
<ol style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-enum">
<li class="list-enum" style="margin-top: 0.00em;">
Open /dev/video* via the <a class="link-man" href="../html2/open.html">open(2)</a> system call.</li>
<li class="list-enum" style="margin-top: 0.00em;">
Read video data from the device via the <a class="link-man" href="../html2/read.html">read(2)</a> system call. The video stream will be started automatically with the first read, which means there is no need to issue a <span class="define">VIDIOC_STREAMON</span> command. The read will always return a consistent video frame, if no error occurs.</li>
<li class="list-enum" style="margin-top: 0.00em;">
Process video data and start over again with step 2.</li>
<li class="list-enum" style="margin-top: 0.00em;">
When finished stop the video stream via the <a class="link-man" href="../html2/close.html">close(2)</a> system call.</li>
</ol>
<div class="spacer">
</div>
The <a class="link-man" href="../html2/select.html">select(2)</a> and <a class="link-man" href="../html2/poll.html">poll(2)</a> system calls are supported for this access type. They will signal when a frame is ready for reading without blocking.</div>
<div class="section">
<h1 id="x4d4d4150">MMAP</h1> Video data can be accessed via the <a class="link-man" href="../html2/mmap.html">mmap(2)</a> system call. The main iteration for userland applications occurs as follow:<div class="spacer">
</div>
<ol style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-enum">
<li class="list-enum" style="margin-top: 0.00em;">
Open /dev/video* via the <a class="link-man" href="../html2/open.html">open(2)</a> system call.</li>
<li class="list-enum" style="margin-top: 0.00em;">
Request desired number of buffers via the <span class="define">VIDIOC_REQBUFS</span> ioctl command. The maximum number of available buffers is normally limited by the hardware driver.</li>
<li class="list-enum" style="margin-top: 0.00em;">
Get the length and offset for the previously requested buffers via the <span class="define">VIDIOC_QUERYBUF</span> ioctl command and map the buffers via the <a class="link-man" href="../html2/mmap.html">mmap(2)</a> system call.</li>
<li class="list-enum" style="margin-top: 0.00em;">
Initially queue the buffers via the <span class="define">VIDIOC_QBUF</span> ioctl command.</li>
<li class="list-enum" style="margin-top: 0.00em;">
Start the video stream via the <span class="define">VIDIOC_STREAMON</span> ioctl command.</li>
<li class="list-enum" style="margin-top: 0.00em;">
Dequeue one buffer via the <span class="define">VIDIOC_DQBUF</span> ioctl command. If the queue is empty the ioctl will block until a buffer gets queued or an error occurs (e.g. a timeout).</li>
<li class="list-enum" style="margin-top: 0.00em;">
Process video data.</li>
<li class="list-enum" style="margin-top: 0.00em;">
Requeue the buffer via the <span class="define">VIDIOC_QBUF</span> ioctl command and start over again with step 6.</li>
<li class="list-enum" style="margin-top: 0.00em;">
When finished stop the video stream via the <span class="define">VIDIOC_STREAMOFF</span> ioctl command.</li>
</ol>
<div class="spacer">
</div>
The <a class="link-man" href="../html2/select.html">select(2)</a> and <a class="link-man" href="../html2/poll.html">poll(2)</a> system calls are supported for this access type. They will signal when at least one frame is ready for dequeuing, allowing to call the <span class="define">VIDIOC_DQBUF</span> ioctl command without blocking.</div>
<div class="section">
<h1 id="x46494c4553">FILES</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="file">/dev/video</i></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
</dd>
</dl>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html1/video.html">video(1)</a>, <a class="link-man" href="../html2/ioctl.html">ioctl(2)</a>, <a class="link-man" href="../html4/uvideo.html">uvideo(4)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The <b class="name">video</b> driver first appeared in <span class="unix">OpenBSD&#160;4.4</span>.</div>
</div>
</body>
</html>

