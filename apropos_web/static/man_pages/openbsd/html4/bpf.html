<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
BPF(4)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">bpf</b> &#8212; <span class="desc">Berkeley Packet Filter</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="config">pseudo-device bpfilter</b></div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The Berkeley Packet Filter provides a raw interface to data link layers in a protocol-independent fashion. All packets on the network, even those destined for other hosts, are accessible through this mechanism.<div class="spacer">
</div>
The packet filter appears as a character special device, <i class="file">/dev/bpf</i>. After opening the device, the file descriptor must be bound to a specific network interface with the <span class="define">BIOCSETIF</span> <a class="link-man" href="../html2/ioctl.html">ioctl(2)</a>. A given interface can be shared between multiple listeners, and the filter underlying each descriptor will see an identical packet stream.<div class="spacer">
</div>
Associated with each open instance of a <b class="name">bpf</b> file is a user-settable packet filter. Whenever a packet is received by an interface, all file descriptors listening on that interface apply their filter. Each descriptor that accepts the packet receives its own copy.<div class="spacer">
</div>
Reads from these files return the next group of packets that have matched the filter. To improve performance, the buffer passed to read must be the same size as the buffers used internally by <b class="name">bpf</b>. This size is returned by the <span class="define">BIOCGBLEN</span> <a class="link-man" href="../html2/ioctl.html">ioctl(2)</a> and can be set with <span class="define">BIOCSBLEN</span>. Note that an individual packet larger than this size is necessarily truncated.<div class="spacer">
</div>
A packet can be sent out on the network by writing to a <b class="name">bpf</b> file descriptor. Each descriptor can also have a user-settable filter for controlling the writes. Only packets matching the filter are sent out of the interface. The writes are unbuffered, meaning only one packet can be processed per write.<div class="spacer">
</div>
Once a descriptor is configured, further changes to the configuration can be prevented using the <span class="define">BIOCLOCK</span> <a class="link-man" href="../html2/ioctl.html">ioctl(2)</a>.</div>
<div class="section">
<h1 id="x494f43544c20494e54455246414345">IOCTL INTERFACE</h1> The <a class="link-man" href="../html2/ioctl.html">ioctl(2)</a> command codes below are defined in <b class="includes">&lt;<a class="link-includes">net/bpf.h</a>&gt;</b>. All commands require these includes:<div class="spacer">
</div>
<br/>
<b class="includes">#include &lt;<a class="link-includes">sys/types.h</a>&gt;</b><br/>
<b class="includes">#include &lt;<a class="link-includes">sys/time.h</a>&gt;</b><br/>
<b class="includes">#include &lt;<a class="link-includes">sys/ioctl.h</a>&gt;</b><br/>
<b class="includes">#include &lt;<a class="link-includes">net/bpf.h</a>&gt;</b><div class="spacer">
</div>
Additionally, <span class="define">BIOCGETIF</span> and <span class="define">BIOCSETIF</span> require <b class="includes">&lt;<a class="link-includes">sys/socket.h</a>&gt;</b> and <b class="includes">&lt;<a class="link-includes">net/if.h</a>&gt;</b>.<div class="spacer">
</div>
The (third) argument to the <a class="link-man" href="../html2/ioctl.html">ioctl(2)</a> call should be a pointer to the type indicated.<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BIOCGBLEN</span> <i class="farg">u_int *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Returns the required buffer length for reads on <b class="name">bpf</b> files.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BIOCSBLEN</span> <i class="farg">u_int *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Sets the buffer length for reads on <b class="name">bpf</b> files. The buffer must be set before the file is attached to an interface with <span class="define">BIOCSETIF</span>. If the requested buffer size cannot be accommodated, the closest allowable size will be set and returned in the argument. A read call will result in <span class="errno">EINVAL</span> if it is passed a buffer that is not this size.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BIOCGDLT</span> <i class="farg">u_int *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Returns the type of the data link layer underlying the attached interface. <span class="errno">EINVAL</span> is returned if no interface has been specified. The device types, prefixed with &#8220;DLT_&#8221;, are defined in <b class="includes">&lt;<a class="link-includes">net/bpf.h</a>&gt;</b>.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BIOCGDLTLIST</span> <i class="farg">struct bpf_dltlist *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Returns an array of the available types of the data link layer underlying the attached interface:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
struct bpf_dltlist { 
	u_int bfl_len; 
	u_int *bfl_list; 
};</pre>
<div class="spacer">
</div>
The available types are returned in the array pointed to by the <b class="var">bfl_list</b> field while their length in <span class="type">u_int</span> is supplied to the <b class="var">bfl_len</b> field. <span class="errno">ENOMEM</span> is returned if there is not enough buffer space and <span class="errno">EFAULT</span> is returned if a bad address is encountered. The <b class="var">bfl_len</b> field is modified on return to indicate the actual length in <span class="type">u_int</span> of the array returned. If <b class="var">bfl_list</b> is <span class="define">NULL</span>, the <b class="var">bfl_len</b> field is set to indicate the required length of the array in <span class="type">u_int</span>.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BIOCSDLT</span> <i class="farg">u_int *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Changes the type of the data link layer underlying the attached interface. <span class="errno">EINVAL</span> is returned if no interface has been specified or the specified type is not available for the interface.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BIOCPROMISC</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Forces the interface into promiscuous mode. All packets, not just those destined for the local host, are processed. Since more than one file can be listening on a given interface, a listener that opened its interface non-promiscuously may receive packets promiscuously. This problem can be remedied with an appropriate filter.<div class="spacer">
</div>
The interface remains in promiscuous mode until all files listening promiscuously are closed.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BIOCFLUSH</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Flushes the buffer of incoming packets and resets the statistics that are returned by <span class="define">BIOCGSTATS</span>.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BIOCLOCK</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This ioctl is designed to prevent the security issues associated with an open <b class="name">bpf</b> descriptor in unprivileged programs. Even with dropped privileges, an open <b class="name">bpf</b> descriptor can be abused by a rogue program to listen on any interface on the system, send packets on these interfaces if the descriptor was opened read-write and send signals to arbitrary processes using the signaling mechanism of <b class="name">bpf</b>. By allowing only &#8220;known safe&#8221; ioctls, the <span class="define">BIOCLOCK</span> ioctl prevents this abuse. The allowable ioctls are <span class="define">BIOCFLUSH</span>, <span class="define">BIOCGBLEN</span>, <span class="define">BIOCGDIRFILT</span>, <span class="define">BIOCGDLT</span>, <span class="define">BIOCGDIRFILT</span>, <span class="define">BIOCGDLTLIST</span>, <span class="define">BIOCGETIF</span>, <span class="define">BIOCGHDRCMPLT</span>, <span class="define">BIOCGRSIG</span>, <span class="define">BIOCGRTIMEOUT</span>, <span class="define">BIOCGSTATS</span>, <span class="define">BIOCIMMEDIATE</span>, <span class="define">BIOCLOCK</span>, <span class="define">BIOCSRTIMEOUT</span>, <span class="define">BIOCVERSION</span>, <span class="define">TIOCGPGRP</span>, and <span class="define">FIONREAD</span>. Use of any other ioctl is denied with error <span class="errno">EPERM</span>. Once a descriptor is locked, it is not possible to unlock it. A process with root privileges is not affected by the lock.<div class="spacer">
</div>
A privileged program can open a <b class="name">bpf</b> device, drop privileges, set the interface, filters and modes on the descriptor, and lock it. Once the descriptor is locked, the system is safe from further abuse through the descriptor. Locking a descriptor does not prevent writes. If the application does not need to send packets through <b class="name">bpf</b>, it can open the device read-only to prevent writing. If sending packets is necessary, a write-filter can be set before locking the descriptor to prevent arbitrary packets from being sent out.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BIOCGETIF</span> <i class="farg">struct ifreq *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Returns the name of the hardware interface that the file is listening on. The name is returned in the <i class="farg">ifr_name</i> field of the <code class="lit">struct ifreq</code>. All other fields are undefined.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BIOCSETIF</span> <i class="farg">struct ifreq *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Sets the hardware interface associated with the file. This command must be performed before any packets can be read. The device is indicated by name using the <i class="farg">ifr_name</i> field of the <code class="lit">struct ifreq</code>. Additionally, performs the actions of <span class="define">BIOCFLUSH</span>.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BIOCSRTIMEOUT</span> <i class="farg">struct timeval *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BIOCGRTIMEOUT</span> <i class="farg">struct timeval *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Sets or gets the read timeout parameter. The <i class="arg">timeval</i> specifies the length of time to wait before timing out on a read request. This parameter is initialized to zero by <a class="link-man" href="../html2/open.html">open(2)</a>, indicating no timeout.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BIOCGSTATS</span> <i class="farg">struct bpf_stat *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Returns the following structure of packet statistics:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
struct bpf_stat { 
	u_int bs_recv; 
	u_int bs_drop; 
};</pre>
<div class="spacer">
</div>
The fields are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">bs_recv</i></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Number of packets received by the descriptor since opened or reset (including any buffered since the last read call).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">bs_drop</i></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Number of packets which were accepted by the filter but dropped by the kernel because of buffer overflows (i.e., the application's reads aren't keeping up with the packet traffic).</dd>
</dl>
<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BIOCIMMEDIATE</span> <i class="farg">u_int *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Enables or disables &#8220;immediate mode&#8221;, based on the truth value of the argument. When immediate mode is enabled, reads return immediately upon packet reception. Otherwise, a read will block until either the kernel buffer becomes full or a timeout occurs. This is useful for programs like <a class="link-man" href="../html8/rarpd.html">rarpd(8)</a>, which must respond to messages in real time. The default for a new file is off.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BIOCSETF</span> <i class="farg">struct bpf_program *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Sets the filter program used by the kernel to discard uninteresting packets. An array of instructions and its length are passed in using the following structure:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
struct bpf_program { 
	u_int bf_len; 
	struct bpf_insn *bf_insns; 
};</pre>
<div class="spacer">
</div>
The filter program is pointed to by the <i class="farg">bf_insns</i> field, while its length in units of <code class="lit">struct bpf_insn</code> is given by the <i class="farg">bf_len</i> field. Also, the actions of <span class="define">BIOCFLUSH</span> are performed.<div class="spacer">
</div>
See section <i class="link-sec"><a class="link-sec" href="#x46494c544552204d414348494e45">FILTER MACHINE</a></i> for an explanation of the filter language.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BIOCSETWF</span> <i class="farg">struct bpf_program *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Sets the filter program used by the kernel to filter the packets written to the descriptor before the packets are sent out on the network. See <span class="define">BIOCSETF</span> for a description of the filter program. This ioctl also acts as <span class="define">BIOCFLUSH</span>.<div class="spacer">
</div>
Note that the filter operates on the packet data written to the descriptor. If the &#8220;header complete&#8221; flag is not set, the kernel sets the link-layer source address of the packet after filtering.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BIOCVERSION</span> <i class="farg">struct bpf_version *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Returns the major and minor version numbers of the filter language currently recognized by the kernel. Before installing a filter, applications must check that the current version is compatible with the running kernel. Version numbers are compatible if the major numbers match and the application minor is less than or equal to the kernel minor. The kernel version number is returned in the following structure:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
struct bpf_version { 
	u_short bv_major; 
	u_short bv_minor; 
};</pre>
<div class="spacer">
</div>
The current version numbers are given by <span class="define">BPF_MAJOR_VERSION</span> and <span class="define">BPF_MINOR_VERSION</span> from <b class="includes">&lt;<a class="link-includes">net/bpf.h</a>&gt;</b>. An incompatible filter may result in undefined behavior (most likely, an error returned by <a class="link-man" href="../html2/ioctl.html">ioctl(2)</a> or haphazard packet matching).<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BIOCSRSIG</span> <i class="farg">u_int *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BIOCGRSIG</span> <i class="farg">u_int *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Sets or gets the receive signal. This signal will be sent to the process or process group specified by <span class="define">FIOSETOWN</span>. It defaults to <span class="define">SIGIO</span>.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BIOCSHDRCMPLT</span> <i class="farg">u_int *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BIOCGHDRCMPLT</span> <i class="farg">u_int *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Sets or gets the status of the &#8220;header complete&#8221; flag. Set to zero if the link level source address should be filled in automatically by the interface output routine. Set to one if the link level source address will be written, as provided, to the wire. This flag is initialized to zero by default.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BIOCSFILDROP</span> <i class="farg">u_int *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BIOCGFILDROP</span> <i class="farg">u_int *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Sets or gets the status of the &#8220;filter drop&#8221; flag. If non-zero, packets matching any filters will be reported to the associated interface so that they can be dropped.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BIOCSDIRFILT</span> <i class="farg">u_int *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BIOCGDIRFILT</span> <i class="farg">u_int *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Sets or gets the status of the &#8220;direction filter&#8221; flag. If non-zero, packets matching the specified direction (either <span class="define">BPF_DIRECTION_IN</span> or <span class="define">BPF_DIRECTION_OUT</span>) will be ignored.</dd>
</dl>
<div class="subsection">
<h2 id="x5374616e6461726420696f63746c73">Standard ioctls</h2> <b class="name">bpf</b> now supports several standard ioctls which allow the user to do asynchronous and/or non-blocking I/O to an open <b class="name">bpf</b> file descriptor.<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">FIONREAD</span> <i class="farg">int *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Returns the number of bytes that are immediately available for reading.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">FIONBIO</span> <i class="farg">int *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Sets or clears non-blocking I/O. If the argument is non-zero, enable non-blocking I/O. If the argument is zero, disable non-blocking I/O. If non-blocking I/O is enabled, the return value of a read while no data is available will be 0. The non-blocking read behavior is different from performing non-blocking reads on other file descriptors, which will return -1 and set <b class="var">errno</b> to <span class="errno">EAGAIN</span> if no data is available. Note: setting this overrides the timeout set by <span class="define">BIOCSRTIMEOUT</span>.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">FIOASYNC</span> <i class="farg">int *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Enables or disables asynchronous I/O. When enabled (argument is non-zero), the process or process group specified by <span class="define">FIOSETOWN</span> will start receiving <span class="define">SIGIO</span> signals when packets arrive. Note that you must perform an <span class="define">FIOSETOWN</span> command in order for this to take effect, as the system will not do it by default. The signal may be changed via <span class="define">BIOCSRSIG</span>.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">FIOSETOWN</span> <i class="farg">int *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">FIOGETOWN</span> <i class="farg">int *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Sets or gets the process or process group (if negative) that should receive <span class="define">SIGIO</span> when packets are available. The signal may be changed using <span class="define">BIOCSRSIG</span> (see above).</dd>
</dl>
</div>
<div class="subsection">
<h2 id="x42504620686561646572">BPF header</h2> The following structure is prepended to each packet returned by <a class="link-man" href="../html2/read.html">read(2)</a>:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
struct bpf_hdr { 
	struct bpf_timeval bh_tstamp; 
	u_int32_t	bh_caplen; 
	u_int32_t	bh_datalen; 
	u_int16_t	bh_hdrlen; 
};</pre>
<div class="spacer">
</div>
The fields, stored in host order, are as follows:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">bh_tstamp</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Time at which the packet was processed by the packet filter.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">bh_caplen</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Length of the captured portion of the packet. This is the minimum of the truncation amount specified by the filter and the length of the packet.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">bh_datalen</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Length of the packet off the wire. This value is independent of the truncation amount specified by the filter.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">bh_hdrlen</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Length of the BPF header, which may not be equal to <code class="lit">sizeof(struct bpf_hdr)</code>.</dd>
</dl>
<div class="spacer">
</div>
The <i class="farg">bh_hdrlen</i> field exists to account for padding between the header and the link level protocol. The purpose here is to guarantee proper alignment of the packet data structures, which is required on alignment-sensitive architectures and improves performance on many other architectures. The packet filter ensures that the <i class="farg">bpf_hdr</i> and the network layer header will be word aligned. Suitable precautions must be taken when accessing the link layer protocol fields on alignment restricted machines. (This isn't a problem on an Ethernet, since the type field is a <code class="lit">short</code> falling on an even offset, and the addresses are probably accessed in a bytewise fashion).<div class="spacer">
</div>
Additionally, individual packets are padded so that each starts on a word boundary. This requires that an application has some knowledge of how to get from packet to packet. The macro <span class="define">BPF_WORDALIGN</span> is defined in <b class="includes">&lt;<a class="link-includes">net/bpf.h</a>&gt;</b> to facilitate this process. It rounds up its argument to the nearest word aligned value (where a word is <span class="define">BPF_ALIGNMENT</span> bytes wide). For example, if <b class="var">p</b> points to the start of a packet, this expression will advance it to the next packet:<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">p = (char *)p + BPF_WORDALIGN(p-&gt;bh_hdrlen + p-&gt;bh_caplen);</code></div>
</blockquote>
<div class="spacer">
</div>
For the alignment mechanisms to work properly, the buffer passed to <a class="link-man" href="../html2/read.html">read(2)</a> must itself be word aligned. <a class="link-man" href="../html3/malloc.html">malloc(3)</a> will always return an aligned buffer.</div>
<div class="subsection">
<h2 id="x46696c746572206d616368696e65">Filter machine</h2> A filter program is an array of instructions with all branches forwardly directed, terminated by a &#8220;return&#8221; instruction. Each instruction performs some action on the pseudo-machine state, which consists of an accumulator, index register, scratch memory store, and implicit program counter.<div class="spacer">
</div>
The following structure defines the instruction format:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
struct bpf_insn { 
	u_int16_t	code; 
	u_char		jt; 
	u_char		jf; 
	u_int32_t	k; 
};</pre>
<div class="spacer">
</div>
The <i class="farg">k</i> field is used in different ways by different instructions, and the <i class="farg">jt</i> and <i class="farg">jf</i> fields are used as offsets by the branch instructions. The opcodes are encoded in a semi-hierarchical fashion. There are eight classes of instructions: <span class="define">BPF_LD</span>, <span class="define">BPF_LDX</span>, <span class="define">BPF_ST</span>, <span class="define">BPF_STX</span>, <span class="define">BPF_ALU</span>, <span class="define">BPF_JMP</span>, <span class="define">BPF_RET</span>, and <span class="define">BPF_MISC</span>. Various other mode and operator bits are logically OR'd into the class to give the actual instructions. The classes and modes are defined in <b class="includes">&lt;<a class="link-includes">net/bpf.h</a>&gt;</b>. Below are the semantics for each defined <b class="name">bpf</b> instruction. We use the convention that A is the accumulator, X is the index register, P[] packet data, and M[] scratch memory store. P[i:n] gives the data at byte offset &#8220;i&#8221; in the packet, interpreted as a word (n=4), unsigned halfword (n=2), or unsigned byte (n=1). M[i] gives the i'th word in the scratch memory store, which is only addressed in word units. The memory store is indexed from 0 to <span class="define">BPF_MEMWORDS</span>-1. <i class="farg">k</i>, <i class="farg">jt</i>, and <i class="farg">jf</i> are the corresponding fields in the instruction definition. &#8220;len&#8221; refers to the length of the packet.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">BPF_LD</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
These instructions copy a value into the accumulator. The type of the source operand is specified by an &#8220;addressing mode&#8221; and can be a constant (<span class="define">BPF_IMM</span>), packet data at a fixed offset (<span class="define">BPF_ABS</span>), packet data at a variable offset (<span class="define">BPF_IND</span>), the packet length (<span class="define">BPF_LEN</span>), or a word in the scratch memory store (<span class="define">BPF_MEM</span>). For <span class="define">BPF_IND</span> and <span class="define">BPF_ABS</span>, the data size must be specified as a word (<span class="define">BPF_W</span>), halfword (<span class="define">BPF_H</span>), or byte (<span class="define">BPF_B</span>). The semantics of all recognized <span class="define">BPF_LD</span> instructions follow.<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_LD</span><code class="none">+</code><span class="define">BPF_W</span><code class="none">+</code><span class="define">BPF_ABS</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
 A &lt;- P[k:4]</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_LD</span><code class="none">+</code><span class="define">BPF_H</span><code class="none">+</code><span class="define">BPF_ABS</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
 A &lt;- P[k:2]</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_LD</span><code class="none">+</code><span class="define">BPF_B</span><code class="none">+</code><span class="define">BPF_ABS</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
 A &lt;- P[k:1]</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_LD</span><code class="none">+</code><span class="define">BPF_W</span><code class="none">+</code><span class="define">BPF_IND</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
 A &lt;- P[X+k:4]</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_LD</span><code class="none">+</code><span class="define">BPF_H</span><code class="none">+</code><span class="define">BPF_IND</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
 A &lt;- P[X+k:2]</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_LD</span><code class="none">+</code><span class="define">BPF_B</span><code class="none">+</code><span class="define">BPF_IND</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
 A &lt;- P[X+k:1]</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_LD</span><code class="none">+</code><span class="define">BPF_W</span><code class="none">+</code><span class="define">BPF_LEN</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
 A &lt;- len</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_LD</span><code class="none">+</code><span class="define">BPF_IMM</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
 A &lt;- k</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_LD</span><code class="none">+</code><span class="define">BPF_MEM</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
 A &lt;- M[k]</dd>
</dl>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">BPF_LDX</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
These instructions load a value into the index register. Note that the addressing modes are more restricted than those of the accumulator loads, but they include <span class="define">BPF_MSH</span>, a hack for efficiently loading the IP header length.<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_LDX</span><code class="none">+</code><span class="define">BPF_W</span><code class="none">+</code><span class="define">BPF_IMM</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
 X &lt;- k</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_LDX</span><code class="none">+</code><span class="define">BPF_W</span><code class="none">+</code><span class="define">BPF_MEM</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
 X &lt;- M[k]</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_LDX</span><code class="none">+</code><span class="define">BPF_W</span><code class="none">+</code><span class="define">BPF_LEN</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
 X &lt;- len</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_LDX</span><code class="none">+</code><span class="define">BPF_B</span><code class="none">+</code><span class="define">BPF_MSH</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
 X &lt;- 4*(P[k:1]&amp;0xf)</dd>
</dl>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">BPF_ST</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This instruction stores the accumulator into the scratch memory. We do not need an addressing mode since there is only one possibility for the destination.<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_ST</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
M[k] &lt;- A</dd>
</dl>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">BPF_STX</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This instruction stores the index register in the scratch memory store.<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_STX</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
M[k] &lt;- X</dd>
</dl>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">BPF_ALU</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The ALU instructions perform operations between the accumulator and index register or constant, and store the result back in the accumulator. For binary operations, a source mode is required (<span class="define">BPF_K</span> or <span class="define">BPF_X</span>).<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_ALU</span><code class="none">+BPF_ADD</code><code class="none">+</code><span class="define">BPF_K</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
 A &lt;- A + k</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_ALU</span><code class="none">+BPF_SUB</code><code class="none">+</code><span class="define">BPF_K</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
 A &lt;- A - k</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_ALU</span><code class="none">+BPF_MUL</code><code class="none">+</code><span class="define">BPF_K</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
 A &lt;- A * k</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_ALU</span><code class="none">+BPF_DIV</code><code class="none">+</code><span class="define">BPF_K</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
 A &lt;- A / k</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_ALU</span><code class="none">+BPF_AND</code><code class="none">+</code><span class="define">BPF_K</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
 A &lt;- A &amp; k</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_ALU</span><code class="none">+BPF_OR</code><code class="none">+</code><span class="define">BPF_K</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
 A &lt;- A | k</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_ALU</span><code class="none">+BPF_LSH</code><code class="none">+</code><span class="define">BPF_K</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
 A &lt;- A &lt;&lt; k</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_ALU</span><code class="none">+BPF_RSH</code><code class="none">+</code><span class="define">BPF_K</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
 A &lt;- A &gt;&gt; k</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_ALU</span><code class="none">+BPF_ADD</code><code class="none">+</code><span class="define">BPF_X</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
 A &lt;- A + X</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_ALU</span><code class="none">+BPF_SUB</code><code class="none">+</code><span class="define">BPF_X</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
 A &lt;- A - X</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_ALU</span><code class="none">+BPF_MUL</code><code class="none">+</code><span class="define">BPF_X</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
 A &lt;- A * X</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_ALU</span><code class="none">+BPF_DIV</code><code class="none">+</code><span class="define">BPF_X</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
 A &lt;- A / X</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_ALU</span><code class="none">+BPF_AND</code><code class="none">+</code><span class="define">BPF_X</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
 A &lt;- A &amp; X</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_ALU</span><code class="none">+BPF_OR</code><code class="none">+</code><span class="define">BPF_X</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
 A &lt;- A | X</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_ALU</span><code class="none">+BPF_LSH</code><code class="none">+</code><span class="define">BPF_X</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
 A &lt;- A &lt;&lt; X</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_ALU</span><code class="none">+BPF_RSH</code><code class="none">+</code><span class="define">BPF_X</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
 A &lt;- A &gt;&gt; X</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_ALU</span><code class="none">+BPF_NEG</code></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
 A &lt;- -A</dd>
</dl>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">BPF_JMP</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The jump instructions alter flow of control. Conditional jumps compare the accumulator against a constant (<span class="define">BPF_K</span>) or the index register (<span class="define">BPF_X</span>). If the result is true (or non-zero), the true branch is taken, otherwise the false branch is taken. Jump offsets are encoded in 8 bits so the longest jump is 256 instructions. However, the jump always (<span class="define">BPF_JA</span>) opcode uses the 32-bit <i class="farg">k</i> field as the offset, allowing arbitrarily distant destinations. All conditionals use unsigned comparison conventions.<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_JMP</span><code class="none">+BPF_JA</code></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
pc += k</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_JMP</span><code class="none">+BPF_JGT</code><code class="none">+</code><span class="define">BPF_K</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
 pc += (A &gt; k) ? jt : jf</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_JMP</span><code class="none">+BPF_JGE</code><code class="none">+</code><span class="define">BPF_K</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
 pc += (A &gt;= k) ? jt : jf</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_JMP</span><code class="none">+BPF_JEQ</code><code class="none">+</code><span class="define">BPF_K</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
 pc += (A == k) ? jt : jf</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_JMP</span><code class="none">+BPF_JSET</code><code class="none">+</code><span class="define">BPF_K</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
 pc += (A &amp; k) ? jt : jf</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_JMP</span><code class="none">+BPF_JGT</code><code class="none">+</code><span class="define">BPF_X</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
 pc += (A &gt; X) ? jt : jf</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_JMP</span><code class="none">+BPF_JGE</code><code class="none">+</code><span class="define">BPF_X</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
 pc += (A &gt;= X) ? jt : jf</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_JMP</span><code class="none">+BPF_JEQ</code><code class="none">+</code><span class="define">BPF_X</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
 pc += (A == X) ? jt : jf</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_JMP</span><code class="none">+BPF_JSET</code><code class="none">+</code><span class="define">BPF_X</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
 pc += (A &amp; X) ? jt : jf</dd>
</dl>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">BPF_RET</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The return instructions terminate the filter program and specify the amount of packet to accept (i.e., they return the truncation amount) or, for the write filter, the maximum acceptable size for the packet (i.e., the packet is dropped if it is larger than the returned amount). A return value of zero indicates that the packet should be ignored/dropped. The return value is either a constant (<span class="define">BPF_K</span>) or the accumulator (<span class="define">BPF_A</span>).<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_RET</span> <code class="none">+</code> <span class="define">BPF_A</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
Accept A bytes.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_RET</span> <code class="none">+</code> <span class="define">BPF_K</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
Accept k bytes.</dd>
</dl>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">BPF_MISC</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The miscellaneous category was created for anything that doesn't fit into the above classes, and for any new instructions that might need to be added. Currently, these are the register transfer instructions that copy the index register to the accumulator or vice versa.<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_MISC</span><code class="none">+</code><span class="define">BPF_TAX</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
 X &lt;- A</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BPF_MISC</span><code class="none">+</code><span class="define">BPF_TXA</span></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
 A &lt;- X</dd>
</dl>
</dd>
</dl>
<div class="spacer">
</div>
The <b class="name">bpf</b> interface provides the following macros to facilitate array initializers:<div class="spacer">
</div>
<div style="margin-left: 5.00ex;" class="display">
<span class="define">BPF_STMT</span> (<i class="arg">opcode</i>, <i class="arg">operand</i>)<div class="spacer">
</div>
<span class="define">BPF_JUMP</span> (<i class="arg">opcode</i>, <i class="arg">operand</i>, <i class="arg">true_offset</i>, <i class="arg">false_offset</i>)</div>
</div>
</div>
<div class="section">
<h1 id="x46494c4553">FILES</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="file">/dev/bpf</i></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
<b class="name">bpf</b> device</dd>
</dl>
</div>
<div class="section">
<h1 id="x4558414d504c4553">EXAMPLES</h1> The following filter is taken from the Reverse ARP daemon. It accepts only Reverse ARP requests.<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
struct bpf_insn insns[] = { 
	BPF_STMT(BPF_LD+BPF_H+BPF_ABS, 12), 
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, ETHERTYPE_REVARP, 0, 3), 
	BPF_STMT(BPF_LD+BPF_H+BPF_ABS, 20), 
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, REVARP_REQUEST, 0, 1), 
	BPF_STMT(BPF_RET+BPF_K, sizeof(struct ether_arp) + 
	    sizeof(struct ether_header)), 
	BPF_STMT(BPF_RET+BPF_K, 0), 
};</pre>
<div class="spacer">
</div>
This filter accepts only IP packets between host 128.3.112.15 and 128.3.112.35.<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
struct bpf_insn insns[] = { 
	BPF_STMT(BPF_LD+BPF_H+BPF_ABS, 12), 
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, ETHERTYPE_IP, 0, 8), 
	BPF_STMT(BPF_LD+BPF_W+BPF_ABS, 26), 
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x8003700f, 0, 2), 
	BPF_STMT(BPF_LD+BPF_W+BPF_ABS, 30), 
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x80037023, 3, 4), 
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x80037023, 0, 3), 
	BPF_STMT(BPF_LD+BPF_W+BPF_ABS, 30), 
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x8003700f, 0, 1), 
	BPF_STMT(BPF_RET+BPF_K, (u_int)-1), 
	BPF_STMT(BPF_RET+BPF_K, 0), 
};</pre>
<div class="spacer">
</div>
Finally, this filter returns only TCP finger packets. We must parse the IP header to reach the TCP header. The <span class="define">BPF_JSET</span> instruction checks that the IP fragment offset is 0 so we are sure that we have a TCP header.<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
struct bpf_insn insns[] = { 
	BPF_STMT(BPF_LD+BPF_H+BPF_ABS, 12), 
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, ETHERTYPE_IP, 0, 10), 
	BPF_STMT(BPF_LD+BPF_B+BPF_ABS, 23), 
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, IPPROTO_TCP, 0, 8), 
	BPF_STMT(BPF_LD+BPF_H+BPF_ABS, 20), 
	BPF_JUMP(BPF_JMP+BPF_JSET+BPF_K, 0x1fff, 6, 0), 
	BPF_STMT(BPF_LDX+BPF_B+BPF_MSH, 14), 
	BPF_STMT(BPF_LD+BPF_H+BPF_IND, 14), 
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 79, 2, 0), 
	BPF_STMT(BPF_LD+BPF_H+BPF_IND, 16), 
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 79, 0, 1), 
	BPF_STMT(BPF_RET+BPF_K, (u_int)-1), 
	BPF_STMT(BPF_RET+BPF_K, 0), 
};</pre>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html2/ioctl.html">ioctl(2)</a>, <a class="link-man" href="../html2/read.html">read(2)</a>, <a class="link-man" href="../html2/select.html">select(2)</a>, <a class="link-man" href="../html3/signal.html">signal(3)</a>, <a class="link-man" href="../html8/MAKEDEV.html">MAKEDEV(8)</a>, <a class="link-man" href="../html8/tcpdump.html">tcpdump(8)</a><div class="spacer">
</div>
<span class="ref"><span class="ref-auth">McCanne, S.</span> and <span class="ref-auth">Jacobson, V.</span>, <span class="ref-title">The BSD Packet Filter: A New Architecture for User-level Packet Capture</span>, <i class="ref-jrnl">1993 Winter USENIX Conference</i>, <span class="ref-date">January 1993</span>.</span></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The Enet packet filter was created in 1980 by Mike Accetta and Rick Rashid at Carnegie-Mellon University. Jeffrey Mogul, at Stanford, ported the code to <span class="unix">BSD</span> and continued its development from 1983 on. Since then, it has evolved into the Ultrix Packet Filter at DEC, a STREAMS NIT module under SunOS 4.1, and BPF.</div>
<div class="section">
<h1 id="x415554484f5253">AUTHORS</h1> <span class="author">Steve McCanne</span> of Lawrence Berkeley Laboratory implemented BPF in Summer 1990. Much of the design is due to <span class="author">Van Jacobson</span>.</div>
<div class="section">
<h1 id="x42554753">BUGS</h1> The read buffer must be of a fixed size (returned by the <span class="define">BIOCGBLEN</span> ioctl).<div class="spacer">
</div>
A file that does not request promiscuous mode may receive promiscuously received packets as a side effect of another file requesting this mode on the same hardware interface. This could be fixed in the kernel with additional processing overhead. However, we favor the model where all files must assume that the interface is promiscuous, and if so desired, must utilize a filter to reject foreign packets.</div>
</div>
</body>
</html>

