<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
ST(4)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">st</b> &#8212; <span class="desc">SCSI tape driver</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="config">st* at scsibus?</b><br/>
<b class="config">#st0 at scsibus0 target 4 lun 0</b> (fixed-configuration example)</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <b class="name">st</b> driver provides support for SCSI tape drives. The device can have both a <span class="emph">raw</span> interface and a <span class="emph">block</span> interface; however, only the raw interface is usually used (or recommended). The raw interface devices will have an &#8216;r&#8217; in their names e.g. <i class="file">/dev/rst0</i>.<div class="spacer">
</div>
SCSI devices have a relatively high level interface and talk to the system via a SCSI adapter and a SCSI adapter driver e.g. <a class="link-man" href="../html4/ahc.html">ahc(4)</a>. The SCSI adapter must be separately configured into the system before a SCSI tape can be configured.<div class="spacer">
</div>
As the SCSI adapter is probed during boot, the SCSI bus is scanned for devices. Any devices found which answer as <span class="emph">Sequential</span> type devices will be attached to the <b class="name">st</b> driver.</div>
<div class="section">
<h1 id="x4d4f554e542053455353494f4e53">MOUNT SESSIONS</h1> The <b class="name">st</b> driver is based around the concept of a <span class="emph">mount session</span>, which is defined as the period between the time that a tape is mounted and the time when it is unmounted. Any parameters set during a mount session remain in effect for the remainder of the session or until replaced. The tape can be unmounted, bringing the session to a close in several ways. These include:<ol style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-enum">
<li class="list-enum" style="margin-top: 1.00em;">
Closing an &#8220;unmount device&#8221;.</li>
<li class="list-enum" style="margin-top: 1.00em;">
Using the <span class="define">MTOFFL</span> <a class="link-man" href="../html2/ioctl.html">ioctl(2)</a> command, reachable through the <b class="flag">offline</b> command of <a class="link-man" href="../html1/mt.html">mt(1)</a>.</li>
</ol>
</div>
<div class="section">
<h1 id="x454a45435420616e6420524557494e44">EJECT and REWIND</h1> Bit 0 of the minor number specifies whether a rewind is attempted when the device is closed. When it is set, the device will not attempt a rewind on close and the device will have an &#8216;n&#8217; in its name. For example, <i class="file">/dev/rst0</i> will rewind on close but <i class="file">/dev/nrst0</i> will not.<div class="spacer">
</div>
Bit 1 of the minor number specifies whether an eject is attempted when the device is closed. When it is set, the device will attempt to eject its media on close and the device will have an &#8216;e&#8217; in its name. For example, <i class="file">/dev/erst0</i> will eject its media on close but <i class="file">/dev/rst0</i> will not.<div class="spacer">
</div>
If both bit 0 and bit 1 are set then an eject will be attempted without a rewind and the device will have both an &#8216;e&#8217; and an &#8216;n&#8217; in its name. For example, <i class="file">/dev/enrst0</i> will eject its media without first rewinding it on close.<div class="spacer">
</div>
There is no guarantee that the attempted eject or rewind will be supported by the actual hardware.</div>
<div class="section">
<h1 id="x424c4f434b494e47204d4f444553">BLOCKING MODES</h1> SCSI tapes may run in either <span class="emph">variable</span> or <span class="emph">fixed</span> block-size modes. Most QIC-type devices run in fixed block-size mode, whereas most nine-track tapes and many new cartridge formats allow variable block-size. The difference between the two is as follows:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-inset">
<dt class="list-inset" style="margin-top: 1.00em;">
Variable block-size:</dt>
<dd class="list-inset">
Each write made to the device results in a single logical record written to the tape. One can never read or write <span class="emph">part</span> of a record from tape (though you may request a larger block and read a smaller record); nor can one read multiple blocks. Data from a single write is therefore read by a single read. The block size used may be any value supported by the device, the SCSI adapter and the system (usually between 1 byte and 64 Kbytes, sometimes more).<div class="spacer">
</div>
When reading a variable record/block from the tape, the head is logically considered to be immediately after the last item read, and before the next item after that. If the next item is a file mark, but it was never read, then the next process to read will immediately hit the file mark and receive an end-of-file notification.</dd>
<dt class="list-inset" style="margin-top: 1.00em;">
Fixed block-size</dt>
<dd class="list-inset">
data written by the user is passed to the tape as a succession of fixed size blocks. It may be contiguous in memory, but it is considered to be a series of independent blocks. One may never write an amount of data that is not an exact multiple of the blocksize. One may read and write the same data as a different set of records. In other words, blocks that were written together may be read separately, and vice-versa.<div class="spacer">
</div>
If one requests more blocks than remain in the file, the drive will encounter the file mark. Because there is some data to return (unless there were no records before the file mark), the read will succeed, returning that data. The next read will return immediately with an <span class="define">EOF</span>. (As above, if the file mark is never read, it remains for the next process to read if in no-rewind mode.)</dd>
</dl>
</div>
<div class="section">
<h1 id="x46494c45204d41524b2048414e444c494e47">FILE MARK HANDLING</h1> The handling of file marks on write is automatic. If the user has written to the tape, and has not done a read since the last write, then a file mark will be written to the tape when the device is closed. If a rewind is requested after a write, then the driver assumes that the last file on the tape has been written, and ensures that there are two file marks written to the tape. The exception to this is that there seems to be a standard (which we follow, but don't understand why) that certain types of tape do not actually write two file marks to tape, but when read, report a &#8220;phantom&#8221; file mark when the last file is read. These devices include the QIC family of devices. (It might be that this set of devices is the same set as that of fixed. This has not yet been determined, and they are treated as separate behaviors by the driver at this time.)</div>
<div class="section">
<h1 id="x494f43544c53">IOCTLS</h1> The following <a class="link-man" href="../html2/ioctl.html">ioctl(2)</a> calls apply to SCSI tapes. Some also apply to other tapes. They are defined in the header file <b class="includes">&lt;<a class="link-includes">sys/mtio.h</a>&gt;</b>.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MTIOCGET</span> <i class="farg">struct mtget *</i></dt>
<dd class="list-tag" style="margin-left: 9.00ex;">
Retrieve the status and parameters of the tape.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MTIOCTOP struct mtop *</span></dt>
<dd class="list-tag" style="margin-left: 9.00ex;">
Perform a multiplexed operation. The argument structure is as follows:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
struct mtop { 
	short	mt_op; 
	int	mt_count; 
};</pre>
<div class="spacer">
</div>
The following operation values are defined for <b class="var">mt_op</b>:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MTWEOF</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Write <b class="var">mt_count</b> end of file marks at the present head position.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MTFSF</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Skip over <b class="var">mt_count</b> file marks. Leave the head on the EOM side of the last skipped file mark.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MTBSF</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Skip <span class="emph">backwards</span> over <b class="var">mt_count</b> file marks. Leave the head on the BOM (beginning of media) side of the last skipped file mark.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MTFSR</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Skip forwards over <b class="var">mt_count</b> records.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MTBSR</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Skip backwards over <b class="var">mt_count</b> records.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MTREW</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Rewind the device to the beginning of the media.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MTOFFL</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Rewind the media (and, if possible, eject). Even if the device cannot eject the media it will often no longer respond to normal requests.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MTNOP</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
No-op; set status only.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MTCACHE</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Enable controller buffering.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MTNOCACHE</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Disable controller buffering.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MTSETBSIZ</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Set the blocksize to use for the device/mode. If the device is capable of variable blocksize operation, and the blocksize is set to 0, then the drive will be driven in variable mode. This parameter is in effect for the present mount session only.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MTSETDNSTY</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Set the density value (see <a class="link-man" href="../html1/mt.html">mt(1)</a>) to use when running in the mode opened (minor bits 2 and 3). This parameter is in effect for the present mount session only.</dd>
</dl>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MTIOCIEOT</span></dt>
<dd class="list-tag" style="margin-left: 9.00ex;">
Set end-of-tape processing (not presently supported for <b class="name">st</b> devices).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MTIOCEEOT</span></dt>
<dd class="list-tag" style="margin-left: 9.00ex;">
Set end-of-tape processing (not presently supported for <b class="name">st</b> devices).</dd>
</dl>
</div>
<div class="section">
<h1 id="x46494c4553">FILES</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="file">/dev/[e][n][r]st[0-9]</i></dt>
<dd class="list-tag" style="margin-left: 21.00ex;">
General form.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="file">/dev/rst0</i></dt>
<dd class="list-tag" style="margin-left: 21.00ex;">
No eject, rewind on close.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="file">/dev/nrst0</i></dt>
<dd class="list-tag" style="margin-left: 21.00ex;">
No eject, no rewind on close.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="file">/dev/erst0</i></dt>
<dd class="list-tag" style="margin-left: 21.00ex;">
Eject, rewind on close.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="file">/dev/enrst0</i></dt>
<dd class="list-tag" style="margin-left: 21.00ex;">
Eject, no rewind on close.</dd>
</dl>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html1/chio.html">chio(1)</a>, <a class="link-man" href="../html1/mt.html">mt(1)</a>, <a class="link-man" href="../html4/intro.html">intro(4)</a>, <a class="link-man" href="../html4/mtio.html">mtio(4)</a>, <a class="link-man" href="../html4/scsi.html">scsi(4)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> This <b class="name">st</b> driver was originally written for Mach 2.5 by Julian Elischer, and was ported to <span class="unix">NetBSD</span> by Charles Hannum. This man page was edited for <span class="unix">NetBSD</span> by Jon Buller.</div>
</div>
</body>
</html>

