<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
NETINTRO(4)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">netintro</b> &#8212; <span class="desc">introduction to networking facilities</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/socket.h</a>&gt;</b><br/>
<b class="includes">#include &lt;<a class="link-includes">net/route.h</a>&gt;</b><br/>
<b class="includes">#include &lt;<a class="link-includes">net/if.h</a>&gt;</b></div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> This section is a general introduction to the networking facilities available in the system. Documentation in this part of section 4 is broken up into three areas: <span class="emph">protocol families</span> (domains), <span class="emph">protocols</span>, and <span class="emph">network interfaces</span>.<div class="spacer">
</div>
All network protocols are associated with a specific <span class="emph">protocol family</span>. A protocol family provides basic services to the protocol implementation to allow it to function within a specific network environment. These services may include packet fragmentation and reassembly, routing, addressing, and basic transport. A protocol family may support multiple methods of addressing, though the current protocol implementations do not. A protocol family is normally comprised of a number of protocols, one per <a class="link-man" href="../html2/socket.html">socket(2)</a> type. It is not required that a protocol family support all socket types. A protocol family may contain multiple protocols supporting the same socket abstraction.<div class="spacer">
</div>
A protocol supports one of the socket abstractions detailed in <a class="link-man" href="../html2/socket.html">socket(2)</a>. A specific protocol may be accessed either by creating a socket of the appropriate type and protocol family, or by requesting the protocol explicitly when creating a socket. Protocols normally accept only one type of address format, usually determined by the addressing structure inherent in the design of the protocol family/network architecture. Certain semantics of the basic socket abstractions are protocol specific. All protocols are expected to support the basic model for their particular socket type, but may, in addition, provide non-standard facilities or extensions to a mechanism. For example, a protocol supporting the <span class="define">SOCK_STREAM</span> abstraction may allow more than one byte of out-of-band data to be transmitted per out-of-band message.<div class="spacer">
</div>
A network interface is similar to a device interface. Network interfaces comprise the lowest layer of the networking subsystem, interacting with the actual transport hardware. An interface may support one or more protocol families and/or address formats. The <i class="link-sec"><a class="link-sec" href="#x53594e4f50534953">SYNOPSIS</a></i> section of each network interface entry gives a sample specification of the related drivers for use in providing a system description to the <a class="link-man" href="../html8/config.html">config(8)</a> program. The <i class="link-sec"><a class="link-sec" href="#x444941474e4f5354494353">DIAGNOSTICS</a></i> section lists messages which may appear on the console and/or in the system error log, <i class="file">/var/log/messages</i> (see <a class="link-man" href="../html8/syslogd.html">syslogd(8)</a>), due to errors in device operation.<div class="spacer">
</div>
Network interfaces may be collected together into interface groups. An interface group is a container that can be used generically when referring to any interface related by some criteria. When an action is performed on an interface group, such as packet filtering by the <a class="link-man" href="../html4/pf.html">pf(4)</a> subsystem, the operation will be applied to each member interface in the group, if supported by the subsystem. The <a class="link-man" href="../html8/ifconfig.html">ifconfig(8)</a> utility can be used to view and assign membership of an interface to an interface group with the <b class="flag">group</b> modifier.</div>
<div class="section">
<h1 id="x50524f544f434f4c53">PROTOCOLS</h1> The system currently supports the Internet protocols (IPv4 and IPv6), MPLS, and a few others. Raw socket interfaces are provided to the IP protocol layer of the Internet. Consult the appropriate manual pages in this section for more information regarding the support for each protocol family.</div>
<div class="section">
<h1 id="x41444452455353494e47">ADDRESSING</h1> Associated with each protocol family is an address format. All network addresses adhere to a general structure, called a <span class="type">sockaddr</span>, described below. However, each protocol imposes a finer, more specific structure, generally renaming the variant, which is discussed in the protocol family manual page alluded to above.<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
struct sockaddr { 
	u_int8_t	sa_len;		/* total length */ 
	sa_family_t	sa_family;	/* address family */ 
	char		sa_data[14];	/* actually longer */ 
};</pre>
<div class="spacer">
</div>
The field <b class="var">sa_len</b> contains the total length of the structure, which may exceed 16 bytes. The following address values for <b class="var">sa_family</b> are known to the system (and additional formats are defined for possible future implementation):<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
#define AF_LOCAL	1	/* local to host */ 
#define AF_INET		2	/* internetwork: UDP, TCP, etc. */ 
#define AF_INET6	24	/* IPv6 */ 
#define AF_MPLS		33	/* Multiprotocol Label Switching */</pre>
<div class="spacer">
</div>
The <b class="var">sa_data</b> field contains the actual address value. Note that it may be longer than 14 bytes.</div>
<div class="section">
<h1 id="x524f5554494e47">ROUTING</h1> <span class="unix">OpenBSD</span> provides some packet routing facilities. The kernel maintains a routing information database, which is used in selecting the appropriate network interface when transmitting packets.<div class="spacer">
</div>
A user process (or possibly multiple co-operating processes) maintains this database by sending messages over a special kind of socket. This supplants fixed-size <a class="link-man" href="../html2/ioctl.html">ioctl(2)</a>s used in earlier releases.<div class="spacer">
</div>
This facility is described in <a class="link-man" href="../html4/route.html">route(4)</a>.</div>
<div class="section">
<h1 id="x494e5445524641434553">INTERFACES</h1> Each network interface in a system corresponds to a path through which messages may be sent and received. A network interface usually has a hardware device associated with it, though certain interfaces such as the loopback interface, <a class="link-man" href="../html4/lo.html">lo(4)</a>, do not.<div class="spacer">
</div>
The following <a class="link-man" href="../html2/ioctl.html">ioctl(2)</a> calls may be used to manipulate network interfaces. The <a class="link-man" href="../html2/ioctl.html">ioctl(2)</a> is made on a socket (typically of type <span class="define">SOCK_DGRAM</span>) in the desired domain. Most of the requests take an <span class="type">ifreq</span> structure pointer as their parameter. This structure is as follows:<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
struct	ifreq { 
#define IFNAMSIZ 16 
	char	ifr_name[IFNAMSIZ];	/* if name, e.g. &quot;en0&quot; */ 
	union { 
		struct	sockaddr	ifru_addr; 
		struct	sockaddr	ifru_dstaddr; 
		struct	sockaddr	ifru_broadaddr; 
		short			ifru_flags; 
		int			ifru_metric; 
		uint64_t		ifru_media; 
		caddr_t			ifru_data; 
	} ifr_ifru; 
#define	ifr_addr	ifr_ifru.ifru_addr	/* address */ 
#define	ifr_dstaddr	ifr_ifru.ifru_dstaddr	/* other end of p-to-p link */ 
#define	ifr_broadaddr	ifr_ifru.ifru_broadaddr	/* broadcast address */ 
#define	ifr_flags	ifr_ifru.ifru_flags	/* flags */ 
#define	ifr_metric	ifr_ifru.ifru_metric	/* metric */ 
#define	ifr_mtu		ifr_ifru.ifru_metric	/* mtu (overload) */ 
#define	ifr_hardmtu	ifr_ifru.ifru_metric	/* hardmtu (overload) */ 
#define	ifr_media	ifr_ifru.ifru_media	/* media options */ 
#define	ifr_rdomainid	ifr_ifru.ifru_metric	/* VRF instance (overload) */ 
#define	ifr_vnetid	ifr_ifru.ifru_metric	/* Virtual Net Id (overload) */ 
#define	ifr_ttl		ifr_ifru.ifru_metric	/* tunnel TTL (overload) */ 
#define	ifr_data	ifr_ifru.ifru_data	/* for use by interface */ 
};</pre>
<div class="spacer">
</div>
The supported <a class="link-man" href="../html2/ioctl.html">ioctl(2)</a> requests are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCSIFADDR</span> <i class="farg">struct ifreq *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Set the interface address for a protocol family. Following the address assignment, the &#8220;initialization&#8221; routine for the interface is called.<div class="spacer">
</div>
This call has been deprecated and superseded by the <span class="define">SIOCAIFADDR</span> call, described below.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCSIFDSTADDR</span> <i class="farg">struct ifreq *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Set the point-to-point address for a protocol family and interface.<div class="spacer">
</div>
This call has been deprecated and superseded by the <span class="define">SIOCAIFADDR</span> call, described below.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCSIFBRDADDR</span> <i class="farg">struct ifreq *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Set the broadcast address for a protocol family and interface.<div class="spacer">
</div>
This call has been deprecated and superseded by the <span class="define">SIOCAIFADDR</span> call, described below.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCGIFADDR</span> <i class="farg">struct ifreq *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Get the interface address for a protocol family.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCGIFDSTADDR</span> <i class="farg">struct ifreq *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Get the point-to-point address for a protocol family and interface.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCGIFBRDADDR</span> <i class="farg">struct ifreq *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Get the broadcast address for a protocol family and interface.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCGIFDESCR</span> <i class="farg">struct ifreq *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Get the interface description, returned in the <b class="var">ifru_data</b> field.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCSIFDESCR</span> <i class="farg">struct ifreq *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Set the interface description to the value of the <b class="var">ifru_data</b> field, limited to the size of <span class="define">IFDESCRSIZE</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCSIFFLAGS</span> <i class="farg">struct ifreq *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Set the interface flags. If the interface is marked down, any processes currently routing packets through the interface are notified; some interfaces may be reset so that incoming packets are no longer received. When marked up again, the interface is reinitialized.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCGIFFLAGS</span> <i class="farg">struct ifreq *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Get the interface flags.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCGIFXFLAGS</span> <i class="farg">struct ifreq *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Get the extended interface flags.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCGIFMTU</span> <i class="farg">struct ifreq *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Get the current MTU of the interface.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCGIFHARDMTU</span> <i class="farg">struct ifreq *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Get the maximum hardware MTU of the interface.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCSIFMEDIA</span> <i class="farg">struct ifreq *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Set the interface media settings. See <a class="link-man" href="../html4/ifmedia.html">ifmedia(4)</a> for possible values.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCGIFMEDIA</span> <i class="farg">struct ifmediareq *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Get the interface media settings. The <span class="type">ifmediareq</span> structure is as follows:<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
struct ifmediareq { 
	char		ifm_name[IFNAMSIZ];	/* if name, e.g. &quot;en0&quot; */ 
	uint64_t	ifm_current;	/* current media options */ 
	uint64_t	ifm_mask;	/* don't care mask */ 
	uint64_t	ifm_status;	/* media status */ 
	uint64_t	ifm_active;	/* active options */ 
	int		ifm_count;	/* #entries in ifm_ulist array */ 
	uint64_t	*ifm_ulist;	/* media words */ 
};</pre>
<div class="spacer">
</div>
See <a class="link-man" href="../html4/ifmedia.html">ifmedia(4)</a> for interpreting this value.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCSIFMETRIC</span> <i class="farg">struct ifreq *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Set the interface routing metric. The metric is used only by user-level routers.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCGIFMETRIC</span> <i class="farg">struct ifreq *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Get the interface metric.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCSIFPRIORITY</span> <i class="farg">struct ifreq *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Set the interface routing priority. The interface routing priority influences the resulting routing priority of new static routes added to the kernel using the specified interface. The value is in the range of 0 to 16 with smaller numbers being better.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCGIFPRIORITY</span> <i class="farg">struct ifreq *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Get the interface priority.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCGIFRDOMAIN</span> <i class="farg">struct ifreq *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Get the interface routing domain. This identifies which routing table is used for the interface.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCAIFADDR</span> <i class="farg">struct ifaliasreq *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
An interface may have more than one address associated with it in some protocols. This request provides a means to add additional addresses (or modify characteristics of the primary address if the default address for the address family is specified).<div class="spacer">
</div>
Rather than making separate calls to set destination or broadcast addresses, or network masks (now an integral feature of multiple protocols), a separate structure, <span class="type">ifaliasreq</span>, is used to specify all three facets simultaneously (see below). One would use a slightly tailored version of this structure specific to each family (replacing each <span class="type">sockaddr</span> by one of the family-specific type). One should always set the length of a <span class="type">sockaddr</span>, as described in <a class="link-man" href="../html2/ioctl.html">ioctl(2)</a>.<div class="spacer">
</div>
The <span class="type">ifaliasreq</span> structure is as follows:<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
struct ifaliasreq { 
	char	ifra_name[IFNAMSIZ];	/* if name, e.g. &quot;en0&quot; */ 
	struct	sockaddr ifra_addr; 
	struct	sockaddr ifra_dstaddr; 
#define ifra_broadaddr ifra_dstaddr 
	struct	sockaddr ifra_mask; 
};</pre>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCDIFADDR</span> <i class="farg">struct ifreq *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This request deletes the specified address from the list associated with an interface. It also uses the <span class="type">ifaliasreq</span> structure to allow for the possibility of protocols allowing multiple masks or destination addresses, and also adopts the convention that specification of the default address means to delete the first address for the interface belonging to the address family in which the original socket was opened.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCGIFCONF</span> <i class="farg">struct ifconf *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Get the interface configuration list. This request takes an <span class="type">ifconf</span> structure (see below) as a value-result parameter. The <b class="var">ifc_len</b> field should be initially set to the size of the buffer pointed to by <b class="var">ifc_buf</b>. On return it will contain the length, in bytes, of the configuration list.<div class="spacer">
</div>
Alternately, if the <b class="var">ifc_len</b> passed in is set to 0, <span class="define">SIOCGIFCONF</span> will set <b class="var">ifc_len</b> to the size that <b class="var">ifc_buf</b> needs to be to fit the entire configuration list and will not fill in the other parameters. This is useful for determining the exact size that <b class="var">ifc_buf</b> needs to be in advance. Note, however, that this is an extension that not all operating systems support.<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
struct ifconf { 
	int	ifc_len;	  /* size of associated buffer */ 
	union { 
		caddr_t	ifcu_buf; 
		struct	ifreq *ifcu_req; 
	} ifc_ifcu; 
#define ifc_buf ifc_ifcu.ifcu_buf /* buffer address */ 
#define ifc_req ifc_ifcu.ifcu_req /* array of structures ret'd */ 
};</pre>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCIFCREATE</span> <i class="farg">struct ifreq *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Attempt to create the specified interface.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCIFDESTROY</span> <i class="farg">struct ifreq *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Attempt to destroy the specified interface.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCIFGCLONERS</span> <i class="farg">struct if_clonereq *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Get the list of clonable interfaces. This request takes an <span class="type">if_clonereq</span> structure pointer (see below) as a value-result parameter. The <b class="var">ifcr_count</b> field should be set to the number of <span class="define">IFNAMSIZ</span>-sized strings that can fit in the buffer pointed to by <b class="var">ifcr_buffer</b>. On return, <b class="var">ifcr_total</b> will be set to the number of clonable interfaces, and the buffer pointed to by <b class="var">ifcr_buffer</b> will be filled with the names of clonable interfaces aligned on <span class="define">IFNAMSIZ</span> boundaries.<div class="spacer">
</div>
The <span class="type">if_clonereq</span> structure is as follows:<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
struct if_clonereq { 
	int   ifcr_total;  /* total cloners (out) */ 
	int   ifcr_count;  /* room for this many in user buf */ 
	char *ifcr_buffer; /* buffer for cloner names */ 
};</pre>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCAIFGROUP</span> <i class="farg">struct ifgroupreq *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Associate the interface named by <b class="var">ifgr_name</b> with the interface group named by <b class="var">ifgr_group</b>. The <span class="type">ifgroupreq</span> structure is as follows:<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
struct ifg_req { 
	char			 ifgrq_group[IFNAMSIZ]; 
}; 
 
struct ifgroupreq { 
	char	ifgr_name[IFNAMSIZ]; 
	u_int	ifgr_len; 
	union { 
		char	ifgru_group[IFNAMSIZ]; 
		struct	ifg_req *ifgru_groups; 
	} ifgr_ifgru; 
#define ifgr_group	ifgr_ifgru.ifgru_group 
#define ifgr_groups	ifgr_ifgru.ifgru_groups 
};</pre>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCGIFGROUP</span> <i class="farg">struct ifgroupreq *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Retrieve the list of groups for which an interface is a member. The interface is named by <b class="var">ifgr_name</b>. On enter, the amount of memory in which the group names will be written is stored in <b class="var">ifgr_len</b>, and the group names themselves will be written to the memory pointed to by <b class="var">ifgr_groups</b>. On return, the amount of memory actually written is returned in <b class="var">ifgr_len</b>.<div class="spacer">
</div>
Alternately, if the <b class="var">ifgr_len</b> passed in is set to 0, <span class="define">SIOCGIFGROUP</span> will set <b class="var">ifgr_len</b> to the size that <b class="var">ifgr_groups</b> needs to be to fit the entire group list and will not fill in the other parameters. This is useful for determining the exact size that <b class="var">ifgr_groups</b> needs to be in advance.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCDIFGROUP</span> <i class="farg">struct ifgroupreq *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Remove the membership of the interface named by <b class="var">ifgr_name</b> from the group <b class="var">ifgr_group</b>.</dd>
</dl>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html1/netstat.html">netstat(1)</a>, <a class="link-man" href="../html2/ioctl.html">ioctl(2)</a>, <a class="link-man" href="../html2/socket.html">socket(2)</a>, <a class="link-man" href="../html4/arp.html">arp(4)</a>, <a class="link-man" href="../html4/bridge.html">bridge(4)</a>, <a class="link-man" href="../html4/ifmedia.html">ifmedia(4)</a>, <a class="link-man" href="../html4/inet.html">inet(4)</a>, <a class="link-man" href="../html4/intro.html">intro(4)</a>, <a class="link-man" href="../html4/ip.html">ip(4)</a>, <a class="link-man" href="../html4/ip6.html">ip6(4)</a>, <a class="link-man" href="../html4/lo.html">lo(4)</a>, <a class="link-man" href="../html4/mpe.html">mpe(4)</a>, <a class="link-man" href="../html4/pf.html">pf(4)</a>, <a class="link-man" href="../html4/tcp.html">tcp(4)</a>, <a class="link-man" href="../html4/udp.html">udp(4)</a>, <a class="link-man" href="../html5/hosts.html">hosts(5)</a>, <a class="link-man" href="../html5/networks.html">networks(5)</a>, <a class="link-man" href="../html8/bgpd.html">bgpd(8)</a>, <a class="link-man" href="../html8/config.html">config(8)</a>, <a class="link-man" href="../html8/ifconfig.html">ifconfig(8)</a>, <a class="link-man" href="../html8/mrouted.html">mrouted(8)</a>, <a class="link-man" href="../html8/netstart.html">netstart(8)</a>, <a class="link-man" href="../html8/ospfd.html">ospfd(8)</a>, <a class="link-man" href="../html8/ripd.html">ripd(8)</a>, <a class="link-man" href="../html8/route.html">route(8)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The <b class="name">netintro</b> manual appeared in <span class="unix">4.3BSD-Tahoe</span>.</div>
</div>
</body>
</html>

