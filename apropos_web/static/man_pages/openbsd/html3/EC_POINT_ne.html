<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
EC_POINT_NEW(3)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
EC_POINT_NEW(3)</td>
<td class="head-vol">
OpenSSL</td>
<td class="head-rtitle">
EC_POINT_NEW(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> EC_POINT_new, EC_POINT_free, EC_POINT_clear_free, EC_POINT_copy, EC_POINT_dup, EC_POINT_method_of, EC_POINT_set_to_infinity, EC_POINT_set_Jprojective_coordinates, EC_POINT_get_Jprojective_coordinates_GFp, EC_POINT_set_affine_coordinates_GFp, EC_POINT_get_affine_coordinates_GFp, EC_POINT_set_compressed_coordinates_GFp, EC_POINT_set_affine_coordinates_GF2m, EC_POINT_get_affine_coordinates_GF2m, EC_POINT_set_compressed_coordinates_GF2m, EC_POINT_point2oct, EC_POINT_oct2point, EC_POINT_point2bn, EC_POINT_bn2point, EC_POINT_point2hex, EC_POINT_hex2point - Functions for creating, destroying and manipulating EC_POINT objects.</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
 #include &lt;openssl/ec.h&gt;<br/>
 #include &lt;openssl/bn.h&gt;<br/>
<br/>
 EC_POINT *EC_POINT_new(const EC_GROUP *group);<br/>
 void EC_POINT_free(EC_POINT *point);<br/>
 void EC_POINT_clear_free(EC_POINT *point);<br/>
 int EC_POINT_copy(EC_POINT *dst, const EC_POINT *src);<br/>
 EC_POINT *EC_POINT_dup(const EC_POINT *src, const EC_GROUP *group);<br/>
 const EC_METHOD *EC_POINT_method_of(const EC_POINT *point);<br/>
 int EC_POINT_set_to_infinity(const EC_GROUP *group, EC_POINT *point);<br/>
 int EC_POINT_set_Jprojective_coordinates_GFp(const EC_GROUP *group, EC_POINT *p,<br/>
        const BIGNUM *x, const BIGNUM *y, const BIGNUM *z, BN_CTX *ctx);<br/>
 int EC_POINT_get_Jprojective_coordinates_GFp(const EC_GROUP *group,<br/>
        const EC_POINT *p, BIGNUM *x, BIGNUM *y, BIGNUM *z, BN_CTX *ctx);<br/>
 int EC_POINT_set_affine_coordinates_GFp(const EC_GROUP *group, EC_POINT *p,<br/>
        const BIGNUM *x, const BIGNUM *y, BN_CTX *ctx);<br/>
 int EC_POINT_get_affine_coordinates_GFp(const EC_GROUP *group,<br/>
        const EC_POINT *p, BIGNUM *x, BIGNUM *y, BN_CTX *ctx);<br/>
 int EC_POINT_set_compressed_coordinates_GFp(const EC_GROUP *group, EC_POINT *p,<br/>
        const BIGNUM *x, int y_bit, BN_CTX *ctx);<br/>
 int EC_POINT_set_affine_coordinates_GF2m(const EC_GROUP *group, EC_POINT *p,<br/>
        const BIGNUM *x, const BIGNUM *y, BN_CTX *ctx);<br/>
 int EC_POINT_get_affine_coordinates_GF2m(const EC_GROUP *group,<br/>
        const EC_POINT *p, BIGNUM *x, BIGNUM *y, BN_CTX *ctx);<br/>
 int EC_POINT_set_compressed_coordinates_GF2m(const EC_GROUP *group, EC_POINT *p,<br/>
        const BIGNUM *x, int y_bit, BN_CTX *ctx);<br/>
 size_t EC_POINT_point2oct(const EC_GROUP *group, const EC_POINT *p,<br/>
        point_conversion_form_t form,<br/>
        unsigned char *buf, size_t len, BN_CTX *ctx);<br/>
 int EC_POINT_oct2point(const EC_GROUP *group, EC_POINT *p,<br/>
        const unsigned char *buf, size_t len, BN_CTX *ctx);<br/>
 BIGNUM *EC_POINT_point2bn(const EC_GROUP *, const EC_POINT *,<br/>
        point_conversion_form_t form, BIGNUM *, BN_CTX *);<br/>
 EC_POINT *EC_POINT_bn2point(const EC_GROUP *, const BIGNUM *,<br/>
        EC_POINT *, BN_CTX *);<br/>
 char *EC_POINT_point2hex(const EC_GROUP *, const EC_POINT *,<br/>
        point_conversion_form_t form, BN_CTX *);<br/>
 EC_POINT *EC_POINT_hex2point(const EC_GROUP *, const char *,<br/>
        EC_POINT *, BN_CTX *);<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> An EC_POINT represents a point on a curve. A new point is constructed by calling the function EC_POINT_new and providing the  <b>group</b> object that the point relates to.<div class="spacer">
</div>
EC_POINT_free frees the memory associated with the EC_POINT.<div class="spacer">
</div>
EC_POINT_clear_free destroys any sensitive data held within the EC_POINT and then frees its memory.<div class="spacer">
</div>
EC_POINT_copy copies the point <b>src</b> into <b>dst</b>. Both <b>src</b> and <b>dst</b> must use the same EC_METHOD.<div class="spacer">
</div>
EC_POINT_dup creates a new EC_POINT object and copies the content from <b>src</b> to the newly created EC_POINT object.<div class="spacer">
</div>
EC_POINT_method_of obtains the EC_METHOD associated with <b>point</b>.<div class="spacer">
</div>
A valid point on a curve is the special point at  infinity. A point is set to be at infinity by calling EC_POINT_set_to_infinity.<div class="spacer">
</div>
The affine co-ordinates for a point describe a point in terms of its x and y position. The functions EC_POINT_set_affine_coordinates_GFp and EC_POINT_set_affine_coordinates_GF2m set the  <b>x</b> and <b>y</b> co-ordinates for the point  <b>p</b> defined over the curve given in <b>group</b>.<div class="spacer">
</div>
As well as the affine co-ordinates, a point can alternatively be described in terms of its Jacobian projective co-ordinates (for Fp curves only). Jacobian projective co-ordinates are expressed as three values x, y and z. Working in this co-ordinate system provides more efficient point multiplication operations. A mapping exists between Jacobian projective co-ordinates and affine co-ordinates. A Jacobian projective co-ordinate (x, y, z) can be written as an affine co-ordinate as (x/(z^2), y/(z^3)). Conversion to Jacobian projective to affine co-ordinates is simple. The co-ordinate (x, y) is mapped to (x, y, 1). To set or get the projective co-ordinates use EC_POINT_set_Jprojective_coordinates_GFp and EC_POINT_get_Jprojective_coordinates_GFp respectively.<div class="spacer">
</div>
Points can also be described in terms of their compressed co-ordinates. For a point (x, y), for any given value for x such that the point is on the curve there will only ever be two possible values for y. Therefore a point can be set using the EC_POINT_set_compressed_coordinates_GFp and EC_POINT_set_compressed_coordinates_GF2m functions where  <b>x</b> is the x co-ordinate and <b>y_bit</b> is a value 0 or 1 to identify which of the two possible values for y should be used.<div class="spacer">
</div>
In addition EC_POINTs can be converted to and from various external representations. Supported representations are octet strings, BIGNUMs and hexadecimal. The format of the external representation is described by the point_conversion_form. See <i>EC_GROUP_copy</i>(3) for a description of point_conversion_form. Octet strings are stored in a buffer along with an associated buffer length. A point held in a BIGNUM is calculated by converting the point to an octet string and then converting that octet string into a BIGNUM integer. Points in hexadecimal format are stored in a NULL terminated character string where each character is one of the printable values 0-9 or A-F (or a-f).<div class="spacer">
</div>
The functions EC_POINT_point2oct, EC_POINT_oct2point, EC_POINT_point2bn, EC_POINT_bn2point, EC_POINT_point2hex and EC_POINT_hex2point convert from and to EC_POINTs for the formats: octet string, BIGNUM and hexadecimal respectively.<div class="spacer">
</div>
The function EC_POINT_point2oct must be supplied with a buffer long enough to store the octet string. The return value provides the number of octets stored. Calling the function with a NULL buffer will not perform the conversion but will still return the required buffer length.<div class="spacer">
</div>
The function EC_POINT_point2hex will allocate sufficient memory to store the hexadecimal string. It is the caller's responsibility to free this memory with a subsequent call to  <i>free()</i>.</div>
<div class="section">
<h1>RETURN VALUES</h1> EC_POINT_new and EC_POINT_dup return the newly allocated EC_POINT or NULL on error.<div class="spacer">
</div>
The following functions return 1 on success or 0 on error: EC_POINT_copy, EC_POINT_set_to_infinity, EC_POINT_set_Jprojective_coordinates_GFp, EC_POINT_get_Jprojective_coordinates_GFp, EC_POINT_set_affine_coordinates_GFp, EC_POINT_get_affine_coordinates_GFp, EC_POINT_set_compressed_coordinates_GFp, EC_POINT_set_affine_coordinates_GF2m, EC_POINT_get_affine_coordinates_GF2m, EC_POINT_set_compressed_coordinates_GF2m and EC_POINT_oct2point.<div class="spacer">
</div>
EC_POINT_method_of returns the EC_METHOD associated with the supplied EC_POINT.<div class="spacer">
</div>
EC_POINT_point2oct returns the length of the required buffer, or 0 on error.<div class="spacer">
</div>
EC_POINT_point2bn returns the pointer to the BIGNUM supplied, or NULL on error.<div class="spacer">
</div>
EC_POINT_bn2point returns the pointer to the EC_POINT supplied, or NULL on error.<div class="spacer">
</div>
EC_POINT_point2hex returns a pointer to the hex string, or NULL on error.<div class="spacer">
</div>
EC_POINT_hex2point returns the pointer to the EC_POINT supplied, or NULL on error.</div>
<div class="section">
<h1>SEE ALSO</h1>  <i>crypto</i>(3), <i>ec</i>(3), <i>EC_GROUP_new</i>(3), <i>EC_GROUP_copy</i>(3),  <i>EC_POINT_add</i>(3), <i>EC_KEY_new</i>(3),  <i>EC_GFp_simple_method</i>(3), <i>d2i_ECPKParameters</i>(3)</div>
<table class="foot">
<tr>
<td class="foot-date">
2014-07-13</td>
<td class="foot-os">
OpenBSD 6.0</td>
</tr>
</table>
</div>
</body>
</html>

