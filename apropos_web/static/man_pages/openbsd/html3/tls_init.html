<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
TLS_INIT(3)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">tls_init</b>, <b class="name">tls_config_error</b>, <b class="name">tls_error</b>, <b class="name">tls_config_new</b>, <b class="name">tls_config_free</b>, <b class="name">tls_config_parse_protocols</b>, <b class="name">tls_config_set_ca_file</b>, <b class="name">tls_config_set_ca_path</b>, <b class="name">tls_config_set_ca_mem</b>, <b class="name">tls_config_set_cert_file</b>, <b class="name">tls_config_set_cert_mem</b>, <b class="name">tls_config_set_ciphers</b>, <b class="name">tls_config_set_dheparams</b>, <b class="name">tls_config_set_ecdhecurve</b>, <b class="name">tls_config_set_key_file</b>, <b class="name">tls_config_set_key_mem</b>, <b class="name">tls_config_set_keypair_file</b>, <b class="name">tls_config_set_keypair_mem</b>, <b class="name">tls_config_set_protocols</b>, <b class="name">tls_config_set_verify_depth</b>, <b class="name">tls_config_prefer_ciphers_client</b>, <b class="name">tls_config_prefer_ciphers_server</b>, <b class="name">tls_config_clear_keys</b>, <b class="name">tls_config_insecure_noverifycert</b>, <b class="name">tls_config_insecure_noverifyname</b>, <b class="name">tls_config_insecure_noverifytime</b>, <b class="name">tls_config_verify</b>, <b class="name">tls_config_verify_client</b>, <b class="name">tls_config_verify_client_optional</b>, <b class="name">tls_peer_cert_provided</b>, <b class="name">tls_peer_cert_contains_name</b>, <b class="name">tls_peer_cert_issuer</b>, <b class="name">tls_peer_cert_subject</b>, <b class="name">tls_peer_cert_hash</b>, <b class="name">tls_peer_cert_notbefore</b>, <b class="name">tls_peer_cert_notafter</b>, <b class="name">tls_conn_version</b>, <b class="name">tls_conn_cipher</b>, <b class="name">tls_load_file</b>, <b class="name">tls_client</b>, <b class="name">tls_server</b>, <b class="name">tls_configure</b>, <b class="name">tls_reset</b>, <b class="name">tls_free</b>, <b class="name">tls_connect</b>, <b class="name">tls_connect_fds</b>, <b class="name">tls_connect_servername</b>, <b class="name">tls_connect_socket</b>, <b class="name">tls_accept_fds</b>, <b class="name">tls_accept_socket</b>, <b class="name">tls_handshake</b>, <b class="name">tls_read</b>, <b class="name">tls_write</b>, <b class="name">tls_close</b> &#8212; <span class="desc">TLS client and server API</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">tls.h</a>&gt;</b><div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">tls_init</b>(<i class="farg" style="white-space:nowrap;">void</i>);<div class="spacer">
</div>
<i class="ftype">const char *</i><br/>
<b class="fname">tls_config_error</b>(<i class="farg" style="white-space:nowrap;">struct tls_config *config</i>);<div class="spacer">
</div>
<i class="ftype">const char *</i><br/>
<b class="fname">tls_error</b>(<i class="farg" style="white-space:nowrap;">struct tls *ctx</i>);<div class="spacer">
</div>
<i class="ftype">struct tls_config *</i><br/>
<b class="fname">tls_config_new</b>(<i class="farg" style="white-space:nowrap;">void</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">tls_config_free</b>(<i class="farg" style="white-space:nowrap;">struct tls_config *config</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">tls_config_parse_protocols</b>(<i class="farg" style="white-space:nowrap;">uint32_t *protocols</i>, <i class="farg" style="white-space:nowrap;">const char *protostr</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">tls_config_set_ca_file</b>(<i class="farg" style="white-space:nowrap;">struct tls_config *config</i>, <i class="farg" style="white-space:nowrap;">const char *ca_file</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">tls_config_set_ca_path</b>(<i class="farg" style="white-space:nowrap;">struct tls_config *config</i>, <i class="farg" style="white-space:nowrap;">const char *ca_path</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">tls_config_set_ca_mem</b>(<i class="farg" style="white-space:nowrap;">struct tls_config *config</i>, <i class="farg" style="white-space:nowrap;">const uint8_t *cert</i>, <i class="farg" style="white-space:nowrap;">size_t len</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">tls_config_set_cert_file</b>(<i class="farg" style="white-space:nowrap;">struct tls_config *config</i>, <i class="farg" style="white-space:nowrap;">const char *cert_file</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">tls_config_set_cert_mem</b>(<i class="farg" style="white-space:nowrap;">struct tls_config *config</i>, <i class="farg" style="white-space:nowrap;">const uint8_t *cert</i>, <i class="farg" style="white-space:nowrap;">size_t len</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">tls_config_set_ciphers</b>(<i class="farg" style="white-space:nowrap;">struct tls_config *config</i>, <i class="farg" style="white-space:nowrap;">const char *ciphers</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">tls_config_set_dheparams</b>(<i class="farg" style="white-space:nowrap;">struct tls_config *config</i>, <i class="farg" style="white-space:nowrap;">const char *params</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">tls_config_set_ecdhecurve</b>(<i class="farg" style="white-space:nowrap;">struct tls_config *config</i>, <i class="farg" style="white-space:nowrap;">const char *name</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">tls_config_set_key_file</b>(<i class="farg" style="white-space:nowrap;">struct tls_config *config</i>, <i class="farg" style="white-space:nowrap;">const char *key_file</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">tls_config_set_key_mem</b>(<i class="farg" style="white-space:nowrap;">struct tls_config *config</i>, <i class="farg" style="white-space:nowrap;">const uint8_t *key</i>, <i class="farg" style="white-space:nowrap;">size_t len</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">tls_config_set_keypair_file</b>(<i class="farg" style="white-space:nowrap;">struct tls_config *config</i>, <i class="farg" style="white-space:nowrap;">const char *cert_file</i>, <i class="farg" style="white-space:nowrap;">const char *key_file</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">tls_config_set_keypair_mem</b>(<i class="farg" style="white-space:nowrap;">struct tls_config *config</i>, <i class="farg" style="white-space:nowrap;">const uint8_t *cert</i>, <i class="farg" style="white-space:nowrap;">size_t cert_len</i>, <i class="farg" style="white-space:nowrap;">const uint8_t *key</i>, <i class="farg" style="white-space:nowrap;">size_t key_len</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">tls_config_set_protocols</b>(<i class="farg" style="white-space:nowrap;">struct tls_config *config</i>, <i class="farg" style="white-space:nowrap;">uint32_t protocols</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">tls_config_set_verify_depth</b>(<i class="farg" style="white-space:nowrap;">struct tls_config *config</i>, <i class="farg" style="white-space:nowrap;">int verify_depth</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">tls_config_prefer_ciphers_client</b>(<i class="farg" style="white-space:nowrap;">struct tls_config *config</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">tls_config_prefer_ciphers_server</b>(<i class="farg" style="white-space:nowrap;">struct tls_config *config</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">tls_config_clear_keys</b>(<i class="farg" style="white-space:nowrap;">struct tls_config *config</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">tls_config_insecure_noverifycert</b>(<i class="farg" style="white-space:nowrap;">struct tls_config *config</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">tls_config_insecure_noverifyname</b>(<i class="farg" style="white-space:nowrap;">struct tls_config *config</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">tls_config_insecure_noverifytime</b>(<i class="farg" style="white-space:nowrap;">struct tls_config *config</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">tls_config_verify</b>(<i class="farg" style="white-space:nowrap;">struct tls_config *config</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">tls_config_verify_client</b>(<i class="farg" style="white-space:nowrap;">struct tls_config *config</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">tls_config_verify_client_optional</b>(<i class="farg" style="white-space:nowrap;">struct tls_config *config</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">tls_peer_cert_provided</b>(<i class="farg" style="white-space:nowrap;">struct tls *ctx</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">tls_peer_cert_contains_name</b>(<i class="farg" style="white-space:nowrap;">struct tls *ctx</i>, <i class="farg" style="white-space:nowrap;">const char *name</i>);<div class="spacer">
</div>
<i class="ftype">const char *</i><br/>
<b class="fname">tls_peer_cert_issuer</b>(<i class="farg" style="white-space:nowrap;">struct tls *ctx</i>);<div class="spacer">
</div>
<i class="ftype">const char *</i><br/>
<b class="fname">tls_peer_cert_subject</b>(<i class="farg" style="white-space:nowrap;">struct tls *ctx</i>);<div class="spacer">
</div>
<i class="ftype">const char *</i><br/>
<b class="fname">tls_peer_cert_hash</b>(<i class="farg" style="white-space:nowrap;">struct tls *ctx</i>);<div class="spacer">
</div>
<i class="ftype">time_t</i><br/>
<b class="fname">tls_peer_cert_notbefore</b>(<i class="farg" style="white-space:nowrap;">struct tls *ctx</i>);<div class="spacer">
</div>
<i class="ftype">time_t</i><br/>
<b class="fname">tls_peer_cert_notafter</b>(<i class="farg" style="white-space:nowrap;">struct tls *ctx</i>);<div class="spacer">
</div>
<i class="ftype">const char *</i><br/>
<b class="fname">tls_conn_version</b>(<i class="farg" style="white-space:nowrap;">struct tls *ctx</i>);<div class="spacer">
</div>
<i class="ftype">const char *</i><br/>
<b class="fname">tls_conn_cipher</b>(<i class="farg" style="white-space:nowrap;">struct tls *ctx</i>);<div class="spacer">
</div>
<i class="ftype">uint8_t *</i><br/>
<b class="fname">tls_load_file</b>(<i class="farg" style="white-space:nowrap;">const char *file</i>, <i class="farg" style="white-space:nowrap;">size_t *len</i>, <i class="farg" style="white-space:nowrap;">char *password</i>);<div class="spacer">
</div>
<i class="ftype">struct tls *</i><br/>
<b class="fname">tls_client</b>(<i class="farg" style="white-space:nowrap;">void</i>);<div class="spacer">
</div>
<i class="ftype">struct tls *</i><br/>
<b class="fname">tls_server</b>(<i class="farg" style="white-space:nowrap;">void</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">tls_configure</b>(<i class="farg" style="white-space:nowrap;">struct tls *ctx</i>, <i class="farg" style="white-space:nowrap;">struct tls_config *config</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">tls_reset</b>(<i class="farg" style="white-space:nowrap;">struct tls *ctx</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">tls_free</b>(<i class="farg" style="white-space:nowrap;">struct tls *ctx</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">tls_connect</b>(<i class="farg" style="white-space:nowrap;">struct tls *ctx</i>, <i class="farg" style="white-space:nowrap;">const char *host</i>, <i class="farg" style="white-space:nowrap;">const char *port</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">tls_connect_fds</b>(<i class="farg" style="white-space:nowrap;">struct tls *ctx</i>, <i class="farg" style="white-space:nowrap;">int fd_read</i>, <i class="farg" style="white-space:nowrap;">int fd_write</i>, <i class="farg" style="white-space:nowrap;">const char *servername</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">tls_connect_servername</b>(<i class="farg" style="white-space:nowrap;">struct tls *ctx</i>, <i class="farg" style="white-space:nowrap;">const char *host</i>, <i class="farg" style="white-space:nowrap;">const char *port</i>, <i class="farg" style="white-space:nowrap;">const char *servername</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">tls_connect_socket</b>(<i class="farg" style="white-space:nowrap;">struct tls *ctx</i>, <i class="farg" style="white-space:nowrap;">int s</i>, <i class="farg" style="white-space:nowrap;">const char *servername</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">tls_accept_fds</b>(<i class="farg" style="white-space:nowrap;">struct tls *tls</i>, <i class="farg" style="white-space:nowrap;">struct tls **cctx</i>, <i class="farg" style="white-space:nowrap;">int fd_read</i>, <i class="farg" style="white-space:nowrap;">int fd_write</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">tls_accept_socket</b>(<i class="farg" style="white-space:nowrap;">struct tls *tls</i>, <i class="farg" style="white-space:nowrap;">struct tls **cctx</i>, <i class="farg" style="white-space:nowrap;">int socket</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">tls_handshake</b>(<i class="farg" style="white-space:nowrap;">struct tls *ctx</i>);<div class="spacer">
</div>
<i class="ftype">ssize_t</i><br/>
<b class="fname">tls_read</b>(<i class="farg" style="white-space:nowrap;">struct tls *ctx</i>, <i class="farg" style="white-space:nowrap;">void *buf</i>, <i class="farg" style="white-space:nowrap;">size_t buflen</i>);<div class="spacer">
</div>
<i class="ftype">ssize_t</i><br/>
<b class="fname">tls_write</b>(<i class="farg" style="white-space:nowrap;">struct tls *ctx</i>, <i class="farg" style="white-space:nowrap;">const void *buf</i>, <i class="farg" style="white-space:nowrap;">size_t buflen</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">tls_close</b>(<i class="farg" style="white-space:nowrap;">struct tls *ctx</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <b class="name">tls</b> family of functions establishes a secure communications channel using the TLS socket protocol. Both clients and servers are supported.<div class="spacer">
</div>
The <b class="fname">tls_init</b>() function should be called once before any function is used. It may be called more than once, but not concurrently.<div class="spacer">
</div>
Before a connection is created, a configuration must be created. The <b class="fname">tls_config_new</b>() function returns a new default configuration that can be used for future connections. Several functions exist to change the options of the configuration; see below.<div class="spacer">
</div>
A TLS connection is represented as a <span class="emph">context</span>. A new <span class="emph">context</span> is created by either the <b class="fname">tls_client</b>() or <b class="fname">tls_server</b>() functions. The context can then be configured with the function <b class="fname">tls_configure</b>(). The same <span class="emph">tls_config</span> object can be used to configure multiple contexts.<div class="spacer">
</div>
A client connection is initiated after configuration by calling <b class="fname">tls_connect</b>(). This function will create a new socket, connect to the specified host and port, and then establish a secure connection. The <b class="fname">tls_connect_servername</b>() function has the same behaviour, however the name to use for verification is explicitly provided, rather than being inferred from the <i class="arg">host</i> value. An already existing socket can be upgraded to a secure connection by calling <b class="fname">tls_connect_socket</b>(). Alternatively, a secure connection can be established over a pair of existing file descriptors by calling <b class="fname">tls_connect_fds</b>().<div class="spacer">
</div>
A server can accept a new client connection by calling <b class="fname">tls_accept_socket</b>() on an already established socket connection. Alternatively, a new client connection can be accepted over a pair of existing file descriptors by calling <b class="fname">tls_accept_fds</b>().<div class="spacer">
</div>
The TLS handshake can be completed by calling <b class="fname">tls_handshake</b>(). Two functions are provided for input and output, <b class="fname">tls_read</b>() and <b class="fname">tls_write</b>(). Both of these functions will result in the TLS handshake being performed if it has not already completed.<div class="spacer">
</div>
After use, a TLS <span class="emph">context</span> should be closed with <b class="fname">tls_close</b>(), and then freed by calling <b class="fname">tls_free</b>(). When no more contexts are to be created, the <span class="emph">tls_config</span> object should be freed by calling <b class="fname">tls_config_free</b>().</div>
<div class="section">
<h1 id="x46554e4354494f4e53">FUNCTIONS</h1> The <b class="fname">tls_init</b>() function initializes global data structures. It should be called once before any other functions.<div class="spacer">
</div>
The following functions create and free configuration objects.<ul style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 4.00ex;" class="list list-bul">
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_config_new</b>() allocates a new default configuration object.</li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_config_free</b>() frees a configuration object.</li>
</ul>
<div class="spacer">
</div>
The <b class="fname">tls_config_parse_protocols</b>() function parses a protocol string and returns the corresponding value via the <i class="arg">protocols</i> argument. This value can then be passed to the <b class="fname">tls_config_set_protocols</b>() function. The protocol string is a comma or colon separated list of keywords. Valid keywords are tlsv1.0, tlsv1.1, tlsv1.2, all (all supported protocols), default (an alias for secure), legacy (an alias for all) and secure (currently TLSv1.2 only). If a value has a negative prefix (in the form of a leading exclamation mark) then it is removed from the list of available protocols, rather than being added to it.<div class="spacer">
</div>
The following functions modify a configuration by setting parameters. Configuration options may apply to only clients or only servers or both.<ul style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 4.00ex;" class="list list-bul">
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_config_set_ca_file</b>() sets the filename used to load a file containing the root certificates. <span class="emph">(Client and Server)</span></li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_config_set_ca_path</b>() sets the path (directory) which should be searched for root certificates. <span class="emph">(Client and Server)</span></li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_config_set_ca_mem</b>() sets the root certificates directly from memory. <span class="emph">(Client and Server)</span></li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_config_set_cert_file</b>() sets file from which the public certificate will be read. <span class="emph">(Client and server)</span></li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_config_set_cert_mem</b>() sets the public certificate directly from memory. <span class="emph">(Client and server)</span></li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_config_set_ciphers</b>() sets the list of ciphers that may be used. Lists of ciphers are specified by name, and the permitted names are:<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">secure</span></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">default (an alias for secure)</span></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">legacy</span></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">compat (an alias for legacy)</span></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
</dd>
</dl>
<div class="spacer">
</div>
<span class="emph">(Client and server)</span></li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_config_set_key_file</b>() sets the file from which the private key will be read. <span class="emph">(Client and server)</span></li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_config_set_key_mem</b>() directly sets the private key from memory. <span class="emph">(Client and server)</span></li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_config_set_keypair_file</b>() sets the files from which the public certificate and private key will be read. <span class="emph">(Client and server)</span></li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_config_set_keypair_mem</b>() directly sets the public certificate and private key from memory. <span class="emph">(Client and server)</span></li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_config_set_protocols</b>() sets which versions of the protocol may be used. Possible values are the bitwise OR of:<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">TLS_PROTOCOL_TLSv1_0</span></dt>
<dd class="list-tag" style="margin-left: 20.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">TLS_PROTOCOL_TLSv1_1</span></dt>
<dd class="list-tag" style="margin-left: 20.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">TLS_PROTOCOL_TLSv1_2</span></dt>
<dd class="list-tag" style="margin-left: 20.00ex;">
</dd>
</dl>
<div class="spacer">
</div>
Additionally, the values <span class="define">TLS_PROTOCOL_TLSv1</span> (TLSv1.0, TLSv1.1 and TLSv1.2), <span class="define">TLS_PROTOCOLS_ALL</span> (all supported protocols) and <span class="define">TLS_PROTOCOLS_DEFAULT</span> (TLSv1.2 only) may be used. <span class="emph">(Client and server)</span></li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_config_prefer_ciphers_client</b>() prefers ciphers in the client's cipher list when selecting a cipher suite. This is considered to be less secure than preferring the server's list. <span class="emph">(Server)</span></li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_config_prefer_ciphers_server</b>() prefers ciphers in the server's cipher list when selecting a cipher suite. This is considered to be more secure than preferring the client's list and is the default. <span class="emph">(Server)</span></li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_config_clear_keys</b>() clears any secret keys from memory. <span class="emph">(Server)</span></li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_config_insecure_noverifycert</b>() disables certificate verification. Be extremely careful when using this option. <span class="emph">(Client and server)</span></li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_config_insecure_noverifyname</b>() disables server name verification. Be careful when using this option. <span class="emph">(Client)</span></li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_config_insecure_noverifytime</b>() disables validity checking of certificates. Be careful when using this option. <span class="emph">(Client and server)</span></li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_config_verify</b>() reenables server name and certificate verification. <span class="emph">(Client)</span></li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_config_verify_client</b>() enables client certificate verification, requiring the client to send a certificate. <span class="emph">(Server)</span></li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_config_verify_client_optional</b>() enables client certificate verification, without requiring the client to send a certificate. <span class="emph">(Server)</span></li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_peer_cert_provided</b>() checks if the peer of <i class="arg">ctx</i> has provided a certificate. <b class="fname">tls_peer_cert_provided</b>() can only succeed after the handshake is complete. <span class="emph">(Server and client)</span></li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_peer_cert_contains_name</b>() checks if the peer of a TLS <i class="arg">ctx</i> has provided a certificate that contains a SAN or CN that matches <i class="arg">name</i>. <b class="fname">tls_peer_cert_contains_name</b>() can only succeed after the handshake is complete. <span class="emph">(Server and client)</span></li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_peer_cert_subject</b>() returns a string corresponding to the subject of the peer certificate from <i class="arg">ctx</i>. <b class="fname">tls_peer_cert_subject</b>() will only succeed after the handshake is complete. <span class="emph">(Server and client)</span></li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_peer_cert_issuer</b>() returns a string corresponding to the issuer of the peer certificate from <i class="arg">ctx</i>. <b class="fname">tls_peer_cert_issuer</b>() will only succeed after the handshake is complete. <span class="emph">(Server and client)</span></li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_peer_cert_hash</b>() returns a string corresponding to a hash of the raw peer certificate from <i class="arg">ctx</i> prefixed by a hash name followed by a colon. The hash currently used is SHA256, though this could change in the future. The hash string for a certificate in file <i class="arg">mycert.crt</i> can be generated using the commands:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
h=$(openssl x509 -outform der -in mycert.crt | sha256) 
printf &quot;SHA256:${h}\n&quot;</pre>
</li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_peer_cert_notbefore</b>() returns the time corresponding to the start of the validity period of the peer certificate from <i class="arg">ctx</i>. <b class="fname">tls_peer_cert_notbefore</b>() will only succeed after the handshake is complete. <span class="emph">(Server and client)</span></li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_peer_cert_notafter</b>() returns the time corresponding to the end of the validity period of the peer certificate from <i class="arg">ctx</i>. <b class="fname">tls_peer_cert_notafter</b>() will only succeed after the handshake is complete. <span class="emph">(Server and client)</span></li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_conn_version</b>() returns a string corresponding to a TLS version negotiated with the peer connected to <i class="arg">ctx</i>. <b class="fname">tls_conn_version</b>() will only succeed after the handshake is complete.</li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_conn_cipher</b>() returns a string corresponding to the cipher suite negotiated with the peer connected to <i class="arg">ctx</i>. <b class="fname">tls_conn_cipher</b>() will only succeed after the handshake is complete. <span class="emph">(Server and client)</span></li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_load_file</b>() loads a certificate or key from disk into memory to be loaded with <b class="fname">tls_config_set_ca_mem</b>(), <b class="fname">tls_config_set_cert_mem</b>() or <b class="fname">tls_config_set_key_mem</b>(). A private key will be decrypted if the optional <i class="arg">password</i> argument is specified. <span class="emph">(Client and server)</span></li>
</ul>
<div class="spacer">
</div>
The following functions create, prepare, and free a connection context.<ul style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 4.00ex;" class="list list-bul">
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_client</b>() creates a new TLS context for client connections.</li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_server</b>() creates a new TLS context for server connections.</li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_configure</b>() readies a TLS context for use by applying the configuration options.</li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_free</b>() frees a TLS context after use.</li>
</ul>
<div class="spacer">
</div>
The following functions initiate a connection and perform input and output operations.<ul style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 4.00ex;" class="list list-bul">
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_connect</b>() connects a client context to the server named by <i class="farg">host</i>. The <i class="farg">port</i> may be numeric or a service name. If it is NULL then a host of the format &quot;hostname:port&quot; is permitted.</li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_connect_fds</b>() connects a client context to a pair of existing file descriptors.</li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_connect_socket</b>() connects a client context to an already established socket connection.</li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_accept_fds</b>() creates a new context suitable for reading and writing on an existing pair of file descriptors and returns it in <i class="farg">*cctx</i>. A configured server context should be passed in <i class="farg">ctx</i>.</li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_accept_socket</b>() creates a new context suitable for reading and writing on an already established socket connection and returns it in <i class="farg">*cctx</i>. A configured server context should be passed in <i class="farg">ctx</i>.</li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_handshake</b>() performs the TLS handshake. It is only necessary to call this function if you need to guarantee that the handshake has completed, as both <b class="fname">tls_read</b>() and <b class="fname">tls_write</b>() will perform the TLS handshake if necessary.</li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_read</b>() reads <i class="farg">buflen</i> bytes of data from the socket into <i class="farg">buf</i>. It returns the amount of data read.</li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_write</b>() writes <i class="farg">buflen</i> bytes of data from <i class="farg">buf</i> to the socket. It returns the amount of data written.</li>
<li class="list-bul" style="margin-top: 1.00em;">
<b class="fname">tls_close</b>() closes a connection after use. Only the TLS layer will be shut down and the caller is responsible for closing the file descriptors, unless the connection was established using <b class="fname">tls_connect</b>() or <b class="fname">tls_connect_servername</b>().</li>
</ul>
</div>
<div class="section">
<h1 id="x52455455524e2056414c554553">RETURN VALUES</h1> The <b class="fname">tls_peer_cert_provided</b>() and <b class="fname">tls_peer_cert_contains_name</b>() functions return 1 if the check succeeds, and 0 if it does not. Functions that return a <span class="type">time_t</span> will return a time in epoch-seconds on success, and -1 on error. Functions that return a <span class="type">ssize_t</span> will return a size on success, and -1 on error. All other functions that return <span class="type">int</span> will return 0 on success and -1 on error. Functions that return a pointer will return NULL on error, which indicates an out of memory condition.<div class="spacer">
</div>
The <b class="fname">tls_handshake</b>(), <b class="fname">tls_read</b>(), <b class="fname">tls_write</b>(), and <b class="fname">tls_close</b>() functions have two special return values:<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">TLS_WANT_POLLIN</span></dt>
<dd class="list-tag" style="margin-left: 16.00ex;">
The underlying read file descriptor needs to be readable in order to continue.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">TLS_WANT_POLLOUT</span></dt>
<dd class="list-tag" style="margin-left: 16.00ex;">
The underlying write file descriptor needs to be writeable in order to continue.</dd>
</dl>
<div class="spacer">
</div>
In the case of blocking file descriptors, the same function call should be repeated immediately. In the case of non-blocking file descriptors, the same function call should be repeated when the required condition has been met.<div class="spacer">
</div>
Callers of these functions cannot rely on the value of the global <i class="arg">errno</i>. To prevent mishandling of error conditions, <b class="fname">tls_handshake</b>(), <b class="fname">tls_read</b>(), <b class="fname">tls_write</b>(), and <b class="fname">tls_close</b>() all explicitly clear <i class="arg">errno</i>.</div>
<div class="section">
<h1 id="x4558414d504c4553">EXAMPLES</h1> The following example demonstrates how to handle TLS writes on a blocking file descriptor:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
... 
while (len &gt; 0) { 
	ssize_t ret; 
 
	ret = tls_write(ctx, buf, len); 
	if (ret == TLS_WANT_POLLIN || ret == TLS_WANT_POLLOUT) 
		continue; 
	if (ret &lt; 0) 
		err(1, &quot;tls_write: %s&quot;, tls_error(ctx)); 
	buf += ret; 
	len -= ret; 
} 
...</pre>
<div class="spacer">
</div>
The following example demonstrates how to handle TLS writes on a non-blocking file descriptor using <a class="link-man" href="../html2/poll.html">poll(2)</a>:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
... 
pfd[0].fd = fd; 
pfd[0].events = POLLIN|POLLOUT; 
while (len &gt; 0) { 
	nready = poll(pfd, 1, 0); 
	if (nready == -1) 
		err(1, &quot;poll&quot;); 
	if ((pfd[0].revents &amp; (POLLERR|POLLNVAL))) 
		errx(1, &quot;bad fd %d&quot;, pfd[0].fd); 
	if ((pfd[0].revents &amp; (pfd[0].events|POLLHUP))) { 
		ssize_t ret; 
 
		ret = tls_write(ctx, buf, len); 
		if (ret == TLS_WANT_POLLIN) 
			pfd[0].events = POLLIN; 
		else if (ret == TLS_WANT_POLLOUT) 
			pfd[0].events = POLLOUT; 
		else if (ret &lt; 0) 
			err(1, &quot;tls_write: %s&quot;, tls_error(ctx)); 
		else { 
			buf += ret; 
			len -= ret; 
		} 
	} 
} 
...</pre>
</div>
<div class="section">
<h1 id="x4552524f5253">ERRORS</h1> The <b class="fname">tls_config_error</b>() and <b class="fname">tls_error</b>() functions may be used to retrieve a string containing more information about the most recent error relating to a configuration or context.</div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The <b class="name">tls</b> API first appeared in <span class="unix">OpenBSD&#160;5.6</span> as a response to the unnecessary challenges other APIs present in order to use them safely.</div>
</div>
</body>
</html>

