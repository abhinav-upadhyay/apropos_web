<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
CMSG_DATA(3)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">CMSG_DATA</b>, <b class="name">CMSG_FIRSTHDR</b>, <b class="name">CMSG_LEN</b>, <b class="name">CMSG_NXTHDR</b>, <b class="name">CMSG_SPACE</b> &#8212; <span class="desc">socket control message routines</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/socket.h</a>&gt;</b><div class="spacer">
</div>
<i class="ftype">void *</i><br/>
<b class="fname">CMSG_DATA</b>(<i class="farg" style="white-space:nowrap;">struct cmsghdr *</i>);<div class="spacer">
</div>
<i class="ftype">struct cmsghdr *</i><br/>
<b class="fname">CMSG_FIRSTHDR</b>(<i class="farg" style="white-space:nowrap;">struct msghdr *</i>);<div class="spacer">
</div>
<i class="ftype">size_t</i><br/>
<b class="fname">CMSG_LEN</b>(<i class="farg" style="white-space:nowrap;">size_t</i>);<div class="spacer">
</div>
<i class="ftype">struct cmsghdr *</i><br/>
<b class="fname">CMSG_NXTHDR</b>(<i class="farg" style="white-space:nowrap;">struct msghdr *</i>, <i class="farg" style="white-space:nowrap;">struct cmsghdr *</i>);<div class="spacer">
</div>
<i class="ftype">size_t</i><br/>
<b class="fname">CMSG_SPACE</b>(<i class="farg" style="white-space:nowrap;">size_t</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The control message API is used to construct ancillary data objects for use in control messages sent and received across sockets.<div class="spacer">
</div>
Control messages are passed around by the <a class="link-man" href="../html2/recvmsg.html">recvmsg(2)</a> and <a class="link-man" href="../html2/sendmsg.html">sendmsg(2)</a> system calls. The <span class="type">cmsghdr</span> structure, described in <a class="link-man" href="../html2/recvmsg.html">recvmsg(2)</a>, is used to specify a chain of control messages.<div class="spacer">
</div>
These routines should be used instead of directly accessing the control message header members and data buffers as they ensure that necessary alignment constraints are met.<div class="spacer">
</div>
The following routines are provided:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">CMSG_DATA</b>(<i class="farg">cmsg</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This routine accesses the data portion of the control message header <i class="farg">cmsg</i>. It ensures proper alignment constraints on the beginning of ancillary data are met.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">CMSG_FIRSTHDR</b>(<i class="farg">mhdr</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This routine accesses the first control message attached to the message <i class="farg">msg</i>. If no control messages are attached to the message, this routine returns <span class="define">NULL</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">CMSG_LEN</b>(<i class="farg">len</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This routine determines the size in bytes of a control message, which includes the control message header. <i class="farg">len</i> specifies the length of the data held by the control message. This value is what is normally stored in the <i class="farg">cmsg_len</i> of each control message. This routine accounts for any alignment constraints on the beginning of ancillary data.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">CMSG_NXTHDR</b>(<i class="farg">mhdr</i>, <i class="farg">cmsg</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This routine returns the location of the control message following <i class="farg">cmsg</i> in the message <i class="farg">mhdr</i>. If <i class="farg">cmsg</i> is the last control message in the chain, this routine returns <span class="define">NULL</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">CMSG_SPACE</b>(<i class="farg">len</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This routine determines the size in bytes needed to hold a control message and its contents of length <i class="farg">len</i>, which includes the control message header. This value is what is normally stored in <i class="farg">msg_msgcontrollen</i>. This routine accounts for any alignment constraints on the beginning of ancillary data as well as any needed to pad the next control message.</dd>
</dl>
</div>
<div class="section">
<h1 id="x4558414d504c4553">EXAMPLES</h1> The following example constructs a control message containing a file descriptor and passes it over a socket:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
struct msghdr	 msg; 
struct cmsghdr	*cmsg; 
union { 
	struct cmsghdr hdr; 
	unsigned char	 buf[CMSG_SPACE(sizeof(int))]; 
} cmsgbuf; 
 
memset(&amp;msg, 0, sizeof(msg)); 
msg.msg_control = &amp;cmsgbuf.buf; 
msg.msg_controllen = sizeof(cmsgbuf.buf); 
 
cmsg = CMSG_FIRSTHDR(&amp;msg); 
cmsg-&gt;cmsg_len = CMSG_LEN(sizeof(int)); 
cmsg-&gt;cmsg_level = SOL_SOCKET; 
cmsg-&gt;cmsg_type = SCM_RIGHTS; 
*(int *)CMSG_DATA(cmsg) = fd; 
 
if (sendmsg(s, &amp;msg, 0) == -1) 
	err(1, &quot;sendmsg&quot;);</pre>
<div class="spacer">
</div>
And an example that receives and decomposes the control message:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
struct msghdr	 msg; 
struct cmsghdr	*cmsg; 
union { 
	struct cmsghdr hdr; 
	unsigned char	 buf[CMSG_SPACE(sizeof(int))]; 
} cmsgbuf; 
 
memset(&amp;msg, 0, sizeof(msg)); 
msg.msg_control = &amp;cmsgbuf.buf; 
msg.msg_controllen = sizeof(cmsgbuf.buf); 
 
if (recvmsg(s, &amp;msg, 0) == -1) 
	err(1, &quot;recvmsg&quot;); 
if ((msg.msg_flags &amp; MSG_TRUNC) || (msg.msg_flags &amp; MSG_CTRUNC)) 
	errx(1, &quot;control message truncated&quot;); 
for (cmsg = CMSG_FIRSTHDR(&amp;msg); cmsg != NULL; 
    cmsg = CMSG_NXTHDR(&amp;msg, cmsg)) { 
	if (cmsg-&gt;cmsg_len == CMSG_LEN(sizeof(int)) &amp;&amp; 
	    cmsg-&gt;cmsg_level == SOL_SOCKET &amp;&amp; 
	    cmsg-&gt;cmsg_type == SCM_RIGHTS) { 
		fd = *(int *)CMSG_DATA(cmsg); 
		/* Do something with the descriptor. */ 
	} 
}</pre>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html2/recvmsg.html">recvmsg(2)</a>, <a class="link-man" href="../html2/sendmsg.html">sendmsg(2)</a>, <a class="link-man" href="../html2/socket.html">socket(2)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The control message API first appeared in <span class="unix">4.2BSD</span>.</div>
</div>
</body>
</html>

