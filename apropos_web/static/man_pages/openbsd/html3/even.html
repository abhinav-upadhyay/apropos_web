<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
EVENT_INIT(3)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">event_init</b>, <b class="name">event_dispatch</b>, <b class="name">event_set</b>, <b class="name">event_add</b>, <b class="name">event_del</b>, <b class="name">event_pending</b>, <b class="name">event_initialized</b>, <b class="name">evtimer_set</b>, <b class="name">evtimer_add</b>, <b class="name">evtimer_del</b>, <b class="name">evtimer_pending</b>, <b class="name">evtimer_initialized</b>, <b class="name">signal_set</b>, <b class="name">signal_add</b>, <b class="name">signal_del</b>, <b class="name">signal_pending</b>, <b class="name">signal_initialized</b>, <b class="name">event_once</b>, <b class="name">event_loop</b>, <b class="name">event_loopexit</b>, <b class="name">event_loopbreak</b>, <b class="name">event_asr_run</b>, <b class="name">event_asr_abort</b>, <b class="name">event_priority_init</b>, <b class="name">event_priority_set</b>, <b class="name">event_base_dispatch</b>, <b class="name">event_base_loop</b>, <b class="name">event_base_loopexit</b>, <b class="name">event_base_loopbreak</b>, <b class="name">event_base_set</b>, <b class="name">event_base_once</b>, <b class="name">event_base_free</b>, <b class="name">bufferevent_base_set</b>, <b class="name">bufferevent_new</b>, <b class="name">bufferevent_free</b>, <b class="name">bufferevent_write</b>, <b class="name">bufferevent_write_buffer</b>, <b class="name">bufferevent_read</b>, <b class="name">bufferevent_enable</b>, <b class="name">bufferevent_disable</b>, <b class="name">bufferevent_settimeout</b> &#8212; <span class="desc">execute a function when a specific event occurs</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/time.h</a>&gt;</b><br/>
<b class="includes">#include &lt;<a class="link-includes">event.h</a>&gt;</b><div class="spacer">
</div>
<i class="ftype">struct event_base *</i><br/>
<b class="fname">event_init</b>(<i class="farg" style="white-space:nowrap;">void</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">event_dispatch</b>(<i class="farg" style="white-space:nowrap;">void</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">event_set</b>(<i class="farg" style="white-space:nowrap;">struct event *ev</i>, <i class="farg" style="white-space:nowrap;">int fd</i>, <i class="farg" style="white-space:nowrap;">short event</i>, <i class="farg" style="white-space:nowrap;">void (*fn)(int, short, void *)</i>, <i class="farg" style="white-space:nowrap;">void *arg</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">event_add</b>(<i class="farg" style="white-space:nowrap;">struct event *ev</i>, <i class="farg" style="white-space:nowrap;">const struct timeval *tv</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">event_del</b>(<i class="farg" style="white-space:nowrap;">struct event *ev</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">event_pending</b>(<i class="farg" style="white-space:nowrap;">struct event *ev</i>, <i class="farg" style="white-space:nowrap;">short event</i>, <i class="farg" style="white-space:nowrap;">const struct timeval *tv</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">event_initialized</b>(<i class="farg" style="white-space:nowrap;">struct event *ev</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">evtimer_set</b>(<i class="farg" style="white-space:nowrap;">struct event *ev</i>, <i class="farg" style="white-space:nowrap;">void (*fn)(int, short, void *)</i>, <i class="farg" style="white-space:nowrap;">void *arg</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">evtimer_add</b>(<i class="farg" style="white-space:nowrap;">struct event *ev</i>, <i class="farg" style="white-space:nowrap;">const struct timeval *tv</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">evtimer_del</b>(<i class="farg" style="white-space:nowrap;">struct event *ev</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">evtimer_pending</b>(<i class="farg" style="white-space:nowrap;">struct event *ev</i>, <i class="farg" style="white-space:nowrap;">const struct timeval *tv</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">evtimer_initialized</b>(<i class="farg" style="white-space:nowrap;">struct event *ev</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">signal_set</b>(<i class="farg" style="white-space:nowrap;">struct event *ev</i>, <i class="farg" style="white-space:nowrap;">int signal</i>, <i class="farg" style="white-space:nowrap;">void (*fn)(int, short, void *)</i>, <i class="farg" style="white-space:nowrap;">void *arg</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">signal_add</b>(<i class="farg" style="white-space:nowrap;">struct event *ev</i>, <i class="farg" style="white-space:nowrap;">const struct timeval *tv</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">signal_del</b>(<i class="farg" style="white-space:nowrap;">struct event *ev</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">signal_pending</b>(<i class="farg" style="white-space:nowrap;">struct event *ev</i>, <i class="farg" style="white-space:nowrap;">const struct timeval *tv</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">signal_initialized</b>(<i class="farg" style="white-space:nowrap;">struct event *ev</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">event_once</b>(<i class="farg" style="white-space:nowrap;">int fd</i>, <i class="farg" style="white-space:nowrap;">short event</i>, <i class="farg" style="white-space:nowrap;">void (*fn)(int, short, void *)</i>, <i class="farg" style="white-space:nowrap;">void *arg</i>, <i class="farg" style="white-space:nowrap;">const struct timeval *tv</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">event_loop</b>(<i class="farg" style="white-space:nowrap;">int flags</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">event_loopexit</b>(<i class="farg" style="white-space:nowrap;">const struct timeval *tv</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">event_loopbreak</b>(<i class="farg" style="white-space:nowrap;">void</i>);<div class="spacer">
</div>
<i class="ftype">struct event_asr *</i><br/>
<b class="fname">event_asr_run</b>(<i class="farg" style="white-space:nowrap;">struct asr_query *aq</i>, <i class="farg" style="white-space:nowrap;">void (*fn)(struct asr_result *, void *)</i>, <i class="farg" style="white-space:nowrap;">void *arg</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">event_asr_abort</b>(<i class="farg" style="white-space:nowrap;">struct event_asr *eva</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">event_priority_init</b>(<i class="farg" style="white-space:nowrap;">int npriorities</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">event_priority_set</b>(<i class="farg" style="white-space:nowrap;">struct event *ev</i>, <i class="farg" style="white-space:nowrap;">int priority</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">event_base_dispatch</b>(<i class="farg" style="white-space:nowrap;">struct event_base *base</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">event_base_loop</b>(<i class="farg" style="white-space:nowrap;">struct event_base *base</i>, <i class="farg" style="white-space:nowrap;">int flags</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">event_base_loopexit</b>(<i class="farg" style="white-space:nowrap;">struct event_base *base</i>, <i class="farg" style="white-space:nowrap;">const struct timeval *tv</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">event_base_loopbreak</b>(<i class="farg" style="white-space:nowrap;">struct event_base *base</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">event_base_set</b>(<i class="farg" style="white-space:nowrap;">struct event_base *base</i>, <i class="farg" style="white-space:nowrap;">struct event *ev</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">event_base_once</b>(<i class="farg" style="white-space:nowrap;">struct event_base *base</i>, <i class="farg" style="white-space:nowrap;">int fd</i>, <i class="farg" style="white-space:nowrap;">short event</i>, <i class="farg" style="white-space:nowrap;">void (*fn)(int, short, void *)</i>, <i class="farg" style="white-space:nowrap;">void *arg</i>, <i class="farg" style="white-space:nowrap;">const struct timeval *tv</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">event_base_free</b>(<i class="farg" style="white-space:nowrap;">struct event_base *base</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">bufferevent_base_set</b>(<i class="farg" style="white-space:nowrap;">struct event_base *base</i>, <i class="farg" style="white-space:nowrap;">struct bufferevent *bufev</i>);<div class="spacer">
</div>
<i class="ftype">struct bufferevent *</i><br/>
<b class="fname">bufferevent_new</b>(<i class="farg" style="white-space:nowrap;">int fd</i>, <i class="farg" style="white-space:nowrap;">evbuffercb readcb</i>, <i class="farg" style="white-space:nowrap;">evbuffercb writecb</i>, <i class="farg" style="white-space:nowrap;">everrorcb errorcb</i>, <i class="farg" style="white-space:nowrap;">void *cbarg</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">bufferevent_free</b>(<i class="farg" style="white-space:nowrap;">struct bufferevent *bufev</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">bufferevent_write</b>(<i class="farg" style="white-space:nowrap;">struct bufferevent *bufev</i>, <i class="farg" style="white-space:nowrap;">const void *data</i>, <i class="farg" style="white-space:nowrap;">size_t size</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">bufferevent_write_buffer</b>(<i class="farg" style="white-space:nowrap;">struct bufferevent *bufev</i>, <i class="farg" style="white-space:nowrap;">struct evbuffer *buf</i>);<div class="spacer">
</div>
<i class="ftype">size_t</i><br/>
<b class="fname">bufferevent_read</b>(<i class="farg" style="white-space:nowrap;">struct bufferevent *bufev</i>, <i class="farg" style="white-space:nowrap;">void *data</i>, <i class="farg" style="white-space:nowrap;">size_t size</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">bufferevent_enable</b>(<i class="farg" style="white-space:nowrap;">struct bufferevent *bufev</i>, <i class="farg" style="white-space:nowrap;">short event</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">bufferevent_disable</b>(<i class="farg" style="white-space:nowrap;">struct bufferevent *bufev</i>, <i class="farg" style="white-space:nowrap;">short event</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">bufferevent_settimeout</b>(<i class="farg" style="white-space:nowrap;">struct bufferevent *bufev</i>, <i class="farg" style="white-space:nowrap;">int timeout_read</i>, <i class="farg" style="white-space:nowrap;">int timeout_write</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <b class="name">event</b> API provides a mechanism to execute a function when a specific event on a file descriptor occurs or after a given time has passed.<div class="spacer">
</div>
The <b class="name">event</b> API needs to be initialized with <b class="fname">event_init</b>() before it can be used.<div class="spacer">
</div>
In order to process events, an application needs to call <b class="fname">event_dispatch</b>(). This function only returns on error, and should replace the event core of the application program.<div class="spacer">
</div>
The function <b class="fname">event_set</b>() prepares the event structure <i class="farg">ev</i> to be used in future calls to <b class="fname">event_add</b>() and <b class="fname">event_del</b>(). The event will be prepared to call the function specified by the <i class="farg">fn</i> argument with an <i class="farg">int</i> argument indicating the file descriptor, a <i class="farg">short</i> argument indicating the type of event, and a <i class="farg">void *</i> argument given in the <i class="farg">arg</i> argument. The <i class="farg">fd</i> indicates the file descriptor that should be monitored for events. The events can be either <b class="var">EV_READ</b>, <b class="var">EV_WRITE</b>, or both, indicating that an application can read or write from the file descriptor respectively without blocking.<div class="spacer">
</div>
The function <i class="farg">fn</i> will be called with the file descriptor that triggered the event and the type of event which will be either <b class="var">EV_TIMEOUT</b>, <b class="var">EV_SIGNAL</b>, <b class="var">EV_READ</b>, or <b class="var">EV_WRITE</b>. Additionally, an event which has registered interest in more than one of the preceding events, via bitwise-OR to <b class="fname">event_set</b>(), can provide its callback function with a bitwise-OR of more than one triggered event. The additional flag <b class="var">EV_PERSIST</b> makes an <b class="fname">event_add</b>() persistent until <b class="fname">event_del</b>() has been called.<div class="spacer">
</div>
Once initialized, the <i class="farg">ev</i> structure can be used repeatedly with <b class="fname">event_add</b>() and <b class="fname">event_del</b>() and does not need to be reinitialized unless the function called and/or the argument to it are to be changed. However, when an <i class="farg">ev</i> structure has been added to libevent using <b class="fname">event_add</b>() the structure must persist until the event occurs (assuming <i class="farg">EV_PERSIST</i> is not set) or is removed using <b class="fname">event_del</b>(). You may not reuse the same <i class="farg">ev</i> structure for multiple monitored descriptors; each descriptor needs its own <i class="farg">ev</i>.<div class="spacer">
</div>
The function <b class="fname">event_add</b>() schedules the execution of the <i class="farg">ev</i> event when the event specified in <b class="fname">event_set</b>() occurs or in at least the time specified in the <i class="farg">tv</i>. If <i class="farg">tv</i> is <span class="define">NULL</span>, no timeout occurs and the function will only be called if a matching event occurs on the file descriptor. The event in the <i class="farg">ev</i> argument must be already initialized by <b class="fname">event_set</b>() and may not be used in calls to <b class="fname">event_set</b>() until it has timed out or been removed with <b class="fname">event_del</b>(). If the event in the <i class="farg">ev</i> argument already has a scheduled timeout, the old timeout will be replaced by the new one.<div class="spacer">
</div>
The function <b class="fname">event_del</b>() will cancel the event in the argument <i class="farg">ev</i>. If the event has already executed or has never been added the call will have no effect.<div class="spacer">
</div>
The functions <b class="fname">evtimer_set</b>(), <b class="fname">evtimer_add</b>(), <b class="fname">evtimer_del</b>(), <b class="fname">evtimer_initialized</b>(), and <b class="fname">evtimer_pending</b>() are abbreviations for common situations where only a timeout is required. The file descriptor passed will be -1, and the event type will be <b class="var">EV_TIMEOUT</b>.<div class="spacer">
</div>
The functions <b class="fname">signal_set</b>(), <b class="fname">signal_add</b>(), <b class="fname">signal_del</b>(), <b class="fname">signal_initialized</b>(), and <b class="fname">signal_pending</b>() are abbreviations. The event type will be a persistent <b class="var">EV_SIGNAL</b>. That means <b class="fname">signal_set</b>() adds <b class="var">EV_PERSIST</b>.<div class="spacer">
</div>
The function <b class="fname">event_once</b>() is similar to <b class="fname">event_set</b>(). However, it schedules a callback to be called exactly once and does not require the caller to prepare an <i class="farg">event</i> structure. This function supports <i class="farg">EV_TIMEOUT</i>, <i class="farg">EV_READ</i>, and <i class="farg">EV_WRITE</i>.<div class="spacer">
</div>
The <b class="fname">event_pending</b>() function can be used to check if the event specified by <i class="farg">event</i> is pending to run. If <b class="var">EV_TIMEOUT</b> was specified and <i class="farg">tv</i> is not <span class="define">NULL</span>, the expiration time of the event will be returned in <i class="farg">tv</i>.<div class="spacer">
</div>
The <b class="fname">event_initialized</b>() macro can be used to check if an event has been initialized.<div class="spacer">
</div>
The <b class="name">event_loop</b> function provides an interface for single pass execution of pending events. The flags <b class="var">EVLOOP_ONCE</b> and <b class="var">EVLOOP_NONBLOCK</b> are recognized. The <b class="name">event_loopexit</b> function exits from the event loop. The next <b class="fname">event_loop</b>() iteration after the given timer expires will complete normally (handling all queued events) then exit without blocking for events again. Subsequent invocations of <b class="fname">event_loop</b>() will proceed normally. The <b class="name">event_loopbreak</b> function exits from the event loop immediately. <b class="fname">event_loop</b>() will abort after the next event is completed; <b class="fname">event_loopbreak</b>() is typically invoked from this event's callback. This behavior is analogous to the &quot;break;&quot; statement. Subsequent invocations of <b class="fname">event_loop</b>() will proceed normally.<div class="spacer">
</div>
It is the responsibility of the caller to provide these functions with pre-allocated event structures.<div class="spacer">
</div>
The <b class="fname">event_asr_run</b>() function is used to schedule the asynchronous resolver query <i class="arg">aq</i> to run within a libevent event loop, and call the <i class="arg">fn</i> callback when the result is available. The extra <i class="arg">arg</i> parameter is passed to the callback. The user does not need to set up an event structure for using this function. It returns an opaque handle representing the running query. This handle becomes invalid before the callback is run. It can be cancelled by calling the <b class="fname">event_asr_abort</b>() function. See <a class="link-man" href="../html3/asr_run.html">asr_run(3)</a> for details on constructing asynchronous resolver queries.</div>
<div class="section">
<h1 id="x4556454e54205052494f524954494553">EVENT PRIORITIES</h1> By default <b class="name">libevent</b> schedules all active events with the same priority. However, sometimes it is desirable to process some events with a higher priority than others. For that reason, <b class="name">libevent</b> supports strict priority queues. Active events with a lower priority are always processed before events with a higher priority.<div class="spacer">
</div>
The number of different priorities can be set initially with the <b class="fname">event_priority_init</b>() function. This function should be called before the first call to <b class="fname">event_dispatch</b>(). The <b class="fname">event_priority_set</b>() function can be used to assign a priority to an event. By default, <b class="name">libevent</b> assigns the middle priority to all events unless their priority is explicitly set.</div>
<div class="section">
<h1 id="x5448524541442053414645204556454e5453">THREAD SAFE EVENTS</h1> <b class="name">Libevent</b> has experimental support for thread-safe events. When initializing the library via <b class="fname">event_init</b>(), an event base is returned. This event base can be used in conjunction with calls to <b class="fname">event_base_set</b>(), <b class="fname">event_base_dispatch</b>(), <b class="fname">event_base_loop</b>(), <b class="fname">event_base_loopexit</b>(), <b class="fname">bufferevent_base_set</b>() and <b class="fname">event_base_free</b>(). <b class="fname">event_base_set</b>() should be called after preparing an event with <b class="fname">event_set</b>(), as <b class="fname">event_set</b>() assigns the provided event to the most recently created event base. <b class="fname">bufferevent_base_set</b>() should be called after preparing a bufferevent with <b class="fname">bufferevent_new</b>(). <b class="fname">event_base_free</b>() should be used to free memory associated with the event base when it is no longer needed.</div>
<div class="section">
<h1 id="x4255464645524544204556454e5453">BUFFERED EVENTS</h1> <b class="name">libevent</b> provides an abstraction on top of the regular event callbacks. This abstraction is called a <b class="var">buffered event</b>. A buffered event provides input and output buffers that get filled and drained automatically. The user of a buffered event no longer deals directly with the IO, but instead is reading from input and writing to output buffers.<div class="spacer">
</div>
A new bufferevent is created by <b class="fname">bufferevent_new</b>(). The parameter <i class="farg">fd</i> specifies the file descriptor from which data is read and written to. This file descriptor is not allowed to be a <a class="link-man" href="../html2/pipe.html">pipe(2)</a>. The next three parameters are callbacks. The read and write callback have the following form: <i class="ftype">void</i> <b class="fname">(*cb)</b>(<i class="farg">struct bufferevent *bufev</i>, <i class="farg">void *arg</i>). The error callback has the following form: <i class="ftype">void</i> <b class="fname">(*cb)</b>(<i class="farg">struct bufferevent *bufev</i>, <i class="farg">short what</i>, <i class="farg">void *arg</i>). The argument is specified by the fourth parameter <i class="farg">cbarg</i>. A <i class="farg">bufferevent struct</i> pointer is returned on success, NULL on error. Both the read and the write callback may be NULL. The error callback has to be always provided.<div class="spacer">
</div>
Once initialized, the bufferevent structure can be used repeatedly with <b class="fname">bufferevent_enable</b>() and <b class="fname">bufferevent_disable</b>(). The flags parameter can be a combination of <b class="var">EV_READ</b> and <b class="var">EV_WRITE</b>. When read enabled the bufferevent will try to read from the file descriptor and call the read callback. The write callback is executed whenever the output buffer is drained below the write low watermark, which is <b class="var">0</b> by default.<div class="spacer">
</div>
The <b class="fname">bufferevent_write</b>() function can be used to write data to the file descriptor. The data is appended to the output buffer and written to the descriptor automatically as it becomes available for writing. <b class="fname">bufferevent_write</b>() returns 0 on success or -1 on failure. The <b class="fname">bufferevent_read</b>() function is used to read data from the input buffer, returning the amount of data read.<div class="spacer">
</div>
If multiple bases are in use, <b class="fname">bufferevent_base_set</b>() must be called before enabling the bufferevent for the first time.</div>
<div class="section">
<h1 id="x4144444954494f4e414c204e4f544553">ADDITIONAL NOTES</h1> It is possible to disable support for <b class="var">kqueue</b>, <b class="var">poll</b> or <b class="var">select</b> by setting the environment variable <b class="var">EVENT_NOKQUEUE</b>, <b class="var">EVENT_NOPOLL</b> or <b class="var">EVENT_NOSELECT</b>, respectively. By setting the environment variable <b class="var">EVENT_SHOW_METHOD</b>, <b class="name">libevent</b> displays the kernel notification method that it uses.</div>
<div class="section">
<h1 id="x52455455524e2056414c554553">RETURN VALUES</h1> Upon successful completion <b class="fname">event_add</b>() and <b class="fname">event_del</b>() return 0. Otherwise, -1 is returned and the global variable errno is set to indicate the error.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html2/kqueue.html">kqueue(2)</a>, <a class="link-man" href="../html2/poll.html">poll(2)</a>, <a class="link-man" href="../html2/select.html">select(2)</a>, <a class="link-man" href="../html3/asr_run.html">asr_run(3)</a>, <a class="link-man" href="../html3/evbuffer_new.html">evbuffer_new(3)</a>, <a class="link-man" href="../html9/timeout.html">timeout(9)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The <b class="name">event</b> API manpage is based on the <a class="link-man" href="../html9/timeout.html">timeout(9)</a> manpage by Artur Grabowski. Support for real-time signals was added by Taral.</div>
<div class="section">
<h1 id="x415554484f5253">AUTHORS</h1> The <b class="name">event</b> library was written by <span class="author">Niels Provos</span>.</div>
</div>
</body>
</html>

