<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
X509_NAME_GET_INDEX_BY_NID(3)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
X509_NAME_GET_INDEX_BY_NID(3)</td>
<td class="head-vol">
OpenSSL</td>
<td class="head-rtitle">
X509_NAME_GET_INDEX_BY_NID(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> X509_NAME_get_index_by_NID, X509_NAME_get_index_by_OBJ, X509_NAME_get_entry, X509_NAME_entry_count, X509_NAME_get_text_by_NID, X509_NAME_get_text_by_OBJ - X509_NAME lookup and enumeration functions</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
 #include &lt;openssl/x509.h&gt;<br/>
<br/>
 int X509_NAME_get_index_by_NID(X509_NAME *name,int nid,int lastpos);<br/>
 int X509_NAME_get_index_by_OBJ(X509_NAME *name,ASN1_OBJECT *obj, int lastpos);<br/>
<br/>
 int X509_NAME_entry_count(X509_NAME *name);<br/>
 X509_NAME_ENTRY *X509_NAME_get_entry(X509_NAME *name, int loc);<br/>
<br/>
 int X509_NAME_get_text_by_NID(X509_NAME *name, int nid, char *buf,int len);<br/>
 int X509_NAME_get_text_by_OBJ(X509_NAME *name, ASN1_OBJECT *obj, char *buf,int len);<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> These functions allow an  <b>X509_NAME</b> structure to be examined. The  <b>X509_NAME</b> structure is the same as the <b>Name</b> type defined in RFC2459 (and elsewhere) and used for example in certificate subject and issuer names.<div class="spacer">
</div>
<i>X509_NAME_get_index_by_NID()</i> and <i>X509_NAME_get_index_by_OBJ()</i> retrieve the next index matching  <b>nid</b> or <b>obj</b> after <b>lastpos</b>. <b>lastpos</b> should initially be set to -1. If there are no more entries -1 is returned.<div class="spacer">
</div>
<i>X509_NAME_entry_count()</i> returns the total number of entries in <b>name</b>.<div class="spacer">
</div>
<i>X509_NAME_get_entry()</i> retrieves the <b>X509_NAME_ENTRY</b> from <b>name</b> corresponding to index  <b>loc</b>. Acceptable values for <b>loc</b> run from 0 to (X509_NAME_entry_count(name) - 1). The value returned is an internal pointer which must not be freed.<div class="spacer">
</div>
<i>X509_NAME_get_text_by_NID()</i>, <i>X509_NAME_get_text_by_OBJ()</i> retrieve the &quot;text&quot; from the first entry in  <b>name</b> which matches <b>nid</b> or  <b>obj</b>, if no such entry exists -1 is returned. At most <b>len</b> bytes will be written and the text written to  <b>buf</b> will be null terminated. The length of the output string written is returned excluding the terminating null. If  <b>buf</b> is &lt;NULL&gt; then the amount of space needed in  <b>buf</b> (excluding the final null) is returned.</div>
<div class="section">
<h1>NOTES</h1>  <i>X509_NAME_get_text_by_NID()</i> and <i>X509_NAME_get_text_by_OBJ()</i> are legacy functions which have various limitations which make them of minimal use in practice. They can only find the first matching entry and will copy the contents of the field verbatim: this can be highly confusing if the target is a multicharacter string type like a BMPString or a UTF8String.<div class="spacer">
</div>
For a more general solution <i>X509_NAME_get_index_by_NID()</i> or  <i>X509_NAME_get_index_by_OBJ()</i> should be used followed by  <i>X509_NAME_get_entry()</i> on any matching indices and then the various  <b>X509_NAME_ENTRY</b> utility functions on the result.</div>
<div class="section">
<h1>EXAMPLES</h1> Process all entries:<div class="spacer">
</div>
<br/>
 int i;<br/>
 X509_NAME_ENTRY *e;<br/>
<br/>
 for (i = 0; i &lt; X509_NAME_entry_count(nm); i++) {<br/>
        e = X509_NAME_get_entry(nm, i);<br/>
        /* Do something with e */<br/>
 }<br/>
<div class="spacer">
</div>
Process all commonName entries:<div class="spacer">
</div>
<br/>
 int loc;<br/>
 X509_NAME_ENTRY *e;<br/>
<br/>
 loc = -1;<br/>
 for (;;) {<br/>
        lastpos = X509_NAME_get_index_by_NID(nm, NID_commonName, lastpos);<br/>
        if (lastpos == -1)<br/>
                break;<br/>
        e = X509_NAME_get_entry(nm, lastpos);<br/>
        /* Do something with e */<br/>
 }<br/>
</div>
<div class="section">
<h1>RETURN VALUES</h1>  <i>X509_NAME_get_index_by_NID()</i> and <i>X509_NAME_get_index_by_OBJ()</i> return the index of the next matching entry or -1 if not found.<div class="spacer">
</div>
<i>X509_NAME_entry_count()</i> returns the total number of entries.<div class="spacer">
</div>
<i>X509_NAME_get_entry()</i> returns an <b>X509_NAME</b> pointer to the requested entry or  <b>NULL</b> if the index is invalid.</div>
<div class="section">
<h1>SEE ALSO</h1>  <i>ERR_get_error</i>(3), <i>d2i_X509_NAME</i>(3)</div>
<table class="foot">
<tr>
<td class="foot-date">
2015-09-22</td>
<td class="foot-os">
OpenBSD 6.0</td>
</tr>
</table>
</div>
</body>
</html>

