<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
IMSG_INIT(3)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">imsg_init</b>, <b class="name">imsg_read</b>, <b class="name">imsg_get</b>, <b class="name">imsg_compose</b>, <b class="name">imsg_composev</b>, <b class="name">imsg_create</b>, <b class="name">imsg_add</b>, <b class="name">imsg_close</b>, <b class="name">imsg_free</b>, <b class="name">imsg_flush</b>, <b class="name">imsg_clear</b>, <b class="name">ibuf_open</b>, <b class="name">ibuf_dynamic</b>, <b class="name">ibuf_add</b>, <b class="name">ibuf_reserve</b>, <b class="name">ibuf_seek</b>, <b class="name">ibuf_size</b>, <b class="name">ibuf_left</b>, <b class="name">ibuf_close</b>, <b class="name">ibuf_write</b>, <b class="name">ibuf_free</b>, <b class="name">msgbuf_init</b>, <b class="name">msgbuf_clear</b>, <b class="name">msgbuf_write</b>, <b class="name">msgbuf_drain</b> &#8212; <span class="desc">IPC messaging functions</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/types.h</a>&gt;</b><br/>
<b class="includes">#include &lt;<a class="link-includes">sys/queue.h</a>&gt;</b><br/>
<b class="includes">#include &lt;<a class="link-includes">sys/uio.h</a>&gt;</b><br/>
<b class="includes">#include &lt;<a class="link-includes">imsg.h</a>&gt;</b><div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">imsg_init</b>(<i class="farg" style="white-space:nowrap;">struct imsgbuf *ibuf</i>, <i class="farg" style="white-space:nowrap;">int fd</i>);<div class="spacer">
</div>
<i class="ftype">ssize_t</i><br/>
<b class="fname">imsg_read</b>(<i class="farg" style="white-space:nowrap;">struct imsgbuf *ibuf</i>);<div class="spacer">
</div>
<i class="ftype">ssize_t</i><br/>
<b class="fname">imsg_get</b>(<i class="farg" style="white-space:nowrap;">struct imsgbuf *ibuf</i>, <i class="farg" style="white-space:nowrap;">struct imsg *imsg</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">imsg_compose</b>(<i class="farg" style="white-space:nowrap;">struct imsgbuf *ibuf</i>, <i class="farg" style="white-space:nowrap;">u_int32_t type</i>, <i class="farg" style="white-space:nowrap;">uint32_t peerid</i>, <i class="farg" style="white-space:nowrap;">pid_t pid</i>, <i class="farg" style="white-space:nowrap;">int fd</i>, <i class="farg" style="white-space:nowrap;">const void *data</i>, <i class="farg" style="white-space:nowrap;">u_int16_t datalen</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">imsg_composev</b>(<i class="farg" style="white-space:nowrap;">struct imsgbuf *ibuf</i>, <i class="farg" style="white-space:nowrap;">u_int32_t type</i>, <i class="farg" style="white-space:nowrap;">u_int32_t peerid</i>, <i class="farg" style="white-space:nowrap;">pid_t pid</i>, <i class="farg" style="white-space:nowrap;">int fd</i>, <i class="farg" style="white-space:nowrap;">const struct iovec *iov</i>, <i class="farg" style="white-space:nowrap;">int iovcnt</i>);<div class="spacer">
</div>
<i class="ftype">struct ibuf *</i><br/>
<b class="fname">imsg_create</b>(<i class="farg" style="white-space:nowrap;">struct imsgbuf *ibuf</i>, <i class="farg" style="white-space:nowrap;">u_int32_t type</i>, <i class="farg" style="white-space:nowrap;">u_int32_t peerid</i>, <i class="farg" style="white-space:nowrap;">pid_t pid</i>, <i class="farg" style="white-space:nowrap;">u_int16_t datalen</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">imsg_add</b>(<i class="farg" style="white-space:nowrap;">struct ibuf *buf</i>, <i class="farg" style="white-space:nowrap;">const void *data</i>, <i class="farg" style="white-space:nowrap;">u_int16_t datalen</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">imsg_close</b>(<i class="farg" style="white-space:nowrap;">struct imsgbuf *ibuf</i>, <i class="farg" style="white-space:nowrap;">struct ibuf *msg</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">imsg_free</b>(<i class="farg" style="white-space:nowrap;">struct imsg *imsg</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">imsg_flush</b>(<i class="farg" style="white-space:nowrap;">struct imsgbuf *ibuf</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">imsg_clear</b>(<i class="farg" style="white-space:nowrap;">struct imsgbuf *ibuf</i>);<div class="spacer">
</div>
<i class="ftype">struct ibuf *</i><br/>
<b class="fname">ibuf_open</b>(<i class="farg" style="white-space:nowrap;">size_t len</i>);<div class="spacer">
</div>
<i class="ftype">struct ibuf *</i><br/>
<b class="fname">ibuf_dynamic</b>(<i class="farg" style="white-space:nowrap;">size_t len</i>, <i class="farg" style="white-space:nowrap;">size_t max</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">ibuf_add</b>(<i class="farg" style="white-space:nowrap;">struct ibuf *buf</i>, <i class="farg" style="white-space:nowrap;">const void *data</i>, <i class="farg" style="white-space:nowrap;">size_t len</i>);<div class="spacer">
</div>
<i class="ftype">void *</i><br/>
<b class="fname">ibuf_reserve</b>(<i class="farg" style="white-space:nowrap;">struct ibuf *buf</i>, <i class="farg" style="white-space:nowrap;">size_t len</i>);<div class="spacer">
</div>
<i class="ftype">void *</i><br/>
<b class="fname">ibuf_seek</b>(<i class="farg" style="white-space:nowrap;">struct ibuf *buf</i>, <i class="farg" style="white-space:nowrap;">size_t pos</i>, <i class="farg" style="white-space:nowrap;">size_t len</i>);<div class="spacer">
</div>
<i class="ftype">size_t</i><br/>
<b class="fname">ibuf_size</b>(<i class="farg" style="white-space:nowrap;">struct ibuf *buf</i>);<div class="spacer">
</div>
<i class="ftype">size_t</i><br/>
<b class="fname">ibuf_left</b>(<i class="farg" style="white-space:nowrap;">struct ibuf *buf</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">ibuf_close</b>(<i class="farg" style="white-space:nowrap;">struct msgbuf *msgbuf</i>, <i class="farg" style="white-space:nowrap;">struct ibuf *buf</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">ibuf_write</b>(<i class="farg" style="white-space:nowrap;">struct msgbuf *msgbuf</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">ibuf_free</b>(<i class="farg" style="white-space:nowrap;">struct ibuf *buf</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">msgbuf_init</b>(<i class="farg" style="white-space:nowrap;">struct msgbuf *msgbuf</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">msgbuf_clear</b>(<i class="farg" style="white-space:nowrap;">struct msgbuf *msgbuf</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">msgbuf_write</b>(<i class="farg" style="white-space:nowrap;">struct msgbuf *msgbuf</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">msgbuf_drain</b>(<i class="farg" style="white-space:nowrap;">struct msgbuf *msgbuf</i>, <i class="farg" style="white-space:nowrap;">size_t n</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <b class="name">imsg</b> functions provide a simple mechanism for communication between processes using sockets. Each transmitted message is guaranteed to be presented to the receiving program whole. They are commonly used in privilege separated processes, where processes with different rights are required to cooperate.<div class="spacer">
</div>
A program using these functions should be linked with <span class="emph">-lutil</span>.<div class="spacer">
</div>
The basic <b class="name">imsg_init</b> structure is the <span class="emph">imsgbuf</span>, which wraps a file descriptor and represents one side of a channel on which messages are sent and received:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
struct imsgbuf { 
	TAILQ_HEAD(, imsg_fd)	fds; 
	struct ibuf_read	r; 
	struct msgbuf		w; 
	int			fd; 
	pid_t			pid; 
};</pre>
<div class="spacer">
</div>
<b class="fname">imsg_init</b>() is a routine which initializes <i class="farg">ibuf</i> as one side of a channel associated with <i class="farg">fd</i>. The file descriptor is used to send and receive messages, but is not closed by any of the imsg functions. An imsgbuf is initialized with the <span class="emph">w</span> member as the output buffer queue, <span class="emph">fd</span> with the file descriptor passed to <b class="fname">imsg_init</b>() and the other members for internal use only.<div class="spacer">
</div>
The <b class="fname">imsg_clear</b>() function frees any data allocated as part of an imsgbuf.<div class="spacer">
</div>
<b class="fname">imsg_create</b>(), <b class="fname">imsg_add</b>() and <b class="fname">imsg_close</b>() are generic construction routines for messages that are to be sent using an imsgbuf.<div class="spacer">
</div>
<b class="fname">imsg_create</b>() creates a new message with header specified by <i class="farg">type</i>, <i class="farg">peerid</i> and <i class="farg">pid</i>. A <i class="farg">pid</i> of zero uses the process ID returned by <a class="link-man" href="../html2/getpid.html">getpid(2)</a> when <i class="farg">ibuf</i> was initialized. In addition to this common imsg header, <i class="farg">datalen</i> bytes of space may be reserved for attaching to this imsg. This space is populated using <b class="fname">imsg_add</b>(). Additionally, the file descriptor <i class="farg">fd</i> may be passed over the socket to the other process. If <i class="farg">fd</i> is given, it is closed in the sending program after the message is sent. A value of -1 indicates no file descriptor should be passed. <b class="fname">imsg_create</b>() returns a pointer to a new message if it succeeds, NULL otherwise.<div class="spacer">
</div>
<b class="fname">imsg_add</b>() appends to <i class="farg">imsg</i> <i class="farg">len</i> bytes of ancillary data pointed to by <i class="farg">buf</i>. It returns <i class="farg">len</i> if it succeeds, -1 otherwise.<div class="spacer">
</div>
<b class="fname">imsg_close</b>() completes creation of <i class="farg">imsg</i> by adding it to <i class="farg">imsgbuf</i> output buffer.<div class="spacer">
</div>
<b class="fname">imsg_compose</b>() is a routine which is used to quickly create and queue an imsg. It takes the same parameters as the <b class="fname">imsg_create</b>(), <b class="fname">imsg_add</b>() and <b class="fname">imsg_close</b>() routines, except that only one ancillary data buffer can be provided. This routine returns 1 if it succeeds, -1 otherwise.<div class="spacer">
</div>
<b class="fname">imsg_composev</b>() is similar to <b class="fname">imsg_compose</b>(). It takes the same parameters, except that the ancillary data buffer is specified by <i class="farg">iovec</i>.<div class="spacer">
</div>
<b class="fname">imsg_flush</b>() is a function which calls <b class="fname">msgbuf_write</b>() in a loop until all imsgs in the output buffer are sent. It returns 0 if it succeeds, -1 otherwise.<div class="spacer">
</div>
The <b class="fname">imsg_read</b>() routine reads pending data with <a class="link-man" href="../html2/recvmsg.html">recvmsg(2)</a> and queues it as individual messages on <i class="farg">imsgbuf</i>. It returns the number of bytes read on success, or -1 on error. A return value of -1 from <b class="fname">imsg_read</b>() invalidates <i class="farg">imsgbuf</i>, and renders it suitable only for passing to <b class="fname">imsg_clear</b>().<div class="spacer">
</div>
<b class="fname">imsg_get</b>() fills in an individual imsg pending on <i class="farg">imsgbuf</i> into the structure pointed to by <i class="farg">imsg</i>. It returns the total size of the message, 0 if no messages are ready, or -1 for an error. Received messages are returned as a <span class="emph">struct imsg</span>, which must be freed by <b class="fname">imsg_free</b>() when no longer required. <span class="emph">struct imsg</span> has this form:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
struct imsg { 
	struct imsg_hdr	 hdr; 
	int		 fd; 
	void		*data; 
}; 
 
struct imsg_hdr { 
	u_int32_t	 type; 
	u_int16_t	 len; 
	u_int16_t	 flags; 
	u_int32_t	 peerid; 
	u_int32_t	 pid; 
};</pre>
<div class="spacer">
</div>
The header members are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
type</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
A integer identifier, typically used to express the meaning of the message.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
len</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The total length of the imsg, including the header and any ancillary data transmitted with the message (pointed to by the <span class="emph">data</span> member of the message itself).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
flags</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Flags used internally by the imsg functions: should not be used by application programs.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
peerid, pid</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
32-bit values specified on message creation and free for any use by the caller, normally used to identify the message sender.</dd>
</dl>
<div class="spacer">
</div>
In addition, <span class="emph">struct imsg</span> has the following:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
fd</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The file descriptor specified when the message was created and passed using the socket control message API, or -1 if no file descriptor was sent.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
data</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
A pointer to the ancillary data transmitted with the imsg.</dd>
</dl>
<div class="spacer">
</div>
The IMSG_HEADER_SIZE define is the size of the imsg message header, which may be subtracted from the <i class="farg">len</i> member of <span class="emph">struct imsg_hdr</span> to obtain the length of any additional data passed with the message.<div class="spacer">
</div>
MAX_IMSGSIZE is defined as the maximum size of a single imsg, currently 16384 bytes.</div>
<div class="section">
<h1 id="x42554646455253">BUFFERS</h1> The imsg API defines functions to manipulate buffers, used internally and during construction of imsgs with <b class="fname">imsg_create</b>(). A <span class="emph">struct ibuf</span> is a single buffer and a <span class="emph">struct msgbuf</span> a queue of output buffers for transmission:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
struct ibuf { 
	TAILQ_ENTRY(ibuf)	 entry; 
	u_char			*buf; 
	size_t			 size; 
	size_t			 max; 
	size_t			 wpos; 
	size_t			 rpos; 
	int			 fd; 
}; 
 
struct msgbuf { 
	TAILQ_HEAD(, ibuf)	 bufs; 
	u_int32_t		 queued; 
	int			 fd; 
};</pre>
<div class="spacer">
</div>
The <b class="fname">ibuf_open</b>() function allocates a fixed-length buffer. The buffer may not be resized and may contain a maximum of <i class="farg">len</i> bytes. On success <b class="fname">ibuf_open</b>() returns a pointer to the buffer; on failure it returns NULL.<div class="spacer">
</div>
<b class="fname">ibuf_dynamic</b>() allocates a resizeable buffer of initial length <i class="farg">len</i> and maximum size <i class="farg">max</i>. Buffers allocated with <b class="fname">ibuf_dynamic</b>() are automatically grown if necessary when data is added.<div class="spacer">
</div>
<b class="fname">ibuf_add</b>() is a routine which appends a block of data to <i class="farg">buf</i>. 0 is returned on success and -1 on failure.<div class="spacer">
</div>
<b class="fname">ibuf_reserve</b>() is used to reserve <i class="farg">len</i> bytes in <i class="farg">buf</i>. A pointer to the start of the reserved space is returned, or NULL on error.<div class="spacer">
</div>
<b class="fname">ibuf_seek</b>() is a function which returns a pointer to the part of the buffer at offset <i class="farg">pos</i> and of extent <i class="farg">len</i>. NULL is returned if the requested range is outside the part of the buffer in use.<div class="spacer">
</div>
<b class="fname">ibuf_size</b>() and <b class="fname">ibuf_left</b>() are functions which return the total bytes used and available in <i class="farg">buf</i> respectively.<div class="spacer">
</div>
<b class="fname">ibuf_close</b>() appends <i class="farg">buf</i> to <i class="farg">msgbuf</i> ready to be sent.<div class="spacer">
</div>
The <b class="fname">ibuf_write</b>() routine transmits as many pending buffers as possible from <b class="fname">msgbuf</b>() using <a class="link-man" href="../html2/writev.html">writev(2)</a>. It returns 1 if it succeeds, -1 on error and 0 when no buffers were pending or an EOF condition on the socket is detected. Temporary resource shortages are returned with errno <span class="errno">EAGAIN</span> and require the application to retry again in the future.<div class="spacer">
</div>
<b class="fname">ibuf_free</b>() frees <i class="farg">buf</i> and any associated storage. If <i class="farg">buf</i> is a NULL pointer, no action occurs.<div class="spacer">
</div>
The <b class="fname">msgbuf_init</b>() function initializes <i class="farg">msgbuf</i> so that buffers may be appended to it. The <span class="emph">fd</span> member should also be set directly before <b class="fname">msgbuf_write</b>() is used.<div class="spacer">
</div>
<b class="fname">msgbuf_clear</b>() empties a msgbuf, removing and discarding any queued buffers.<div class="spacer">
</div>
The <b class="fname">msgbuf_write</b>() routine calls <a class="link-man" href="../html2/sendmsg.html">sendmsg(2)</a> to transmit buffers queued in <i class="farg">msgbuf</i>. It returns 1 if it succeeds, -1 on error, and 0 when the queue was empty or an EOF condition on the socket is detected. Temporary resource shortages are returned with errno <span class="errno">EAGAIN</span> and require the application to retry again in the future.<div class="spacer">
</div>
<b class="fname">msgbuf_drain</b>() discards data from buffers queued in <i class="farg">msgbuf</i> until <i class="farg">n</i> bytes have been removed or <i class="farg">msgbuf</i> is empty.</div>
<div class="section">
<h1 id="x4558414d504c4553">EXAMPLES</h1> In a typical program, a channel between two processes is created with <a class="link-man" href="../html2/socketpair.html">socketpair(2)</a>, and an <span class="emph">imsgbuf</span> created around one file descriptor in each process:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
struct imsgbuf	parent_ibuf, child_ibuf; 
int		imsg_fds[2]; 
 
if (socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC, imsg_fds) == -1) 
	err(1, &quot;socketpair&quot;); 
 
switch (fork()) { 
case -1: 
	err(1, &quot;fork&quot;); 
case 0: 
	/* child */ 
	close(imsg_fds[0]); 
	imsg_init(&amp;child_ibuf, imsg_fds[1]); 
	exit(child_main(&amp;child_ibuf)); 
} 
 
/* parent */ 
close(imsg_fds[1]); 
imsg_init(&amp;parent_ibuf, imsg_fds[0]); 
exit(parent_main(&amp;parent_ibuf));</pre>
<div class="spacer">
</div>
Messages may then be composed and queued on the <span class="emph">imsgbuf</span>, for example using the <b class="fname">imsg_compose</b>() function:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
enum imsg_type { 
	IMSG_A_MESSAGE, 
	IMSG_MESSAGE2 
}; 
 
int 
child_main(struct imsgbuf *ibuf) 
{ 
	int	idata; 
	... 
	idata = 42; 
	imsg_compose(ibuf, IMSG_A_MESSAGE, 
		0, 0, -1, &amp;idata, sizeof idata); 
	... 
}</pre>
<div class="spacer">
</div>
A mechanism such as <a class="link-man" href="../html2/poll.html">poll(2)</a> or the <a class="link-man" href="../html3/event.html">event(3)</a> library is used to monitor the socket file descriptor. When the socket is ready for writing, queued messages are transmitted with <b class="fname">msgbuf_write</b>():<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
	if (msgbuf_write(&amp;ibuf-&gt;w) &lt;= 0 &amp;&amp; errno != EAGAIN) { 
		/* handle write failure */ 
	}</pre>
<div class="spacer">
</div>
And when ready for reading, messages are first received using <b class="fname">imsg_read</b>() and then extracted with <b class="fname">imsg_get</b>():<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
void 
dispatch_imsg(struct imsgbuf *ibuf) 
{ 
	struct imsg	imsg; 
	ssize_t         n, datalen; 
	int		idata; 
 
	if (((n = imsg_read(ibuf)) == -1 &amp;&amp; errno != EAGAIN) || n == 0) { 
		/* handle socket error */ 
	} 
 
	for (;;) { 
		if ((n = imsg_get(ibuf, &amp;imsg)) == -1) { 
			/* handle read error */ 
		} 
		if (n == 0)	/* no more messages */ 
			return; 
		datalen = imsg.hdr.len - IMSG_HEADER_SIZE; 
 
		switch (imsg.hdr.type) { 
		case IMSG_A_MESSAGE: 
			if (datalen &lt; sizeof idata) { 
				/* handle corrupt message */ 
			} 
			memcpy(&amp;idata, imsg.data, sizeof idata); 
			/* handle message received */ 
			break; 
		... 
		} 
 
		imsg_free(&amp;imsg); 
	} 
}</pre>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html2/socketpair.html">socketpair(2)</a>, <a class="link-man" href="../html4/unix.html">unix(4)</a></div>
</div>
</body>
</html>

