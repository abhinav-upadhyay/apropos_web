<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
SSL_CTX_SET_CLIENT_CERT_CB(3)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">SSL_CTX_set_client_cert_cb</b>, <b class="name">SSL_CTX_get_client_cert_cb</b> &#8212; <span class="desc">handle client certificate callback function</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">openssl/ssl.h</a>&gt;</b><div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">SSL_CTX_set_client_cert_cb</b>(<i class="farg">SSL_CTX *ctx</i>, <i class="farg">int (*client_cert_cb)(SSL *ssl, X509 **x509, EVP_PKEY **pkey)</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">(*SSL_CTX_get_client_cert_cb(SSL_CTX *ctx))</b>(<i class="farg">SSL *ssl</i>, <i class="farg">X509 **x509</i>, <i class="farg">EVP_PKEY **pkey</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">(*client_cert_cb)</b>(<i class="farg" style="white-space:nowrap;">SSL *ssl</i>, <i class="farg" style="white-space:nowrap;">X509 **x509</i>, <i class="farg" style="white-space:nowrap;">EVP_PKEY **pkey</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> <b class="fname">SSL_CTX_set_client_cert_cb</b>() sets the <i class="farg">client_cert_cb()</i> callback that is called when a client certificate is requested by a server and no certificate was yet set for the SSL object.<div class="spacer">
</div>
When <i class="farg">client_cert_cb</i> is <span class="define">NULL</span>, no callback function is used.<div class="spacer">
</div>
<b class="fname">SSL_CTX_get_client_cert_cb</b>() returns a pointer to the currently set callback function.<div class="spacer">
</div>
<b class="fname">client_cert_cb</b>() is the application-defined callback. If it wants to set a certificate, a certificate/private key combination must be set using the <i class="farg">x509</i> and <i class="farg">pkey</i> arguments and 1 must be returned. The certificate will be installed into <i class="farg">ssl</i>; see the <i class="link-sec"><a class="link-sec" href="#x4e4f544553">NOTES</a></i> and <i class="link-sec"><a class="link-sec" href="#x42554753">BUGS</a></i> sections. If no certificate should be set, 0 has to be returned and no certificate will be sent. A negative return value will suspend the handshake and the handshake function will return immediately. <a class="link-man" href="../html3/SSL_get_error.html">SSL_get_error(3)</a> will return <span class="define">SSL_ERROR_WANT_X509_LOOKUP</span> to indicate that the handshake was suspended. The next call to the handshake function will again lead to the call of <i class="farg">client_cert_cb()</i>. It is the job of the <i class="farg">client_cert_cb()</i> to store information about the state of the last call, if required to continue.</div>
<div class="section">
<h1 id="x4e4f544553">NOTES</h1> During a handshake (or renegotiation) a server may request a certificate from the client. A client certificate must only be sent when the server did send the request.<div class="spacer">
</div>
When a certificate has been set using the <a class="link-man" href="../html3/SSL_CTX_use_certificate.html">SSL_CTX_use_certificate(3)</a> family of functions, it will be sent to the server. The TLS standard requires that only a certificate is sent if it matches the list of acceptable CAs sent by the server. This constraint is violated by the default behavior of the OpenSSL library. Using the callback function it is possible to implement a proper selection routine or to allow a user interaction to choose the certificate to be sent.<div class="spacer">
</div>
If a callback function is defined and no certificate was yet defined for the <span class="type">SSL</span> object, the callback function will be called. If the callback function returns a certificate, the OpenSSL library will try to load the private key and certificate data into the <span class="type">SSL</span> object using the <b class="fname">SSL_use_certificate</b>() and <b class="fname">SSL_use_private_key</b>() functions. Thus it will permanently install the certificate and key for this SSL object. It will not be reset by calling <a class="link-man" href="../html3/SSL_clear.html">SSL_clear(3)</a>. If the callback returns no certificate, the OpenSSL library will not send a certificate.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html3/ssl.html">ssl(3)</a>, <a class="link-man" href="../html3/SSL_clear.html">SSL_clear(3)</a>, <a class="link-man" href="../html3/SSL_CTX_add_extra_chain_cert.html">SSL_CTX_add_extra_chain_cert(3)</a>, <a class="link-man" href="../html3/SSL_CTX_use_certificate.html">SSL_CTX_use_certificate(3)</a>, <a class="link-man" href="../html3/SSL_free.html">SSL_free(3)</a>, <a class="link-man" href="../html3/SSL_get_client_CA_list.html">SSL_get_client_CA_list(3)</a></div>
<div class="section">
<h1 id="x42554753">BUGS</h1> The <i class="farg">client_cert_cb()</i> cannot return a complete certificate chain; it can only return one client certificate. If the chain only has a length of 2, the root CA certificate may be omitted according to the TLS standard and thus a standard conforming answer can be sent to the server. For a longer chain, the client must send the complete chain (with the option to leave out the root CA certificate). This can be accomplished only by either adding the intermediate CA certificates into the trusted certificate store for the <span class="type">SSL_CTX</span> object (resulting in having to add CA certificates that otherwise maybe would not be trusted), or by adding the chain certificates using the <a class="link-man" href="../html3/SSL_CTX_add_extra_chain_cert.html">SSL_CTX_add_extra_chain_cert(3)</a> function, which is only available for the <span class="type">SSL_CTX</span> object as a whole and that therefore probably can only apply for one client certificate, making the concept of the callback function (to allow the choice from several certificates) questionable.<div class="spacer">
</div>
Once the <span class="type">SSL</span> object has been used in conjunction with the callback function, the certificate will be set for the <span class="type">SSL</span> object and will not be cleared even when <a class="link-man" href="../html3/SSL_clear.html">SSL_clear(3)</a> is called. It is therefore <span class="emph">mandatory</span> to destroy the <span class="type">SSL</span> object using <a class="link-man" href="../html3/SSL_free.html">SSL_free(3)</a> and create a new one to return to the previous state.</div>
</div>
</body>
</html>

