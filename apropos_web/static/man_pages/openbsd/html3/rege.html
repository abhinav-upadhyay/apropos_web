<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
REGEXEC(3)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">regcomp</b>, <b class="name">regexec</b>, <b class="name">regerror</b>, <b class="name">regfree</b> &#8212; <span class="desc">regular expression routines</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/types.h</a>&gt;</b><br/>
<b class="includes">#include &lt;<a class="link-includes">regex.h</a>&gt;</b><div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">regcomp</b>(<i class="farg" style="white-space:nowrap;">regex_t *preg</i>, <i class="farg" style="white-space:nowrap;">const char *pattern</i>, <i class="farg" style="white-space:nowrap;">int cflags</i>);<div class="spacer">
</div>
<br/>
<i class="ftype">int</i><br/>
<b class="fname">regexec</b>(<i class="farg" style="white-space:nowrap;">const regex_t *preg</i>, <i class="farg" style="white-space:nowrap;">const char *string</i>, <i class="farg" style="white-space:nowrap;">size_t nmatch</i>, <i class="farg" style="white-space:nowrap;">regmatch_t pmatch[]</i>, <i class="farg" style="white-space:nowrap;">int eflags</i>);<div class="spacer">
</div>
<br/>
<i class="ftype">size_t</i><br/>
<b class="fname">regerror</b>(<i class="farg" style="white-space:nowrap;">int errcode</i>, <i class="farg" style="white-space:nowrap;">const regex_t *preg</i>, <i class="farg" style="white-space:nowrap;">char *errbuf</i>, <i class="farg" style="white-space:nowrap;">size_t errbuf_size</i>);<div class="spacer">
</div>
<br/>
<i class="ftype">void</i><br/>
<b class="fname">regfree</b>(<i class="farg" style="white-space:nowrap;">regex_t *preg</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> These routines implement IEEE Std 1003.2 (&#8220;POSIX.2&#8221;) regular expressions (&#8220;REs&#8221;); see <a class="link-man" href="../html7/re_format.html">re_format(7)</a>. <b class="fname">regcomp</b>() compiles an RE written as a string into an internal form, <b class="fname">regexec</b>() matches that internal form against a string and reports results, <b class="fname">regerror</b>() transforms error codes from either into human-readable messages, and <b class="fname">regfree</b>() frees any dynamically allocated storage used by the internal form of an RE.<div class="spacer">
</div>
The header <b class="includes">&lt;<a class="link-includes">regex.h</a>&gt;</b> declares two structure types, <code class="lit">regex_t</code> and <code class="lit">regmatch_t</code>, the former for compiled internal forms and the latter for match reporting. It also declares the four functions, a type <code class="lit">regoff_t</code>, and a number of constants with names starting with <span class="define">REG_</span>.<div class="spacer">
</div>
<b class="fname">regcomp</b>() compiles the regular expression contained in the <i class="farg">pattern</i> string, subject to the flags in <i class="farg">cflags</i>, and places the results in the <code class="lit">regex_t</code> structure pointed to by <i class="farg">preg</i>. The <i class="farg">cflags</i> argument is the bitwise OR of zero or more of the following values:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">REG_EXTENDED</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
Compile modern (&#8220;extended&#8221;) REs, rather than the obsolete (&#8220;basic&#8221;) REs that are the default.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">REG_BASIC</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
This is a synonym for 0, provided as a counterpart to <span class="define">REG_EXTENDED</span> to improve readability.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">REG_NOSPEC</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
Compile with recognition of all special characters turned off. All characters are thus considered ordinary, so the RE is a literal string. This is an extension, compatible with but not specified by IEEE Std 1003.2 (&#8220;POSIX.2&#8221;), and should be used with caution in software intended to be portable to other systems. <span class="define">REG_EXTENDED</span> and <span class="define">REG_NOSPEC</span> may not be used in the same call to <b class="fname">regcomp</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">REG_ICASE</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
Compile for matching that ignores upper/lower case distinctions. See <a class="link-man" href="../html7/re_format.html">re_format(7)</a>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">REG_NOSUB</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
Compile for matching that need only report success or failure, not what was matched.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">REG_NEWLINE</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
Compile for newline-sensitive matching. By default, newline is a completely ordinary character with no special meaning in either REs or strings. With this flag, &#8216;<code class="lit">[^</code>&#8217; bracket expressions and &#8216;<code class="lit">.</code>&#8217; never match newline, a &#8216;<code class="lit">^</code>&#8217; anchor matches the null string after any newline in the string in addition to its normal function, and the &#8216;<code class="lit">$</code>&#8217; anchor matches the null string before any newline in the string in addition to its normal function.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">REG_PEND</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
The regular expression ends, not at the first NUL, but just before the character pointed to by the <i class="farg">re_endp</i> member of the structure pointed to by <i class="farg">preg</i>. The <i class="farg">re_endp</i> member is of type <i class="farg">const&#160;char&#160;*</i>. This flag permits inclusion of NULs in the RE; they are considered ordinary characters. This is an extension, compatible with but not specified by IEEE Std 1003.2 (&#8220;POSIX.2&#8221;), and should be used with caution in software intended to be portable to other systems.</dd>
</dl>
<div class="spacer">
</div>
When successful, <b class="fname">regcomp</b>() returns 0 and fills in the structure pointed to by <i class="farg">preg</i>. One member of that structure (other than <i class="farg">re_endp</i>) is publicized: <i class="farg">re_nsub</i>, of type <i class="farg">size_t</i>, contains the number of parenthesized subexpressions within the RE (except that the value of this member is undefined if the <span class="define">REG_NOSUB</span> flag was used). If <b class="fname">regcomp</b>() fails, it returns a non-zero error code; see DIAGNOSTICS.<div class="spacer">
</div>
<b class="fname">regexec</b>() matches the compiled RE pointed to by <i class="farg">preg</i> against the <i class="farg">string</i>, subject to the flags in <i class="farg">eflags</i>, and reports results using <i class="farg">nmatch</i>, <i class="farg">pmatch</i>, and the returned value. The RE must have been compiled by a previous invocation of <b class="fname">regcomp</b>(). The compiled form is not altered during execution of <b class="fname">regexec</b>(), so a single compiled RE can be used simultaneously by multiple threads.<div class="spacer">
</div>
By default, the NUL-terminated string pointed to by <i class="farg">string</i> is considered to be the text of an entire line, minus any terminating newline. The <i class="farg">eflags</i> argument is the bitwise OR of zero or more of the following values:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">REG_NOTBOL</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
The first character of the string is treated as the continuation of a line. This means that the anchors &#8216;<code class="lit">^</code>&#8217;, &#8216;<code class="lit">[[:&lt;:]]</code>&#8217;, and &#8216;<code class="lit">\&lt;</code>&#8217; do not match before it; but see <span class="define">REG_STARTEND</span> below. This does not affect the behavior of newlines under <span class="define">REG_NEWLINE</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">REG_NOTEOL</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
The NUL terminating the string does not end a line, so the &#8216;<code class="lit">$</code>&#8217; anchor does not match before it. This does not affect the behavior of newlines under <span class="define">REG_NEWLINE</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">REG_STARTEND</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
The string is considered to start at <i class="farg">string</i> <code class="none">+</code> <i class="farg">pmatch</i>[0].<i class="farg">rm_so</i> and to end before the byte located at <i class="farg">string</i> <code class="none">+</code> <i class="farg">pmatch</i>[0].<i class="farg">rm_eo</i>, regardless of the value of <i class="farg">nmatch</i>. See below for the definition of <i class="farg">pmatch</i> and <i class="farg">nmatch</i>. This is an extension, compatible with but not specified by IEEE Std 1003.2 (&#8220;POSIX.2&#8221;), and should be used with caution in software intended to be portable to other systems.<div class="spacer">
</div>
Without <span class="define">REG_NOTBOL</span>, the position <i class="farg">rm_so</i> is considered the beginning of a line, such that &#8216;<code class="lit">^</code>&#8217; matches before it, and the beginning of a word if there is a word character at this position, such that &#8216;<code class="lit">[[:&lt;:]]</code>&#8217; and &#8216;<code class="lit">\&lt;</code>&#8217; match before it.<div class="spacer">
</div>
With <span class="define">REG_NOTBOL</span>, the character at position <i class="farg">rm_so</i> is treated as the continuation of a line, and if <i class="farg">rm_so</i> is greater than 0, the preceding character is taken into consideration. If the preceding character is a newline and the regular expression was compiled with <span class="define">REG_NEWLINE</span>, &#8216;<code class="lit">^</code>&#8217; matches before the string; if the preceding character is not a word character but the string starts with a word character, &#8216;<code class="lit">[[:&lt;:]]</code>&#8217; and &#8216;<code class="lit">\&lt;</code>&#8217; match before the string.</dd>
</dl>
<div class="spacer">
</div>
See <a class="link-man" href="../html7/re_format.html">re_format(7)</a> for a discussion of what is matched in situations where an RE or a portion thereof could match any of several substrings of <i class="farg">string</i>.<div class="spacer">
</div>
Normally, <b class="fname">regexec</b>() returns 0 for success and the non-zero code <span class="define">REG_NOMATCH</span> for failure. Other non-zero error codes may be returned in exceptional situations; see DIAGNOSTICS.<div class="spacer">
</div>
If <span class="define">REG_NOSUB</span> was specified in the compilation of the RE, or if <i class="farg">nmatch</i> is 0, <b class="fname">regexec</b>() ignores the <i class="farg">pmatch</i> argument (but see below for the case where <span class="define">REG_STARTEND</span> is specified). Otherwise, <i class="farg">pmatch</i> points to an array of <i class="farg">nmatch</i> structures of type <code class="lit">regmatch_t</code>. Such a structure has at least the members <i class="farg">rm_so</i> and <i class="farg">rm_eo</i>, both of type <i class="farg">regoff_t</i> (a signed arithmetic type at least as large as an <code class="lit">off_t</code> and a <code class="lit">ssize_t</code>), containing respectively the offset of the first character of a substring and the offset of the first character after the end of the substring. Offsets are measured from the beginning of the <i class="farg">string</i> argument given to <b class="fname">regexec</b>(). An empty substring is denoted by equal offsets, both indicating the character following the empty substring.<div class="spacer">
</div>
The 0th member of the <i class="farg">pmatch</i> array is filled in to indicate what substring of <i class="farg">string</i> was matched by the entire RE. Remaining members report what substring was matched by parenthesized subexpressions within the RE; member <b class="var">i</b> reports subexpression <b class="var">i</b>, with subexpressions counted (starting at 1) by the order of their opening parentheses in the RE, left to right. Unused entries in the array&#8212;corresponding either to subexpressions that did not participate in the match at all, or to subexpressions that do not exist in the RE (that is,  <i>i</i>&#160;&gt; <i>preg</i>-&gt;<i>re_nsub</i>)&#8212;have both <i class="farg">rm_so</i> and <i class="farg">rm_eo</i> set to -1. If a subexpression participated in the match several times, the reported substring is the last one it matched. (Note, as an example in particular, that when the RE &#8220;(b*)+&#8221; matches &#8220;bbb&#8221;, the parenthesized subexpression matches each of the three &#8216;bs&#8217; and then an infinite number of empty strings following the last &#8216;b&#8217;, so the reported substring is one of the empties.)<div class="spacer">
</div>
If <span class="define">REG_STARTEND</span> is specified, <i class="farg">pmatch</i> must point to at least one <code class="lit">regmatch_t</code> (even if <i class="farg">nmatch</i> is 0 or <span class="define">REG_NOSUB</span> was specified), to hold the input offsets for <span class="define">REG_STARTEND</span>. Use for output is still entirely controlled by <i class="farg">nmatch</i>; if <i class="farg">nmatch</i> is 0 or <span class="define">REG_NOSUB</span> was specified, the value of <i class="farg">pmatch[0]</i> will not be changed by a successful <b class="fname">regexec</b>().<div class="spacer">
</div>
<b class="fname">regerror</b>() maps a non-zero <b class="var">errcode</b> from either <b class="fname">regcomp</b>() or <b class="fname">regexec</b>() to a human-readable, printable message. If <i class="farg">preg</i> is non-NULL, the error code should have arisen from use of the <code class="lit">regex_t</code> pointed to by <i class="farg">preg</i>, and if the error code came from <b class="fname">regcomp</b>(), it should have been the result from the most recent <b class="fname">regcomp</b>() using that <code class="lit">regex_t</code>. (<b class="fname">regerror</b>() may be able to supply a more detailed message using information from the <code class="lit">regex_t</code>.) <b class="fname">regerror</b>() places the NUL-terminated message into the buffer pointed to by <i class="farg">errbuf</i>, limiting the length (including the NUL) to at most <i class="farg">errbuf_size</i> bytes. If the whole message won't fit, as much of it as will fit before the terminating NUL is supplied. In any case, the returned value is the size of buffer needed to hold the whole message (including the terminating NUL). If <i class="farg">errbuf_size</i> is 0, <i class="farg">errbuf</i> is ignored but the return value is still correct.<div class="spacer">
</div>
If the <i class="farg">errcode</i> given to <b class="fname">regerror</b>() is first OR'ed with <span class="define">REG_ITOA</span>, the &#8220;message&#8221; that results is the printable name of the error code, e.g., &#8220;REG_NOMATCH&#8221;, rather than an explanation thereof. If <i class="farg">errcode</i> is <span class="define">REG_ATOI</span>, then <i class="farg">preg</i> shall be non-null and the <i class="farg">re_endp</i> member of the structure it points to must point to the printable name of an error code; in this case, the result in <i class="farg">errbuf</i> is the decimal digits of the numeric value of the error code (0 if the name is not recognized). <span class="define">REG_ITOA</span> and <span class="define">REG_ATOI</span> are intended primarily as debugging facilities; they are extensions, compatible with but not specified by IEEE Std 1003.2 (&#8220;POSIX.2&#8221;) and should be used with caution in software intended to be portable to other systems. Be warned also that they are considered experimental and changes are possible.<div class="spacer">
</div>
<b class="fname">regfree</b>() frees any dynamically allocated storage associated with the compiled RE pointed to by <i class="farg">preg</i>. The remaining <code class="lit">regex_t</code> is no longer a valid compiled RE and the effect of supplying it to <b class="fname">regexec</b>() or <b class="fname">regerror</b>() is undefined.<div class="spacer">
</div>
None of these functions references global variables except for tables of constants; all are safe for use from multiple threads if the arguments are safe.</div>
<div class="section">
<h1 id="x494d504c454d454e544154494f4e2043484f49434553">IMPLEMENTATION CHOICES</h1> There are a number of decisions that IEEE Std 1003.2 (&#8220;POSIX.2&#8221;) leaves up to the implementor, either by explicitly saying &#8220;undefined&#8221; or by virtue of them being forbidden by the RE grammar. This implementation treats them as follows.<div class="spacer">
</div>
See <a class="link-man" href="../html7/re_format.html">re_format(7)</a> for a discussion of the definition of case-independent matching.<div class="spacer">
</div>
There is no particular limit on the length of REs, except insofar as memory is limited. Memory usage is approximately linear in RE size, and largely insensitive to RE complexity, except for bounded repetitions. See <i class="link-sec"><a class="link-sec" href="#x42554753">BUGS</a></i> for one short RE using them that will run almost any system out of memory.<div class="spacer">
</div>
A backslashed character other than one specifically given a magic meaning by IEEE Std 1003.2 (&#8220;POSIX.2&#8221;) (such magic meanings occur only in obsolete REs) is taken as an ordinary character.<div class="spacer">
</div>
Any unmatched &#8216;<code class="lit">[</code>&#8217; is a <span class="define">REG_EBRACK</span> error.<div class="spacer">
</div>
Equivalence classes cannot begin or end bracket-expression ranges. The endpoint of one range cannot begin another.<div class="spacer">
</div>
RE_DUP_MAX, the limit on repetition counts in bounded repetitions, is 255.<div class="spacer">
</div>
A repetition operator (?, *, +, or bounds) cannot follow another repetition operator. A repetition operator cannot begin an expression or subexpression or follow &#8216;<code class="lit">^</code>&#8217; or &#8216;<code class="lit">|</code>&#8217;.<div class="spacer">
</div>
A &#8216;<code class="lit">|</code>&#8217; cannot appear first or last in a (sub)expression, or after another &#8216;<code class="lit">|</code>&#8217;, i.e., an operand of &#8216;<code class="lit">|</code>&#8217; cannot be an empty subexpression. An empty parenthesized subexpression, &#8216;<code class="lit">()</code>&#8217;, is legal and matches an empty (sub)string. An empty string is not a legal RE.<div class="spacer">
</div>
A &#8216;<code class="lit">{</code>&#8217; followed by a digit is considered the beginning of bounds for a bounded repetition, which must then follow the syntax for bounds. A &#8216;<code class="lit">{</code>&#8217; <span class="emph">not</span> followed by a digit is considered an ordinary character.<div class="spacer">
</div>
&#8216;<code class="lit">^</code>&#8217; and &#8216;<code class="lit">$</code>&#8217; beginning and ending subexpressions in obsolete (&#8220;basic&#8221;) REs are anchors, not ordinary characters.</div>
<div class="section">
<h1 id="x444941474e4f5354494353">DIAGNOSTICS</h1> Non-zero error codes from <b class="fname">regcomp</b>() and <b class="fname">regexec</b>() include the following:<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="errno">REG_NOMATCH</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
regexec() failed to match</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="errno">REG_BADPAT</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
invalid regular expression</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="errno">REG_ECOLLATE</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
invalid collating element</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="errno">REG_ECTYPE</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
invalid character class</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="errno">REG_EESCAPE</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
\ applied to unescapable character</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="errno">REG_ESUBREG</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
invalid backreference number</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="errno">REG_EBRACK</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
brackets [ ] not balanced</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="errno">REG_EPAREN</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
parentheses ( ) not balanced</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="errno">REG_EBRACE</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
braces { } not balanced</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="errno">REG_BADBR</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
invalid repetition count(s) in { }</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="errno">REG_ERANGE</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
invalid character range in [ ]</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="errno">REG_ESPACE</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
ran out of memory</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="errno">REG_BADRPT</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
?, *, or + operand invalid</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="errno">REG_EMPTY</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
empty (sub)expression</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="errno">REG_ASSERT</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
&#8220;can't happen&#8221; &#8212;you found a bug</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="errno">REG_INVARG</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
invalid argument, e.g., negative-length string</dd>
</dl>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html1/grep.html">grep(1)</a>, <a class="link-man" href="../html7/re_format.html">re_format(7)</a><div class="spacer">
</div>
IEEE Std 1003.2 (&#8220;POSIX.2&#8221;), sections 2.8 (Regular Expression Notation) and B.5 (C Binding for Regular Expression Matching).</div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> Predecessors to <b class="fname">regcomp</b>() and <b class="fname">regexec</b>(), <b class="fname">regcmp</b>() and <b class="fname">regex</b>(), first appeared in the Programmer's Workbench (PWB/UNIX).<div class="spacer">
</div>
The present functions were originally written by Henry Spencer and altered for inclusion in the <span class="unix">4.4BSD</span> distribution.</div>
<div class="section">
<h1 id="x42554753">BUGS</h1> This is an alpha release with known defects. Please report problems.<div class="spacer">
</div>
There is one known functionality bug. The implementation of internationalization is incomplete: the locale is always assumed to be the default one of IEEE Std 1003.2 (&#8220;POSIX.2&#8221;), and only the collating elements etc. of that locale are available.<div class="spacer">
</div>
The back-reference code is subtle and doubts linger about its correctness in complex cases.<div class="spacer">
</div>
<b class="fname">regexec</b>() performance is poor. This will improve with later releases. <i class="farg">nmatch</i> exceeding 0 is expensive; <i class="farg">nmatch</i> exceeding 1 is worse. <b class="fname">regexec</b>() is largely insensitive to RE complexity <span class="emph">except</span> that back references are massively expensive. RE length does matter; in particular, there is a strong speed bonus for keeping RE length under about 30 characters, with most special characters counting roughly double.<div class="spacer">
</div>
<b class="fname">regcomp</b>() implements bounded repetitions by macro expansion, which is costly in time and space if counts are large or bounded repetitions are nested. A RE like, say, &#8220;((((a{1,100}){1,100}){1,100}){1,100}){1,100}&#8221; will (eventually) run almost any existing machine out of swap space.<div class="spacer">
</div>
There are suspected problems with response to obscure error conditions. Notably, certain kinds of internal overflow, produced only by truly enormous REs or by multiply nested bounded repetitions, are probably not handled well.<div class="spacer">
</div>
Due to a mistake in IEEE Std 1003.2 (&#8220;POSIX.2&#8221;), things like &#8216;<code class="lit">a)b</code>&#8217; are legal REs because &#8216;<code class="lit">)</code>&#8217; is a special character only in the presence of a previous unmatched &#8216;<code class="lit">(</code>&#8217;. This can't be fixed until the spec is fixed.<div class="spacer">
</div>
The standard's definition of back references is vague. For example, does &#8220;a\(\(b\)*\2\)*d&#8221; match &#8220;abbbd&#8221;? Until the standard is clarified, behavior in such cases should not be relied on.<div class="spacer">
</div>
The implementation of word-boundary matching is a bit of a kludge, and bugs may lurk in combinations of word-boundary matching and anchoring.</div>
</div>
</body>
</html>

