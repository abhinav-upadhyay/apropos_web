<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
GETADDRINFO(3)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">getaddrinfo</b>, <b class="name">freeaddrinfo</b> &#8212; <span class="desc">host and service name to socket address structure</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/types.h</a>&gt;</b><br/>
<b class="includes">#include &lt;<a class="link-includes">sys/socket.h</a>&gt;</b><br/>
<b class="includes">#include &lt;<a class="link-includes">netdb.h</a>&gt;</b><div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">getaddrinfo</b>(<i class="farg" style="white-space:nowrap;">const char *hostname</i>, <i class="farg" style="white-space:nowrap;">const char *servname</i>, <i class="farg" style="white-space:nowrap;">const struct addrinfo *hints</i>, <i class="farg" style="white-space:nowrap;">struct addrinfo **res</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">freeaddrinfo</b>(<i class="farg" style="white-space:nowrap;">struct addrinfo *ai</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <b class="fname">getaddrinfo</b>() function is used to get a list of IP addresses and port numbers for host <i class="farg">hostname</i> and service <i class="farg">servname</i>. It is a replacement for and provides more flexibility than the <a class="link-man" href="../html3/gethostbyname.html">gethostbyname(3)</a> and <a class="link-man" href="../html3/getservbyname.html">getservbyname(3)</a> functions.<div class="spacer">
</div>
The <i class="farg">hostname</i> and <i class="farg">servname</i> arguments are either pointers to NUL-terminated strings or the null pointer. An acceptable value for <i class="farg">hostname</i> is either a valid host name or a numeric host address string consisting of a dotted decimal IPv4 address or an IPv6 address. The <i class="farg">servname</i> is either a decimal port number or a service name listed in <a class="link-man" href="../html5/services.html">services(5)</a>. At least one of <i class="farg">hostname</i> and <i class="farg">servname</i> must be non-null.<div class="spacer">
</div>
<i class="farg">hints</i> is an optional pointer to a <code class="lit">struct addrinfo</code>, as defined by <b class="includes">&lt;<a class="link-includes">netdb.h</a>&gt;</b>:<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
struct addrinfo { 
	int ai_flags;		/* input flags */ 
	int ai_family;		/* address family for socket */ 
	int ai_socktype;	/* socket type */ 
	int ai_protocol;	/* protocol for socket */ 
	socklen_t ai_addrlen;	/* length of socket-address */ 
	struct sockaddr *ai_addr; /* socket-address for socket */ 
	char *ai_canonname;	/* canonical name for service location */ 
	struct addrinfo *ai_next; /* pointer to next in list */ 
};</pre>
<div class="spacer">
</div>
This structure can be used to provide hints concerning the type of socket that the caller supports or wishes to use. The caller can supply the following structure elements in <i class="farg">hints</i>:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">ai_family</i></dt>
<dd class="list-tag" style="margin-left: 13.00ex;">
The address family that should be used. When <i class="farg">ai_family</i> is set to <span class="define">AF_UNSPEC</span>, it means the caller will accept any address family supported by the operating system.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">ai_socktype</i></dt>
<dd class="list-tag" style="margin-left: 13.00ex;">
Denotes the type of socket that is wanted: <span class="define">SOCK_STREAM</span>, <span class="define">SOCK_DGRAM</span>, or <span class="define">SOCK_RAW</span>. When <i class="farg">ai_socktype</i> is zero the caller will accept any socket type.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">ai_protocol</i></dt>
<dd class="list-tag" style="margin-left: 13.00ex;">
Indicates which transport protocol is desired, <span class="define">IPPROTO_UDP</span> or <span class="define">IPPROTO_TCP</span>. If <i class="farg">ai_protocol</i> is zero the caller will accept any protocol.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">ai_flags</i></dt>
<dd class="list-tag" style="margin-left: 13.00ex;">
<i class="farg">ai_flags</i> is formed by OR'ing the following values:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">AI_ADDRCONFIG</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
If the <span class="define">AI_ADDRCONFIG</span> bit is set, IPv4 addresses will be returned only if an IPv4 address is configured on an interface, and IPv6 addresses will be returned only if an IPv6 address is configured on an interface. Addresses on a loopback interface and link-local IPv6 addresses are not considered valid as configured addresses. This bit is only considered when determining whether a DNS query should be performed or not.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">AI_CANONNAME</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
If the <span class="define">AI_CANONNAME</span> bit is set, a successful call to <b class="fname">getaddrinfo</b>() will return a NUL-terminated string containing the canonical name of the specified host name in the <i class="farg">ai_canonname</i> element of the first <code class="lit">addrinfo</code> structure returned.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">AI_FQDN</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
If the <span class="define">AI_FQDN</span> bit is set, a successful call to <b class="fname">getaddrinfo</b>() will return a NUL-terminated string containing the fully qualified domain name of the specified host name in the <i class="farg">ai_canonname</i> element of the first <code class="lit">addrinfo</code> structure returned.<div class="spacer">
</div>
This is different from the <span class="define">AI_CANONNAME</span> bit flag that returns the canonical name registered in DNS, which may be different from the fully qualified domain name that the host name resolved to. Only one of the <span class="define">AI_FQDN</span> and <span class="define">AI_CANONNAME</span> bits can be set.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">AI_NUMERICHOST</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
If the <span class="define">AI_NUMERICHOST</span> bit is set, it indicates that <i class="farg">hostname</i> should be treated as a numeric string defining an IPv4 or IPv6 address and no name resolution should be attempted.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">AI_NUMERICSERV</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
If the <span class="define">AI_NUMERICSERV</span> bit is set, it indicates that <i class="farg">servname</i> should be treated as a numeric port string and no service name resolution should be attempted.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">AI_PASSIVE</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
If the <span class="define">AI_PASSIVE</span> bit is set it indicates that the returned socket address structure is intended for use in a call to <a class="link-man" href="../html2/bind.html">bind(2)</a>. In this case, if the <i class="farg">hostname</i> argument is the null pointer, then the IP address portion of the socket address structure will be set to <span class="define">INADDR_ANY</span> for an IPv4 address or <span class="define">IN6ADDR_ANY_INIT</span> for an IPv6 address.<div class="spacer">
</div>
If the <span class="define">AI_PASSIVE</span> bit is not set, the returned socket address structure will be ready for use in a call to <a class="link-man" href="../html2/connect.html">connect(2)</a> for a connection-oriented protocol or <a class="link-man" href="../html2/connect.html">connect(2)</a>, <a class="link-man" href="../html2/sendto.html">sendto(2)</a>, or <a class="link-man" href="../html2/sendmsg.html">sendmsg(2)</a> if a connectionless protocol was chosen. The IP address portion of the socket address structure will be set to the loopback address if <i class="farg">hostname</i> is the null pointer and <span class="define">AI_PASSIVE</span> is not set.</dd>
</dl>
</dd>
</dl>
<div class="spacer">
</div>
All other elements of the <code class="lit">addrinfo</code> structure passed via <i class="farg">hints</i> must be zero or the null pointer.<div class="spacer">
</div>
If <i class="farg">hints</i> is the null pointer, <b class="fname">getaddrinfo</b>() behaves as if the caller provided a <code class="lit">struct addrinfo</code> with <i class="farg">ai_family</i> set to <span class="define">AF_UNSPEC</span>, <i class="farg">ai_flags</i> set to <span class="define">AI_ADDRCONFIG</span>, and all other elements set to zero or <span class="define">NULL</span>.<div class="spacer">
</div>
After a successful call to <b class="fname">getaddrinfo</b>(), <i class="farg">*res</i> is a pointer to a linked list of one or more <code class="lit">addrinfo</code> structures. The list can be traversed by following the <i class="farg">ai_next</i> pointer in each <code class="lit">addrinfo</code> structure until a null pointer is encountered. The three members <i class="farg">ai_family</i>, <i class="farg">ai_socktype</i>, and <i class="farg">ai_protocol</i> in each returned <code class="lit">addrinfo</code> structure are suitable for a call to <a class="link-man" href="../html2/socket.html">socket(2)</a>. For each <code class="lit">addrinfo</code> structure in the list, the <i class="farg">ai_addr</i> member points to a filled-in socket address structure of length <i class="farg">ai_addrlen</i>.<div class="spacer">
</div>
This implementation of <b class="fname">getaddrinfo</b>() allows numeric IPv6 address notation with scope identifier, as documented in RFC 4007. By appending the percent character and scope identifier to addresses, one can fill the <code class="lit">sin6_scope_id</code> field for addresses. This would make management of scoped addresses easier and allows cut-and-paste input of scoped addresses.<div class="spacer">
</div>
At this moment the code supports only link-local addresses with the format. The scope identifier is hardcoded to the name of the hardware interface associated with the link (such as <code class="lit">ne0</code>). An example is &#8220;<code class="lit">fe80::1%ne0</code>&#8221;, which means &#8220;<code class="lit">fe80::1</code> on the link associated with the <code class="lit">ne0</code> interface&#8221;.<div class="spacer">
</div>
The current implementation assumes a one-to-one relationship between the interface and link, which is not necessarily true from the specification.<div class="spacer">
</div>
All of the information returned by <b class="fname">getaddrinfo</b>() is dynamically allocated: the <code class="lit">addrinfo</code> structures themselves as well as the socket address structures and the canonical host name strings included in the <code class="lit">addrinfo</code> structures.<div class="spacer">
</div>
Memory allocated for the dynamically allocated structures created by a successful call to <b class="fname">getaddrinfo</b>() is released by the <b class="fname">freeaddrinfo</b>() function. The <i class="farg">ai</i> pointer should be an <code class="lit">addrinfo</code> structure created by a call to <b class="fname">getaddrinfo</b>().</div>
<div class="section">
<h1 id="x52455455524e2056414c554553">RETURN VALUES</h1> <b class="fname">getaddrinfo</b>() returns zero on success or one of the error codes listed in <a class="link-man" href="../html3/gai_strerror.html">gai_strerror(3)</a> if an error occurs. If an error occurs, no memory is allocated by <b class="fname">getaddrinfo</b>(), therefore it is not necessary to release the <code class="lit">addrinfo</code> structure(s).</div>
<div class="section">
<h1 id="x4558414d504c4553">EXAMPLES</h1> The following code tries to connect to &#8220;<code class="lit">www.kame.net</code>&#8221; service &#8220;<code class="lit">www</code>&#8221; via a stream socket. It loops through all the addresses available, regardless of address family. If the destination resolves to an IPv4 address, it will use an <span class="define">AF_INET</span> socket. Similarly, if it resolves to IPv6, an <span class="define">AF_INET6</span> socket is used. Observe that there is no hardcoded reference to a particular address family. The code works even if <b class="fname">getaddrinfo</b>() returns addresses that are not IPv4/v6.<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
struct addrinfo hints, *res, *res0; 
int error; 
int save_errno; 
int s; 
const char *cause = NULL; 
 
memset(&amp;hints, 0, sizeof(hints)); 
hints.ai_family = AF_UNSPEC; 
hints.ai_socktype = SOCK_STREAM; 
error = getaddrinfo(&quot;www.kame.net&quot;, &quot;www&quot;, &amp;hints, &amp;res0); 
if (error) 
	errx(1, &quot;%s&quot;, gai_strerror(error)); 
s = -1; 
for (res = res0; res; res = res-&gt;ai_next) { 
	s = socket(res-&gt;ai_family, res-&gt;ai_socktype, 
	    res-&gt;ai_protocol); 
	if (s == -1) { 
		cause = &quot;socket&quot;; 
		continue; 
	} 
 
	if (connect(s, res-&gt;ai_addr, res-&gt;ai_addrlen) == -1) { 
		cause = &quot;connect&quot;; 
		save_errno = errno; 
		close(s); 
		errno = save_errno; 
		s = -1; 
		continue; 
	} 
 
	break;	/* okay we got one */ 
} 
if (s == -1) 
	err(1, &quot;%s&quot;, cause); 
freeaddrinfo(res0);</pre>
<div class="spacer">
</div>
The following example tries to open a wildcard listening socket onto service &#8220;<code class="lit">www</code>&#8221;, for all the address families available.<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
struct addrinfo hints, *res, *res0; 
int error; 
int save_errno; 
int s[MAXSOCK]; 
int nsock; 
const char *cause = NULL; 
 
memset(&amp;hints, 0, sizeof(hints)); 
hints.ai_family = AF_UNSPEC; 
hints.ai_socktype = SOCK_STREAM; 
hints.ai_flags = AI_PASSIVE; 
error = getaddrinfo(NULL, &quot;www&quot;, &amp;hints, &amp;res0); 
if (error) 
	errx(1, &quot;%s&quot;, gai_strerror(error)); 
nsock = 0; 
for (res = res0; res &amp;&amp; nsock &lt; MAXSOCK; res = res-&gt;ai_next) { 
	s[nsock] = socket(res-&gt;ai_family, res-&gt;ai_socktype, 
	    res-&gt;ai_protocol); 
	if (s[nsock] == -1) { 
		cause = &quot;socket&quot;; 
		continue; 
	} 
 
	if (bind(s[nsock], res-&gt;ai_addr, res-&gt;ai_addrlen) == -1) { 
		cause = &quot;bind&quot;; 
		save_errno = errno; 
		close(s[nsock]); 
		errno = save_errno; 
		continue; 
	} 
	(void) listen(s[nsock], 5); 
 
	nsock++; 
} 
if (nsock == 0) 
	err(1, &quot;%s&quot;, cause); 
freeaddrinfo(res0);</pre>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html2/bind.html">bind(2)</a>, <a class="link-man" href="../html2/connect.html">connect(2)</a>, <a class="link-man" href="../html2/send.html">send(2)</a>, <a class="link-man" href="../html2/socket.html">socket(2)</a>, <a class="link-man" href="../html3/gai_strerror.html">gai_strerror(3)</a>, <a class="link-man" href="../html3/gethostbyname.html">gethostbyname(3)</a>, <a class="link-man" href="../html3/getnameinfo.html">getnameinfo(3)</a>, <a class="link-man" href="../html3/getservbyname.html">getservbyname(3)</a>, <a class="link-man" href="../html3/resolver.html">resolver(3)</a>, <a class="link-man" href="../html5/hosts.html">hosts(5)</a>, <a class="link-man" href="../html5/resolv.conf.html">resolv.conf(5)</a>, <a class="link-man" href="../html5/services.html">services(5)</a>, <a class="link-man" href="../html7/hostname.html">hostname(7)</a><div class="spacer">
</div>
<span class="ref"><span class="ref-auth">Craig Metz</span>, <span class="ref-title">Protocol Independence Using the Sockets API</span>, <i class="ref-book">Proceedings of the Freenix Track: 2000 USENIX Annual Technical Conference</i>, <span class="ref-date">June 2000</span>.</span></div>
<div class="section">
<h1 id="x5354414e4441524453">STANDARDS</h1> The <b class="fname">getaddrinfo</b>() function is defined by the IEEE Std 1003.1g-2000 (&#8220;POSIX.1g&#8221;) draft specification and documented in RFC 3493.<div class="spacer">
</div>
The <span class="define">AI_FQDN</span> flag bit first appeared in Windows 7.<div class="spacer">
</div>
<span class="ref"><span class="ref-auth">R. Gilligan</span>, <span class="ref-auth">S. Thomson</span>, <span class="ref-auth">J. Bound</span>, <span class="ref-auth">J. McCann</span>, and <span class="ref-auth">W. Stevens</span>, <span class="ref-title">Basic Socket Interface Extensions for IPv6</span>, <span class="ref-rep">RFC 3493</span>, <span class="ref-date">February 2003</span>.</span><div class="spacer">
</div>
<span class="ref"><span class="ref-auth">S. Deering</span>, <span class="ref-auth">B. Haberman</span>, <span class="ref-auth">T. Jinmei</span>, <span class="ref-auth">E. Nordmark</span>, and <span class="ref-auth">B. Zill</span>, <span class="ref-title">IPv6 Scoped Address Architecture</span>, <span class="ref-rep">RFC 4007</span>, <span class="ref-date">March 2005</span>.</span></div>
</div>
</body>
</html>

