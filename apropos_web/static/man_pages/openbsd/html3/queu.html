<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
SLIST_INIT(3)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">SLIST_ENTRY</b>, <b class="name">SLIST_HEAD</b>, <b class="name">SLIST_HEAD_INITIALIZER</b>, <b class="name">SLIST_FIRST</b>, <b class="name">SLIST_NEXT</b>, <b class="name">SLIST_EMPTY</b>, <b class="name">SLIST_FOREACH</b>, <b class="name">SLIST_FOREACH_SAFE</b>, <b class="name">SLIST_INIT</b>, <b class="name">SLIST_INSERT_AFTER</b>, <b class="name">SLIST_INSERT_HEAD</b>, <b class="name">SLIST_REMOVE_AFTER</b>, <b class="name">SLIST_REMOVE_HEAD</b>, <b class="name">SLIST_REMOVE</b>, <b class="name">LIST_ENTRY</b>, <b class="name">LIST_HEAD</b>, <b class="name">LIST_HEAD_INITIALIZER</b>, <b class="name">LIST_FIRST</b>, <b class="name">LIST_NEXT</b>, <b class="name">LIST_EMPTY</b>, <b class="name">LIST_FOREACH</b>, <b class="name">LIST_FOREACH_SAFE</b>, <b class="name">LIST_INIT</b>, <b class="name">LIST_INSERT_AFTER</b>, <b class="name">LIST_INSERT_BEFORE</b>, <b class="name">LIST_INSERT_HEAD</b>, <b class="name">LIST_REMOVE</b>, <b class="name">LIST_REPLACE</b>, <b class="name">SIMPLEQ_ENTRY</b>, <b class="name">SIMPLEQ_HEAD</b>, <b class="name">SIMPLEQ_HEAD_INITIALIZER</b>, <b class="name">SIMPLEQ_FIRST</b>, <b class="name">SIMPLEQ_NEXT</b>, <b class="name">SIMPLEQ_EMPTY</b>, <b class="name">SIMPLEQ_FOREACH</b>, <b class="name">SIMPLEQ_FOREACH_SAFE</b>, <b class="name">SIMPLEQ_INIT</b>, <b class="name">SIMPLEQ_INSERT_AFTER</b>, <b class="name">SIMPLEQ_INSERT_HEAD</b>, <b class="name">SIMPLEQ_INSERT_TAIL</b>, <b class="name">SIMPLEQ_REMOVE_AFTER</b>, <b class="name">SIMPLEQ_REMOVE_HEAD</b>, <b class="name">SIMPLEQ_CONCAT</b>, <b class="name">TAILQ_ENTRY</b>, <b class="name">TAILQ_HEAD</b>, <b class="name">TAILQ_HEAD_INITIALIZER</b>, <b class="name">TAILQ_FIRST</b>, <b class="name">TAILQ_NEXT</b>, <b class="name">TAILQ_LAST</b>, <b class="name">TAILQ_PREV</b>, <b class="name">TAILQ_EMPTY</b>, <b class="name">TAILQ_FOREACH</b>, <b class="name">TAILQ_FOREACH_SAFE</b>, <b class="name">TAILQ_FOREACH_REVERSE</b>, <b class="name">TAILQ_FOREACH_REVERSE_SAFE</b>, <b class="name">TAILQ_INIT</b>, <b class="name">TAILQ_INSERT_AFTER</b>, <b class="name">TAILQ_INSERT_BEFORE</b>, <b class="name">TAILQ_INSERT_HEAD</b>, <b class="name">TAILQ_INSERT_TAIL</b>, <b class="name">TAILQ_REMOVE</b>, <b class="name">TAILQ_REPLACE</b>, <b class="name">TAILQ_CONCAT</b> &#8212; <span class="desc">implementations of singly-linked lists, doubly-linked lists, simple queues, and tail queues</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/queue.h</a>&gt;</b><div class="spacer">
</div>
<br/>
<b class="fname">SLIST_ENTRY</b>(<i class="farg" style="white-space:nowrap;">TYPE</i>);<div class="spacer">
</div>
<b class="fname">SLIST_HEAD</b>(<i class="farg" style="white-space:nowrap;">HEADNAME</i>, <i class="farg" style="white-space:nowrap;">TYPE</i>);<div class="spacer">
</div>
<b class="fname">SLIST_HEAD_INITIALIZER</b>(<i class="farg" style="white-space:nowrap;">SLIST_HEAD head</i>);<div class="spacer">
</div>
<i class="ftype">struct TYPE *</i><br/>
<b class="fname">SLIST_FIRST</b>(<i class="farg" style="white-space:nowrap;">SLIST_HEAD *head</i>);<div class="spacer">
</div>
<i class="ftype">struct TYPE *</i><br/>
<b class="fname">SLIST_NEXT</b>(<i class="farg" style="white-space:nowrap;">struct TYPE *listelm</i>, <i class="farg" style="white-space:nowrap;">FIELDNAME</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">SLIST_EMPTY</b>(<i class="farg" style="white-space:nowrap;">SLIST_HEAD *head</i>);<div class="spacer">
</div>
<b class="fname">SLIST_FOREACH</b>(<i class="farg" style="white-space:nowrap;">VARNAME</i>, <i class="farg" style="white-space:nowrap;">SLIST_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">FIELDNAME</i>);<div class="spacer">
</div>
<b class="fname">SLIST_FOREACH_SAFE</b>(<i class="farg" style="white-space:nowrap;">VARNAME</i>, <i class="farg" style="white-space:nowrap;">SLIST_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">FIELDNAME</i>, <i class="farg" style="white-space:nowrap;">TEMP_VARNAME</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">SLIST_INIT</b>(<i class="farg" style="white-space:nowrap;">SLIST_HEAD *head</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">SLIST_INSERT_AFTER</b>(<i class="farg" style="white-space:nowrap;">struct TYPE *listelm</i>, <i class="farg" style="white-space:nowrap;">struct TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">FIELDNAME</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">SLIST_INSERT_HEAD</b>(<i class="farg" style="white-space:nowrap;">SLIST_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">struct TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">FIELDNAME</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">SLIST_REMOVE_AFTER</b>(<i class="farg" style="white-space:nowrap;">struct TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">FIELDNAME</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">SLIST_REMOVE_HEAD</b>(<i class="farg" style="white-space:nowrap;">SLIST_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">FIELDNAME</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">SLIST_REMOVE</b>(<i class="farg" style="white-space:nowrap;">SLIST_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">struct TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">TYPE</i>, <i class="farg" style="white-space:nowrap;">FIELDNAME</i>);<div class="spacer">
</div>
<br/>
<b class="fname">LIST_ENTRY</b>(<i class="farg" style="white-space:nowrap;">TYPE</i>);<div class="spacer">
</div>
<b class="fname">LIST_HEAD</b>(<i class="farg" style="white-space:nowrap;">HEADNAME</i>, <i class="farg" style="white-space:nowrap;">TYPE</i>);<div class="spacer">
</div>
<b class="fname">LIST_HEAD_INITIALIZER</b>(<i class="farg" style="white-space:nowrap;">LIST_HEAD head</i>);<div class="spacer">
</div>
<i class="ftype">struct TYPE *</i><br/>
<b class="fname">LIST_FIRST</b>(<i class="farg" style="white-space:nowrap;">LIST_HEAD *head</i>);<div class="spacer">
</div>
<i class="ftype">struct TYPE *</i><br/>
<b class="fname">LIST_NEXT</b>(<i class="farg" style="white-space:nowrap;">struct TYPE *listelm</i>, <i class="farg" style="white-space:nowrap;">FIELDNAME</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">LIST_EMPTY</b>(<i class="farg" style="white-space:nowrap;">LIST_HEAD *head</i>);<div class="spacer">
</div>
<b class="fname">LIST_FOREACH</b>(<i class="farg" style="white-space:nowrap;">VARNAME</i>, <i class="farg" style="white-space:nowrap;">LIST_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">FIELDNAME</i>);<div class="spacer">
</div>
<b class="fname">LIST_FOREACH_SAFE</b>(<i class="farg" style="white-space:nowrap;">VARNAME</i>, <i class="farg" style="white-space:nowrap;">LIST_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">FIELDNAME</i>, <i class="farg" style="white-space:nowrap;">TEMP_VARNAME</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">LIST_INIT</b>(<i class="farg" style="white-space:nowrap;">LIST_HEAD *head</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">LIST_INSERT_AFTER</b>(<i class="farg" style="white-space:nowrap;">struct TYPE *listelm</i>, <i class="farg" style="white-space:nowrap;">struct TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">FIELDNAME</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">LIST_INSERT_BEFORE</b>(<i class="farg" style="white-space:nowrap;">struct TYPE *listelm</i>, <i class="farg" style="white-space:nowrap;">struct TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">FIELDNAME</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">LIST_INSERT_HEAD</b>(<i class="farg" style="white-space:nowrap;">LIST_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">struct TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">FIELDNAME</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">LIST_REMOVE</b>(<i class="farg" style="white-space:nowrap;">struct TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">FIELDNAME</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">LIST_REPLACE</b>(<i class="farg" style="white-space:nowrap;">struct TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">struct TYPE *elm2</i>, <i class="farg" style="white-space:nowrap;">FIELDNAME</i>);<div class="spacer">
</div>
<br/>
<b class="fname">SIMPLEQ_ENTRY</b>(<i class="farg" style="white-space:nowrap;">TYPE</i>);<div class="spacer">
</div>
<b class="fname">SIMPLEQ_HEAD</b>(<i class="farg" style="white-space:nowrap;">HEADNAME</i>, <i class="farg" style="white-space:nowrap;">TYPE</i>);<div class="spacer">
</div>
<b class="fname">SIMPLEQ_HEAD_INITIALIZER</b>(<i class="farg" style="white-space:nowrap;">SIMPLEQ_HEAD head</i>);<div class="spacer">
</div>
<i class="ftype">struct TYPE *</i><br/>
<b class="fname">SIMPLEQ_FIRST</b>(<i class="farg" style="white-space:nowrap;">SIMPLEQ_HEAD *head</i>);<div class="spacer">
</div>
<i class="ftype">struct TYPE *</i><br/>
<b class="fname">SIMPLEQ_NEXT</b>(<i class="farg" style="white-space:nowrap;">struct TYPE *listelm</i>, <i class="farg" style="white-space:nowrap;">FIELDNAME</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">SIMPLEQ_EMPTY</b>(<i class="farg" style="white-space:nowrap;">SIMPLEQ_HEAD *head</i>);<div class="spacer">
</div>
<b class="fname">SIMPLEQ_FOREACH</b>(<i class="farg" style="white-space:nowrap;">VARNAME</i>, <i class="farg" style="white-space:nowrap;">SIMPLEQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">FIELDNAME</i>);<div class="spacer">
</div>
<b class="fname">SIMPLEQ_FOREACH_SAFE</b>(<i class="farg" style="white-space:nowrap;">VARNAME</i>, <i class="farg" style="white-space:nowrap;">SIMPLEQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">FIELDNAME</i>, <i class="farg" style="white-space:nowrap;">TEMP_VARNAME</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">SIMPLEQ_INIT</b>(<i class="farg" style="white-space:nowrap;">SIMPLEQ_HEAD *head</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">SIMPLEQ_INSERT_AFTER</b>(<i class="farg" style="white-space:nowrap;">SIMPLEQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">struct TYPE *listelm</i>, <i class="farg" style="white-space:nowrap;">struct TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">FIELDNAME</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">SIMPLEQ_INSERT_HEAD</b>(<i class="farg" style="white-space:nowrap;">SIMPLEQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">struct TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">FIELDNAME</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">SIMPLEQ_INSERT_TAIL</b>(<i class="farg" style="white-space:nowrap;">SIMPLEQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">struct TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">FIELDNAME</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">SIMPLEQ_REMOVE_AFTER</b>(<i class="farg" style="white-space:nowrap;">SIMPLEQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">struct TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">FIELDNAME</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">SIMPLEQ_REMOVE_HEAD</b>(<i class="farg" style="white-space:nowrap;">SIMPLEQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">FIELDNAME</i>);<div class="spacer">
</div>
<b class="fname">SIMPLEQ_CONCAT</b>(<i class="farg" style="white-space:nowrap;">SIMPLEQ_HEAD *head1</i>, <i class="farg" style="white-space:nowrap;">SIMPLEQ_HEAD *head2</i>);<div class="spacer">
</div>
<br/>
<b class="fname">TAILQ_ENTRY</b>(<i class="farg" style="white-space:nowrap;">TYPE</i>);<div class="spacer">
</div>
<b class="fname">TAILQ_HEAD</b>(<i class="farg" style="white-space:nowrap;">HEADNAME</i>, <i class="farg" style="white-space:nowrap;">TYPE</i>);<div class="spacer">
</div>
<b class="fname">TAILQ_HEAD_INITIALIZER</b>(<i class="farg" style="white-space:nowrap;">TAILQ_HEAD head</i>);<div class="spacer">
</div>
<i class="ftype">struct TYPE *</i><br/>
<b class="fname">TAILQ_FIRST</b>(<i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head</i>);<div class="spacer">
</div>
<i class="ftype">struct TYPE *</i><br/>
<b class="fname">TAILQ_NEXT</b>(<i class="farg" style="white-space:nowrap;">struct TYPE *listelm</i>, <i class="farg" style="white-space:nowrap;">FIELDNAME</i>);<div class="spacer">
</div>
<i class="ftype">struct TYPE *</i><br/>
<b class="fname">TAILQ_LAST</b>(<i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">HEADNAME</i>);<div class="spacer">
</div>
<i class="ftype">struct TYPE *</i><br/>
<b class="fname">TAILQ_PREV</b>(<i class="farg" style="white-space:nowrap;">struct TYPE *listelm</i>, <i class="farg" style="white-space:nowrap;">HEADNAME</i>, <i class="farg" style="white-space:nowrap;">FIELDNAME</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">TAILQ_EMPTY</b>(<i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head</i>);<div class="spacer">
</div>
<b class="fname">TAILQ_FOREACH</b>(<i class="farg" style="white-space:nowrap;">VARNAME</i>, <i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">FIELDNAME</i>);<div class="spacer">
</div>
<b class="fname">TAILQ_FOREACH_SAFE</b>(<i class="farg" style="white-space:nowrap;">VARNAME</i>, <i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">FIELDNAME</i>, <i class="farg" style="white-space:nowrap;">TEMP_VARNAME</i>);<div class="spacer">
</div>
<b class="fname">TAILQ_FOREACH_REVERSE</b>(<i class="farg" style="white-space:nowrap;">VARNAME</i>, <i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">HEADNAME</i>, <i class="farg" style="white-space:nowrap;">FIELDNAME</i>);<div class="spacer">
</div>
<b class="fname">TAILQ_FOREACH_REVERSE_SAFE</b>(<i class="farg" style="white-space:nowrap;">VARNAME</i>, <i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">HEADNAME</i>, <i class="farg" style="white-space:nowrap;">FIELDNAME</i>, <i class="farg" style="white-space:nowrap;">TEMP_VARNAME</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">TAILQ_INIT</b>(<i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">TAILQ_INSERT_AFTER</b>(<i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">struct TYPE *listelm</i>, <i class="farg" style="white-space:nowrap;">struct TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">FIELDNAME</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">TAILQ_INSERT_BEFORE</b>(<i class="farg" style="white-space:nowrap;">struct TYPE *listelm</i>, <i class="farg" style="white-space:nowrap;">struct TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">FIELDNAME</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">TAILQ_INSERT_HEAD</b>(<i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">struct TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">FIELDNAME</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">TAILQ_INSERT_TAIL</b>(<i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">struct TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">FIELDNAME</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">TAILQ_REMOVE</b>(<i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">struct TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">FIELDNAME</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">TAILQ_REPLACE</b>(<i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">struct TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">struct TYPE *elm2</i>, <i class="farg" style="white-space:nowrap;">FIELDNAME</i>);<div class="spacer">
</div>
<b class="fname">TAILQ_CONCAT</b>(<i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head1</i>, <i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head2</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> These macros define and operate on four types of data structures: singly-linked lists, simple queues, lists, and tail queues. All four structures support the following functionality:<div class="spacer">
</div>
<ol style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-enum">
<li class="list-enum" style="margin-top: 0.00em;">
Insertion of a new entry at the head of the list.</li>
<li class="list-enum" style="margin-top: 0.00em;">
Insertion of a new entry after any element in the list.</li>
<li class="list-enum" style="margin-top: 0.00em;">
Removal of an entry from the head of the list.</li>
<li class="list-enum" style="margin-top: 0.00em;">
Forward traversal through the list.</li>
</ol>
<div class="spacer">
</div>
Singly-linked lists are the simplest of the four data structures and support only the above functionality. Singly-linked lists are ideal for applications with large datasets and few or no removals, or for implementing a LIFO queue.<div class="spacer">
</div>
Simple queues add the following functionality:<div class="spacer">
</div>
<ol style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-enum">
<li class="list-enum" style="margin-top: 0.00em;">
Entries can be added at the end of a list.</li>
</ol>
<div class="spacer">
</div>
However:<div class="spacer">
</div>
<ol style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-enum">
<li class="list-enum" style="margin-top: 0.00em;">
All list insertions must specify the head of the list.</li>
<li class="list-enum" style="margin-top: 0.00em;">
Each head entry requires two pointers rather than one.</li>
<li class="list-enum" style="margin-top: 0.00em;">
Code size is about 15% greater and operations run about 20% slower than singly-linked lists.</li>
</ol>
<div class="spacer">
</div>
Simple queues are ideal for applications with large datasets and few or no removals, or for implementing a FIFO queue.<div class="spacer">
</div>
All doubly linked types of data structures (lists and tail queues) additionally allow:<div class="spacer">
</div>
<ol style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-enum">
<li class="list-enum" style="margin-top: 0.00em;">
Insertion of a new entry before any element in the list.</li>
<li class="list-enum" style="margin-top: 0.00em;">
Removal of any entry in the list.</li>
</ol>
<div class="spacer">
</div>
However:<div class="spacer">
</div>
<ol style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-enum">
<li class="list-enum" style="margin-top: 0.00em;">
Each element requires two pointers rather than one.</li>
<li class="list-enum" style="margin-top: 0.00em;">
Code size and execution time of operations (except for removal) is about twice that of the singly-linked data-structures.</li>
</ol>
<div class="spacer">
</div>
Lists are the simplest of the doubly linked data structures and support only the above functionality over singly-linked lists.<div class="spacer">
</div>
Tail queues add the following functionality:<div class="spacer">
</div>
<ol style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-enum">
<li class="list-enum" style="margin-top: 0.00em;">
Entries can be added at the end of a list.</li>
<li class="list-enum" style="margin-top: 0.00em;">
They may be traversed backwards, at a cost.</li>
</ol>
<div class="spacer">
</div>
However:<div class="spacer">
</div>
<ol style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-enum">
<li class="list-enum" style="margin-top: 0.00em;">
All list insertions and removals must specify the head of the list.</li>
<li class="list-enum" style="margin-top: 0.00em;">
Each head entry requires two pointers rather than one.</li>
<li class="list-enum" style="margin-top: 0.00em;">
Code size is about 15% greater and operations run about 20% slower than singly-linked lists.</li>
</ol>
<div class="spacer">
</div>
An additional type of data structure, circular queues, violated the C language aliasing rules and were miscompiled as a result. All code using them should be converted to another structure; tail queues are usually the easiest to convert to.<div class="spacer">
</div>
In the macro definitions, <i class="farg">TYPE</i> is the name tag of a user defined structure that must contain a field of type <code class="lit">SLIST_ENTRY</code>, <code class="lit">LIST_ENTRY</code>, <code class="lit">SIMPLEQ_ENTRY</code>, or <code class="lit">TAILQ_ENTRY</code>, named <i class="farg">FIELDNAME</i>. The argument <i class="farg">HEADNAME</i> is the name tag of a user defined structure that must be declared using the macros <b class="fname">SLIST_HEAD</b>(), <b class="fname">LIST_HEAD</b>(), <b class="fname">SIMPLEQ_HEAD</b>(), or <b class="fname">TAILQ_HEAD</b>(). See the examples below for further explanation of how these macros are used.</div>
<div class="section">
<h1 id="x53494e474c591e4c494e4b4544204c49535453">SINGLY-LINKED LISTS</h1> A singly-linked list is headed by a structure defined by the <b class="fname">SLIST_HEAD</b>() macro. This structure contains a single pointer to the first element on the list. The elements are singly linked for minimum space and pointer manipulation overhead at the expense of O(n) removal for arbitrary elements. New elements can be added to the list after an existing element or at the head of the list. A <i class="farg">SLIST_HEAD</i> structure is declared as follows:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
SLIST_HEAD(HEADNAME, TYPE) head;</pre>
<div class="spacer">
</div>
where <i class="farg">HEADNAME</i> is the name of the structure to be defined, and struct <i class="farg">TYPE</i> is the type of the elements to be linked into the list. A pointer to the head of the list can later be declared as:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
struct HEADNAME *headp;</pre>
<div class="spacer">
</div>
(The names <code class="lit">head</code> and <code class="lit">headp</code> are user selectable.)<div class="spacer">
</div>
The <i class="farg">HEADNAME</i> facility is often not used, leading to the following bizarre code:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
SLIST_HEAD(, TYPE) head, *headp;</pre>
<div class="spacer">
</div>
The <b class="fname">SLIST_ENTRY</b>() macro declares a structure that connects the elements in the list.<div class="spacer">
</div>
The <b class="fname">SLIST_INIT</b>() macro initializes the list referenced by <i class="farg">head</i>.<div class="spacer">
</div>
The list can also be initialized statically by using the <b class="fname">SLIST_HEAD_INITIALIZER</b>() macro like this:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
SLIST_HEAD(HEADNAME, TYPE) head = SLIST_HEAD_INITIALIZER(head);</pre>
<div class="spacer">
</div>
The <b class="fname">SLIST_INSERT_HEAD</b>() macro inserts the new element <i class="farg">elm</i> at the head of the list.<div class="spacer">
</div>
The <b class="fname">SLIST_INSERT_AFTER</b>() macro inserts the new element <i class="farg">elm</i> after the element <i class="farg">listelm</i>.<div class="spacer">
</div>
The <b class="fname">SLIST_REMOVE_HEAD</b>() macro removes the first element of the list pointed by <i class="farg">head</i>.<div class="spacer">
</div>
The <b class="fname">SLIST_REMOVE_AFTER</b>() macro removes the list element immediately following <i class="farg">elm</i>.<div class="spacer">
</div>
The <b class="fname">SLIST_REMOVE</b>() macro removes the element <i class="farg">elm</i> of the list pointed by <i class="farg">head</i>.<div class="spacer">
</div>
The <b class="fname">SLIST_FIRST</b>() and <b class="fname">SLIST_NEXT</b>() macros can be used to traverse the list:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
for (np = SLIST_FIRST(&amp;head); np != NULL; np = SLIST_NEXT(np, FIELDNAME))</pre>
<div class="spacer">
</div>
Or, for simplicity, one can use the <b class="fname">SLIST_FOREACH</b>() macro:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
SLIST_FOREACH(np, head, FIELDNAME)</pre>
<div class="spacer">
</div>
The macro <b class="fname">SLIST_FOREACH_SAFE</b>() traverses the list referenced by head in a forward direction, assigning each element in turn to var. However, unlike <b class="fname">SLIST_FOREACH</b>() it is permitted to remove var as well as free it from within the loop safely without interfering with the traversal.<div class="spacer">
</div>
The <b class="fname">SLIST_EMPTY</b>() macro should be used to check whether a simple list is empty.</div>
<div class="section">
<h1 id="x53494e474c591e4c494e4b4544204c495354204558414d504c45">SINGLY-LINKED LIST EXAMPLE</h1><pre style="margin-left: 0.00ex;" class="lit display">
SLIST_HEAD(listhead, entry) head; 
struct entry { 
	... 
	SLIST_ENTRY(entry) entries;	/* Simple list. */ 
	... 
} *n1, *n2, *np; 
 
SLIST_INIT(&amp;head);			/* Initialize simple list. */ 
 
n1 = malloc(sizeof(struct entry));	/* Insert at the head. */ 
SLIST_INSERT_HEAD(&amp;head, n1, entries); 
 
n2 = malloc(sizeof(struct entry));	/* Insert after. */ 
SLIST_INSERT_AFTER(n1, n2, entries); 
 
SLIST_FOREACH(np, &amp;head, entries)	/* Forward traversal. */ 
	np-&gt; ... 
 
while (!SLIST_EMPTY(&amp;head)) {	 	/* Delete. */ 
	n1 = SLIST_FIRST(&amp;head); 
	SLIST_REMOVE_HEAD(&amp;head, entries); 
	free(n1); 
} 
</pre>
</div>
<div class="section">
<h1 id="x4c49535453">LISTS</h1> A list is headed by a structure defined by the <b class="fname">LIST_HEAD</b>() macro. This structure contains a single pointer to the first element on the list. The elements are doubly linked so that an arbitrary element can be removed without traversing the list. New elements can be added to the list after an existing element, before an existing element, or at the head of the list. A <i class="farg">LIST_HEAD</i> structure is declared as follows:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
LIST_HEAD(HEADNAME, TYPE) head;</pre>
<div class="spacer">
</div>
where <i class="farg">HEADNAME</i> is the name of the structure to be defined, and struct <i class="farg">TYPE</i> is the type of the elements to be linked into the list. A pointer to the head of the list can later be declared as:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
struct HEADNAME *headp;</pre>
<div class="spacer">
</div>
(The names <code class="lit">head</code> and <code class="lit">headp</code> are user selectable.)<div class="spacer">
</div>
The <i class="farg">HEADNAME</i> facility is often not used, leading to the following bizarre code:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
LIST_HEAD(, TYPE) head, *headp;</pre>
<div class="spacer">
</div>
The <b class="fname">LIST_ENTRY</b>() macro declares a structure that connects the elements in the list.<div class="spacer">
</div>
The <b class="fname">LIST_INIT</b>() macro initializes the list referenced by <i class="farg">head</i>.<div class="spacer">
</div>
The list can also be initialized statically by using the <b class="fname">LIST_HEAD_INITIALIZER</b>() macro like this:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
LIST_HEAD(HEADNAME, TYPE) head = LIST_HEAD_INITIALIZER(head);</pre>
<div class="spacer">
</div>
The <b class="fname">LIST_INSERT_HEAD</b>() macro inserts the new element <i class="farg">elm</i> at the head of the list.<div class="spacer">
</div>
The <b class="fname">LIST_INSERT_AFTER</b>() macro inserts the new element <i class="farg">elm</i> after the element <i class="farg">listelm</i>.<div class="spacer">
</div>
The <b class="fname">LIST_INSERT_BEFORE</b>() macro inserts the new element <i class="farg">elm</i> before the element <i class="farg">listelm</i>.<div class="spacer">
</div>
The <b class="fname">LIST_REMOVE</b>() macro removes the element <i class="farg">elm</i> from the list.<div class="spacer">
</div>
The <b class="fname">LIST_REPLACE</b>() macro replaces the list element <i class="farg">elm</i> with the new element <i class="farg">elm2</i>.<div class="spacer">
</div>
The <b class="fname">LIST_FIRST</b>() and <b class="fname">LIST_NEXT</b>() macros can be used to traverse the list:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
for (np = LIST_FIRST(&amp;head); np != NULL; np = LIST_NEXT(np, FIELDNAME))</pre>
<div class="spacer">
</div>
Or, for simplicity, one can use the <b class="fname">LIST_FOREACH</b>() macro:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
LIST_FOREACH(np, head, FIELDNAME)</pre>
<div class="spacer">
</div>
The macro <b class="fname">LIST_FOREACH_SAFE</b>() traverses the list referenced by head in a forward direction, assigning each element in turn to var. However, unlike <b class="fname">LIST_FOREACH</b>() it is permitted to remove var as well as free it from within the loop safely without interfering with the traversal.<div class="spacer">
</div>
The <b class="fname">LIST_EMPTY</b>() macro should be used to check whether a list is empty.</div>
<div class="section">
<h1 id="x4c495354204558414d504c45">LIST EXAMPLE</h1><pre style="margin-left: 0.00ex;" class="lit display">
LIST_HEAD(listhead, entry) head; 
struct entry { 
	... 
	LIST_ENTRY(entry) entries;	/* List. */ 
	... 
} *n1, *n2, *np; 
 
LIST_INIT(&amp;head);			/* Initialize list. */ 
 
n1 = malloc(sizeof(struct entry));	/* Insert at the head. */ 
LIST_INSERT_HEAD(&amp;head, n1, entries); 
 
n2 = malloc(sizeof(struct entry));	/* Insert after. */ 
LIST_INSERT_AFTER(n1, n2, entries); 
 
n2 = malloc(sizeof(struct entry));	/* Insert before. */ 
LIST_INSERT_BEFORE(n1, n2, entries); 
					/* Forward traversal. */ 
LIST_FOREACH(np, &amp;head, entries) 
	np-&gt; ... 
 
while (!LIST_EMPTY(&amp;head)) {		/* Delete. */ 
	n1 = LIST_FIRST(&amp;head); 
	LIST_REMOVE(n1, entries); 
	free(n1); 
}</pre>
</div>
<div class="section">
<h1 id="x53494d504c4520515545554553">SIMPLE QUEUES</h1> A simple queue is headed by a structure defined by the <b class="fname">SIMPLEQ_HEAD</b>() macro. This structure contains a pair of pointers, one to the first element in the simple queue and the other to the last element in the simple queue. The elements are singly linked. New elements can be added to the queue after an existing element, at the head of the queue or at the tail of the queue. A <i class="farg">SIMPLEQ_HEAD</i> structure is declared as follows:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
SIMPLEQ_HEAD(HEADNAME, TYPE) head;</pre>
<div class="spacer">
</div>
where <i class="farg">HEADNAME</i> is the name of the structure to be defined, and struct <i class="farg">TYPE</i> is the type of the elements to be linked into the queue. A pointer to the head of the queue can later be declared as:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
struct HEADNAME *headp;</pre>
<div class="spacer">
</div>
(The names <code class="lit">head</code> and <code class="lit">headp</code> are user selectable.)<div class="spacer">
</div>
The <b class="fname">SIMPLEQ_ENTRY</b>() macro declares a structure that connects the elements in the queue.<div class="spacer">
</div>
The <b class="fname">SIMPLEQ_INIT</b>() macro initializes the queue referenced by <i class="farg">head</i>.<div class="spacer">
</div>
The queue can also be initialized statically by using the <b class="fname">SIMPLEQ_HEAD_INITIALIZER</b>() macro like this:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
SIMPLEQ_HEAD(HEADNAME, TYPE) head = SIMPLEQ_HEAD_INITIALIZER(head);</pre>
<div class="spacer">
</div>
The <b class="fname">SIMPLEQ_INSERT_AFTER</b>() macro inserts the new element <i class="farg">elm</i> after the element <i class="farg">listelm</i>.<div class="spacer">
</div>
The <b class="fname">SIMPLEQ_INSERT_HEAD</b>() macro inserts the new element <i class="farg">elm</i> at the head of the queue.<div class="spacer">
</div>
The <b class="fname">SIMPLEQ_INSERT_TAIL</b>() macro inserts the new element <i class="farg">elm</i> at the end of the queue.<div class="spacer">
</div>
The <b class="fname">SIMPLEQ_REMOVE_AFTER</b>() macro removes the queue element immediately following <i class="farg">elm</i>.<div class="spacer">
</div>
The <b class="fname">SIMPLEQ_REMOVE_HEAD</b>() macro removes the first element from the queue.<div class="spacer">
</div>
The <b class="fname">SIMPLEQ_CONCAT</b>() macro concatenates all the elements of the queue referenced by <i class="farg">head2</i> to the end of the queue referenced by <i class="farg">head1</i>, emptying <i class="farg">head2</i> in the process. This is more efficient than removing and inserting the individual elements as it does not actually traverse <i class="farg">head2</i>.<div class="spacer">
</div>
The <b class="fname">SIMPLEQ_FIRST</b>() and <b class="fname">SIMPLEQ_NEXT</b>() macros can be used to traverse the queue. The <b class="fname">SIMPLEQ_FOREACH</b>() is used for queue traversal:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
SIMPLEQ_FOREACH(np, head, FIELDNAME)</pre>
<div class="spacer">
</div>
The macro <b class="fname">SIMPLEQ_FOREACH_SAFE</b>() traverses the queue referenced by head in a forward direction, assigning each element in turn to var. However, unlike <b class="fname">SIMPLEQ_FOREACH</b>() it is permitted to remove var as well as free it from within the loop safely without interfering with the traversal.<div class="spacer">
</div>
The <b class="fname">SIMPLEQ_EMPTY</b>() macro should be used to check whether a list is empty.</div>
<div class="section">
<h1 id="x53494d504c45205155455545204558414d504c45">SIMPLE QUEUE EXAMPLE</h1><pre style="margin-left: 0.00ex;" class="lit display">
SIMPLEQ_HEAD(listhead, entry) head = SIMPLEQ_HEAD_INITIALIZER(head); 
struct entry { 
	... 
	SIMPLEQ_ENTRY(entry) entries;	/* Simple queue. */ 
	... 
} *n1, *n2, *np; 
 
n1 = malloc(sizeof(struct entry));	/* Insert at the head. */ 
SIMPLEQ_INSERT_HEAD(&amp;head, n1, entries); 
 
n2 = malloc(sizeof(struct entry));	/* Insert after. */ 
SIMPLEQ_INSERT_AFTER(&amp;head, n1, n2, entries); 
 
n2 = malloc(sizeof(struct entry));	/* Insert at the tail. */ 
SIMPLEQ_INSERT_TAIL(&amp;head, n2, entries); 
					/* Forward traversal. */ 
SIMPLEQ_FOREACH(np, &amp;head, entries) 
	np-&gt; ... 
					/* Delete. */ 
while (!SIMPLEQ_EMPTY(&amp;head)) { 
	n1 = SIMPLEQ_FIRST(&amp;head); 
	SIMPLEQ_REMOVE_HEAD(&amp;head, entries); 
	free(n1); 
}</pre>
</div>
<div class="section">
<h1 id="x5441494c20515545554553">TAIL QUEUES</h1> A tail queue is headed by a structure defined by the <b class="fname">TAILQ_HEAD</b>() macro. This structure contains a pair of pointers, one to the first element in the tail queue and the other to the last element in the tail queue. The elements are doubly linked so that an arbitrary element can be removed without traversing the tail queue. New elements can be added to the queue after an existing element, before an existing element, at the head of the queue, or at the end of the queue. A <i class="farg">TAILQ_HEAD</i> structure is declared as follows:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
TAILQ_HEAD(HEADNAME, TYPE) head;</pre>
<div class="spacer">
</div>
where <i class="farg">HEADNAME</i> is the name of the structure to be defined, and struct <i class="farg">TYPE</i> is the type of the elements to be linked into the tail queue. A pointer to the head of the tail queue can later be declared as:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
struct HEADNAME *headp;</pre>
<div class="spacer">
</div>
(The names <code class="lit">head</code> and <code class="lit">headp</code> are user selectable.)<div class="spacer">
</div>
The <b class="fname">TAILQ_ENTRY</b>() macro declares a structure that connects the elements in the tail queue.<div class="spacer">
</div>
The <b class="fname">TAILQ_INIT</b>() macro initializes the tail queue referenced by <i class="farg">head</i>.<div class="spacer">
</div>
The tail queue can also be initialized statically by using the <b class="fname">TAILQ_HEAD_INITIALIZER</b>() macro.<div class="spacer">
</div>
The <b class="fname">TAILQ_INSERT_HEAD</b>() macro inserts the new element <i class="farg">elm</i> at the head of the tail queue.<div class="spacer">
</div>
The <b class="fname">TAILQ_INSERT_TAIL</b>() macro inserts the new element <i class="farg">elm</i> at the end of the tail queue.<div class="spacer">
</div>
The <b class="fname">TAILQ_INSERT_AFTER</b>() macro inserts the new element <i class="farg">elm</i> after the element <i class="farg">listelm</i>.<div class="spacer">
</div>
The <b class="fname">TAILQ_INSERT_BEFORE</b>() macro inserts the new element <i class="farg">elm</i> before the element <i class="farg">listelm</i>.<div class="spacer">
</div>
The <b class="fname">TAILQ_REMOVE</b>() macro removes the element <i class="farg">elm</i> from the tail queue.<div class="spacer">
</div>
The <b class="fname">TAILQ_REPLACE</b>() macro replaces the list element <i class="farg">elm</i> with the new element <i class="farg">elm2</i>.<div class="spacer">
</div>
The <b class="fname">TAILQ_CONCAT</b>() macro concatenates all the elements of the tail queue referenced by <i class="farg">head2</i> to the end of the tail queue referenced by <i class="farg">head1</i>, emptying <i class="farg">head2</i> in the process. This is more efficient than removing and inserting the individual elements as it does not actually traverse <i class="farg">head2</i>.<div class="spacer">
</div>
<b class="fname">TAILQ_FOREACH</b>() and <b class="fname">TAILQ_FOREACH_REVERSE</b>() are used for traversing a tail queue. <b class="fname">TAILQ_FOREACH</b>() starts at the first element and proceeds towards the last. <b class="fname">TAILQ_FOREACH_REVERSE</b>() starts at the last element and proceeds towards the first.<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
TAILQ_FOREACH(np, &amp;head, FIELDNAME) 
TAILQ_FOREACH_REVERSE(np, &amp;head, HEADNAME, FIELDNAME)</pre>
<div class="spacer">
</div>
The macros <b class="fname">TAILQ_FOREACH_SAFE</b>() and <b class="fname">TAILQ_FOREACH_REVERSE_SAFE</b>() traverse the list referenced by head in a forward or reverse direction respectively, assigning each element in turn to var. However, unlike their unsafe counterparts, they permit both the removal of var as well as freeing it from within the loop safely without interfering with the traversal.<div class="spacer">
</div>
The <b class="fname">TAILQ_FIRST</b>(), <b class="fname">TAILQ_NEXT</b>(), <b class="fname">TAILQ_LAST</b>() and <b class="fname">TAILQ_PREV</b>() macros can be used to manually traverse a tail queue or an arbitrary part of one.<div class="spacer">
</div>
The <b class="fname">TAILQ_EMPTY</b>() macro should be used to check whether a tail queue is empty.</div>
<div class="section">
<h1 id="x5441494c205155455545204558414d504c45">TAIL QUEUE EXAMPLE</h1><pre style="margin-left: 0.00ex;" class="lit display">
TAILQ_HEAD(tailhead, entry) head; 
struct entry { 
	... 
	TAILQ_ENTRY(entry) entries;	/* Tail queue. */ 
	... 
} *n1, *n2, *np; 
 
TAILQ_INIT(&amp;head);			/* Initialize queue. */ 
 
n1 = malloc(sizeof(struct entry));	/* Insert at the head. */ 
TAILQ_INSERT_HEAD(&amp;head, n1, entries); 
 
n1 = malloc(sizeof(struct entry));	/* Insert at the tail. */ 
TAILQ_INSERT_TAIL(&amp;head, n1, entries); 
 
n2 = malloc(sizeof(struct entry));	/* Insert after. */ 
TAILQ_INSERT_AFTER(&amp;head, n1, n2, entries); 
 
n2 = malloc(sizeof(struct entry));	/* Insert before. */ 
TAILQ_INSERT_BEFORE(n1, n2, entries); 
					/* Forward traversal. */ 
TAILQ_FOREACH(np, &amp;head, entries) 
	np-&gt; ... 
					/* Manual forward traversal. */ 
for (np = n2; np != NULL; np = TAILQ_NEXT(np, entries)) 
	np-&gt; ... 
					/* Delete. */ 
while ((np = TAILQ_FIRST(&amp;head))) { 
	TAILQ_REMOVE(&amp;head, np, entries); 
	free(np); 
} 
</pre>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html3/tree.html">tree(3)</a></div>
<div class="section">
<h1 id="x4e4f544553">NOTES</h1> It is an error to assume the next and previous fields are preserved after an element has been removed from a list or queue. Using any macro (except the various forms of insertion) on an element removed from a list or queue is incorrect. An example of erroneous usage is removing the same element twice.<div class="spacer">
</div>
The <b class="fname">SLIST_END</b>(), <b class="fname">LIST_END</b>(), <b class="fname">SIMPLEQ_END</b>() and <b class="fname">TAILQ_END</b>() macros are deprecated; they provided symmetry with the historical <b class="fname">CIRCLEQ_END</b>() and just expand to <span class="define">NULL</span>.<div class="spacer">
</div>
Trying to free a list in the following way is a common error:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
LIST_FOREACH(var, head, entry) 
	free(var); 
free(head);</pre>
<div class="spacer">
</div>
Since <b class="var">var</b> is free'd, the FOREACH macros refer to a pointer that may have been reallocated already. A similar situation occurs when the current element is deleted from the list. In cases like these the data structure's FOREACH_SAFE macros should be used instead.</div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The <b class="name">queue</b> functions first appeared in <span class="unix">4.4BSD</span>. The historical circle queue macros were deprecated in <span class="unix">OpenBSD&#160;5.5</span>.</div>
</div>
</body>
</html>

