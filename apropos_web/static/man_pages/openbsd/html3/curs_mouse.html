<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
curs_mouse(3)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
curs_mouse(3)</td>
<td class="head-vol">
Library Functions Manual</td>
<td class="head-rtitle">
curs_mouse(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1>  <b>getmouse</b>, <b>ungetmouse</b>,  <b>mousemask</b>, <b>wenclose</b>,  <b>mouse_trafo</b>, <b>wmouse_trafo</b>,  <b>mouseinterval</b> - mouse interface through curses</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
<b>#include &lt;curses.h&gt;</b><div class="spacer">
</div>
<b>typedef unsigned long mmask_t;</b><div class="spacer">
</div>
typedef struct<br/>
{<br/>
    short id;         <i>/* ID to distinguish multiple devices */</i><b></b><br/>
<b>    int x, y, z;      </b><i>/* event coordinates */</i><b></b><br/>
<b>    mmask_t bstate;   </b><i>/* button state bits */</i><b></b><br/>
<b>}</b><br/>
<b>MEVENT;</b><br/>
<div style="height: 0.00em;">
&#160;</div>
<b>int getmouse(MEVENT *event);</b><div style="height: 0.00em;">
&#160;</div>
<b>int ungetmouse(MEVENT *event);</b><div style="height: 0.00em;">
&#160;</div>
<b>mmask_t mousemask(mmask_t newmask, mmask_t *oldmask);</b><div style="height: 0.00em;">
&#160;</div>
<b>bool wenclose(const WINDOW *win, int y, int x);</b><div style="height: 0.00em;">
&#160;</div>
<b>bool mouse_trafo(int* pY, int* pX, bool to_screen);</b><div style="height: 0.00em;">
&#160;</div>
<b>bool wmouse_trafo(const WINDOW* win, int* pY, int* pX,</b><div style="height: 0.00em;">
&#160;</div>
	<b>bool to_screen);</b><div style="height: 0.00em;">
&#160;</div>
<b>int mouseinterval(int erval);</b><div style="height: 0.00em;">
&#160;</div>
</div>
<div class="section">
<h1>DESCRIPTION</h1> These functions provide an interface to mouse events from  <b>ncurses</b>(3). Mouse events are represented by  <b>KEY_MOUSE</b> pseudo-key values in the  <b>wgetch</b> input stream.<div class="spacer">
</div>
To make mouse events visible, use the <b>mousemask</b> function. This will set the mouse events to be reported. By default, no mouse events are reported. The function will return a mask to indicate which of the specified mouse events can be reported; on complete failure it returns 0. If oldmask is non-NULL, this function fills the indicated location with the previous value of the given window's mouse event mask.<div class="spacer">
</div>
As a side effect, setting a zero mousemask may turn off the mouse pointer; setting a nonzero mask may turn it on. Whether this happens is device-dependent.<div class="spacer">
</div>
Here are the mouse event type masks which may be defined:<table class="tbl">
<col style="width: 22.00ex;"/>
<col style="width: 43.00ex;"/>
<tbody>
<tr>
<td>
<i>Name</i></td>
<td>
<i>Description</i></td>
</tr>
<tr>
<td colspan="0">
</td>
</tr>
<tr>
<td>
BUTTON1_PRESSED</td>
<td>
mouse button 1 down</td>
</tr>
<tr>
<td>
BUTTON1_RELEASED</td>
<td>
mouse button 1 up</td>
</tr>
<tr>
<td>
BUTTON1_CLICKED</td>
<td>
mouse button 1 clicked</td>
</tr>
<tr>
<td>
BUTTON1_DOUBLE_CLICKED</td>
<td>
mouse button 1 double clicked</td>
</tr>
<tr>
<td>
BUTTON1_TRIPLE_CLICKED</td>
<td>
mouse button 1 triple clicked</td>
</tr>
<tr>
<td colspan="0">
</td>
</tr>
<tr>
<td>
BUTTON2_PRESSED</td>
<td>
mouse button 2 down</td>
</tr>
<tr>
<td>
BUTTON2_RELEASED</td>
<td>
mouse button 2 up</td>
</tr>
<tr>
<td>
BUTTON2_CLICKED</td>
<td>
mouse button 2 clicked</td>
</tr>
<tr>
<td>
BUTTON2_DOUBLE_CLICKED</td>
<td>
mouse button 2 double clicked</td>
</tr>
<tr>
<td>
BUTTON2_TRIPLE_CLICKED</td>
<td>
mouse button 2 triple clicked</td>
</tr>
<tr>
<td colspan="0">
</td>
</tr>
<tr>
<td>
BUTTON3_PRESSED</td>
<td>
mouse button 3 down</td>
</tr>
<tr>
<td>
BUTTON3_RELEASED</td>
<td>
mouse button 3 up</td>
</tr>
<tr>
<td>
BUTTON3_CLICKED</td>
<td>
mouse button 3 clicked</td>
</tr>
<tr>
<td>
BUTTON3_DOUBLE_CLICKED</td>
<td>
mouse button 3 double clicked</td>
</tr>
<tr>
<td>
BUTTON3_TRIPLE_CLICKED</td>
<td>
mouse button 3 triple clicked</td>
</tr>
<tr>
<td colspan="0">
</td>
</tr>
<tr>
<td>
BUTTON4_PRESSED</td>
<td>
mouse button 4 down</td>
</tr>
<tr>
<td>
BUTTON4_RELEASED</td>
<td>
mouse button 4 up</td>
</tr>
<tr>
<td>
BUTTON4_CLICKED</td>
<td>
mouse button 4 clicked</td>
</tr>
<tr>
<td>
BUTTON4_DOUBLE_CLICKED</td>
<td>
mouse button 4 double clicked</td>
</tr>
<tr>
<td>
BUTTON4_TRIPLE_CLICKED</td>
<td>
mouse button 4 triple clicked</td>
</tr>
<tr>
<td colspan="0">
</td>
</tr>
<tr>
<td>
BUTTON5_PRESSED</td>
<td>
mouse button 5 down</td>
</tr>
<tr>
<td>
BUTTON5_RELEASED</td>
<td>
mouse button 5 up</td>
</tr>
<tr>
<td>
BUTTON5_CLICKED</td>
<td>
mouse button 5 clicked</td>
</tr>
<tr>
<td>
BUTTON5_DOUBLE_CLICKED</td>
<td>
mouse button 5 double clicked</td>
</tr>
<tr>
<td>
BUTTON5_TRIPLE_CLICKED</td>
<td>
mouse button 5 triple clicked</td>
</tr>
<tr>
<td colspan="0">
</td>
</tr>
<tr>
<td>
BUTTON_SHIFT</td>
<td>
shift was down during button state change</td>
</tr>
<tr>
<td>
BUTTON_CTRL</td>
<td>
control was down during button state change</td>
</tr>
<tr>
<td>
BUTTON_ALT</td>
<td>
alt was down during button state change</td>
</tr>
<tr>
<td>
ALL_MOUSE_EVENTS</td>
<td>
report all button state changes</td>
</tr>
<tr>
<td>
REPORT_MOUSE_POSITION</td>
<td>
report mouse movement</td>
</tr>
<tr>
<td colspan="0">
</td>
</tr>
</tbody>
</table>
<div class="spacer">
</div>
Once a class of mouse events have been made visible in a window, calling the  <b>wgetch</b> function on that window may return  <b>KEY_MOUSE</b> as an indicator that a mouse event has been queued. To read the event data and pop the event off the queue, call  <b>getmouse</b>. This function will return  <b>OK</b> if a mouse event is actually visible in the given window,  <b>ERR</b> otherwise. When  <b>getmouse</b> returns <b>OK</b>, the data deposited as y and x in the event structure coordinates will be screen-relative character-cell coordinates. The returned state mask will have exactly one bit set to indicate the event type.<div class="spacer">
</div>
The <b>ungetmouse</b> function behaves analogously to <b>ungetch</b>. It pushes a  <b>KEY_MOUSE</b> event onto the input queue, and associates with that event the given state data and screen-relative character-cell coordinates.<div class="spacer">
</div>
The <b>wenclose</b> function tests whether a given pair of screen-relative character-cell coordinates is enclosed by a given window, returning TRUE if it is and FALSE otherwise. It is useful for determining what subset of the screen windows enclose the location of a mouse event.<div class="spacer">
</div>
The <b>wmouse_trafo</b> function transforms a given pair of coordinates from stdscr-relative coordinates to coordinates relative to the given window or vice versa. Please remember, that stdscr-relative coordinates are not always identical to window-relative coordinates due to the mechanism to reserve lines on top or bottom of the screen for other purposes (see the  <b>ripoffline()</b> and <b>slk_init</b> calls, for example). If the parameter  <b>to_screen</b> is <b>TRUE</b>, the pointers  <b>pY, pX</b> must reference the coordinates of a location inside the window  <b>win</b>. They are converted to window-relative coordinates and returned through the pointers. If the conversion was successful, the function returns  <b>TRUE</b>. If one of the parameters was NULL or the location is not inside the window,  <b>FALSE</b> is returned. If  <b>to_screen</b> is  <b>FALSE</b>, the pointers <b>pY, pX</b> must reference window-relative coordinates. They are converted to stdscr-relative coordinates if the window  <b>win</b> encloses this point. In this case the function returns  <b>TRUE</b>. If one of the parameters is NULL or the point is not inside the window,  <b>FALSE</b> is returned. Please notice, that the referenced coordinates are only replaced by the converted coordinates if the transformation was successful.<div class="spacer">
</div>
The <b>mouse_trafo</b> function performs the same translation as  <b>wmouse_trafo</b>, using stdscr for  <b>win</b>.<div class="spacer">
</div>
The <b>mouseinterval</b> function sets the maximum time (in thousands of a second) that can elapse between press and release events for them to be recognized as a click. Use  <b>mouseinterval(0)</b> to disable click resolution. This function returns the previous interval value. Use  <b>mouseinterval(-1)</b> to obtain the interval without altering it. The default is one sixth of a second.<div class="spacer">
</div>
Note that mouse events will be ignored when input is in cooked mode, and will cause an error beep when cooked mode is being simulated in a window by a function such as  <b>getstr</b> that expects a linefeed for input-loop termination.</div>
<div class="section">
<h1>RETURN VALUE</h1>  <b>getmouse</b> and <b>ungetmouse</b> return the integer  <b>ERR</b> upon failure or <b>OK</b> upon successful completion.<div style="margin-left: 5.00ex;">
<dl>
<dt>
<b>getmouse</b></dt>
<dd>
returns an error. If no mouse driver was initialized, or if the mask parameter is zero,</dd>
</dl>
<dl>
<dt>
<b>ungetmouse</b></dt>
<dd>
returns an error if the FIFO is full.</dd>
</dl>
</div>
<div class="spacer">
</div>
<b>mousemask</b> returns the mask of reportable events.<div class="spacer">
</div>
<b>mouseinterval</b> returns the previous interval value, unless the terminal was not initialized. In that case, it returns the maximum interval value (166).<div class="spacer">
</div>
<b>wenclose</b> and <b>wmouse_trafo</b> are boolean functions returning  <b>TRUE</b> or <b>FALSE</b> depending on their test result.</div>
<div class="section">
<h1>PORTABILITY</h1> These calls were designed for  <b>ncurses</b>(3), and are not found in SVr4 curses, 4.4BSD curses, or any other previous version of curses.<div class="spacer">
</div>
The feature macro <b>NCURSES_MOUSE_VERSION</b> is provided so the preprocessor can be used to test whether these features are present. If the interface is changed, the value of  <b>NCURSES_MOUSE_VERSION</b> will be incremented. These values for  <b>NCURSES_MOUSE_VERSION</b> may be specified when configuring ncurses:<div style="margin-left: 5.00ex;">
<dl>
<dt>
1</dt>
<dd>
has definitions for reserved events. The mask uses 28 bits.</dd>
</dl>
<dl>
<dt>
2</dt>
<dd>
adds definitions for button 5, removes the definitions for reserved events. The mask uses 29 bits.</dd>
</dl>
</div>
<div class="spacer">
</div>
The order of the <b>MEVENT</b> structure members is not guaranteed. Additional fields may be added to the structure in the future.<div class="spacer">
</div>
Under <b>ncurses</b>(3), these calls are implemented using either xterm's built-in mouse-tracking API or platform-specific drivers including<div style="margin-left: 5.00ex;">
Alessandro Rubini's gpm server.<div style="height: 0.00em;">
&#160;</div>
FreeBSD sysmouse<div style="height: 0.00em;">
&#160;</div>
OS/2 EMX</div>
If you are using an unsupported configuration, mouse events will not be visible to  <b>ncurses</b>(3) (and the <b>mousemask</b> function will always return  <b>0</b>).<div class="spacer">
</div>
If the terminfo entry contains a <b>XM</b> string, this is used in the xterm mouse driver to control the way the terminal is initialized for mouse operation. The default, if  <b>XM</b> is not found, corresponds to private mode 1000 of xterm:<div style="margin-left: 5.00ex;">
\E[?1000%?%p1%{1}%=%th%el%;</div>
The z member in the event structure is not presently used. It is intended for use with touch screens (which may be pressure-sensitive) or with 3D-mice/trackballs/power gloves.</div>
<div class="section">
<h1>BUGS</h1> Mouse events under xterm will not in fact be ignored during cooked mode, if they have been enabled by  <b>mousemask</b>. Instead, the xterm mouse report sequence will appear in the string read.<div class="spacer">
</div>
Mouse events under xterm will not be detected correctly in a window with its keypad bit off, since they are interpreted as a variety of function key. Your terminfo description should have  <b>kmous</b> set to &quot;\E[M&quot; (the beginning of the response from xterm for mouse clicks). Other values for  <b>kmous</b> are permitted, but under the same assumption, i.e., it is the beginning of the response.<div class="spacer">
</div>
Because there are no standard terminal responses that would serve to identify terminals which support the xterm mouse protocol,  <b>ncurses</b> assumes that if your $TERM environment variable contains &quot;xterm&quot;, or  <b>kmous</b> is defined in the terminal description, then the terminal may send mouse events.</div>
<div class="section">
<h1>SEE ALSO</h1>  <b>curses</b>(3),  <b>curs_kernel</b>(3),  <b>curs_slk</b>(3).</div>
<table class="foot">
<tr>
<td class="foot-date">
</td>
<td class="foot-os">
</td>
</tr>
</table>
</div>
</body>
</html>

