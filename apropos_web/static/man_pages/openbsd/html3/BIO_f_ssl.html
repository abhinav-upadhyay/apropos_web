<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
BIO_F_SSL(3)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">BIO_f_ssl</b>, <b class="name">BIO_set_ssl</b>, <b class="name">BIO_get_ssl</b>, <b class="name">BIO_set_ssl_mode</b>, <b class="name">BIO_set_ssl_renegotiate_bytes</b>, <b class="name">BIO_get_num_renegotiates</b>, <b class="name">BIO_set_ssl_renegotiate_timeout</b>, <b class="name">BIO_new_ssl</b>, <b class="name">BIO_new_ssl_connect</b>, <b class="name">BIO_new_buffer_ssl_connect</b>, <b class="name">BIO_ssl_copy_session_id</b>, <b class="name">BIO_ssl_shutdown</b>, <b class="name">BIO_do_handshake</b> &#8212; <span class="desc">SSL BIO</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">openssl/bio.h</a>&gt;</b><br/>
<b class="includes">#include &lt;<a class="link-includes">openssl/ssl.h</a>&gt;</b><div class="spacer">
</div>
<i class="ftype">BIO_METHOD *</i><br/>
<b class="fname">BIO_f_ssl</b>(<i class="farg" style="white-space:nowrap;">void</i>);<div class="spacer">
</div>
<b class="macro">#define BIO_set_ssl(b,ssl,c) BIO_ctrl(b,BIO_C_SET_SSL,c,(char *)ssl)</b><br/>
<b class="macro">#define BIO_get_ssl(b,sslp) BIO_ctrl(b,BIO_C_GET_SSL,0,(char *)sslp)</b><br/>
<b class="macro">#define BIO_set_ssl_mode(b,client) BIO_ctrl(b,BIO_C_SSL_MODE,client,NULL)</b><br/>
<b class="macro">#define BIO_set_ssl_renegotiate_bytes(b,num) BIO_ctrl(b,BIO_C_SET_SSL_RENEGOTIATE_BYTES,num,NULL)</b><br/>
<b class="macro">#define BIO_set_ssl_renegotiate_timeout(b,seconds) BIO_ctrl(b,BIO_C_SET_SSL_RENEGOTIATE_TIMEOUT,seconds,NULL)</b><br/>
<b class="macro">#define BIO_get_num_renegotiates(b) BIO_ctrl(b,BIO_C_SET_SSL_NUM_RENEGOTIATES,0,NULL)</b><div class="spacer">
</div>
<i class="ftype">BIO *</i><br/>
<b class="fname">BIO_new_ssl</b>(<i class="farg" style="white-space:nowrap;">SSL_CTX *ctx</i>, <i class="farg" style="white-space:nowrap;">int client</i>);<div class="spacer">
</div>
<i class="ftype">BIO *</i><br/>
<b class="fname">BIO_new_ssl_connect</b>(<i class="farg" style="white-space:nowrap;">SSL_CTX *ctx</i>);<div class="spacer">
</div>
<i class="ftype">BIO *</i><br/>
<b class="fname">BIO_new_buffer_ssl_connect</b>(<i class="farg" style="white-space:nowrap;">SSL_CTX *ctx</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">BIO_ssl_copy_session_id</b>(<i class="farg" style="white-space:nowrap;">BIO *to</i>, <i class="farg" style="white-space:nowrap;">BIO *from</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">BIO_ssl_shutdown</b>(<i class="farg" style="white-space:nowrap;">BIO *bio</i>);<div class="spacer">
</div>
<b class="macro">#define BIO_do_handshake(b) BIO_ctrl(b,BIO_C_DO_STATE_MACHINE,0,NULL)</b></div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> <b class="fname">BIO_f_ssl</b>() returns the <span class="type">SSL</span> <span class="type">BIO</span> method. This is a filter <span class="type">BIO</span> which is a wrapper around the OpenSSL <span class="type">SSL</span> routines adding a <span class="type">BIO</span> &#8220;flavor&#8221; to SSL I/O.<div class="spacer">
</div>
I/O performed on an <span class="type">SSL</span> <span class="type">BIO</span> communicates using the SSL protocol with the <span class="type">SSL</span>'s read and write <span class="type">BIO</span>s. If an SSL connection is not established then an attempt is made to establish one on the first I/O call.<div class="spacer">
</div>
If a <span class="type">BIO</span> is appended to an <span class="type">SSL</span> <span class="type">BIO</span> using <a class="link-man" href="../html3/BIO_push.html">BIO_push(3)</a> it is automatically used as the <span class="type">SSL</span> <span class="type">BIO</span>'s read and write <span class="type">BIO</span>s.<div class="spacer">
</div>
Calling <a class="link-man" href="../html3/BIO_reset.html">BIO_reset(3)</a> on an <span class="type">SSL</span> <span class="type">BIO</span> closes down any current SSL connection by calling <a class="link-man" href="../html3/SSL_shutdown.html">SSL_shutdown(3)</a>. <a class="link-man" href="../html1/BIO_reset.html">BIO_reset</a> is then sent to the next <span class="type">BIO</span> in the chain; this will typically disconnect the underlying transport. The <span class="type">SSL</span> <span class="type">BIO</span> is then reset to the initial accept or connect state.<div class="spacer">
</div>
If the close flag is set when an <span class="type">SSL</span> <span class="type">BIO</span> is freed then the internal <span class="type">SSL</span> structure is also freed using <a class="link-man" href="../html3/SSL_free.html">SSL_free(3)</a>.<div class="spacer">
</div>
<b class="fname">BIO_set_ssl</b>() sets the internal <span class="type">SSL</span> pointer of <span class="type">BIO</span> <i class="farg">b</i> to <i class="farg">ssl</i> using the close flag <i class="farg">c</i>.<div class="spacer">
</div>
<b class="fname">BIO_get_ssl</b>() retrieves the <span class="type">SSL</span> pointer of <span class="type">BIO</span> <i class="farg">b</i>; it can then be manipulated using the standard SSL library functions.<div class="spacer">
</div>
<b class="fname">BIO_set_ssl_mode</b>() sets the <span class="type">SSL</span> <span class="type">BIO</span> mode to <i class="farg">client</i>. If <i class="farg">client</i> is 1, client mode is set. If <i class="farg">client</i> is 0, server mode is set.<div class="spacer">
</div>
<b class="fname">BIO_set_ssl_renegotiate_bytes</b>() sets the renegotiate byte count to <i class="farg">num</i>. When set after every <i class="farg">num</i> bytes of I/O (read and write) the SSL session is automatically renegotiated. <i class="farg">num</i> must be at least 512 bytes.<div class="spacer">
</div>
<b class="fname">BIO_set_ssl_renegotiate_timeout</b>() sets the renegotiate timeout to <i class="farg">seconds</i>. When the renegotiate timeout elapses the session is automatically renegotiated.<div class="spacer">
</div>
<b class="fname">BIO_get_num_renegotiates</b>() returns the total number of session renegotiations due to I/O or timeout.<div class="spacer">
</div>
<b class="fname">BIO_new_ssl</b>() allocates an <span class="type">SSL</span> <span class="type">BIO</span> using <span class="type">SSL_CTX</span> <b class="var">ctx</b> and using client mode if <i class="farg">client</i> is nonzero.<div class="spacer">
</div>
<b class="fname">BIO_new_ssl_connect</b>() creates a new <span class="type">BIO</span> chain consisting of an <span class="type">SSL</span> <span class="type">BIO</span> (using <i class="farg">ctx</i>) followed by a connect BIO.<div class="spacer">
</div>
<b class="fname">BIO_new_buffer_ssl_connect</b>() creates a new <span class="type">BIO</span> chain consisting of a buffering <span class="type">BIO</span>, an <span class="type">SSL</span> <span class="type">BIO</span> (using <i class="farg">ctx</i>) and a connect <span class="type">BIO</span>.<div class="spacer">
</div>
<b class="fname">BIO_ssl_copy_session_id</b>() copies an SSL session id between <span class="type">BIO</span> chains <i class="farg">from</i> and <i class="farg">to</i>. It does this by locating the <span class="type">SSL</span> <span class="type">BIO</span>s in each chain and calling <a class="link-man" href="../html3/SSL_copy_session_id.html">SSL_copy_session_id(3)</a> on the internal <span class="type">SSL</span> pointer.<div class="spacer">
</div>
<b class="fname">BIO_ssl_shutdown</b>() closes down an SSL connection on <span class="type">BIO</span> chain <i class="farg">bio</i>. It does this by locating the <span class="type">SSL</span> <span class="type">BIO</span> in the chain and calling <a class="link-man" href="../html3/SSL_shutdown.html">SSL_shutdown(3)</a> on its internal <span class="type">SSL</span> pointer.<div class="spacer">
</div>
<b class="fname">BIO_do_handshake</b>() attempts to complete an SSL handshake on the supplied <span class="type">BIO</span> and establish the SSL connection. It returns 1 if the connection was established successfully. A zero or negative value is returned if the connection could not be established; the call <a class="link-man" href="../html3/BIO_should_retry.html">BIO_should_retry(3)</a> should be used for non blocking connect <span class="type">BIO</span>s to determine if the call should be retried. If an SSL connection has already been established this call has no effect.</div>
<div class="section">
<h1 id="x4e4f544553">NOTES</h1> <span class="type">SSL</span> <span class="type">BIO</span>s are exceptional in that if the underlying transport is non-blocking they can still request a retry in exceptional circumstances. Specifically this will happen if a session renegotiation takes place during a <a class="link-man" href="../html3/BIO_read.html">BIO_read(3)</a> operation. One case where this happens is when step up occurs.<div class="spacer">
</div>
In OpenSSL 0.9.6 and later the SSL flag <span class="define">SSL_AUTO_RETRY</span> can be set to disable this behaviour. In other words, when this flag is set an <span class="type">SSL</span> <span class="type">BIO</span> using a blocking transport will never request a retry.<div class="spacer">
</div>
Since unknown <a class="link-man" href="../html3/BIO_ctrl.html">BIO_ctrl(3)</a> operations are sent through filter <span class="type">BIO</span>s the server name and port can be set using <a class="link-man" href="../html3/BIO_set_host.html">BIO_set_host(3)</a> on the <span class="type">BIO</span> returned by <b class="fname">BIO_new_ssl_connect</b>() without having to locate the connect <span class="type">BIO</span> first.<div class="spacer">
</div>
Applications do not have to call <b class="fname">BIO_do_handshake</b>() but may wish to do so to separate the handshake process from other I/O processing.</div>
<div class="section">
<h1 id="x52455455524e2056414c554553">RETURN VALUES</h1> This section is incomplete.</div>
<div class="section">
<h1 id="x4558414d504c4553">EXAMPLES</h1> This SSL/TLS client example attempts to retrieve a page from an SSL/TLS web server. The I/O routines are identical to those of the unencrypted example in <a class="link-man" href="../html3/BIO_s_connect.html">BIO_s_connect(3)</a>.<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
BIO *sbio, *out; 
int len; 
char tmpbuf[1024]; 
SSL_CTX *ctx; 
SSL *ssl; 
 
ERR_load_crypto_strings(); 
ERR_load_SSL_strings(); 
OpenSSL_add_all_algorithms(); 
 
/* 
 * We would seed the PRNG here if the platform didn't do it automatically 
 */ 
 
ctx = SSL_CTX_new(SSLv23_client_method()); 
 
/* 
 * We'd normally set some stuff like the verify paths and mode here because 
 * as things stand this will connect to any server whose certificate is 
 * signed by any CA. 
 */ 
 
sbio = BIO_new_ssl_connect(ctx); 
 
BIO_get_ssl(sbio, &amp;ssl); 
 
if (!ssl) { 
	fprintf(stderr, &quot;Can't locate SSL pointer\n&quot;); 
	/* whatever ... */ 
} 
 
/* Don't want any retries */ 
SSL_set_mode(ssl, SSL_MODE_AUTO_RETRY); 
 
/* We might want to do other things with ssl here */ 
 
BIO_set_conn_hostname(sbio, &quot;localhost:https&quot;); 
 
out = BIO_new_fp(stdout, BIO_NOCLOSE); 
if (BIO_do_connect(sbio) &lt;= 0) { 
	fprintf(stderr, &quot;Error connecting to server\n&quot;); 
	ERR_print_errors_fp(stderr); 
	/* whatever ... */ 
} 
 
if (BIO_do_handshake(sbio) &lt;= 0) { 
	fprintf(stderr, &quot;Error establishing SSL connection\n&quot;); 
	ERR_print_errors_fp(stderr); 
	/* whatever ... */ 
} 
 
/* Could examine ssl here to get connection info */ 
 
BIO_puts(sbio, &quot;GET / HTTP/1.0\n\n&quot;); 
for (;;) { 
	len = BIO_read(sbio, tmpbuf, 1024); 
	if(len &lt;= 0) break; 
	BIO_write(out, tmpbuf, len); 
} 
BIO_free_all(sbio); 
BIO_free(out);</pre>
<div class="spacer">
</div>
Here is a simple server example. It makes use of a buffering <span class="type">BIO</span> to allow lines to be read from the <span class="type">SSL</span> <span class="type">BIO</span> using <a class="link-man" href="../html3/BIO_gets.html">BIO_gets(3)</a>. It creates a pseudo web page containing the actual request from a client and also echoes the request to standard output.<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
BIO *sbio, *bbio, *acpt, *out; 
int len; 
char tmpbuf[1024]; 
SSL_CTX *ctx; 
SSL *ssl; 
 
ERR_load_crypto_strings(); 
ERR_load_SSL_strings(); 
OpenSSL_add_all_algorithms(); 
 
/* Might seed PRNG here */ 
 
ctx = SSL_CTX_new(SSLv23_server_method()); 
 
if (!SSL_CTX_use_certificate_file(ctx,&quot;server.pem&quot;,SSL_FILETYPE_PEM) 
    || !SSL_CTX_use_PrivateKey_file(ctx,&quot;server.pem&quot;,SSL_FILETYPE_PEM) 
    || !SSL_CTX_check_private_key(ctx)) { 
	fprintf(stderr, &quot;Error setting up SSL_CTX\n&quot;); 
	ERR_print_errors_fp(stderr); 
	return 0; 
} 
 
/* 
 * Might do other things here like setting verify locations and DH and/or 
 * RSA temporary key callbacks 
 */ 
 
/* New SSL BIO setup as server */ 
sbio = BIO_new_ssl(ctx,0); 
 
BIO_get_ssl(sbio, &amp;ssl); 
 
if (!ssl) { 
	fprintf(stderr, &quot;Can't locate SSL pointer\n&quot;); 
	/* whatever ... */ 
} 
 
/* Don't want any retries */ 
SSL_set_mode(ssl, SSL_MODE_AUTO_RETRY); 
 
/* Create the buffering BIO */ 
 
bbio = BIO_new(BIO_f_buffer()); 
 
/* Add to chain */ 
sbio = BIO_push(bbio, sbio); 
 
acpt = BIO_new_accept(&quot;4433&quot;); 
 
/* 
 * By doing this when a new connection is established we automatically 
 * have sbio inserted into it. The BIO chain is now 'swallowed' by the 
 * accept BIO and will be freed when the accept BIO is freed. 
 */ 
 
BIO_set_accept_bios(acpt,sbio); 
 
out = BIO_new_fp(stdout, BIO_NOCLOSE); 
 
/* Setup accept BIO */ 
if (BIO_do_accept(acpt) &lt;= 0) { 
	fprintf(stderr, &quot;Error setting up accept BIO\n&quot;); 
	ERR_print_errors_fp(stderr); 
	return 0; 
} 
 
/* Now wait for incoming connection */ 
if (BIO_do_accept(acpt) &lt;= 0) { 
	fprintf(stderr, &quot;Error in connection\n&quot;); 
	ERR_print_errors_fp(stderr); 
	return 0; 
} 
 
/* We only want one connection so remove and free accept BIO */ 
 
sbio = BIO_pop(acpt); 
 
BIO_free_all(acpt); 
 
if (BIO_do_handshake(sbio) &lt;= 0) { 
	fprintf(stderr, &quot;Error in SSL handshake\n&quot;); 
	ERR_print_errors_fp(stderr); 
	return 0; 
} 
 
BIO_puts(sbio, &quot;HTTP/1.0 200 OK\r\nContent-type: text/plain\r\n\r\n&quot;); 
BIO_puts(sbio, &quot;\r\nConnection Established\r\nRequest headers:\r\n&quot;); 
BIO_puts(sbio, &quot;--------------------------------------------------\r\n&quot;); 
 
for (;;) { 
	len = BIO_gets(sbio, tmpbuf, 1024); 
	if (len &lt;= 0) 
		break; 
	BIO_write(sbio, tmpbuf, len); 
	BIO_write(out, tmpbuf, len); 
	/* Look for blank line signifying end of headers */ 
	if ((tmpbuf[0] == '\r') || (tmpbuf[0] == '\n')) 
		break; 
} 
 
BIO_puts(sbio, &quot;--------------------------------------------------\r\n&quot;); 
BIO_puts(sbio, &quot;\r\n&quot;); 
 
/* Since there is a buffering BIO present we had better flush it */ 
BIO_flush(sbio); 
 
BIO_free_all(sbio);</pre>
</div>
<div class="section">
<h1 id="x42554753">BUGS</h1> In OpenSSL versions before 1.0.0 the <a class="link-man" href="../html3/BIO_pop.html">BIO_pop(3)</a> call was handled incorrectly: the I/O BIO reference count was incorrectly incremented (instead of decremented) and dissociated with the <span class="type">SSL</span> <span class="type">BIO</span> even if the <span class="type">SSL</span> <span class="type">BIO</span> was not explicitly being popped (e.g., a pop higher up the chain). Applications which included workarounds for this bug (e.g., freeing BIOs more than once) should be modified to handle this fix or they may free up an already freed <span class="type">BIO</span>.</div>
</div>
</body>
</html>

