<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
BIO_SHOULD_RETRY(3)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">BIO_should_retry</b>, <b class="name">BIO_should_read</b>, <b class="name">BIO_should_write</b>, <b class="name">BIO_should_io_special</b>, <b class="name">BIO_retry_type</b>, <b class="name">BIO_get_retry_BIO</b>, <b class="name">BIO_get_retry_reason</b> &#8212; <span class="desc">BIO retry functions</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">openssl/bio.h</a>&gt;</b><div class="spacer">
</div>
<br/>
<b class="macro">#define BIO_should_read(a)		((a)-&gt;flags &amp; BIO_FLAGS_READ)</b><br/>
<b class="macro">#define BIO_should_write(a)		((a)-&gt;flags &amp; BIO_FLAGS_WRITE)</b><br/>
<b class="macro">#define BIO_should_io_special(a)	((a)-&gt;flags &amp; BIO_FLAGS_IO_SPECIAL)</b><br/>
<b class="macro">#define BIO_retry_type(a)		((a)-&gt;flags &amp; BIO_FLAGS_RWS)</b><br/>
<b class="macro">#define BIO_should_retry(a)		((a)-&gt;flags &amp; BIO_FLAGS_SHOULD_RETRY)</b><br/>
<b class="macro">#define BIO_FLAGS_READ			0x01</b><br/>
<b class="macro">#define BIO_FLAGS_WRITE			0x02</b><br/>
<b class="macro">#define BIO_FLAGS_IO_SPECIAL		0x04</b><br/>
<b class="macro">#define BIO_FLAGS_RWS \</b><br/>
<b class="macro">	(BIO_FLAGS_READ|BIO_FLAGS_WRITE|BIO_FLAGS_IO_SPECIAL)</b><br/>
<b class="macro">#define BIO_FLAGS_SHOULD_RETRY	0x08</b><div class="spacer">
</div>
<i class="ftype">BIO *</i><br/>
<b class="fname">BIO_get_retry_BIO</b>(<i class="farg">BIO *bio</i>, <i class="farg">int *reason</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">BIO_get_retry_reason</b>(<i class="farg">BIO *bio</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> These functions determine why a BIO is not able to read or write data. They will typically be called after a failed <a class="link-man" href="../html3/BIO_read.html">BIO_read(3)</a> or <a class="link-man" href="../html3/BIO_write.html">BIO_write(3)</a> call.<div class="spacer">
</div>
<b class="fname">BIO_should_retry</b>() is true if the call that produced this condition should be retried at a later time.<div class="spacer">
</div>
If <b class="fname">BIO_should_retry</b>() is false, the cause is an error condition.<div class="spacer">
</div>
<b class="fname">BIO_should_read</b>() is true if the cause of the condition is that a BIO needs to read data.<div class="spacer">
</div>
<b class="fname">BIO_should_write</b>() is true if the cause of the condition is that a BIO needs to write data.<div class="spacer">
</div>
<b class="fname">BIO_should_io_special</b>() is true if some &quot;special&quot; condition, that is a reason other than reading or writing, is the cause of the condition.<div class="spacer">
</div>
<b class="fname">BIO_retry_type</b>() returns a mask of the cause of a retry condition consisting of the values <span class="define">BIO_FLAGS_READ</span>, <span class="define">BIO_FLAGS_WRITE</span>, <span class="define">BIO_FLAGS_IO_SPECIAL</span> though current BIO types will only set one of these.<div class="spacer">
</div>
<b class="fname">BIO_get_retry_BIO</b>() determines the precise reason for the special condition. It returns the BIO that caused this condition and if <i class="farg">reason</i> is not <span class="define">NULL</span> it contains the reason code. The meaning of the reason code and the action that should be taken depends on the type of BIO that resulted in this condition.<div class="spacer">
</div>
<b class="fname">BIO_get_retry_reason</b>() returns the reason for a special condition if passed the relevant BIO, for example as returned by <b class="fname">BIO_get_retry_BIO</b>().</div>
<div class="section">
<h1 id="x4e4f544553">NOTES</h1> If <b class="fname">BIO_should_retry</b>() returns false, then the precise &quot;error condition&quot; depends on the BIO type that caused it and the return code of the BIO operation. For example if a call to <a class="link-man" href="../html3/BIO_read.html">BIO_read(3)</a> on a socket BIO returns 0 and <b class="fname">BIO_should_retry</b>() is false, then the cause will be that the connection closed. A similar condition on a file BIO will mean that it has reached EOF. Some BIO types may place additional information on the error queue. For more details see the individual BIO type manual pages.<div class="spacer">
</div>
If the underlying I/O structure is in a blocking mode, almost all current BIO types will not request a retry, because the underlying I/O calls will not. If the application knows that the BIO type will never signal a retry then it need not call <b class="fname">BIO_should_retry</b>() after a failed BIO I/O call. This is typically done with file BIOs.<div class="spacer">
</div>
SSL BIOs are the only current exception to this rule: they can request a retry even if the underlying I/O structure is blocking, if a handshake occurs during a call to <a class="link-man" href="../html3/BIO_read.html">BIO_read(3)</a>. An application can retry the failed call immediately or avoid this situation by setting <span class="define">SSL_MODE_AUTO_RETRY</span> on the underlying SSL structure.<div class="spacer">
</div>
While an application may retry a failed non blocking call immediately, this is likely to be very inefficient because the call will fail repeatedly until data can be processed or is available. An application will normally wait until the necessary condition is satisfied. How this is done depends on the underlying I/O structure.<div class="spacer">
</div>
For example if the cause is ultimately a socket and <b class="fname">BIO_should_read</b>() is true then a call to <a class="link-man" href="../html2/select.html">select(2)</a> may be made to wait until data is available and then retry the BIO operation. By combining the retry conditions of several non blocking BIOs in a single <a class="link-man" href="../html2/select.html">select(2)</a> call it is possible to service several BIOs in a single thread, though the performance may be poor if SSL BIOs are present because long delays can occur during the initial handshake process.<div class="spacer">
</div>
It is possible for a BIO to block indefinitely if the underlying I/O structure cannot process or return any data. This depends on the behaviour of the platforms I/O functions. This is often not desirable: one solution is to use non blocking I/O and use a timeout on the <a class="link-man" href="../html2/select.html">select(2)</a> (or equivalent) call.</div>
<div class="section">
<h1 id="x42554753">BUGS</h1> The OpenSSL ASN1 functions cannot gracefully deal with non blocking I/O: they cannot retry after a partial read or write. This is usually worked around by only passing the relevant data to ASN1 functions when the entire structure can be read or written.</div>
</div>
</body>
</html>

