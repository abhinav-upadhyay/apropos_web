<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
OHASH_INIT(3)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">ohash_init</b>, <b class="name">ohash_delete</b>, <b class="name">ohash_lookup_interval</b>, <b class="name">ohash_lookup_memory</b>, <b class="name">ohash_find</b>, <b class="name">ohash_remove</b>, <b class="name">ohash_insert</b>, <b class="name">ohash_first</b>, <b class="name">ohash_next</b>, <b class="name">ohash_entries</b> &#8212; <span class="desc">light-weight open hashing</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">stdint.h</a>&gt;</b><br/>
<b class="includes">#include &lt;<a class="link-includes">stddef.h</a>&gt;</b><br/>
<b class="includes">#include &lt;<a class="link-includes">ohash.h</a>&gt;</b><div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">ohash_init</b>(<i class="farg" style="white-space:nowrap;">struct ohash *h</i>, <i class="farg" style="white-space:nowrap;">unsigned int size</i>, <i class="farg" style="white-space:nowrap;">struct ohash_info *info</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">ohash_delete</b>(<i class="farg" style="white-space:nowrap;">struct ohash *h</i>);<div class="spacer">
</div>
<i class="ftype">unsigned int</i><br/>
<b class="fname">ohash_lookup_interval</b>(<i class="farg" style="white-space:nowrap;">struct ohash *h</i>, <i class="farg" style="white-space:nowrap;">const char *start</i>, <i class="farg" style="white-space:nowrap;">const char *end</i>, <i class="farg" style="white-space:nowrap;">uint32_t hv</i>);<div class="spacer">
</div>
<i class="ftype">unsigned int</i><br/>
<b class="fname">ohash_lookup_memory</b>(<i class="farg" style="white-space:nowrap;">struct ohash *h</i>, <i class="farg" style="white-space:nowrap;">const char *k</i>, <i class="farg" style="white-space:nowrap;">size_t s</i>, <i class="farg" style="white-space:nowrap;">uint32_t hv</i>);<div class="spacer">
</div>
<i class="ftype">void *</i><br/>
<b class="fname">ohash_find</b>(<i class="farg" style="white-space:nowrap;">struct ohash *h</i>, <i class="farg" style="white-space:nowrap;">unsigned int i</i>);<div class="spacer">
</div>
<i class="ftype">void *</i><br/>
<b class="fname">ohash_remove</b>(<i class="farg" style="white-space:nowrap;">struct ohash *h</i>, <i class="farg" style="white-space:nowrap;">unsigned int i</i>);<div class="spacer">
</div>
<i class="ftype">void *</i><br/>
<b class="fname">ohash_insert</b>(<i class="farg" style="white-space:nowrap;">struct ohash *h</i>, <i class="farg" style="white-space:nowrap;">unsigned int i</i>, <i class="farg" style="white-space:nowrap;">void *p</i>);<div class="spacer">
</div>
<i class="ftype">void *</i><br/>
<b class="fname">ohash_first</b>(<i class="farg" style="white-space:nowrap;">struct ohash *h</i>, <i class="farg" style="white-space:nowrap;">unsigned int *i</i>);<div class="spacer">
</div>
<i class="ftype">void *</i><br/>
<b class="fname">ohash_next</b>(<i class="farg" style="white-space:nowrap;">struct ohash *h</i>, <i class="farg" style="white-space:nowrap;">unsigned int *i</i>);<div class="spacer">
</div>
<i class="ftype">unsigned int</i><br/>
<b class="fname">ohash_entries</b>(<i class="farg" style="white-space:nowrap;">struct ohash *h</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> These functions have been designed as a fast, extensible alternative to the usual hash table functions. They provide storage and retrieval of records indexed by keys, where a key is a contiguous sequence of bytes at a fixed position in each record. Keys can either be NUL-terminated strings or fixed-size memory areas. All functions take a pointer to an ohash structure as the <i class="farg">h</i> function argument. Storage for this structure should be provided by user code.<div class="spacer">
</div>
<b class="fname">ohash_init</b>() initializes the table to store roughly 2 to the power <i class="farg">size</i> elements. <i class="farg">info</i> is a pointer to a <i class="farg">struct ohash_info</i>.<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
struct ohash_info { 
	ptrdiff_t key_offset; 
	void *data;	/* user data */ 
	void *(*calloc)(size_t, size_t, void *); 
	void (*free)(void *, void *); 
	void *(*alloc)(size_t, void *); 
};</pre>
<div class="spacer">
</div>
The <b class="var">offset</b> field holds the position of the key in each record; the <b class="var">calloc</b> and <b class="var">free</b> fields are pointers to <a class="link-man" href="../html3/calloc.html">calloc(3)</a> and <a class="link-man" href="../html3/free.html">free(3)</a>-like functions, used for managing the table internal storage; the <b class="var">alloc</b> field is only used by the utility function <a class="link-man" href="../html3/ohash_create_entry.html">ohash_create_entry(3)</a>.<div class="spacer">
</div>
Each of these functions are called similarly to their standard counterpart, but with an extra <i class="ftype">void *</i> parameter corresponding to the content of the field <i class="farg">data</i>, which can be used to communicate specific information to the functions.<div class="spacer">
</div>
<b class="fname">ohash_init</b>() stores a copy of those fields internally, so <i class="farg">info</i> can be reclaimed after initialization.<div class="spacer">
</div>
<b class="fname">ohash_delete</b>() frees storage internal to <i class="farg">h</i>. Elements themselves should be freed by the user first, using for instance <b class="fname">ohash_first</b>() and <b class="fname">ohash_next</b>().<div class="spacer">
</div>
<b class="fname">ohash_lookup_interval</b>() and <b class="fname">ohash_lookup_memory</b>() are the basic look-up element functions. The hashing function result is provided by the user as <i class="farg">hv</i>. These return a &#8220;slot&#8221; in the ohash table <i class="farg">h</i>, to be used with <b class="fname">ohash_find</b>(), <b class="fname">ohash_insert</b>(), or <b class="fname">ohash_remove</b>(). This slot is only valid up to the next call to <b class="fname">ohash_insert</b>() or <b class="fname">ohash_remove</b>().<div class="spacer">
</div>
<b class="fname">ohash_lookup_interval</b>() handles string-like keys. <b class="fname">ohash_lookup_interval</b>() assumes the key is the interval between <i class="farg">start</i> and <i class="farg">end</i>, exclusive, though the actual elements stored in the table should only contain NUL-terminated keys.<div class="spacer">
</div>
<b class="fname">ohash_lookup_memory</b>() assumes the key is the memory area starting at <i class="farg">k</i> of size <i class="farg">s</i>. All bytes are significant in key comparison.<div class="spacer">
</div>
<b class="fname">ohash_find</b>() retrieves an element from a slot <i class="farg">i</i> returned by the <b class="fname">ohash_lookup*</b>() functions. It returns <span class="define">NULL</span> if the slot is empty.<div class="spacer">
</div>
<b class="fname">ohash_insert</b>() inserts a new element <i class="farg">p</i> at slot <i class="farg">i</i>. Slot <i class="farg">i</i> must be empty and element <i class="farg">p</i> must have a key corresponding to the <b class="fname">ohash_lookup*</b>() call.<div class="spacer">
</div>
<b class="fname">ohash_remove</b>() removes the element at slot <i class="farg">i</i>. It returns the removed element, for user code to dispose of, or <span class="define">NULL</span> if the slot was empty.<div class="spacer">
</div>
<b class="fname">ohash_first</b>() and <b class="fname">ohash_next</b>() can be used to access all elements in an ohash table, like this:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
for (n = ohash_first(h, &amp;i); n != NULL; n = ohash_next(h, &amp;i)) 
	do_something_with(n);</pre>
<div class="spacer">
</div>
<i class="farg">i</i> points to an auxiliary unsigned integer used to record the current position in the ohash table. Those functions are safe to use even while entries are added to/removed from the table, but in such a case they don't guarantee that new entries will be returned. As a special case, they can safely be used to free elements in the table.<div class="spacer">
</div>
<b class="fname">ohash_entries</b>() returns the number of elements in the hash table.</div>
<div class="section">
<h1 id="x53544f524147452048414e444c494e47">STORAGE HANDLING</h1> Only <b class="fname">ohash_init</b>(), <b class="fname">ohash_insert</b>(), <b class="fname">ohash_remove</b>() and <b class="fname">ohash_delete</b>() may call the user-supplied memory functions:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
p = (*info-&gt;calloc)(n, sizeof_record, info-&gt;data); 
/* copy data from old to p */ 
(*info-&gt;free)(old, info-&gt;data);</pre>
<div class="spacer">
</div>
It is the responsibility of the user memory allocation code to verify that those calls did not fail.<div class="spacer">
</div>
If memory allocation fails, <b class="fname">ohash_init</b>() returns a useless hash table. <b class="fname">ohash_insert</b>() and <b class="fname">ohash_remove</b>() still perform the requested operation, but the returned table should be considered read-only. It can still be accessed by <b class="fname">ohash_lookup*</b>(), <b class="fname">ohash_find</b>(), <b class="fname">ohash_first</b>() and <b class="fname">ohash_next</b>() to dump relevant information to disk before aborting.</div>
<div class="section">
<h1 id="x54485245414420534146455459">THREAD SAFETY</h1> The open hashing functions are not thread-safe by design. In particular, in a threaded environment, there is no guarantee that a &#8220;slot&#8221; will not move between a <b class="fname">ohash_lookup*</b>() and a <b class="fname">ohash_find</b>(), <b class="fname">ohash_insert</b>() or <b class="fname">ohash_remove</b>() call.<div class="spacer">
</div>
Multi-threaded applications should explicitly protect ohash table access.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html3/hcreate.html">hcreate(3)</a>, <a class="link-man" href="../html3/ohash_interval.html">ohash_interval(3)</a><div class="spacer">
</div>
<span class="ref"><span class="ref-auth">Donald E. Knuth</span>, <i class="ref-book">The Art of Computer Programming</i>, <span class="ref-vol">Vol. 3</span>, <span class="ref-page">pp 506-550</span>, <span class="ref-date">1973</span>.</span></div>
<div class="section">
<h1 id="x5354414e4441524453">STANDARDS</h1> Those functions are completely non-standard and should be avoided in portable programs.</div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> Those functions were designed and written for <span class="unix">OpenBSD</span> <a class="link-man" href="../html1/make.html">make(1)</a> by Marc Espie in 1999.</div>
</div>
</body>
</html>

