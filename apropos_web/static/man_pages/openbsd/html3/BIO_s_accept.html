<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
BIO_S_ACCEPT(3)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">BIO_s_accept</b>, <b class="name">BIO_set_accept_port</b>, <b class="name">BIO_get_accept_port</b>, <b class="name">BIO_new_accept</b>, <b class="name">BIO_set_nbio_accept</b>, <b class="name">BIO_set_accept_bios</b>, <b class="name">BIO_set_bind_mode</b>, <b class="name">BIO_get_bind_mode</b>, <b class="name">BIO_do_accept</b> &#8212; <span class="desc">accept BIO</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">openssl/bio.h</a>&gt;</b><div class="spacer">
</div>
<i class="ftype">BIO_METHOD *</i><br/>
<b class="fname">BIO_s_accept</b>(<i class="farg">void</i>);<div class="spacer">
</div>
<i class="ftype">long</i><br/>
<b class="fname">BIO_set_accept_port</b>(<i class="farg">BIO *b</i>, <i class="farg">char *name</i>);<div class="spacer">
</div>
<i class="ftype">char *</i><br/>
<b class="fname">BIO_get_accept_port</b>(<i class="farg">BIO *b</i>);<div class="spacer">
</div>
<i class="ftype">BIO *</i><br/>
<b class="fname">BIO_new_accept</b>(<i class="farg">char *host_port</i>);<div class="spacer">
</div>
<i class="ftype">long</i><br/>
<b class="fname">BIO_set_nbio_accept</b>(<i class="farg">BIO *b</i>, <i class="farg">int n</i>);<div class="spacer">
</div>
<i class="ftype">long</i><br/>
<b class="fname">BIO_set_accept_bios</b>(<i class="farg">BIO *b</i>, <i class="farg">char *bio</i>);<div class="spacer">
</div>
<i class="ftype">long</i><br/>
<b class="fname">BIO_set_bind_mode</b>(<i class="farg">BIO *b</i>, <i class="farg">long mode</i>);<div class="spacer">
</div>
<i class="ftype">long</i><br/>
<b class="fname">BIO_get_bind_mode</b>(<i class="farg">BIO *b</i>, <i class="farg">long dummy</i>);<div class="spacer">
</div>
<b class="macro">#define BIO_BIND_NORMAL				0</b><br/>
<b class="macro">#define BIO_BIND_REUSEADDR_IF_UNUSED	1</b><br/>
<b class="macro">#define BIO_BIND_REUSEADDR			2</b><div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">BIO_do_accept</b>(<i class="farg">BIO *b</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> <b class="fname">BIO_s_accept</b>() returns the accept BIO method. This is a wrapper round the platform's TCP/IP socket accept routines.<div class="spacer">
</div>
Using accept BIOs, TCP/IP connections can be accepted and data transferred using only BIO routines. In this way any platform specific operations are hidden by the BIO abstraction.<div class="spacer">
</div>
Read and write operations on an accept BIO will perform I/O on the underlying connection. If no connection is established and the port (see below) is set up properly then the BIO waits for an incoming connection.<div class="spacer">
</div>
Accept BIOs support <a class="link-man" href="../html3/BIO_puts.html">BIO_puts(3)</a> but not <a class="link-man" href="../html3/BIO_gets.html">BIO_gets(3)</a>.<div class="spacer">
</div>
If the close flag is set on an accept BIO, then any active connection on that chain is shutdown and the socket closed when the BIO is freed.<div class="spacer">
</div>
Calling <a class="link-man" href="../html3/BIO_reset.html">BIO_reset(3)</a> on a accept BIO will close any active connection and reset the BIO into a state where it awaits another incoming connection.<div class="spacer">
</div>
<a class="link-man" href="../html3/BIO_get_fd.html">BIO_get_fd(3)</a> and <a class="link-man" href="../html3/BIO_set_fd.html">BIO_set_fd(3)</a> can be called to retrieve or set the accept socket. See <a class="link-man" href="../html3/BIO_s_fd.html">BIO_s_fd(3)</a>.<div class="spacer">
</div>
<b class="fname">BIO_set_accept_port</b>() uses the string <i class="farg">name</i> to set the accept port. The port is represented as a string of the form <i class="arg">host</i>:<i class="arg">port</i>, where <i class="arg">host</i> is the interface to use and <i class="arg">port</i> is the port. Either or both values can be &#8220;*&#8221; which is interpreted as meaning any interface or port respectively. <i class="arg">port</i> has the same syntax as the port specified in <a class="link-man" href="../html3/BIO_set_conn_port.html">BIO_set_conn_port(3)</a> for connect BIOs. It can be a numerical port string or a string to lookup using <a class="link-man" href="../html3/getservbyname.html">getservbyname(3)</a> and a string table.<div class="spacer">
</div>
<b class="fname">BIO_new_accept</b>() combines <a class="link-man" href="../html3/BIO_new.html">BIO_new(3)</a> and <b class="fname">BIO_set_accept_port</b>() into a single call. It creates a new accept BIO with port <i class="farg">host_port</i>.<div class="spacer">
</div>
<b class="fname">BIO_set_nbio_accept</b>() sets the accept socket to blocking mode (the default) if <i class="farg">n</i> is 0 or non blocking mode if <i class="farg">n</i> is 1.<div class="spacer">
</div>
<b class="fname">BIO_set_accept_bios</b>() can be used to set a chain of BIOs which will be duplicated and prepended to the chain when an incoming connection is received. This is useful if, for example, a buffering or SSL BIO is required for each connection. The chain of BIOs must not be freed after this call, they will be automatically freed when the accept BIO is freed.<div class="spacer">
</div>
<b class="fname">BIO_set_bind_mode</b>() and <b class="fname">BIO_get_bind_mode</b>() set and retrieve the current bind mode. If <span class="define">BIO_BIND_NORMAL</span> (the default) is set, then another socket cannot be bound to the same port. If <span class="define">BIO_BIND_REUSEADDR</span> is set, then other sockets can bind to the same port. If <span class="define">BIO_BIND_REUSEADDR_IF_UNUSED</span> is set, then an attempt is first made to use <span class="define">BIO_BIN_NORMAL</span>; if this fails and the port is not in use, then a second attempt is made using <span class="define">BIO_BIND_REUSEADDR</span>.<div class="spacer">
</div>
<b class="fname">BIO_do_accept</b>() serves two purposes. When it is first called, after the accept BIO has been setup, it will attempt to create the accept socket and bind an address to it. Second and subsequent calls to <b class="fname">BIO_do_accept</b>() will await an incoming connection, or request a retry in non blocking mode.</div>
<div class="section">
<h1 id="x4e4f544553">NOTES</h1> When an accept BIO is at the end of a chain, it will await an incoming connection before processing I/O calls. When an accept BIO is not at then end of a chain, it passes I/O calls to the next BIO in the chain.<div class="spacer">
</div>
When a connection is established a new socket BIO is created for the connection and appended to the chain. That is the chain is now accept-&gt;socket. This effectively means that attempting I/O on an initial accept socket will await an incoming connection then perform I/O on it.<div class="spacer">
</div>
If any additional BIOs have been set using <b class="fname">BIO_set_accept_bios</b>(), then they are placed between the socket and the accept BIO, that is the chain will be accept-&gt;otherbios-&gt;socket.<div class="spacer">
</div>
If a server wishes to process multiple connections (as is normally the case), then the accept BIO must be made available for further incoming connections. This can be done by waiting for a connection and then calling:<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">connection = BIO_pop(accept);</code></div>
</blockquote>
<div class="spacer">
</div>
After this call, <span class="symb">connection</span> will contain a BIO for the recently established connection and <span class="symb">accept</span> will now be a single BIO again which can be used to await further incoming connections. If no further connections will be accepted, the <span class="symb">accept</span> can be freed using <a class="link-man" href="../html3/BIO_free.html">BIO_free(3)</a>.<div class="spacer">
</div>
If only a single connection will be processed, it is possible to perform I/O using the accept BIO itself. This is often undesirable however because the accept BIO will still accept additional incoming connections. This can be resolved by using <a class="link-man" href="../html3/BIO_pop.html">BIO_pop(3)</a> (see above) and freeing up the accept BIO after the initial connection.<div class="spacer">
</div>
If the underlying accept socket is non-blocking and <b class="fname">BIO_do_accept</b>() is called to await an incoming connection, it is possible for <a class="link-man" href="../html3/BIO_should_io_special.html">BIO_should_io_special(3)</a> with the reason <span class="define">BIO_RR_ACCEPT</span>. If this happens, then it is an indication that an accept attempt would block: the application should take appropriate action to wait until the underlying socket has accepted a connection and retry the call.<div class="spacer">
</div>
<b class="fname">BIO_set_accept_port</b>(), <b class="fname">BIO_get_accept_port</b>(), <b class="fname">BIO_set_nbio_accept</b>(), <b class="fname">BIO_set_accept_bios</b>(), <b class="fname">BIO_set_bind_mode</b>(), <b class="fname">BIO_get_bind_mode</b>(), and <b class="fname">BIO_do_accept</b>() are macros.</div>
<div class="section">
<h1 id="x4558414d504c4553">EXAMPLES</h1> This example accepts two connections on port 4444, sends messages down each and finally closes both down.<div class="spacer">
</div>
<pre style="margin-left: 2.00ex;" class="lit display">
BIO *abio, *cbio, *cbio2; 
ERR_load_crypto_strings(); 
abio = BIO_new_accept(&quot;4444&quot;); 
 
/* First call to BIO_accept() sets up accept BIO */ 
if (BIO_do_accept(abio) &lt;= 0) { 
	fprintf(stderr, &quot;Error setting up accept\n&quot;); 
	ERR_print_errors_fp(stderr); 
	exit(0); 
} 
 
/* Wait for incoming connection */ 
if (BIO_do_accept(abio) &lt;= 0) { 
	fprintf(stderr, &quot;Error accepting connection\n&quot;); 
	ERR_print_errors_fp(stderr); 
	exit(0); 
} 
fprintf(stderr, &quot;Connection 1 established\n&quot;); 
 
/* Retrieve BIO for connection */ 
cbio = BIO_pop(abio); 
 
BIO_puts(cbio, &quot;Connection 1: Sending out Data on initial connection\n&quot;); 
fprintf(stderr, &quot;Sent out data on connection 1\n&quot;); 
 
/* Wait for another connection */ 
if (BIO_do_accept(abio) &lt;= 0) { 
	fprintf(stderr, &quot;Error accepting connection\n&quot;); 
	ERR_print_errors_fp(stderr); 
	exit(0); 
} 
fprintf(stderr, &quot;Connection 2 established\n&quot;); 
 
/* Close accept BIO to refuse further connections */ 
cbio2 = BIO_pop(abio); 
BIO_free(abio); 
 
BIO_puts(cbio2, &quot;Connection 2: Sending out Data on second\n&quot;); 
fprintf(stderr, &quot;Sent out data on connection 2\n&quot;); 
BIO_puts(cbio, &quot;Connection 1: Second connection established\n&quot;); 
 
/* Close the two established connections */ 
BIO_free(cbio); 
BIO_free(cbio2);</pre>
</div>
</div>
</body>
</html>

