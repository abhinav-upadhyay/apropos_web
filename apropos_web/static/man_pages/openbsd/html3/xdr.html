<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
XDR_ARRAY(3)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">xdr_array</b>, <b class="name">xdr_bool</b>, <b class="name">xdr_bytes</b>, <b class="name">xdr_char</b>, <b class="name">xdr_destroy</b>, <b class="name">xdr_double</b>, <b class="name">xdr_enum</b>, <b class="name">xdr_float</b>, <b class="name">xdr_free</b>, <b class="name">xdr_getpos</b>, <b class="name">xdr_inline</b>, <b class="name">xdr_int</b>, <b class="name">xdr_long</b>, <b class="name">xdr_int64_t</b>, <b class="name">xdrmem_create</b>, <b class="name">xdr_opaque</b>, <b class="name">xdr_pointer</b>, <b class="name">xdrrec_create</b>, <b class="name">xdrrec_endofrecord</b>, <b class="name">xdrrec_eof</b>, <b class="name">xdrrec_skiprecord</b>, <b class="name">xdr_reference</b>, <b class="name">xdr_setpos</b>, <b class="name">xdr_short</b>, <b class="name">xdrstdio_create</b>, <b class="name">xdr_string</b>, <b class="name">xdr_u_char</b>, <b class="name">xdr_u_int</b>, <b class="name">xdr_u_long</b>, <b class="name">xdr_u_int64_t</b>, <b class="name">xdr_u_short</b>, <b class="name">xdr_union</b>, <b class="name">xdr_vector</b>, <b class="name">xdr_void</b>, <b class="name">xdr_wrapstring</b> &#8212; <span class="desc">library routines for external data representation</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/types.h</a>&gt;</b><br/>
<b class="includes">#include &lt;<a class="link-includes">rpc/xdr.h</a>&gt;</b><div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">xdr_array</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">char **arrp</i>, <i class="farg" style="white-space:nowrap;">u_int *sizep</i>, <i class="farg" style="white-space:nowrap;">u_int maxsize</i>, <i class="farg" style="white-space:nowrap;">u_int elsize</i>, <i class="farg" style="white-space:nowrap;">xdrproc_t elproc</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">xdr_bool</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">bool_t *bp</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">xdr_bytes</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">char **sp</i>, <i class="farg" style="white-space:nowrap;">u_int *sizep</i>, <i class="farg" style="white-space:nowrap;">u_int maxsize</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">xdr_char</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">char *cp</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">xdr_destroy</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">xdr_double</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">double *dp</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">xdr_enum</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">enum_t *ep</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">xdr_float</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">float *fp</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">xdr_free</b>(<i class="farg" style="white-space:nowrap;">xdrproc_t proc</i>, <i class="farg" style="white-space:nowrap;">char *objp</i>);<div class="spacer">
</div>
<i class="ftype">u_int</i><br/>
<b class="fname">xdr_getpos</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>);<div class="spacer">
</div>
<i class="ftype">long *</i><br/>
<b class="fname">xdr_inline</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">int len</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">xdr_int</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">int *ip</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">xdr_long</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">long *lp</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">xdr_int64_t</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">int64_t *lp</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">xdrmem_create</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">char *addr</i>, <i class="farg" style="white-space:nowrap;">u_int size</i>, <i class="farg" style="white-space:nowrap;">enum xdr_op op</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">xdr_opaque</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">char *cp</i>, <i class="farg" style="white-space:nowrap;">u_int cnt</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">xdr_pointer</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">char **objpp</i>, <i class="farg" style="white-space:nowrap;">u_int objsize</i>, <i class="farg" style="white-space:nowrap;">xdrproc_t xdrobj</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">xdrrec_create</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">u_int sendsize</i>, <i class="farg" style="white-space:nowrap;">u_int recvsize</i>, <i class="farg" style="white-space:nowrap;">char *handle</i>, <i class="farg" style="white-space:nowrap;">int (*readit)()</i>, <i class="farg" style="white-space:nowrap;">int (*writeit)()</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">xdrrec_endofrecord</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">int sendnow</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">xdrrec_eof</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">xdrrec_skiprecord</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">xdr_reference</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">char **pp</i>, <i class="farg" style="white-space:nowrap;">u_int size</i>, <i class="farg" style="white-space:nowrap;">xdrproc_t proc</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">xdr_setpos</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">u_int pos</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">xdr_short</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">short *sp</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">xdrstdio_create</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">FILE *file</i>, <i class="farg" style="white-space:nowrap;">enum xdr_op op</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">xdr_string</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">char **sp</i>, <i class="farg" style="white-space:nowrap;">u_int maxsize</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">xdr_u_char</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">unsigned char *ucp</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">xdr_u_int</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">unsigned int *up</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">xdr_u_long</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">unsigned long *ulp</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">xdr_u_int64_t</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">u_int64_t *ullp</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">xdr_u_short</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">unsigned short *usp</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">xdr_union</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">int *dscmp</i>, <i class="farg" style="white-space:nowrap;">char *unp</i>, <i class="farg" style="white-space:nowrap;">struct xdr_discrim *choices</i>, <i class="farg" style="white-space:nowrap;">bool_t (*defaultarm)()</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">xdr_vector</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">char *arrp</i>, <i class="farg" style="white-space:nowrap;">u_int size</i>, <i class="farg" style="white-space:nowrap;">u_int elsize</i>, <i class="farg" style="white-space:nowrap;">xdrproc_t elproc</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">xdr_void</b>(<i class="farg" style="white-space:nowrap;">void</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">xdr_wrapstring</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">char **sp</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> These routines allow C programmers to describe arbitrary data structures in a machine-independent fashion. Data for remote procedure calls are transmitted using these routines.<div class="spacer">
</div>
<b class="fname">xdr_array</b>() is a filter primitive that translates between variable-length arrays and their corresponding external representations. The parameter <i class="farg">arrp</i> is the address of the pointer to the array, while <i class="farg">sizep</i> is the address of the element count of the array; this element count cannot exceed <i class="farg">maxsize</i>. The parameter <i class="farg">elsize</i> is the size of each of the array's elements, and <i class="farg">elproc</i> is an XDR filter that translates between the array elements' C form, and their external representation. This routine returns one if it succeeds, zero otherwise.<div class="spacer">
</div>
<b class="fname">xdr_bool</b>() is a filter primitive that translates between booleans (C integers) and their external representations. When encoding data, this filter produces values of either one or zero. This routine returns one if it succeeds, zero otherwise.<div class="spacer">
</div>
<b class="fname">xdr_bytes</b>() is a filter primitive that translates between counted byte strings and their external representations. The parameter <i class="farg">sp</i> is the address of the string pointer. The length of the string is located at address <i class="farg">sizep</i>; strings cannot be longer than <i class="farg">maxsize</i>. This routine returns one if it succeeds, zero otherwise.<div class="spacer">
</div>
<b class="fname">xdr_char</b>() is a filter primitive that translates between C characters and their external representations. This routine returns one if it succeeds, zero otherwise. Note: encoded characters are not packed, and occupy 4 bytes each. For arrays of characters, it is worthwhile to consider <b class="fname">xdr_bytes</b>(), <b class="fname">xdr_opaque</b>(), or <b class="fname">xdr_string</b>().<div class="spacer">
</div>
<b class="fname">xdr_destroy</b>() is a macro that invokes the destroy routine associated with the XDR stream <i class="farg">xdrs</i>. Destruction usually involves freeing private data structures associated with the stream. Using <i class="farg">xdrs</i> after invoking <b class="fname">xdr_destroy</b>() is undefined.<div class="spacer">
</div>
<b class="fname">xdr_double</b>() is a filter primitive that translates between C <code class="lit">double</code> precision numbers and their external representations. This routine returns one if it succeeds, zero otherwise.<div class="spacer">
</div>
<b class="fname">xdr_enum</b>() is a filter primitive that translates between the C <code class="lit">enum</code> type (actually an integer) and its external representations. This routine returns one if it succeeds, zero otherwise.<div class="spacer">
</div>
<b class="fname">xdr_float</b>() is a filter primitive that translates between the C <code class="lit">float</code> type and its external representations. This routine returns one if it succeeds, zero otherwise.<div class="spacer">
</div>
<b class="fname">xdr_free</b>() is a generic freeing routine. The first argument is the XDR routine for the object being freed. The second argument is a pointer to the object itself. Note: the pointer passed to this routine is <i class="farg">not</i> freed, but what it points to is freed (recursively).<div class="spacer">
</div>
<b class="fname">xdr_getpos</b>() is a macro that invokes the get-position routine associated with the XDR stream <i class="farg">xdrs</i>. The routine returns an unsigned integer, which indicates the position of the XDR byte stream. A desirable feature of XDR streams is that simple arithmetic works with this number, although the XDR stream instances need not guarantee this.<div class="spacer">
</div>
<b class="fname">xdr_inline</b>() is a macro that invokes the in-line routine associated with the XDR stream <i class="farg">xdrs</i>. The routine returns a pointer to a contiguous piece of the stream's buffer; <i class="farg">len</i> is the byte length of the desired buffer. Note: pointer is cast to <code class="lit">long *</code>. Warning: <b class="fname">xdr_inline</b>() may return <span class="define">NULL</span> if it cannot allocate a contiguous piece of a buffer. Therefore the behavior may vary among stream instances; it exists for the sake of efficiency.<div class="spacer">
</div>
<b class="fname">xdr_int</b>() is a filter primitive that translates between C integers and their external representations. This routine returns one if it succeeds, zero otherwise.<div class="spacer">
</div>
<b class="fname">xdr_long</b>() is a filter primitive that translates between C <code class="lit">long</code> integers and their external representations. This routine returns one if it succeeds, zero otherwise.<div class="spacer">
</div>
<b class="fname">xdr_int64_t</b>() is a filter primitive that translates between C <code class="lit">int64_t</code> integers and their external representations. This routine returns one if it succeeds, zero otherwise.<div class="spacer">
</div>
<b class="fname">xdrmem_create</b>() is a routine which initializes the XDR stream object pointed to by <i class="farg">xdrs</i>. The stream's data is written to, or read from, a chunk of memory at location <i class="farg">addr</i> whose length is no more than <i class="farg">size</i> bytes long. The <i class="farg">op</i> determines the direction of the XDR stream (either <span class="define">XDR_ENCODE</span>, <span class="define">XDR_DECODE</span>, or <span class="define">XDR_FREE</span>).<div class="spacer">
</div>
<b class="fname">xdr_opaque</b>() is a filter primitive that translates between fixed size opaque data and its external representation. The parameter <i class="farg">cp</i> is the address of the opaque object, and <i class="farg">cnt</i> is its size in bytes. This routine returns one if it succeeds, zero otherwise.<div class="spacer">
</div>
<b class="fname">xdr_pointer</b>() is like <b class="fname">xdr_reference</b>() except that it serializes <span class="define">NULL</span> pointers, whereas <b class="fname">xdr_reference</b>() does not. Thus, <b class="fname">xdr_pointer</b>() can represent recursive data structures, such as binary trees or linked lists.<div class="spacer">
</div>
<b class="fname">xdrrec_create</b>() is a routine which initializes the XDR stream object pointed to by <i class="farg">xdrs</i>. The stream's data is written to a buffer of size <i class="farg">sendsize</i>; a value of zero indicates the system should use a suitable default. The stream's data is read from a buffer of size <i class="farg">recvsize</i>; it too can be set to a suitable default by passing a zero value. When a stream's output buffer is full, <b class="fname">(*writeit)</b>() is called. Similarly, when a stream's input buffer is empty, <b class="fname">(*readit)</b>() is called. The behavior of these two routines is similar to the system calls <b class="fname">read</b>() and <b class="fname">write</b>(), except that <i class="farg">handle</i> is passed to the former routines as the first parameter. Note: the XDR stream's <i class="farg">op</i> field must be set by the caller. Warning: this XDR stream implements an intermediate record stream. Therefore there are additional bytes in the stream to provide record boundary information.<div class="spacer">
</div>
<b class="fname">xdrrec_endofrecord</b>() is a routine which can be invoked only on streams created by <b class="fname">xdrrec_create</b>(). The data in the output buffer is marked as a completed record, and the output buffer is optionally written out if <i class="farg">sendnow</i> is non-zero. This routine returns one if it succeeds, zero otherwise.<div class="spacer">
</div>
<b class="fname">xdrrec_eof</b>() is a routine which can be invoked only on streams created by <b class="fname">xdrrec_create</b>(). After consuming the rest of the current record in the stream, this routine returns one if the stream has no more input, zero otherwise.<div class="spacer">
</div>
<b class="fname">xdrrec_skiprecord</b>() is a routine which can be invoked only on streams created by <b class="fname">xdrrec_create</b>(). It tells the XDR implementation that the rest of the current record in the stream's input buffer should be discarded. This routine returns one if it succeeds, zero otherwise.<div class="spacer">
</div>
<b class="fname">xdr_reference</b>() is a primitive that provides pointer chasing within structures. The parameter <i class="farg">pp</i> is the address of the pointer; <i class="farg">size</i> is the size of the structure that <i class="farg">*pp</i> points to; and <i class="farg">proc</i> is an XDR procedure that filters the structure between its C form and its external representation. This routine returns one if it succeeds, zero otherwise. Warning: this routine does not understand <span class="define">NULL</span> pointers. Use <b class="fname">xdr_pointer</b>() instead.<div class="spacer">
</div>
<b class="fname">xdr_setpos</b>() is a macro that invokes the set position routine associated with the XDR stream <i class="farg">xdrs</i>. The parameter <i class="farg">pos</i> is a position value obtained from <b class="fname">xdr_getpos</b>(). This routine returns one if the XDR stream could be repositioned, and zero otherwise. Warning: it is difficult to reposition some types of XDR streams, so this routine may fail with one type of stream and succeed with another.<div class="spacer">
</div>
<b class="fname">xdr_short</b>() is a filter primitive that translates between C <code class="lit">short</code> integers and their external representations. This routine returns one if it succeeds, zero otherwise.<div class="spacer">
</div>
<b class="fname">xdrstdio_create</b>() is a routine which initializes the XDR stream object pointed to by <i class="farg">xdrs</i>. The XDR stream data is written to, or read from, the Standard I/O stream <i class="farg">file</i>. The parameter <i class="farg">op</i> determines the direction of the XDR stream (either <span class="define">XDR_ENCODE</span>, <span class="define">XDR_DECODE</span>, or <span class="define">XDR_FREE</span>). Warning: the destroy routine associated with such XDR streams calls <b class="fname">fflush</b>() on the <i class="farg">file</i> stream, but never <b class="fname">fclose</b>().<div class="spacer">
</div>
<b class="fname">xdr_string</b>() is a filter primitive that translates between C strings and their corresponding external representations. Strings cannot be longer than <i class="farg">maxsize</i>. Note: <i class="farg">sp</i> is the address of the string's pointer. This routine returns one if it succeeds, zero otherwise.<div class="spacer">
</div>
<b class="fname">xdr_u_char</b>() is a filter primitive that translates between <code class="lit">unsigned</code> C characters and their external representations. This routine returns one if it succeeds, zero otherwise.<div class="spacer">
</div>
<b class="fname">xdr_u_int</b>() is a filter primitive that translates between C <code class="lit">unsigned</code> integers and their external representations. This routine returns one if it succeeds, zero otherwise.<div class="spacer">
</div>
<b class="fname">xdr_u_long</b>() is a filter primitive that translates between C <code class="lit">unsigned long</code> integers and their external representations. This routine returns one if it succeeds, zero otherwise.<div class="spacer">
</div>
<b class="fname">xdr_u_int64_t</b>() is a filter primitive that translates between C <code class="lit">u_int64_t</code> integers and their external representations. This routine returns one if it succeeds, zero otherwise.<div class="spacer">
</div>
<b class="fname">xdr_u_short</b>() is a filter primitive that translates between C <code class="lit">unsigned short</code> integers and their external representations. This routine returns one if it succeeds, zero otherwise.<div class="spacer">
</div>
<b class="fname">xdr_union</b>() is a filter primitive that translates between a discriminated C <code class="lit">union</code> and its corresponding external representation. It first translates the discriminant of the union located at <i class="farg">dscmp</i>. This discriminant is always an <code class="lit">enum_t</code>. Next the union located at <i class="farg">unp</i> is translated. The parameter <i class="farg">choices</i> is a pointer to an array of <code class="lit">struct xdr_discrim</code> structures. Each structure contains an ordered pair of [<i class="ftype">value</i>, <i class="ftype">proc ].</i> If the union's discriminant is equal to the associated <i class="farg">value</i>, then the <i class="farg">proc</i> is called to translate the union. The end of the <code class="lit">struct xdr_discrim</code> structure array is denoted by a routine of value <span class="define">NULL</span>. If the discriminant is not found in the <i class="farg">choices</i> array, then the <b class="fname">(*defaultarm)</b>() procedure is called (if it is not <span class="define">NULL</span>). Returns one if it succeeds, zero otherwise.<div class="spacer">
</div>
<b class="fname">xdr_vector</b>() is a filter primitive that translates between fixed-length arrays and their corresponding external representations. The parameter <i class="farg">arrp</i> is the address of the pointer to the array, while <i class="farg">size</i> is the element count of the array. The parameter <i class="farg">elsize</i> is the size of each of the array's elements, and <i class="farg">elproc</i> is an XDR filter that translates between the array elements' C form, and their external representation. This routine returns one if it succeeds, zero otherwise.<div class="spacer">
</div>
<b class="fname">xdr_void</b>() is a routine which always returns one. It may be passed to RPC routines that require a function parameter, but where nothing is to be done.<div class="spacer">
</div>
<b class="fname">xdr_wrapstring</b>() is a primitive that calls <b class="name">xdr_string</b>(<i class="farg">xdrs</i>, <i class="farg">sp</i>, <span class="define">MAXUN.UNSIGNED</span>) where <span class="define">MAXUN.UNSIGNED</span> is the maximum value of an unsigned integer. <b class="fname">xdr_wrapstring</b>() is handy because the RPC package passes a maximum of two XDR routines as parameters, and <b class="fname">xdr_string</b>(), one of the most frequently used primitives, requires three. Returns one if it succeeds, zero otherwise.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html3/rpc.html">rpc(3)</a><div class="spacer">
</div>
<span class="ref"><span class="ref-title">eXternal Data Representation Standard: Protocol Specification</span>.</span><div class="spacer">
</div>
<span class="ref"><span class="ref-title">eXternal Data Representation: Sun Technical Notes</span>.</span></div>
<div class="section">
<h1 id="x5354414e4441524453">STANDARDS</h1> <span class="ref"><span class="ref-title">XDR: External Data Representation Standard</span>, <span class="ref-rep">RFC 1014</span>, <span class="ref-corp">Sun Microsystems, Inc.</span>, <span class="ref-date">June 1987</span>.</span></div>
</div>
</body>
</html>

