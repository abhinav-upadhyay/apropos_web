<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
CALLRPC(3)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">callrpc</b>, <b class="name">clnt_broadcast</b>, <b class="name">clnt_call</b>, <b class="name">clnt_control</b>, <b class="name">clnt_create</b>, <b class="name">clnt_destroy</b>, <b class="name">clnt_freeres</b>, <b class="name">clnt_pcreateerror</b>, <b class="name">clnt_perrno</b>, <b class="name">clnt_perror</b>, <b class="name">clnt_spcreateerror</b>, <b class="name">clnt_sperrno</b>, <b class="name">clnt_sperror</b>, <b class="name">clntraw_create</b>, <b class="name">clnttcp_create</b>, <b class="name">clntudp_bufcreate</b>, <b class="name">clntudp_create</b>, <b class="name">clnt_geterr</b>, <b class="name">get_myaddress</b>, <b class="name">pmap_getmaps</b>, <b class="name">pmap_getport</b>, <b class="name">pmap_rmtcall</b>, <b class="name">pmap_set</b>, <b class="name">pmap_unset</b>, <b class="name">registerrpc</b>, <b class="name">rpc_createerr</b>, <b class="name">svc_destroy</b>, <b class="name">svc_fds</b>, <b class="name">svc_fdset</b>, <b class="name">svc_freeargs</b>, <b class="name">svc_getargs</b>, <b class="name">svc_getcaller</b>, <b class="name">svc_getreq</b>, <b class="name">svc_getreq_common</b>, <b class="name">svc_getreq_poll</b>, <b class="name">svc_getreqset</b>, <b class="name">svc_getreqset2</b>, <b class="name">svc_register</b>, <b class="name">svc_max_pollfd</b>, <b class="name">svc_pollfd</b>, <b class="name">svc_run</b>, <b class="name">svc_sendreply</b>, <b class="name">svc_unregister</b>, <b class="name">svcerr_auth</b>, <b class="name">svcerr_decode</b>, <b class="name">svcerr_noproc</b>, <b class="name">svcerr_noprog</b>, <b class="name">svcerr_progvers</b>, <b class="name">svcerr_systemerr</b>, <b class="name">svcerr_weakauth</b>, <b class="name">svcfd_create</b>, <b class="name">svcraw_create</b>, <b class="name">svctcp_create</b>, <b class="name">svcudp_create</b>, <b class="name">svcudp_bufcreate</b>, <b class="name">xdr_accepted_reply</b>, <b class="name">xdr_authunix_parms</b>, <b class="name">xdr_callhdr</b>, <b class="name">xdr_callmsg</b>, <b class="name">xdr_opaque_auth</b>, <b class="name">xdr_pmap</b>, <b class="name">xdr_pmaplist</b>, <b class="name">xdr_rejected_reply</b>, <b class="name">xdr_replymsg</b>, <b class="name">xprt_register</b>, <b class="name">xprt_unregister</b> &#8212; <span class="desc">library routines for remote procedure calls</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">rpc/rpc.h</a>&gt;</b><div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">callrpc</b>(<i class="farg" style="white-space:nowrap;">char *host</i>, <i class="farg" style="white-space:nowrap;">u_long prognum</i>, <i class="farg" style="white-space:nowrap;">u_long versnum</i>, <i class="farg" style="white-space:nowrap;">u_long procnum</i>, <i class="farg" style="white-space:nowrap;">xdrproc_t inproc</i>, <i class="farg" style="white-space:nowrap;">char *in</i>, <i class="farg" style="white-space:nowrap;">xdrproc_t outproc</i>, <i class="farg" style="white-space:nowrap;">char *out</i>);<div class="spacer">
</div>
<i class="ftype">enum clnt_stat</i><br/>
<b class="fname">clnt_broadcast</b>(<i class="farg" style="white-space:nowrap;">u_long prognum</i>, <i class="farg" style="white-space:nowrap;">u_long versnum</i>, <i class="farg" style="white-space:nowrap;">u_long procnum</i>, <i class="farg" style="white-space:nowrap;">xdrproc_t inproc</i>, <i class="farg" style="white-space:nowrap;">char *in</i>, <i class="farg" style="white-space:nowrap;">xdrproc_t outproc</i>, <i class="farg" style="white-space:nowrap;">char *out</i>, <i class="farg" style="white-space:nowrap;">resultproc_t eachresult</i>);<div class="spacer">
</div>
<i class="ftype">enum clnt_stat</i><br/>
<b class="fname">clnt_call</b>(<i class="farg" style="white-space:nowrap;">CLIENT *clnt</i>, <i class="farg" style="white-space:nowrap;">u_long procnum</i>, <i class="farg" style="white-space:nowrap;">xdrproc_t inproc</i>, <i class="farg" style="white-space:nowrap;">char *in</i>, <i class="farg" style="white-space:nowrap;">xdrproc_t outproc</i>, <i class="farg" style="white-space:nowrap;">char *out</i>, <i class="farg" style="white-space:nowrap;">struct timeval tout</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">clnt_destroy</b>(<i class="farg" style="white-space:nowrap;">CLIENT *clnt</i>);<div class="spacer">
</div>
<i class="ftype">CLIENT *</i><br/>
<b class="fname">clnt_create</b>(<i class="farg" style="white-space:nowrap;">char *host</i>, <i class="farg" style="white-space:nowrap;">u_long prog</i>, <i class="farg" style="white-space:nowrap;">u_long vers</i>, <i class="farg" style="white-space:nowrap;">char *proto</i>);<div class="spacer">
</div>
<i class="ftype">bool_t</i><br/>
<b class="fname">clnt_control</b>(<i class="farg" style="white-space:nowrap;">CLIENT *cl</i>, <i class="farg" style="white-space:nowrap;">int req</i>, <i class="farg" style="white-space:nowrap;">char *info</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">clnt_freeres</b>(<i class="farg" style="white-space:nowrap;">CLIENT *clnt</i>, <i class="farg" style="white-space:nowrap;">xdrproc_t outproc</i>, <i class="farg" style="white-space:nowrap;">char *out</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">clnt_geterr</b>(<i class="farg" style="white-space:nowrap;">CLIENT *clnt</i>, <i class="farg" style="white-space:nowrap;">struct rpc_err *errp</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">clnt_pcreateerror</b>(<i class="farg" style="white-space:nowrap;">char *s</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">clnt_perrno</b>(<i class="farg" style="white-space:nowrap;">enum clnt_stat stat</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">clnt_perror</b>(<i class="farg" style="white-space:nowrap;">CLIENT *clnt</i>, <i class="farg" style="white-space:nowrap;">char *s</i>);<div class="spacer">
</div>
<i class="ftype">char *</i><br/>
<b class="fname">clnt_spcreateerror</b>(<i class="farg" style="white-space:nowrap;">char *s</i>);<div class="spacer">
</div>
<i class="ftype">char *</i><br/>
<b class="fname">clnt_sperrno</b>(<i class="farg" style="white-space:nowrap;">enum clnt_stat stat</i>);<div class="spacer">
</div>
<i class="ftype">char *</i><br/>
<b class="fname">clnt_sperror</b>(<i class="farg" style="white-space:nowrap;">CLIENT *rpch</i>, <i class="farg" style="white-space:nowrap;">char *s</i>);<div class="spacer">
</div>
<i class="ftype">CLIENT *</i><br/>
<b class="fname">clntraw_create</b>(<i class="farg" style="white-space:nowrap;">u_long prognum</i>, <i class="farg" style="white-space:nowrap;">u_long versnum</i>);<div class="spacer">
</div>
<i class="ftype">CLIENT *</i><br/>
<b class="fname">clnttcp_create</b>(<i class="farg" style="white-space:nowrap;">struct sockaddr_in *addr</i>, <i class="farg" style="white-space:nowrap;">u_long prognum</i>, <i class="farg" style="white-space:nowrap;">u_long versnum</i>, <i class="farg" style="white-space:nowrap;">int *sockp</i>, <i class="farg" style="white-space:nowrap;">u_int sendsz</i>, <i class="farg" style="white-space:nowrap;">u_int recvsz</i>);<div class="spacer">
</div>
<i class="ftype">CLIENT *</i><br/>
<b class="fname">clntudp_create</b>(<i class="farg" style="white-space:nowrap;">struct sockaddr_in *addr</i>, <i class="farg" style="white-space:nowrap;">u_long prognum</i>, <i class="farg" style="white-space:nowrap;">u_long versnum</i>, <i class="farg" style="white-space:nowrap;">struct timeval wait</i>, <i class="farg" style="white-space:nowrap;">int *sockp</i>);<div class="spacer">
</div>
<i class="ftype">CLIENT *</i><br/>
<b class="fname">clntudp_bufcreate</b>(<i class="farg" style="white-space:nowrap;">struct sockaddr_in *addr</i>, <i class="farg" style="white-space:nowrap;">u_long prognum</i>, <i class="farg" style="white-space:nowrap;">u_long versnum</i>, <i class="farg" style="white-space:nowrap;">struct timeval wait</i>, <i class="farg" style="white-space:nowrap;">int *sockp</i>, <i class="farg" style="white-space:nowrap;">unsigned int sendsize</i>, <i class="farg" style="white-space:nowrap;">unsigned int recosize</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">get_myaddress</b>(<i class="farg" style="white-space:nowrap;">struct sockaddr_in *addr</i>);<div class="spacer">
</div>
<i class="ftype">struct pmaplist *</i><br/>
<b class="fname">pmap_getmaps</b>(<i class="farg" style="white-space:nowrap;">struct sockaddr_in *addr</i>);<div class="spacer">
</div>
<i class="ftype">u_short</i><br/>
<b class="fname">pmap_getport</b>(<i class="farg" style="white-space:nowrap;">struct sockaddr_in *addr</i>, <i class="farg" style="white-space:nowrap;">u_long prognum</i>, <i class="farg" style="white-space:nowrap;">u_long versnum</i>, <i class="farg" style="white-space:nowrap;">u_long protocol</i>);<div class="spacer">
</div>
<i class="ftype">enum clnt_stat</i><br/>
<b class="fname">pmap_rmtcall</b>(<i class="farg" style="white-space:nowrap;">struct sockaddr_in *</i>, <i class="farg" style="white-space:nowrap;">u_long prog</i>, <i class="farg" style="white-space:nowrap;">u_long vers</i>, <i class="farg" style="white-space:nowrap;">u_long proc</i>, <i class="farg" style="white-space:nowrap;">xdrproc_t inp</i>, <i class="farg" style="white-space:nowrap;">char *in</i>, <i class="farg" style="white-space:nowrap;">xdrproc_t outp</i>, <i class="farg" style="white-space:nowrap;">char *out</i>, <i class="farg" style="white-space:nowrap;">struct timeval tv</i>, <i class="farg" style="white-space:nowrap;">u_long *portp</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">pmap_set</b>(<i class="farg" style="white-space:nowrap;">u_long prognum</i>, <i class="farg" style="white-space:nowrap;">u_long versnum</i>, <i class="farg" style="white-space:nowrap;">u_int protocol</i>, <i class="farg" style="white-space:nowrap;">int port</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">pmap_unset</b>(<i class="farg" style="white-space:nowrap;">u_long prognum</i>, <i class="farg" style="white-space:nowrap;">u_long versnum</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">registerrpc</b>(<i class="farg" style="white-space:nowrap;">u_long prognum</i>, <i class="farg" style="white-space:nowrap;">u_long versnum</i>, <i class="farg" style="white-space:nowrap;">u_long procnum</i>, <i class="farg" style="white-space:nowrap;">char *(*procname)() </i>, <i class="farg" style="white-space:nowrap;">xdrproc_t inproc</i>, <i class="farg" style="white-space:nowrap;">xdrproc_t outproc</i>);<div class="spacer">
</div>
<span class="type">struct rpc_createerr rpc_createerr</span>;<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">svc_destroy</b>(<i class="farg" style="white-space:nowrap;">SVCXPRT *xprt</i>);<div class="spacer">
</div>
<span class="type">struct pollfd *svc_pollfd</span>;<br/>
<span class="type">int svc_max_pollfd</span>;<br/>
<span class="type">fd_set svc_fdset</span>;<br/>
<span class="type">fd_set *__svc_fdset</span>;<br/>
<span class="type">int __svc_fdsetsize</span>;<br/>
<span class="type">int svc_fds</span>;<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">svc_freeargs</b>(<i class="farg" style="white-space:nowrap;">SVCXPRT *xprt</i>, <i class="farg" style="white-space:nowrap;">xdrproc_t inproc</i>, <i class="farg" style="white-space:nowrap;">char *in</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">svc_getargs</b>(<i class="farg" style="white-space:nowrap;">SVCXPRT *xprt</i>, <i class="farg" style="white-space:nowrap;">xdrproc_t inproc</i>, <i class="farg" style="white-space:nowrap;">char *in</i>);<div class="spacer">
</div>
<i class="ftype">struct sockaddr_in *</i><br/>
<b class="fname">svc_getcaller</b>(<i class="farg" style="white-space:nowrap;">SVCXPRT *xprt</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">svc_getreq_common</b>(<i class="farg" style="white-space:nowrap;">int fd</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">svc_getreq_poll</b>(<i class="farg" style="white-space:nowrap;">struct pollfd *pfds</i>, <i class="farg" style="white-space:nowrap;">const int pollretval</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">svc_getreqset</b>(<i class="farg" style="white-space:nowrap;">fd_set *rdfds</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">svc_getreqset2</b>(<i class="farg" style="white-space:nowrap;">fd_set *rdfds</i>, <i class="farg" style="white-space:nowrap;">int width</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">svc_getreq</b>(<i class="farg" style="white-space:nowrap;">int rdfds</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">svc_register</b>(<i class="farg" style="white-space:nowrap;">SVCXPRT *xprt</i>, <i class="farg" style="white-space:nowrap;">u_long prognum</i>, <i class="farg" style="white-space:nowrap;">u_long versnum</i>, <i class="farg" style="white-space:nowrap;">void (*dispatch)()</i>, <i class="farg" style="white-space:nowrap;">u_long protocol</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">svc_run</b>(<i class="farg" style="white-space:nowrap;">void</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">svc_sendreply</b>(<i class="farg" style="white-space:nowrap;">SVCXPRT *xprt</i>, <i class="farg" style="white-space:nowrap;">xdrproc_t outproc</i>, <i class="farg" style="white-space:nowrap;">char *out</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">svc_unregister</b>(<i class="farg" style="white-space:nowrap;">u_long prognum</i>, <i class="farg" style="white-space:nowrap;">u_long versnum</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">svcerr_auth</b>(<i class="farg" style="white-space:nowrap;">SVCXPRT *xprt</i>, <i class="farg" style="white-space:nowrap;">enum auth_stat why</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">svcerr_decode</b>(<i class="farg" style="white-space:nowrap;">SVCXPRT *xprt</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">svcerr_noproc</b>(<i class="farg" style="white-space:nowrap;">SVCXPRT *xprt</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">svcerr_noprog</b>(<i class="farg" style="white-space:nowrap;">SVCXPRT *xprt</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">svcerr_progvers</b>(<i class="farg" style="white-space:nowrap;">SVCXPRT *xprt</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">svcerr_systemerr</b>(<i class="farg" style="white-space:nowrap;">SVCXPRT *xprt</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">svcerr_weakauth</b>(<i class="farg" style="white-space:nowrap;">SVCXPRT *xprt</i>);<div class="spacer">
</div>
<i class="ftype">SVCXPRT *</i><br/>
<b class="fname">svcraw_create</b>(<i class="farg" style="white-space:nowrap;">void</i>);<div class="spacer">
</div>
<i class="ftype">SVCXPRT *</i><br/>
<b class="fname">svctcp_create</b>(<i class="farg" style="white-space:nowrap;">int sock</i>, <i class="farg" style="white-space:nowrap;">u_int send_buf_size</i>, <i class="farg" style="white-space:nowrap;">u_int recv_buf_size</i>);<div class="spacer">
</div>
<i class="ftype">SVCXPRT *</i><br/>
<b class="fname">svcfd_create</b>(<i class="farg" style="white-space:nowrap;">int fd</i>, <i class="farg" style="white-space:nowrap;">u_int sendsize</i>, <i class="farg" style="white-space:nowrap;">u_int recvsize</i>);<div class="spacer">
</div>
<i class="ftype">SVCXPRT *</i><br/>
<b class="fname">svcudp_create</b>(<i class="farg" style="white-space:nowrap;">int sock</i>);<div class="spacer">
</div>
<i class="ftype">SVCXPRT *</i><br/>
<b class="fname">svcudp_bufcreate</b>(<i class="farg" style="white-space:nowrap;">int sock</i>, <i class="farg" style="white-space:nowrap;">u_int sendsz</i>, <i class="farg" style="white-space:nowrap;">u_int recvsz</i>);<div class="spacer">
</div>
<i class="ftype">bool_t</i><br/>
<b class="fname">xdr_accepted_reply</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">struct accepted_reply *ar</i>);<div class="spacer">
</div>
<i class="ftype">bool_t</i><br/>
<b class="fname">xdr_authunix_parms</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">struct authunix_parms *aupp</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">xdr_callhdr</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">struct rpc_msg *chdr</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">xdr_callmsg</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">struct rpc_msg *cmsg</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">xdr_opaque_auth</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">struct opaque_auth *ap</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">xdr_pmap</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">struct pmap *regs</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">xdr_pmaplist</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">struct pmaplist **rp</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">xdr_rejected_reply</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">struct rejected_reply *rr</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">xdr_replymsg</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">struct rpc_msg *rmsg</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">xprt_register</b>(<i class="farg" style="white-space:nowrap;">SVCXPRT *xprt</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">xprt_unregister</b>(<i class="farg" style="white-space:nowrap;">SVCXPRT *xprt</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> These routines allow C programs to make procedure calls on other machines across the network. First, the client calls a procedure to send a data packet to the server. Upon receipt of the packet, the server calls a dispatch routine to perform the requested service, and then sends back a reply. Finally, the procedure call returns to the client.<div class="spacer">
</div>
<b class="fname">callrpc</b>() calls the remote procedure associated with <i class="farg">prognum</i>, <i class="farg">versnum</i>, and <i class="farg">procnum</i> on the machine, <i class="farg">host</i>. The parameter <i class="farg">in</i> is the address of the procedure's argument(s), and <i class="farg">out</i> is the address of where to place the result(s); <i class="farg">inproc</i> is used to encode the procedure's parameters, and <i class="farg">outproc</i> is used to decode the procedure's results. This routine returns zero if it succeeds, or the value of <i class="farg">enum clnt_stat</i> cast to an integer if it fails. The routine <b class="fname">clnt_perrno</b>() is handy for translating failure statuses into messages.<div class="spacer">
</div>
<span class="symb">Warning:</span> calling remote procedures with this routine uses UDP/IP as a transport; see <b class="fname">clntudp_create</b>() for restrictions. You do not have control of timeouts or authentication using this routine.<div class="spacer">
</div>
<b class="fname">clnt_broadcast</b>() is like <b class="fname">callrpc</b>(), except the call message is broadcast to all locally connected broadcast nets. Each time it receives a response, this routine calls <i class="farg">eachresult</i>, whose form is:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
<i class="ftype">int</i> 
<b class="fname">eachresult</b>(<i class="farg">char *out</i>, <i class="farg">struct sockaddr_in *addr</i>)</pre>
<div class="spacer">
</div>
where <i class="farg">out</i> is the same as <i class="farg">out</i> passed to <b class="fname">clnt_broadcast</b>(), except that the remote procedure's output is decoded there; <i class="farg">addr</i> points to the address of the machine that sent the results. If <i class="farg">eachresult</i> returns zero, <b class="fname">clnt_broadcast</b>() waits for more replies; otherwise it returns with appropriate status.<div class="spacer">
</div>
<span class="symb">Warning:</span> broadcast sockets are limited in size to the maximum transfer unit of the data link. For Ethernet, this value is 1500 bytes.<div class="spacer">
</div>
<b class="fname">clnt_call</b>() is a macro that calls the remote procedure <i class="farg">procnum</i> associated with the client handle, <i class="farg">clnt</i>, which is obtained with an RPC client creation routine such as <b class="fname">clnt_create</b>(). The parameter <i class="farg">in</i> is the address of the procedure's argument(s), and <i class="farg">out</i> is the address of where to place the result(s); <i class="farg">inproc</i> is used to encode the procedure's parameters, and <i class="farg">outproc</i> is used to decode the procedure's results; <i class="farg">tout</i> is the time allowed for results to come back.<div class="spacer">
</div>
<b class="fname">clnt_destroy</b>() is a macro that destroys the client's RPC handle. Destruction usually involves deallocation of private data structures, including <i class="farg">clnt</i> itself. Use of <i class="farg">clnt</i> is undefined after calling <b class="fname">clnt_destroy</b>(). If the RPC library opened the associated socket, it will close it also. Otherwise, the socket remains open.<div class="spacer">
</div>
<b class="fname">clnt_create</b>() is a generic client creation routine. <i class="farg">host</i> identifies the name of the remote host where the server is located. <i class="farg">proto</i> indicates which kind of transport protocol to use. The currently supported values for this field are &#8220;udp&#8221; and &#8220;tcp&#8221;. Default timeouts are set, but can be modified using <b class="fname">clnt_control</b>(). This routine returns <span class="define">NULL</span> if it fails.<div class="spacer">
</div>
<span class="symb">Warning:</span> Using UDP has its shortcomings. Since UDP-based RPC messages can only hold up to 8 Kbytes of encoded data, this transport cannot be used for procedures that take large arguments or return huge results.<div class="spacer">
</div>
<b class="fname">clnt_control</b>() is a macro used to change or retrieve various information about a client object. <i class="farg">req</i> indicates the type of operation, and <i class="farg">info</i> is a pointer to the information. For both UDP and TCP, the supported values of <i class="farg">req</i> and their argument types and what they do are:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
CLSET_TIMEOUT	struct timeval	set total timeout 
CLGET_TIMEOUT	struct timeval	get total timeout</pre>
<div class="spacer">
</div>
<span class="symb">Note:</span> if you set the timeout using <b class="fname">clnt_control</b>(), the timeout parameter passed to <b class="fname">clnt_call</b>() will be ignored in all future calls.<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
CLGET_SERVER_ADDR	struct sockaddr_in 	get server's address</pre>
<div class="spacer">
</div>
The following operations are valid for UDP only:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
CLSET_RETRY_TIMEOUT   struct timeval	set the retry timeout 
CLGET_RETRY_TIMEOUT   struct timeval	get the retry timeout</pre>
<div class="spacer">
</div>
The retry timeout is the time that UDP RPC waits for the server to reply before retransmitting the request.<div class="spacer">
</div>
<b class="fname">clnt_freeres</b>() is a macro that frees any data allocated by the RPC/XDR system when it decoded the results of an RPC call. The parameter <i class="farg">out</i> is the address of the results, and <i class="farg">outproc</i> is the XDR routine describing the results. This routine returns one if the results were successfully freed, and zero otherwise.<div class="spacer">
</div>
<b class="fname">clnt_geterr</b>() is a macro that copies the error structure out of the client handle to the structure at address <i class="farg">errp</i>.<div class="spacer">
</div>
<b class="fname">clnt_pcreateerror</b>() prints a message to standard error indicating why a client RPC handle could not be created. The message is prepended with string <i class="farg">s</i> and a colon. Used when a <b class="fname">clnt_create</b>(), <b class="fname">clntraw_create</b>(), <b class="fname">clnttcp_create</b>(), or <b class="fname">clntudp_create</b>() call fails.<div class="spacer">
</div>
<b class="fname">clnt_perrno</b>() prints a message to standard error corresponding to the condition indicated by <i class="farg">stat</i>. Used after <b class="fname">callrpc</b>().<div class="spacer">
</div>
<b class="fname">clnt_perror</b>() prints a message to standard error indicating why an RPC call failed; <i class="farg">clnt</i> is the handle used to do the call. The message is prepended with string <i class="farg">s</i> and a colon. Used after <b class="fname">clnt_call</b>().<div class="spacer">
</div>
<b class="fname">clnt_spcreateerror</b>() is like <b class="fname">clnt_pcreateerror</b>(), except that it returns a string instead of printing to the standard error.<div class="spacer">
</div>
<span class="symb">Bugs:</span> returns pointer to static data that is overwritten on each call.<div class="spacer">
</div>
<b class="fname">clnt_sperrno</b>() takes the same arguments as <b class="fname">clnt_perrno</b>(), but instead of sending a message to the standard error indicating why an RPC call failed, returns a pointer to a string which contains the message. Unlike <b class="fname">clnt_perror</b>(), it does not append a newline character to the end of the message.<div class="spacer">
</div>
<b class="fname">clnt_sperrno</b>() is used instead of <b class="fname">clnt_perrno</b>() if the program does not have a standard error (as a program running as a server quite likely does not), or if the programmer does not want the message to be output with <b class="fname">printf</b>(), or if a message format different than that supported by <b class="fname">clnt_perrno</b>() is to be used.<div class="spacer">
</div>
<span class="symb">Note:</span> unlike <b class="fname">clnt_sperror</b>() and <b class="fname">clnt_spcreaterror</b>(), <b class="fname">clnt_sperrno</b>() returns a pointer to static data, but the result will not get overwritten on each call.<div class="spacer">
</div>
<b class="fname">clnt_sperror</b>() is like <b class="fname">clnt_perror</b>(), except that (like <b class="fname">clnt_sperrno</b>()) it returns a string instead of printing to standard error.<div class="spacer">
</div>
<span class="symb">Bugs:</span> returns pointer to static data that is overwritten on each call.<div class="spacer">
</div>
<b class="fname">clntraw_create</b>() is a routine which creates a toy RPC client for the remote program <i class="farg">prognum</i>, version <i class="farg">versnum</i>. The transport used to pass messages to the service is actually a buffer within the process's address space, so the corresponding RPC server should live in the same address space; see <b class="fname">svcraw_create</b>(). This allows simulation of RPC and acquisition of RPC overheads, such as round trip times, without any kernel interference. This routine returns <span class="define">NULL</span> if it fails.<div class="spacer">
</div>
<b class="fname">clnttcp_create</b>() is a routine which creates an RPC client for the remote program <i class="farg">prognum</i>, version <i class="farg">versnum</i>; the client uses TCP/IP as a transport. The remote program is located at Internet address <i class="farg">*addr</i>. If <i class="farg">addr-&gt;sin_port</i> is zero, then it is set to the actual port that the remote program is listening on (the remote <a class="link-man" href="../html8/portmap.html">portmap(8)</a> service is consulted for this information). The parameter <i class="farg">sockp</i> is a socket; if it is <i class="farg">RPC_ANYSOCK</i>, then this routine opens a new one and sets <i class="farg">sockp</i>. Since TCP-based RPC uses buffered I/O, the user may specify the size of the send and receive buffers with the parameters <i class="farg">sendsz</i> and <i class="farg">recvsz</i>; values of zero choose suitable defaults. This routine returns <span class="define">NULL</span> if it fails.<div class="spacer">
</div>
<b class="fname">clntudp_create</b>() is a routine which creates an RPC client for the remote program <i class="farg">prognum</i>, on <i class="farg">versnum</i>; the client uses use UDP/IP as a transport. The remote program is located at Internet address <i class="farg">addr</i>. If <i class="farg">addr-&gt;sin_port</i> is zero, then it is set to actual port that the remote program is listening on (the remote <a class="link-man" href="../html8/portmap.html">portmap(8)</a> service is consulted for this information). The parameter <i class="farg">sockp</i> is a socket; if it is <i class="farg">RPC_ANYSOCK</i>, then this routine opens a new one and sets <i class="farg">sockp</i>. The UDP transport resends the call message in intervals of <i class="farg">wait</i> time until a response is received or until the call times out. The total time for the call to time out is specified by <b class="fname">clnt_call</b>(). This routine returns <span class="define">NULL</span> if it fails.<div class="spacer">
</div>
<b class="fname">clntudp_bufcreate</b>() is like <b class="fname">clntudp_create</b>(), except that it allows the user to specify the maximum packet size for sending and receiving UDP-based RPC messages instead of using the default size limit of 8800 bytes.<div class="spacer">
</div>
<b class="fname">get_myaddress</b>() stuffs the machine's IP address into <i class="farg">*addr</i>, without consulting the library routines that deal with <i class="file">/etc/hosts</i>. The port number is always set to <i class="farg">htons(PMAPPORT)</i>. Returns zero on success, non-zero on failure.<div class="spacer">
</div>
<b class="fname">pmap_getmaps</b>() is a function interface to the <a class="link-man" href="../html8/portmap.html">portmap(8)</a> service, which returns a list of the current RPC program-to-port mappings on the host located at IP address <i class="farg">*addr</i>. This routine can return <span class="define">NULL</span>. The command &#8220;<code class="lit">rpcinfo -p</code>&#8221; uses this routine.<div class="spacer">
</div>
<b class="fname">pmap_getport</b>() is a user interface to the <a class="link-man" href="../html8/portmap.html">portmap(8)</a> service, which returns the port number on which waits a service that supports program number <i class="farg">prognum</i>, version <i class="farg">versnum</i>, and speaks the transport protocol associated with <i class="farg">protocol</i>. The value of <i class="farg">protocol</i> is most likely <span class="define">IPPROTO_UDP</span> or <span class="define">IPPROTO_TCP</span>. A return value of zero means that the mapping does not exist or that the RPC system failured to contact the remote <a class="link-man" href="../html8/portmap.html">portmap(8)</a> service. In the latter case, the global variable <b class="var">rpc_createerr</b> contains the RPC status.<div class="spacer">
</div>
<b class="fname">pmap_rmtcall</b>() is a user interface to the <a class="link-man" href="../html8/portmap.html">portmap(8)</a> service, which instructs <a class="link-man" href="../html8/portmap.html">portmap(8)</a> on the host at IP address <i class="farg">*addr</i> to make an RPC call on your behalf to a procedure on that host. The parameter <i class="farg">*portp</i> will be modified to the program's port number if the procedure succeeds. The definitions of other parameters are discussed in <b class="fname">callrpc</b>() and <b class="fname">clnt_call</b>(). This procedure should be used for a &#8220;ping&#8221; and nothing else. See also <b class="fname">clnt_broadcast</b>().<div class="spacer">
</div>
<b class="fname">pmap_set</b>() is a user interface to the <a class="link-man" href="../html8/portmap.html">portmap(8)</a> service, which establishes a mapping between the triple [<i class="farg">prognum</i>, <i class="farg">versnum</i>, <i class="farg">protocol</i>] and <i class="farg">port</i> on the machine's <a class="link-man" href="../html8/portmap.html">portmap(8)</a> service. The value of <i class="farg">protocol</i> is most likely <span class="define">IPPROTO_UDP</span> or <span class="define">IPPROTO_TCP</span>. This routine returns one if it succeeds, zero otherwise. Automatically done by <b class="fname">svc_register</b>().<div class="spacer">
</div>
<b class="fname">pmap_unset</b>() is a user interface to the <a class="link-man" href="../html8/portmap.html">portmap(8)</a> service, which destroys all mapping between the triple [<i class="farg">prognum</i>, <i class="farg">versnum</i>, <i class="farg">*</i>] and <i class="farg">ports</i> on the machine's <a class="link-man" href="../html8/portmap.html">portmap(8)</a> service. This routine returns one if it succeeds, zero otherwise.<div class="spacer">
</div>
<b class="fname">registerrpc</b>() will register a procedure <i class="farg">procname</i> with the RPC service package. If a request arrives for program <i class="farg">prognum</i>, version <i class="farg">versnum</i>, and procedure <i class="farg">procnum</i>, <i class="farg">procname</i> is called with a pointer to its parameter(s); <i class="farg">procname</i> should return a pointer to its static result(s); <i class="farg">inproc</i> is used to decode the parameters while <i class="farg">outproc</i> is used to encode the results. This routine returns zero if the registration succeeded, -1 otherwise.<div class="spacer">
</div>
<span class="symb">Warning:</span> remote procedures registered in this form are accessed using the UDP/IP transport; see <b class="fname">svcudp_create</b>() for restrictions.<div class="spacer">
</div>
<b class="var">rpc_createerr</b> is a global variable whose value is set by any RPC client creation routine that does not succeed. Use the routine <b class="fname">clnt_pcreateerror</b>() to print the reason why.<div class="spacer">
</div>
<b class="fname">svc_destroy</b>() is a macro that destroys the RPC service transport handle, <i class="farg">xprt</i>. Destruction usually involves deallocation of private data structures, including <i class="farg">xprt</i> itself. Use of <i class="farg">xprt</i> is undefined after calling this routine.<div class="spacer">
</div>
<b class="var">svc_pollfd</b> is a global variable reflecting the RPC service side's read file descriptor array. This variable is only of interest if service implementors do not call <b class="fname">svc_run</b>(), but rather do their own asynchronous event processing. This variable is read-only, and it may change after calls to <b class="fname">svc_getreq_poll</b>() or any creation routines. Do not pass it directly to <a class="link-man" href="../html2/poll.html">poll(2)</a>! Instead, make a copy and pass that instead.<div class="spacer">
</div>
<b class="var">svc_max_pollfd</b> is a global variable containing the maximum length of the <b class="var">svc_pollfd</b> array. <b class="var">svc_max_pollfd</b> is not a hard limit; it will grow automatically as needed. This variable is read-only, and it may change after calls to <b class="fname">svc_getreq_poll</b>() or any creation routines. The purpose of <b class="var">svc_max_pollfd</b> is to allow a service implementor to make a copy of <b class="var">svc_pollfd</b> that may in turn be passed to <a class="link-man" href="../html2/poll.html">poll(2)</a>.<div class="spacer">
</div>
<b class="var">__svc_fdset</b> and <b class="var">__svc_fdsetsize</b> are global variables reflecting the RPC service side's read file descriptor bit mask. <b class="var">__svc_fdsetsize</b> is a count of the number of checkable bits in <b class="var">__svc_fdset</b>, and can expand to the full size that <a class="link-man" href="../html2/select.html">select(2)</a> supports, hence exceeding <i class="farg">FD_SETSIZE</i> if required. These variables are only of interest if service implementors do not call <b class="fname">svc_run</b>(), but rather do their own asynchronous event processing. This variable is read-only, and it may change after calls to <b class="fname">svc_getreqset</b>() or any creation routines. Do not pass its address to <a class="link-man" href="../html2/select.html">select(2)</a>! Instead, pass the address of a copy. These variables are considered obsolete; new programs should use <b class="var">svc_pollfd</b> and <b class="var">svc_max_pollfd</b> instead.<div class="spacer">
</div>
<b class="var">svc_fdset</b> is similar to <b class="var">__svc_fdset</b> but limited to <i class="farg">FD_SETSIZE</i> descriptors. This is only of interest if service implementors do not call <b class="fname">svc_run</b>(), but rather do their own asynchronous event processing. This variable is read-only, and it may change after calls to <b class="fname">svc_getreqset</b>() or any creation routines. Do not pass it directly to <a class="link-man" href="../html2/select.html">select(2)</a>! Instead, make a copy and pass that instead.<div class="spacer">
</div>
Additionally, note that if the process has descriptor limits which are extended beyond <i class="farg">FD_SETSIZE</i>, this variable will only be usable for the first <i class="farg">FD_SETSIZE</i> descriptors. This variable is considered obsolete; new programs should use <b class="var">svc_pollfd</b> which does not have this limit.<div class="spacer">
</div>
<b class="var">svc_fds</b> is similar to <b class="var">svc_fdset</b>, but limited to 32 descriptors. This interface is obsoleted by <b class="var">svc_fdset</b> and is included for source compatibility only.<div class="spacer">
</div>
<b class="fname">svc_freeargs</b>() is a macro that frees any data allocated by the RPC/XDR system when it decoded the arguments to a service procedure using <b class="fname">svc_getargs</b>(). This routine returns 1 if the results were successfully freed, and zero otherwise.<div class="spacer">
</div>
<b class="fname">svc_getargs</b>() is a macro that decodes the arguments of an RPC request associated with the RPC service transport handle, <i class="farg">xprt</i>. The parameter <i class="farg">in</i> is the address where the arguments will be placed; <i class="farg">inproc</i> is the XDR routine used to decode the arguments. This routine returns one if decoding succeeds, and zero otherwise.<div class="spacer">
</div>
<b class="fname">svc_getcaller</b>() is the approved way of getting the network address of the caller of a procedure associated with the RPC service transport handle, <i class="farg">xprt</i>.<div class="spacer">
</div>
<b class="fname">svc_getreq_common</b>() is called to handle a request on the given socket. It is used internally by <b class="fname">svc_getreq_poll</b>(), <b class="fname">svc_getreqset</b>(), <b class="fname">svc_getreqset2</b>(), and <b class="fname">svc_getreq</b>().<div class="spacer">
</div>
<b class="fname">svc_getreq_poll</b>() is a routine which is only of interest if a service implementor does not call <b class="fname">svc_run</b>(), but instead implements custom asynchronous event processing. It is called when the <a class="link-man" href="../html2/poll.html">poll(2)</a> system call has determined that an RPC request has arrived on some RPC <i class="farg">socket(s)</i>; <i class="farg">pollretval</i> is the value returned by <a class="link-man" href="../html2/poll.html">poll(2)</a> and <i class="farg">pfds</i> is the array of <i class="farg">pollfd</i> structures passed to <a class="link-man" href="../html2/poll.html">poll(2)</a>. The routine returns when all sockets described by <i class="farg">pollfd</i> have been serviced.<div class="spacer">
</div>
<b class="fname">svc_getreqset</b>() is a routine which is only of interest if a service implementor does not call <b class="fname">svc_run</b>(), but instead implements custom asynchronous event processing. It is called when the <a class="link-man" href="../html2/select.html">select(2)</a> system call has determined that an RPC request has arrived on some RPC <i class="farg">socket(s)</i>; <i class="farg">rdfds</i> is the resultant read file descriptor bit mask. The routine returns when all sockets associated with the value of <i class="farg">rdfds</i> have been serviced.<div class="spacer">
</div>
<b class="fname">svc_getreqset2</b>() is a non-standard routine which is only of interest if a service implementor does not call <b class="fname">svc_run</b>(), but instead implements custom asynchronous event processing. It is called when the <a class="link-man" href="../html2/select.html">select(2)</a> system call has determined that an RPC request has arrived on some RPC <i class="farg">socket(s)</i>; <i class="farg">rdfds</i> is the resultant read file descriptor bit mask. The routine returns when all sockets associated with the value of <i class="farg">rdfds</i> have been serviced. This interface is non-portable, but provided for applications which need to deal with large fd_set sizes.<div class="spacer">
</div>
<b class="fname">svc_getreq</b>() is similar to <i class="farg">svc_getreqset</i>, but limited to 32 descriptors. This interface is obsoleted by <i class="farg">svc_getreq_poll</i> and <i class="farg">svc_getreqset</i>.<div class="spacer">
</div>
<b class="fname">svc_register</b>() associates <i class="farg">prognum</i> and <i class="farg">versnum</i> with the service dispatch procedure, <i class="farg">dispatch</i>. If <i class="farg">protocol</i> is zero, the service is not registered with the <a class="link-man" href="../html8/portmap.html">portmap(8)</a> service. If <i class="farg">protocol</i> is non-zero, then a mapping of the triple [<i class="farg">prognum</i>, <i class="farg">versnum</i>, <i class="farg">protocol</i>] to <i class="farg">xprt-&gt;xp_port</i> is established with the local <a class="link-man" href="../html8/portmap.html">portmap(8)</a> service (generally <i class="farg">protocol</i> is zero, <span class="define">IPPROTO_UDP</span> or <span class="define">IPPROTO_TCP</span>). The procedure <i class="farg">dispatch</i> has the following form: <i class="ftype">int</i> <b class="fname">dispatch</b>(<i class="farg">struct svc_req *request</i>, <i class="farg">SVCXPRT *xprt</i>) The <b class="fname">svc_register</b>() routine returns one if it succeeds, and zero otherwise.<div class="spacer">
</div>
<b class="fname">svc_run</b>() never returns. It waits for RPC requests to arrive, and calls the appropriate service procedure using <b class="fname">svc_getreq_poll</b>() when one arrives. This procedure is usually waiting for a <a class="link-man" href="../html2/poll.html">poll(2)</a> system call to return.<div class="spacer">
</div>
<b class="fname">svc_sendreply</b>() is called by an RPC service's dispatch routine to send the results of a remote procedure call. The parameter <i class="farg">xprt</i> is the request's associated transport handle; <i class="farg">outproc</i> is the XDR routine which is used to encode the results; and <i class="farg">out</i> is the address of the results. This routine returns one if it succeeds, zero otherwise.<div class="spacer">
</div>
<b class="fname">svc_unregister</b>() removes all mapping of the double [<i class="farg">prognum</i>, <i class="farg">versnum</i>] to dispatch routines, and of the triple [<i class="farg">prognum</i>, <i class="farg">versnum</i>, <i class="farg">*</i>] to port number.<div class="spacer">
</div>
<b class="fname">svcerr_auth</b>() is called by a service dispatch routine that refuses to perform a remote procedure call due to an authentication error.<div class="spacer">
</div>
<b class="fname">svcerr_decode</b>() is called by a service dispatch routine that cannot successfully decode its parameters. See also <b class="fname">svc_getargs</b>().<div class="spacer">
</div>
<b class="fname">svcerr_noproc</b>() is called by a service dispatch routine that does not implement the procedure number that the caller requests.<div class="spacer">
</div>
<b class="fname">svcerr_noprog</b>() is called when the desired program is not registered with the RPC package. Service implementors usually do not need this routine.<div class="spacer">
</div>
<b class="fname">svcerr_progvers</b>() is called when the desired version of a program is not registered with the RPC package. Service implementors usually do not need this routine.<div class="spacer">
</div>
<b class="fname">svcerr_systemerr</b>() is called by a service dispatch routine when it detects a system error not covered by any particular protocol. For example, if a service can no longer allocate storage, it may call this routine.<div class="spacer">
</div>
<b class="fname">svcerr_weakauth</b>() is called by a service dispatch routine that refuses to perform a remote procedure call due to insufficient authentication parameters. The routine calls <i class="farg">svcerr_auth(xprt, AUTH_TOOWEAK)</i>.<div class="spacer">
</div>
<b class="fname">svcraw_create</b>() is a routine which creates a toy RPC service transport, to which it returns a pointer. The transport is really a buffer within the process's address space, so the corresponding RPC client should live in the same address space; see <b class="fname">clntraw_create</b>(). This routine allows simulation of RPC and acquisition of RPC overheads (such as round trip times), without any kernel interference. This routine returns <span class="define">NULL</span> if it fails.<div class="spacer">
</div>
<b class="fname">svctcp_create</b>() is a routine which creates a TCP/IP-based RPC service transport, to which it returns a pointer. The transport is associated with the socket <i class="farg">sock</i>, which may be <i class="farg">RPC_ANYSOCK</i>, in which case a new socket is created. If the socket is not bound to a local TCP port, then this routine binds it to an arbitrary port. Upon completion, <i class="farg">xprt-&gt;xp_sock</i> is the transport's socket descriptor, and <i class="farg">xprt-&gt;xp_port</i> is the transport's port number. This routine returns <span class="define">NULL</span> if it fails. Since TCP-based RPC uses buffered I/O, users may specify the size of buffers; values of zero choose suitable defaults.<div class="spacer">
</div>
<b class="fname">svcfd_create</b>() will create a service on top of any open descriptor. Typically, this descriptor is a connected socket for a stream protocol such as TCP. <i class="farg">sendsize</i> and <i class="farg">recvsize</i> indicate sizes for the send and receive buffers. If they are zero, a reasonable default is chosen.<div class="spacer">
</div>
<b class="fname">svcudp_create</b>() is a routine which creates a UDP/IP-based RPC service transport, to which it returns a pointer. The transport is associated with the socket <i class="farg">sock</i>, which may be <i class="farg">RPC_ANYSOCK</i>, in which case a new socket is created. If the socket is not bound to a local UDP port, then this routine binds it to an arbitrary port. Upon completion, <i class="farg">xprt-&gt;xp_sock</i> is the transport's socket descriptor, and <i class="farg">xprt-&gt;xp_port</i> is the transport's port number. This routine returns <span class="define">NULL</span> if it fails.<div class="spacer">
</div>
<b class="fname">svcudp_bufcreate</b>() is like <b class="fname">svcudp_create</b>(), except that it allows the user to specify the maximum packet size for sending and receiving UDP-based RPC messages instead of using the default size limit of 8800 bytes.<div class="spacer">
</div>
<b class="fname">xdr_accepted_reply</b>() is used for encoding RPC reply messages. This routine is useful for users who wish to generate RPC-style messages without using the RPC package.<div class="spacer">
</div>
<b class="fname">xdr_authunix_parms</b>() is used for describing <span class="unix">UNIX</span> credentials. This routine is useful for users who wish to generate these credentials without using the RPC authentication package.<div class="spacer">
</div>
<b class="fname">xdr_callhdr</b>() is used for describing RPC call header messages. This routine is useful for users who wish to generate RPC-style messages without using the RPC package.<div class="spacer">
</div>
<b class="fname">xdr_callmsg</b>() is used for describing RPC call messages. This routine is useful for users who wish to generate RPC-style messages without using the RPC package.<div class="spacer">
</div>
<b class="fname">xdr_opaque_auth</b>() is used for describing RPC authentication information messages. This routine is useful for users who wish to generate RPC-style messages without using the RPC package.<div class="spacer">
</div>
<b class="fname">xdr_pmap</b>() is used for describing parameters to various <a class="link-man" href="../html8/portmap.html">portmap(8)</a> procedures, externally. This routine is useful for users who wish to generate these parameters without using the pmap interface.<div class="spacer">
</div>
<b class="fname">xdr_pmaplist</b>() is used for describing a list of port mappings, externally. This routine is useful for users who wish to generate these parameters without using the pmap interface.<div class="spacer">
</div>
<b class="fname">xdr_rejected_reply</b>() is used for describing RPC reply messages. This routine is useful for users who wish to generate RPC-style messages without using the RPC package.<div class="spacer">
</div>
<b class="fname">xdr_replymsg</b>() is used for describing RPC reply messages. This routine is useful for users who wish to generate RPC-style messages without using the RPC package.<div class="spacer">
</div>
<b class="fname">xprt_register</b>() is used to register transport handles. After RPC service transport handles are created, they should register themselves with the RPC service package. This routine modifies the global variables <b class="var">svc_pollfd</b>, <b class="var">svc_fdset</b>, <b class="var">__svc_fdset</b> and may modify <b class="var">svc_max_pollfd</b> and <b class="var">__svc_fdsetsize</b>. Service implementors usually do not need this routine.<div class="spacer">
</div>
<b class="fname">xprt_unregister</b>() is used to unregister a transport handle. Before an RPC service transport handle is destroyed, it should unregister itself with the RPC service package. This routine modifies the global variable <b class="var">svc_pollfd</b>, <b class="var">svc_fdset</b>, and <b class="var">__svc_fdset</b>. Service implementors usually do not need this routine.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html1/rpcgen.html">rpcgen(1)</a>, <a class="link-man" href="../html2/poll.html">poll(2)</a>, <a class="link-man" href="../html2/select.html">select(2)</a>, <a class="link-man" href="../html3/authnone_create.html">authnone_create(3)</a>, <a class="link-man" href="../html3/getrpcent.html">getrpcent(3)</a>, <a class="link-man" href="../html3/getrpcport.html">getrpcport(3)</a>, <a class="link-man" href="../html3/xdr.html">xdr(3)</a>, <a class="link-man" href="../html5/rpc.html">rpc(5)</a>, <a class="link-man" href="../html8/portmap.html">portmap(8)</a><div class="spacer">
</div>
<span class="ref"><span class="ref-title">Remote Procedure Calls: Protocol Specification</span>, <span class="ref-corp">Sun Microsystems, Inc.</span>.</span><div class="spacer">
</div>
<span class="ref"><span class="ref-title">Remote Procedure Call Programming Guide</span>, <span class="ref-corp">Sun Microsystems, Inc.</span>.</span><div class="spacer">
</div>
<span class="ref"><span class="ref-title">rpcgen Programming Guide</span>, <span class="ref-corp">Sun Microsystems, Inc.</span>.</span></div>
<div class="section">
<h1 id="x5354414e4441524453">STANDARDS</h1> <span class="ref"><span class="ref-title">RPC: Remote Procedure Call Protocol Specification Version 2</span>, <span class="ref-rep">RFC 1057</span>, <span class="ref-corp">Sun Microsystems, Inc.</span>, <span class="ref-date">June 1988</span>.</span></div>
</div>
</body>
</html>

