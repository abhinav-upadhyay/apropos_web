<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
SELECT(2)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">select</b>, <b class="name">pselect</b>, <b class="name">FD_SET</b>, <b class="name">FD_CLR</b>, <b class="name">FD_ISSET</b>, <b class="name">FD_ZERO</b> &#8212; <span class="desc">synchronous I/O multiplexing</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/select.h</a>&gt;</b><div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">select</b>(<i class="farg" style="white-space:nowrap;">int nfds</i>, <i class="farg" style="white-space:nowrap;">fd_set *readfds</i>, <i class="farg" style="white-space:nowrap;">fd_set *writefds</i>, <i class="farg" style="white-space:nowrap;">fd_set *exceptfds</i>, <i class="farg" style="white-space:nowrap;">struct timeval *timeout</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">pselect</b>(<i class="farg" style="white-space:nowrap;">int nfds</i>, <i class="farg" style="white-space:nowrap;">fd_set *readfds</i>, <i class="farg" style="white-space:nowrap;">fd_set *writefds</i>, <i class="farg" style="white-space:nowrap;">fd_set *exceptfds</i>, <i class="farg" style="white-space:nowrap;">const struct timespec *timeout</i>, <i class="farg" style="white-space:nowrap;">const sigset_t *mask</i>);<div class="spacer">
</div>
<b class="fname">FD_SET</b>(<i class="farg" style="white-space:nowrap;">fd</i>, <i class="farg" style="white-space:nowrap;">&amp;fdset</i>);<div class="spacer">
</div>
<b class="fname">FD_CLR</b>(<i class="farg" style="white-space:nowrap;">fd</i>, <i class="farg" style="white-space:nowrap;">&amp;fdset</i>);<div class="spacer">
</div>
<b class="fname">FD_ISSET</b>(<i class="farg" style="white-space:nowrap;">fd</i>, <i class="farg" style="white-space:nowrap;">&amp;fdset</i>);<div class="spacer">
</div>
<b class="fname">FD_ZERO</b>(<i class="farg" style="white-space:nowrap;">&amp;fdset</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> <b class="fname">select</b>() examines the I/O descriptor sets whose addresses are passed in <i class="farg">readfds</i>, <i class="farg">writefds</i>, and <i class="farg">exceptfds</i> to see if some of their descriptors are ready for reading, are ready for writing, or have an exceptional condition pending, respectively. Exceptional conditions include the presence of out-of-band data on a socket. The first <i class="farg">nfds</i> descriptors are checked in each set; i.e., the descriptors from 0 through <i class="farg">nfds</i>-1 in the descriptor sets are examined. On return, <b class="fname">select</b>() replaces the given descriptor sets with subsets consisting of those descriptors that are ready for the requested operation. <b class="fname">select</b>() returns the total number of ready descriptors in all the sets.<div class="spacer">
</div>
The descriptor sets are stored as bit fields in arrays of integers. The following macros are provided for manipulating such descriptor sets: <b class="fname">FD_ZERO</b>(<i class="farg">&amp;fdset</i>) initializes a descriptor set <i class="farg">fdset</i> to the null set. <b class="fname">FD_SET</b>(<i class="farg">fd</i>, <i class="farg">&amp;fdset</i>) includes a particular descriptor <i class="farg">fd</i> in <i class="farg">fdset</i>. <b class="fname">FD_CLR</b>(<i class="farg">fd</i>, <i class="farg">&amp;fdset</i>) removes <i class="farg">fd</i> from <i class="farg">fdset</i>. <b class="fname">FD_ISSET</b>(<i class="farg">fd</i>, <i class="farg">&amp;fdset</i>) is non-zero if <i class="farg">fd</i> is a member of <i class="farg">fdset</i>, zero otherwise. The behavior of these macros is undefined if a descriptor value is less than zero or greater than or equal to <span class="define">FD_SETSIZE</span>, which is normally at least equal to the maximum number of descriptors supported by the system.<div class="spacer">
</div>
If <i class="farg">timeout</i> is a non-null pointer, it specifies a maximum interval to wait for the selection to complete. If <i class="farg">timeout</i> is a null pointer, the select blocks indefinitely. To effect a poll, the <i class="farg">timeout</i> argument should be non-null, pointing to a zero-valued timeval structure. <i class="farg">timeout</i> is not changed by <b class="fname">select</b>(), and may be reused on subsequent calls; however, it is good style to re-initialize it before each invocation of <b class="fname">select</b>().<div class="spacer">
</div>
Any of <i class="farg">readfds</i>, <i class="farg">writefds</i>, and <i class="farg">exceptfds</i> may be given as null pointers if no descriptors are of interest.<div class="spacer">
</div>
The <b class="fname">pselect</b>() function is similar to <b class="fname">select</b>() except that it specifies the timeout using a timespec structure. Also, if <i class="farg">mask</i> is a non-null pointer, <b class="fname">pselect</b>() atomically sets the calling thread's signal mask to the signal set pointed to by <i class="farg">mask</i> for the duration of the function call. In this case, the original signal mask will be restored before <b class="fname">pselect</b>() returns.</div>
<div class="section">
<h1 id="x52455455524e2056414c554553">RETURN VALUES</h1> If successful, <b class="fname">select</b>() and <b class="fname">pselect</b>() return the number of ready descriptors that are contained in the descriptor sets. If a descriptor is included in multiple descriptor sets, each inclusion is counted separately. If the time limit expires before any descriptors become ready, they return 0.<div class="spacer">
</div>
Otherwise, if <b class="fname">select</b>() or <b class="fname">pselect</b>() return with an error, including one due to an interrupted call, they return -1, and the descriptor sets will be unmodified.</div>
<div class="section">
<h1 id="x4552524f5253">ERRORS</h1> An error return from <b class="fname">select</b>() or <b class="fname">pselect</b>() indicates:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
[<span class="errno">EFAULT</span>]</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
One or more of <i class="farg">readfds</i>, <i class="farg">writefds</i>, or <i class="farg">exceptfds</i> points outside the process's allocated address space.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
[<span class="errno">EBADF</span>]</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
One of the descriptor sets specified an invalid descriptor.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
[<span class="errno">EINTR</span>]</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
A signal was delivered before the time limit expired and before any of the selected descriptors became ready.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
[<span class="errno">EINVAL</span>]</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
The specified time limit is invalid. One of its components is negative or too large.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
[<span class="errno">EINVAL</span>]</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
<i class="farg">nfds</i> was less than 0.</dd>
</dl>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html2/accept.html">accept(2)</a>, <a class="link-man" href="../html2/clock_gettime.html">clock_gettime(2)</a>, <a class="link-man" href="../html2/connect.html">connect(2)</a>, <a class="link-man" href="../html2/gettimeofday.html">gettimeofday(2)</a>, <a class="link-man" href="../html2/poll.html">poll(2)</a>, <a class="link-man" href="../html2/read.html">read(2)</a>, <a class="link-man" href="../html2/recv.html">recv(2)</a>, <a class="link-man" href="../html2/send.html">send(2)</a>, <a class="link-man" href="../html2/write.html">write(2)</a>, <a class="link-man" href="../html3/getdtablesize.html">getdtablesize(3)</a></div>
<div class="section">
<h1 id="x5354414e4441524453">STANDARDS</h1> The <b class="fname">select</b>() and <b class="fname">pselect</b>() functions conform to IEEE Std 1003.1-2008 (&#8220;POSIX.1&#8221;).</div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The <b class="fname">select</b>() system call first appeared in <span class="unix">4.1cBSD</span>. The <b class="fname">pselect</b>() system call has been available since <span class="unix">OpenBSD&#160;5.4</span>.</div>
<div class="section">
<h1 id="x42554753">BUGS</h1> Although the provision of <a class="link-man" href="../html3/getdtablesize.html">getdtablesize(3)</a> was intended to allow user programs to be written independent of the kernel limit on the number of open files, the dimension of a sufficiently large bit field for select remains a problem. The default bit size of <i class="ftype">fd_set</i> is based on the symbol <span class="define">FD_SETSIZE</span> (currently 1024), but that is somewhat smaller than the current kernel limit to the number of open files. However, in order to accommodate programs which might potentially use a larger number of open files with select, it is possible to increase this size within a program by providing a larger definition of <span class="define">FD_SETSIZE</span> before the inclusion of any headers. The kernel will cope, and the userland libraries provided with the system are also ready for large numbers of file descriptors.<div class="spacer">
</div>
Alternatively, to be really safe, it is possible to allocate <i class="ftype">fd_set</i> bit-arrays dynamically. The idea is to permit a program to work properly even if it is <a class="link-man" href="../html2/execve.html">execve(2)</a>'d with 4000 file descriptors pre-allocated. The following illustrates the technique which is used by userland libraries:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
fd_set *fdsr; 
int max = fd; 
 
fdsr = calloc(howmany(max+1, NFDBITS), sizeof(fd_mask)); 
if (fdsr == NULL) { 
	... 
	return (-1); 
} 
FD_SET(fd, fdsr); 
n = select(max+1, fdsr, NULL, NULL, &amp;tv); 
... 
free(fdsr);</pre>
<div class="spacer">
</div>
Alternatively, it is possible to use the <a class="link-man" href="../html2/poll.html">poll(2)</a> interface. <a class="link-man" href="../html2/poll.html">poll(2)</a> is more efficient when the size of <b class="fname">select</b>()'s <i class="ftype">fd_set</i> bit-arrays are very large, and for fixed numbers of file descriptors one need not size and dynamically allocate a memory object.<div class="spacer">
</div>
<b class="fname">select</b>() should probably have been designed to return the time remaining from the original timeout, if any, by modifying the time value in place. Even though some systems stupidly act in this different way, it is unlikely this semantic will ever be commonly implemented, as the change causes massive source code compatibility problems. Furthermore, recent new standards have dictated the current behaviour. In general, due to the existence of those brain-damaged non-conforming systems, it is unwise to assume that the timeout value will be unmodified by the <b class="fname">select</b>() call, and the caller should reinitialize it on each invocation. Calculating the delta is easily done by calling <a class="link-man" href="../html2/gettimeofday.html">gettimeofday(2)</a> before and after the call to <b class="fname">select</b>(), and using <b class="fname">timersub</b>() (as described in <a class="link-man" href="../html2/getitimer.html">getitimer(2)</a>).<div class="spacer">
</div>
Internally to the kernel, <b class="fname">select</b>() and <b class="fname">pselect</b>() work poorly if multiple processes wait on the same file descriptor. Given that, it is rather surprising to see that many daemons are written that way.</div>
</div>
</body>
</html>

