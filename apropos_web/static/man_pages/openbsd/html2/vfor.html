<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
VFORK(2)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">vfork</b> &#8212; <span class="desc">spawn new process and block parent</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">unistd.h</a>&gt;</b><div class="spacer">
</div>
<i class="ftype">pid_t</i><br/>
<b class="fname">vfork</b>(<i class="farg" style="white-space:nowrap;">void</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> <b class="fname">vfork</b>() was originally used to create new processes without fully copying the address space of the old process, which is horrendously inefficient in a paged environment. It was useful when the purpose of <a class="link-man" href="../html2/fork.html">fork(2)</a> would have been to create a new system context for an <a class="link-man" href="../html2/execve.html">execve(2)</a>. Since <a class="link-man" href="../html2/fork.html">fork(2)</a> is now efficient, even in the above case, the need for <b class="fname">vfork</b>() has diminished. <b class="fname">vfork</b>() differs from <a class="link-man" href="../html2/fork.html">fork(2)</a> in that the parent is suspended until the child makes a call to <a class="link-man" href="../html2/execve.html">execve(2)</a> or an exit (either by a call to <a class="link-man" href="../html2/_exit.html">_exit(2)</a> or abnormally). In addition, fork handlers established using <a class="link-man" href="../html3/pthread_atfork.html">pthread_atfork(3)</a> are not called when a multithreaded program calls <b class="fname">vfork</b>().<div class="spacer">
</div>
<b class="fname">vfork</b>() returns 0 in the child's context and (later) the PID of the child in the parent's context.</div>
<div class="section">
<h1 id="x52455455524e2056414c554553">RETURN VALUES</h1> Same as for <a class="link-man" href="../html2/fork.html">fork(2)</a>.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html2/execve.html">execve(2)</a>, <a class="link-man" href="../html2/fork.html">fork(2)</a>, <a class="link-man" href="../html2/sigaction.html">sigaction(2)</a>, <a class="link-man" href="../html2/wait.html">wait(2)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The <b class="fname">vfork</b>() function call appeared in <span class="unix">3.0BSD</span> with the additional semantics that the child process ran in the memory of the parent until it called <a class="link-man" href="../html2/execve.html">execve(2)</a> or exited. That sharing of memory was removed in <span class="unix">4.4BSD</span>, leaving just the semantics of blocking the parent until the child calls <a class="link-man" href="../html2/execve.html">execve(2)</a> or exits. On many other systems the original behavior has been restored, making this interface particularly unportable.</div>
<div class="section">
<h1 id="x42554753">BUGS</h1> To avoid a possible deadlock situation, processes that are children in the middle of a <b class="fname">vfork</b>() are never sent <span class="define">SIGTTOU</span> or <span class="define">SIGTTIN</span> signals; rather, output or <a class="link-man" href="../html2/ioctl.html">ioctl(2)</a> calls are allowed and input attempts result in an end-of-file indication.</div>
</div>
</body>
</html>

