<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
BUFFERCACHE(9)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">buffercache</b>, <b class="name">bread</b>, <b class="name">breadn</b>, <b class="name">bwrite</b>, <b class="name">bawrite</b>, <b class="name">bdwrite</b>, <b class="name">getblk</b>, <b class="name">geteblk</b>, <b class="name">incore</b>, <b class="name">brelse</b>, <b class="name">biodone</b>, <b class="name">biowait</b> &#8212; <span class="desc">buffer cache interfaces</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/buf.h</a>&gt;</b><div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">bread</b>(<i class="farg" style="white-space:nowrap;">struct vnode *vp</i>, <i class="farg" style="white-space:nowrap;">daddr_t blkno</i>, <i class="farg" style="white-space:nowrap;">int size</i>, <i class="farg" style="white-space:nowrap;">struct buf **bpp</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">breadn</b>(<i class="farg" style="white-space:nowrap;">struct vnode *vp</i>, <i class="farg" style="white-space:nowrap;">daddr_t blkno</i>, <i class="farg" style="white-space:nowrap;">int size</i>, <i class="farg" style="white-space:nowrap;">daddr_t rablks[]</i>, <i class="farg" style="white-space:nowrap;">int rasizes[]</i>, <i class="farg" style="white-space:nowrap;">int nrablks</i>, <i class="farg" style="white-space:nowrap;">struct buf **bpp</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">bwrite</b>(<i class="farg" style="white-space:nowrap;">struct buf *bp</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">bawrite</b>(<i class="farg" style="white-space:nowrap;">struct buf *bp</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">bdwrite</b>(<i class="farg" style="white-space:nowrap;">struct buf *bp</i>);<div class="spacer">
</div>
<i class="ftype">struct buf *</i><br/>
<b class="fname">getblk</b>(<i class="farg" style="white-space:nowrap;">struct vnode *vp</i>, <i class="farg" style="white-space:nowrap;">daddr_t blkno</i>, <i class="farg" style="white-space:nowrap;">int size</i>, <i class="farg" style="white-space:nowrap;">int slpflag</i>, <i class="farg" style="white-space:nowrap;">int slptimeo</i>);<div class="spacer">
</div>
<i class="ftype">struct buf *</i><br/>
<b class="fname">geteblk</b>(<i class="farg" style="white-space:nowrap;">int size</i>);<div class="spacer">
</div>
<i class="ftype">struct buf *</i><br/>
<b class="fname">incore</b>(<i class="farg" style="white-space:nowrap;">struct vnode *vp</i>, <i class="farg" style="white-space:nowrap;">daddr_t blkno</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">brelse</b>(<i class="farg" style="white-space:nowrap;">struct buf *bp</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">biodone</b>(<i class="farg" style="white-space:nowrap;">struct buf *bp</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">biowait</b>(<i class="farg" style="white-space:nowrap;">struct buf *bp</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <b class="name">buffercache</b> interface is used by each filesystem to improve I/O performance using in-core caches of filesystem blocks.<div class="spacer">
</div>
The kernel memory used to cache a block is called a buffer and described by a <span class="emph">buf</span> structure. In addition to describing a cached block, a <span class="emph">buf</span> structure is also used to describe an I/O request as a part of the disk driver interface.</div>
<div class="section">
<h1 id="x46554e4354494f4e53">FUNCTIONS</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">bread</b>(<i class="farg">vp</i>, <i class="farg">blkno</i>, <i class="farg">size</i>, <i class="farg">bpp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Read a block corresponding to <i class="farg">vp</i> and <i class="farg">blkno</i>. The buffer is returned via <i class="farg">bpp</i>.<div class="spacer">
</div>
If the buffer is not found (i.e. the block is not cached in memory), <b class="fname">bread</b>() calls <b class="fname">getblk</b>() to allocate a buffer with enough pages for <i class="farg">size</i> and reads the specified disk block into it.<div class="spacer">
</div>
The buffer returned by <b class="fname">bread</b>() is marked as busy. (The <span class="define">B_BUSY</span> flag is set.) After manipulation of the buffer returned from <b class="fname">bread</b>(), the caller should unbusy it so that another thread can get it. If the buffer contents are modified and should be written back to disk, it should be unbusied using one of the variants of <b class="fname">bwrite</b>(). Otherwise, it should be unbusied using <b class="fname">brelse</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">breadn</b>(<i class="farg">vp</i>, <i class="farg">blkno</i>, <i class="farg">size</i>, <i class="farg">rablks</i>, <i class="farg">rasizes</i>, <i class="farg">nrablks</i>, <i class="farg">bpp</i>);</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Get a buffer as <b class="fname">bread</b>(). In addition, <b class="fname">breadn</b>() will start read-ahead of blocks specified by <i class="farg">rablks</i>, <i class="farg">rasizes</i>, and <i class="farg">nrablks</i>. The read-ahead blocks aren't returned, but are available in cache for future accesses.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">bwrite</b>(<i class="farg">bp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Write a block. Start I/O for write using <b class="fname">VOP_STRATEGY</b>(). Then, unless the <span class="define">B_ASYNC</span> flag is set in <i class="farg">bp</i>, <b class="fname">bwrite</b>() waits for the I/O to complete.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">bawrite</b>(<i class="farg">bp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Write a block asynchronously. Set the <span class="define">B_ASYNC</span> flag in <i class="farg">bp</i> and simply call <b class="fname">VOP_BWRITE</b>(), which results in <b class="fname">bwrite</b>() for most filesystems.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">bdwrite</b>(<i class="farg">bp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Delayed write. Unlike <b class="fname">bawrite</b>(), <b class="fname">bdwrite</b>() won't start any I/O. It only marks the buffer as dirty (<span class="define">B_DELWRI</span>) and unbusies it. This routine should be used when the buffer is expected to be modified again soon, typically a small write that partially fills a buffer.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">getblk</b>(<i class="farg">vp</i>, <i class="farg">blkno</i>, <i class="farg">size</i>, <i class="farg">slpflag</i>, <i class="farg">slptimeo</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Get a block of requested size <i class="farg">size</i> that is associated with a given vnode and block offset, specified by <i class="farg">vp</i> and <i class="farg">blkno</i>. If it is found in the block cache, mark it as having been found, make it busy and return it. Otherwise, return an empty block of the correct size. It is up to the caller to ensure that the cached blocks are of the correct size.<div class="spacer">
</div>
If <b class="fname">getblk</b>() needs to sleep, <i class="farg">slpflag</i> and <i class="farg">slptimeo</i> are used as arguments for <b class="fname">tsleep</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">geteblk</b>(<i class="farg">size</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Allocate an empty, disassociated block of a given size <i class="farg">size</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">incore</b>(<i class="farg">vp</i>, <i class="farg">blkno</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Determine if a block associated with a given vnode and block offset is in the cache. If it is there, return a pointer to it. Note that <b class="fname">incore</b>() doesn't mark the buffer as busy unlike <b class="fname">getblk</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">brelse</b>(<i class="farg">bp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Unlock a buffer by clearing the <span class="define">B_AGE</span>, <span class="define">B_ASYNC</span>, <span class="define">B_BUSY</span>, <span class="define">B_NOCACHE</span>, and <span class="define">B_DEFERRED</span> flags and release it to the free lists.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">biodone</b>(<i class="farg">bp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Mark I/O complete on a buffer. If a callback has been requested by <span class="define">B_CALL</span>, do so. Otherwise, wake up the waiting processes.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">biowait</b>(<i class="farg">bp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Wait for operations on the buffer to complete. When they do, extract and return the I/O's error value. If the operation on the buffer is being done via a direct call to a <b class="fname">strategy</b>() type function, then the buffer must be previously initialized with the <span class="define">B_RAW</span> flag.</dd>
</dl>
</div>
<div class="section">
<h1 id="x434f4445205245464552454e434553">CODE REFERENCES</h1> This section describes places within the <span class="unix">OpenBSD</span> source tree where actual code implementing the buffer cache subsystem can be found. All pathnames are relative to <i class="file">/usr/src</i>.<div class="spacer">
</div>
The buffer cache subsystem is implemented within the file <i class="file">sys/kern/vfs_bio.c</i>.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html9/intro.html">intro(9)</a>, <a class="link-man" href="../html9/vnode.html">vnode(9)</a>, <a class="link-man" href="../html9/VOP_STRATEGY.html">VOP_STRATEGY(9)</a><div class="spacer">
</div>
<span class="ref"><span class="ref-auth">Maurice J. Bach</span>, <i class="ref-book">The Design of the UNIX Operating System</i>, <i class="ref-issue">Prentice Hall</i>, <span class="ref-date">1986</span>.</span><div class="spacer">
</div>
<span class="ref"><span class="ref-auth">Marshall Kirk McKusick</span>, <span class="ref-auth">Keith Bostic</span>, <span class="ref-auth">Michael J. Karels</span>, and <span class="ref-auth">John S. Quarterman</span>, <i class="ref-book">The Design and Implementation of the 4.4BSD Operating System</i>, <i class="ref-issue">Addison Wesley</i>, <span class="ref-date">1996</span>.</span><div class="spacer">
</div>
<span class="ref"><span class="ref-auth">Leffler, et. al.</span>, <i class="ref-book">The Design and Implementation of the 4.3 BSD Unix Operating System</i>, <i class="ref-issue">Addison Wesley</i>, <span class="ref-date">1989</span>.</span></div>
</div>
</body>
</html>

