<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
TC_INIT(9)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">tc_init</b> &#8212; <span class="desc">machine-independent binary timescale</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/timetc.h</a>&gt;</b><div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">tc_init</b>(<i class="farg" style="white-space:nowrap;">struct timecounter *tc</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The timecounter interface is a machine-independent implementation of a binary timescale using whatever hardware support is at hand for tracking time.<div class="spacer">
</div>
A timecounter is a binary counter which has two properties:<ul style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-bul">
<li class="list-bul" style="margin-top: 1.00em;">
it runs at a fixed, known frequency</li>
<li class="list-bul" style="margin-top: 1.00em;">
it has sufficient bits to not roll over in less than approximately max(2 msec, 2/HZ seconds) (the value 2 here is really 1 + delta, for some indeterminate value of delta)</li>
</ul>
<div class="spacer">
</div>
The interface between the hardware which implements a timecounter and the machine-independent code which uses this to keep track of time is a <b class="var">timecounter</b> structure:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
struct timecounter { 
	timecounter_get_t	*tc_get_timecount; 
	timecounter_pps_t	*tc_poll_pps; 
	u_int 			tc_counter_mask; 
	u_int64_t		tc_frequency; 
	char			*tc_name; 
	int			tc_quality; 
	void			*tc_priv; 
	struct timecounter	*tc_next; 
}</pre>
<div class="spacer">
</div>
The fields of the <b class="var">timecounter</b> structure are described below.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="ftype">u_int</i> <b class="fname">(*tc_get_timecount)</b>(<i class="farg">struct timecounter *</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This function reads the counter. It is not required to mask any unimplemented bits out, as long as they are constant.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="ftype">void</i> <b class="fname">(*tc_poll_pps)</b>(<i class="farg">struct timecounter *</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This function is optional and can be set to NULL. It will be called whenever the timecounter is rewound, and is intended to check for PPS events. Normal hardware does not need it but timecounters which latch PPS in hardware do.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">tc_counter_mask</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This mask should mask off any unimplemented bits.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">tc_frequency</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Frequency of the counter in Hz.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">tc_name</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Name of the timecounter. Can be any null-terminated string.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">tc_quality</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Used to determine if this timecounter is better than another timecounter - higher means better. If this field is negative, the counter is only used at explicit request.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">tc_priv</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Pointer to the timecounter's private parts.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">tc_next</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
For internal use.</dd>
</dl>
<div class="spacer">
</div>
To register a new timecounter, the hardware device driver should fill a <b class="var">timecounter</b> structure with appropriate values and call the <b class="fname">tc_init</b>() function, giving a pointer to the structure as a <i class="farg">tc</i> parameter.</div>
<div class="section">
<h1 id="x434f4445205245464552454e434553">CODE REFERENCES</h1> The timecounter framework is implemented in the file <i class="file">sys/kern/kern_tc.c</i>.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html4/amdpm.html">amdpm(4)</a>, <a class="link-man" href="../html4/elansc.html">elansc(4)</a>, <a class="link-man" href="../html4/gscpm.html">gscpm(4)</a>, <a class="link-man" href="../html4/ichpcib.html">ichpcib(4)</a>, <a class="link-man" href="../html4/viapm.html">viapm(4)</a>, <a class="link-man" href="../html9/hz.html">hz(9)</a>, <a class="link-man" href="../html9/microtime.html">microtime(9)</a><div class="spacer">
</div>
<span class="ref"><span class="ref-auth">Poul-Henning Kamp</span>, <span class="ref-title">Timecounter: Efficient and precise timekeeping in SMP kernels</span>, <i class="ref-jrnl">The FreeBSD Project</i>, <a class="link-ref" href="http://phk.freebsd.dk/pubs/timecounter.pdf">http://phk.freebsd.dk/pubs/timecounter.pdf</a>.</span></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The timecounter interface first appeared in <span class="unix">OpenBSD&#160;3.6</span>.</div>
</div>
</body>
</html>

