<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
EVCOUNT(9)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">evcount</b>, <b class="name">evcount_attach</b>, <b class="name">evcount_detach</b> &#8212; <span class="desc">generic interrupt and event counter kernel API</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/evcount.h</a>&gt;</b><div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">evcount_attach</b>(<i class="farg" style="white-space:nowrap;">struct evcount *ec</i>, <i class="farg" style="white-space:nowrap;">const char *name</i>, <i class="farg" style="white-space:nowrap;">void *data</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">evcount_detach</b>(<i class="farg" style="white-space:nowrap;">struct evcount *ec</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <b class="name">evcount</b> API provides an interface for generic event and interrupt counting, whose statistics are made available to machine-independent <a class="link-man" href="../html3/sysctl.html">sysctl(3)</a> nodes.<div class="subsection">
<h2 id="x4f76657276696577">Overview</h2> With <b class="name">evcount</b>, an architecture can collect interrupt counting for any device. All registered counters will be made available under the <b class="var">kern.evcount</b> <a class="link-man" href="../html3/sysctl.html">sysctl(3)</a> node as a flat list. The following is a sample list of counters provided by some common architectures:<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
clock</dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
Interrupt counter for the system clock</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
stat</dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
Second-level interrupt decrementer counter</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
rtc</dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
Real-time clock counter</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
prof</dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
System profiler counter</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
pciide0</dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
PCI IDE controller counter (see <a class="link-man" href="../html4/pciide.html">pciide(4)</a>)</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
uhci0</dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
USB 1.0 controller counter (see <a class="link-man" href="../html4/usb.html">usb(4)</a>)</dd>
</dl>
<div class="spacer">
</div>
See <a class="link-man" href="../html4/intro.html">intro(4)</a> for a list of devices for any of which <b class="name">evcount</b> may track interrupt counting.<div class="spacer">
</div>
The <a class="link-man" href="../html1/systat.html">systat(1)</a> and <a class="link-man" href="../html8/vmstat.html">vmstat(8)</a> utilities can be used to view interrupts collected by <b class="name">evcount</b>.</div>
<div class="subsection">
<h2 id="x54686520415049">The API</h2> The <span class="type">evcount</span> structure has the following definition:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
struct evcount { 
	u_int64_t		ec_count;	/* main counter */ 
	int			ec_id;		/* counter ID */ 
	const char		*ec_name;	/* counter name */ 
	void			*ec_data;	/* user data */ 
 
	TAILQ_ENTRY(evcount)	next; 
};</pre>
<div class="spacer">
</div>
The <b class="fname">evcount_attach</b>(<i class="farg">ec</i>, <i class="farg">name</i>, <i class="farg">data</i>) function adds the given event counter to the system's counter list. <i class="farg">name</i> provides the counter name, which is modeled after a device, such as &#8220;clock&#8221; or &#8220;pciide0&#8221;. <i class="farg">data</i> provides a chunk of data that will be made available through the <a class="link-man" href="../html3/sysctl.html">sysctl(3)</a> call.<div class="spacer">
</div>
The <b class="fname">evcount_detach</b>(<i class="farg">ec</i>) function removes the given event counter <i class="farg">ec</i> from the counter list.</div>
</div>
<div class="section">
<h1 id="x4558414d504c4553">EXAMPLES</h1> The following is an outline of code that provides routines to register and de-register interrupt handlers for devices, plugging the counting of interrupts generated by them during system operation into the <b class="name">evcount</b> framework.<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
#include &lt;sys/evcount.h&gt; 
#include &lt;machine/intr.h&gt; 
 
/* 
 * machine/intr.h provides a structure, intrhand, which is 
 * machine-dependent but is usually similar to this: 
 * 
 *	struct intrhand { 
 *		int		(*ih_fun)(void *); 
 *		void		 *ih_arg; 
 *		int		  ih_level; 
 *		struct intrhand  *ih_next; 
 *		int		  ih_irq; 
 *		struct evcount    ih_count; 
 *	} 
 */ 
 
/* 
 * Register an interrupt handler. 
 */ 
void * 
intr_establish(void *lcv, int irq, int type, int level, 
	       int (*ih_fun)(void *), void *ih_arg, char *name) 
{ 
	struct intrhand *ih, **p; 
 
	/* 
	 * Allocate memory for the handler, sanity-check incoming 
	 * values (IRQ#, etc.), and link the handler into 
	 * machine-dependent data structures. 
	 */ 
 
	/* 
	 * Fill out the handler. 
	 */ 
	ih-&gt;ih_fun = ih_fun; 
	ih-&gt;ih_arg = ih_arg; 
	ih-&gt;ih_next = NULL; 
	ih-&gt;ih_level = level; 
	ih-&gt;ih_irq = irq; 
 
	/* 
	 * Attach it. 
	 */ 
	evcount_attach(&amp;ih-&gt;ih_count, name, &amp;ih-&gt;ih_irq); 
 
	return (ih); 
} 
 
/* 
 * Deregister an interrupt handler. 
 */ 
void 
intr_disestablish(void *lcp, void *arg) 
{ 
	struct intrhand *ih = arg; 
 
	/* 
	 * Sanity-check incoming values (IRQ, etc.) and remove 
	 * the interrupt handler from machine-dependent data 
	 * structures. 
	 */ 
 
	evcount_detach(&amp;ih-&gt;ih_count); 
 
	/* 
	 * Free up memory and install a null interrupt handler. 
	 */ 
}</pre>
<div class="spacer">
</div>
An interrupt handler for a device will be registered during <a class="link-man" href="../html9/autoconf.html">autoconf(9)</a> with a call to the above <b class="fname">intr_establish</b>().<div class="spacer">
</div>
The main external interrupt handler, which handles all system interrupts, will select the appropriate handler for the device that created the interrupt when an interrupt is generated. In this case, the handler is the routine assigned to <b class="var">ih_fun</b>, and <b class="name">evcount</b> will be made aware of interrupt occurrence.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html1/systat.html">systat(1)</a>, <a class="link-man" href="../html3/queue.html">queue(3)</a>, <a class="link-man" href="../html3/sysctl.html">sysctl(3)</a>, <a class="link-man" href="../html4/intro.html">intro(4)</a>, <a class="link-man" href="../html8/vmstat.html">vmstat(8)</a>, <a class="link-man" href="../html9/autoconf.html">autoconf(9)</a></div>
<div class="section">
<h1 id="x415554484f5253">AUTHORS</h1> The <b class="name">evcount</b> API was written by <span class="author">Artur Grabowski</span> and <span class="author">Aaron Campbell</span> for <span class="unix">OpenBSD&#160;3.6</span>.</div>
</div>
</body>
</html>

