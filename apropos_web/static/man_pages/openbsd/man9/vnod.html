<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
VNODE(9)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">vnode</b> &#8212; <span class="desc">an overview of vnodes</span></div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> A <span class="emph">vnode</span> is an object in kernel memory that speaks the <span class="unix">UNIX</span> file interface (open, read, write, close, readdir, etc.). Vnodes can represent files, directories, FIFOs, domain sockets, block devices, character devices.<div class="spacer">
</div>
Each vnode has a set of methods which start with the string &#8220;VOP_&#8221;. These methods include <b class="fname">VOP_OPEN</b>(), <b class="fname">VOP_READ</b>(), <b class="fname">VOP_WRITE</b>(), <b class="fname">VOP_RENAME</b>(), <b class="fname">VOP_CLOSE</b>(), and <b class="fname">VOP_MKDIR</b>(). Many of these methods correspond closely to the equivalent file system call - <a class="link-man" href="../html2/open.html">open(2)</a>, <a class="link-man" href="../html2/read.html">read(2)</a>, <a class="link-man" href="../html2/write.html">write(2)</a>, <a class="link-man" href="../html2/rename.html">rename(2)</a>, etc. Each file system (FFS, NFS, etc.) provides implementations for these methods.<div class="spacer">
</div>
The Virtual File System library (see <a class="link-man" href="../html9/vfs.html">vfs(9)</a>) maintains a pool of vnodes. File systems cannot allocate their own vnodes; they must use the functions provided by the VFS to create and manage vnodes.<div class="spacer">
</div>
The definition of a vnode is as follows:<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
struct vnode { 
	struct uvm_vnode v_uvm;		/* uvm(9) data */ 
	int	(**v_op)(void *);	/* vnode operations vector */ 
	enum	vtype v_type;		/* vnode type */ 
	u_int	v_flag;			/* vnode flags (see below) */ 
	u_int	v_usecount;		/* reference count of users */ 
	u_int	v_writecount;		/* reference count of writers */ 
	/* Flags that can be read/written in interrupts */ 
	u_int	v_bioflag;		/* flags used by intr handlers */ 
	u_int	v_holdcnt;		/* buffer references */ 
	u_int	v_id;			/* capability identifier */ 
	struct	mount *v_mount;		/* ptr to vfs we are in */ 
	TAILQ_ENTRY(vnode) v_freelist;	/* vnode freelist */ 
	LIST_ENTRY(vnode) v_mntvnodes;	/* vnodes for mount point */ 
	struct	buflists v_cleanblkhd;	/* clean blocklist head */ 
	struct	buflists v_dirtyblkhd;	/* dirty blocklist head */ 
	u_int	v_numoutput;		/* num of writes in progress */ 
	LIST_ENTRY(vnode) v_synclist;	/* vnode with dirty buffers */ 
	union { 
	  struct mount    *vu_mountedhere;/* ptr to mounted vfs (VDIR) */ 
	  struct socket   *vu_socket;	/* UNIX IPC (VSOCK) */ 
	  struct specinfo *vu_specinfo;	/* device (VCHR, VBLK) */ 
	  struct fifoinfo *vu_fifoinfo;	/* fifo (VFIFO) */ 
	} v_un; 
 
	enum	vtagtype v_tag;		/* type of underlying data */ 
	void	*v_data;		/* private data for fs */ 
	struct { 
	  struct simplelock vsi_lock;	/* lock to protect below */ 
	  struct selinfo vsi_selinfo;	/* identity of poller(s) */ 
	} v_selectinfo; 
}; 
#define v_mountedhere	v_un.vu_mountedhere 
#define v_socket	v_un.vu_socket 
#define v_specinfo	v_un.vu_specinfo 
#define v_fifoinfo	v_un.vu_fifoinfo</pre>
<div class="subsection">
<h2 id="x566e6f6465206c696665206379636c65">Vnode life cycle</h2> When a client of the VFS requests a new vnode, the vnode allocation code can reuse an old vnode object that is no longer in use. Whether a vnode is in use is tracked by the vnode reference count (<b class="var">v_usecount</b>). By convention, each open file handle holds a reference as do VM objects backed by files. A vnode with a reference count of 1 or more will not be deallocated or reused to point to a different file. So, if you want to ensure that your vnode doesn't become a different file under you, you better be sure you have a reference to it. A vnode that points to a valid file and has a reference count of 1 or more is called <span class="emph">active</span>.<div class="spacer">
</div>
When a vnode's reference count drops to zero, it becomes <span class="emph">inactive</span>, that is, a candidate for reuse. An inactive vnode still refers to a valid file and one can try to reactivate it using <a class="link-man" href="../html9/vget.html">vget(9)</a> (this is used a lot by caches).<div class="spacer">
</div>
Before the VFS can reuse an inactive vnode to refer to another file, it must clean all information pertaining to the old file. A cleaned out vnode is called a <span class="emph">reclaimed</span> vnode.<div class="spacer">
</div>
To support forceable unmounts and the <a class="link-man" href="../html2/revoke.html">revoke(2)</a> system call, the VFS may reclaim a vnode with a positive reference count. The reclaimed vnode is given to the dead file system, which returns errors for most operations. The reclaimed vnode will not be reused for another file until its reference count hits zero.</div>
<div class="subsection">
<h2 id="x566e6f646520706f6f6c">Vnode pool</h2> The <a class="link-man" href="../html9/getnewvnode.html">getnewvnode(9)</a> call allocates a vnode from the pool, possibly reusing an inactive vnode, and returns it to the caller. The vnode returned has a reference count (<b class="var">v_usecount</b>) of 1.<div class="spacer">
</div>
The <a class="link-man" href="../html9/vref.html">vref(9)</a> call increments the reference count on the vnode. It may only be on a vnode with reference count of 1 or greater. The <a class="link-man" href="../html9/vrele.html">vrele(9)</a> and <a class="link-man" href="../html9/vput.html">vput(9)</a> calls decrement the reference count. In addition, the <a class="link-man" href="../html9/vput.html">vput(9)</a> call also releases the vnode lock.<div class="spacer">
</div>
The <a class="link-man" href="../html9/vget.html">vget(9)</a> call, when used on an inactive vnode, will make the vnode active by bumping the reference count to one. When called on an active vnode, <b class="fname">vget</b>() increases the reference count by one. However, if the vnode is being reclaimed concurrently, then <b class="fname">vget</b>() will fail and return an error.<div class="spacer">
</div>
The <a class="link-man" href="../html9/vgone.html">vgone(9)</a> and <a class="link-man" href="../html9/vgonel.html">vgonel(9)</a> calls orchestrate the reclamation of a vnode. They can be called on both active and inactive vnodes.<div class="spacer">
</div>
When transitioning a vnode to the reclaimed state, the VFS will call the <a class="link-man" href="../html9/VOP_RECLAIM.html">VOP_RECLAIM(9)</a> method. File systems use this method to free any file-system-specific data they attached to the vnode.</div>
<div class="subsection">
<h2 id="x566e6f6465206c6f636b73">Vnode locks</h2> The vnode actually has two different types of locks: the vnode lock and the vnode reclamation lock (<span class="define">VXLOCK</span>).</div>
<div class="subsection">
<h2 id="x54686520766e6f6465206c6f636b">The vnode lock</h2> The vnode lock and its consistent use accomplishes the following:<ul style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-bul">
<li class="list-bul" style="margin-top: 1.00em;">
It keeps a locked vnode from changing across certain pairs of VOP_ calls, thus preserving cached data. For example, it keeps the directory from changing between a <a class="link-man" href="../html9/VOP_LOOKUP.html">VOP_LOOKUP(9)</a> call and a <a class="link-man" href="../html9/VOP_CREATE.html">VOP_CREATE(9)</a>. The <b class="fname">VOP_LOOKUP</b>() call makes sure the name doesn't already exist in the directory and finds free room in the directory for the new entry. The <b class="fname">VOP_CREATE</b>() call can then go ahead and create the file without checking if it already exists or looking for free space.</li>
<li class="list-bul" style="margin-top: 1.00em;">
Some file systems rely on it to ensure that only one &#8220;thread&#8221; at a time is calling VOP_ vnode operations on a given file or directory. Otherwise, the file system's behavior is undefined.</li>
<li class="list-bul" style="margin-top: 1.00em;">
On rare occasions, code will hold the vnode lock so that a series of VOP_ operations occurs as an atomic unit. (Of course, this doesn't work with network file systems like NFSv2 that don't have any notion of bundling a bunch of operations into an atomic unit.)</li>
<li class="list-bul" style="margin-top: 1.00em;">
While the vnode lock is held, the vnode will not be reclaimed.</li>
</ul>
<div class="spacer">
</div>
There is a discipline to using the vnode lock. Some VOP_ operations require that the vnode lock is held before being called.<div class="spacer">
</div>
The vnode lock is acquired by calling <a class="link-man" href="../html9/vn_lock.html">vn_lock(9)</a> and released by calling <a class="link-man" href="../html9/VOP_UNLOCK.html">VOP_UNLOCK(9)</a>.<div class="spacer">
</div>
A process is allowed to sleep while holding the vnode lock.<div class="spacer">
</div>
The implementation of the vnode lock is the responsibility of the individual file systems. Not all file systems implement it.<div class="spacer">
</div>
To prevent deadlocks, when acquiring locks on multiple vnodes, the lock of parent directory must be acquired before the lock on the child directory.</div>
<div class="subsection">
<h2 id="x4f7468657220766e6f64652073796e6368726f6e697a6174696f6e">Other vnode synchronization</h2> The vnode reclamation lock (<span class="define">VXLOCK</span>) is used to prevent multiple processes from entering the vnode reclamation code. It is also used as a flag to indicate that reclamation is in progress. The <span class="define">VXWANT</span> flag is set by processes that wish to be woken up when reclamation is finished.<div class="spacer">
</div>
The <a class="link-man" href="../html9/vwaitforio.html">vwaitforio(9)</a> call is used to wait for all outstanding write I/Os associated with a vnode to complete.</div>
<div class="subsection">
<h2 id="x56657273696f6e206e756d6265722f6361706162696c697479">Version number/capability</h2> The vnode capability, <b class="var">v_id</b>, is a 32-bit version number on the vnode. Every time a vnode is reassigned to a new file, the vnode capability is changed. This is used by code that wishes to keep pointers to vnodes but doesn't want to hold a reference (e.g., caches). The code keeps both a vnode pointer and a copy of the capability. The code can later compare the vnode's capability to its copy and see if the vnode still points to the same file.<div class="spacer">
</div>
Note: for this to work, memory assigned to hold a <span class="type">struct vnode</span> can only be used for another purpose when all pointers to it have disappeared. Since the vnode pool has no way of knowing when all pointers have disappeared, it never frees memory it has allocated for vnodes.</div>
<div class="subsection">
<h2 id="x566e6f6465206669656c6473">Vnode fields</h2> Most of the fields of the vnode structure should be treated as opaque and only manipulated through the proper APIs. This section describes the fields that are manipulated directly.<div class="spacer">
</div>
The <b class="var">v_flag</b> attribute contains random flags related to various functions. They are summarized in the following table:<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VROOT</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
This vnode is the root of its file system.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VTEXT</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
This vnode is a pure text prototype.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VSYSTEM</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
This vnode is being used by kernel.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VISTTY</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
This vnode represents a <a class="link-man" href="../html4/tty.html">tty(4)</a>.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VXLOCK</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
This vnode is locked to change its underlying type.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VXWANT</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
A process is waiting for this vnode.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VALIASED</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
This vnode has an alias.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VLOCKSWORK</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
This vnode's underlying file system supports locking discipline.</dd>
</dl>
<div class="spacer">
</div>
The <b class="var">v_tag</b> attribute indicates what file system the vnode belongs to. Very little code actually uses this attribute and its use is deprecated. Programmers should seriously consider using more object-oriented approaches (e.g. function tables). There is no safe way of defining new <b class="var">v_tag</b>'s for loadable file systems. The <b class="var">v_tag</b> attribute is read-only.<div class="spacer">
</div>
The <b class="var">v_type</b> attribute indicates what type of file (e.g. directory, regular, FIFO) this vnode is. This is used by the generic code for various checks. For example, the <a class="link-man" href="../html2/read.html">read(2)</a> system call returns zero when a read is attempted on a directory.<div class="spacer">
</div>
Possible types are:<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VNON</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
This vnode has no type.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VREG</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
This vnode represents a regular file.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VDIR</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
This vnode represents a directory.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VBLK</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
This vnode represents a block device.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VCHR</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
This vnode represents a character device.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VLNK</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
This vnode represents a symbolic link.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VSOCK</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
This vnode represents a socket.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VFIFO</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
This vnode represents a named pipe.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VBAD</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
This vnode represents a bad or dead file.</dd>
</dl>
<div class="spacer">
</div>
The <b class="var">v_data</b> attribute allows a file system to attach a piece of file system specific memory to the vnode. This contains information about the file that is specific to the file system (such as an inode pointer in the case of FFS).<div class="spacer">
</div>
The <b class="var">v_numoutput</b> attribute indicates the number of pending synchronous and asynchronous writes on the vnode. It does not track the number of dirty buffers attached to the vnode. The attribute is used by code like <a class="link-man" href="../html2/fsync.html">fsync(2)</a> to wait for all writes to complete before returning to the user. This attribute must be manipulated at <a class="link-man" href="../html9/splbio.html">splbio(9)</a>.<div class="spacer">
</div>
The <b class="var">v_writecount</b> attribute tracks the number of write calls pending on the vnode.</div>
<div class="subsection">
<h2 id="x52756c6573">Rules</h2> The vast majority of vnode functions may not be called from interrupt context. The exceptions are <b class="fname">bgetvp</b>() and <b class="fname">brelvp</b>(). The following fields of the vnode are manipulated at interrupt level: <b class="var">v_numoutput</b>, <b class="var">v_holdcnt</b>, <b class="var">v_dirtyblkhd</b>, <b class="var">v_cleanblkhd</b>, <b class="var">v_bioflag</b>, <b class="var">v_freelist</b>, and <b class="var">v_synclist</b>. Any access to these fields should be protected by <a class="link-man" href="../html9/splbio.html">splbio(9)</a>.</div>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html9/uvm.html">uvm(9)</a>, <a class="link-man" href="../html9/vaccess.html">vaccess(9)</a>, <a class="link-man" href="../html9/vclean.html">vclean(9)</a>, <a class="link-man" href="../html9/vcount.html">vcount(9)</a>, <a class="link-man" href="../html9/vdevgone.html">vdevgone(9)</a>, <a class="link-man" href="../html9/vfinddev.html">vfinddev(9)</a>, <a class="link-man" href="../html9/vflush.html">vflush(9)</a>, <a class="link-man" href="../html9/vflushbuf.html">vflushbuf(9)</a>, <a class="link-man" href="../html9/vfs.html">vfs(9)</a>, <a class="link-man" href="../html9/vget.html">vget(9)</a>, <a class="link-man" href="../html9/vgone.html">vgone(9)</a>, <a class="link-man" href="../html9/vhold.html">vhold(9)</a>, <a class="link-man" href="../html9/vinvalbuf.html">vinvalbuf(9)</a>, <a class="link-man" href="../html9/vn_lock.html">vn_lock(9)</a>, <a class="link-man" href="../html9/VOP_LOOKUP.html">VOP_LOOKUP(9)</a>, <a class="link-man" href="../html9/vput.html">vput(9)</a>, <a class="link-man" href="../html9/vrecycle.html">vrecycle(9)</a>, <a class="link-man" href="../html9/vref.html">vref(9)</a>, <a class="link-man" href="../html9/vrele.html">vrele(9)</a>, <a class="link-man" href="../html9/vwaitforio.html">vwaitforio(9)</a>, <a class="link-man" href="../html9/vwakeup.html">vwakeup(9)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> This document first appeared in <span class="unix">OpenBSD&#160;2.9</span>.</div>
</div>
</body>
</html>

