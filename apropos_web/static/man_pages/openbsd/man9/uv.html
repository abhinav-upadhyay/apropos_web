<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
UVM_INIT(9)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">uvm_init</b>, <b class="name">uvm_init_limits</b>, <b class="name">uvm_setpagesize</b>, <b class="name">uvm_swap_init</b>, <b class="name">uvm_map</b>, <b class="name">uvm_map_pageable</b>, <b class="name">uvm_map_pageable_all</b>, <b class="name">uvm_map_checkprot</b>, <b class="name">uvm_map_protect</b>, <b class="name">uvm_deallocate</b>, <b class="name">uvmspace_alloc</b>, <b class="name">uvmspace_exec</b>, <b class="name">uvmspace_fork</b>, <b class="name">uvmspace_free</b>, <b class="name">uvmspace_share</b>, <b class="name">uvm_uarea_alloc</b>, <b class="name">uvm_uarea_free</b>, <b class="name">UVM_MAPFLAG</b>, <b class="name">uvm_fault</b>, <b class="name">uvn_attach</b>, <b class="name">uvm_vnp_setsize</b>, <b class="name">uvm_vnp_sync</b>, <b class="name">uvm_vnp_terminate</b>, <b class="name">uvm_vnp_uncache</b>, <b class="name">uvm_io</b>, <b class="name">uvm_km_alloc</b>, <b class="name">uvm_km_zalloc</b>, <b class="name">uvm_km_alloc1</b>, <b class="name">uvm_km_kmemalloc</b>, <b class="name">uvm_km_valloc</b>, <b class="name">uvm_km_valloc_wait</b>, <b class="name">uvm_km_suballoc</b>, <b class="name">uvm_km_free</b>, <b class="name">uvm_km_free_wakeup</b>, <b class="name">uvm_pagealloc</b>, <b class="name">uvm_pagerealloc</b>, <b class="name">uvm_pagefree</b>, <b class="name">uvm_pglistalloc</b>, <b class="name">uvm_pglistfree</b>, <b class="name">uvm_page_physload</b>, <b class="name">uvm_pageout</b>, <b class="name">uao_create</b>, <b class="name">uao_detach</b>, <b class="name">uao_reference</b>, <b class="name">uvm_chgkprot</b>, <b class="name">uvm_kernacc</b>, <b class="name">uvm_vslock</b>, <b class="name">uvm_vsunlock</b>, <b class="name">uvm_meter</b>, <b class="name">uvm_sysctl</b>, <b class="name">uvm_grow</b>, <b class="name">uvm_coredump</b> &#8212; <span class="desc">virtual memory system external interface</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/param.h</a>&gt;</b><br/>
<b class="includes">#include &lt;<a class="link-includes">uvm/uvm.h</a>&gt;</b></div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The UVM virtual memory system manages access to the computer's memory resources. User processes and the kernel access these resources through UVM's external interface. UVM's external interface includes functions that:<div class="spacer">
</div>
<ul style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-hyph">
<li class="list-hyph" style="margin-top: 0.00em;">
initialise UVM subsystems</li>
<li class="list-hyph" style="margin-top: 0.00em;">
manage virtual address spaces</li>
<li class="list-hyph" style="margin-top: 0.00em;">
resolve page faults</li>
<li class="list-hyph" style="margin-top: 0.00em;">
memory map files and devices</li>
<li class="list-hyph" style="margin-top: 0.00em;">
perform uio-based I/O to virtual memory</li>
<li class="list-hyph" style="margin-top: 0.00em;">
allocate and free kernel virtual memory</li>
<li class="list-hyph" style="margin-top: 0.00em;">
allocate and free physical memory</li>
</ul>
<div class="spacer">
</div>
In addition to exporting these services, UVM has two kernel-level processes: pagedaemon and swapper. The pagedaemon process sleeps until physical memory becomes scarce. When that happens, pagedaemon is awoken. It scans physical memory, paging out and freeing memory that has not been recently used. The swapper process swaps in runnable processes that are currently swapped out, if there is room.<div class="spacer">
</div>
UVM has a machine independent and a machine dependent layer. See <a class="link-man" href="../html9/pmap.html">pmap(9)</a> for the machine dependent layer.</div>
<div class="section">
<h1 id="x494e495449414c49534154494f4e">INITIALISATION</h1> <i class="ftype">void</i><br/>
<b class="fname">uvm_init</b>(<i class="farg" style="white-space:nowrap;">void</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">uvm_init_limits</b>(<i class="farg" style="white-space:nowrap;">struct proc *p</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">uvm_setpagesize</b>(<i class="farg" style="white-space:nowrap;">void</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">uvm_swap_init</b>(<i class="farg" style="white-space:nowrap;">void</i>);<div class="spacer">
</div>
The <b class="fname">uvm_init</b>() function sets up the UVM system at system boot time, after the copyright has been printed. It initialises global state, the page, map, kernel virtual memory state, machine-dependent physical map, kernel memory allocator, pager and anonymous memory subsystems, and then enables paging of kernel objects. <b class="fname">uvm_init</b>() must be called after machine-dependent code has registered some free RAM with the <b class="fname">uvm_page_physload</b>() function.<div class="spacer">
</div>
The <b class="fname">uvm_init_limits</b>() function initialises process limits for the named process. This is for use by the system startup for process zero, before any other processes are created.<div class="spacer">
</div>
The <b class="fname">uvm_setpagesize</b>() function initialises the uvmexp members pagesize (if not already done by machine-dependent code), pageshift and pagemask. It should be called by machine-dependent code early in the <a class="link-man" href="../html9/pmap_init.html">pmap_init(9)</a> call.<div class="spacer">
</div>
The <b class="fname">uvm_swap_init</b>() function initialises the swap subsystem.</div>
<div class="section">
<h1 id="x5649525455414c2041444452455353205350414345204d414e4147454d454e54">VIRTUAL ADDRESS SPACE MANAGEMENT</h1> <i class="ftype">int</i><br/>
<b class="fname">uvm_map</b>(<i class="farg" style="white-space:nowrap;">vm_map_t map</i>, <i class="farg" style="white-space:nowrap;">vaddr_t *startp</i>, <i class="farg" style="white-space:nowrap;">vsize_t size</i>, <i class="farg" style="white-space:nowrap;">struct uvm_object *uobj</i>, <i class="farg" style="white-space:nowrap;">voff_t uoffset</i>, <i class="farg" style="white-space:nowrap;">vsize_t alignment</i>, <i class="farg" style="white-space:nowrap;">unsigned int flags</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">uvm_map_pageable</b>(<i class="farg" style="white-space:nowrap;">vm_map_t map</i>, <i class="farg" style="white-space:nowrap;">vaddr_t start</i>, <i class="farg" style="white-space:nowrap;">vaddr_t end</i>, <i class="farg" style="white-space:nowrap;">boolean_t new_pageable</i>, <i class="farg" style="white-space:nowrap;">int lockflags</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">uvm_map_pageable_all</b>(<i class="farg" style="white-space:nowrap;">vm_map_t map</i>, <i class="farg" style="white-space:nowrap;">int flags</i>, <i class="farg" style="white-space:nowrap;">vsize_t limit</i>);<div class="spacer">
</div>
<i class="ftype">boolean_t</i><br/>
<b class="fname">uvm_map_checkprot</b>(<i class="farg" style="white-space:nowrap;">vm_map_t map</i>, <i class="farg" style="white-space:nowrap;">vaddr_t start</i>, <i class="farg" style="white-space:nowrap;">vaddr_t end</i>, <i class="farg" style="white-space:nowrap;">vm_prot_t protection</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">uvm_map_protect</b>(<i class="farg" style="white-space:nowrap;">vm_map_t map</i>, <i class="farg" style="white-space:nowrap;">vaddr_t start</i>, <i class="farg" style="white-space:nowrap;">vaddr_t end</i>, <i class="farg" style="white-space:nowrap;">vm_prot_t new_prot</i>, <i class="farg" style="white-space:nowrap;">boolean_t set_max</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">uvm_deallocate</b>(<i class="farg" style="white-space:nowrap;">vm_map_t map</i>, <i class="farg" style="white-space:nowrap;">vaddr_t start</i>, <i class="farg" style="white-space:nowrap;">vsize_t size</i>);<div class="spacer">
</div>
<i class="ftype">struct vmspace *</i><br/>
<b class="fname">uvmspace_alloc</b>(<i class="farg" style="white-space:nowrap;">vaddr_t min</i>, <i class="farg" style="white-space:nowrap;">vaddr_t max</i>, <i class="farg" style="white-space:nowrap;">boolean_t pageable</i>, <i class="farg" style="white-space:nowrap;">boolean_t remove_holes</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">uvmspace_exec</b>(<i class="farg" style="white-space:nowrap;">struct proc *p</i>, <i class="farg" style="white-space:nowrap;">vaddr_t start</i>, <i class="farg" style="white-space:nowrap;">vaddr_t end</i>);<div class="spacer">
</div>
<i class="ftype">struct vmspace *</i><br/>
<b class="fname">uvmspace_fork</b>(<i class="farg" style="white-space:nowrap;">struct process *pr</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">uvmspace_free</b>(<i class="farg" style="white-space:nowrap;">struct vmspace *vm</i>);<div class="spacer">
</div>
<i class="ftype">struct vmspace *</i><br/>
<b class="fname">uvmspace_share</b>(<i class="farg" style="white-space:nowrap;">struct process *pr</i>);<div class="spacer">
</div>
<i class="ftype">vaddr_t</i><br/>
<b class="fname">uvm_uarea_alloc</b>(<i class="farg" style="white-space:nowrap;">void</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">uvm_uarea_free</b>(<i class="farg" style="white-space:nowrap;">struct proc *p</i>);<div class="spacer">
</div>
<i class="ftype">unsigned int</i><br/>
<b class="fname">UVM_MAPFLAG</b>(<i class="farg" style="white-space:nowrap;">vm_prot_t prot</i>, <i class="farg" style="white-space:nowrap;">vm_prot_t maxprot</i>, <i class="farg" style="white-space:nowrap;">vm_inherit_t inh</i>, <i class="farg" style="white-space:nowrap;">int advice</i>, <i class="farg" style="white-space:nowrap;">int flags</i>);<div class="spacer">
</div>
The <b class="fname">uvm_map</b>() function establishes a valid mapping in map <i class="farg">map</i>, which must be unlocked. The new mapping has size <i class="farg">size</i>, which must be in <span class="define">PAGE_SIZE</span> units. If <i class="farg">alignment</i> is non-zero, it describes the required alignment of the list, in power-of-two notation. The <i class="farg">uobj</i> and <i class="farg">uoffset</i> arguments can have four meanings. When <i class="farg">uobj</i> is <span class="define">NULL</span> and <i class="farg">uoffset</i> is <span class="define">UVM_UNKNOWN_OFFSET</span>, <b class="fname">uvm_map</b>() does not use the machine-dependent <span class="define">PMAP_PREFER</span> function. If <i class="farg">uoffset</i> is any other value, it is used as the hint to <span class="define">PMAP_PREFER</span>. When <i class="farg">uobj</i> is not <span class="define">NULL</span> and <i class="farg">uoffset</i> is <span class="define">UVM_UNKNOWN_OFFSET</span>, <b class="fname">uvm_map</b>() finds the offset based upon the virtual address, passed as <i class="farg">startp</i>. If <i class="farg">uoffset</i> is any other value, we are doing a normal mapping at this offset. The start address of the map will be returned in <i class="farg">startp</i>.<div class="spacer">
</div>
<i class="farg">flags</i> passed to <b class="fname">uvm_map</b>() are typically created using the <b class="fname">UVM_MAPFLAG</b>() macro, which uses the following values. The <i class="farg">prot</i> and <i class="farg">maxprot</i> can take a mix of the following values:<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
#define PROT_MASK   0x07    /* protection mask */ 
#define PROT_NONE   0x00    /* protection none */ 
#define PROT_READ   0x01    /* read */ 
#define PROT_WRITE  0x02    /* write */ 
#define PROT_EXEC   0x04    /* exec */</pre>
<div class="spacer">
</div>
The values that <i class="farg">inh</i> can take are:<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
#define MAP_INHERIT_MASK    0x30    /* inherit mask */ 
#define MAP_INHERIT_SHARE   0x00    /* &quot;share&quot; */ 
#define MAP_INHERIT_COPY    0x10    /* &quot;copy&quot; */ 
#define MAP_INHERIT_NONE    0x20    /* &quot;none&quot; */ 
#define MAP_INHERIT_ZERO    0x30    /* &quot;zero&quot; */</pre>
<div class="spacer">
</div>
The values that <i class="farg">advice</i> can take are:<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
#define MADV_NORMAL  0x0     /* 'normal' */ 
#define MADV_RANDOM  0x1     /* 'random' */ 
#define MADV_SEQUENTIAL 0x2  /* 'sequential' */ 
#define MADV_MASK    0x7     /* mask */</pre>
<div class="spacer">
</div>
The values that <i class="farg">flags</i> can take are:<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
#define UVM_FLAG_FIXED   0x010000 /* find space */ 
#define UVM_FLAG_OVERLAY 0x020000 /* establish overlay */ 
#define UVM_FLAG_NOMERGE 0x040000 /* don't merge map entries */ 
#define UVM_FLAG_COPYONW 0x080000 /* set copy_on_write flag */ 
#define UVM_FLAG_AMAPPAD 0x100000 /* bss: pad amap to reduce malloc() */ 
#define UVM_FLAG_TRYLOCK 0x200000 /* fail if we can not lock map */ 
#define UVM_FLAG_HOLE    0x400000 /* no backend */</pre>
<div class="spacer">
</div>
The <span class="define">UVM_MAPFLAG</span> macro arguments can be combined with an or operator. There are also some additional macros to extract bits from the flags. The <span class="define">UVM_PROTECTION</span>, <span class="define">UVM_INHERIT</span>, <span class="define">UVM_MAXPROTECTION</span> and <span class="define">UVM_ADVICE</span> macros return the protection, inheritance, maximum protection and advice, respectively. <b class="fname">uvm_map</b>() returns a standard errno.<div class="spacer">
</div>
The <b class="fname">uvm_map_pageable</b>() function changes the pageability of the pages in the range from <i class="farg">start</i> to <i class="farg">end</i> in map <i class="farg">map</i> to <i class="farg">new_pageable</i>. The <b class="fname">uvm_map_pageable_all</b>() function changes the pageability of all mapped regions. If <i class="farg">limit</i> is non-zero and <b class="fname">pmap_wired_count</b>() is implemented, <span class="define">ENOMEM</span> is returned if the amount of wired pages exceed <i class="farg">limit</i>. The map is locked on entry if <i class="farg">lockflags</i> contain <span class="define">UVM_LK_ENTER</span>, and locked on exit if <i class="farg">lockflags</i> contain <span class="define">UVM_LK_EXIT</span>. <b class="fname">uvm_map_pageable</b>() and <b class="fname">uvm_map_pageable_all</b>() return a standard errno.<div class="spacer">
</div>
The <b class="fname">uvm_map_checkprot</b>() function checks the protection of the range from <i class="farg">start</i> to <i class="farg">end</i> in map <i class="farg">map</i> against <i class="farg">protection</i>. This returns either <span class="define">TRUE</span> or <span class="define">FALSE</span>.<div class="spacer">
</div>
The <b class="fname">uvm_map_protect</b>() function changes the protection <i class="farg">start</i> to <i class="farg">end</i> in map <i class="farg">map</i> to <i class="farg">new_prot</i>, also setting the maximum protection to the region to <i class="farg">new_prot</i> if <i class="farg">set_max</i> is non-zero. This function returns a standard errno.<div class="spacer">
</div>
The <b class="fname">uvm_deallocate</b>() function deallocates kernel memory in map <i class="farg">map</i> from address <i class="farg">start</i> to <i class="farg">start + size</i>.<div class="spacer">
</div>
The <b class="fname">uvmspace_alloc</b>() function allocates and returns a new address space, with ranges from <i class="farg">min</i> to <i class="farg">max</i>, setting the pageability of the address space to <i class="farg">pageable</i>. If <i class="farg">remove_holes</i> is non-zero, hardware &#8216;holes&#8217; in the virtual address space will be removed from the newly allocated address space.<div class="spacer">
</div>
The <b class="fname">uvmspace_exec</b>() function either reuses the address space of process <i class="farg">p</i> if there are no other references to it, or creates a new one with <b class="fname">uvmspace_alloc</b>(). The range of valid addresses in the address space is reset to <i class="farg">start</i> through <i class="farg">end</i>.<div class="spacer">
</div>
The <b class="fname">uvmspace_fork</b>() function creates and returns a new address space based upon the address space of process <i class="farg">pr</i> and is typically used when allocating an address space for a child process.<div class="spacer">
</div>
The <b class="fname">uvmspace_free</b>() function lowers the reference count on the address space <i class="farg">vm</i>, freeing the data structures if there are no other references.<div class="spacer">
</div>
The <b class="fname">uvmspace_share</b>() function returns a reference to the address space of process <i class="farg">pr</i>, increasing its reference count.<div class="spacer">
</div>
The <b class="fname">uvm_uarea_alloc</b>() function allocates a thread's &#8216;uarea&#8217;, the memory where its kernel stack and PCB are stored. The <b class="fname">uvm_uarea_free</b>() function frees the uarea for thread <i class="farg">p</i>, which must no longer be running.</div>
<div class="section">
<h1 id="x50414745204641554c542048414e444c494e47">PAGE FAULT HANDLING</h1> <i class="ftype">int</i><br/>
<b class="fname">uvm_fault</b>(<i class="farg" style="white-space:nowrap;">vm_map_t orig_map</i>, <i class="farg" style="white-space:nowrap;">vaddr_t vaddr</i>, <i class="farg" style="white-space:nowrap;">vm_fault_t fault_type</i>, <i class="farg" style="white-space:nowrap;">vm_prot_t access_type</i>);<div class="spacer">
</div>
The <b class="fname">uvm_fault</b>() function is the main entry point for faults. It takes <i class="farg">orig_map</i> as the map the fault originated in, a <i class="farg">vaddr</i> offset into the map the fault occurred, <i class="farg">fault_type</i> describing the type of fault, and <i class="farg">access_type</i> describing the type of access requested. <b class="fname">uvm_fault</b>() returns a standard errno.</div>
<div class="section">
<h1 id="x4d454d4f5259204d415050494e472046494c455320414e442044455649434553">MEMORY MAPPING FILES AND DEVICES</h1> <i class="ftype">struct uvm_object *</i><br/>
<b class="fname">uvn_attach</b>(<i class="farg" style="white-space:nowrap;">struct vnode *vp</i>, <i class="farg" style="white-space:nowrap;">vm_prot_t accessprot</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">uvm_vnp_setsize</b>(<i class="farg" style="white-space:nowrap;">struct vnode *vp</i>, <i class="farg" style="white-space:nowrap;">voff_t newsize</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">uvm_vnp_sync</b>(<i class="farg" style="white-space:nowrap;">struct mount *mp</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">uvm_vnp_terminate</b>(<i class="farg" style="white-space:nowrap;">struct vnode *vp</i>);<div class="spacer">
</div>
<i class="ftype">boolean_t</i><br/>
<b class="fname">uvm_vnp_uncache</b>(<i class="farg" style="white-space:nowrap;">struct vnode *vp</i>);<div class="spacer">
</div>
The <b class="fname">uvn_attach</b>() function attaches a UVM object to vnode <i class="farg">vp</i>, creating the object if necessary. The object is returned.<div class="spacer">
</div>
The <b class="fname">uvm_vnp_setsize</b>() function sets the size of vnode <i class="farg">vp</i> to <i class="farg">newsize</i>. Caller must hold a reference to the vnode. If the vnode shrinks, pages no longer used are discarded. This function will be removed when the file system and VM buffer caches are merged.<div class="spacer">
</div>
The <b class="fname">uvm_vnp_sync</b>() function flushes dirty vnodes from either the mount point passed in <i class="farg">mp</i>, or all dirty vnodes if <i class="farg">mp</i> is <span class="define">NULL</span>. This function will be removed when the file system and VM buffer caches are merged.<div class="spacer">
</div>
The <b class="fname">uvm_vnp_terminate</b>() function frees all VM resources allocated to vnode <i class="farg">vp</i>. If the vnode still has references, it will not be destroyed; however all future operations using this vnode will fail. This function will be removed when the file system and VM buffer caches are merged.<div class="spacer">
</div>
The <b class="fname">uvm_vnp_uncache</b>() function disables vnode <i class="farg">vp</i> from persisting when all references are freed. This function will be removed when the file system and UVM caches are unified. Returns true if there is no active vnode.</div>
<div class="section">
<h1 id="x5649525455414c204d454d4f525920492f4f">VIRTUAL MEMORY I/O</h1> <i class="ftype">int</i><br/>
<b class="fname">uvm_io</b>(<i class="farg" style="white-space:nowrap;">vm_map_t map</i>, <i class="farg" style="white-space:nowrap;">struct uio *uio</i>);<div class="spacer">
</div>
The <b class="fname">uvm_io</b>() function performs the I/O described in <i class="farg">uio</i> on the memory described in <i class="farg">map</i>.</div>
<div class="section">
<h1 id="x414c4c4f434154494f4e204f46204b45524e454c204d454d4f5259">ALLOCATION OF KERNEL MEMORY</h1> <i class="ftype">vaddr_t</i><br/>
<b class="fname">uvm_km_alloc</b>(<i class="farg" style="white-space:nowrap;">vm_map_t map</i>, <i class="farg" style="white-space:nowrap;">vsize_t size</i>);<div class="spacer">
</div>
<i class="ftype">vaddr_t</i><br/>
<b class="fname">uvm_km_zalloc</b>(<i class="farg" style="white-space:nowrap;">vm_map_t map</i>, <i class="farg" style="white-space:nowrap;">vsize_t size</i>);<div class="spacer">
</div>
<i class="ftype">vaddr_t</i><br/>
<b class="fname">uvm_km_alloc1</b>(<i class="farg" style="white-space:nowrap;">vm_map_t map</i>, <i class="farg" style="white-space:nowrap;">vsize_t size</i>, <i class="farg" style="white-space:nowrap;">vsize_t align</i>, <i class="farg" style="white-space:nowrap;">boolean_t zeroit</i>);<div class="spacer">
</div>
<i class="ftype">vaddr_t</i><br/>
<b class="fname">uvm_km_kmemalloc</b>(<i class="farg" style="white-space:nowrap;">vm_map_t map</i>, <i class="farg" style="white-space:nowrap;">struct uvm_object *obj</i>, <i class="farg" style="white-space:nowrap;">vsize_t size</i>, <i class="farg" style="white-space:nowrap;">int flags</i>);<div class="spacer">
</div>
<i class="ftype">vaddr_t</i><br/>
<b class="fname">uvm_km_valloc</b>(<i class="farg" style="white-space:nowrap;">vm_map_t map</i>, <i class="farg" style="white-space:nowrap;">vsize_t size</i>);<div class="spacer">
</div>
<i class="ftype">vaddr_t</i><br/>
<b class="fname">uvm_km_valloc_wait</b>(<i class="farg" style="white-space:nowrap;">vm_map_t map</i>, <i class="farg" style="white-space:nowrap;">vsize_t size</i>);<div class="spacer">
</div>
<i class="ftype">struct vm_map *</i><br/>
<b class="fname">uvm_km_suballoc</b>(<i class="farg" style="white-space:nowrap;">vm_map_t map</i>, <i class="farg" style="white-space:nowrap;">vaddr_t *min</i>, <i class="farg" style="white-space:nowrap;">vaddr_t *max </i>, <i class="farg" style="white-space:nowrap;">vsize_t size</i>, <i class="farg" style="white-space:nowrap;">int flags</i>, <i class="farg" style="white-space:nowrap;">boolean_t fixed</i>, <i class="farg" style="white-space:nowrap;">vm_map_t submap</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">uvm_km_free</b>(<i class="farg" style="white-space:nowrap;">vm_map_t map</i>, <i class="farg" style="white-space:nowrap;">vaddr_t addr</i>, <i class="farg" style="white-space:nowrap;">vsize_t size</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">uvm_km_free_wakeup</b>(<i class="farg" style="white-space:nowrap;">vm_map_t map</i>, <i class="farg" style="white-space:nowrap;">vaddr_t addr</i>, <i class="farg" style="white-space:nowrap;">vsize_t size</i>);<div class="spacer">
</div>
The <b class="fname">uvm_km_alloc</b>() and <b class="fname">uvm_km_zalloc</b>() functions allocate <i class="farg">size</i> bytes of wired kernel memory in map <i class="farg">map</i>. In addition to allocation, <b class="fname">uvm_km_zalloc</b>() zeros the memory. Both of these functions are defined as macros in terms of <b class="fname">uvm_km_alloc1</b>(), and should almost always be used in preference to <b class="fname">uvm_km_alloc1</b>().<div class="spacer">
</div>
The <b class="fname">uvm_km_alloc1</b>() function allocates and returns <i class="farg">size</i> bytes of wired memory in the kernel map aligned to the <i class="farg">align</i> boundary, zeroing the memory if the <i class="farg">zeroit</i> argument is non-zero.<div class="spacer">
</div>
The <b class="fname">uvm_km_kmemalloc</b>() function allocates and returns <i class="farg">size</i> bytes of wired kernel memory into <i class="farg">obj</i>. The flags can be any of:<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
#define UVM_KMF_NOWAIT  0x1                     /* matches M_NOWAIT */ 
#define UVM_KMF_VALLOC  0x2                     /* allocate VA only */ 
#define UVM_KMF_TRYLOCK UVM_FLAG_TRYLOCK        /* try locking only */</pre>
<div class="spacer">
</div>
The <span class="define">UVM_KMF_NOWAIT</span> flag causes <b class="fname">uvm_km_kmemalloc</b>() to return immediately if no memory is available. <span class="define">UVM_KMF_VALLOC</span> causes no pages to be allocated, only a virtual address. <span class="define">UVM_KMF_TRYLOCK</span> causes <b class="fname">uvm_km_kmemalloc</b>() to only try and not sleep when locking maps.<div class="spacer">
</div>
The <b class="fname">uvm_km_valloc</b>() and <b class="fname">uvm_km_valloc_wait</b>() functions return a newly allocated zero-filled address in the kernel map of size <i class="farg">size</i>. <b class="fname">uvm_km_valloc_wait</b>() will also wait for kernel memory to become available, if there is a memory shortage.<div class="spacer">
</div>
The <b class="fname">uvm_km_suballoc</b>() function allocates submap (with the specified <i class="farg">flags</i>, as described above) from <i class="farg">map</i>, creating a new map if <i class="farg">submap</i> is <span class="define">NULL</span>. The addresses of the submap can be specified exactly by setting the <i class="farg">fixed</i> argument to non-zero, which causes the <i class="farg">min</i> argument to specify the beginning of the address in the submap. If <i class="farg">fixed</i> is zero, any address of size <i class="farg">size</i> will be allocated from <i class="farg">map</i> and the start and end addresses returned in <i class="farg">min</i> and <i class="farg">max</i>.<div class="spacer">
</div>
The <b class="fname">uvm_km_free</b>() and <b class="fname">uvm_km_free_wakeup</b>() functions free <i class="farg">size</i> bytes of memory in the kernel map, starting at address <i class="farg">addr</i>. <b class="fname">uvm_km_free_wakeup</b>() calls <b class="fname">wakeup</b>() on the map before unlocking the map.</div>
<div class="section">
<h1 id="x414c4c4f434154494f4e204f4620504859534943414c204d454d4f5259">ALLOCATION OF PHYSICAL MEMORY</h1> <i class="ftype">struct vm_page *</i><br/>
<b class="fname">uvm_pagealloc</b>(<i class="farg" style="white-space:nowrap;">struct uvm_object *uobj</i>, <i class="farg" style="white-space:nowrap;">voff_t off</i>, <i class="farg" style="white-space:nowrap;">struct vm_anon *anon</i>, <i class="farg" style="white-space:nowrap;">int flags</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">uvm_pagerealloc</b>(<i class="farg" style="white-space:nowrap;">struct vm_page *pg</i>, <i class="farg" style="white-space:nowrap;">struct uvm_object *newobj</i>, <i class="farg" style="white-space:nowrap;">voff_t newoff</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">uvm_pagefree</b>(<i class="farg" style="white-space:nowrap;">struct vm_page *pg</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">uvm_pglistalloc</b>(<i class="farg" style="white-space:nowrap;">psize_t size</i>, <i class="farg" style="white-space:nowrap;">paddr_t low</i>, <i class="farg" style="white-space:nowrap;">paddr_t high</i>, <i class="farg" style="white-space:nowrap;">paddr_t alignment</i>, <i class="farg" style="white-space:nowrap;">paddr_t boundary</i>, <i class="farg" style="white-space:nowrap;">struct pglist *rlist</i>, <i class="farg" style="white-space:nowrap;">int nsegs</i>, <i class="farg" style="white-space:nowrap;">int flags</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">uvm_pglistfree</b>(<i class="farg" style="white-space:nowrap;">struct pglist *list</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">uvm_page_physload</b>(<i class="farg" style="white-space:nowrap;">paddr_t start</i>, <i class="farg" style="white-space:nowrap;">paddr_t end</i>, <i class="farg" style="white-space:nowrap;">paddr_t avail_start</i>, <i class="farg" style="white-space:nowrap;">paddr_t avail_end</i>, <i class="farg" style="white-space:nowrap;">int free_list</i>);<div class="spacer">
</div>
The <b class="fname">uvm_pagealloc</b>() function allocates a page of memory at virtual address <i class="farg">off</i> in either the object <i class="farg">uobj</i> or the anonymous memory <i class="farg">anon</i>, or returns <span class="define">NULL</span> if no pages are free. Only one of <i class="farg">anon</i> and <i class="farg">uobj</i> can be non <span class="define">NULL</span>. The <i class="farg">flags</i> can be any of:<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
#define UVM_PGA_USERESERVE      0x0001  /* ok to use reserve pages */ 
#define UVM_PGA_ZERO            0x0002  /* returned page must be zeroed */</pre>
<div class="spacer">
</div>
The <span class="define">UVM_PGA_USERESERVE</span> flag means to allocate a page even if that will result in the number of free pages being lower than <span class="define">uvmexp.reserve_pagedaemon</span> (if the current thread is the pagedaemon) or <span class="define">uvmexp.reserve_kernel</span> (if the current thread is not the pagedaemon). The <span class="define">UVM_PGA_ZERO</span> flag causes the returned page to be filled with zeroes, either by allocating it from a pool of pre-zeroed pages or by zeroing it in-line as necessary.<div class="spacer">
</div>
The <b class="fname">uvm_pagerealloc</b>() function reallocates page <i class="farg">pg</i> to a new object <i class="farg">newobj</i>, at a new offset <i class="farg">newoff</i>.<div class="spacer">
</div>
The <b class="fname">uvm_pagefree</b>() function frees the physical page <i class="farg">pg</i>.<div class="spacer">
</div>
The <b class="fname">uvm_pglistalloc</b>() function allocates a list of pages for size <i class="farg">size</i> byte under various constraints. <i class="farg">low</i> and <i class="farg">high</i> describe the lowest and highest addresses acceptable for the list. If <i class="farg">alignment</i> is non-zero, it describes the required alignment of the list, in power-of-two notation. If <i class="farg">boundary</i> is non-zero, no segment of the list may cross this power-of-two boundary, relative to zero. <i class="farg">nsegs</i> is the maximum number of physically contiguous segments. The allocated memory is returned in the <i class="farg">rlist</i> list. The <i class="farg">flags</i> can be any of:<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
#define UVM_PLA_WAITOK	0x0001	/* may sleep */ 
#define UVM_PLA_NOWAIT	0x0002	/* can't sleep */ 
#define UVM_PLA_ZERO	0x0004	/* zero all pages before returning */</pre>
<div class="spacer">
</div>
The <span class="define">UVM_PLA_WAITOK</span> flag means that the function may sleep while trying to allocate the list of pages (this is currently ignored). Conversely, the <span class="define">UVM_PLA_NOWAIT</span> flag signifies that the function may not sleep while allocating. It is an error not to provide one of the above flags. Optionally, one may also specify the <span class="define">UVM_PLA_ZERO</span> flag to receive zeroed memory in the page list.<div class="spacer">
</div>
The <b class="fname">uvm_pglistfree</b>() function frees the list of pages pointed to by <i class="farg">list</i>.<div class="spacer">
</div>
The <b class="fname">uvm_page_physload</b>() function loads physical memory segments into VM space on the specified <i class="farg">free_list</i>. <b class="fname">uvm_page_physload</b>() must be called at system boot time to set up physical memory management pages. The arguments describe the <i class="farg">start</i> and <i class="farg">end</i> of the physical addresses of the segment, and the available start and end addresses of pages not already in use.</div>
<div class="section">
<h1 id="x50524f434553534553">PROCESSES</h1> <i class="ftype">void</i><br/>
<b class="fname">uvm_pageout</b>(<i class="farg" style="white-space:nowrap;">void *arg</i>);<div class="spacer">
</div>
The <b class="fname">uvm_pageout</b>() function is the main loop for the page daemon. The <i class="farg">arg</i> argument is ignored.</div>
<div class="section">
<h1 id="x4d495343454c4c414e454f55532046554e4354494f4e53">MISCELLANEOUS FUNCTIONS</h1> <i class="ftype">struct uvm_object *</i><br/>
<b class="fname">uao_create</b>(<i class="farg" style="white-space:nowrap;">vsize_t size</i>, <i class="farg" style="white-space:nowrap;">int flags</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">uao_detach</b>(<i class="farg" style="white-space:nowrap;">struct uvm_object *uobj</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">uao_reference</b>(<i class="farg" style="white-space:nowrap;">struct uvm_object *uobj</i>);<div class="spacer">
</div>
<i class="ftype">boolean_t</i><br/>
<b class="fname">uvm_chgkprot</b>(<i class="farg" style="white-space:nowrap;">caddr_t addr</i>, <i class="farg" style="white-space:nowrap;">size_t len</i>, <i class="farg" style="white-space:nowrap;">int rw</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">uvm_kernacc</b>(<i class="farg" style="white-space:nowrap;">caddr_t addr</i>, <i class="farg" style="white-space:nowrap;">size_t len</i>, <i class="farg" style="white-space:nowrap;">int rw</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">uvm_vslock</b>(<i class="farg" style="white-space:nowrap;">struct proc *p</i>, <i class="farg" style="white-space:nowrap;">caddr_t addr</i>, <i class="farg" style="white-space:nowrap;">size_t len</i>, <i class="farg" style="white-space:nowrap;">vm_prot_t access_type</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">uvm_vsunlock</b>(<i class="farg" style="white-space:nowrap;">struct proc *p</i>, <i class="farg" style="white-space:nowrap;">caddr_t addr</i>, <i class="farg" style="white-space:nowrap;">size_t len</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">uvm_meter</b>();<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">uvm_sysctl</b>(<i class="farg" style="white-space:nowrap;">int *name</i>, <i class="farg" style="white-space:nowrap;">u_int namelen</i>, <i class="farg" style="white-space:nowrap;">void *oldp</i>, <i class="farg" style="white-space:nowrap;">size_t *oldlenp</i>, <i class="farg" style="white-space:nowrap;">void *newp </i>, <i class="farg" style="white-space:nowrap;">size_t newlen</i>, <i class="farg" style="white-space:nowrap;">struct proc *p</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">uvm_grow</b>(<i class="farg" style="white-space:nowrap;">struct proc *p</i>, <i class="farg" style="white-space:nowrap;">vaddr_t sp</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">uvm_coredump</b>(<i class="farg" style="white-space:nowrap;">struct proc *p</i>, <i class="farg" style="white-space:nowrap;">struct vnode *vp</i>, <i class="farg" style="white-space:nowrap;">struct ucred *cred</i>, <i class="farg" style="white-space:nowrap;">struct core *chdr</i>);<div class="spacer">
</div>
The <b class="fname">uao_create</b>(), <b class="fname">uao_detach</b>() and <b class="fname">uao_reference</b>() functions operate on anonymous memory objects, such as those used to support System V shared memory. <b class="fname">uao_create</b>() returns an object of size <i class="farg">size</i> with flags:<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
#define UAO_FLAG_KERNOBJ        0x1     /* create kernel object */ 
#define UAO_FLAG_KERNSWAP       0x2     /* enable kernel swap */ 
<div class="spacer">
</div>
</pre>
which can only be used once each at system boot time. <b class="fname">uao_reference</b>() creates an additional reference to the named anonymous memory object. <b class="fname">uao_detach</b>() removes a reference from the named anonymous memory object, destroying it if removing the last reference.<div class="spacer">
</div>
The <b class="fname">uvm_chgkprot</b>() function changes the protection of kernel memory from <i class="farg">addr</i> to <i class="farg">addr + len</i> to the value of <i class="farg">rw</i>. This is primarily useful for debuggers, for setting breakpoints. This function is only available with options <span class="define">KGDB</span>.<div class="spacer">
</div>
The <b class="fname">uvm_kernacc</b>() function checks the access at address <i class="farg">addr</i> to <i class="farg">addr + len</i> for <i class="farg">rw</i> access, in the kernel address space.<div class="spacer">
</div>
The <b class="fname">uvm_vslock</b>() and <b class="fname">uvm_vsunlock</b>() functions control the wiring and unwiring of pages for process <i class="farg">p</i> from <i class="farg">addr</i> to <i class="farg">addr + len</i>. The <i class="farg">access_type</i> argument of <b class="fname">uvm_vslock</b>() is passed to <b class="fname">uvm_fault</b>(). These functions are normally used to wire memory for I/O.<div class="spacer">
</div>
The <b class="fname">uvm_meter</b>() function calculates the load average and wakes up the swapper if necessary.<div class="spacer">
</div>
The <b class="fname">uvm_sysctl</b>() function provides support for the <span class="define">CTL_VM</span> domain of the <a class="link-man" href="../html3/sysctl.html">sysctl(3)</a> hierarchy. <b class="fname">uvm_sysctl</b>() handles the <span class="define">VM_LOADAVG</span>, <span class="define">VM_METER</span> and <span class="define">VM_UVMEXP</span> calls, which return the current load averages, calculates current VM totals, and returns the uvmexp structure respectively. The load averages are accessed from userland using the <a class="link-man" href="../html3/getloadavg.html">getloadavg(3)</a> function. The uvmexp structure has all global state of the UVM system, and has the following members:<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
/* vm_page constants */ 
int pagesize;   /* size of a page (PAGE_SIZE): must be power of 2 */ 
int pagemask;   /* page mask */ 
int pageshift;  /* page shift */ 
 
/* vm_page counters */ 
int npages;     /* number of pages we manage */ 
int free;       /* number of free pages */ 
int active;     /* number of active pages */ 
int inactive;   /* number of pages that we free'd but may want back */ 
int paging;	/* number of pages in the process of being paged out */ 
int wired;      /* number of wired pages */ 
 
int zeropages;		/* number of zero'd pages */ 
int reserve_pagedaemon; /* number of pages reserved for pagedaemon */ 
int reserve_kernel;	/* number of pages reserved for kernel */ 
int anonpages;		/* number of pages used by anon pagers */ 
int vnodepages;		/* number of pages used by vnode page cache */ 
int vtextpages;		/* number of pages used by vtext vnodes */ 
 
/* pageout params */ 
int freemin;    /* min number of free pages */ 
int freetarg;   /* target number of free pages */ 
int inactarg;   /* target number of inactive pages */ 
int wiredmax;   /* max number of wired pages */ 
int anonmin;	/* min threshold for anon pages */ 
int vtextmin;	/* min threshold for vtext pages */ 
int vnodemin;	/* min threshold for vnode pages */ 
int anonminpct;	/* min percent anon pages */ 
int vtextminpct;/* min percent vtext pages */ 
int vnodeminpct;/* min percent vnode pages */ 
 
/* swap */ 
int nswapdev;	/* number of configured swap devices in system */ 
int swpages;	/* number of PAGE_SIZE'ed swap pages */ 
int swpginuse;	/* number of swap pages in use */ 
int swpgonly;	/* number of swap pages in use, not also in RAM */ 
int nswget;	/* number of times fault calls uvm_swap_get() */ 
int nanon;	/* number total of anon's in system */ 
int nanonneeded;/* number of anons currently needed */ 
int nfreeanon;	/* number of free anon's */ 
 
/* stat counters */ 
int faults;		/* page fault count */ 
int traps;		/* trap count */ 
int intrs;		/* interrupt count */ 
int swtch;		/* context switch count */ 
int softs;		/* software interrupt count */ 
int syscalls;		/* system calls */ 
int pageins;		/* pagein operation count */ 
			/* pageouts are in pdpageouts below */ 
int swapins;		/* swapins */ 
int swapouts;		/* swapouts */ 
int pgswapin;		/* pages swapped in */ 
int pgswapout;		/* pages swapped out */ 
int forks;		/* forks */ 
int forks_ppwait;	/* forks where parent waits */ 
int forks_sharevm;	/* forks where vmspace is shared */ 
int pga_zerohit;	/* pagealloc where zero wanted and zero 
			   was available */ 
int pga_zeromiss;	/* pagealloc where zero wanted and zero 
			   not available */ 
int zeroaborts;		/* number of times page zeroing was 
			   aborted */ 
 
/* fault subcounters */ 
int fltnoram;	/* number of times fault was out of ram */ 
int fltnoanon;	/* number of times fault was out of anons */ 
int fltpgwait;	/* number of times fault had to wait on a page */ 
int fltpgrele;	/* number of times fault found a released page */ 
int fltrelck;	/* number of times fault relock called */ 
int fltrelckok;	/* number of times fault relock is a success */ 
int fltanget;	/* number of times fault gets anon page */ 
int fltanretry;	/* number of times fault retrys an anon get */ 
int fltamcopy;	/* number of times fault clears &quot;needs copy&quot; */ 
int fltnamap;	/* number of times fault maps a neighbor anon page */ 
int fltnomap;	/* number of times fault maps a neighbor obj page */ 
int fltlget;	/* number of times fault does a locked pgo_get */ 
int fltget;	/* number of times fault does an unlocked get */ 
int flt_anon;	/* number of times fault anon (case 1a) */ 
int flt_acow;	/* number of times fault anon cow (case 1b) */ 
int flt_obj;	/* number of times fault is on object page (2a) */ 
int flt_prcopy;	/* number of times fault promotes with copy (2b) */ 
int flt_przero;	/* number of times fault promotes with zerofill (2b) */ 
 
/* daemon counters */ 
int pdwoke;	/* number of times daemon woke up */ 
int pdrevs;	/* number of times daemon rev'd clock hand */ 
int pdswout;	/* number of times daemon called for swapout */ 
int pdfreed;	/* number of pages daemon freed since boot */ 
int pdscans;	/* number of pages daemon scanned since boot */ 
int pdanscan;	/* number of anonymous pages scanned by daemon */ 
int pdobscan;	/* number of object pages scanned by daemon */ 
int pdreact;	/* number of pages daemon reactivated since boot */ 
int pdbusy;	/* number of times daemon found a busy page */ 
int pdpageouts;	/* number of times daemon started a pageout */ 
int pdpending;	/* number of times daemon got a pending pagout */ 
int pddeact;	/* number of pages daemon deactivates */ 
int pdreanon;	/* anon pages reactivated due to min threshold */ 
int pdrevnode;	/* vnode pages reactivated due to min threshold */ 
int pdrevtext;	/* vtext pages reactivated due to min threshold */ 
 
int fpswtch;	/* FPU context switches */ 
int kmapent;	/* number of kernel map entries */</pre>
<div class="spacer">
</div>
The <b class="fname">uvm_grow</b>() function increases the stack segment of process <i class="farg">p</i> to include <i class="farg">sp</i>.<div class="spacer">
</div>
The <b class="fname">uvm_coredump</b>() function generates a coredump on vnode <i class="farg">vp</i> for process <i class="farg">p</i> with credentials <i class="farg">cred</i> and core header description in <i class="farg">chdr</i>.</div>
<div class="section">
<h1 id="x4e4f544553">NOTES</h1> The structure and types whose names begin with &#8220;vm_&#8221; were named so UVM could coexist with BSD VM during the early development stages.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html3/getloadavg.html">getloadavg(3)</a>, <a class="link-man" href="../html3/kvm.html">kvm(3)</a>, <a class="link-man" href="../html3/sysctl.html">sysctl(3)</a>, <a class="link-man" href="../html4/ddb.html">ddb(4)</a>, <a class="link-man" href="../html4/options.html">options(4)</a>, <a class="link-man" href="../html9/pmap.html">pmap(9)</a><div class="spacer">
</div>
<span class="ref"><span class="ref-auth">Charles D. Cranor</span>, <span class="ref-title">Design and Implementation of the UVM Virtual Memory System, D.Sc. dissertation</span>, <span class="ref-corp">Department of Computer Science, Sever Institute of Technology, Washington University</span>, <span class="ref-city">St. Louis, Missouri</span>, <span class="ref-date">August 1998</span>.</span></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The UVM virtual memory system was developed at Washington University in St. Louis. UVM's roots lie partly in the Mach-based <span class="unix">4.4BSD</span> VM system, the <span class="unix">FreeBSD</span> VM system, and the SunOS4 VM system. UVM's basic structure is based on the <span class="unix">4.4BSD</span> VM system. UVM's new anonymous memory system is based on the anonymous memory system found in the SunOS4 VM (as described in papers published by Sun Microsystems, Inc.). UVM also includes a number of features new to <span class="unix">BSD</span> including page loanout, map entry passing, simplified copy-on-write, and clustered anonymous memory pageout.<div class="spacer">
</div>
UVM appeared in <span class="unix">OpenBSD&#160;2.9</span>.</div>
<div class="section">
<h1 id="x415554484f5253">AUTHORS</h1> <span class="author">Charles D. Cranor</span> &lt;<a class="link-mail" href="mailto:chuck@ccrc.wustl.edu">chuck@ccrc.wustl.edu</a>&gt; designed and implemented UVM.<div class="spacer">
</div>
<span class="author">Matthew Green</span> &lt;<a class="link-mail" href="mailto:mrg@eterna.com.au">mrg@eterna.com.au</a>&gt; wrote the swap-space management code.<div class="spacer">
</div>
<span class="author">Chuck Silvers</span> &lt;<a class="link-mail" href="mailto:chuq@chuq.com">chuq@chuq.com</a>&gt; implemented the aobj pager, thus allowing UVM to support System V shared memory and process swapping.<div class="spacer">
</div>
<span class="author">Artur Grabowski</span> &lt;<a class="link-mail" href="mailto:art@openbsd.org">art@openbsd.org</a>&gt; handled the logistical issues involved with merging UVM into the <span class="unix">OpenBSD</span> source tree.</div>
</div>
</body>
</html>

