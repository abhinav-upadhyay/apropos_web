<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
MGET(9)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">m_copym2</b>, <b class="name">m_copym</b>, <b class="name">m_free</b>, <b class="name">m_get</b>, <b class="name">MGET</b>, <b class="name">m_getclr</b>, <b class="name">m_gethdr</b>, <b class="name">m_resethdr</b>, <b class="name">MGETHDR</b>, <b class="name">m_prepend</b>, <b class="name">M_PREPEND</b>, <b class="name">m_pulldown</b>, <b class="name">m_pullup</b>, <b class="name">m_split</b>, <b class="name">m_inject</b>, <b class="name">m_getptr</b>, <b class="name">m_adj</b>, <b class="name">m_copyback</b>, <b class="name">m_defrag</b>, <b class="name">m_freem</b>, <b class="name">m_purge</b>, <b class="name">m_reclaim</b>, <b class="name">m_copydata</b>, <b class="name">m_cat</b>, <b class="name">m_devget</b>, <b class="name">m_apply</b>, <b class="name">MCLGET</b>, <b class="name">MCLGETI</b>, <b class="name">MEXTADD</b>, <b class="name">M_ALIGN</b>, <b class="name">MH_ALIGN</b>, <b class="name">M_READONLY</b>, <b class="name">M_LEADINGSPACE</b>, <b class="name">M_TRAILINGSPACE</b>, <b class="name">mtod</b>, <b class="name">m_dup_pkt</b>, <b class="name">m_dup_pkthdr</b> &#8212; <span class="desc">kernel memory management for networking protocols</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/mbuf.h</a>&gt;</b><div class="spacer">
</div>
<i class="ftype">struct mbuf *</i><br/>
<b class="fname">m_copym2</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>, <i class="farg" style="white-space:nowrap;">int off</i>, <i class="farg" style="white-space:nowrap;">int len</i>, <i class="farg" style="white-space:nowrap;">int wait</i>);<div class="spacer">
</div>
<i class="ftype">struct mbuf *</i><br/>
<b class="fname">m_copym</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>, <i class="farg" style="white-space:nowrap;">int off</i>, <i class="farg" style="white-space:nowrap;">int len</i>, <i class="farg" style="white-space:nowrap;">int wait</i>);<div class="spacer">
</div>
<i class="ftype">struct mbuf *</i><br/>
<b class="fname">m_free</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>);<div class="spacer">
</div>
<i class="ftype">struct mbuf *</i><br/>
<b class="fname">m_get</b>(<i class="farg" style="white-space:nowrap;">int how</i>, <i class="farg" style="white-space:nowrap;">int type</i>);<div class="spacer">
</div>
<b class="fname">MGET</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>, <i class="farg" style="white-space:nowrap;">int how</i>, <i class="farg" style="white-space:nowrap;">int type</i>);<div class="spacer">
</div>
<i class="ftype">struct mbuf *</i><br/>
<b class="fname">m_getclr</b>(<i class="farg" style="white-space:nowrap;">int how</i>, <i class="farg" style="white-space:nowrap;">int type</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">m_resethdr</b>(<i class="farg" style="white-space:nowrap;">struct</i>, <i class="farg" style="white-space:nowrap;">mbuf</i>, <i class="farg" style="white-space:nowrap;">*</i>);<div class="spacer">
</div>
<i class="ftype">struct mbuf *</i><br/>
<b class="fname">m_gethdr</b>(<i class="farg" style="white-space:nowrap;">int how</i>, <i class="farg" style="white-space:nowrap;">int type</i>);<div class="spacer">
</div>
<b class="fname">MGETHDR</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>, <i class="farg" style="white-space:nowrap;">int how</i>, <i class="farg" style="white-space:nowrap;">int type</i>);<div class="spacer">
</div>
<i class="ftype">struct mbuf *</i><br/>
<b class="fname">m_prepend</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>, <i class="farg" style="white-space:nowrap;">int len</i>, <i class="farg" style="white-space:nowrap;">int how</i>);<div class="spacer">
</div>
<b class="fname">M_PREPEND</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>, <i class="farg" style="white-space:nowrap;">int plen</i>, <i class="farg" style="white-space:nowrap;">int how</i>);<div class="spacer">
</div>
<i class="ftype">struct mbuf *</i><br/>
<b class="fname">m_pulldown</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>, <i class="farg" style="white-space:nowrap;">int off</i>, <i class="farg" style="white-space:nowrap;">int len</i>, <i class="farg" style="white-space:nowrap;">int *offp</i>);<div class="spacer">
</div>
<i class="ftype">struct mbuf *</i><br/>
<b class="fname">m_pullup</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *n</i>, <i class="farg" style="white-space:nowrap;">int len</i>);<div class="spacer">
</div>
<i class="ftype">struct mbuf *</i><br/>
<b class="fname">m_split</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m0</i>, <i class="farg" style="white-space:nowrap;">int len0</i>, <i class="farg" style="white-space:nowrap;">int wait</i>);<div class="spacer">
</div>
<i class="ftype">struct mbuf *</i><br/>
<b class="fname">m_inject</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m0</i>, <i class="farg" style="white-space:nowrap;">int len0</i>, <i class="farg" style="white-space:nowrap;">int siz</i>, <i class="farg" style="white-space:nowrap;">int wait</i>);<div class="spacer">
</div>
<i class="ftype">struct mbuf *</i><br/>
<b class="fname">m_getptr</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>, <i class="farg" style="white-space:nowrap;">int loc</i>, <i class="farg" style="white-space:nowrap;">int *off</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">m_adj</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *mp</i>, <i class="farg" style="white-space:nowrap;">int req_len</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">m_copyback</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m0</i>, <i class="farg" style="white-space:nowrap;">int off</i>, <i class="farg" style="white-space:nowrap;">int len</i>, <i class="farg" style="white-space:nowrap;">const void *cp</i>, <i class="farg" style="white-space:nowrap;">int wait</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">m_defrag</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>, <i class="farg" style="white-space:nowrap;">int wait</i>);<div class="spacer">
</div>
<i class="ftype">struct mbuf *</i><br/>
<b class="fname">m_freem</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">m_purge</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">m_reclaim</b>(<i class="farg" style="white-space:nowrap;">void</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">m_copydata</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>, <i class="farg" style="white-space:nowrap;">int off</i>, <i class="farg" style="white-space:nowrap;">int len</i>, <i class="farg" style="white-space:nowrap;">caddr_t cp</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">m_cat</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>, <i class="farg" style="white-space:nowrap;">struct mbuf *n</i>);<div class="spacer">
</div>
<i class="ftype">struct mbuf *</i><br/>
<b class="fname">m_devget</b>(<i class="farg" style="white-space:nowrap;">char *buf</i>, <i class="farg" style="white-space:nowrap;">int totlen</i>, <i class="farg" style="white-space:nowrap;">int off</i>, <i class="farg" style="white-space:nowrap;">struct ifnet *ifp</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">m_apply</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>, <i class="farg" style="white-space:nowrap;">int off</i>, <i class="farg" style="white-space:nowrap;">int len</i>, <i class="farg" style="white-space:nowrap;">int (*func)(caddr_t, caddr_t, unsigned int)</i>, <i class="farg" style="white-space:nowrap;">caddr_t fstate</i>);<div class="spacer">
</div>
<b class="fname">MCLGET</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>, <i class="farg" style="white-space:nowrap;">int how</i>);<div class="spacer">
</div>
<i class="ftype">struct mbuf *</i><br/>
<b class="fname">MCLGETI</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>, <i class="farg" style="white-space:nowrap;">int how</i>, <i class="farg" style="white-space:nowrap;">struct ifnet *ifp</i>, <i class="farg" style="white-space:nowrap;">int len</i>);<div class="spacer">
</div>
<b class="fname">MEXTADD</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>, <i class="farg" style="white-space:nowrap;">caddr_t buf</i>, <i class="farg" style="white-space:nowrap;">u_int size</i>, <i class="farg" style="white-space:nowrap;">int flags</i>, <i class="farg" style="white-space:nowrap;">void (*free)(caddr_t, u_int, void *)</i>, <i class="farg" style="white-space:nowrap;">void *arg</i>);<div class="spacer">
</div>
<b class="fname">M_ALIGN</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>, <i class="farg" style="white-space:nowrap;">int len</i>);<div class="spacer">
</div>
<b class="fname">MH_ALIGN</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>, <i class="farg" style="white-space:nowrap;">int len</i>);<div class="spacer">
</div>
<b class="fname">M_READONLY</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>);<div class="spacer">
</div>
<b class="fname">M_LEADINGSPACE</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>);<div class="spacer">
</div>
<b class="fname">M_TRAILINGSPACE</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>);<div class="spacer">
</div>
<i class="ftype">struct mbuf *</i><br/>
<b class="fname">m_dup_pkt</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>, <i class="farg" style="white-space:nowrap;">u_int adj</i>, <i class="farg" style="white-space:nowrap;">int how</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">m_dup_pkthdr</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *to</i>, <i class="farg" style="white-space:nowrap;">struct mbuf *from</i>, <i class="farg" style="white-space:nowrap;">int how</i>);<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
#define MSIZE           256 
 
#define MLEN            (MSIZE - sizeof(struct m_hdr)) 
#define MHLEN           (MLEN - sizeof(struct pkthdr)) 
 
#define MAXMCLBYTES     (64 * 1024) 
#define MINCLSIZE       (MHLEN + MLEN + 1) 
#define M_MAXCOMPRESS   (MHLEN / 2) 
 
#define MCLSHIFT        11 
 
#define MCLBYTES        (1 &lt;&lt; MCLSHIFT) 
#define MCLOFSET        (MCLBYTES - 1) 
 
#define mtod(m,t)       ((t)((m)-&gt;m_data)) 
 
struct m_hdr { 
        struct  mbuf *mh_next; 
        struct  mbuf *mh_nextpkt; 
        caddr_t mh_data; 
        u_int   mh_len; 
        short   mh_type; 
        u_short mh_flags; 
}; 
 
struct pkthdr { 
	void			*ph_cookie; 
	SLIST_HEAD(, m_tag)	 ph_tags; 
	int			 len; 
	u_int16_t		 ph_tagsset; 
	u_int16_t		 ph_flowid; 
	u_int16_t		 csum_flags; 
	u_int16_t		 ether_vtag; 
	u_int			 ph_rtableid; 
	u_int			 ph_ifidx; 
	struct pkthdr_pf	 pf; 
}; 
 
struct pkthdr_pf { 
	struct pf_state_key *statekey; 
	struct inpcb *inp; 
	u_int32_t qid; 
	u_int16_t tag; 
	u_int8_t  flags; 
	u_int8_t  routed; 
	u_int8_t  prio; 
	u_int8_t  pad[3]; 
}; 
 
struct mbuf_ext { 
	caddr_t ext_buf; 
	void    (*ext_free)(caddr_t, u_int, void *); 
	void    *ext_arg; 
	u_int   ext_size; 
	struct mbuf *ext_nextref; 
	struct mbuf *ext_prevref; 
}; 
 
struct mbuf { 
        struct  m_hdr m_hdr; 
        union { 
                struct { 
                        struct  pkthdr MH_pkthdr; 
                        union { 
                                struct  mbuf_ext MH_ext; 
                                char    MH_databuf[MHLEN]; 
                        } MH_dat; 
                } MH; 
                char    M_databuf[MLEN]; 
        } M_dat; 
}; 
 
#define m_next          m_hdr.mh_next 
#define m_len           m_hdr.mh_len 
#define m_data          m_hdr.mh_data 
#define m_type          m_hdr.mh_type 
#define m_flags         m_hdr.mh_flags 
#define m_nextpkt       m_hdr.mh_nextpkt 
#define m_pkthdr        M_dat.MH.MH_pkthdr 
#define m_ext           M_dat.MH.MH_dat.MH_ext 
#define m_pktdat        M_dat.MH.MH_dat.MH_databuf 
#define m_dat           M_dat.M_databuf</pre>
</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <b class="name">mbuf</b> functions provide a way to manage the memory buffers used by the kernel's networking subsystem. Several functions and macros are used to allocate and deallocate mbufs, but also to get, inject, remove, copy, modify, prepend or append data inside these mbufs. The size of an <b class="name">mbuf</b> is defined by MSIZE.<div class="spacer">
</div>
An <b class="name">mbuf</b> structure is defined as an <i class="farg">m_hdr</i> structure followed by a union. The header contains the following elements:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">mh_next</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
A pointer to the next mbuf in the mbuf chain.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">mh_nextpkt</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
A pointer to the next mbuf chain (i.e., packet) in the queue.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">mh_data</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Indicates the address of the beginning of data in the mbuf.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">mh_len</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Indicates the amount of data in the mbuf.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">mh_type</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Indicates the type of data contained in the mbuf (see below).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">mh_flags</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Flags (see below).</dd>
</dl>
<div class="spacer">
</div>
The <i class="farg">mh_type</i> variable can take the following values:<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">MT_FREE</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
the mbuf should be on the free list.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">MT_DATA</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
the data in the mbuf was dynamically allocated.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">MT_HEADER</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
the data contains a packet header.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">MT_SONAME</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
the data is a socket name.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">MT_SOOPTS</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
the data are socket options.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">MT_FTABLE</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
the data is a fragment reassembly header.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">MT_CONTROL</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
the mbuf contains extra-data protocol message.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">MT_OOBDATA</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
the data consists of out-of-band data.</dd>
</dl>
<div class="spacer">
</div>
The <i class="farg">mh_flags</i> variable can take the following values:<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">M_EXT</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
mbuf has associated external storage.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">M_PKTHDR</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
the mbuf is the first that forms a packet.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">M_EOR</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
end of record.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">M_EXTWR</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
external storage is writable.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">M_PROTO1</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
protocol-specific.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">M_VLANTAG</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
<i class="farg">m_pkthdr.ether_vtag</i> variable is valid.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">M_LOOP</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
for mbuf statistics.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">M_FILDROP</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
dropped by <a class="link-man" href="../html4/bpf.html">bpf(4)</a> filter.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">M_BCAST</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
packet send/received as link-level broadcast.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">M_MCAST</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
packet send/received as link-level multicast.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">M_CONF</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
packet was encrypted (ESP-transport).</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">M_AUTH</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
packet was authenticated (AH or ESP).</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">M_TUNNEL</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
header was IP-in-IP encapsulated by tunnel mode IPsec.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">M_ZEROIZE</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Zero the data part of the mbufs in the mbuf chain pointed to by <b class="name">m_free</b>.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">M_COMP</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
header was decompressed.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">M_LINK0</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
link layer specific flag.</dd>
</dl>
<div class="spacer">
</div>
An external cluster is used when the data to hold in the mbuf is large. The size of an external cluster is between MCLBYTES and MAXMCLBYTES. A cluster should be used when the size of the data reach MINCLSIZE (the minimum size to be held by an external cluster).<div class="spacer">
</div>
The combination of the M_EXT and M_PKTHDR flags give four types of mbuf. When none of these constants are in use, the mbuf is a &quot;normal&quot; one, where the data part of the mbuf has the following elements:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">m_dat</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
buffer holding the data (size MLEN).</dd>
</dl>
<div class="spacer">
</div>
When only M_PKTHDR is set, the data contained in the mbuf is a packet header. The data itself is contained in the mbuf (just like the previous case), but part of the mbuf is used to store a packet header. The data part has then the following elements:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">m_pkthdr</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
packet header, containing the length of the data, a pointer to the interface on which the data was received, checksum information and list of <a class="link-man" href="../html9/mbuf_tags.html">mbuf_tags(9)</a>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">m_pktdat</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
buffer holding the data (size MHLEN).</dd>
</dl>
<div class="spacer">
</div>
The <i class="farg">m_pkthdr.csum_flags</i> variable can take the following values:<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">M_IPV4_CSUM_OUT</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
IPv4 checksum needed.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">M_TCP_CSUM_OUT</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
TCP checksum needed.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">M_UDP_CSUM_OUT</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
UDP checksum needed.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">M_ICMP_CSUM_OUT</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
ICMP/ICMPv6 checksum needed.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">M_IPV4_CSUM_IN_OK</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
IPv4 checksum verified.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">M_IPV4_CSUM_IN_BAD</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
IPv4 checksum bad.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">M_TCP_CSUM_IN_OK</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
TCP checksum verified.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">M_TCP_CSUM_IN_BAD</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
TCP checksum bad.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">M_UDP_CSUM_IN_OK</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
UDP checksum verified.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">M_UDP_CSUM_IN_BAD</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
UDP checksum bad.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">M_ICMP_CSUM_IN_OK</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
ICMP/ICMPv6 checksum verified.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">M_ICMP_CSUM_IN_BAD</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
ICMP/ICMPv6 checksum bad.</dd>
</dl>
<div class="spacer">
</div>
The <i class="farg">m_pkthdr.flowid</i> variable can contain a low resolution (15-bit) classification of a flow or connection that the current mbuf is part of. If the flowid is valid, it may be used as an alternative to hashing the packets content to pick between different paths for the traffic. The following masks can be ORed with the flowid:<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">M_FLOWID_VALID</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
The flow ID has been set.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">M_FLOWID_MASK</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
The flow ID.</dd>
</dl>
<div class="spacer">
</div>
When only M_EXT flag is set, an external storage buffer is being used to hold the data, which is no longer stored in the mbuf. The data part of the mbuf has now the following elements:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">m_pkthdr</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
a packet header, just like the previous case, but it is empty. No information is stored here.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">m_ext</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
a structure containing information about the external storage buffer. The information consists of the address of the external buffer, a pointer to the function used to free the buffer, a pointer to the arguments of the function, the size of the buffer, the type of the buffer, and pointers to the previous and next mbufs using this cluster.</dd>
</dl>
<div class="spacer">
</div>
When both the M_EXT and M_PKTHDR flags are set, an external storage buffer is being used to store the data and this data contains a packet header. The structure used is the same as the previous one except that the <i class="farg">m_pkthdr</i> element is not empty, it contains the same information as when M_PKTHDR is used alone.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_copym</b>(<i class="farg">struct mbuf *m</i>, <i class="farg">int off</i>, <i class="farg">int len</i>, <i class="farg">int wait</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Copy an mbuf chain starting at <i class="farg">off</i> bytes from the beginning and continuing for <i class="farg">len</i> bytes. If <i class="farg">off</i> is zero and <i class="farg">m</i> has the M_PKTHDR flag set, the header is copied. If <i class="farg">len</i> is M_COPYALL the whole mbuf is copied. The <i class="farg">wait</i> parameter can be M_WAIT or M_DONTWAIT. It does not copy clusters, it just increases their reference count.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_copym2</b>(<i class="farg">struct mbuf *m</i>, <i class="farg">int off</i>, <i class="farg">int len</i>, <i class="farg">int wait</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The same as <b class="fname">m_copym</b>() except that it copies cluster mbufs, whereas <b class="fname">m_copym</b>() just increases the reference count of the clusters.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_free</b>(<i class="farg">struct mbuf *m</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Free the mbuf pointed to by <i class="farg">m</i>. A pointer to the successor of the mbuf, if it exists, is returned by the function. If <i class="farg">m</i> is a <span class="define">NULL</span> pointer, no action occurs and <span class="define">NULL</span> is returned.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_get</b>(<i class="farg">int how</i>, <i class="farg">int type</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Return a pointer to an mbuf of the type specified. If the <i class="farg">how</i> argument is <i class="farg">M_WAITOK</i>, the function may call <a class="link-man" href="../html9/tsleep.html">tsleep(9)</a> to await resources. If <i class="farg">how</i> is <i class="farg">M_DONTWAIT</i> and resources are not available, <b class="fname">m_get</b>() returns NULL.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">MGET</b>(<i class="farg">struct mbuf *m</i>, <i class="farg">int how</i>, <i class="farg">int type</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Return a pointer to an mbuf in <i class="farg">m</i> of the type specified. See <b class="fname">m_get</b>() for a description of <i class="farg">how</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_getclr</b>(<i class="farg">int how</i>, <i class="farg">int type</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Return a pointer to an mbuf of the type specified, and clear the data area of the mbuf. See <b class="fname">m_get</b>() for a description of <i class="farg">how</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_resethdr</b>(<i class="farg">struct mbuf *</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Deletes all <a class="link-man" href="../html4/pf.html">pf(4)</a> data and all tags attached to a <i class="farg">mbuf</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_gethdr</b>(<i class="farg">int how</i>, <i class="farg">int type</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Return a pointer to an mbuf of the type specified after initializing it to contain a packet header. See <b class="fname">m_get</b>() for a description of <i class="farg">how</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">MGETHDR</b>(<i class="farg">struct mbuf *m</i>, <i class="farg">int how</i>, <i class="farg">int type</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Return a pointer to an mbuf of the type specified after initializing it to contain a packet header. See <b class="fname">m_get</b>() for a description of <i class="farg">how</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_prepend</b>(<i class="farg">struct mbuf *m</i>, <i class="farg">int len</i>, <i class="farg">int how</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Allocate a new mbuf and prepend it to the mbuf chain pointed to by <i class="farg">m</i>. If <i class="farg">m</i> points to an mbuf with a packet header, it is moved to the new mbuf that has been prepended. The return value is a pointer on the new mbuf chain. If this function fails to allocate a new mbuf, <i class="farg">m</i> is freed. See <b class="fname">m_get</b>() for a description of <i class="farg">how</i>.<div class="spacer">
</div>
<b class="fname">m_prepend</b>() should never be called directly. Use <b class="fname">M_PREPEND</b>() instead.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">M_PREPEND</b>(<i class="farg">struct mbuf *m</i>, <i class="farg">int plen</i>, <i class="farg">int how</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Prepend space of size <i class="farg">plen</i> to the mbuf pointed to by <i class="farg">m</i>. If a new mbuf must be allocated, <i class="farg">how</i> specifies whether to wait or not. If this function fails to allocate a new mbuf, <i class="farg">m</i> is freed.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_pulldown</b>(<i class="farg">struct mbuf *m</i>, <i class="farg">int off</i>, <i class="farg">int len</i>, <i class="farg">int *offp</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Ensure that the data in the mbuf chain starting at <i class="farg">off</i> and ending at <i class="farg">off+len</i> will be put in a continuous memory region. If memory must be allocated, then it will fail if the <i class="farg">len</i> argument is greater than MAXMCLBYTES. The pointer returned points to an mbuf in the chain and the new offset for data in this mbuf is <i class="farg">*offp</i>. If this function fails, <i class="farg">m</i> is freed.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_pullup</b>(<i class="farg">struct mbuf *n</i>, <i class="farg">int len</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Ensure that the data in the mbuf chain starting at the beginning of the chain and ending at <i class="farg">len</i> will be put in continuous memory region. If memory must be allocated, then it will fail if the <i class="farg">len</i> argument is greater than MAXMCLBYTES. If this function fails, <i class="farg">n</i> is freed.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_split</b>(<i class="farg">struct mbuf *m0</i>, <i class="farg">int len0</i>, <i class="farg">int wait</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Split an mbuf chain in two pieces, returning a pointer to the tail (which is made of the previous mbuf chain except the first <i class="farg">len0</i> bytes).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_inject</b>(<i class="farg">struct mbuf *m0</i>, <i class="farg">int len0</i>, <i class="farg">int siz</i>, <i class="farg">int wait</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Inject a new mbuf chain of length <i class="farg">siz</i> into the mbuf chain pointed to by <i class="farg">m0</i> at position <i class="farg">len0</i>. If there is enough space for an object of size <i class="farg">siz</i> in the appropriate location, no memory will be allocated. On failure, the function returns NULL (the mbuf is left untouched) and on success, a pointer to the first injected mbuf is returned.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_getptr</b>(<i class="farg">struct mbuf *m</i>, <i class="farg">int loc</i>, <i class="farg">int *off</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Returns a pointer to the mbuf containing the data located at <i class="farg">loc</i> bytes of the beginning. The offset in the new mbuf is pointed to by <i class="farg">off</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_adj</b>(<i class="farg">struct mbuf *mp</i>, <i class="farg">int req_len</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Trims <i class="farg">req_len</i> bytes of data from the mbuf chain pointed to by <i class="farg">mp</i>. If <i class="farg">req_len</i> is positive, the data will be trimmed from the head of the mbuf chain and if it is negative, it will be trimmed from the tail of the mbuf chain.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_copyback</b>(<i class="farg">struct mbuf *m0</i>, <i class="farg">int off</i>, <i class="farg">int len</i>, <i class="farg">caddr_t cp</i>, <i class="farg">int wait</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Copy data from a buffer pointed to by <i class="farg">cp</i> back into the mbuf chain pointed to by <i class="farg">m0</i> starting at <i class="farg">off</i> bytes from the beginning, extending the mbuf chain if necessary, sleeping for mbufs if <i class="farg">wait</i> is <i class="farg">M_WAIT</i>. If <i class="farg">M_NOWAIT</i> is set and no mbufs are available, <b class="fname">m_copyback</b>() returns <span class="errno">ENOBUFS</span>. The mbuf chain must be initialized properly, including setting <i class="farg">m_len</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_defrag</b>(<i class="farg">struct mbuf *m</i>, <i class="farg">int wait</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Defragment the data mbufs referenced by <i class="farg">m</i> by replacing the chain with a copy of their contents made into a single mbuf or cluster. <i class="farg">wait</i> specifies whether it can wait or not for the replacement storage. <b class="fname">m_defrag</b>() returns 0 on success or <span class="errno">ENOBUFS</span> on failure. The mbuf pointer <i class="farg">m</i> remains in existence and unchanged on failure.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_freem</b>(<i class="farg">struct mbuf *m</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Free the mbuf chain pointed to by <i class="farg">m</i>. A pointer to the next mbuf in the list linked by m_nextpkt, if it exists, is returned by the function. If <i class="farg">m</i> is a <span class="define">NULL</span> pointer, no action occurs and <span class="define">NULL</span> is returned.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_purge</b>(<i class="farg">struct mbuf *m</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Free the list of mbufs linked by m_nextpkt that is pointed to by <i class="farg">m</i>. Each mbuf is freed by a call to <b class="fname">m_freem</b>(). If <i class="farg">m</i> is a <span class="define">NULL</span> pointer, no action occurs.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_reclaim</b>(<i class="farg">void</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Ask protocols to free unused memory space.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_copydata</b>(<i class="farg">struct mbuf *m</i>, <i class="farg">int off</i>, <i class="farg">int len</i>, <i class="farg">caddr_t cp</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Copy data from the mbuf chain pointed to by <i class="farg">m</i> starting at <i class="farg">off</i> bytes from the beginning and continuing for <i class="farg">len</i> bytes into the buffer pointed to by <i class="farg">cp</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_cat</b>(<i class="farg">struct mbuf *m</i>, <i class="farg">struct mbuf *n</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Concatenate the mbuf chain pointed to by <i class="farg">n</i> to the mbuf chain pointed to by <i class="farg">m</i>. The mbuf chains must be of the same type.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_devget</b>(<i class="farg">char *buf</i>, <i class="farg">int totlen</i>, <i class="farg">int off</i>, <i class="farg">struct ifnet *ifp</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Copy <i class="farg">totlen</i> bytes of data from device local memory pointed to by <i class="farg">buf</i>. The data is copied into an mbuf chain at offset <i class="farg">off</i> and a pointer to the head of the chain is returned. Returns NULL on failure.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_apply</b>(<i class="farg">struct mbuf *m</i>, <i class="farg">int off</i>, <i class="farg">int len</i>, <i class="farg">int (*func)(caddr_t, caddr_t, unsigned int)</i>, <i class="farg">caddr_t fstate</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Apply the function <i class="farg">func</i> to the data in the mbuf chain pointed to by <i class="farg">m</i> starting at <i class="farg">off</i> bytes from the beginning and continuing for <i class="farg">len</i> bytes.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">mtod</b>(<i class="farg">struct mbuf *m</i>, <i class="farg">datatype</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Return a pointer to the data contained in the specified mbuf <i class="farg">m</i> cast to <i class="farg">datatype</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">MCLGET</b>(<i class="farg">struct mbuf *m</i>, <i class="farg">int how</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Allocate and add an mbuf cluster to the mbuf pointed to by <i class="farg">m</i>. On success, the flag M_EXT is set in the mbuf. See <b class="fname">m_get</b>() for a description of <i class="farg">how</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">MCLGETI</b>(<i class="farg">struct mbuf *m</i>, <i class="farg">int how</i>, <i class="farg">struct ifnet *ifp</i>, <i class="farg">int len</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
If <i class="farg">m</i> is NULL, allocate it. Then allocate and add an mbuf cluster of length <i class="farg">len</i> to the mbuf pointed to by <i class="farg">m</i>. Returns either the mbuf <i class="farg">m</i> that was passed in, or the newly allocated one which was allocated; in either case the flag M_EXT is set in the mbuf. See <b class="fname">m_get</b>() for a description of <i class="farg">how</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">MEXTADD</b>(<i class="farg">struct mbuf *m</i>, <i class="farg">caddr_t buf</i>, <i class="farg">u_int size</i>, <i class="farg">int flags</i>, <i class="farg">void (*free)(caddr_t, u_int, void *)</i>, <i class="farg">void *arg</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Add pre-allocated storage to the mbuf pointed to by <i class="farg">m</i>. On success, the flag M_EXT is set in the mbuf, and M_EXTWR is specified in <i class="farg">flags</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">M_ALIGN</b>(<i class="farg">struct mbuf *m</i>, <i class="farg">int len</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Set the <i class="farg">m_data</i> pointer of the newly allocated mbuf with <b class="fname">m_get</b>() or <b class="fname">MGET</b>() pointed to by <i class="farg">m</i> to an object of the specified size <i class="farg">len</i> at the end of the mbuf, longword aligned.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">MH_ALIGN</b>(<i class="farg">m</i>, <i class="farg">len</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Same as <b class="fname">M_ALIGN</b>() except it is for an mbuf allocated with <b class="fname">m_gethdr</b>() or <b class="fname">MGETHDR</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">M_READONLY</b>(<i class="farg">struct mbuf *m</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Check if the data of the mbuf pointed to by <i class="farg">m</i> is read-only. This is true for non-cluster external storage and for clusters that are being referenced by more than one mbuf.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">M_LEADINGSPACE</b>(<i class="farg">struct mbuf *m</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Compute the amount of space available before the current start of data in the mbuf pointed to by <i class="farg">m</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">M_TRAILINGSPACE</b>(<i class="farg">struct mbuf *m</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Compute the amount of space available after the end of data in the mbuf pointed to by <i class="farg">m</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_dup_pkt</b>(<i class="farg">struct mbuf *m</i>, <i class="farg">u_int adj</i>, <i class="farg">int how</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Allocate a new mbuf and storage and copy the packet data and header, including mbuf tags, from <i class="farg">m</i>. The data in the new mbuf will be offset from the start of the storage by <i class="farg">adj</i> bytes. See <b class="fname">m_get</b>() for a description of <i class="farg">how</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_dup_pkthdr</b>(<i class="farg">struct mbuf *to</i>, <i class="farg">struct mbuf *from</i>, <i class="farg">int how</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Copy mbuf packet header, including mbuf tags, from <i class="farg">from</i> to <i class="farg">to</i>. See <b class="fname">m_get</b>() for a description of <i class="farg">how</i>.</dd>
</dl>
</div>
<div class="section">
<h1 id="x434f4445205245464552454e434553">CODE REFERENCES</h1> The mbuf management functions are implemented in the files <i class="file">sys/kern/uipc_mbuf.c</i> and <i class="file">sys/kern/uipc_mbuf2.c</i>. The function prototypes and the macros are located in <i class="file">sys/sys/mbuf.h</i>.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html1/netstat.html">netstat(1)</a>, <a class="link-man" href="../html9/mbuf_tags.html">mbuf_tags(9)</a>, <a class="link-man" href="../html9/mutex.html">mutex(9)</a>, <a class="link-man" href="../html9/spl.html">spl(9)</a><div class="spacer">
</div>
<span class="ref"><span class="ref-auth">Jun-Ichiro Hagino</span>, <span class="ref-title">Mbuf issues in 4.4BSD IPv6/IPsec support (experiences from KAME IPv6/IPsec implementation)</span>, <i class="ref-book">Proceedings of the Freenix Track: 2000 USENIX Annual Technical Conference</i>, <span class="ref-date">June 2000</span>.</span></div>
</div>
</body>
</html>

