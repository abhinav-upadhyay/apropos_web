<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
AUDIO(9)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">audio</b> &#8212; <span class="desc">interface between low and high level audio drivers</span></div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The audio device driver is divided into a high level, hardware independent layer, and a low level, hardware dependent layer. The interface between these is the <b class="var">audio_hw_if</b> structure.<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
struct audio_hw_if { 
	int	(*open)(void *, int); 
	void	(*close)(void *); 
	int	(*drain)(void *); 
 
	int	(*query_encoding)(void *, struct audio_encoding *); 
	int	(*set_params)(void *, int, int, 
		    struct audio_params *, struct audio_params *); 
	int	(*round_blocksize)(void *, int); 
 
	int	(*commit_settings)(void *); 
 
	int	(*init_output)(void *, void *, int); 
	int	(*init_input)(void *, void *, int); 
	int	(*start_output)(void *, void *, int, 
		    void (*)(void *), void *); 
	int	(*start_input)(void *, void *, int, 
		    void (*)(void *), void *); 
	int	(*halt_output)(void *); 
	int	(*halt_input)(void *); 
 
	int	(*speaker_ctl)(void *, int); 
#define SPKR_ON  1 
#define SPKR_OFF 0 
 
	int	(*getdev)(void *, struct audio_device *); 
	int	(*setfd)(void *, int); 
 
	int	(*set_port)(void *, struct mixer_ctrl *); 
	int	(*get_port)(void *, struct mixer_ctrl *); 
 
	int	(*query_devinfo)(void *, struct mixer_devinfo *); 
 
	void	*(*allocm)(void *, int, size_t, int, int); 
	void	(*freem)(void *, void *, int); 
	size_t	(*round_buffersize)(void *, int, size_t); 
	paddr_t	(*mappage)(void *, void *, off_t, int); 
 
	int 	(*get_props)(void *); 
 
	int	(*trigger_output)(void *, void *, void *, int, 
		    void (*)(void *), void *, struct audio_params *); 
	int	(*trigger_input)(void *, void *, void *, int, 
		    void (*)(void *), void *, struct audio_params *); 
	void	(*get_default_params)(void *, int, struct audio_params *); 
}; 
 
struct audio_params { 
	u_long	sample_rate;		/* sample rate */ 
	u_int	encoding;		/* mu-law, linear, etc */ 
	u_int	precision;		/* bits/sample */ 
	u_int	bps;			/* bytes/sample */ 
	u_int	msb;			/* data alignment */ 
	u_int	channels;		/* mono(1), stereo(2) */ 
	/* Software en/decode functions, set if SW coding required by HW */ 
	void	(*sw_code)(void *, u_char *, int); 
	int	factor;			/* coding space change */ 
};</pre>
<div class="spacer">
</div>
The high level audio driver attaches to the low level driver when the latter calls <b class="fname">audio_attach_mi</b>(). This call is:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
struct device * 
audio_attach_mi(struct audio_hw_if *ahwp, void *hdl, 
		struct device *dev);</pre>
<div class="spacer">
</div>
The <b class="var">audio_hw_if</b> struct is as shown above. The <i class="farg">hdl</i> argument is a handle to some low level data structure. It is sent as the first argument to all the functions in <i class="farg">ahwp</i> when the high level driver calls them. <i class="farg">dev</i> is the device struct for the hardware device.<div class="spacer">
</div>
The upper layer of the audio driver allocates one buffer for playing and one for recording. It handles the buffering of data from the user processes in these. The data is presented to the lower level in smaller chunks, called blocks. During playback, if there is no data available from the user process when the hardware requests another block, a block of silence will be used instead. Similarly, if the user process does not read data quickly enough during recording, data will be thrown away.<div class="spacer">
</div>
The fields of <b class="var">audio_hw_if</b> are described in some more detail below. Some fields are optional and can be set to <span class="define">NULL</span> if not needed.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="ftype">int</i> <b class="fname">(*open)</b>(<i class="farg">void *hdl</i>, <i class="farg">int flags</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This function is called when the audio device is opened, with <i class="farg">flags</i> the kernel representation of flags passed to the <a class="link-man" href="../html2/open.html">open(2)</a> system call (see <span class="define">OFLAGS</span> and <span class="define">FFLAGS</span> in <b class="includes">&lt;<a class="link-includes">sys/fcntl.h</a>&gt;</b>). It initializes the hardware for I/O. Every successful call to <b class="fname">open</b>() is matched by a call to <b class="fname">close</b>(). This function returns 0 on success, otherwise an error code.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="ftype">void</i> <b class="fname">(*close)</b>(<i class="farg">void *hdl</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This function is called when the audio device is closed.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="ftype">int</i> <b class="fname">(*drain)</b>(<i class="farg">void *hdl</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This function is optional. If supplied, it is called before the device is closed or when the <span class="define">AUDIO_DRAIN</span> <a class="link-man" href="../html2/ioctl.html">ioctl(2)</a> is called. It makes sure that no samples remain to be played that could be lost when <b class="fname">close</b>() is called. This function returns 0 on success, otherwise an error code.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="ftype">int</i> <b class="fname">(*query_encoding)</b>(<i class="farg">void *hdl</i>, <i class="farg">struct audio_encoding *ae</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This function is used when the <span class="define">AUDIO_GETENC</span> <a class="link-man" href="../html2/ioctl.html">ioctl(2)</a> is called. It fills <i class="farg">ae</i> and returns 0 or, if there is no encoding with the given number, returns <span class="errno">EINVAL</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="ftype">int</i> <b class="fname">(*set_params)</b>(<i class="farg">void *hdl</i>, <i class="farg">int setmode</i>, <i class="farg">int usemode</i>, <i class="farg">struct audio_params *play</i>, <i class="farg">struct audio_params *rec</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This function is called to set the audio encoding mode. <i class="farg">setmode</i> is a combination of the <span class="define">AUMODE_RECORD</span> and <span class="define">AUMODE_PLAY</span> flags to indicate which mode(s) are to be set. <i class="farg">usemode</i> is also a combination of these flags, but indicates the current mode of the device (i.e., the value of <b class="var">mode</b> in the <b class="var">audio_info</b> struct). The <i class="farg">play</i> and <i class="farg">rec</i> structures contain the encoding parameters that will be set. If the hardware requires software assistance with some encoding (e.g., it might be lacking mu-law support), it will fill the <b class="var">sw_code</b> and <b class="var">factor</b> fields of these structures. See <i class="file">/usr/src/sys/dev/auconv.h</i> for available software support. The values of the structures may also be modified if the hardware cannot be set to exactly the requested mode (e.g., if the requested sampling rate is not supported, but one close enough is). If the device does not have the <span class="define">AUDIO_PROP_INDEPENDENT</span> property, the same value is passed in both <i class="farg">play</i> and <i class="farg">rec</i> and the encoding parameters from <i class="farg">play</i> are copied into <i class="farg">rec</i> after the call to <b class="fname">set_params</b>().<div class="spacer">
</div>
The machine independent audio driver does some preliminary parameter checking; it verifies that the precision is compatible with the encoding, and it translates <span class="define">AUDIO_ENCODING_[US]LINEAR</span> to <span class="define">AUDIO_ENCODING_[US]LINEAR_{LE,BE}</span>.<div class="spacer">
</div>
This function returns 0 on success, otherwise an error code.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="ftype">int</i> <b class="fname">(*round_blocksize)</b>(<i class="farg">void *hdl</i>, <i class="farg">int bs</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This function is optional. If supplied, it is called with the block size, <i class="farg">bs</i>, which has been computed by the upper layer. It returns a block size, possibly changed according to the needs of the hardware driver.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="ftype">int</i> <b class="fname">(*commit_settings)</b>(<i class="farg">void *hdl</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This function is optional. If supplied, it is called after all calls to <b class="fname">set_params</b>() and <b class="fname">set_port</b>() are done. A hardware driver that needs to get the hardware in and out of command mode for each change can save all the changes during previous calls and do them all here. This function returns 0 on success, otherwise an error code.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="ftype">int</i> <b class="fname">(*init_output)</b>(<i class="farg">void *hdl</i>, <i class="farg">void *buffer</i>, <i class="farg">int size</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This function is optional. If supplied, it is called before any output starts, but only after the total <i class="farg">size</i> of the output <i class="farg">buffer</i> has been determined. It can be used to initialize looping DMA for hardware that needs it. This function returns 0 on success, otherwise an error code.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="ftype">int</i> <b class="fname">(*init_input)</b>(<i class="farg">void *hdl</i>, <i class="farg">void *buffer</i>, <i class="farg">int size</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This function is optional. If supplied, it is called before any input starts, but only after the total <i class="farg">size</i> of the input <i class="farg">buffer</i> has been determined. It can be used to initialize looping DMA for hardware that needs it. This function returns 0 on success, otherwise an error code.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="ftype">int</i> <b class="fname">(*start_output)</b>(<i class="farg">void *hdl</i>, <i class="farg">void *block</i>, <i class="farg">int bsize</i>, <i class="farg">void (*intr)(void *)</i>, <i class="farg">void *intrarg</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This function is called to start the transfer of <i class="farg">bsize</i> bytes from <i class="farg">block</i> to the audio hardware. The call returns when the data transfer has been initiated (normally with DMA). When the hardware is ready to accept more samples the function <i class="farg">intr</i> will be called with the argument <i class="farg">intrarg</i>. Calling <i class="farg">intr</i> will normally initiate another call to <b class="fname">start_output</b>(). This function returns 0 on success, otherwise an error code.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="ftype">int</i> <b class="fname">(*start_input)</b>(<i class="farg">void *hdl</i>, <i class="farg">void *block</i>, <i class="farg">int bsize</i>, <i class="farg">void (*intr)(void *)</i>, <i class="farg">void *intrarg</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This function is called to start the transfer of <i class="farg">bsize</i> bytes to <i class="farg">block</i> from the audio hardware. The call returns when the data transfer has been initiated (normally with DMA). When the hardware is ready to deliver more samples the function <i class="farg">intr</i> will be called with the argument <i class="farg">intrarg</i>. Calling <i class="farg">intr</i> will normally initiate another call to <b class="fname">start_input</b>(). This function returns 0 on success, otherwise an error code.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="ftype">int</i> <b class="fname">(*halt_output)</b>(<i class="farg">void *hdl</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This function is called to abort the output transfer (started by <b class="fname">start_output</b>()) in progress. This function returns 0 on success, otherwise an error code.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="ftype">int</i> <b class="fname">(*halt_input)</b>(<i class="farg">void *hdl</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This function is called to abort the input transfer (started by <b class="fname">start_input</b>()) in progress. This function returns 0 on success, otherwise an error code.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="ftype">int</i> <b class="fname">(*speaker_ctl)</b>(<i class="farg">void *hdl</i>, <i class="farg">int on</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This function is optional. If supplied, it is called when a half duplex device changes between playing and recording. It can, e.g., be used to turn the speaker on and off. This function returns 0 on success, otherwise an error code.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="ftype">int</i> <b class="fname">(*getdev)</b>(<i class="farg">void *hdl</i>, <i class="farg">struct audio_device *ret</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This function fills <i class="farg">ret</i> with relevant information about the driver and returns 0 on success, or it returns an error code on failure.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="ftype">int</i> <b class="fname">(*setfd)</b>(<i class="farg">void *hdl</i>, <i class="farg">int fd</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This function is optional. If supplied, it is called when the <span class="define">AUDIO_SETFD</span> <a class="link-man" href="../html2/ioctl.html">ioctl(2)</a> is used, but only if the device has <span class="define">AUDIO_PROP_FULLDUPLEX</span> set. This function returns 0 on success, otherwise an error code.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="ftype">int</i> <b class="fname">(*set_port)</b>(<i class="farg">void *hdl</i>, <i class="farg">struct mixer_ctrl *mc</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This function is called when the <span class="define">AUDIO_MIXER_WRITE</span> <a class="link-man" href="../html2/ioctl.html">ioctl(2)</a> is used. It takes data from <i class="farg">mc</i> and sets the corresponding mixer values. This function returns 0 on success, otherwise an error code.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="ftype">int</i> <b class="fname">(*get_port)</b>(<i class="farg">void *hdl</i>, <i class="farg">struct mixer_ctrl *mc</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This function is called when the <span class="define">AUDIO_MIXER_READ</span> <a class="link-man" href="../html2/ioctl.html">ioctl(2)</a> is used. It fills <i class="farg">mc</i> and returns 0 on success, or it returns an error code on failure.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="ftype">int</i> <b class="fname">(*query_devinfo)</b>(<i class="farg">void *hdl</i>, <i class="farg">struct mixer_devinfo *di</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This function is called when the <span class="define">AUDIO_MIXER_DEVINFO</span> <a class="link-man" href="../html2/ioctl.html">ioctl(2)</a> is used. It fills <i class="farg">di</i> and returns 0 on success, or it returns an error code on failure.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="ftype">void</i> <b class="fname">*(*allocm)</b>(<i class="farg">void *hdl</i>, <i class="farg">int direction</i>, <i class="farg">size_t size</i>, <i class="farg">int type</i>, <i class="farg">int flags</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This function is optional. If supplied, it is called to allocate the device buffers. If not supplied, <a class="link-man" href="../html9/malloc.html">malloc(9)</a> is used instead (with the same arguments but the first two). The reason for using a device dependent routine instead of <a class="link-man" href="../html9/malloc.html">malloc(9)</a> is that some buses need special allocation to do DMA. <i class="farg">direction</i> is <span class="define">AUMODE_PLAY</span> or <span class="define">AUMODE_RECORD</span>. This function returns the address of the buffer on success, or 0 on failure.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="ftype">void</i> <b class="fname">(*freem)</b>(<i class="farg">void *hdl</i>, <i class="farg">void *addr</i>, <i class="farg">int type</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This function is optional. If supplied, it is called to free memory allocated by <b class="fname">allocm</b>(). If not supplied, <a class="link-man" href="../html9/free.html">free(9)</a> is used instead.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="ftype">size_t</i> <b class="fname">(*round_buffersize)</b>(<i class="farg">void *hdl</i>, <i class="farg">int direction</i>, <i class="farg">size_t bufsize</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This function is optional. If supplied, it is called at startup to determine the audio buffer size. The upper layer supplies the suggested size in <i class="farg">bufsize</i>, which the hardware driver can then change if needed. E.g., DMA on the ISA bus cannot exceed 65536 bytes. Note that the buffer size is always a multiple of the block size, so <b class="fname">round_blocksize</b>() and <b class="fname">round_buffersize</b>() must be consistent.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="ftype">paddr_t</i> <b class="fname">(*mappage)</b>(<i class="farg">void *hdl</i>, <i class="farg">void *addr</i>, <i class="farg">off_t offs</i>, <i class="farg">int prot</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This function is optional. If supplied, it is called for <a class="link-man" href="../html2/mmap.html">mmap(2)</a>. It returns the map value for the page at offset <i class="farg">offs</i> from address <i class="farg">addr</i> mapped with protection <i class="farg">prot</i>. This function returns -1 on failure, or a machine dependent opaque value on success.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="ftype">int</i> <b class="fname">(*get_props)</b>(<i class="farg">void *hdl</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This function returns the device properties, as per <a class="link-man" href="../html4/audio.html">audio(4)</a> <span class="define">AUDIO_GETPROPS</span> <a class="link-man" href="../html2/ioctl.html">ioctl(2)</a>, i.e., a combination of <span class="define">AUDIO_PROP_xxx</span> properties.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="ftype">int</i> <b class="fname">(*trigger_output)</b>(<i class="farg">void *hdl</i>, <i class="farg">void *start</i>, <i class="farg">void *end</i>, <i class="farg">int blksize</i>, <i class="farg">void (*intr)(void *)</i>, <i class="farg">void *intrarg</i>, <i class="farg">struct audio_params *param</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This function is optional. If supplied, it is called to start the transfer of data from the circular buffer delimited by <i class="farg">start</i> and <i class="farg">end</i> to the audio hardware, parameterized as in <i class="farg">param</i>. The call returns when the data transfer has been initiated (normally with DMA). When the hardware is finished transferring each <i class="farg">blksize</i> sized block, the function <i class="farg">intr</i> will be called with the argument <i class="farg">intrarg</i> (typically from the audio hardware interrupt service routine). Once started, the transfer may be stopped using <b class="fname">halt_output</b>(). This function returns 0 on success, otherwise an error code.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="ftype">int</i> <b class="fname">(*trigger_input)</b>(<i class="farg">void *hdl</i>, <i class="farg">void *start</i>, <i class="farg">void *end</i>, <i class="farg">int blksize</i>, <i class="farg">void (*intr)(void *)</i>, <i class="farg">void *intrarg</i>, <i class="farg">struct audio_params *param</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This function is optional. If supplied, it is called to start the transfer of data from the audio hardware, parameterized as in <i class="farg">param</i>, to the circular buffer delimited by <i class="farg">start</i> and <i class="farg">end</i>. The call returns when the data transfer has been initiated (normally with DMA). When the hardware is finished transferring each <i class="farg">blksize</i> sized block, the function <i class="farg">intr</i> will be called with the argument <i class="farg">intrarg</i> (typically from the audio hardware interrupt service routine). Once started, the transfer may be stopped using <b class="fname">halt_input</b>(). This function returns 0 on success, otherwise an error code.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="ftype">void</i> <b class="fname">(*get_default_params)</b>(<i class="farg">void *hdl</i>, <i class="farg">int direction</i>, <i class="farg">struct audio_params *param</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This function is optional. If supplied, it is called to retrieve the default configuration for the given <i class="farg">direction</i>, parameterized in <i class="farg">param</i>. <i class="farg">direction</i> is <span class="define">AUMODE_PLAY</span> or <span class="define">AUMODE_RECORD</span>. The default configuration should not include emulated formats, and should reflect the optimal operating configuration for the underlying hardware.</dd>
</dl>
<div class="spacer">
</div>
The <b class="fname">query_devinfo</b>() method should define certain mixer controls for <span class="define">AUDIO_SETINFO</span> to be able to change the port and gain.<div class="spacer">
</div>
If the audio hardware is capable of input from more than one source it should define <span class="define">AudioNsource</span> in class <span class="define">AudioCrecord</span>. This mixer control should be of type <span class="define">AUDIO_MIXER_ENUM</span> or <span class="define">AUDIO_MIXER_SET</span> and enumerate the possible input sources. For each of the named sources there should be a control in the <span class="define">AudioCinputs</span> class of type <span class="define">AUDIO_MIXER_VALUE</span> if recording level of the source can be set. If the overall recording level can be changed (i.e., regardless of the input source) then this control should be named <span class="define">AudioNrecord</span> and be of class <span class="define">AudioCinputs</span>.<div class="spacer">
</div>
If the audio hardware is capable of output to more than one destination it should define <span class="define">AudioNoutput</span> in class <span class="define">AudioCmonitor</span>. This mixer control should be of type <span class="define">AUDIO_MIXER_ENUM</span> or <span class="define">AUDIO_MIXER_SET</span> and enumerate the possible destinations. For each of the named destinations there should be a control in the <span class="define">AudioCoutputs</span> class of type <span class="define">AUDIO_MIXER_VALUE</span> if output level of the destination can be set. If the overall output level can be changed (i.e., regardless of the destination) then this control should be named <span class="define">AudioNmaster</span> and be of class <span class="define">AudioCoutputs</span>.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html2/ioctl.html">ioctl(2)</a>, <a class="link-man" href="../html2/mmap.html">mmap(2)</a>, <a class="link-man" href="../html2/open.html">open(2)</a>, <a class="link-man" href="../html3/sio_open.html">sio_open(3)</a>, <a class="link-man" href="../html4/audio.html">audio(4)</a>, <a class="link-man" href="../html9/free.html">free(9)</a>, <a class="link-man" href="../html9/malloc.html">malloc(9)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> This <b class="name">audio</b> interface first appeared in <span class="unix">OpenBSD&#160;1.2</span>.</div>
</div>
</body>
</html>

