<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
UIOMOVE(9)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">uiomove</b> &#8212; <span class="desc">move data described by a struct uio</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/systm.h</a>&gt;</b><div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">uiomove</b>(<i class="farg" style="white-space:nowrap;">void *buf</i>, <i class="farg" style="white-space:nowrap;">size_t n</i>, <i class="farg" style="white-space:nowrap;">struct uio *uio</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <b class="name">uiomove</b> function copies up to <i class="farg">n</i> bytes between the kernel-space address pointed to by <i class="farg">buf</i> and the addresses described by <i class="farg">uio</i>, which may be in user-space or kernel-space.<div class="spacer">
</div>
The <i class="farg">uio</i> argument is a pointer to a <i class="farg">struct uio</i> as defined by <b class="includes">&lt;<a class="link-includes">sys/uio.h</a>&gt;</b>:<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
struct uio { 
	struct	iovec *uio_iov;	/* pointer to array of iovecs */ 
	int	uio_iovcnt;	/* number of iovecs in array */ 
	off_t	uio_offset;	/* offset into file this uio corresponds to */ 
	size_t	uio_resid;	/* residual i/o count */ 
	enum	uio_seg uio_segflg; 
	enum	uio_rw uio_rw; 
	struct	proc *uio_procp;/* associated process or NULL */ 
};</pre>
<div class="spacer">
</div>
A <i class="farg">struct uio</i> typically describes data in motion. Several of the fields described below reflect that expectation.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
uio_iov</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Pointer to array of <i class="farg">struct iovecs</i>:<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
struct iovec { 
	void	*iov_base;	/* Base address. */ 
	size_t	 iov_len;	/* Length. */ 
};</pre>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
uio_iovcnt</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
The number of iovecs in the array.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
uio_offset</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
An offset into the corresponding object.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
uio_resid</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
The amount of data remaining to be transferred.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
uio_segflg</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
A flag indicating whether the space described is in user-space (UIO_USERSPACE) or kernel-space (UIO_SYSSPACE).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
uio_rw</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
A flag indicating whether data should be read into the space (UIO_READ) or written from the space (UIO_WRITE).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
uio_procp</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
A pointer to a process whose data area is described by the structure, or which is having the I/O done on its behalf if the area is in kernel-space. <b class="name">uiomove</b> itself does not use this field if the area is in kernel-space, but other functions that take a <i class="farg">struct uio</i> may depend on this information.</dd>
</dl>
<div class="spacer">
</div>
The value of <i class="farg">uio-&gt;uio_rw</i> controls whether <b class="name">uiomove</b> copies data from <i class="farg">buf</i> to <i class="farg">uio</i> or vice versa.<div class="spacer">
</div>
The lesser of <i class="farg">n</i> or <i class="farg">uio-&gt;uio_resid</i> bytes are copied.<div class="spacer">
</div>
<b class="name">uiomove</b> changes fields of the structure pointed to by <i class="farg">uio</i>, such that <i class="farg">uio-&gt;uio_resid</i> is decremented by the amount of data moved, <i class="farg">uio-&gt;uio_offset</i> is incremented by the same amount, and the array of iovecs is adjusted to point that much farther into the region described. This allows multiple calls to <b class="name">uiomove</b> to easily be used to fill or drain the region of data.</div>
<div class="section">
<h1 id="x52455455524e2056414c554553">RETURN VALUES</h1> <b class="name">uiomove</b> returns 0 on success or EFAULT if a bad address is encountered.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html9/copy.html">copy(9)</a></div>
</div>
</body>
</html>

