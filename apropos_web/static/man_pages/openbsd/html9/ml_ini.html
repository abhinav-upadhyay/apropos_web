<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
ML_INIT(9)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">ml_init</b>, <b class="name">ml_enqueue</b>, <b class="name">ml_dequeue</b>, <b class="name">ml_enlist</b>, <b class="name">ml_dechain</b>, <b class="name">ml_len</b>, <b class="name">ml_empty</b>, <b class="name">ml_purge</b>, <b class="name">MBUF_LIST_INITIALIZER</b>, <b class="name">MBUF_LIST_FIRST</b>, <b class="name">MBUF_LIST_NEXT</b>, <b class="name">MBUF_LIST_FOREACH</b> &#8212; <span class="desc">mbuf list API</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/mbuf.h</a>&gt;</b><div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">ml_init</b>(<i class="farg" style="white-space:nowrap;">struct mbuf_list *ml</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">ml_enqueue</b>(<i class="farg" style="white-space:nowrap;">struct mbuf_list *ml</i>, <i class="farg" style="white-space:nowrap;">struct mbuf *m</i>);<div class="spacer">
</div>
<i class="ftype">struct mbuf *</i><br/>
<b class="fname">ml_dequeue</b>(<i class="farg" style="white-space:nowrap;">struct mbuf_list *ml</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">ml_enlist</b>(<i class="farg" style="white-space:nowrap;">struct mbuf_list *ml</i>, <i class="farg" style="white-space:nowrap;">struct mbuf_list *src</i>);<div class="spacer">
</div>
<i class="ftype">struct mbuf *</i><br/>
<b class="fname">ml_dechain</b>(<i class="farg" style="white-space:nowrap;">struct mbuf_list *ml</i>);<div class="spacer">
</div>
<i class="ftype">unsigned int</i><br/>
<b class="fname">ml_len</b>(<i class="farg" style="white-space:nowrap;">struct mbuf_list *ml</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">ml_empty</b>(<i class="farg" style="white-space:nowrap;">struct mbuf_list *ml</i>);<div class="spacer">
</div>
<i class="ftype">unsigned int</i><br/>
<b class="fname">ml_purge</b>(<i class="farg" style="white-space:nowrap;">struct mbuf_list *ml</i>);<div class="spacer">
</div>
<i class="ftype">struct mbuf_list</i><br/>
<b class="fname">MBUF_LIST_INITIALIZER</b>();<div class="spacer">
</div>
<i class="ftype">struct mbuf *</i><br/>
<b class="fname">MBUF_LIST_FIRST</b>(<i class="farg" style="white-space:nowrap;">struct mbuf_list *ml</i>);<div class="spacer">
</div>
<i class="ftype">struct mbuf *</i><br/>
<b class="fname">MBUF_LIST_NEXT</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>);<div class="spacer">
</div>
<b class="fname">MBUF_LIST_FOREACH</b>(<i class="farg" style="white-space:nowrap;">struct mbuf_list *ml</i>, <i class="farg" style="white-space:nowrap;">VARNAME</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The mbuf list API provides implementations of data structures and operations for managing lists of mbufs between contexts.<div class="spacer">
</div>
mbuf_list structures support the following functionality:<div class="spacer">
</div>
<ol style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-enum">
<li class="list-enum" style="margin-top: 0.00em;">
Insertion of a new mbuf at the end of the list.</li>
<li class="list-enum" style="margin-top: 0.00em;">
Removal of an mbuf from the head of the list.</li>
</ol>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">ml_init</b>(<i class="farg">struct mbuf_list *ml</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Initialise the <i class="farg">ml</i> mbuf_list structure.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">MBUF_LIST_INITIALIZER</b>()</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
An initialiser for an mbuf_list structure declaration.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">ml_enqueue</b>(<i class="farg">struct mbuf_list *ml</i>, <i class="farg">struct mbuf *m</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Enqueue mbuf <i class="farg">m</i> on the end of the <i class="farg">ml</i> mbuf list.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">ml_dequeue</b>(<i class="farg">struct mbuf_list *ml</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Dequeue an mbuf from the front of the <i class="farg">ml</i> mbuf list.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">ml_enlist</b>(<i class="farg">struct mbuf_list *ml</i>, <i class="farg">struct mbuf_list *src</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Enqueue all the mbufs on the <i class="farg">src</i> mbuf list on to the end of the <i class="farg">ml</i> mbuf list.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">ml_dechain</b>(<i class="farg">struct mbuf_list *ml</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Dequeues all mbufs from the <i class="farg">ml</i> mbuf list.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">ml_len</b>(<i class="farg">struct mbuf_list *ml</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Return the number of mbufs on the <i class="farg">ml</i> mbuf list.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">ml_empty</b>(<i class="farg">struct mbuf_list *ml</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Return if the <i class="farg">ml</i> mbuf list is empty.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">ml_purge</b>(<i class="farg">struct mbuf_list *ml</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Free all the mbufs on the <i class="farg">ml</i> mbuf list.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">MBUF_LIST_FIRST</b>(<i class="farg">struct mbuf_list *ml</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Access the first mbuf in the <i class="farg">ml</i> mbuf list for traversal.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">MBUF_LIST_NEXT</b>(<i class="farg">struct mbuf *m</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Access the next mbuf in the mbuf list after <i class="farg">m</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">MBUF_LIST_FOREACH</b>(<i class="farg">struct mbuf_list *ml</i>, <i class="farg">VARNAME</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
A convenience macro that can be used to iterate over the contents of the <i class="farg">ml</i> mbuf list. <i class="farg">VARNAME</i> identifies the name (not the address) of an mbuf pointer that will be set to each entry on the list. Note that it is unsafe to modify the list while iterating over it.</dd>
</dl>
</div>
<div class="section">
<h1 id="x434f4e54455854">CONTEXT</h1> <b class="fname">ml_init</b>(), <b class="fname">ml_enqueue</b>(), <b class="fname">ml_dequeue</b>(), <b class="fname">ml_enlist</b>(), <b class="fname">ml_dechain</b>(), <b class="fname">ml_len</b>(), <b class="fname">ml_empty</b>(), <b class="fname">ml_purge</b>(), <b class="fname">MBUF_LIST_INITIALIZER</b>(), <b class="fname">MBUF_LIST_FIRST</b>(), <b class="fname">MBUF_LIST_NEXT</b>(), and <b class="fname">MBUF_LIST_FOREACH</b>() can be called during autoconf, from process context, or from interrupt context.</div>
<div class="section">
<h1 id="x52455455524e2056414c554553">RETURN VALUES</h1> <b class="fname">ml_dequeue</b>() returns the mbuf that was at the head of its list. If the list was empty, <span class="define">NULL</span> is returned.<div class="spacer">
</div>
<b class="fname">ml_dechain</b>() returns all the mbufs that were on the list via a pointer to an mbuf with the chain accessible via m_nextpkt members. If the list was empty, <span class="define">NULL</span> is returned.<div class="spacer">
</div>
<b class="fname">ml_len</b>() returns the number of mbufs on the list.<div class="spacer">
</div>
<b class="fname">ml_empty</b>() return a non-zero value if the list is empty, otherwise 0.<div class="spacer">
</div>
<b class="fname">ml_purge</b>() returns the number of mbufs that were freed.<div class="spacer">
</div>
<b class="fname">MBUF_LIST_FIRST</b>() returns the first mbuf in the mbuf list, or <span class="define">NULL</span> if the list is empty.<div class="spacer">
</div>
<b class="fname">MBUF_LIST_NEXT</b>() returns the next mbuf in the mbuf list, or <span class="define">NULL</span> if the end of the list has been reached.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html9/mbuf.html">mbuf(9)</a></div>
</div>
</body>
</html>

