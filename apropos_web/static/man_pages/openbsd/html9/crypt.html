<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
CRYPTO_GET_DRIVERID(9)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">crypto_get_driverid</b>, <b class="name">crypto_register</b>, <b class="name">crypto_unregister</b>, <b class="name">crypto_done</b>, <b class="name">crypto_newsession</b>, <b class="name">crypto_freesession</b>, <b class="name">crypto_dispatch</b>, <b class="name">crypto_getreq</b>, <b class="name">crypto_freereq</b> &#8212; <span class="desc">API for cryptographic services in the kernel</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">crypto/cryptodev.h</a>&gt;</b><div class="spacer">
</div>
<i class="ftype">int32_t</i><br/>
<b class="fname">crypto_get_driverid</b>(<i class="farg" style="white-space:nowrap;">u_int8_t</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">crypto_register</b>(<i class="farg" style="white-space:nowrap;">u_int32_t</i>, <i class="farg" style="white-space:nowrap;">int *</i>, <i class="farg" style="white-space:nowrap;">int (*)(u_int32_t *, struct cryptoini *)</i>, <i class="farg" style="white-space:nowrap;">int (*)(u_int64_t)</i>, <i class="farg" style="white-space:nowrap;">int (*)(struct cryptop *)</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">crypto_unregister</b>(<i class="farg" style="white-space:nowrap;">u_int32_t</i>, <i class="farg" style="white-space:nowrap;">int</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">crypto_done</b>(<i class="farg" style="white-space:nowrap;">struct cryptop *</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">crypto_newsession</b>(<i class="farg" style="white-space:nowrap;">u_int64_t *</i>, <i class="farg" style="white-space:nowrap;">struct cryptoini *</i>, <i class="farg" style="white-space:nowrap;">int</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">crypto_freesession</b>(<i class="farg" style="white-space:nowrap;">u_int64_t</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">crypto_dispatch</b>(<i class="farg" style="white-space:nowrap;">struct cryptop *</i>);<div class="spacer">
</div>
<i class="ftype">struct cryptop *</i><br/>
<b class="fname">crypto_getreq</b>(<i class="farg" style="white-space:nowrap;">int</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">crypto_freereq</b>(<i class="farg" style="white-space:nowrap;">struct cryptop *</i>);<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
 
#define EALG_MAX_BLOCK_LEN      16 
 
struct cryptoini { 
	int                cri_alg; 
	int                cri_klen; 
	int                cri_rnd; 
	caddr_t            cri_key; 
	u_int8_t           cri_iv[EALG_MAX_BLOCK_LEN]; 
	struct cryptoini  *cri_next; 
}; 
 
struct cryptodesc { 
	int                crd_skip; 
	int                crd_len; 
	int                crd_inject; 
	int                crd_flags; 
	struct cryptoini   CRD_INI; 
	struct cryptodesc *crd_next; 
}; 
 
struct cryptop { 
	u_int64_t          crp_sid; 
	int                crp_ilen; 
	int                crp_olen; 
	int                crp_alloctype; 
	int                crp_etype; 
	int                crp_flags; 
	void              *crp_buf; 
	void              *crp_opaque; 
	struct cryptodesc *crp_desc; 
	int              (*crp_callback)(struct cryptop *); 
	struct cryptop    *crp_next; 
	caddr_t            crp_mac; 
};</pre>
</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> <b class="name">crypto_get_driverid</b> is a framework for drivers of cryptographic hardware to register with the kernel so &#8220;consumers&#8221; (other kernel subsystems, and eventually users through an appropriate device) are able to make use of it. Drivers register with the framework the algorithms they support, and provide entry points (functions) the framework may call to establish, use, and tear down sessions. Sessions are used to cache cryptographic information in a particular driver (or associated hardware), so initialization is not needed with every request. Consumers of cryptographic services pass a set of descriptors that instruct the framework (and the drivers registered with it) of the operations that should be applied on the data (more than one cryptographic operation can be requested).<div class="spacer">
</div>
Since the consumers may not be associated with a process, drivers may not use <a class="link-man" href="../html9/tsleep.html">tsleep(9)</a>. The same holds for the framework. Thus, a callback mechanism is used to notify a consumer that a request has been completed (the callback is specified by the consumer on a per-request basis). The callback is invoked by the framework whether the request was successfully completed or not. An error indication is provided in the latter case. A specific error code, <span class="errno">EAGAIN</span>, is used to indicate that a session number has changed and that the request may be re-submitted immediately with the new session number. Errors are only returned to the invoking function if not enough information to call the callback is available (meaning, there was a fatal error in verifying the arguments). For session initialization and teardown there is no callback mechanism used.<div class="spacer">
</div>
The <b class="fname">crypto_newsession</b>() routine is called by consumers of cryptographic services (such as the <a class="link-man" href="../html4/ipsec.html">ipsec(4)</a> stack) that wish to establish a new session with the framework. On success, the first argument will contain the Session Identifier (SID). The second argument contains all the necessary information for the driver to establish the session. The third argument indicates whether a hardware driver should be used (1) or not (0). The various fields in the <i class="farg">cryptoini</i> structure are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">cri_alg</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Contains an algorithm identifier. Currently supported encryption algorithms are:<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
CRYPTO_3DES_CBC 
CRYPTO_BLF_CBC 
CRYPTO_CAST_CBC 
CRYPTO_AES_CBC 
CRYPTO_AES_CTR 
CRYPTO_AES_XTS</pre>
<div class="spacer">
</div>
Authentication algorithms are:<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
CRYPTO_MD5_HMAC 
CRYPTO_SHA1_HMAC 
CRYPTO_RIPEMD160_HMAC 
CRYPTO_SHA2_256_HMAC 
CRYPTO_SHA2_384_HMAC 
CRYPTO_SHA2_512_HMAC</pre>
<div class="spacer">
</div>
Algorithms performing authenticated encryption are:<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
CRYPTO_AES_GCM_16 
CRYPTO_AES_GMAC 
CRYPTO_CHACHA20_POLY1305</pre>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">cri_klen</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Specifies the length of the key in bits, for variable-size key algorithms.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">cri_rnd</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Specifies the number of rounds to be used with the algorithm, for variable-round algorithms.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">cri_key</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Contains the key to be used with the algorithm.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">cri_iv</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Contains an explicit initialization vector (IV), if it does not prefix the data. This field is ignored during initialization. If no IV is explicitly passed (see below on details), a random IV is used by the device driver processing the request.<div class="spacer">
</div>
In the case of the CRYPTO_AES_XTS transform, the IV should be provided as a 64-bit block number in host byte order.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">cri_next</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Contains a pointer to another <i class="farg">cryptoini</i> structure. Multiple such structures may be linked to establish multi-algorithm sessions (<a class="link-man" href="../html4/ipsec.html">ipsec(4)</a> is an example consumer of such a feature).</dd>
</dl>
<div class="spacer">
</div>
The <i class="farg">cryptoini</i> structure and its contents will not be modified by the framework (or the drivers used). Subsequent requests for processing that use the SID returned will avoid the cost of re-initializing the hardware (in essence, SID acts as an index in the session cache of the driver).<div class="spacer">
</div>
<b class="fname">crypto_freesession</b>() is called with the SID returned by <b class="fname">crypto_newsession</b>() to disestablish the session.<div class="spacer">
</div>
<b class="fname">crypto_dispatch</b>() is called to process a request. The various fields in the <i class="farg">cryptop</i> structure are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">crp_sid</i></dt>
<dd class="list-tag" style="margin-left: 13.00ex;">
Contains the SID.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">crp_ilen</i></dt>
<dd class="list-tag" style="margin-left: 13.00ex;">
Indicates the total length in bytes of the buffer to be processed.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">crp_olen</i></dt>
<dd class="list-tag" style="margin-left: 13.00ex;">
On return, contains the length of the result, not including <i class="farg">crd_skip</i>. For symmetric crypto operations, this will be the same as the input length.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">crp_alloctype</i></dt>
<dd class="list-tag" style="margin-left: 13.00ex;">
Indicates the type of buffer, as used in the kernel <a class="link-man" href="../html9/malloc.html">malloc(9)</a> routine. This will be used if the framework needs to allocate a new buffer for the result (or for re-formatting the input).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">crp_callback</i></dt>
<dd class="list-tag" style="margin-left: 13.00ex;">
This routine is invoked upon completion of the request, whether successful or not. It is invoked through the <b class="fname">crypto_done</b>() routine. If the request was not successful, an error code is set in the <i class="farg">crp_etype</i> field. It is the responsibility of the callback routine to set the appropriate <a class="link-man" href="../html9/spl.html">spl(9)</a> level.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">crp_etype</i></dt>
<dd class="list-tag" style="margin-left: 13.00ex;">
Contains the error type, if any errors were encountered, or zero if the request was successfully processed. If the <span class="errno">EAGAIN</span> error code is returned, the SID has changed (and has been recorded in the <i class="farg">crp_sid</i> field). The consumer should record the new SID and use it in all subsequent requests. In this case, the request may be re-submitted immediately. This mechanism is used by the framework to perform session migration (move a session from one driver to another, because of availability, performance, or other considerations).<div class="spacer">
</div>
Note that this field only makes sense when examined by the callback routine specified in <i class="farg">crp_callback</i>. Errors are returned to the invoker of <b class="fname">crypto_process</b>() only when enough information is not present to call the callback routine (i.e., if the pointer passed is <span class="define">NULL</span> or if no callback routine was specified).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">crp_flags</i></dt>
<dd class="list-tag" style="margin-left: 13.00ex;">
Is a bitmask of flags associated with this request. Currently defined flags are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">CRYPTO_F_IMBUF</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
The buffer pointed to by <i class="farg">crp_buf</i> is an mbuf chain.</dd>
</dl>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">crp_buf</i></dt>
<dd class="list-tag" style="margin-left: 13.00ex;">
Points to the input buffer. On return (when the callback is invoked), it contains the result of the request. The input buffer may be an mbuf chain or a struct uio depending on <i class="farg">crp_flags</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">crp_opaque</i></dt>
<dd class="list-tag" style="margin-left: 13.00ex;">
This is passed through the crypto framework untouched and is intended for the invoking application's use.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">crp_desc</i></dt>
<dd class="list-tag" style="margin-left: 13.00ex;">
This is a linked list of descriptors. Each descriptor provides information about what type of cryptographic operation should be done on the input buffer. The various fields are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">crd_skip</i></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
The offset in the input buffer where processing should start.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">crd_len</i></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
How many bytes, after <i class="farg">crd_skip</i>, should be processed.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">crd_inject</i></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Offset from the beginning of the buffer to insert any results. For encryption algorithms, this is where the initialization vector (IV) will be inserted when encrypting or where it can be found when decrypting (subject to <i class="farg">crd_flags</i>). For MAC algorithms, this is where the result of the keyed hash will be inserted.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">crd_flags</i></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
The following flags are defined:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">CRD_F_ENCRYPT</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
For encryption algorithms, this bit is set when encryption is required (when not set, decryption is performed).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">CRD_F_IV_PRESENT</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
For encryption algorithms, this bit is set when the IV already precedes the data, so the <i class="farg">crd_inject</i> value will be ignored and no IV will be written in the buffer. Otherwise, the IV used to encrypt the packet will be written at the location pointed to by <i class="farg">crd_inject</i>. The IV length is assumed to be equal to the blocksize of the encryption algorithm. Some applications that do special &#8220;IV cooking&#8221;, such as the half-IV mode in <a class="link-man" href="../html4/ipsec.html">ipsec(4)</a>, can use this flag to indicate that the IV should not be written on the packet. This flag is typically used in conjunction with the <span class="define">CRD_F_IV_EXPLICIT</span> flag.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">CRD_F_IV_EXPLICIT</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
For encryption algorithms, this bit is set when the IV is explicitly provided by the consumer in the <i class="farg">crd_iv</i> fields. Otherwise, for encryption operations the IV is provided for by the driver used to perform the operation, whereas for decryption operations it is pointed to by the <i class="farg">crd_inject</i> field. This flag is typically used when the IV is calculated &#8220;on the fly&#8221; by the consumer, and does not precede the data (some <a class="link-man" href="../html4/ipsec.html">ipsec(4)</a> configurations, and the encrypted swap are two such examples).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">CRD_F_COMP</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
For compression algorithms, this bit is set when compression is required (when not set, decompression is performed).</dd>
</dl>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">CRD_INI</i></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
This <i class="farg">cryptoini</i> structure will not be modified by the framework or the device drivers. Since this information accompanies every cryptographic operation request, drivers may re-initialize state on-demand (typically an expensive operation). Furthermore, the cryptographic framework may re-route requests as a result of full queues or hardware failure, as described above.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">crd_next</i></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Point to the next descriptor. Linked operations are useful in protocols such as <a class="link-man" href="../html4/ipsec.html">ipsec(4)</a>, where multiple cryptographic transforms may be applied on the same block of data.</dd>
</dl>
</dd>
</dl>
<div class="spacer">
</div>
<b class="fname">crypto_getreq</b>() allocates a <i class="farg">cryptop</i> structure with a linked list of as many <i class="farg">cryptodesc</i> structures as were specified in the argument passed to it.<div class="spacer">
</div>
<b class="fname">crypto_freereq</b>() deallocates a structure <i class="farg">cryptop</i> and any <i class="farg">cryptodesc</i> structures linked to it. Note that it is the responsibility of the callback routine to do the necessary cleanups associated with the opaque field in the <i class="farg">cryptop</i> structure.</div>
<div class="section">
<h1 id="x4452495645521e5349444520415049">DRIVER-SIDE API</h1> The <b class="fname">crypto_get_driverid</b>(), <b class="fname">crypto_register</b>(), <b class="fname">crypto_unregister</b>(), and <b class="fname">crypto_done</b>() routines are used by drivers that provide support for cryptographic primitives to register and unregister with the kernel crypto services framework. Drivers must first use the <b class="fname">crypto_get_driverid</b>() function to acquire a driver identifier, specifying the <i class="farg">cc_flags</i> as an argument (normally 0, but software-only drivers should specify <span class="define">CRYPTOCAP_F_SOFTWARE</span>). For each algorithm the driver supports, it must then call <b class="fname">crypto_register</b>(). The first argument is the driver identifier. The second argument is an array of <span class="define">CRYPTO_ALGORITHM_MAX + 1</span> elements, indicating which algorithms are supported. The last three arguments are pointers to three driver-provided functions that the framework may call to establish new cryptographic context with the driver, free already established context, and ask for a request to be processed (encrypt, decrypt, etc.) <b class="fname">crypto_unregister</b>() is called by drivers that wish to withdraw support for an algorithm. The two arguments are the driver and algorithm identifiers, respectively. Typically, drivers for <a class="link-man" href="../html4/pcmcia.html">pcmcia(4)</a> crypto cards that are being ejected will invoke this routine for all algorithms supported by the card. If called with <span class="define">CRYPTO_ALGORITHM_ALL</span>, all algorithms registered for a driver will be unregistered in one go and the driver will be disabled (no new sessions will be allocated on that driver, and any existing sessions will be migrated to other drivers). The same will be done if all algorithms associated with a driver are unregistered one by one.<div class="spacer">
</div>
The calling convention for the three driver-supplied routines is:<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
int (*newsession) (u_int32_t *, struct cryptoini *); 
int (*freesession) (u_int64_t); 
int (*process) (struct cryptop *);</pre>
<div class="spacer">
</div>
On invocation, the first argument to <b class="fname">newsession</b>() contains the driver identifier obtained via <b class="fname">crypto_get_driverid</b>(). On successfully returning, it should contain a driver-specific session identifier. The second argument is identical to that of <b class="fname">crypto_newsession</b>().<div class="spacer">
</div>
The <b class="fname">freesession</b>() routine takes as argument the SID (which is the concatenation of the driver identifier and the driver-specific session identifier). It should clear any context associated with the session (clear hardware registers, memory, etc.).<div class="spacer">
</div>
The <b class="fname">process</b>() routine is invoked with a request to perform crypto processing. This routine must not block, but should queue the request and return immediately. Upon processing the request, the callback routine should be invoked. In case of error, the error indication must be placed in the <i class="farg">crp_etype</i> field of the <i class="farg">cryptop</i> structure. When the request is completed, or an error is detected, the <b class="fname">process</b>() routine should invoke <b class="fname">crypto_done</b>(). Session migration may be performed, as mentioned previously.</div>
<div class="section">
<h1 id="x52455455524e2056414c554553">RETURN VALUES</h1> <b class="fname">crypto_register</b>(), <b class="fname">crypto_unregister</b>(), <b class="fname">crypto_newsession</b>(), and <b class="fname">crypto_freesession</b>() return 0 on success, or an error code on failure. <b class="fname">crypto_get_driverid</b>() returns a non-negative value on error, and -1 on failure. <b class="fname">crypto_getreq</b>() returns a pointer to a <i class="farg">cryptop</i> structure and <span class="define">NULL</span> on failure. <b class="fname">crypto_dispatch</b>() returns <span class="errno">EINVAL</span> if its argument or the callback function was <span class="define">NULL</span>, and 0 otherwise. The callback is provided with an error code in case of failure, in the <i class="farg">crp_etype</i> field.</div>
<div class="section">
<h1 id="x46494c4553">FILES</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="file">sys/crypto/crypto.c</i></dt>
<dd class="list-tag" style="margin-left: 19.00ex;">
most of the framework code</dd>
</dl>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html4/ipsec.html">ipsec(4)</a>, <a class="link-man" href="../html4/pcmcia.html">pcmcia(4)</a>, <a class="link-man" href="../html9/malloc.html">malloc(9)</a>, <a class="link-man" href="../html9/tsleep.html">tsleep(9)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The cryptographic framework first appeared in <span class="unix">OpenBSD&#160;2.7</span> and was written by <span class="author">Angelos D. Keromytis</span> &lt;<a class="link-mail" href="mailto:angelos@openbsd.org">angelos@openbsd.org</a>&gt;.</div>
<div class="section">
<h1 id="x42554753">BUGS</h1> The framework currently assumes that all the algorithms in a <b class="fname">crypto_newsession</b>() operation must be available by the same driver. If that's not the case, session initialization will fail.<div class="spacer">
</div>
The framework also needs a mechanism for determining which driver is best for a specific set of algorithms associated with a session. Some type of benchmarking is in order here.<div class="spacer">
</div>
Multiple instances of the same algorithm in the same session are not supported.<div class="spacer">
</div>
A queue for completed operations should be implemented and processed at some software <a class="link-man" href="../html9/spl.html">spl(9)</a> level, to avoid overall system latency issues, and potential kernel stack exhaustion while processing a callback.</div>
</div>
</body>
</html>

