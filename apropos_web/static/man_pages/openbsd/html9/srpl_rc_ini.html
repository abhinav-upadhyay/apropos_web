<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
SRPL_RC_INIT(9)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">srpl_rc_init</b>, <b class="name">SRPL_HEAD</b>, <b class="name">SRPL_ENTRY</b>, <b class="name">SRPL_INIT</b>, <b class="name">SRPL_ENTER</b>, <b class="name">SRPL_NEXT</b>, <b class="name">SRPL_FOREACH</b>, <b class="name">SRPL_LEAVE</b>, <b class="name">SRPL_EMPTY_LOCKED</b>, <b class="name">SRPL_FIRST_LOCKED</b>, <b class="name">SRPL_NEXT_LOCKED</b>, <b class="name">SRPL_FOREACH_LOCKED</b>, <b class="name">SRPL_FOREACH_SAFE_LOCKED</b>, <b class="name">SRPL_INSERT_HEAD_LOCKED</b>, <b class="name">SRPL_INSERT_AFTER_LOCKED</b>, <b class="name">SRPL_REMOVE_LOCKED</b>, <b class="name">SRPL_RC_INITIALIZER</b> &#8212; <span class="desc">singly-linked shared reference pointer list</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/srp.h</a>&gt;</b><div class="spacer">
</div>
<span class="type">struct srpl_rc;</span><div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">srpl_rc_init</b>(<i class="farg">struct srpl_rc *rc</i>, <i class="farg">void (*ref)(void *, void *)</i>, <i class="farg">void (*unref)(void *, void *)</i>, <i class="farg">void *ctx</i>);<div class="spacer">
</div>
<b class="fname">SRPL_HEAD</b>(<i class="farg" style="white-space:nowrap;">HEADNAME</i>, <i class="farg" style="white-space:nowrap;">TYPE</i>);<div class="spacer">
</div>
<b class="fname">SRPL_ENTRY</b>(<i class="farg" style="white-space:nowrap;">TYPE</i>);<div class="spacer">
</div>
<b class="fname">SRPL_INIT</b>(<i class="farg" style="white-space:nowrap;">SRPL_HEAD *sl</i>);<div class="spacer">
</div>
<i class="ftype">void *</i><br/>
<b class="fname">SRPL_ENTER</b>(<i class="farg" style="white-space:nowrap;">struct srp_ref *sr</i>, <i class="farg" style="white-space:nowrap;">SRPL_HEAD *sl</i>);<div class="spacer">
</div>
<i class="ftype">void *</i><br/>
<b class="fname">SRPL_NEXT</b>(<i class="farg" style="white-space:nowrap;">struct srp_ref *sr</i>, <i class="farg" style="white-space:nowrap;">struct TYPE *listelm</i>, <i class="farg" style="white-space:nowrap;">FIELDNAME</i>);<div class="spacer">
</div>
<b class="fname">SRPL_FOREACH</b>(<i class="farg">VARNAME</i>, <i class="farg">struct srp_ref *sr</i>, <i class="farg">SRPL_HEAD *sl</i>, <i class="farg">FIELDNAME</i>);<div class="spacer">
</div>
<b class="fname">SRPL_LEAVE</b>(<i class="farg" style="white-space:nowrap;">struct srp_ref *sr</i>);<div class="spacer">
</div>
<b class="fname">SRPL_EMPTY_LOCKED</b>(<i class="farg" style="white-space:nowrap;">SRPL_HEAD *sl</i>);<div class="spacer">
</div>
<i class="ftype">void *</i><br/>
<b class="fname">SRPL_FIRST_LOCKED</b>(<i class="farg" style="white-space:nowrap;">SRPL_HEAD *sl</i>);<div class="spacer">
</div>
<i class="ftype">void *</i><br/>
<b class="fname">SRPL_NEXT_LOCKED</b>(<i class="farg" style="white-space:nowrap;">struct TYPE *listelm</i>, <i class="farg" style="white-space:nowrap;">FIELDNAME</i>);<div class="spacer">
</div>
<b class="fname">SRPL_FOREACH_LOCKED</b>(<i class="farg" style="white-space:nowrap;">VARNAME</i>, <i class="farg" style="white-space:nowrap;">SRPL_HEAD *sl</i>, <i class="farg" style="white-space:nowrap;">FIELDNAME</i>);<div class="spacer">
</div>
<b class="fname">SRPL_FOREACH_SAFE_LOCKED</b>(<i class="farg" style="white-space:nowrap;">VARNAME</i>, <i class="farg" style="white-space:nowrap;">SRPL_HEAD *sl</i>, <i class="farg" style="white-space:nowrap;">FIELDNAME</i>, <i class="farg" style="white-space:nowrap;">TEMP_VARNAME</i>);<div class="spacer">
</div>
<b class="fname">SRPL_INSERT_HEAD_LOCKED</b>(<i class="farg">struct srpl_rc *rc</i>, <i class="farg">SRPL_HEAD *sl</i>, <i class="farg">struct TYPE *elm</i>, <i class="farg">FIELDNAME</i>);<div class="spacer">
</div>
<b class="fname">SRPL_INSERT_AFTER_LOCKED</b>(<i class="farg">struct srpl_rc *rc</i>, <i class="farg">struct TYPE *listelm</i>, <i class="farg">struct TYPE *elm</i>, <i class="farg">FIELDNAME</i>);<div class="spacer">
</div>
<b class="fname">SRPL_REMOVE_LOCKED</b>(<i class="farg">struct srpl_rc *rc</i>, <i class="farg">SRPL_HEAD *sl</i>, <i class="farg">struct TYPE *listelm</i>, <i class="farg">TYPE</i>, <i class="farg">FIELDNAME</i>);<div class="spacer">
</div>
<b class="fname">SRPL_RC_INITIALIZER</b>(<i class="farg">void (*ref)(void *, void *)</i>, <i class="farg">void (*unref)(void *, void *)</i>, <i class="farg">void *ctx</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The srpl macros build a linked list on top of shared reference pointers. This allows concurrent traversal of a linked list and access to the items on the list.<div class="spacer">
</div>
SRP lists are a generic type represented by a <span class="type">SRPL_HEAD</span>. The elements inserted into the list must be structures that contain a <span class="type">SRPL_ENTRY</span> field. Further, the elements must also support reference counting as insertion and removal operations can cause items to be temporarily referenced by multiple SRPs within the list at the same time.<div class="spacer">
</div>
<b class="fname">srpl_rc_init</b>() initialises the SRP list refcounts <i class="farg">rc</i> structure so it can be used to manage the reference counts on elements in the list. The insertion or removal of an element in an SRP list will increment the reference counts on elements within the list via calls to <i class="farg">ref</i>. As these references are released by the SRP infrastructure, the reference counts will be decremented by calls to <i class="farg">unref</i>. <i class="farg">unref</i> is also responsible for freeing the element when the reference count reaches 0. Both <i class="farg">ref</i> and <i class="farg">unref</i> will be called with <i class="farg">ctx</i> as their first argument and a pointer to the element as their second argument.<div class="spacer">
</div>
<b class="fname">SRPL_INIT</b>() initialises the SRP list <i class="farg">sl</i> to an empty state.<div class="spacer">
</div>
<b class="fname">SRPL_ENTER</b>() begins iterating over elements in the SRP list <i class="farg">sl</i>. The reference to the list item is held via <i class="farg">sr</i>. Every call to <b class="fname">SRPL_ENTER</b>() must have a corresponding call to <b class="fname">SRPL_LEAVE</b>() to release references to the list and its elements.<div class="spacer">
</div>
<b class="fname">SRPL_NEXT</b>() accesses the element in the SRP list after <i class="farg">listelm</i>.<div class="spacer">
</div>
<b class="fname">SRPL_FOREACH</b>() creates a loop for traversing the list. Every call to <b class="fname">SRPL_FOREACH</b>() must have a corresponding call to <b class="fname">SRPL_LEAVE</b>() to release references to the list and its elements.<div class="spacer">
</div>
<b class="fname">SRPL_LEAVE</b>() releases references to the list and its elements held by previous calls to <b class="fname">SRPL_ENTER</b>(), <b class="fname">SRPL_NEXT</b>(), or <b class="fname">SRPL_FOREACH</b>().<div class="spacer">
</div>
<b class="fname">SRPL_EMPTY_LOCKED</b>() tests whether the SRP list <i class="farg">sl</i> is empty.<div class="spacer">
</div>
<b class="fname">SRPL_FIRST_LOCKED</b>() accesses the first element in the SRP list <i class="farg">sl</i>.<div class="spacer">
</div>
<b class="fname">SRPL_NEXT_LOCKED</b>() accesses the next element in the SRP list after <i class="farg">listelm</i>.<div class="spacer">
</div>
<b class="fname">SRPL_FOREACH_LOCKED</b>() creates a loop for traversing the elements in the SRP list <i class="farg">sl</i>.<div class="spacer">
</div>
<b class="fname">SRPL_FOREACH_SAFE_LOCKED</b>() creates a loop for traversing the elements in the SRP list <i class="farg">sl</i>, permitting it to remove <i class="farg">VARNAME</i> as well as freeing it from within the loop safely without interfering with the traversal.<div class="spacer">
</div>
<b class="fname">SRPL_INSERT_HEAD_LOCKED</b>() inserts <i class="farg">elm</i> into the SRP list <i class="farg">sl</i>. Reference counts are adjusted on the list items using the functions specified by <i class="farg">rc</i>.<div class="spacer">
</div>
<b class="fname">SRPL_INSERT_AFTER_LOCKED</b>() inserts <i class="farg">elm</i> into an SRP list after the element <i class="farg">listelm</i>. Reference counts are adjusted on the list items using the functions specified by <i class="farg">rc</i>.<div class="spacer">
</div>
<b class="fname">SRPL_REMOVE_LOCKED</b>() iterates over the SRP list <i class="farg">sl</i> until it finds <i class="farg">listelm</i> and then removes it. Reference counts are adjusted on the list items using the functions specified by <i class="farg">rc</i>.<div class="spacer">
</div>
An srpl_rc declaration can be initialised with the <b class="fname">SRPL_RC_INITIALIZER</b>() macro.</div>
<div class="section">
<h1 id="x434f4e54455854">CONTEXT</h1> <b class="fname">SRPL_INIT</b>(), <b class="fname">SRPL_ENTER</b>(), <b class="fname">SRPL_NEXT</b>(), <b class="fname">SRPL_FOREACH</b>(), and <b class="fname">SRPL_LEAVE</b>() may be called during autoconf, from process context, or from interrupt context.<div class="spacer">
</div>
<b class="fname">srpl_rc_init</b>(), <b class="fname">SRPL_EMPTY_LOCKED</b>(), <b class="fname">SRPL_FIRST_LOCKED</b>(), <b class="fname">SRPL_NEXT_LOCKED</b>(), <b class="fname">SRPL_FOREACH_LOCKED</b>(), <b class="fname">SRPL_INSERT_HEAD_LOCKED</b>(), <b class="fname">SRPL_INSERT_AFTER_LOCKED</b>(), and <b class="fname">SRPL_REMOVE_LOCKED</b>() may be called during autoconf or from process context. An appropriate lock must be held that prevents concurrent modifications to the list.</div>
<div class="section">
<h1 id="x52455455524e2056414c554553">RETURN VALUES</h1> <b class="fname">SRPL_ENTER</b>(), <b class="fname">SRPL_NEXT</b>(), <b class="fname">SRPL_FIRST_LOCKED</b>(), and <b class="fname">SRPL_NEXT_LOCKED</b>() return a pointer to elements in the SRP list, or <span class="define">NULL</span> if there are no more elements.<div class="spacer">
</div>
<b class="fname">SRPL_EMPTY_LOCKED</b>() returns non-zero when the list is empty, otherwise 0.</div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The srp API was originally written by <span class="author">Jonathan Matthew</span> &lt;<a class="link-mail" href="mailto:jmatthew@openbsd.org">jmatthew@openbsd.org</a>&gt; and <span class="author">David Gwynne</span> &lt;<a class="link-mail" href="mailto:dlg@openbsd.org">dlg@openbsd.org</a>&gt;. The SRP list API first appeared in <span class="unix">OpenBSD&#160;5.9</span>.</div>
</div>
</body>
</html>

