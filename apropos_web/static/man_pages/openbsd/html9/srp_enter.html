<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
SRP_ENTER(9)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">srp_init</b>, <b class="name">srp_gc_init</b>, <b class="name">srp_update</b>, <b class="name">srp_update_locked</b>, <b class="name">srp_enter</b>, <b class="name">srp_follow</b>, <b class="name">srp_leave</b>, <b class="name">srp_get_locked</b>, <b class="name">srp_gc_finalize</b>, <b class="name">SRP_INITIALIZER</b>, <b class="name">SRP_GC_INITIALIZER</b> &#8212; <span class="desc">shared reference pointers</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/srp.h</a>&gt;</b><div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">srp_init</b>(<i class="farg" style="white-space:nowrap;">struct srp *p</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">srp_gc_init</b>(<i class="farg">struct srp_gc *gc</i>, <i class="farg">void (*dtor)(void *, void *)</i>, <i class="farg">void *ctx</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">srp_update</b>(<i class="farg" style="white-space:nowrap;">struct srp_gc *gc</i>, <i class="farg" style="white-space:nowrap;">struct srp *p</i>, <i class="farg" style="white-space:nowrap;">void *v</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">srp_update_locked</b>(<i class="farg" style="white-space:nowrap;">struct srp_gc *gc</i>, <i class="farg" style="white-space:nowrap;">struct srp *p</i>, <i class="farg" style="white-space:nowrap;">void *v</i>);<div class="spacer">
</div>
<i class="ftype">void *</i><br/>
<b class="fname">srp_enter</b>(<i class="farg" style="white-space:nowrap;">struct srp_ref *sr</i>, <i class="farg" style="white-space:nowrap;">struct srp *p</i>);<div class="spacer">
</div>
<i class="ftype">void *</i><br/>
<b class="fname">srp_follow</b>(<i class="farg" style="white-space:nowrap;">struct srp_ref *sr</i>, <i class="farg" style="white-space:nowrap;">struct srp *n</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">srp_leave</b>(<i class="farg" style="white-space:nowrap;">struct srp_ref *sr</i>);<div class="spacer">
</div>
<i class="ftype">void *</i><br/>
<b class="fname">srp_get_locked</b>(<i class="farg" style="white-space:nowrap;">struct srp *p</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">srp_gc_finalize</b>(<i class="farg" style="white-space:nowrap;">struct srp_gc *gc</i>);<div class="spacer">
</div>
<b class="fname">SRP_INITIALIZER</b>();<div class="spacer">
</div>
<b class="fname">SRP_GC_INITIALIZER</b>(<i class="farg">void (*dtor)(void *, void *)</i>, <i class="farg">void *ctx</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> An srp structure represents a pointer or reference to an object in memory. The srp API provides concurrent lock free access to these objects, and can guarantee that the data isn't destroyed while that reference is in use. It does not prevent concurrent modification of the referenced object.<div class="spacer">
</div>
<b class="fname">srp_init</b>() initialises the srp structure <i class="farg">p</i> to an empty state.<div class="spacer">
</div>
<b class="fname">srp_gc_init</b>() initialises the srp_gc structure <i class="farg">gc</i> so it can be used as a garbage collector for data that gets referenced by srp structures. An update to an srp structure will cause the old data to be destroyed when it is no longer referenced by any CPU in the system. The old data will be destroyed by the garbage collector by a call to <i class="farg">dtor</i> with <i class="farg">ctx</i> as the first argument and the pointer to the data as the second argument.<div class="spacer">
</div>
<b class="fname">srp_update</b>() and <b class="fname">srp_update_locked</b>() replace the data referenced by the srp struct <i class="farg">p</i> with the data referenced by <i class="farg">v</i>. When the original data is no longer in use it will be destroyed by the garbage collector <i class="farg">gc</i>. <b class="fname">srp_update</b>() uses atomic CPU operations to change the references. <b class="fname">srp_update_locked</b>() may be used if modifications to <i class="farg">p</i> are already serialised by the caller. Both <b class="fname">srp_update</b>() and <b class="fname">srp_update_locked</b>() may sleep.<div class="spacer">
</div>
<b class="fname">srp_enter</b>() returns a pointer to a data structure referenced by the srp struct <i class="farg">p</i> and guarantees it will remain available for use until it is released with a call to <b class="fname">srp_leave</b>() or <b class="fname">srp_follow</b>(). The reference is held via <i class="farg">sr</i>.<div class="spacer">
</div>
<b class="fname">srp_follow</b>() replaces the reference held via <i class="farg">sr</i> with a reference to the data structure represented by <i class="farg">p</i>.<div class="spacer">
</div>
<b class="fname">srp_leave</b>() releases the reference held via <i class="farg">sr</i> and makes it available for garbage collection.<div class="spacer">
</div>
<b class="fname">srp_get_locked</b>() provides access to the data referenced by the srp <i class="farg">p</i> if the caller has excluded updates to <i class="farg">p</i>.<div class="spacer">
</div>
<b class="fname">srp_gc_finalize</b>() sleeps until all references to data by srp structures using the garbage collector <i class="farg">gc</i> have completed. That in turn means the <i class="farg">gc</i> structure will no longer be referenced and can itself be destroyed.<div class="spacer">
</div>
A srp structure declaration can be initialised with the <b class="fname">SRP_INITIALIZER</b>() macro.<div class="spacer">
</div>
A srp_gc structure declaration can be initialised with the <b class="fname">SRP_GC_INITIALIZER</b>() macro. Data will be destroyed by the garbage collector by a call to <i class="farg">dtor</i> with <i class="farg">ctx</i> as the first argument and the pointer to the data as the second argument.</div>
<div class="section">
<h1 id="x434f4e54455854">CONTEXT</h1> <b class="fname">srp_init</b>(), <b class="fname">srp_gc_init</b>(), <b class="fname">srp_update</b>(), <b class="fname">srp_update_locked</b>(), <b class="fname">srp_get_locked</b>(), and <b class="fname">srp_gc_finalize</b>() can be called during autoconf, or from process context.<div class="spacer">
</div>
<b class="fname">srp_enter</b>(), <b class="fname">srp_follow</b>(), and <b class="fname">srp_leave</b>() can be called during autoconf, from process context, or from interrupt context.</div>
<div class="section">
<h1 id="x52455455524e2056414c554553">RETURN VALUES</h1> <b class="fname">srp_enter</b>(), <b class="fname">srp_follow</b>(), and <b class="fname">srp_get_locked</b>() return a pointer to the data referenced by the srp structure <i class="farg">p</i> or <span class="define">NULL</span>.</div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The srp API was originally written by <span class="author">Jonathan Matthew</span> &lt;<a class="link-mail" href="mailto:jmatthew@openbsd.org">jmatthew@openbsd.org</a>&gt; and <span class="author">David Gwynne</span> &lt;<a class="link-mail" href="mailto:dlg@openbsd.org">dlg@openbsd.org</a>&gt;. The srp API first appeared in <span class="unix">OpenBSD&#160;5.8</span>.</div>
</div>
</body>
</html>

