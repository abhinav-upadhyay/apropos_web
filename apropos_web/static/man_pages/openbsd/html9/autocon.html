<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
CONFIG_SEARCH(9)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">config_search</b>, <b class="name">config_rootsearch</b>, <b class="name">config_found_sm</b>, <b class="name">config_found</b>, <b class="name">config_rootfound</b> &#8212; <span class="desc">autoconfiguration framework</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/param.h</a>&gt;</b><br/>
<b class="includes">#include &lt;<a class="link-includes">sys/device.h</a>&gt;</b></div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> Autoconfiguration is the process of matching hardware devices with an appropriate device driver. In its most basic form, autoconfiguration consists of the recursive process of finding and attaching all devices on a bus, including other buses.<div class="spacer">
</div>
The autoconfiguration framework supports <span class="emph">direct configuration</span> where the bus driver can determine the devices present.<div class="spacer">
</div>
The autoconfiguration framework also supports <span class="emph">indirect configuration</span> where the drivers must probe the bus looking for the presence of a device. Direct configuration is preferred since it can find hardware regardless of the presence of proper drivers.<div class="spacer">
</div>
The autoconfiguration process occurs at system bootstrap and is driven by a table generated from a &#8220;machine description&#8221; file by <a class="link-man" href="../html8/config.html">config(8)</a>. For a description of the <a class="link-man" href="../html8/config.html">config(8)</a> &#8220;device definition&#8221; language, see <a class="link-man" href="../html5/files.conf.html">files.conf(5)</a>.<div class="spacer">
</div>
Each device must have a name consisting of an alphanumeric string that ends with a unit number. The unit number identifies an instance of the driver. Device data structures are allocated dynamically during autoconfiguration, giving a unique address for each instance.</div>
<div class="section">
<h1 id="x494e44495245435420434f4e46494755524154494f4e">INDIRECT CONFIGURATION</h1> <i class="ftype">void *</i><br/>
<b class="fname">config_search</b>(<i class="farg" style="white-space:nowrap;">cfmatch_t func</i>, <i class="farg" style="white-space:nowrap;">struct device *parent</i>, <i class="farg" style="white-space:nowrap;">void *aux</i>);<div class="spacer">
</div>
<i class="ftype">void *</i><br/>
<b class="fname">config_rootsearch</b>(<i class="farg" style="white-space:nowrap;">cfmatch_t func</i>, <i class="farg" style="white-space:nowrap;">char *rootname</i>, <i class="farg" style="white-space:nowrap;">void *aux</i>);<div class="spacer">
</div>
The <b class="fname">config_search</b>() function performs indirect configuration of physical devices by iterating over all potential children, calling the given function <i class="farg">func</i> for each one.<div class="spacer">
</div>
The <b class="fname">config_rootsearch</b>() function finds the root device identified by the string <i class="farg">rootname</i>, in a manner similar to <b class="fname">config_search</b>(), except that there is no parent device. If <i class="farg">func</i> is <span class="define">NULL</span>, <b class="fname">config_search</b>() applies each child's match function instead. The argument <i class="farg">parent</i> is the pointer to the parent's device structure. The given <i class="farg">aux</i> argument describes the device that has been found and is simply passed on through <i class="farg">func</i> to the child. <b class="fname">config_search</b>() returns a pointer to the best-matched child or <span class="define">NULL</span> otherwise.<div class="spacer">
</div>
The role of <i class="farg">func</i> is to call the match function for each device and call <b class="fname">config_attach</b>() for any positive matches.<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
typedef int (*cfmatch_t)(struct device *parent, void *child, void *aux);</pre>
<div class="spacer">
</div>
If <i class="farg">func</i> is <span class="define">NULL</span>, then the parent should record the return value from <b class="fname">config_search</b>() and call <b class="fname">config_attach</b>() itself.<div class="spacer">
</div>
Note that this function is designed so that it can be used to apply an arbitrary function to all potential children. In this case callers may choose to ignore the return value.</div>
<div class="section">
<h1 id="x44495245435420434f4e46494755524154494f4e">DIRECT CONFIGURATION</h1> <i class="ftype">struct device *</i><br/>
<b class="fname">config_found_sm</b>(<i class="farg" style="white-space:nowrap;">struct device *parent</i>, <i class="farg" style="white-space:nowrap;">void *aux</i>, <i class="farg" style="white-space:nowrap;">cfprint_t print</i>, <i class="farg" style="white-space:nowrap;">cfmatch_t submatch</i>);<div class="spacer">
</div>
<i class="ftype">struct device *</i><br/>
<b class="fname">config_found</b>(<i class="farg" style="white-space:nowrap;">struct device *parent</i>, <i class="farg" style="white-space:nowrap;">void *aux</i>, <i class="farg" style="white-space:nowrap;">cfprint_t print</i>);<div class="spacer">
</div>
<i class="ftype">struct device *</i><br/>
<b class="fname">config_rootfound</b>(<i class="farg" style="white-space:nowrap;">char *rootname</i>, <i class="farg" style="white-space:nowrap;">void *aux</i>);<div class="spacer">
</div>
The <b class="fname">config_found_sm</b>() function performs direct configuration on a physical device. <b class="fname">config_found_sm</b>() is called by the parent and in turn calls the <i class="farg">submatch</i> function to call the match function as determined by the configuration table. If <i class="farg">submatch</i> is <span class="define">NULL</span>, the driver match functions are called directly. The argument <i class="farg">parent</i> is the pointer to the parent's device structure. The given <i class="farg">aux</i> argument describes the device that has been found. The <span class="emph">softc</span> structure for the matched device will be allocated, and the appropriate driver attach function will be called.<div class="spacer">
</div>
If the device is matched, the system prints the name of the child and parent devices, and then calls the <i class="farg">print</i> function to produce additional information if desired. If no driver takes a match, the same <i class="farg">print</i> function is called to complain. The print function is called with the <i class="farg">aux</i> argument and, if the matches failed, the full name (including unit number) of the parent device, otherwise <span class="define">NULL</span>.<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
typedef int (*cfprint_t)(void *aux, const char *parentname); 
#define	QUIET	0		/* print nothing */ 
#define	UNCONF	1		/* print &quot; not configured&quot; */ 
#define	UNSUPP	2		/* print &quot; not supported&quot; */</pre>
<div class="spacer">
</div>
Two special strings, &#8220;not configured&#8221; and &#8220;unsupported&#8221; will be appended automatically to non-driver reports if the return value is <span class="define">UNCONF</span> or <span class="define">UNSUPP</span> respectively, otherwise the function should return the value <span class="define">QUIET</span>.<div class="spacer">
</div>
The <b class="fname">config_found_sm</b>() function returns a pointer to the attached device's <span class="emph">softc</span> structure if the device is attached, <span class="define">NULL</span> otherwise. Most callers can ignore this value, since the system will already have printed a diagnostic.<div class="spacer">
</div>
The <b class="fname">config_found</b>() macro expands to <b class="fname">config_found_sm</b>(<i class="farg">parent</i>, <i class="farg">aux</i>, <i class="farg">print</i>, <i class="farg">submatch</i>) with <i class="farg">submatch</i> set to <span class="define">NULL</span> and is provided for compatibility with older drivers.<div class="spacer">
</div>
The <b class="fname">config_rootfound</b>() function performs the same operation on the root device identified by the <i class="farg">rootname</i> string.</div>
<div class="section">
<h1 id="x434f4445205245464552454e434553">CODE REFERENCES</h1> The autoconfiguration framework itself is implemented within the file <i class="file">sys/kern/subr_autoconf.c</i>. Data structures and function prototypes for the framework are located in <i class="file">sys/sys/device.h</i>.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html4/autoconf.html">autoconf(4)</a>, <a class="link-man" href="../html5/files.conf.html">files.conf(5)</a>, <a class="link-man" href="../html8/config.html">config(8)</a>, <a class="link-man" href="../html9/config_attach.html">config_attach(9)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> Autoconfiguration first appeared in <span class="unix">4.1BSD</span>. The autoconfiguration framework was completely revised in <span class="unix">4.4BSD</span>.</div>
</div>
</body>
</html>

