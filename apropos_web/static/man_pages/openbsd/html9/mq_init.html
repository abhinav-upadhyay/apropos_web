<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
MQ_INIT(9)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">mq_init</b>, <b class="name">mq_enqueue</b>, <b class="name">mq_dequeue</b>, <b class="name">mq_enlist</b>, <b class="name">mq_delist</b>, <b class="name">mq_dechain</b>, <b class="name">mq_len</b>, <b class="name">mq_empty</b>, <b class="name">mq_purge</b>, <b class="name">mq_drops</b>, <b class="name">mq_set_maxlen</b>, <b class="name">MBUF_QUEUE_INITIALIZER</b> &#8212; <span class="desc">mbuf queue API</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/mbuf.h</a>&gt;</b><div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">mq_init</b>(<i class="farg" style="white-space:nowrap;">struct mbuf_queue *mq</i>, <i class="farg" style="white-space:nowrap;">unsigned int maxlen</i>, <i class="farg" style="white-space:nowrap;">int ipl</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">mq_enqueue</b>(<i class="farg" style="white-space:nowrap;">struct mbuf_queue *mq</i>, <i class="farg" style="white-space:nowrap;">struct mbuf *m</i>);<div class="spacer">
</div>
<i class="ftype">struct mbuf *</i><br/>
<b class="fname">mq_dequeue</b>(<i class="farg" style="white-space:nowrap;">struct mbuf_queue *mq</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">mq_enlist</b>(<i class="farg" style="white-space:nowrap;">struct mbuf_queue *mq</i>, <i class="farg" style="white-space:nowrap;">struct mbuf_list *ml</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">mq_delist</b>(<i class="farg" style="white-space:nowrap;">struct mbuf_queue *mq</i>, <i class="farg" style="white-space:nowrap;">struct mbuf_list *ml</i>);<div class="spacer">
</div>
<i class="ftype">struct mbuf *</i><br/>
<b class="fname">mq_dechain</b>(<i class="farg" style="white-space:nowrap;">struct mbuf_queue *mq</i>);<div class="spacer">
</div>
<i class="ftype">unsigned int</i><br/>
<b class="fname">mq_len</b>(<i class="farg" style="white-space:nowrap;">struct mbuf_queue *mq</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">mq_empty</b>(<i class="farg" style="white-space:nowrap;">struct mbuf_queue *mq</i>);<div class="spacer">
</div>
<i class="ftype">unsigned int</i><br/>
<b class="fname">mq_purge</b>(<i class="farg" style="white-space:nowrap;">struct mbuf_queue *mq</i>);<div class="spacer">
</div>
<i class="ftype">unsigned int</i><br/>
<b class="fname">mq_drops</b>(<i class="farg" style="white-space:nowrap;">struct mbuf_queue *mq</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">mq_set_maxlen</b>(<i class="farg" style="white-space:nowrap;">struct mbuf_queue *mq</i>, <i class="farg" style="white-space:nowrap;">unsigned int</i>);<div class="spacer">
</div>
<i class="ftype">struct mbuf_queue</i><br/>
<b class="fname">MBUF_QUEUE_INITIALIZER</b>(<i class="farg" style="white-space:nowrap;">unsigned int maxlen</i>, <i class="farg" style="white-space:nowrap;">int ipl</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The mbuf queue API provides implementions of data structures and operations for queueing mbufs and lists of mbufs between contexts.<div class="spacer">
</div>
mbuf_queue data structures provide a superset of the functionality available in mbuf_lists, and protect themselves internally with a <a class="link-man" href="../html9/mutex.html">mutex(9)</a>, making them useful for moving mbufs between contexts or subsystems. Additionally, mbuf_queues provide a limit on the number of mbufs that may be queued.<div class="spacer">
</div>
mbuf_queue structures support the following functionality:<div class="spacer">
</div>
<ol style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-enum">
<li class="list-enum" style="margin-top: 0.00em;">
Insertion of a new mbuf at the end of the queue.</li>
<li class="list-enum" style="margin-top: 0.00em;">
Removal of an mbuf from the head of the queue.</li>
<li class="list-enum" style="margin-top: 0.00em;">
Reinsertion of an mbuf at the head of the queue.</li>
<li class="list-enum" style="margin-top: 0.00em;">
Removal of the entire chain of mbufs on the queue.</li>
<li class="list-enum" style="margin-top: 0.00em;">
Insertion of the mbufs in an mbuf_list at the end of the queue.</li>
<li class="list-enum" style="margin-top: 0.00em;">
Removal of all the mbufs on the queue as an mbuf_list.</li>
</ol>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">mq_init</b>(<i class="farg">struct mbuf_queue *mq</i>, <i class="farg">unsigned int maxlen</i>, <i class="farg">int ipl</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Initialises the mbuf queue structure <i class="farg">mq</i>. The maximum number of mbufs that should be queued is specified with <i class="farg">maxlen</i>. The highest interrupt priority level the queue will be operated at is specified via <i class="farg">ipl</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">MBUF_QUEUE_INITIALIZER</b>(<i class="farg">unsigned int maxlen</i>, <i class="farg">int ipl</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Initialises an mbuf queue structure declaration. The maximum number of mbufs that should be queued is specified with <i class="farg">maxlen</i>. The highest interrupt priority level the queue will be operated at is specified via <i class="farg">ipl</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">mq_enqueue</b>(<i class="farg">struct mbuf_queue *mq</i>, <i class="farg">struct mbuf *m</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Enqueue mbuf <i class="farg">m</i> on the end of the <i class="farg">mq</i> mbuf queue.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">mq_dequeue</b>(<i class="farg">struct mbuf_queue *mq</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Dequeue an mbuf from the front of the <i class="farg">mq</i> mbuf queue.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">mq_enlist</b>(<i class="farg">struct mbuf_queue *mq</i>, <i class="farg">struct mbuf_list *ml</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Enqueue all the mbufs on the <i class="farg">ml</i> mbuf list on to the end of the <i class="farg">mq</i> mbuf queue. Note, the number of mbufs placed on the queue may exceed its maximum length.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">mq_delist</b>(<i class="farg">struct mbuf_queue *mq</i>, <i class="farg">struct mbuf_list *ml</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Dequeue all the mbufs on the <i class="farg">mq</i> mbuf queue on to the <i class="farg">ml</i> mbuf list.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">mq_dechain</b>(<i class="farg">struct mbuf_queue *mq</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Dequeue all mbufs from the <i class="farg">mq</i> mbuf queue.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">mq_len</b>(<i class="farg">struct mbuf_queue *mq</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Return the number of mbufs on the <i class="farg">mq</i> mbuf queue.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">mq_empty</b>(<i class="farg">struct mbuf_queue *mq</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Return if the <i class="farg">mq</i> mbuf queue is empty.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">mq_purge</b>(<i class="farg">struct mbuf_queue *mq</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Free all the mbufs on the <i class="farg">mq</i> mbuf queue.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">mq_drops</b>(<i class="farg">struct mbuf_queue *mq</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Return how many mbufs were dropped and freed by <a class="link-man" href="../html9/m_freem.html">m_freem(9)</a> if the <i class="farg">mq</i> mbuf queue was too full.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">mq_set_maxlen</b>(<i class="farg">struct mbuf_queue *mq</i>, <i class="farg">unsigned int</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Alter the maximum number of mbufs that should be queued on the <i class="farg">mq</i> mbuf queue. Note, <b class="fname">mq_set_maxlen</b>() will only set a new limit, it will not free any excess mbufs that may already exist on the queue.</dd>
</dl>
</div>
<div class="section">
<h1 id="x434f4e54455854">CONTEXT</h1> <b class="fname">mq_init</b>(), <b class="fname">mq_enqueue</b>(), <b class="fname">mq_dequeue</b>(), <b class="fname">mq_enlist</b>(), <b class="fname">mq_delist</b>(), <b class="fname">mq_dechain</b>(), <b class="fname">mq_len</b>(), <b class="fname">mq_empty</b>(), <b class="fname">mq_purge</b>(), <b class="fname">mq_drops</b>(), <b class="fname">mq_set_maxlen</b>(), and <b class="fname">MBUF_QUEUE_INITIALIZER</b>() can be called during autoconf, from process context, or from interrupt context.</div>
<div class="section">
<h1 id="x52455455524e2056414c554553">RETURN VALUES</h1> <b class="fname">mq_dequeue</b>() returns the mbuf that was at the head of its queue. If the queue was empty, <span class="define">NULL</span> is returned.<div class="spacer">
</div>
<b class="fname">mq_dechain</b>() returns all the mbufs that were on its queues via a pointer to an mbuf with the chain accessible via m_nextpkt members. If the queue was empty, <span class="define">NULL</span> is returned.<div class="spacer">
</div>
<b class="fname">mq_len</b>() returns the number of mbufs on the queue.<div class="spacer">
</div>
<b class="fname">mq_empty</b>() returns a non-zero value if the queue is empty, otherwise 0.<div class="spacer">
</div>
<b class="fname">mq_enqueue</b>() returns 0 if the mbuf was successfully queued, or non-zero if the mbuf was freed because it would cause the queue to exceed its maximum length.<div class="spacer">
</div>
<b class="fname">mq_enlist</b>() returns the number of mbufs that were dropped from the list if the length of the queue exceeded its maximum length.<div class="spacer">
</div>
<b class="fname">mq_purge</b>() returns the number of mbufs that were freed.<div class="spacer">
</div>
<b class="fname">mq_drops</b>() returns the number of mbufs that were freed during <b class="fname">mq_enqueue</b>() operations that would have caused the queue to exceed its maximum length.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html9/mbuf.html">mbuf(9)</a>, <a class="link-man" href="../html9/ml_init.html">ml_init(9)</a>, <a class="link-man" href="../html9/mutex.html">mutex(9)</a></div>
</div>
</body>
</html>

