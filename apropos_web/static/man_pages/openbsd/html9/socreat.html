<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
SOCREATE(9)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">sobind</b>, <b class="name">soclose</b>, <b class="name">soconnect</b>, <b class="name">socreate</b>, <b class="name">soreceive</b>, <b class="name">sosetopt</b>, <b class="name">sogetopt</b>, <b class="name">sosend</b>, <b class="name">soshutdown</b> &#8212; <span class="desc">kernel socket interface</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/socket.h</a>&gt;</b><br/>
<b class="includes">#include &lt;<a class="link-includes">sys/socketvar.h</a>&gt;</b><div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">sobind</b>(<i class="farg" style="white-space:nowrap;">struct socket *so</i>, <i class="farg" style="white-space:nowrap;">struct mbuf *nam</i>, <i class="farg" style="white-space:nowrap;">struct proc *p</i>);<div class="spacer">
</div>
<i class="ftype">void</i><br/>
<b class="fname">soclose</b>(<i class="farg" style="white-space:nowrap;">struct socket *so</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">soconnect</b>(<i class="farg" style="white-space:nowrap;">struct socket *so</i>, <i class="farg" style="white-space:nowrap;">struct mbuf *nam</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">socreate</b>(<i class="farg">int dom</i>, <i class="farg">struct socket **aso</i>, <i class="farg">int type</i>, <i class="farg">int proto</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">soreceive</b>(<i class="farg">struct socket *so</i>, <i class="farg">struct mbuf **paddr</i>, <i class="farg">struct uio *uio</i>, <i class="farg">struct mbuf **mp0</i>, <i class="farg">struct mbuf **controlp</i>, <i class="farg">int *flagsp</i>, <i class="farg">socklen_t controllen</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">sosetopt</b>(<i class="farg" style="white-space:nowrap;">struct socket *so</i>, <i class="farg" style="white-space:nowrap;">int level</i>, <i class="farg" style="white-space:nowrap;">int optname</i>, <i class="farg" style="white-space:nowrap;">struct mbuf *m0</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">sogetopt</b>(<i class="farg" style="white-space:nowrap;">struct socket *so</i>, <i class="farg" style="white-space:nowrap;">int level</i>, <i class="farg" style="white-space:nowrap;">int optname</i>, <i class="farg" style="white-space:nowrap;">struct mbuf **mp</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">sosend</b>(<i class="farg">struct socket *so</i>, <i class="farg">struct mbuf *addr</i>, <i class="farg">struct uio *uio</i>, <i class="farg">struct mbuf *top</i>, <i class="farg">struct mbuf *control</i>, <i class="farg">int flags</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">soshutdown</b>(<i class="farg" style="white-space:nowrap;">struct socket *so</i>, <i class="farg" style="white-space:nowrap;">int how</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The kernel socket programming interface permits in-kernel consumers to interact with local and network socket objects in a manner similar to that permitted using the <a class="link-man" href="../html2/socket.html">socket(2)</a> user API. These interfaces are appropriate for use by distributed file systems and other network-aware kernel services. While the user API operates on file descriptors, the kernel interfaces operate directly on <span class="type">struct socket</span> pointers.<div class="spacer">
</div>
Except where otherwise indicated, <b class="name">sobind</b> functions may sleep.<div class="subsection">
<h2 id="x4372656174696e6720616e642044657374726f79696e6720536f636b657473">Creating and Destroying Sockets</h2> A new socket may be created using <b class="fname">socreate</b>(). As with <a class="link-man" href="../html2/socket.html">socket(2)</a>, arguments specify the requested domain, type, and protocol via <i class="farg">dom</i>, <i class="farg">type</i>, and <i class="farg">proto</i>. The socket is returned via <i class="farg">aso</i> on success. <span class="emph">Warning</span>: authorization of the socket creation operation will be performed using <span class="define">curproc</span> for some protocols (such as raw sockets).<div class="spacer">
</div>
Sockets may be closed and freed using <b class="fname">soclose</b>(), which has similar semantics to <a class="link-man" href="../html2/close.html">close(2)</a>.</div>
<div class="subsection">
<h2 id="x436f6e6e656374696f6e7320616e6420416464726573736573">Connections and Addresses</h2> The <b class="fname">sobind</b>() function is equivalent to the <a class="link-man" href="../html2/bind.html">bind(2)</a> system call, and binds the socket <i class="farg">so</i> to the address <i class="farg">nam</i>. The operation would be authorized using the credential on process <i class="farg">p</i>.<div class="spacer">
</div>
The <b class="fname">soconnect</b>() function is equivalent to the <a class="link-man" href="../html2/connect.html">connect(2)</a> system call, and initiates a connection on the socket <i class="farg">so</i> to the address <i class="farg">nam</i>. The operation will be authorized using the credential on <span class="define">curproc</span>. Unlike the user system call, <b class="fname">soconnect</b>() returns immediately; the caller may <a class="link-man" href="../html9/tsleep.html">tsleep(9)</a> on <i class="farg">so-&gt;so_timeo</i> and wait for the <span class="define">SS_ISCONNECTING</span> flag to clear or <i class="farg">so-&gt;so_error</i> to become non-zero. If <b class="fname">soconnect</b>() fails, the caller must manually clear the <span class="define">SS_ISCONNECTING</span> flag.<div class="spacer">
</div>
The <b class="fname">soshutdown</b>() function is equivalent to the <a class="link-man" href="../html2/shutdown.html">shutdown(2)</a> system call, and causes part or all of a connection on a socket to be closed down.</div>
<div class="subsection">
<h2 id="x536f636b6574204f7074696f6e73">Socket Options</h2> The <b class="fname">sogetopt</b>() function is equivalent to the <a class="link-man" href="../html2/getsockopt.html">getsockopt(2)</a> system call, and retrieves a socket option on socket <i class="farg">so</i>. The <b class="fname">sosetopt</b>() function is equivalent to the <a class="link-man" href="../html2/setsockopt.html">setsockopt(2)</a> system call, and sets a socket option on socket <i class="farg">so</i>.<div class="spacer">
</div>
The next two arguments in both <b class="fname">sogetopt</b>() and <b class="fname">sosetopt</b>() are <i class="farg">level</i> and <i class="farg">optname</i> describing the protocol level and socket option. The last argument is either a pointer to a prefilled mbuf <i class="farg">m0</i> or a pointer to a mbuf pointer <i class="farg">mp</i> which will point to the retrieved data.</div>
<div class="subsection">
<h2 id="x536f636b657420492f4f">Socket I/O</h2> The <b class="fname">soreceive</b>() function is equivalent to the <a class="link-man" href="../html2/recvmsg.html">recvmsg(2)</a> system call, and attempts to receive bytes of data from the socket <i class="farg">so</i>, optionally blocking and awaiting data if none is ready to read. Data may be retrieved directly to kernel or user memory via the <i class="farg">uio</i> argument, or as an mbuf chain returned to the caller via <i class="farg">mp0</i>, avoiding a data copy. If <i class="farg">mp0</i> is not <span class="define">NULL</span>, <i class="farg">uio</i> must still be passed with uio_resid set to specify the maximum amount of data to be returned to the caller via an mbuf chain. The caller may optionally retrieve a socket address on a protocol with the <span class="define">PR_ADDR</span> capability by providing storage via a non-<span class="define">NULL</span> <i class="farg">paddr</i> argument. The caller may optionally retrieve up to <i class="farg">controllen</i> bytes of control data in mbufs via a non-<span class="define">NULL</span> <i class="farg">controlp</i> argument. Optional flags may be passed to <b class="fname">soreceive</b>() via a non-<span class="define">NULL</span> <i class="farg">flagsp</i> argument, and use the same flag name space as the <a class="link-man" href="../html2/recvmsg.html">recvmsg(2)</a> system call.<div class="spacer">
</div>
The <b class="fname">sosend</b>() function is equivalent to the <a class="link-man" href="../html2/sendmsg.html">sendmsg(2)</a> system call, and attempts to send bytes of data via the socket <i class="farg">so</i>, optionally blocking if data cannot be immediately sent. Data may be sent directly from kernel or user memory via the <i class="farg">uio</i> argument, or as an mbuf chain via <i class="farg">top</i>, avoiding a data copy. Only one of the <i class="farg">uio</i> or <i class="farg">top</i> pointers may be non-<span class="define">NULL</span>. An optional destination address may be specified via a non-<span class="define">NULL</span> <i class="farg">addr</i> argument, which may result in an implicit connect if supported by the protocol. The caller may optionally send control data mbufs via a non-<span class="define">NULL</span> <i class="farg">control</i> argument. Flags may be passed to <b class="fname">sosend</b>() using the <i class="farg">flags</i> argument, and use the same flag name space as the <a class="link-man" href="../html2/sendmsg.html">sendmsg(2)</a> system call.<div class="spacer">
</div>
Kernel callers running in interrupt context, or with a mutex held, will wish to use non-blocking sockets and pass the <span class="define">MSG_DONTWAIT</span> flag in order to prevent these functions from sleeping.</div>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html2/bind.html">bind(2)</a>, <a class="link-man" href="../html2/close.html">close(2)</a>, <a class="link-man" href="../html2/connect.html">connect(2)</a>, <a class="link-man" href="../html2/getsockopt.html">getsockopt(2)</a>, <a class="link-man" href="../html2/recv.html">recv(2)</a>, <a class="link-man" href="../html2/send.html">send(2)</a>, <a class="link-man" href="../html2/setsockopt.html">setsockopt(2)</a>, <a class="link-man" href="../html2/shutdown.html">shutdown(2)</a>, <a class="link-man" href="../html2/socket.html">socket(2)</a>, <a class="link-man" href="../html9/tsleep.html">tsleep(9)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The <a class="link-man" href="../html2/socket.html">socket(2)</a> system call appeared in <span class="unix">4.2BSD</span>. This manual page was introduced in <span class="unix">FreeBSD&#160;7.0</span> and ported to <span class="unix">OpenBSD&#160;4.5</span>.</div>
<div class="section">
<h1 id="x415554484f5253">AUTHORS</h1> This manual page was written by <span class="author">Robert Watson</span>.</div>
<div class="section">
<h1 id="x42554753">BUGS</h1> The use of credentials hung from explicitly passed processes, and the credential on <span class="define">curproc</span>, and the cached credential from socket creation time is inconsistent, and may lead to unexpected behaviour.<div class="spacer">
</div>
The caller may need to manually clear <span class="define">SS_ISCONNECTING</span> if <b class="fname">soconnect</b>() returns an error.<div class="spacer">
</div>
The <span class="define">MSG_DONTWAIT</span> flag is not implemented for <b class="fname">sosend</b>().<div class="spacer">
</div>
This manual page does not describe how to register socket upcalls or monitor a socket for readability/writability without using blocking I/O.</div>
</div>
</body>
</html>

