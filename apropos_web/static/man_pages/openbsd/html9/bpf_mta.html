<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
BPF_MTAP(9)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">bpf_filter</b>, <b class="name">bpf_mfilter</b>, <b class="name">bpf_validate</b>, <b class="name">bpf_tap</b>, <b class="name">bpf_mtap</b>, <b class="name">bpf_mtap_hdr</b>, <b class="name">bpf_mtap_af</b>, <b class="name">bpf_mtap_ether</b> &#8212; <span class="desc">BPF kernel API</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">net/bpf.h</a>&gt;</b><div class="spacer">
</div>
<i class="ftype">u_int</i><br/>
<b class="fname">bpf_filter</b>(<i class="farg">const struct bpf_insn *pc</i>, <i class="farg">const u_char *pkt</i>, <i class="farg">u_int wirelen</i>, <i class="farg">u_int pktlen</i>);<div class="spacer">
</div>
<i class="ftype">u_int</i><br/>
<b class="fname">bpf_mfilter</b>(<i class="farg">const struct bpf_insn *pc</i>, <i class="farg">const struct mbuf *m</i>, <i class="farg">u_int wirelen</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">bpf_validate</b>(<i class="farg" style="white-space:nowrap;">struct bpf_insn *pc</i>, <i class="farg" style="white-space:nowrap;">int len</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">bpf_tap</b>(<i class="farg" style="white-space:nowrap;">caddr_t bpf</i>, <i class="farg" style="white-space:nowrap;">u_char *pkt</i>, <i class="farg" style="white-space:nowrap;">u_int pktlen</i>, <i class="farg" style="white-space:nowrap;">u_int direction</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">bpf_mtap</b>(<i class="farg" style="white-space:nowrap;">caddr_t bpf</i>, <i class="farg" style="white-space:nowrap;">const struct mbuf *m</i>, <i class="farg" style="white-space:nowrap;">u_int direction</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">bpf_mtap_hdr</b>(<i class="farg">caddr_t bpf</i>, <i class="farg">caddr_t hdr</i>, <i class="farg">u_int hdrlen</i>, <i class="farg">const struct mbuf *m</i>, <i class="farg">u_int direction</i>, <i class="farg">void (*cpfn)(const void *, void *, size_t)</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">bpf_mtap_af</b>(<i class="farg">caddr_t bpf</i>, <i class="farg">u_int32_t af</i>, <i class="farg">const struct mbuf *m</i>, <i class="farg">u_int direction</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">bpf_mtap_ether</b>(<i class="farg" style="white-space:nowrap;">caddr_t bpf</i>, <i class="farg" style="white-space:nowrap;">const struct mbuf *m</i>, <i class="farg" style="white-space:nowrap;">u_int direction</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The BPF kernel API provides functions for evaluating BPF instructions against packets, and incoming linkage from device drivers. A packet is parsed by the filters associated with each interface and, if accepted, stashed into the corresponding buffer.<div class="spacer">
</div>
<b class="fname">bpf_filter</b>() executes the BPF program referenced by <i class="farg">pc</i> against the packet buffer starting at <i class="farg">pkt</i> of <i class="farg">pktlen</i> bytes in length. <i class="farg">wirelen</i> is the length of the original packet on the wire.<div class="spacer">
</div>
<b class="fname">bpf_mfilter</b>() executes the BPF program referenced by <i class="farg">pc</i> against the packet in the mbuf <i class="farg">m</i>. <i class="farg">wirelen</i> is the length of the original packet on the wire.<div class="spacer">
</div>
<b class="fname">bpf_validate</b>() tests if the BPF program referenced by <i class="farg">pc</i> is valid. <i class="farg">len</i> specifies the number of instructions in <i class="farg">pc</i>.<div class="spacer">
</div>
<b class="fname">bfp_tap</b>() runs the filters on the BPF interface referenced by <i class="farg">bpf</i> in the direction <i class="farg">direction</i> against the packet in the <i class="farg">pkt</i> buffer.<div class="spacer">
</div>
<b class="fname">bfp_mtap</b>() runs the filters on the BPF interface referenced by <i class="farg">bpf</i> in the direction <i class="farg">direction</i> against the packet in mbuf chain <i class="farg">m</i>.<div class="spacer">
</div>
<b class="fname">bfp_mtap_hdr</b>() runs the filters on the BPF interface referenced by <i class="farg">bpf</i> in the direction <i class="farg">direction</i> against the packet in mbuf chain <i class="farg">m</i>. The header referenced by <i class="farg">hdr</i> will be prefixed to the packet during filter evaluation. A custom packet copy function may be provided via <i class="farg">cpfn</i>. If <i class="farg">cpfn</i> is <span class="define">NULL</span> an internal function for copying mbuf payloads will be used.<div class="spacer">
</div>
<b class="fname">bpf_mtap_af</b>() runs the filters on the BPF interface referenced by <i class="farg">bpf</i> in the direction <i class="farg">direction</i> against the packet in mbuf chain <i class="farg">m</i>. The address family specified by <i class="farg">af</i> will be prepended to the packet before matching occurs.<div class="spacer">
</div>
<b class="fname">bpf_mtap_ether</b>() runs the filters on the BPF interface referenced by <i class="farg">bpf</i> in the direction <i class="farg">direction</i> against an Ethernet packet in the mbuf <i class="farg">m</i>. If the mbuf is flagged with <span class="define">M_VLANTAG</span> an Ethernet VLAN header is constructed using m-&gt;m_pkthdr.ether_vtag and m-&gt;m_pkthdr.pf.prio before matching occurs.</div>
<div class="section">
<h1 id="x434f4e54455854">CONTEXT</h1> <b class="fname">bpf_filter</b>(), <b class="fname">bpf_mfilter</b>(), and <b class="fname">bpf_validate</b>() can be called from process context, or from an interrupt context.<div class="spacer">
</div>
<b class="fname">bpf_mtap</b>(), <b class="fname">bpf_tap</b>(), <b class="fname">bpf_mtap</b>(), <b class="fname">bpf_mtap_hdr</b>(), <b class="fname">bpf_mtap_af</b>(), and <b class="fname">bpf_mtap_ether</b>() can be called from process context, or from an interrupt context at or below <span class="define">IPL_NET</span>.</div>
<div class="section">
<h1 id="x52455455524e2056414c554553">RETURN VALUES</h1> <b class="fname">bpf_filter</b>(), and <b class="fname">bpf_mfilter</b>() return -1 (cast to an unsigned integer) if the filter program is <span class="define">NULL</span>, or the result of the filter program. Filter programs should return the maximum number of bytes of the packet to capture, or 0 if the packet does not match the filter program.<div class="spacer">
</div>
<b class="fname">bpf_validate</b>() returns a non-zero value if the BPF program is valid, otherwise 0.<div class="spacer">
</div>
<b class="fname">bpf_tap</b>(), <b class="fname">bpf_mtap</b>(), <b class="fname">bpf_mtap_hdr</b>(), <b class="fname">bpf_mtap_af</b>(), and <b class="fname">bpf_mtap_ether</b>() return 1 if the packet matched a filter that indicates the packet should be dropped, otherwise 0.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html9/mbuf.html">mbuf(9)</a>, <a class="link-man" href="../html9/spl.html">spl(9)</a></div>
</div>
</body>
</html>

