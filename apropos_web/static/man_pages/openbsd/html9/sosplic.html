<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
SOSPLICE(9)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">sosplice</b>, <b class="name">somove</b> &#8212; <span class="desc">splice two sockets for zero-copy data transfer</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <i class="ftype">int</i><br/>
<b class="fname">sosplice</b>(<i class="farg" style="white-space:nowrap;">struct socket *so</i>, <i class="farg" style="white-space:nowrap;">int fd</i>, <i class="farg" style="white-space:nowrap;">off_t max</i>, <i class="farg" style="white-space:nowrap;">struct timeval *tv</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">somove</b>(<i class="farg" style="white-space:nowrap;">struct socket *so</i>, <i class="farg" style="white-space:nowrap;">int wait</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The function <b class="fname">sosplice</b>() is used to splice together a source and a drain socket. The source socket is passed as the <i class="farg">so</i> argument; the file descriptor of the drain is passed in <i class="farg">fd</i>. If <i class="farg">fd</i> is negative, an existing splicing gets dissolved. If <i class="farg">max</i> is positive, at most that many bytes will get transferred. If <i class="farg">tv</i> is not NULL, a <a class="link-man" href="../html9/timeout.html">timeout(9)</a> is scheduled to dissolve splicing in the case when no data can be transferred for the specified period of time. Socket splicing can be invoked from userland via the <a class="link-man" href="../html2/setsockopt.html">setsockopt(2)</a> system-call at the <span class="define">SOL_SOCKET</span> level with the socket option <span class="define">SO_SPLICE</span>.<div class="spacer">
</div>
Before connecting both sockets, several checks are executed. See the <i class="link-sec"><a class="link-sec" href="#x4552524f5253">ERRORS</a></i> section for possible failures. The connection between both sockets is implemented by setting these additional fields in <span class="type">struct socket</span>:<div class="spacer">
</div>
<ul style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-dash">
<li class="list-dash" style="margin-top: 0.00em;">
<span class="type">struct socket</span> <i class="farg">*so_splice</i> links from the source to the drain socket.</li>
<li class="list-dash" style="margin-top: 0.00em;">
<span class="type">struct socket</span> <i class="farg">*so_spliceback</i> links back from the drain to the source socket.</li>
<li class="list-dash" style="margin-top: 0.00em;">
<span class="type">off_t</span> <i class="farg">so_splicelen</i> counts the number of bytes spliced so far from this socket.</li>
<li class="list-dash" style="margin-top: 0.00em;">
<span class="type">off_t</span> <i class="farg">so_splicemax</i> specifies the maximum number of bytes to splice from this socket if non-zero.</li>
<li class="list-dash" style="margin-top: 0.00em;">
<span class="type">struct timeval</span> <i class="farg">so_idletv</i> specifies the maximum idle time if non-zero.</li>
<li class="list-dash" style="margin-top: 0.00em;">
<span class="type">struct timeout</span> <i class="farg">so_idleto</i> provides storage for the kernel timeout if idle time is used.</li>
</ul>
<div class="spacer">
</div>
After connecting both sockets, <b class="fname">sosplice</b>() calls <b class="fname">somove</b>() to transfer the mbufs already in the source receive buffer to the drain send buffer. Finally the socket buffer flag <span class="define">SB_SPLICE</span> is set on both socket buffers, to indicate that the protocol layer has to call <b class="fname">somove</b>() whenever data or space is available.<div class="spacer">
</div>
The function <b class="fname">somove</b>() transfers data from the source's receive buffer to the drain's send buffer. It must be called at <a class="link-man" href="../html9/splsoftnet.html">splsoftnet(9)</a> and <i class="farg">so</i> must be a spliced drain socket. It may be necessary to split an mbuf to handle out-of-band data inline or when the maximum splice length has been reached. If <i class="farg">wait</i> is <span class="define">M_WAIT</span>, splitting mbufs will always succeed. For <span class="define">M_DONTWAIT</span> the out-of-band property might get lost or a short splice might happen. In the latter case, less than the given maximum number of bytes are transferred and userland has to cope with this. Note that a short splice cannot happen if <b class="fname">somove</b>() was called by <b class="fname">sosplice</b>(). So a second <a class="link-man" href="../html2/setsockopt.html">setsockopt(2)</a> after a short splice pointing to the same maximum will always succeed.<div class="spacer">
</div>
Before transferring data, <b class="fname">somove</b>() checks both sockets for errors and that the drain socket is connected. If the drain cannot send anymore, an <span class="errno">EPIPE</span> error is set on the source socket. The data length to move is limited by the optional maximum splice length and the space in the drain's send socket buffer. Up to this amount of data is taken out of the source's receive socket buffer.<div class="spacer">
</div>
For atomic protocols, either one complete packet is taken out, or nothing is taken at all if: the packet is bigger than the drain's send buffer size, in which case the splicing gets aborted with an <span class="errno">EMSGSIZE</span> error; the packet does not fit into the drain's current send buffer space, in which case it is left in the source's receive buffer for later processing; or the maximum splice length is located within a packet, in which case splicing gets dissolved like a short splice. All address or control mbufs associated with the taken packet are dropped.<div class="spacer">
</div>
If the maximum splice length has been reached, an mbuf may get split for non-atomic protocols. Otherwise an mbuf is either moved completely to the send buffer or left in the receive buffer for later processing. If SO_OOBINLINE is set, out-of-band data will get moved as such although this might not be reliable. The data is sent out to the drain socket via the protocol function. If that fails and the drain socket cannot send anymore, an <span class="errno">EPIPE</span> error is set on the source socket.<div class="spacer">
</div>
For packet oriented protocols <b class="fname">somove</b>() iterates over the next packet queue.<div class="spacer">
</div>
If a maximum splice length was specified and at least this amount of data has been received from the drain socket, splicing gets dissolved. In this case, an <span class="errno">EFBIG</span> error is set on the source socket if the maximum amount of data has been transferred. Userland can process this error to distinguish the full splice from a short splice or to react to the completed maximum splice immediately. If an idle timeout was specified and no data has been transferred for that period of time, the handler <b class="fname">soidle</b>() dissolves splicing and sets an <span class="errno">ETIMEDOUT</span> error on the source socket.<div class="spacer">
</div>
The function <b class="fname">sounsplice</b>() is called to dissolve the socket splicing if the source socket cannot receive anymore and its receive buffer is empty; or if the drain socket cannot send anymore; or if the maximum has been reached; or if an error occurred; or if the idle timeout has fired.<div class="spacer">
</div>
If the socket buffer flag <span class="define">SB_SPLICE</span> is set, the functions <b class="fname">sorwakeup</b>() and <b class="fname">sowwakeup</b>() will call <b class="fname">somove</b>() to trigger the transfer when new data or buffer space is available. While socket splicing is active, any <a class="link-man" href="../html2/read.html">read(2)</a> from the source socket will block and the wakeup will not be delivered to the file descriptor. A read event or a socket error is signaled to userland after dissolving.</div>
<div class="section">
<h1 id="x52455455524e2056414c554553">RETURN VALUES</h1> <b class="fname">sosplice</b>() returns 0 on success and otherwise the error number. <b class="fname">somove</b>() returns 0 if socket splicing has been finished and 1 if it continues.</div>
<div class="section">
<h1 id="x4552524f5253">ERRORS</h1> <b class="fname">sosplice</b>() will succeed unless:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
[<span class="errno">EBADF</span>]</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
The given file descriptor <i class="farg">fd</i> is not an active descriptor.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
[<span class="errno">EBUSY</span>]</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
The source or the drain socket is already spliced.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
[<span class="errno">EINVAL</span>]</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
The given maximum value <i class="farg">max</i> is negative.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
[<span class="errno">ENOTCONN</span>]</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
The source socket requires a connection and is neither connected nor in the process of connecting to a peer.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
[<span class="errno">ENOTCONN</span>]</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
The drain socket is neither connected nor in the process of connecting to a peer.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
[<span class="errno">ENOTSOCK</span>]</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
The given file descriptor <i class="farg">fd</i> is not a socket.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
[<span class="errno">EOPNOTSUPP</span>]</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
The source or the drain socket is a listen socket.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
[<span class="errno">EPROTONOSUPPORT</span>]</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
The source socket's protocol layer does not have the <span class="define">PR_SPLICE</span> flag set. Only TCP and UDP socket splicing is supported.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
[<span class="errno">EPROTONOSUPPORT</span>]</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
The drain socket's protocol does not have the same <i class="farg">pr_usrreq</i> function as the source.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
[<span class="errno">EWOULDBLOCK</span>]</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
The source socket is non-blocking and the receive buffer is already locked.</dd>
</dl>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html2/setsockopt.html">setsockopt(2)</a>, <a class="link-man" href="../html4/options.html">options(4)</a>, <a class="link-man" href="../html9/timeout.html">timeout(9)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> Socket splicing for TCP first appeared in <span class="unix">OpenBSD&#160;4.9</span>; support for UDP was added in <span class="unix">OpenBSD&#160;5.3</span>.</div>
<div class="section">
<h1 id="x415554484f5253">AUTHORS</h1> The idea for socket splicing originally came from <span class="author">Markus Friedl</span> &lt;<a class="link-mail" href="mailto:markus@openbsd.org">markus@openbsd.org</a>&gt;, and <span class="author">Alexander Bluhm</span> &lt;<a class="link-mail" href="mailto:bluhm@openbsd.org">bluhm@openbsd.org</a>&gt; implemented it. <span class="author">Mike Belopuhov</span> &lt;<a class="link-mail" href="mailto:mikeb@openbsd.org">mikeb@openbsd.org</a>&gt; added the timeout feature.</div>
</div>
</body>
</html>

