<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
PF.CONF(5)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">pf.conf</b> &#8212; <span class="desc">packet filter configuration file</span></div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <a class="link-man" href="../html4/pf.html">pf(4)</a> packet filter modifies, drops, or passes packets according to rules or definitions specified in <b class="name">pf.conf</b>.<div class="spacer">
</div>
This is an overview of the sections in this manual page:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-inset">
<dt class="list-inset" style="margin-top: 1.00em;">
<i class="link-sec"><a class="link-sec" href="#x5041434b45542046494c544552494e47">PACKET FILTERING</a></i></dt>
<dd class="list-inset">
including network address translation (NAT).</dd>
<dt class="list-inset" style="margin-top: 1.00em;">
<i class="link-sec"><a class="link-sec" href="#x4f5054494f4e53">OPTIONS</a></i></dt>
<dd class="list-inset">
globally tune the behaviour of the packet filtering engine.</dd>
<dt class="list-inset" style="margin-top: 1.00em;">
<i class="link-sec"><a class="link-sec" href="#x5155455545494e47">QUEUEING</a></i></dt>
<dd class="list-inset">
provides rule-based bandwidth control.</dd>
<dt class="list-inset" style="margin-top: 1.00em;">
<i class="link-sec"><a class="link-sec" href="#x5441424c4553">TABLES</a></i></dt>
<dd class="list-inset">
provide a method for dealing with large numbers of addresses.</dd>
<dt class="list-inset" style="margin-top: 1.00em;">
<i class="link-sec"><a class="link-sec" href="#x414e43484f5253">ANCHORS</a></i></dt>
<dd class="list-inset">
are containers for rules and tables.</dd>
<dt class="list-inset" style="margin-top: 1.00em;">
<i class="link-sec"><a class="link-sec" href="#x535441544546554c2046494c544552494e47">STATEFUL FILTERING</a></i></dt>
<dd class="list-inset">
tracks packets by state.</dd>
<dt class="list-inset" style="margin-top: 1.00em;">
<i class="link-sec"><a class="link-sec" href="#x54524146464943204e4f524d414c49534154494f4e">TRAFFIC NORMALISATION</a></i></dt>
<dd class="list-inset">
includes scrub, fragment handling, and blocking spoofed traffic.</dd>
<dt class="list-inset" style="margin-top: 1.00em;">
<i class="link-sec"><a class="link-sec" href="#x4f5045524154494e472053595354454d2046494e4745525052494e54494e47">OPERATING SYSTEM FINGERPRINTING</a></i></dt>
<dd class="list-inset">
is a method for detecting a host's operating system.</dd>
<dt class="list-inset" style="margin-top: 1.00em;">
<i class="link-sec"><a class="link-sec" href="#x4558414d504c4553">EXAMPLES</a></i></dt>
<dd class="list-inset">
provides some example rulesets.</dd>
<dt class="list-inset" style="margin-top: 1.00em;">
<i class="link-sec"><a class="link-sec" href="#x4752414d4d4152">GRAMMAR</a></i></dt>
<dd class="list-inset">
provides a complete BNF grammar reference.</dd>
</dl>
<div class="spacer">
</div>
The current line can be extended over multiple lines using a backslash (&#8216;\&#8217;). Comments can be put anywhere in the file using a hash mark (&#8216;#&#8217;), and extend to the end of the current line. Care should be taken when commenting out multi-line text: the comment is effective until the end of the entire block.<div class="spacer">
</div>
Argument names not beginning with a letter, digit, or underscore must be quoted.<div class="spacer">
</div>
Additional configuration files can be included with the <b class="cmd">include</b> keyword, for example:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
include &quot;/etc/pf/sub.filter.conf&quot;</pre>
<div class="spacer">
</div>
Macros can be defined that will later be expanded in context. Macro names must start with a letter, digit, or underscore, and may contain any of those characters. Macro names may not be reserved words (for example <b class="cmd">pass</b>, <b class="flag">in</b>, <b class="flag">out</b>). Macros are not expanded inside quotes.<div class="spacer">
</div>
For example:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
ext_if = &quot;kue0&quot; 
all_ifs = &quot;{&quot; $ext_if lo0 &quot;}&quot; 
pass out on $ext_if from any to any 
pass in  on $ext_if proto tcp from any to any port 25</pre>
</div>
<div class="section">
<h1 id="x5041434b45542046494c544552494e47">PACKET FILTERING</h1> <a class="link-man" href="../html4/pf.html">pf(4)</a> has the ability to <b class="cmd">block</b>, <b class="cmd">pass</b>, and <b class="cmd">match</b> packets based on attributes of their layer 3 and layer 4 headers. Filter rules determine which of these actions are taken; filter parameters specify the packets to which a rule applies.<div class="spacer">
</div>
For each packet processed by the packet filter, the filter rules are evaluated in sequential order, from first to last. For <b class="cmd">block</b> and <b class="cmd">pass</b>, the last matching rule decides what action is taken; if no rule matches the packet, the default action is to pass the packet without creating a state. For <b class="cmd">match</b>, rules are evaluated every time they match; the pass/block state of a packet remains unchanged.<div class="spacer">
</div>
Most parameters are optional. If a parameter is specified, the rule only applies to packets with matching attributes. Certain parameters can be expressed as lists, in which case <a class="link-man" href="../html8/pfctl.html">pfctl(8)</a> generates all needed rule combinations.<div class="spacer">
</div>
By default <a class="link-man" href="../html4/pf.html">pf(4)</a> filters packets statefully: the first time a packet matches a <b class="cmd">pass</b> rule, a state entry is created. The packet filter examines each packet to see if it matches an existing state. If it does, the packet is passed without evaluation of any rules. After the connection is closed or times out, the state entry is automatically removed.<div class="spacer">
</div>
The following actions can be used in the filter:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="cmd">block</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The packet is blocked. There are a number of ways in which a <b class="cmd">block</b> rule can behave when blocking a packet. The default behaviour is to <b class="flag">drop</b> packets silently, however this can be overridden or made explicit either globally, by setting the <b class="flag">block-policy</b> option, or on a per-rule basis with one of the following options:<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">drop</b></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
The packet is silently dropped.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">return</b></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
This causes a TCP RST to be returned for TCP packets and an ICMP UNREACHABLE for other types of packets.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">return-icmp</b></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">return-icmp6</b></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
This causes ICMP messages to be returned for packets which match the rule. By default this is an ICMP UNREACHABLE message, however this can be overridden by specifying a message as a code or number.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">return-rst</b></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
This applies only to TCP packets, and issues a TCP RST which closes the connection. An optional parameter, <b class="flag">ttl</b>, may be given with a TTL value.</dd>
</dl>
<div class="spacer">
</div>
Options returning ICMP packets currently have no effect if <a class="link-man" href="../html4/pf.html">pf(4)</a> operates on a <a class="link-man" href="../html4/bridge.html">bridge(4)</a>, as the code to support this feature has not yet been implemented.<div class="spacer">
</div>
The simplest mechanism to block everything by default and only pass packets that match explicit rules is specify a first filter rule of:<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">block all</code></div>
</blockquote>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="cmd">match</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The packet is matched. This mechanism is used to provide fine grained filtering without altering the block/pass state of a packet. <b class="cmd">match</b> rules differ from <b class="cmd">block</b> and <b class="cmd">pass</b> rules in that parameters are set every time a packet matches the rule, not only on the last matching rule. For the following parameters, this means that the parameter effectively becomes &#8220;sticky&#8221; until explicitly overridden: <b class="flag">nat-to</b>, <b class="flag">binat-to</b>, <b class="flag">rdr-to</b>, <b class="flag">queue</b>, <b class="flag">rtable</b>, and <b class="flag">scrub</b>.<div class="spacer">
</div>
<b class="flag">log</b> is different still, in that the action happens every time a rule matches i.e. a single packet can get logged more than once.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="cmd">pass</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The packet is passed; state is created unless the <b class="flag">no state</b> option is specified.</dd>
</dl>
<div class="spacer">
</div>
The following parameters can be used in the filter:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">in</b> <code class="none">or</code> <b class="flag">out</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
A packet always comes in on, or goes out through, one interface. <b class="flag">in</b> and <b class="flag">out</b> apply to incoming and outgoing packets; if neither are specified, the rule will match packets in both directions.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">log</b> [<span class="opt"><b class="flag">all</b> | <b class="flag">matches</b> | <b class="flag">to</b> <i class="arg">interface</i> | <b class="flag">user</b></span>]</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
In addition to any action specified, log the packet. Only the packet that establishes the state is logged, unless the <b class="flag">no state</b> option is specified. The logged packets are sent to a <a class="link-man" href="../html4/pflog.html">pflog(4)</a> interface, by default <i class="file">pflog0</i>; pflog0 is monitored by the <a class="link-man" href="../html8/pflogd.html">pflogd(8)</a> logging daemon which logs to the file <i class="file">/var/log/pflog</i> in <a class="link-man" href="../html3/pcap.html">pcap(3)</a> binary format.<div class="spacer">
</div>
The keywords <b class="flag">all</b>, <b class="flag">matches</b>, <b class="flag">to</b>, and <b class="flag">user</b> are all optional, and can be combined using commas.<div class="spacer">
</div>
Use <b class="flag">all</b> to force logging of all packets for a connection. This is not necessary when <b class="flag">no state</b> is explicitly specified.<div class="spacer">
</div>
If <b class="flag">matches</b> is specified, it logs the packet on all subsequent matching rules. It is often combined with <b class="flag">to</b> <i class="arg">interface</i> to avoid adding noise to the default log file.<div class="spacer">
</div>
The keyword <b class="flag">user</b> logs the UID and PID of the socket on the local host used to send or receive a packet, in addition to the normal information.<div class="spacer">
</div>
To specify a logging interface other than <i class="file">pflog0</i>, use the syntax <b class="flag">to</b> <i class="arg">interface</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">quick</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
If a packet matches a rule which has the <b class="flag">quick</b> option set, this rule is considered the last matching rule, and evaluation of subsequent rules is skipped.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">on</b> <i class="arg">interface</i> | <b class="flag">any</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This rule applies only to packets coming in on, or going out through, this particular interface or interface group. For more information on interface groups, see the <b class="cmd">group</b> keyword in <a class="link-man" href="../html8/ifconfig.html">ifconfig(8)</a>. <b class="flag">any</b> will match any existing interface except loopback ones.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">on rdomain</b> <i class="arg">number</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This rule applies only to packets coming in on, or going out through, this particular routing domain.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">inet</b> | <b class="flag">inet6</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This rule applies only to packets of this address family.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">proto</b> <i class="arg">protocol</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This rule applies only to packets of this protocol. Common protocols are ICMP, ICMP6, TCP, and UDP. For a list of all the protocol name to number mappings used by <a class="link-man" href="../html8/pfctl.html">pfctl(8)</a>, see the file <i class="file">/etc/protocols</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">from</b> <i class="arg">source</i> <b class="flag">port</b> <i class="arg">source</i> <b class="flag">os</b> <i class="arg">source</i> <b class="flag">to</b> <i class="arg">dest</i> <b class="flag">port</b> <i class="arg">dest</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This rule applies only to packets with the specified source and destination addresses and ports.<div class="spacer">
</div>
Addresses can be specified in CIDR notation (matching netblocks), as symbolic host names, interface names or interface group names, or as any of the following keywords:<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">any</b></dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
Any address.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">no-route</b></dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
Any address which is not currently routable.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">route</b> <i class="arg">label</i></dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
Any address matching the given <a class="link-man" href="../html8/route.html">route(8)</a> <i class="arg">label</i>.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">self</b></dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
Expands to all addresses assigned to all interfaces.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
&lt;<i class="arg">table</i>&gt;</dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
Any address matching the given <i class="arg">table</i>.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">urpf-failed</b></dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
Any source address that fails a unicast reverse path forwarding (URPF) check, i.e. packets coming in on an interface other than that which holds the route back to the packet's source address.</dd>
</dl>
<div class="spacer">
</div>
Ranges of addresses are specified using the &#8216;-&#8217; operator. For instance: &#8220;10.1.1.10 - 10.1.1.12&#8221; means all addresses from 10.1.1.10 to 10.1.1.12, hence addresses 10.1.1.10, 10.1.1.11, and 10.1.1.12.<div class="spacer">
</div>
Interface names, interface group names, and <b class="flag">self</b> can have modifiers appended:<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">:0</b></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Do not include interface aliases.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">:broadcast</b></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Translates to the interface's broadcast address(es).</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">:network</b></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Translates to the network(s) attached to the interface.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">:peer</b></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Translates to the point-to-point interface's peer address(es).</dd>
</dl>
<div class="spacer">
</div>
Host names may also have the <b class="flag">:0</b> modfier appended to restrict the name resolution to the first of each v4 and v6 address found.<div class="spacer">
</div>
Host name resolution and interface to address translation are done at ruleset load-time. When the address of an interface (or host name) changes (under DHCP or PPP, for instance), the ruleset must be reloaded for the change to be reflected in the kernel. Surrounding the interface name (and optional modifiers) in parentheses changes this behaviour. When the interface name is surrounded by parentheses, the rule is automatically updated whenever the interface changes its address. The ruleset does not need to be reloaded. This is especially useful with NAT.<div class="spacer">
</div>
Ports can be specified either by number or by name. For example, port 80 can be specified as <b class="flag">www</b>. For a list of all port name to number mappings used by <a class="link-man" href="../html8/pfctl.html">pfctl(8)</a>, see the file <i class="file">/etc/services</i>.<div class="spacer">
</div>
Ports and ranges of ports are specified using these operators:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
=	(equal) 
!=	(unequal) 
&lt;	(less than) 
&lt;=	(less than or equal) 
&gt;	(greater than) 
&gt;=	(greater than or equal) 
:	(range including boundaries) 
&gt;&lt;	(range excluding boundaries) 
&lt;&gt;	(except range)</pre>
<div class="spacer">
</div>
&#8216;&gt;&lt;&#8217;, &#8216;&lt;&gt;&#8217; and &#8216;:&#8217; are binary operators (they take two arguments). For instance:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">port 2000:2004</code></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
means &#8216;all ports &#8805; 2000 and &#8804; 2004&#8217;, hence ports 2000, 2001, 2002, 2003, and 2004.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">port 2000 &gt;&lt; 2004</code></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
means &#8216;all ports &gt; 2000 and &lt; 2004&#8217;, hence ports 2001, 2002, and 2003.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">port 2000 &lt;&gt; 2004</code></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
means &#8216;all ports &lt; 2000 or &gt; 2004&#8217;, hence ports 1&#8211;1999 and 2005&#8211;65535.</dd>
</dl>
<div class="spacer">
</div>
The operating system of the source host can be specified in the case of TCP rules with the <b class="flag">os</b> modifier. See the <i class="link-sec"><a class="link-sec" href="#x4f5045524154494e472053595354454d2046494e4745525052494e54494e47">OPERATING SYSTEM FINGERPRINTING</a></i> section for more information.<div class="spacer">
</div>
The <b class="flag">host</b>, <b class="flag">port</b>, and <b class="flag">os</b> specifications are optional, as in the following examples:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
pass in all 
pass in from any to any 
pass in proto tcp from any port &lt; 1024 to any 
pass in proto tcp from any to any port 25 
pass in proto tcp from 10.0.0.0/8 port &gt;= 1024 \ 
      to ! 10.1.2.3 port != ssh 
pass in proto tcp from any os &quot;OpenBSD&quot; 
pass in proto tcp from route &quot;DTAG&quot;</pre>
</dd>
</dl>
<div class="spacer">
</div>
The following additional parameters can be used in the filter:<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">all</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This is equivalent to &#8216;<code class="lit">from any to any</code>&#8217;.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">allow-opts</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
By default, IPv4 packets with IP options or IPv6 packets with routing extension headers are blocked. When <b class="flag">allow-opts</b> is specified for a <b class="cmd">pass</b> rule, packets that pass the filter based on that rule (last matching) do so even if they contain IP options or routing extension headers. For packets that match state, the rule that initially created the state is used. The implicit pass rule that is used when a packet does not match any rules does not allow IP options.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">divert-packet port</b> <i class="arg">port</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Used to send matching packets to <a class="link-man" href="../html4/divert.html">divert(4)</a> sockets bound to port <i class="arg">port</i>. If the default option of fragment reassembly is enabled, scrubbing with <b class="flag">reassemble tcp</b> is also enabled for <b class="flag">divert-packet</b> rules.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">divert-reply</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Used to receive replies for sockets that are bound to addresses which are not local to the machine. See <a class="link-man" href="../html2/setsockopt.html">setsockopt(2)</a> for information on how to bind these sockets.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">divert-to</b> <i class="arg">host</i> <b class="flag">port</b> <i class="arg">port</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Used to redirect packets to a local socket bound to <i class="arg">host</i> and <i class="arg">port</i>. The packets will not be modified, so <a class="link-man" href="../html2/getsockname.html">getsockname(2)</a> on the socket will return the original destination address of the packet.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">flags</b> <i class="arg">a</i>/<i class="arg">b</i> | <b class="flag">any</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This rule only applies to TCP packets that have the flags <i class="arg">a</i> set out of set <i class="arg">b</i>. Flags not specified in <i class="arg">b</i> are ignored. For stateful connections, the default is <b class="flag">flags S/SA</b>. To indicate that flags should not be checked at all, specify <b class="flag">flags any</b>. The flags are: (F)IN, (S)YN, (R)ST, (P)USH, (A)CK, (U)RG, (E)CE, and C(W)R.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">flags S/S</b></dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
Flag SYN is set. The other flags are ignored.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">flags S/SA</b></dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
This is the default setting for stateful connections. Out of SYN and ACK, exactly SYN may be set. SYN, SYN+PSH, and SYN+RST match, but SYN+ACK, ACK, and ACK+RST do not. This is more restrictive than the previous example.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">flags /SFRA</b></dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
If the first set is not specified, it defaults to none. All of SYN, FIN, RST, and ACK must be unset.</dd>
</dl>
<div class="spacer">
</div>
Because <b class="flag">flags S/SA</b> is applied by default (unless <b class="flag">no state</b> is specified), only the initial SYN packet of a TCP handshake will create a state for a TCP connection. It is possible to be less restrictive, and allow state creation from intermediate (non-SYN) packets, by specifying <b class="flag">flags any</b>. This will cause <a class="link-man" href="../html4/pf.html">pf(4)</a> to synchronize to existing connections, for instance if one flushes the state table. However, states created from such intermediate packets may be missing connection details such as the TCP window scaling factor. States which modify the packet flow, such as those affected by <b class="flag">af-to</b>, <b class="flag">modulate state</b>, <b class="flag">nat-to</b>, <b class="flag">rdr-to</b>, or <b class="flag">synproxy state</b> options, or scrubbed with <b class="flag">reassemble tcp</b>, will also not be recoverable from intermediate packets. Such connections will stall and time out.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">group</b> <i class="arg">group</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Similar to <b class="flag">user</b>, this rule only applies to packets of sockets owned by the specified <i class="arg">group</i>.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">icmp-type</b> <i class="arg">type</i> <b class="flag">code</b> <i class="arg">code</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">icmp6-type</b> <i class="arg">type</i> <b class="flag">code</b> <i class="arg">code</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This rule only applies to ICMP or ICMP6 packets with the specified type and code. Text names for ICMP types and codes are listed in <a class="link-man" href="../html4/icmp.html">icmp(4)</a> and <a class="link-man" href="../html4/icmp6.html">icmp6(4)</a>. The protocol and the ICMP type indicator (<b class="flag">icmp-type</b> or <b class="flag">icmp6-type</b>) must match.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">label</b> <i class="arg">string</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Adds a label to the rule, which can be used to identify the rule. For instance, &#8216;<code class="lit">pfctl -s labels</code>&#8217; shows per-rule statistics for rules that have labels.<div class="spacer">
</div>
The following macros can be used in labels:<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="var">$dstaddr</b></dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
The destination IP address.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="var">$dstport</b></dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
The destination port specification.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="var">$if</b></dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
The interface.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="var">$nr</b></dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
The rule number.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="var">$proto</b></dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
The protocol name.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="var">$srcaddr</b></dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
The source IP address.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="var">$srcport</b></dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
The source port specification.</dd>
</dl>
<div class="spacer">
</div>
For example:<pre style="margin-left: 5.00ex;" class="lit display">
ips = &quot;{ 1.2.3.4, 1.2.3.5 }&quot; 
pass in proto tcp from any to $ips \ 
      port &gt; 1023 label &quot;$dstaddr:$dstport&quot;</pre>
<div class="spacer">
</div>
Expands to:<pre style="margin-left: 5.00ex;" class="lit display">
pass in inet proto tcp from any to 1.2.3.4 \ 
      port &gt; 1023 label &quot;1.2.3.4:&gt;1023&quot; 
pass in inet proto tcp from any to 1.2.3.5 \ 
      port &gt; 1023 label &quot;1.2.3.5:&gt;1023&quot;</pre>
<div class="spacer">
</div>
The macro expansion for the <b class="flag">label</b> directive occurs only at configuration file parse time, not during runtime.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">once</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Creates a one shot rule that will remove itself from an active ruleset after the first match. In case this is the only rule in the anchor, the anchor will be destroyed automatically after the rule is matched.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">probability</b> <i class="arg">number</i>%</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
A probability attribute can be attached to a rule, with a value set between 0 and 100%, in which case the rule is honoured using the given probability value. For example, the following rule will drop 20% of incoming ICMP packets:<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">block in proto icmp probability 20%</code></div>
</blockquote>
<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">prio</b> <i class="arg">number</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Only match packets which have the given queueing priority assigned.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">received-on</b> <i class="arg">interface</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Only match packets which were received on the specified <b class="flag">interface</b> (or interface group). <b class="flag">any</b> will match any existing interface except loopback ones.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">rtable</b> <i class="arg">number</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Used to select an alternate routing table for the routing lookup. Only effective before the route lookup happened, i.e. when filtering inbound.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">set prio</b> <i class="arg">priority</i> | (<i class="arg">priority</i>, <i class="arg">priority</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Packets matching this rule will be assigned a specific queueing priority. Priorities are assigned as integers 0 through 7, with a default priority of 3. If the packet is transmitted on a <a class="link-man" href="../html4/vlan.html">vlan(4)</a> interface, the queueing priority will also be written as the priority code point in the 802.1Q VLAN header. If two priorities are given, packets which have a TOS of <b class="flag">lowdelay</b> and TCP ACKs with no data payload will be assigned to the second one. Packets with a higher priority number are processed first, and packets with the same priority are processed in the order in which they are received.<div class="spacer">
</div>
For example:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
pass in proto tcp to port 25 set prio 2 
pass in proto tcp to port 22 set prio (2, 5)</pre>
<div class="spacer">
</div>
The interface priority queues accessed by the <b class="flag">set prio</b> keyword are always enabled and do not require any additional configuration, unlike the queues described below and in the <i class="link-sec"><a class="link-sec" href="#x5155455545494e47">QUEUEING</a></i> section.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">set queue</b> <i class="arg">queue</i> | (<i class="arg">queue</i>, <i class="arg">queue</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Packets matching this rule will be assigned to the specified <i class="arg">queue</i>. If two queues are given, packets which have a TOS of <b class="flag">lowdelay</b> and TCP ACKs with no data payload will be assigned to the second one. See <i class="link-sec"><a class="link-sec" href="#x5155455545494e47">QUEUEING</a></i> for setup details.<div class="spacer">
</div>
For example:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
pass in proto tcp to port 25 set queue mail 
pass in proto tcp to port 22 set queue(ssh_bulk, ssh_prio)</pre>
<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">set tos</b> <i class="arg">string</i> | <i class="arg">number</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Enforces a TOS for matching packets. <i class="arg">string</i> may be one of <b class="flag">critical</b>, <b class="flag">inetcontrol</b>, <b class="flag">lowdelay</b>, <b class="flag">netcontrol</b>, <b class="flag">throughput</b>, <b class="flag">reliability</b>, or one of the DiffServ Code Points: <b class="flag">ef</b>, <b class="flag">af11</b> <code class="none">...</code> <b class="flag">af43</b>, <b class="flag">cs0</b> <code class="none">...</code> <b class="flag">cs7</b>; <i class="arg">number</i> may be either a hex or decimal number.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">tag</b> <i class="arg">string</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Packets matching this rule will be tagged with the specified <i class="arg">string</i>. The tag acts as an internal marker that can be used to identify these packets later on. This can be used, for example, to provide trust between interfaces and to determine if packets have been processed by translation rules. Tags are &#8220;sticky&#8221;, meaning that the packet will be tagged even if the rule is not the last matching rule. Further matching rules can replace the tag with a new one but will not remove a previously applied tag. A packet is only ever assigned one tag at a time. Tags take the same macros as labels (see above).<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
[<span class="opt"><b class="flag">!</b></span>]<b class="flag">tagged</b> <i class="arg">string</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Used with filter or translation rules to specify that packets must already be tagged with the given <i class="arg">string</i> in order to match the rule. Inverse tag matching can also be done by specifying the <b class="flag">!</b> operator before the <b class="flag">tagged</b> keyword.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">tos</b> <i class="arg">string</i> | <i class="arg">number</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This rule applies to packets with the specified TOS bits set. <i class="arg">string</i> may be one of <b class="flag">critical</b>, <b class="flag">inetcontrol</b>, <b class="flag">lowdelay</b>, <b class="flag">netcontrol</b>, <b class="flag">throughput</b>, <b class="flag">reliability</b>, or one of the DiffServ Code Points: <b class="flag">ef</b>, <b class="flag">af11</b> <code class="none">...</code> <b class="flag">af43</b>, <b class="flag">cs0</b> <code class="none">...</code> <b class="flag">cs7</b>; <i class="arg">number</i> may be either a hex or decimal number.<div class="spacer">
</div>
For example, the following rules are identical:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
pass all tos lowdelay 
pass all tos 0x10 
pass all tos 16</pre>
<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">user</b> <i class="arg">user</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This rule only applies to packets of sockets owned by the specified <i class="arg">user</i>. For outgoing connections initiated from the firewall, this is the user that opened the connection. For incoming connections to the firewall itself, this is the user that listens on the destination port.<div class="spacer">
</div>
When listening sockets are bound to the wildcard address, <a class="link-man" href="../html4/pf.html">pf(4)</a> cannot determine if a connection is destined for the firewall itself. To avoid false matches on just the destination port, combine a <b class="flag">user</b> rule with source or destination address <b class="flag">self</b>.<div class="spacer">
</div>
All packets, both outgoing and incoming, of one connection are associated with the same user and group. Only TCP and UDP packets can be associated with users.<div class="spacer">
</div>
The <i class="arg">user</i> and <i class="arg">group</i> arguments refer to the effective (as opposed to the real) IDs, in case the socket is created by a setuid/setgid process. User and group IDs are stored when a socket is created; when a process creates a listening socket as root (for instance, by binding to a privileged port) and subsequently changes to another user ID (to drop privileges), the credentials will remain root.<div class="spacer">
</div>
User and group IDs can be specified as either numbers or names. The syntax is similar to the one for ports. The following example allows only selected users to open outgoing connections:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
block out proto tcp all 
pass  out proto tcp from self user { &lt; 1000, dhartmei }</pre>
</dd>
</dl>
<div class="subsection">
<h2 id="x5472616e736c6174696f6e">Translation</h2> Translation options modify either the source or destination address and port of the packets associated with a stateful connection. <a class="link-man" href="../html4/pf.html">pf(4)</a> modifies the specified address and/or port in the packet and recalculates IP, TCP, and UDP checksums as necessary.<div class="spacer">
</div>
Subsequent rules will see packets as they look after any addresses and ports have been translated. These rules will therefore have to filter based on the translated address and port number.<div class="spacer">
</div>
The state entry created permits <a class="link-man" href="../html4/pf.html">pf(4)</a> to keep track of the original address for traffic associated with that state and correctly direct return traffic for that connection.<div class="spacer">
</div>
Different types of translation are possible with pf:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">af-to</b></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
Translation between different address families (NAT64) is handled using <b class="flag">af-to</b> rules. Because address family translation overrides the routing table, it's only possible to use <b class="flag">af-to</b> on inbound rules, and a source address for the resulting translation must always be specified.<div class="spacer">
</div>
The optional second argument is the host or subnet the original addresses are translated into for the destination. The lowest bits of the original destination address form the host part of the new destination address according to the specified subnet. It is possible to embed a complete IPv4 address into an IPv6 address using a network prefix of /96 or smaller.<div class="spacer">
</div>
When a destination address is not specified it is assumed that the host part is 32-bit long. For IPv6 to IPv4 translation this would mean using only the lower 32 bits of the original IPv6 destination address. For IPv4 to IPv6 translation the destination subnet defaults to the subnet of the new IPv6 source address with a prefix length of /96. See RFC 6052 Section 2.2 for details on how the prefix determines the destination address encoding.<div class="spacer">
</div>
For example, the following rules are identical:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
pass in inet af-to inet6 from 2001:db8::1 to 2001:db8::/96 
pass in inet af-to inet6 from 2001:db8::1</pre>
<div class="spacer">
</div>
In the above example the matching IPv4 packets will be modified to have a source address of 2001:db8::1 and a destination address will get prefixed with 2001:db8::/96, e.g. 198.51.100.100 will be translated to 2001:db8::c633:6464.<div class="spacer">
</div>
In the reverse case the following rules are identical:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
pass in inet6 af-to inet from 198.51.100.1 to 0.0.0.0/0 
pass in inet6 af-to inet from 198.51.100.1</pre>
<div class="spacer">
</div>
The destination IPv4 address is assumed to be embedded inside the original IPv6 destination address, e.g. 64:ff9b::c633:6464 will be translated to 198.51.100.100.<div class="spacer">
</div>
The current implementation will only extract IPv4 addresses from the IPv6 addresses with a prefix length of /96 and greater.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">binat-to</b></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
A <b class="flag">binat-to</b> rule specifies a bidirectional mapping between an external IP netblock and an internal IP netblock. It expands to an outbound <b class="flag">nat-to</b> rule and an inbound <b class="flag">rdr-to</b> rule.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">nat-to</b></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
A <b class="flag">nat-to</b> option specifies that IP addresses are to be changed as the packet traverses the given interface. This technique allows one or more IP addresses on the translating host to support network traffic for a larger range of machines on an &#8220;inside&#8221; network. Although in theory any IP address can be used on the inside, it is strongly recommended that one of the address ranges defined by RFC 1918 be used. Those netblocks are:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
10.0.0.0 &#8211; 10.255.255.255 (all of net 10, i.e. 10/8) 
172.16.0.0 &#8211; 172.31.255.255 (i.e. 172.16/12) 
192.168.0.0 &#8211; 192.168.255.255 (i.e. 192.168/16)</pre>
<div class="spacer">
</div>
<b class="flag">nat-to</b> is usually applied outbound. If applied inbound, nat-to to a local IP address is not supported.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">rdr-to</b></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
The packet is redirected to another destination and possibly a different port. <b class="flag">rdr-to</b> can optionally specify port ranges instead of single ports. For instance:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
match in ... port 2000:2999 rdr-to ... port 4000</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
redirects ports 2000 to 2999 (inclusive) to port 4000.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
match in ... port 2000:2999 rdr-to ... port 4000:*</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
redirects port 2000 to 4000, port 2001 to 4001, ..., port 2999 to 4999.</dd>
</dl>
<div class="spacer">
</div>
<b class="flag">rdr-to</b> is usually applied inbound. If applied outbound, rdr-to to a local IP address is not supported.</dd>
</dl>
<div class="spacer">
</div>
In addition to modifying the address, some translation rules may modify source or destination ports for TCP or UDP connections; implicitly in the case of <b class="flag">nat-to</b> options and explicitly in the case of <b class="flag">rdr-to</b> ones. Port numbers are never translated with a <b class="flag">binat-to</b> rule.<div class="spacer">
</div>
Translation options apply only to packets that pass through the specified interface, and if no interface is specified, translation is applied to packets on all interfaces. For instance, redirecting port 80 on an external interface to an internal web server will only work for connections originating from the outside. Connections to the address of the external interface from local hosts will not be redirected, since such packets do not actually pass through the external interface. Redirections cannot reflect packets back through the interface they arrive on, they can only be redirected to hosts connected to different interfaces or to the firewall itself.<div class="spacer">
</div>
However packets may be redirected to hosts connected to the interface the packet arrived on by using redirection with NAT. For example:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
pass in on $int_if proto tcp from $int_net to $ext_if port 80 \ 
	rdr-to $server 
pass out on $int_if proto tcp to $server port 80 \ 
	received-on $int_if nat-to $int_if</pre>
<div class="spacer">
</div>
Note that redirecting external incoming connections to the loopback address will effectively allow an external host to connect to daemons bound solely to the loopback address, circumventing the traditional blocking of such connections on a real interface. For example:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
pass in on egress proto tcp from any to any port smtp \ 
	rdr-to 127.0.0.1 port spamd</pre>
<div class="spacer">
</div>
Unless this effect is desired, any of the local non-loopback addresses should be used instead as the redirection target, which allows external connections only to daemons bound to this address or not bound to any address.<div class="spacer">
</div>
For <b class="flag">af-to</b>, <b class="flag">nat-to</b> and <b class="flag">rdr-to</b> options for which there is a single redirection address which has a subnet mask smaller than 32 for IPv4 or 128 for IPv6 (more than one IP address), a variety of different methods for assigning this address can be used:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">bitmask</b></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The <b class="flag">bitmask</b> option applies the network portion of the redirection address to the address to be modified (source with <b class="flag">nat-to</b>, destination with <b class="flag">rdr-to</b>).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">least-states</b> [<span class="opt"><b class="flag">sticky-address</b></span>]</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The <b class="flag">least-states</b> option selects the address with the least active states from a given address pool and considers given weights associated with address(es). Weights can be specified between 1 and 65535. Addresses with higher weights are selected more often.<div class="spacer">
</div>
<b class="flag">sticky-address</b> can be specified to ensure that multiple connections from the same source are mapped to the same redirection address. Associations are destroyed as soon as there are no longer states which refer to them; in order to make the mappings last beyond the lifetime of the states, increase the global options with <b class="cmd">set</b> <b class="flag">timeout src.track</b>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">random</b> [<span class="opt"><b class="flag">sticky-address</b></span>]</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The <b class="flag">random</b> option selects an address at random within the defined block of addresses. <b class="flag">sticky-address</b> is as described above.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">round-robin</b> [<span class="opt"><b class="flag">sticky-address</b></span>]</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The <b class="flag">round-robin</b> option loops through the redirection address(es) and considers given weights associated with address(es). Weights can be specified between 1 and 65535. Addresses with higher weights are selected more often. <b class="flag">sticky-address</b> is as described above.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">source-hash</b> [<span class="opt"><i class="arg">key</i></span>]</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The <b class="flag">source-hash</b> option uses a hash of the source address to determine the redirection address, ensuring that the redirection address is always the same for a given source. An optional <i class="arg">key</i> can be specified after this keyword either in hex or as a string; by default <a class="link-man" href="../html8/pfctl.html">pfctl(8)</a> randomly generates a key for source-hash every time the ruleset is reloaded.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">static-port</b></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
With <b class="flag">nat-to</b> rules, the <b class="flag">static-port</b> option prevents <a class="link-man" href="../html4/pf.html">pf(4)</a> from modifying the source port on TCP and UDP packets.</dd>
</dl>
<div class="spacer">
</div>
When more than one redirection address or a table is specified, <b class="flag">bitmask</b> is not permitted as a pool type.</div>
<div class="subsection">
<h2 id="x526f7574696e67">Routing</h2> If a packet matches a rule with one of the following route options set, the packet filter will route the packet according to the type of route option. When such a rule creates state, the route option is also applied to all packets matching the same connection.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">dup-to</b></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
The <b class="flag">dup-to</b> option creates a duplicate of the packet and routes it like <b class="flag">route-to</b>. The original packet gets routed as it normally would.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">reply-to</b></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
The <b class="flag">reply-to</b> option is similar to <b class="flag">route-to</b>, but routes packets that pass in the opposite direction (replies) to the specified interface. Opposite direction is only defined in the context of a state entry, and <b class="flag">reply-to</b> is useful only in rules that create state. It can be used on systems with multiple external connections to route all outgoing packets of a connection through the interface the incoming connection arrived through (symmetric routing enforcement).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">route-to</b></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
The <b class="flag">route-to</b> option routes the packet to the specified interface with an optional address for the next hop. When a <b class="flag">route-to</b> rule creates state, only packets that pass in the same direction as the filter rule specifies will be routed in this way. Packets passing in the opposite direction (replies) are not affected and are routed normally.</dd>
</dl>
<div class="spacer">
</div>
For the <b class="flag">dup-to</b>, <b class="flag">reply-to</b>, and <b class="flag">route-to</b> route options for which there is a single redirection address which has a subnet mask smaller than 32 for IPv4 or 128 for IPv6 (more than one IP address), the methods <b class="flag">least-states</b>, <b class="flag">random</b>, <b class="flag">round-robin</b>, and <b class="flag">source-hash</b>, as described above, can be used.</div>
</div>
<div class="section">
<h1 id="x4f5054494f4e53">OPTIONS</h1> <a class="link-man" href="../html4/pf.html">pf(4)</a> may be tuned for various situations using the <b class="cmd">set</b> command.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="cmd">set</b> <b class="flag">block-policy drop</b> | <b class="flag">return</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The <b class="flag">block-policy</b> option sets the default behaviour for the packet <b class="cmd">block</b> action:<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">drop</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Packet is silently dropped.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">return</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
A TCP RST is returned for blocked TCP packets, an ICMP UNREACHABLE is returned for blocked UDP packets, and all other packets are silently dropped.</dd>
</dl>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="cmd">set</b> <b class="flag">debug</b> <i class="arg">level</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Set the debug <i class="arg">level</i>, which limits the severity of log messages printed by <a class="link-man" href="../html4/pf.html">pf(4)</a>. This should be a keyword from the following ordered list (highest to lowest): <b class="flag">emerg</b>, <b class="flag">alert</b>, <b class="flag">crit</b>, <b class="flag">err</b>, <b class="flag">warning</b>, <b class="flag">notice</b>, <b class="flag">info</b>, and <b class="flag">debug</b>. These keywords correspond to the similar (LOG_) values specified to the <a class="link-man" href="../html3/syslog.html">syslog(3)</a> library routine.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">set</b> <b class="flag">fingerprints</b> <i class="arg">filename</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Load fingerprints of known operating systems from the given <i class="arg">filename</i>. By default fingerprints of known operating systems are automatically loaded from <a class="link-man" href="../html5/pf.os.html">pf.os(5)</a>, but can be overridden via this option. Setting this option may leave a small period of time where the fingerprints referenced by the currently active ruleset are inconsistent until the new ruleset finishes loading.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="cmd">set</b> <b class="flag">hostid</b> <i class="arg">number</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The 32-bit hostid <i class="arg">number</i> identifies this firewall's state table entries to other firewalls in a <a class="link-man" href="../html4/pfsync.html">pfsync(4)</a> failover cluster. By default the hostid is set to a pseudo-random value, however it may be desirable to manually configure it, for example to more easily identify the source of state table entries. The hostid may be specified in either decimal or hexadecimal.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="cmd">set</b> <b class="flag">limit</b> <i class="arg">limit-item number</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Sets hard limits on the memory pools used by the packet filter. See <a class="link-man" href="../html9/pool.html">pool(9)</a> for an explanation of memory pools.<div class="spacer">
</div>
For example, to set the maximum number of entries in the memory pool used by state table entries (generated by <b class="cmd">pass</b> rules which do not specify <b class="flag">no state</b>) to 20000:<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">set limit states 20000</code></div>
</blockquote>
<div class="spacer">
</div>
To set the maximum number of entries in the memory pool used for fragment reassembly to 2000:<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">set limit frags 2000</code></div>
</blockquote>
<div class="spacer">
</div>
This maximum may not exceed, and should be well below, the maximum number of mbuf clusters (sysctl kern.maxclusters) in the system.<div class="spacer">
</div>
To set the maximum number of entries in the memory pool used for tracking source IP addresses (generated by the <b class="flag">sticky-address</b> and <b class="flag">src.track</b> options) to 2000:<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">set limit src-nodes 2000</code></div>
</blockquote>
<div class="spacer">
</div>
To set limits on the memory pools used by tables:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
set limit tables 1000 
set limit table-entries 100000</pre>
<div class="spacer">
</div>
The first limits the number of tables that can exist to 1000. The second limits the overall number of addresses that can be stored in tables to 100000.<div class="spacer">
</div>
Various limits can be combined on a single line:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
set limit { states 20000, frags 2000, src-nodes 2000 }</pre>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="cmd">set</b> <b class="flag">loginterface</b> <i class="arg">interface</i> | <b class="flag">none</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Enable collection of packet and byte count statistics for the given interface or interface group. These statistics can be viewed using:<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit"># pfctl -s info</code></div>
</blockquote>
<div class="spacer">
</div>
In this example <a class="link-man" href="../html4/pf.html">pf(4)</a> collects statistics on the interface named dc0:<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">set loginterface dc0</code></div>
</blockquote>
<div class="spacer">
</div>
One can disable the loginterface using:<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">set loginterface none</code></div>
</blockquote>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="cmd">set</b> <b class="flag">optimization</b> <i class="arg">environment</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Optimize state timeouts for one of the following network environments:<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">aggressive</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Aggressively expire connections. This can greatly reduce the memory usage of the firewall at the cost of dropping idle connections early.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">conservative</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Extremely conservative settings. Avoid dropping legitimate connections at the expense of greater memory utilization (possibly much greater on a busy network) and slightly increased processor utilization.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">high-latency</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
A high-latency environment (such as a satellite connection).</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">normal</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
A normal network environment. Suitable for almost all networks.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">satellite</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Alias for <b class="flag">high-latency</b>.</dd>
</dl>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="cmd">set</b> <b class="flag">reassemble yes</b> | <b class="flag">no</b> [<span class="opt"><b class="flag">no-df</b></span>]</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The <b class="flag">reassemble</b> option is used to enable or disable the reassembly of fragmented packets, and can be set to <b class="flag">yes</b> (the default) or <b class="flag">no</b>. If <b class="flag">no-df</b> is also specified, fragments with the &#8220;dont-fragment&#8221; bit set are reassembled too, instead of being dropped; the reassembled packet will have the &#8220;dont-fragment&#8221; bit cleared.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="cmd">set</b> <b class="flag">ruleset-optimization</b> <i class="arg">level</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">basic</b></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Enable basic ruleset optimization. This is the default behaviour. Basic ruleset optimization does four things to improve the performance of ruleset evaluations:<div class="spacer">
</div>
<ol style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-enum">
<li class="list-enum" style="margin-top: 0.00em;">
remove duplicate rules</li>
<li class="list-enum" style="margin-top: 0.00em;">
remove rules that are a subset of another rule</li>
<li class="list-enum" style="margin-top: 0.00em;">
combine multiple rules into a table when advantageous</li>
<li class="list-enum" style="margin-top: 0.00em;">
reorder the rules to improve evaluation performance</li>
</ol>
<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">none</b></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Disable the ruleset optimizer.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">profile</b></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Uses the currently loaded ruleset as a feedback profile to tailor the ordering of <b class="flag">quick</b> rules to actual network traffic.</dd>
</dl>
<div class="spacer">
</div>
It is important to note that the ruleset optimizer will modify the ruleset to improve performance. A side effect of the ruleset modification is that per-rule accounting statistics will have different meanings than before. If per-rule accounting is important for billing purposes or whatnot, either the ruleset optimizer should not be used or a label field should be added to all of the accounting rules to act as optimization barriers.<div class="spacer">
</div>
Optimization can also be set as a command-line argument to <a class="link-man" href="../html8/pfctl.html">pfctl(8)</a>, overriding the settings in <b class="name">pf.conf</b>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="cmd">set</b> <b class="flag">skip on</b> <i class="arg">ifspec</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
List interfaces for which packets should not be filtered. Packets passing in or out on such interfaces are passed as if pf was disabled, i.e. pf does not process them in any way. This can be useful on loopback and other virtual interfaces, when packet filtering is not desired and can have unexpected effects. <i class="arg">ifspec</i> is only evaluated when the ruleset is loaded; interfaces created later will not be skipped.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="cmd">set</b> <b class="flag">state-defaults</b> <i class="arg">state-option</i>, <i class="arg">...</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The <b class="flag">state-defaults</b> option sets the state options for states created from rules without an explicit <b class="flag">keep state</b>. For example:<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">set state-defaults pflow, no-sync</code></div>
</blockquote>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="cmd">set</b> <b class="flag">state-policy if-bound</b> | <b class="flag">floating</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The <b class="flag">state-policy</b> option sets the default behaviour for states:<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">if-bound</b></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
States are bound to an interface.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">floating</b></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
States can match packets on any interfaces (the default).</dd>
</dl>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="cmd">set</b> <b class="flag">timeout</b> <i class="arg">variable value</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">frag</b></dt>
<dd class="list-tag" style="margin-left: 9.00ex;">
Seconds before an unassembled fragment is expired.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">interval</b></dt>
<dd class="list-tag" style="margin-left: 9.00ex;">
Interval between purging expired states and fragments.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">src.track</b></dt>
<dd class="list-tag" style="margin-left: 9.00ex;">
Length of time to retain a source tracking entry after the last state expires.</dd>
</dl>
<div class="spacer">
</div>
When a packet matches a stateful connection, the seconds to live for the connection will be updated to that of the protocol and modifier which corresponds to the connection state. Each packet which matches this state will reset the TTL. Tuning these values may improve the performance of the firewall at the risk of dropping valid idle connections.<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">tcp.closed</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The state after one endpoint sends an RST.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">tcp.closing</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The state after the first FIN has been sent.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">tcp.established</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The fully established state.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">tcp.finwait</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The state after both FINs have been exchanged and the connection is closed. Some hosts (notably web servers on Solaris) send TCP packets even after closing the connection. Increasing <b class="flag">tcp.finwait</b> (and possibly <b class="flag">tcp.closing</b>) can prevent blocking of such packets.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">tcp.first</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The state after the first packet.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">tcp.opening</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The state after the second packet but before both endpoints have acknowledged the connection.</dd>
</dl>
<div class="spacer">
</div>
ICMP and UDP are handled in a fashion similar to TCP, but with a much more limited set of states:<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">icmp.error</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The state after an ICMP error came back in response to an ICMP packet.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">icmp.first</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The state after the first packet.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">udp.first</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The state after the first packet.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">udp.multiple</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The state if both hosts have sent packets.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">udp.single</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The state if the source host sends more than one packet but the destination host has never sent one back.</dd>
</dl>
<div class="spacer">
</div>
Other protocols are handled similarly to UDP:<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">other.first</b></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">other.multiple</b></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">other.single</b></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
</dd>
</dl>
<div class="spacer">
</div>
Timeout values can be reduced adaptively as the number of state table entries grows.<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">adaptive.end</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
When reaching this number of state entries, all timeout values become zero, effectively purging all state entries immediately. This value is used to define the scale factor; it should not actually be reached (set a lower state limit, see below).</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">adaptive.start</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
When the number of state entries exceeds this value, adaptive scaling begins. All timeout values are scaled linearly with factor (adaptive.end - number of states) / (adaptive.end - adaptive.start).</dd>
</dl>
<div class="spacer">
</div>
Adaptive timeouts are enabled by default, with an adaptive.start value equal to 60% of the state limit, and an adaptive.end value equal to 120% of the state limit. They can be disabled by setting both adaptive.start and adaptive.end to 0.<div class="spacer">
</div>
The adaptive timeout values can be defined both globally and for each rule. When used on a per-rule basis, the values relate to the number of states created by the rule, otherwise to the total number of states.<div class="spacer">
</div>
For example:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
set timeout tcp.first 120 
set timeout tcp.established 86400 
set timeout { adaptive.start 6000, adaptive.end 12000 } 
set limit states 10000</pre>
<div class="spacer">
</div>
With 9000 state table entries, the timeout values are scaled to 50% (tcp.first 60, tcp.established 43200).</dd>
</dl>
</div>
<div class="section">
<h1 id="x5155455545494e47">QUEUEING</h1> Packets can be assigned to queues for the purpose of bandwidth control. At least one declaration is required to configure queues, and later any packet filtering rule can reference the defined queues by name. During the filtering component of <b class="name">pf.conf</b>, the last referenced <i class="arg">queue</i> name is where any passed packets will be queued, while for blocked packets it specifies where any resulting ICMP or TCP RST packets should be queued. If the referenced queue does not exist on the outgoing interface the default queue for that interface is used. Queues attached to an interface build a tree, thus each queue can have further child queues. Only leaf queues, i.e. queues without children, can be used to assign packets to. The root queue must specifically reference an interface, all other queues pick up the interface(s) they should be created on from their parent queues unless explicitly specified.<div class="spacer">
</div>
In the following example, a queue named std is created on the interface em0, with 3 child queues ssh, mail and http.<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
queue std on em0 bandwidth 100M 
queue ssh parent std bandwidth 10M 
queue mail parent std bandwidth 10M 
queue http parent std bandwidth 80M default</pre>
<div class="spacer">
</div>
The specified bandwidth is the target bandwidth, every queue can receive more bandwidth as long as the parent still has some available. The maximum bandwidth that should be assigned to a given queue can be limited using the <b class="flag">max</b> keyword. Similarly, a minimum (reserved) bandwidth can be specified.<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
queue ssh parent std bandwidth 10M, min 5M, max 25M</pre>
<div class="spacer">
</div>
For each of these 3 bandwidth specifications an additional burst bandwidth and time can be specified.<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
queue ssh parent std bandwidth 10M burst 90M for 100ms</pre>
<div class="spacer">
</div>
All <b class="flag">bandwidth</b> values must be specified as an absolute value. The suffixes <b class="flag">K</b>, <b class="flag">M</b>, and <b class="flag">G</b> are used to represent bits, kilobits, megabits, and gigabits per second, respectively. The value must not exceed the interface bandwidth.<div class="spacer">
</div>
In addition to the bandwidth specifications queues support the following options:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">default</b></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Packets not matched by another queue are assigned to this queue. Exactly one default queue per interface is required.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">on</b> <i class="arg">interface</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Specifies the interface the queue operates on. If not given, it operates on all matching interfaces.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">parent</b> <i class="arg">name</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Defines which parent queue the queue should be attached to. Mandatory for all queues except root queues. The parent queue must exist.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">qlimit</b> <i class="arg">limit</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The maximum number of packets held in the queue. The default is 50.</dd>
</dl>
<div class="spacer">
</div>
Packets can be assigned to queues based on filter rules by using the <b class="flag">queue</b> keyword. Normally only one <i class="arg">queue</i> is specified; when a second one is specified it will instead be used for packets which have a TOS of <b class="flag">lowdelay</b> and for TCP ACKs with no data payload.<div class="spacer">
</div>
To continue the previous example, the examples below would specify the four referenced queues, plus a few child queues. Interactive <a class="link-man" href="../html1/ssh.html">ssh(1)</a> sessions get a queue with a minimum bandwidth; <a class="link-man" href="../html1/scp.html">scp(1)</a> and <a class="link-man" href="../html1/sftp.html">sftp(1)</a> bulk transfers go to a separate queue. The queues are then referenced by filtering rules (see <i class="link-sec"><a class="link-sec" href="#x5041434b45542046494c544552494e47">PACKET FILTERING</a></i>, above).<div class="spacer">
</div>
<pre style="margin-left: 4.00ex;" class="lit display">
queue rootq on em0 bandwidth 100M max 100M 
queue http parent rootq bandwidth 60M burst 90M for 100ms 
queue  developers parent http bandwidth 45M 
queue  employees parent http bandwidth 15M 
queue mail parent rootq bandwidth 10M 
queue ssh parent rootq bandwidth 20M 
queue  ssh_interactive parent ssh bandwidth 10M min 5M 
queue  ssh_bulk parent ssh bandwidth 10M 
queue std parent rootq bandwidth 20M default 
 
block return out on em0 inet all set queue std 
pass out on em0 inet proto tcp from $developerhosts to any port 80 \ 
      set queue developers 
pass out on em0 inet proto tcp from $employeehosts to any port 80 \ 
      set queue employees 
pass out on em0 inet proto tcp from any to any port 22 \ 
      set queue(ssh_bulk, ssh_interactive) 
pass out on em0 inet proto tcp from any to any port 25 \ 
      set queue mail</pre>
</div>
<div class="section">
<h1 id="x5441424c4553">TABLES</h1> Tables are named structures which can hold a collection of addresses and networks. Lookups against tables in <a class="link-man" href="../html4/pf.html">pf(4)</a> are relatively fast, making a single rule with tables much more efficient, in terms of processor usage and memory consumption, than a large number of rules which differ only in IP address (either created explicitly or automatically by rule expansion).<div class="spacer">
</div>
Tables can be used as the source or destination of filter or translation rules. They can also be used for the redirect address of <b class="flag">nat-to</b> and <b class="flag">rdr-to</b> and in the routing options of filter rules, but not for <b class="flag">bitmask</b> pools.<div class="spacer">
</div>
Tables can be defined with any of the following <a class="link-man" href="../html8/pfctl.html">pfctl(8)</a> mechanisms. As with macros, reserved words may not be used as table names.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
manually</dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
Persistent tables can be manually created with the <b class="flag">add</b> or <b class="flag">replace</b> option of <a class="link-man" href="../html8/pfctl.html">pfctl(8)</a>, before or after the ruleset has been loaded.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="name">pf.conf</b></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
Table definitions can be placed directly in this file and loaded at the same time as other rules are loaded, atomically. Table definitions inside <b class="name">pf.conf</b> use the <b class="cmd">table</b> statement, and are especially useful to define non-persistent tables. The contents of a pre-existing table defined without a list of addresses to initialize it is not altered when <b class="name">pf.conf</b> is loaded. A table initialized with the empty list, <code class="lit">{ }</code>, will be cleared on load.</dd>
</dl>
<div class="spacer">
</div>
Tables may be defined with the following attributes:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">const</b></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
The <b class="flag">const</b> flag prevents the user from altering the contents of the table once it has been created. Without that flag, <a class="link-man" href="../html8/pfctl.html">pfctl(8)</a> can be used to add or remove addresses from the table at any time, even when running with <a class="link-man" href="../html7/securelevel.html">securelevel(7)</a> = 2.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">counters</b></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
The <b class="flag">counters</b> flag enables per-address packet and byte counters, which can be displayed with <a class="link-man" href="../html8/pfctl.html">pfctl(8)</a>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">persist</b></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
The <b class="flag">persist</b> flag forces the kernel to keep the table even when no rules refer to it. If the flag is not set, the kernel will automatically remove the table when the last rule referring to it is flushed.</dd>
</dl>
<div class="spacer">
</div>
This example creates a table called &#8220;private&#8221;, to hold RFC 1918 private network blocks, and a table called &#8220;badhosts&#8221;, which is initially empty. A filter rule is set up to block all traffic coming from addresses listed in either table:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
table &lt;private&gt; const { 10/8, 172.16/12, 192.168/16 } 
table &lt;badhosts&gt; persist 
block on fxp0 from { &lt;private&gt;, &lt;badhosts&gt; } to any</pre>
<div class="spacer">
</div>
The private table cannot have its contents changed and the badhosts table will exist even when no active filter rules reference it. Addresses may later be added to the badhosts table, so that traffic from these hosts can be blocked by using the following:<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit"># pfctl -t badhosts -Tadd 204.92.77.111</code></div>
</blockquote>
<div class="spacer">
</div>
A table can also be initialized with an address list specified in one or more external files, using the following syntax:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
table &lt;spam&gt; persist file &quot;/etc/spammers&quot; file &quot;/etc/openrelays&quot; 
block on fxp0 from &lt;spam&gt; to any</pre>
<div class="spacer">
</div>
The files <i class="file">/etc/spammers</i> and <i class="file">/etc/openrelays</i> list IP addresses, one per line. Any lines beginning with a &#8216;#&#8217; are treated as comments and ignored. In addition to being specified by IP address, hosts may also be specified by their hostname. When the resolver is called to add a hostname to a table, <span class="emph">all</span> resulting IPv4 and IPv6 addresses are placed into the table. IP addresses can also be entered in a table by specifying a valid interface name, a valid interface group, or the <b class="flag">self</b> keyword, in which case all addresses assigned to the interface(s) will be added to the table.</div>
<div class="section">
<h1 id="x414e43484f5253">ANCHORS</h1> Besides the main ruleset, <b class="name">pf.conf</b> can specify anchor attachment points. An anchor is a container that can hold rules, address tables, and other anchors. When evaluation of the main ruleset reaches an <b class="cmd">anchor</b> rule, <a class="link-man" href="../html4/pf.html">pf(4)</a> will proceed to evaluate all rules specified in that anchor.<div class="spacer">
</div>
The following example blocks all packets on the external interface by default, then evaluates all rules in the anchor named &quot;spam&quot;, and finally passes all outgoing connections and incoming connections to port 25:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
ext_if = &quot;kue0&quot; 
block on $ext_if all 
anchor spam 
pass out on $ext_if all 
pass in on $ext_if proto tcp from any to $ext_if port smtp</pre>
<div class="spacer">
</div>
Anchors can be manipulated through <a class="link-man" href="../html8/pfctl.html">pfctl(8)</a> without reloading the main ruleset or other anchors. This loads a single rule into the anchor, which blocks all packets from a specific address:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
# echo &quot;block in quick from 1.2.3.4 to any&quot; | pfctl -a spam -f -</pre>
<div class="spacer">
</div>
The anchor can also be populated by adding a <b class="cmd">load anchor</b> rule after the anchor rule. When <a class="link-man" href="../html8/pfctl.html">pfctl(8)</a> loads <b class="name">pf.conf</b>, it will also load all the rules from the file <i class="file">/etc/pf-spam.conf</i> into the anchor.<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
anchor spam 
load anchor spam from &quot;/etc/pf-spam.conf&quot;</pre>
<div class="spacer">
</div>
Filter rule anchors can also be loaded inline in the ruleset within a brace-delimited block. Brace delimited blocks may contain rules or other brace-delimited blocks. When anchors are loaded this way the anchor name becomes optional. Since the parser specification for anchor names is a string, double quote characters (&#8216;&quot;&#8217;) should be placed around the anchor name.<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
anchor &quot;external&quot; on egress { 
	block 
	anchor out { 
		pass proto tcp from any to port { 25, 80, 443 } 
	} 
	pass in proto tcp to any port 22 
}</pre>
<div class="spacer">
</div>
Anchor rules can also specify packet filtering parameters using the same syntax as filter rules. When parameters are used, the anchor rule is only evaluated for matching packets. This allows conditional evaluation of anchors, like:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
block on $ext_if all 
anchor spam proto tcp from any to any port smtp 
pass out on $ext_if all 
pass in on $ext_if proto tcp from any to $ext_if port smtp</pre>
<div class="spacer">
</div>
The rules inside anchor &quot;spam&quot; are only evaluated for TCP packets with destination port 25. Hence, the following will only block connections from 1.2.3.4 to port 25:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
# echo &quot;block in quick from 1.2.3.4 to any&quot; | pfctl -a spam -f -</pre>
<div class="spacer">
</div>
Matching filter and translation rules marked with the <b class="flag">quick</b> option are final and abort the evaluation of the rules in other anchors and the main ruleset. If the anchor itself is marked with the <b class="flag">quick</b> option, ruleset evaluation will terminate when the anchor is exited if the packet is matched by any rule within the anchor.<div class="spacer">
</div>
An anchor references other anchor attachment points using the following syntax:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="cmd">anchor</b> <i class="arg">name</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Evaluates the filter rules in the specified anchor.</dd>
</dl>
<div class="spacer">
</div>
An anchor has a name which specifies the path where <a class="link-man" href="../html8/pfctl.html">pfctl(8)</a> can be used to access the anchor to perform operations on it, such as attaching child anchors to it or loading rules into it. Anchors may be nested, with components separated by &#8216;/&#8217; characters, similar to how file system hierarchies are laid out. The main ruleset is actually the default anchor, so filter and translation rules, for example, may also be contained in any anchor.<div class="spacer">
</div>
Anchor rules are evaluated relative to the anchor in which they are contained. For example, all anchor rules specified in the main ruleset will reference anchor attachment points underneath the main ruleset, and anchor rules specified in a file loaded from a <b class="cmd">load anchor</b> rule will be attached under that anchor point.<div class="spacer">
</div>
Anchors may end with the asterisk (&#8216;*&#8217;) character, which signifies that all anchors attached at that point should be evaluated in the alphabetical ordering of their anchor name. For example, the following will evaluate each rule in each anchor attached to the &quot;spam&quot; anchor:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
anchor &quot;spam/*&quot;</pre>
<div class="spacer">
</div>
Note that it will only evaluate anchors that are directly attached to the &quot;spam&quot; anchor, and will not descend to evaluate anchors recursively.<div class="spacer">
</div>
Since anchors are evaluated relative to the anchor in which they are contained, there is a mechanism for accessing the parent and ancestor anchors of a given anchor. Similar to file system path name resolution, if the sequence &#8216;..&#8217; appears as an anchor path component, the parent anchor of the current anchor in the path evaluation at that point will become the new current anchor. As an example, consider the following:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
# printf 'anchor &quot;spam/allowed&quot;\n' | pfctl -f - 
# printf 'anchor &quot;../banned&quot;\npass\n' | pfctl -a spam/allowed -f -</pre>
<div class="spacer">
</div>
Evaluation of the main ruleset will lead into the spam/allowed anchor, which will evaluate the rules in the spam/banned anchor, if any, before finally evaluating the <b class="cmd">pass</b> rule.</div>
<div class="section">
<h1 id="x535441544546554c2046494c544552494e47">STATEFUL FILTERING</h1> <a class="link-man" href="../html4/pf.html">pf(4)</a> filters packets statefully, which has several advantages. For TCP connections, comparing a packet to a state involves checking its sequence numbers, as well as TCP timestamps if a rule using the <b class="flag">reassemble tcp</b> parameter applies to the connection. If these values are outside the narrow windows of expected values, the packet is dropped. This prevents spoofing attacks, such as when an attacker sends packets with a fake source address/port but does not know the connection's sequence numbers. Similarly, <a class="link-man" href="../html4/pf.html">pf(4)</a> knows how to match ICMP replies to states. For example, to allow echo requests (such as those created by <a class="link-man" href="../html8/ping.html">ping(8)</a>) out statefully and match incoming echo replies correctly to states:<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">pass out inet proto icmp all icmp-type echoreq</code></div>
</blockquote>
<div class="spacer">
</div>
Also, looking up states is usually faster than evaluating rules. If there are 50 rules, all of them are evaluated sequentially in O(n). Even with 50000 states, only 16 comparisons are needed to match a state, since states are stored in a binary search tree that allows searches in O(log2&#160;n).<div class="spacer">
</div>
Furthermore, correct handling of ICMP error messages is critical to many protocols, particularly TCP. <a class="link-man" href="../html4/pf.html">pf(4)</a> matches ICMP error messages to the correct connection, checks them against connection parameters, and passes them if appropriate. For example if an ICMP source quench message referring to a stateful TCP connection arrives, it will be matched to the state and get passed.<div class="spacer">
</div>
Finally, state tracking is required for <b class="flag">nat-to</b> and <b class="flag">rdr-to</b> options, in order to track address and port translations and reverse the translation on returning packets.<div class="spacer">
</div>
<a class="link-man" href="../html4/pf.html">pf(4)</a> will also create state for other protocols which are effectively stateless by nature. UDP packets are matched to states using only host addresses and ports, and other protocols are matched to states using only the host addresses.<div class="spacer">
</div>
If stateless filtering of individual packets is desired, the <b class="flag">no state</b> keyword can be used to specify that state will not be created if this is the last matching rule. Note that packets which match neither block nor pass rules, and thus are passed by default, are effectively passed as if <b class="flag">no state</b> had been specified.<div class="spacer">
</div>
A number of parameters can also be set to affect how <a class="link-man" href="../html4/pf.html">pf(4)</a> handles state tracking, as detailed below.<div class="subsection">
<h2 id="x5374617465204d6f64756c6174696f6e">State Modulation</h2> Much of the security derived from TCP is attributable to how well the initial sequence numbers (ISNs) are chosen. Some popular stack implementations choose <span class="emph">very</span> poor ISNs and thus are normally susceptible to ISN prediction exploits. By applying a <b class="flag">modulate state</b> rule to a TCP connection, <a class="link-man" href="../html4/pf.html">pf(4)</a> will create a high quality random sequence number for each connection endpoint.<div class="spacer">
</div>
The <b class="flag">modulate state</b> directive implicitly keeps state on the rule and is only applicable to TCP connections.<div class="spacer">
</div>
For instance:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
block all 
pass out proto tcp from any to any modulate state 
pass in  proto tcp from any to any port 25 flags S/SFRA \ 
      modulate state</pre>
<div class="spacer">
</div>
Note that modulated connections will not recover when the state table is lost (firewall reboot, flushing the state table, etc.). <a class="link-man" href="../html4/pf.html">pf(4)</a> will not be able to infer a connection again after the state table flushes the connection's modulator. When the state is lost, the connection may be left dangling until the respective endpoints time out the connection. It is possible on a fast local network for the endpoints to start an ACK storm while trying to resynchronize after the loss of the modulator. The default <b class="flag">flags</b> settings (or a more strict equivalent) should be used on <b class="flag">modulate state</b> rules to prevent ACK storms.<div class="spacer">
</div>
Note that alternative methods are available to prevent loss of the state table and allow for firewall failover. See <a class="link-man" href="../html4/carp.html">carp(4)</a> and <a class="link-man" href="../html4/pfsync.html">pfsync(4)</a> for further information.</div>
<div class="subsection">
<h2 id="x53594e2050726f7879">SYN Proxy</h2> By default, <a class="link-man" href="../html4/pf.html">pf(4)</a> passes packets that are part of a TCP handshake between the endpoints. The <b class="flag">synproxy state</b> option can be used to cause <a class="link-man" href="../html4/pf.html">pf(4)</a> itself to complete the handshake with the active endpoint, perform a handshake with the passive endpoint, and then forward packets between the endpoints.<div class="spacer">
</div>
No packets are sent to the passive endpoint before the active endpoint has completed the handshake, hence so-called SYN floods with spoofed source addresses will not reach the passive endpoint, as the sender can't complete the handshake.<div class="spacer">
</div>
The proxy is transparent to both endpoints; they each see a single connection from/to the other endpoint. <a class="link-man" href="../html4/pf.html">pf(4)</a> chooses random initial sequence numbers for both handshakes. Once the handshakes are completed, the sequence number modulators (see previous section) are used to translate further packets of the connection. <b class="flag">synproxy state</b> includes <b class="flag">modulate state</b>.<div class="spacer">
</div>
Rules with <b class="flag">synproxy state</b> will not work if <a class="link-man" href="../html4/pf.html">pf(4)</a> operates on a <a class="link-man" href="../html4/bridge.html">bridge(4)</a>.<div class="spacer">
</div>
Example:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
pass in proto tcp from any to any port www synproxy state</pre>
</div>
<div class="subsection">
<h2 id="x537461746566756c20547261636b696e67204f7074696f6e73">Stateful Tracking Options</h2> A number of options related to stateful tracking can be applied on a per-rule basis. One of <b class="flag">keep state</b>, <b class="flag">modulate state</b>, or <b class="flag">synproxy state</b> must be specified explicitly to apply these options to a rule.<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">floating</b></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
States can match packets on any interfaces (the opposite of <b class="flag">if-bound</b>). This is the default.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">if-bound</b></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
States are bound to an interface (the opposite of <b class="flag">floating</b>).</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">max</b> <i class="arg">number</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Limits the number of concurrent states the rule may create. When this limit is reached, further packets that would create state are dropped until existing states time out.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">no-sync</b></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Prevent state changes for states created by this rule from appearing on the <a class="link-man" href="../html4/pfsync.html">pfsync(4)</a> interface.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">pflow</b></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
States created by this rule are exported on the <a class="link-man" href="../html4/pflow.html">pflow(4)</a> interface.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">sloppy</b></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Uses a sloppy TCP connection tracker that does not check sequence numbers at all, which makes insertion and ICMP teardown attacks way easier. This is intended to be used in situations where one does not see all packets of a connection, e.g. in asymmetric routing situations. It cannot be used with <b class="flag">modulate state</b> or <b class="flag">synproxy state</b>.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">timeout seconds</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Changes the <i class="arg">timeout</i> values used for states created by this rule. For a list of all valid <i class="arg">timeout</i> names, see <i class="link-sec"><a class="link-sec" href="#x4f5054494f4e53">OPTIONS</a></i> above.</dd>
</dl>
<div class="spacer">
</div>
Multiple options can be specified, separated by commas:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
pass in proto tcp from any to any \ 
      port www keep state \ 
      (max 100, source-track rule, max-src-nodes 75, \ 
      max-src-states 3, tcp.established 60, tcp.closing 5)</pre>
<div class="spacer">
</div>
When the <b class="flag">source-track</b> keyword is specified, the number of states per source IP is tracked.<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">source-track global</b></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The number of states created by all rules that use this option is limited. Each rule can specify different <b class="flag">max-src-nodes</b> and <b class="flag">max-src-states</b> options, however state entries created by any participating rule count towards each individual rule's limits.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">source-track rule</b></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The maximum number of states created by this rule is limited by the rule's <b class="flag">max-src-nodes</b> and <b class="flag">max-src-states</b> options. Only state entries created by this particular rule count toward the rule's limits.</dd>
</dl>
<div class="spacer">
</div>
The following limits can be set:<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">max-src-nodes</b> <i class="arg">number</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Limits the maximum number of source addresses which can simultaneously have state table entries.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">max-src-states</b> <i class="arg">number</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Limits the maximum number of simultaneous state entries that a single source address can create with this rule.</dd>
</dl>
<div class="spacer">
</div>
For stateful TCP connections, limits on established connections (connections which have completed the TCP 3-way handshake) can also be enforced per source IP.<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">max-src-conn</b> <i class="arg">number</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Limits the maximum number of simultaneous TCP connections which have completed the 3-way handshake that a single host can make.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">max-src-conn-rate</b> <i class="arg">number</i>/<i class="arg">seconds</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Limit the rate of new connections over a time interval. The connection rate is an approximation calculated as a moving average.</dd>
</dl>
<div class="spacer">
</div>
When one of these limits is reached, further packets that would create state are dropped until existing states time out.<div class="spacer">
</div>
Because the 3-way handshake ensures that the source address is not being spoofed, more aggressive action can be taken based on these limits. With the <b class="flag">overload</b> &lt;<i class="arg">table</i>&gt; state option, source IP addresses which hit either of the limits on established connections will be added to the named <i class="arg">table</i>. This table can be used in the ruleset to block further activity from the offending host, redirect it to a tarpit process, or restrict its bandwidth.<div class="spacer">
</div>
The optional <b class="flag">flush</b> keyword kills all states created by the matching rule which originate from the host which exceeds these limits. The <b class="flag">global</b> modifier to the <b class="flag">flush</b> command kills all states originating from the offending host, regardless of which rule created the state.<div class="spacer">
</div>
For example, the following rules will protect the webserver against hosts making more than 100 connections in 10 seconds. Any host which connects faster than this rate will have its address added to the &lt;bad_hosts&gt; table and have all states originating from it flushed. Any new packets arriving from this host will be dropped unconditionally by the block rule.<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
block quick from &lt;bad_hosts&gt; 
pass in on $ext_if proto tcp to $webserver port www keep state \ 
      (max-src-conn-rate 100/10, overload &lt;bad_hosts&gt; flush global)</pre>
</div>
</div>
<div class="section">
<h1 id="x54524146464943204e4f524d414c49534154494f4e">TRAFFIC NORMALISATION</h1> Traffic normalisation is a broad umbrella term for aspects of the packet filter which deal with verifying packets, packet fragments, spoof traffic, and other irregularities.<div class="subsection">
<h2 id="x5363727562">Scrub</h2> Scrub involves sanitising packet content in such a way that there are no ambiguities in packet interpretation on the receiving side. It is invoked with the <b class="flag">scrub</b> option, added to regular rules.<div class="spacer">
</div>
Parameters are specified enclosed in parentheses. At least one of the following parameters must be specified:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">max-mss</b> <i class="arg">number</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Enforces a maximum segment size (MSS) for matching TCP packets.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">min-ttl</b> <i class="arg">number</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Enforces a minimum TTL for matching IP packets.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">no-df</b></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Clears the &#8220;dont-fragment&#8221; bit from a matching IPv4 packet. Some operating systems have NFS implementations which are known to generate fragmented packets with the &#8220;dont-fragment&#8221; bit set. <a class="link-man" href="../html4/pf.html">pf(4)</a> will drop such fragmented &#8220;dont-fragment&#8221; packets unless <b class="flag">no-df</b> is specified.<div class="spacer">
</div>
Unfortunately some operating systems also generate their &#8220;dont-fragment&#8221; packets with a zero IP identification field. Clearing the &#8220;dont-fragment&#8221; bit on packets with a zero IP ID may cause deleterious results if an upstream router later fragments the packet. Using <b class="flag">random-id</b> is recommended in combination with <b class="flag">no-df</b> to ensure unique IP identifiers.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">random-id</b></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Replaces the IPv4 identification field with random values to compensate for predictable values generated by many hosts. This option only applies to packets that are not fragmented after the optional fragment reassembly.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">reassemble tcp</b></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Statefully normalises TCP connections. <b class="flag">reassemble tcp</b> performs the following normalisations:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-ohang">
<dt class="list-ohang" style="margin-top: 1.00em;">
TTL</dt>
<dd class="list-ohang">
Neither side of the connection is allowed to reduce their IP TTL. An attacker may send a packet such that it reaches the firewall, affects the firewall state, and expires before reaching the destination host. <b class="flag">reassemble tcp</b> will raise the TTL of all packets back up to the highest value seen on the connection.</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
Timestamp Modulation</dt>
<dd class="list-ohang">
Modern TCP stacks will send a timestamp on every TCP packet and echo the other endpoint's timestamp back to them. Many operating systems will merely start the timestamp at zero when first booted, and increment it several times a second. The uptime of the host can be deduced by reading the timestamp and multiplying by a constant. Also observing several different timestamps can be used to count hosts behind a NAT device. And spoofing TCP packets into a connection requires knowing or guessing valid timestamps. Timestamps merely need to be monotonically increasing and not derived off a guessable base time. <b class="flag">reassemble tcp</b> will cause <b class="flag">scrub</b> to modulate the TCP timestamps with a random number.</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
Extended PAWS Checks</dt>
<dd class="list-ohang">
There is a problem with TCP on long fat pipes, in that a packet might get delayed for longer than it takes the connection to wrap its 32-bit sequence space. In such an occurrence, the old packet would be indistinguishable from a new packet and would be accepted as such. The solution to this is called PAWS: Protection Against Wrapped Sequence numbers. It protects against it by making sure the timestamp on each packet does not go backwards. <b class="flag">reassemble tcp</b> also makes sure the timestamp on the packet does not go forward more than the RFC allows. By doing this, <a class="link-man" href="../html4/pf.html">pf(4)</a> artificially extends the security of TCP sequence numbers by 10 to 18 bits when the host uses appropriately randomized timestamps, since a blind attacker would have to guess the timestamp as well.</dd>
</dl>
</dd>
</dl>
<div class="spacer">
</div>
For example:<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">match in all scrub (no-df random-id max-mss 1440)</code></div>
</blockquote>
</div>
<div class="subsection">
<h2 id="x467261676d656e742048616e646c696e67">Fragment Handling</h2> The size of IP datagrams (packets) can be significantly larger than the maximum transmission unit (MTU) of the network. In cases when it is necessary or more efficient to send such large packets, the large packet will be fragmented into many smaller packets that will each fit onto the wire. Unfortunately for a firewalling device, only the first logical fragment will contain the necessary header information for the subprotocol that allows <a class="link-man" href="../html4/pf.html">pf(4)</a> to filter on things such as TCP ports or to perform NAT.<div class="spacer">
</div>
One alternative is to filter individual fragments with filter rules. If packet reassembly is turned off, it is passed to the filter. Filter rules with matching IP header parameters decide whether the fragment is passed or blocked, in the same way as complete packets are filtered. Without reassembly, fragments can only be filtered based on IP header fields (source/destination address, protocol), since subprotocol header fields are not available (TCP/UDP port numbers, ICMP code/type). The <b class="flag">fragment</b> option can be used to restrict filter rules to apply only to fragments, but not complete packets. Filter rules without the <b class="flag">fragment</b> option still apply to fragments, if they only specify IP header fields. For instance:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
pass in proto tcp from any to any port 80</pre>
<div class="spacer">
</div>
The rule above never applies to a fragment, even if the fragment is part of a TCP packet with destination port 80, because without reassembly this information is not available for each fragment. This also means that fragments cannot create new or match existing state table entries, which makes stateful filtering and address translation (NAT, redirection) for fragments impossible.<div class="spacer">
</div>
In most cases, the benefits of reassembly outweigh the additional memory cost, so reassembly is on by default.<div class="spacer">
</div>
The memory allocated for fragment caching can be limited using <a class="link-man" href="../html8/pfctl.html">pfctl(8)</a>. Once this limit is reached, fragments that would have to be cached are dropped until other entries time out. The timeout value can also be adjusted.<div class="spacer">
</div>
When forwarding reassembled IPv6 packets, pf refragments them with the original maximum fragment size. This allows the sender to determine the optimal fragment size by path MTU discovery.</div>
<div class="subsection">
<h2 id="x426c6f636b696e672053706f6f6665642054726166666963">Blocking Spoofed Traffic</h2> Spoofing is the faking of IP addresses, typically for malicious purposes. The <b class="cmd">antispoof</b> directive expands to a set of filter rules which will block all traffic with a source IP from the network(s) directly connected to the specified interface(s) from entering the system through any other interface.<div class="spacer">
</div>
For example:<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">antispoof for lo0</code></div>
</blockquote>
<div class="spacer">
</div>
Expands to:<pre style="margin-left: 5.00ex;" class="lit display">
block drop in on ! lo0 inet from 127.0.0.1/8 to any 
block drop in on ! lo0 inet6 from ::1 to any</pre>
<div class="spacer">
</div>
For non-loopback interfaces, there are additional rules to block incoming packets with a source IP address identical to the interface's IP(s). For example, assuming the interface wi0 had an IP address of 10.0.0.1 and a netmask of 255.255.255.0:<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">antispoof for wi0 inet</code></div>
</blockquote>
<div class="spacer">
</div>
Expands to:<pre style="margin-left: 5.00ex;" class="lit display">
block drop in on ! wi0 inet from 10.0.0.0/24 to any 
block drop in inet from 10.0.0.1 to any</pre>
<div class="spacer">
</div>
Caveat: Rules created by the <b class="cmd">antispoof</b> directive interfere with packets sent over loopback interfaces to local addresses. One should pass these explicitly.</div>
</div>
<div class="section">
<h1 id="x4f5045524154494e472053595354454d2046494e4745525052494e54494e47">OPERATING SYSTEM FINGERPRINTING</h1> Passive OS fingerprinting is a mechanism to inspect nuances of a TCP connection's initial SYN packet and guess at the host's operating system. Unfortunately these nuances are easily spoofed by an attacker so the fingerprint is not useful in making security decisions. But the fingerprint is typically accurate enough to make policy decisions upon.<div class="spacer">
</div>
The fingerprints may be specified by operating system class, by version, or by subtype/patchlevel. The class of an operating system is typically the vendor or genre and would be <span class="unix">OpenBSD</span> for the <a class="link-man" href="../html4/pf.html">pf(4)</a> firewall itself. The version of the oldest available <span class="unix">OpenBSD</span> release on the main FTP site would be 2.6 and the fingerprint would be written as:<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">&quot;OpenBSD 2.6&quot;</code></div>
</blockquote>
<div class="spacer">
</div>
The subtype of an operating system is typically used to describe the patchlevel if that patch led to changes in the TCP stack behavior. In the case of <span class="unix">OpenBSD</span>, the only subtype is for a fingerprint that was normalised by the <b class="flag">no-df</b> scrub option and would be specified as:<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">&quot;OpenBSD 3.3 no-df&quot;</code></div>
</blockquote>
<div class="spacer">
</div>
Fingerprints for most popular operating systems are provided by <a class="link-man" href="../html5/pf.os.html">pf.os(5)</a>. Once <a class="link-man" href="../html4/pf.html">pf(4)</a> is running, a complete list of known operating system fingerprints may be listed by running:<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit"># pfctl -so</code></div>
</blockquote>
<div class="spacer">
</div>
Filter rules can enforce policy at any level of operating system specification assuming a fingerprint is present. Policy could limit traffic to approved operating systems or even ban traffic from hosts that aren't at the latest service pack.<div class="spacer">
</div>
The <b class="flag">unknown</b> class can also be used as the fingerprint which will match packets for which no operating system fingerprint is known.<div class="spacer">
</div>
Examples:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
pass  out proto tcp from any os OpenBSD 
block out proto tcp from any os Doors 
block out proto tcp from any os &quot;Doors PT&quot; 
block out proto tcp from any os &quot;Doors PT SP3&quot; 
block out from any os &quot;unknown&quot; 
pass on lo0 proto tcp from any os &quot;OpenBSD 3.3 lo0&quot;</pre>
<div class="spacer">
</div>
Operating system fingerprinting is limited only to the TCP SYN packet. This means that it will not work on other protocols and will not match a currently established connection.<div class="spacer">
</div>
Caveat: operating system fingerprints are occasionally wrong. There are three problems: an attacker can trivially craft his packets to appear as any operating system he chooses; an operating system patch could change the stack behavior and no fingerprints will match it until the database is updated; and multiple operating systems may have the same fingerprint.</div>
<div class="section">
<h1 id="x4558414d504c4553">EXAMPLES</h1> In this example, the external interface is <i class="file">kue0</i>. We use a macro for the interface name, so it can be changed easily. All incoming traffic is &quot;normalised&quot;, and everything is blocked and logged by default.<div class="spacer">
</div>
<pre style="margin-left: 4.00ex;" class="lit display">
ext_if = &quot;kue0&quot; 
match in all scrub (no-df max-mss 1440) 
block return log on $ext_if all</pre>
<div class="spacer">
</div>
Here we specifically block packets we don't want: anything coming from source we have no back routes for; packets whose ingress interface does not match the one in the route back to their source address; anything that does not have our address (157.161.48.183) as source; broadcasts (cable modem noise); and anything from reserved address space or invalid addresses.<div class="spacer">
</div>
<pre style="margin-left: 4.00ex;" class="lit display">
block in from no-route to any 
block in from urpf-failed to any 
block out log quick on $ext_if from ! 157.161.48.183 to any 
block in quick on $ext_if from any to 255.255.255.255 
block in log quick on $ext_if from { 10.0.0.0/8, 172.16.0.0/12, \ 
    192.168.0.0/16, 255.255.255.255/32 } to any</pre>
<div class="spacer">
</div>
For ICMP, pass out/in ping queries. State matching is done on host addresses and ICMP ID (not type/code), so replies (like 0/0 for 8/0) will match queries. ICMP error messages (which always refer to a TCP/UDP packet) are handled by the TCP/UDP states.<div class="spacer">
</div>
<pre style="margin-left: 4.00ex;" class="lit display">
pass on $ext_if inet proto icmp all icmp-type 8 code 0</pre>
<div class="spacer">
</div>
For UDP, pass out all UDP connections. DNS connections are passed in.<div class="spacer">
</div>
<pre style="margin-left: 4.00ex;" class="lit display">
pass out on $ext_if proto udp all 
pass in on $ext_if proto udp from any to any port domain</pre>
<div class="spacer">
</div>
For TCP, pass out all TCP connections and modulate state. SSH, SMTP, DNS, and IDENT connections are passed in. We do not allow Windows 9x SMTP connections since they are typically a viral worm.<div class="spacer">
</div>
<pre style="margin-left: 4.00ex;" class="lit display">
pass out on $ext_if proto tcp all modulate state 
pass in on $ext_if proto tcp from any to any \ 
    port { ssh, smtp, domain, auth } 
block in on $ext_if proto tcp from any \ 
    os { &quot;Windows 95&quot;, &quot;Windows 98&quot; } to any port smtp</pre>
<div class="spacer">
</div>
Here we pass in/out all IPv6 traffic: note that we have to enable this in two different ways, on both our physical interface and our tunnel.<div class="spacer">
</div>
<pre style="margin-left: 4.00ex;" class="lit display">
pass quick on gif0 inet6 
pass quick on $ext_if proto ipv6</pre>
<div class="spacer">
</div>
This example illustrates packet tagging. There are three interfaces: $int_if, $ext_if, and $wifi_if (wireless). NAT is being done on $ext_if for all outgoing packets. Packets in on $int_if are tagged and passed out on $ext_if. All other outgoing packets (i.e. packets from the wireless network) are only permitted to access port 80.<div class="spacer">
</div>
<pre style="margin-left: 4.00ex;" class="lit display">
pass in on $int_if from any to any tag INTNET 
pass in on $wifi_if from any to any 
 
block out on $ext_if from any to any 
pass out quick on $ext_if tagged INTNET 
pass out on $ext_if proto tcp from any to any port 80</pre>
<div class="spacer">
</div>
In this example, we tag incoming packets as they are redirected to spamd(8). The tag is used to pass those packets through the packet filter.<div class="spacer">
</div>
<pre style="margin-left: 4.00ex;" class="lit display">
match in on $ext_if inet proto tcp from &lt;spammers&gt; to port smtp \ 
     tag SPAMD rdr-to 127.0.0.1 port spamd 
 
block in on $ext_if 
pass in on $ext_if inet proto tcp tagged SPAMD</pre>
<div class="spacer">
</div>
This example maps incoming requests on port 80 to port 8080, on which a daemon is running (because, for example, it is not run as root, and therefore lacks permission to bind to port 80).<div class="spacer">
</div>
<pre style="margin-left: 4.00ex;" class="lit display">
match in on $ext_if proto tcp from any to any port 80 \ 
      rdr-to 127.0.0.1 port 8080</pre>
<div class="spacer">
</div>
If a <b class="cmd">pass</b> rule is used with the <b class="flag">quick</b> modifier, packets matching the translation rule are passed without inspecting subsequent filter rules.<div class="spacer">
</div>
<pre style="margin-left: 4.00ex;" class="lit display">
pass in quick on $ext_if proto tcp from any to any port 80 \ 
      rdr-to 127.0.0.1 port 8080</pre>
<div class="spacer">
</div>
In the example below, vlan12 is configured as 192.168.168.1; the machine translates all packets coming from 192.168.168.0/24 to 204.92.77.111 when they are going out any interface except vlan12. This has the net effect of making traffic from the 192.168.168.0/24 network appear as though it is the Internet routable address 204.92.77.111 to nodes behind any interface on the router except for the nodes on vlan12. Thus, 192.168.168.1 can talk to the 192.168.168.0/24 nodes.<div class="spacer">
</div>
<pre style="margin-left: 4.00ex;" class="lit display">
match out on ! vlan12 from 192.168.168.0/24 to any nat-to 204.92.77.111</pre>
<div class="spacer">
</div>
In the example below, the machine sits between a fake internal 144.19.74.* network, and a routable external IP of 204.92.77.100. The last rule excludes protocol AH from being translated.<div class="spacer">
</div>
<pre style="margin-left: 4.00ex;" class="lit display">
pass out on $ext_if from 144.19.74.0/24 nat-to 204.92.77.100 
pass out on $ext_if proto ah from 144.19.74.0/24</pre>
<div class="spacer">
</div>
In the example below, packets bound for one specific server, as well as those generated by the sysadmins are not proxied; all other connections are.<div class="spacer">
</div>
<pre style="margin-left: 4.00ex;" class="lit display">
pass in on $int_if proto { tcp, udp } from any to any port 80 \ 
      rdr-to 127.0.0.1 port 80 
pass in on $int_if proto { tcp, udp } from any to $server port 80 
pass in on $int_if proto { tcp, udp } from $sysadmins to any port 80</pre>
<div class="spacer">
</div>
This example maps outgoing packets' source port to an assigned proxy port instead of an arbitrary port. In this case, proxy outgoing isakmp with port 500 on the gateway.<div class="spacer">
</div>
<pre style="margin-left: 4.00ex;" class="lit display">
match out on $ext_if inet proto udp from any port isakmp to any \ 
    nat-to ($ext_if) port 500</pre>
<div class="spacer">
</div>
One more example uses <b class="flag">rdr-to</b> to redirect a TCP and UDP port to an internal machine.<div class="spacer">
</div>
<pre style="margin-left: 4.00ex;" class="lit display">
match in on $ext_if inet proto tcp from any to ($ext_if) port 8080 \ 
      rdr-to 10.1.2.151 port 22 
match in on $ext_if inet proto udp from any to ($ext_if) port 8080 \ 
      rdr-to 10.1.2.151 port 53</pre>
<div class="spacer">
</div>
In this example, a NAT gateway is set up to translate internal addresses using a pool of public addresses (192.0.2.16/28). A given source address is always translated to the same pool address by using the <b class="flag">source-hash</b> keyword. The gateway also translates incoming web server connections to a group of web servers on the internal network.<div class="spacer">
</div>
<pre style="margin-left: 4.00ex;" class="lit display">
match out on $ext_if inet from any to any nat-to 192.0.2.16/28 \ 
    source-hash 
match in  on $ext_if proto tcp from any to any port 80 \ 
    rdr-to { 10.1.2.155 weight 2, 10.1.2.160 weight 1, \ 
             10.1.2.161 weight 8 } round-robin</pre>
<div class="spacer">
</div>
The bidirectional address translation example uses a single <b class="flag">binat-to</b> rule that expands to a <b class="flag">nat-to</b> and an <b class="flag">rdr-to</b> rule.<div class="spacer">
</div>
<pre style="margin-left: 4.00ex;" class="lit display">
pass on $ext_if from 10.1.2.120 to any binat-to 192.0.2.17</pre>
<div class="spacer">
</div>
The previous example is identical to the following set of rules:<div class="spacer">
</div>
<pre style="margin-left: 4.00ex;" class="lit display">
pass out on $ext_if inet from 10.1.2.120 to any \ 
      nat-to 192.0.2.17 static-port 
pass in on $ext_if inet from any to 192.0.2.17 rdr-to 10.1.2.120</pre>
<div class="spacer">
</div>
In the example below, a router handling both address families translates an internal IPv4 subnet to IPv6 using the well-known 64:ff9b::/96 prefix:<div class="spacer">
</div>
<pre style="margin-left: 4.00ex;" class="lit display">
pass in on $v4_if inet af-to inet6 from ($v6_if) to 64:ff9b::/96</pre>
<div class="spacer">
</div>
Paired with the example above, the example below can be used on another router handling both address families to translate back to IPv4:<div class="spacer">
</div>
<pre style="margin-left: 4.00ex;" class="lit display">
pass in on $v6_if inet6 to 64:ff9b::/96 af-to inet from ($v4_if)</pre>
</div>
<div class="section">
<h1 id="x4752414d4d4152">GRAMMAR</h1> Syntax for <b class="name">pf.conf</b> in BNF:<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
line           = ( option | pf-rule | 
                 antispoof-rule | queue-rule | anchor-rule | 
                 anchor-close | load-anchor | table-rule | include ) 
 
option         = &quot;set&quot; ( [ &quot;timeout&quot; ( timeout | &quot;{&quot; timeout-list &quot;}&quot; ) ] | 
                 [ &quot;ruleset-optimization&quot; [ &quot;none&quot; | &quot;basic&quot; | 
                 &quot;profile&quot; ] ] | 
                 [ &quot;optimization&quot; [ &quot;default&quot; | &quot;normal&quot; | &quot;high-latency&quot; | 
                 &quot;satellite&quot; | &quot;aggressive&quot; | &quot;conservative&quot; ] ] 
                 [ &quot;limit&quot; ( limit-item | &quot;{&quot; limit-list &quot;}&quot; ) ] | 
                 [ &quot;loginterface&quot; ( interface-name | &quot;none&quot; ) ] | 
                 [ &quot;block-policy&quot; ( &quot;drop&quot; | &quot;return&quot; ) ] | 
                 [ &quot;state-policy&quot; ( &quot;if-bound&quot; | &quot;floating&quot; ) ] 
                 [ &quot;state-defaults&quot; state-opts ] 
                 [ &quot;fingerprints&quot; filename ] | 
                 [ &quot;skip on&quot; ifspec ] | 
                 [ &quot;debug&quot; ( &quot;emerg&quot; | &quot;alert&quot; | &quot;crit&quot; | &quot;err&quot; | 
                 &quot;warning&quot; | &quot;notice&quot; | &quot;info&quot; | &quot;debug&quot; ) ] | 
		 [ &quot;reassemble&quot; ( &quot;yes&quot; | &quot;no&quot; ) [ &quot;no-df&quot; ] ] ) 
 
pf-rule        = action [ ( &quot;in&quot; | &quot;out&quot; ) ] 
                 [ &quot;log&quot; [ &quot;(&quot; logopts &quot;)&quot;] ] [ &quot;quick&quot; ] 
                 [ &quot;on&quot; ( ifspec | &quot;rdomain&quot; number ) ] [ af ] 
                 [ protospec ] hosts [ filteropts ] 
 
logopts        = logopt [ [ &quot;,&quot; ] logopts ] 
logopt         = &quot;all&quot; | &quot;matches&quot; | &quot;user&quot; | &quot;to&quot; interface-name 
 
filteropts     = filteropt [ [ &quot;,&quot; ] filteropts ] 
filteropt      = user | group | flags | icmp-type | icmp6-type | 
                 &quot;tos&quot; tos | 
                 ( &quot;no&quot; | &quot;keep&quot; | &quot;modulate&quot; | &quot;synproxy&quot; ) &quot;state&quot; 
                 [ &quot;(&quot; state-opts &quot;)&quot; ] | &quot;scrub&quot; &quot;(&quot; scrubopts &quot;)&quot; | 
                 &quot;fragment&quot; | &quot;allow-opts&quot; | &quot;once&quot; | 
		 &quot;divert-packet&quot; &quot;port&quot; port | &quot;divert-reply&quot; | 
		 &quot;divert-to&quot; host &quot;port&quot; port | 
                 &quot;label&quot; string | &quot;tag&quot; string | [ ! ] &quot;tagged&quot; string | 
                 &quot;set prio&quot; ( number | &quot;(&quot; number [ [ &quot;,&quot; ] number ] &quot;)&quot; ) | 
                 &quot;set queue&quot; ( string | &quot;(&quot; string [ [ &quot;,&quot; ] string ] &quot;)&quot; ) | 
                 &quot;rtable&quot; number | &quot;probability&quot; number&quot;%&quot; | &quot;prio&quot; number | 
		 &quot;af-to&quot; af &quot;from&quot; ( redirhost | &quot;{&quot; redirhost-list &quot;}&quot; ) 
		 [ &quot;to&quot; ( redirhost | &quot;{&quot; redirhost-list &quot;}&quot; ) ] | 
		 &quot;binat-to&quot; ( redirhost | &quot;{&quot; redirhost-list &quot;}&quot; ) 
		 [ portspec ] [ pooltype ] | 
		 &quot;rdr-to&quot; ( redirhost | &quot;{&quot; redirhost-list &quot;}&quot; ) 
		 [ portspec ] [ pooltype ] | 
		 &quot;nat-to&quot; ( redirhost | &quot;{&quot; redirhost-list &quot;}&quot; ) 
		 [ portspec ] [ pooltype ] [ &quot;static-port&quot; ] | 
		 [ route ] | [ &quot;set tos&quot; tos ] | 
		 [ [ &quot;!&quot; ] &quot;received-on&quot; ( interface-name | interface-group ) ] 
 
scrubopts      = scrubopt [ [ &quot;,&quot; ] scrubopts ] 
scrubopt       = &quot;no-df&quot; | &quot;min-ttl&quot; number | &quot;max-mss&quot; number | 
                 &quot;reassemble tcp&quot; | &quot;random-id&quot; 
 
antispoof-rule = &quot;antispoof&quot; [ &quot;log&quot; ] [ &quot;quick&quot; ] 
                 &quot;for&quot; ifspec [ af ] [ &quot;label&quot; string ] 
 
table-rule     = &quot;table&quot; &quot;&lt;&quot; string &quot;&gt;&quot; [ tableopts ] 
tableopts      = tableopt [ tableopts ] 
tableopt       = &quot;persist&quot; | &quot;const&quot; | &quot;counters&quot; | 
                 &quot;file&quot; string | &quot;{&quot; [ tableaddrs ] &quot;}&quot; 
tableaddrs     = tableaddr-spec [ [ &quot;,&quot; ] tableaddrs ] 
tableaddr-spec = [ &quot;!&quot; ] tableaddr [ &quot;/&quot; mask-bits ] 
tableaddr      = hostname | ifspec | &quot;self&quot; | 
                 ipv4-dotted-quad | ipv6-coloned-hex 
 
queue-rule     = &quot;queue&quot; string [ &quot;on&quot; interface-name ] queueopts-list 
 
anchor-rule    = &quot;anchor&quot; [ string ] [ ( &quot;in&quot; | &quot;out&quot; ) ] [ &quot;on&quot; ifspec ] 
                 [ af ] [ protospec ] [ hosts ] [ filteropt-list ] [ &quot;{&quot; ] 
 
anchor-close   = &quot;}&quot; 
 
load-anchor    = &quot;load anchor&quot; string &quot;from&quot; filename 
 
queueopts-list = queueopts-list queueopts | queueopts 
queueopts      = [ &quot;bandwidth&quot; bandwidth ] | [ &quot;min&quot; bandwidth ] | 
                 [ &quot;max&quot; bandwidth ] | [ &quot;parent&quot; string ] | 
                 [ &quot;default&quot; ] | [ &quot;qlimit&quot; number ] 
bandwidth      = bandwidth-spec [ &quot;burst&quot; bandwidth-spec &quot;for&quot; number &quot;ms&quot; ] 
bandwidth-spec = number ( &quot;&quot; | &quot;K&quot; | &quot;M&quot; | &quot;G&quot; ) 
 
action         = &quot;pass&quot; | &quot;match&quot; | &quot;block&quot; [ return ] 
return         = &quot;drop&quot; | &quot;return&quot; | 
                 &quot;return-rst&quot; [ &quot;(&quot; &quot;ttl&quot; number &quot;)&quot; ] | 
                 &quot;return-icmp&quot; [ &quot;(&quot; icmpcode [ [ &quot;,&quot; ] icmp6code ] &quot;)&quot; ] | 
                 &quot;return-icmp6&quot; [ &quot;(&quot; icmp6code &quot;)&quot; ] 
icmpcode       = ( icmp-code-name | icmp-code-number ) 
icmp6code      = ( icmp6-code-name | icmp6-code-number ) 
 
ifspec         = ( [ &quot;!&quot; ] ( interface-name | interface-group ) ) | 
                 &quot;{&quot; interface-list &quot;}&quot; 
interface-list = [ &quot;!&quot; ] ( interface-name | interface-group ) 
                 [ [ &quot;,&quot; ] interface-list ] 
route          = ( &quot;route-to&quot; | &quot;reply-to&quot; | &quot;dup-to&quot; ) 
                 ( routehost | &quot;{&quot; routehost-list &quot;}&quot; ) 
                 [ pooltype ] 
af             = &quot;inet&quot; | &quot;inet6&quot; 
 
protospec      = &quot;proto&quot; ( proto-name | proto-number | 
                 &quot;{&quot; proto-list &quot;}&quot; ) 
proto-list     = ( proto-name | proto-number ) [ [ &quot;,&quot; ] proto-list ] 
 
hosts          = &quot;all&quot; | 
                 &quot;from&quot; ( &quot;any&quot; | &quot;no-route&quot; | &quot;urpf-failed&quot; | &quot;self&quot; | 
                 host | &quot;{&quot; host-list &quot;}&quot; | &quot;route&quot; string ) [ port ] 
                 [ os ] 
                 &quot;to&quot;   ( &quot;any&quot; | &quot;no-route&quot; | &quot;self&quot; | host | 
                 &quot;{&quot; host-list &quot;}&quot; | &quot;route&quot; string ) [ port ] 
 
ipspec         = &quot;any&quot; | host | &quot;{&quot; host-list &quot;}&quot; 
host           = [ &quot;!&quot; ] ( address [ &quot;weight&quot; number ] | 
                 address [ &quot;/&quot; mask-bits ] [ &quot;weight&quot; number ] | 
                 &quot;&lt;&quot; string &quot;&gt;&quot; ) 
redirhost      = address [ &quot;/&quot; mask-bits ] 
routehost      = host | host &quot;@&quot; interface-name | 
                 &quot;(&quot; interface-name [ address [ &quot;/&quot; mask-bits ] ] &quot;)&quot; 
address        = ( interface-name | interface-group | 
                 &quot;(&quot; ( interface-name | interface-group ) &quot;)&quot; | 
                 hostname | ipv4-dotted-quad | ipv6-coloned-hex ) 
host-list      = host [ [ &quot;,&quot; ] host-list ] 
redirhost-list = redirhost [ [ &quot;,&quot; ] redirhost-list ] 
routehost-list = routehost [ [ &quot;,&quot; ] routehost-list ] 
 
port           = &quot;port&quot; ( unary-op | binary-op | &quot;{&quot; op-list &quot;}&quot; ) 
portspec       = &quot;port&quot; ( number | name ) [ &quot;:&quot; ( &quot;*&quot; | number | name ) ] 
os             = &quot;os&quot;  ( os-name | &quot;{&quot; os-list &quot;}&quot; ) 
user           = &quot;user&quot; ( unary-op | binary-op | &quot;{&quot; op-list &quot;}&quot; ) 
group          = &quot;group&quot; ( unary-op | binary-op | &quot;{&quot; op-list &quot;}&quot; ) 
 
unary-op       = [ &quot;=&quot; | &quot;!=&quot; | &quot;&lt;&quot; | &quot;&lt;=&quot; | &quot;&gt;&quot; | &quot;&gt;=&quot; ] 
                 ( name | number ) 
binary-op      = number ( &quot;&lt;&gt;&quot; | &quot;&gt;&lt;&quot; | &quot;:&quot; ) number 
op-list        = ( unary-op | binary-op ) [ [ &quot;,&quot; ] op-list ] 
 
os-name        = operating-system-name 
os-list        = os-name [ [ &quot;,&quot; ] os-list ] 
 
flags          = &quot;flags&quot; ( [ flag-set ] &quot;/&quot;  flag-set | &quot;any&quot; ) 
flag-set       = [ &quot;F&quot; ] [ &quot;S&quot; ] [ &quot;R&quot; ] [ &quot;P&quot; ] [ &quot;A&quot; ] [ &quot;U&quot; ] [ &quot;E&quot; ] 
                 [ &quot;W&quot; ] 
 
icmp-type      = &quot;icmp-type&quot; ( icmp-type-code | &quot;{&quot; icmp-list &quot;}&quot; ) 
icmp6-type     = &quot;icmp6-type&quot; ( icmp-type-code | &quot;{&quot; icmp-list &quot;}&quot; ) 
icmp-type-code = ( icmp-type-name | icmp-type-number ) 
                 [ &quot;code&quot; ( icmp-code-name | icmp-code-number ) ] 
icmp-list      = icmp-type-code [ [ &quot;,&quot; ] icmp-list ] 
 
tos            = ( &quot;lowdelay&quot; | &quot;throughput&quot; | &quot;reliability&quot; | 
                 [ &quot;0x&quot; ] number ) 
 
state-opts     = state-opt [ [ &quot;,&quot; ] state-opts ] 
state-opt      = ( &quot;max&quot; number | &quot;no-sync&quot; | timeout | &quot;sloppy&quot; | 
                 &quot;pflow&quot; | &quot;source-track&quot; [ ( &quot;rule&quot; | &quot;global&quot; ) ] | 
                 &quot;max-src-nodes&quot; number | &quot;max-src-states&quot; number | 
                 &quot;max-src-conn&quot; number | 
                 &quot;max-src-conn-rate&quot; number &quot;/&quot; number | 
                 &quot;overload&quot; &quot;&lt;&quot; string &quot;&gt;&quot; [ &quot;flush&quot; [ &quot;global&quot; ] ] | 
                 &quot;if-bound&quot; | &quot;floating&quot; ) 
 
timeout-list   = timeout [ [ &quot;,&quot; ] timeout-list ] 
timeout        = ( &quot;tcp.first&quot; | &quot;tcp.opening&quot; | &quot;tcp.established&quot; | 
                 &quot;tcp.closing&quot; | &quot;tcp.finwait&quot; | &quot;tcp.closed&quot; | 
                 &quot;udp.first&quot; | &quot;udp.single&quot; | &quot;udp.multiple&quot; | 
                 &quot;icmp.first&quot; | &quot;icmp.error&quot; | 
                 &quot;other.first&quot; | &quot;other.single&quot; | &quot;other.multiple&quot; | 
                 &quot;frag&quot; | &quot;interval&quot; | &quot;src.track&quot; | 
                 &quot;adaptive.start&quot; | &quot;adaptive.end&quot; ) number 
 
limit-list     = limit-item [ [ &quot;,&quot; ] limit-list ] 
limit-item     = ( &quot;states&quot; | &quot;frags&quot; | &quot;src-nodes&quot; | &quot;tables&quot; | 
                 &quot;table-entries&quot; ) number 
 
pooltype       = ( &quot;bitmask&quot; | &quot;least-states&quot; | 
                 &quot;random&quot; | &quot;round-robin&quot; | 
                 &quot;source-hash&quot; [ ( hex-key | string-key ) ] ) 
                 [ &quot;sticky-address&quot; ] 
 
include        = &quot;include&quot; filename</pre>
</div>
<div class="section">
<h1 id="x46494c4553">FILES</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="file">/etc/hosts</i></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
Host name database.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="file">/etc/pf.conf</i></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
Default location of the ruleset file.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="file">/etc/pf.os</i></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
Default location of OS fingerprints.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="file">/etc/protocols</i></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
Protocol name database.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="file">/etc/services</i></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
Service name database.</dd>
</dl>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html4/pf.html">pf(4)</a>, <a class="link-man" href="../html4/pflow.html">pflow(4)</a>, <a class="link-man" href="../html4/pfsync.html">pfsync(4)</a>, <a class="link-man" href="../html5/pf.os.html">pf.os(5)</a>, <a class="link-man" href="../html8/pfctl.html">pfctl(8)</a>, <a class="link-man" href="../html8/pflogd.html">pflogd(8)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The <b class="name">pf.conf</b> file format first appeared in <span class="unix">OpenBSD&#160;3.0</span>.</div>
</div>
</body>
</html>

