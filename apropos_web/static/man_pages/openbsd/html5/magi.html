<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
MAGIC(5)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">magic</b> &#8212; <span class="desc">file command's magic pattern file</span></div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> This manual page documents the format of the magic file as used by the <a class="link-man" href="../html1/file.html">file(1)</a> command, version 4.24. The <a class="link-man" href="../html1/file.html">file(1)</a> command identifies the type of a file using, among other tests, a test for whether the file contains certain &#8220;magic patterns&#8221;. The file <i class="file">/etc/magic</i> specifies what magic numbers are to be tested for, what message to print if a particular magic number is found, and additional information to extract from the file.<div class="spacer">
</div>
Each line of the file specifies a test to be performed. A test compares the data starting at a particular offset in the file with a byte value, a string or a numeric value. If the test succeeds, a message is printed. The line consists of the following fields:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">offset</span></dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
A number specifying the offset, in bytes, into the file of the data which is to be tested.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">type</span></dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
The type of the data to be tested. The possible values are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">byte</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
A one-byte value.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">short</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
A two-byte value in this machine's native byte order.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">long</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
A four-byte value in this machine's native byte order.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">quad</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
An eight-byte value in this machine's native byte order.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">float</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
A 32-bit single precision IEEE floating point number in this machine's native byte order.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">double</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
A 64-bit double precision IEEE floating point number in this machine's native byte order.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">string</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
A string of bytes. The string type specification can be optionally followed by /[Bbc]*. The &#8220;B&#8221; flag compacts whitespace in the target, which must contain at least one whitespace character. If the magic has <span class="define">n</span> consecutive blanks, the target needs at least <span class="define">n</span> consecutive blanks to match. The &#8220;b&#8221; flag treats every blank in the target as an optional blank. Finally the &#8220;c&#8221; flag, specifies case insensitive matching: lowercase characters in the magic match both lower and upper case characters in the target, whereas upper case characters in the magic only match uppercase characters in the target.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">pstring</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
A Pascal-style string where the first byte is interpreted as the an unsigned length. The string is not NUL terminated.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">date</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
A four-byte value interpreted as a UNIX date.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">qdate</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
An eight-byte value interpreted as a UNIX date.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">ldate</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
A four-byte value interpreted as a UNIX-style date, but interpreted as local time rather than UTC.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">qldate</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
An eight-byte value interpreted as a UNIX-style date, but interpreted as local time rather than UTC.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">beshort</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
A two-byte value in big-endian byte order.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">belong</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
A four-byte value in big-endian byte order.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">bequad</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
An eight-byte value in big-endian byte order.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">befloat</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
A 32-bit single precision IEEE floating point number in big-endian byte order.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">bedouble</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
A 64-bit double precision IEEE floating point number in big-endian byte order.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">bedate</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
A four-byte value in big-endian byte order, interpreted as a Unix date.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">beqdate</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
An eight-byte value in big-endian byte order, interpreted as a Unix date.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">beldate</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
A four-byte value in big-endian byte order, interpreted as a UNIX-style date, but interpreted as local time rather than UTC.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">beqldate</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
An eight-byte value in big-endian byte order, interpreted as a UNIX-style date, but interpreted as local time rather than UTC.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">bestring16</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
A two-byte unicode (UCS16) string in big-endian byte order.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">leshort</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
A two-byte value in little-endian byte order.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">lelong</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
A four-byte value in little-endian byte order.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">lequad</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
An eight-byte value in little-endian byte order.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">lefloat</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
A 32-bit single precision IEEE floating point number in little-endian byte order.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">ledouble</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
A 64-bit double precision IEEE floating point number in little-endian byte order.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">ledate</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
A four-byte value in little-endian byte order, interpreted as a UNIX date.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">leqdate</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
An eight-byte value in little-endian byte order, interpreted as a UNIX date.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">leldate</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
A four-byte value in little-endian byte order, interpreted as a UNIX-style date, but interpreted as local time rather than UTC.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">leqldate</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
An eight-byte value in little-endian byte order, interpreted as a UNIX-style date, but interpreted as local time rather than UTC.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">lestring16</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
A two-byte unicode (UCS16) string in little-endian byte order.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">melong</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
A four-byte value in middle-endian (PDP-11) byte order.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">medate</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
A four-byte value in middle-endian (PDP-11) byte order, interpreted as a UNIX date.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">meldate</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
A four-byte value in middle-endian (PDP-11) byte order, interpreted as a UNIX-style date, but interpreted as local time rather than UTC.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">regex</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
A regular expression match in extended POSIX regular expression syntax (like egrep). Regular expressions can take exponential time to process, and their performance is hard to predict, so their use is discouraged. When used in production environments, their performance should be carefully checked. The type specification can be optionally followed by <span class="define">/[c][s]</span>. The &#8220;c&#8221; flag makes the match case insensitive, while the &#8220;s&#8221; flag update the offset to the start offset of the match, rather than the end. The regular expression is tested against line <span class="define">N + 1</span> onwards, where <span class="define">N</span> is the given offset. Line endings are assumed to be in the machine's native format. <span class="define">^</span> and <span class="define">$</span> match the beginning and end of individual lines, respectively, not beginning and end of file.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">search</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
A literal string search starting at the given offset. The same modifier flags can be used as for string patterns. The modifier flags (if any) must be followed by <span class="define">/number</span> the range, that is, the number of positions at which the match will be attempted, starting from the start offset. This is suitable for searching larger binary expressions with variable offsets, using <span class="define">\</span> escapes for special characters. The offset works as for regex.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">default</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
This is intended to be used with the test <span class="emph">x</span> (which is always true) and a message that is to be used if there are no other matches.</dd>
</dl>
<div class="spacer">
</div>
Each top-level magic pattern (see below for an explanation of levels) is classified as text or binary according to the types used. Types &#8220;regex&#8221; and &#8220;search&#8221; are classified as text tests, unless non-printable characters are used in the pattern. All other tests are classified as binary. A top-level pattern is considered to be a test text when all its patterns are text patterns; otherwise, it is considered to be a binary pattern. When matching a file, binary patterns are tried first; if no match is found, and the file looks like text, then its encoding is determined and the text patterns are tried.<div class="spacer">
</div>
The numeric types may optionally be followed by <span class="define">&amp;</span> and a numeric value, to specify that the value is to be AND'ed with the numeric value before any comparisons are done. Prepending a <span class="define">u</span> to the type indicates that ordered comparisons should be unsigned.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">test</span></dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
The value to be compared with the value from the file. If the type is numeric, this value is specified in C form; if it is a string, it is specified as a C string with the usual escapes permitted (e.g. \n for new-line).<div class="spacer">
</div>
Numeric values may be preceded by a character indicating the operation to be performed. It may be <span class="define">=</span>, to specify that the value from the file must equal the specified value, <span class="define">&lt;</span>, to specify that the value from the file must be less than the specified value, <span class="define">&gt;</span>, to specify that the value from the file must be greater than the specified value, <span class="define">&amp;</span>, to specify that the value from the file must have set all of the bits that are set in the specified value, <span class="define">^</span>, to specify that the value from the file must have clear any of the bits that are set in the specified value, or <span class="define">~</span>, the value specified after is negated before tested. <span class="define">x</span>, to specify that any value will match. If the character is omitted, it is assumed to be <span class="define">=</span>. Operators <span class="define">&amp;</span>, <span class="define">^</span>, and <span class="define">~</span> don't work with floats and doubles. The operator <span class="define">!</span> specifies that the line matches if the test does <span class="emph">not</span> succeed.<div class="spacer">
</div>
Numeric values are specified in C form; e.g. <span class="define">13</span> is decimal, <span class="define">013</span> is octal, and <span class="define">0x13</span> is hexadecimal.<div class="spacer">
</div>
For string values, the string from the file must match the specified string. The operators <span class="define">=</span>, <span class="define">&lt;</span> and <span class="define">&gt;</span> (but not <span class="define">&amp;</span>) can be applied to strings. The length used for matching is that of the string argument in the magic file. This means that a line can match any non-empty string (usually used to then print the string), with <span class="emph">&gt;\0</span> (because all non-empty strings are greater than the empty string).<div class="spacer">
</div>
The special test <span class="emph">x</span> always evaluates to true.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">message</span></dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
The message to be printed if the comparison succeeds. If the string contains a <a class="link-man" href="../html3/printf.html">printf(3)</a> format specification, the value from the file (with any specified masking performed) is printed using the message as the format string. If the string begins with &#8220;\b&#8221;, the message printed is the remainder of the string with no whitespace added before it: multiple matches are normally separated by a single space.</dd>
</dl>
<div class="spacer">
</div>
A MIME type is given on a separate line, which must be the next non-blank or comment line after the magic line that identifies the file type, and has the following format:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
!:mime	MIMETYPE</pre>
<div class="spacer">
</div>
i.e. the literal string &#8220;!:mime&#8221; followed by the MIME type.<div class="spacer">
</div>
Some file formats contain additional information which is to be printed along with the file type or need additional tests to determine the true file type. These additional tests are introduced by one or more <span class="emph">&gt;</span> characters preceding the offset. The number of <span class="emph">&gt;</span> on the line indicates the level of the test; a line with no <span class="emph">&gt;</span> at the beginning is considered to be at level 0. Tests are arranged in a tree-like hierarchy: If a test on a line at level <span class="emph">n</span> succeeds, all following tests at level <span class="emph">n+1</span> are performed, and the messages printed if the tests succeed, until a line with level <span class="emph">n</span> (or less) appears. For more complex files, one can use empty messages to get just the &quot;if/then&quot; effect, in the following way:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
0      string   MZ 
&gt;0x18  leshort  &lt;0x40   MS-DOS executable 
&gt;0x18  leshort  &gt;0x3f   extended PC executable (e.g., MS Windows)</pre>
<div class="spacer">
</div>
Offsets do not need to be constant, but can also be read from the file being examined. If the first character following the last <span class="emph">&gt;</span> is a <span class="emph">(</span> then the string after the parenthesis is interpreted as an indirect offset. That means that the number after the parenthesis is used as an offset in the file. The value at that offset is read, and is used again as an offset in the file. Indirect offsets are of the form: <span class="emph">(( x [.[bslBSL]][+-][ y ])</span>. The value of <span class="emph">x</span> is used as an offset in the file. A byte, short or long is read at that offset depending on the [<span class="opt">bslBSLm</span>] type specifier. The capitalized types interpret the number as a big endian value, whereas the small letter versions interpret the number as a little endian value; the <span class="emph">m</span> type interprets the number as a middle endian (PDP-11) value. To that number the value of <span class="emph">y</span> is added and the result is used as an offset in the file. The default type if one is not specified is long.<div class="spacer">
</div>
That way variable length structures can be examined:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
# MS Windows executables are also valid MS-DOS executables 
0           string  MZ 
&gt;0x18       leshort &lt;0x40   MZ executable (MS-DOS) 
# skip the whole block below if it is not an extended executable 
&gt;0x18       leshort &gt;0x3f 
&gt;&gt;(0x3c.l)  string  PE\0\0  PE executable (MS-Windows) 
&gt;&gt;(0x3c.l)  string  LX\0\0  LX executable (OS/2)</pre>
<div class="spacer">
</div>
This strategy of examining has a drawback: You must make sure that you eventually print something, or users may get empty output (like, when there is neither PE\0\0 nor LE\0\0 in the above example)<div class="spacer">
</div>
If this indirect offset cannot be used directly, simple calculations are possible: appending <span class="emph">[+-*/%&amp;|^]number</span> inside parentheses allows one to modify the value read from the file before it is used as an offset:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
# MS Windows executables are also valid MS-DOS executables 
0           string  MZ 
# sometimes, the value at 0x18 is less that 0x40 but there's still an 
# extended executable, simply appended to the file 
&gt;0x18       leshort &lt;0x40 
&gt;&gt;(4.s*512) leshort 0x014c  COFF executable (MS-DOS, DJGPP) 
&gt;&gt;(4.s*512) leshort !0x014c MZ executable (MS-DOS)</pre>
<div class="spacer">
</div>
Sometimes you do not know the exact offset as this depends on the length or position (when indirection was used before) of preceding fields. You can specify an offset relative to the end of the last up-level field using &#8216;&amp;&#8217; as a prefix to the offset:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
0           string  MZ 
&gt;0x18       leshort &gt;0x3f 
&gt;&gt;(0x3c.l)  string  PE\0\0    PE executable (MS-Windows) 
# immediately following the PE signature is the CPU type 
&gt;&gt;&gt;&amp;0       leshort 0x14c     for Intel 80386 
&gt;&gt;&gt;&amp;0       leshort 0x184     for DEC Alpha</pre>
<div class="spacer">
</div>
Indirect and relative offsets can be combined:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
0             string  MZ 
&gt;0x18         leshort &lt;0x40 
&gt;&gt;(4.s*512)   leshort !0x014c MZ executable (MS-DOS) 
# if it's not COFF, go back 512 bytes and add the offset taken 
# from byte 2/3, which is yet another way of finding the start 
# of the extended executable 
&gt;&gt;&gt;&amp;(2.s-514) string  LE      LE executable (MS Windows VxD driver)</pre>
<div class="spacer">
</div>
Or the other way around:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
0                 string  MZ 
&gt;0x18             leshort &gt;0x3f 
&gt;&gt;(0x3c.l)        string  LE\0\0  LE executable (MS-Windows) 
# at offset 0x80 (-4, since relative offsets start at the end 
# of the up-level match) inside the LE header, we find the absolute 
# offset to the code area, where we look for a specific signature 
&gt;&gt;&gt;(&amp;0x7c.l+0x26) string  UPX     \b, UPX compressed</pre>
<div class="spacer">
</div>
Or even both!<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
0                string  MZ 
&gt;0x18            leshort &gt;0x3f 
&gt;&gt;(0x3c.l)       string  LE\0\0 LE executable (MS-Windows) 
# at offset 0x58 inside the LE header, we find the relative offset 
# to a data area where we look for a specific signature 
&gt;&gt;&gt;&amp;(&amp;0x54.l-3)  string  UNACE  \b, ACE self-extracting archive</pre>
<div class="spacer">
</div>
Finally, if you have to deal with offset/length pairs in your file, even the second value in a parenthesized expression can be taken from the file itself, using another set of parentheses. Note that this additional indirect offset is always relative to the start of the main indirect offset.<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
0                 string       MZ 
&gt;0x18             leshort      &gt;0x3f 
&gt;&gt;(0x3c.l)        string       PE\0\0 PE executable (MS-Windows) 
# search for the PE section called &quot;.idata&quot;... 
&gt;&gt;&gt;&amp;0xf4          search/0x140 .idata 
# ...and go to the end of it, calculated from start+length; 
# these are located 14 and 10 bytes after the section name 
&gt;&gt;&gt;&gt;(&amp;0xe.l+(-4)) string       PK\3\4 \b, ZIP self-extracting archive</pre>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html1/file.html">file(1)</a> - the command that reads this file.</div>
<div class="section">
<h1 id="x42554753">BUGS</h1> The formats <span class="define">long</span>, <span class="define">belong</span>, <span class="define">lelong</span>, <span class="define">melong</span>, <span class="define">short</span>, <span class="define">beshort</span>, <span class="define">leshort</span>, <span class="define">date</span>, <span class="define">bedate</span>, <span class="define">medate</span>, <span class="define">ledate</span>, <span class="define">beldate</span>, <span class="define">leldate</span>, and <span class="define">meldate</span> are system-dependent; perhaps they should be specified as a number of bytes (2B, 4B, etc), since the files being recognized typically come from a system on which the lengths are invariant.</div>
</div>
</body>
</html>

