<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
nsd-control(8)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
nsd-control(8)</td>
<td class="head-vol">
nsd 4.1.7</td>
<td class="head-rtitle">
nsd-control(8)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> <b>nsd-control,</b> <b>nsd-control-setup</b> - NSD remote server control utility.</div>
<div class="section">
<h1>SYNOPSIS</h1> <b>nsd-control</b> [<b>-c</b> <i>cfgfile</i>] [<b>-s</b> <i>server</i>] <i>command</i></div>
<div class="section">
<h1>DESCRIPTION</h1> <b>nsd-control</b> performs remote administration on the  <i>nsd</i>(8) DNS server.  It reads the configuration file, contacts the nsd server over SSL, sends the command and displays the result.<div class="spacer">
</div>
The available options are:<dl>
<dt>
<b>-h</b></dt>
<dd>
Show the version and commandline option help.</dd>
</dl>
<dl>
<dt>
<b>-c <i>cfgfile</i></b></dt>
<dd>
The config file to read with settings.  If not given the default config file /var/nsd/etc/nsd.conf is used.</dd>
</dl>
<dl>
<dt>
<b>-s <i>server[@port]</i></b></dt>
<dd>
IPv4 or IPv6 address of the server to contact.  If not given, the address is read from the config file.</dd>
</dl>
</div>
<div class="section">
<h1>COMMANDS</h1> There are several commands that the server understands.<dl>
<dt>
<b>start</b></dt>
<dd>
Start the server. Simply execs <i>nsd</i>(8).  The nsd executable is searched for in the  <b>PATH</b> set in the environment.  It is started with the config file specified using  <i>-c</i> or the default config file.</dd>
</dl>
<dl>
<dt>
<b>stop</b></dt>
<dd>
Stop the server. The server daemon exits.</dd>
</dl>
<dl>
<dt>
<b>reload [&lt;zone&gt;]</b></dt>
<dd>
Reload zonefiles and reopen logfile.  Without argument reads changed zonefiles.  With argument reads the zonefile for the given zone and loads it.</dd>
</dl>
<dl>
<dt>
<b>reconfig</b></dt>
<dd>
Reload nsd.conf and apply changes to TSIG keys and configuration patterns, and apply the changes to add and remove zones that are mentioned in the config. Other changes are not applied, such as listening ip address and port and chroot. The pattern updates means that the configuration options for zones (request-xfr, zonefile, notify, ...) are updated.  Also new patterns are available for use with the addzone command.</dd>
</dl>
<dl>
<dt>
<b>repattern</b></dt>
<dd>
Same as the reconfig option.</dd>
</dl>
<dl>
<dt>
<b>log_reopen</b></dt>
<dd>
Reopen the logfile, for log rotate that wants to move the logfile away and create a new logfile.  The log can also be reopened with kill -HUP (which also reloads all zonefiles).</dd>
</dl>
<dl>
<dt>
<b>status</b></dt>
<dd>
Display server status. Exit code 3 if not running (the connection to the port is refused), 1 on error, 0 if running.</dd>
</dl>
<dl>
<dt>
<b>stats</b></dt>
<dd>
Output a sequence of name=value lines with statistics information, requires NSD to be compiled with this option enabled.</dd>
</dl>
<dl>
<dt>
<b>stats_noreset</b></dt>
<dd>
Same as stats, but does not zero the counters.</dd>
</dl>
<dl>
<dt>
<b>addzone &lt;zone name&gt; &lt;pattern name&gt;</b></dt>
<dd>
Add a new zone to the running server.  The zone is added to the zonelist file on disk, so it stays after a restart.  The pattern name determines the options for the new zone.  For slave zones a zone transfer is immediately attempted.  For zones with a zonefile, the zone file is attempted to be read in.</dd>
</dl>
<dl>
<dt>
<b>delzone &lt;zone name&gt;</b></dt>
<dd>
Remove the zone from the running server.  The zone is removed from the zonelist file on disk, from the nsd.db file and from the memory.  If it had a zonefile, this remains (but may be outdated).  Zones configured inside nsd.conf itself cannot be removed this way because the daemon does not write to the nsd.conf file, you need to add such zones to the zonelist file to be able to delete them with the delzone command.</dd>
</dl>
<dl>
<dt>
<b>addzones</b></dt>
<dd>
Add zones read from stdin of nsd-control.  Input is read per line, with name space patternname on a line.  For bulk additions.</dd>
</dl>
<dl>
<dt>
<b>delzones</b></dt>
<dd>
Remove zones read from stdin of nsd-control.  Input is one name per line. For bulk removals.</dd>
</dl>
<dl>
<dt>
<b>write [&lt;zone&gt;]</b></dt>
<dd>
Write zonefiles to disk, or the given zonefile to disk.  Zones that have changed (via AXFR or IXFR) are written, or if the zonefile has not been created yet then it is created.  Directory components of the zonefile path are created if necessary.</dd>
</dl>
<dl>
<dt>
<b>notify [&lt;zone&gt;]</b></dt>
<dd>
Send NOTIFY messages to slave servers.  Sends to the IP addresses configured in the 'notify:' lists for the master zones hosted on this server.  Usually NSD sends NOTIFY messages right away when a master zone serial is updated.  If a zone is given, notifies are sent for that zone. These slave servers are supposed to initiate a zone transfer request later (to this server or another master), this can be allowed via the 'provide-xfr:' acl list configuration.</dd>
</dl>
<dl>
<dt>
<b>transfer [&lt;zone&gt;]</b></dt>
<dd>
Attempt to update slave zones that are hosted on this server by contacting the masters.  The masters are configured via 'request-xfr:' lists. If a zone is given, that zone is updated.  Usually NSD receives a NOTIFY from the masters (configured via 'allow-notify:' acl list) that a new zone serial has to be transferred.  For zones with no content, NSD may have backed off from asking often because the masters did not respond, but this command will reset the backoff to its initial timeout, for frequent retries.</dd>
</dl>
<dl>
<dt>
<b>force_transfer [&lt;zone&gt;]</b></dt>
<dd>
Force update slave zones that are hosted on this server.  Even if the master hosts the same serial number of the zone, a full AXFR is performed to fetch it.  If you want to use IXFR and check that the serial number increases, use the 'transfer' command.</dd>
</dl>
<dl>
<dt>
<b>zonestatus [&lt;zone&gt;]</b></dt>
<dd>
Print state of the zone, the serial numbers and since when they have been acquired.  Also prints the notify action (to which server), and zone transfer (and from which master) if there is activity right now. The state of the zone is printed as: 'master' (master zones), 'ok' (slave zone is up-to-date), 'expired' (slave zone has expired), 'refreshing' (slave zone has transfers active).  The serial numbers printed are the 'served-serial' (currently active), the 'commit-serial' (is in reload), the 'notified-serial' (got notify, busy fetching the data).  The serial numbers are only printed if such a serial number is available.</dd>
</dl>
<dl>
<dt>
<b>serverpid</b></dt>
<dd>
Prints the PID of the server process.  This is used for statistics (and only works when NSD is compiled with statistics enabled).  This pid is not for sending unix signals, use the pid from nsd.pid for that, that pid is also stable.</dd>
</dl>
<dl>
<dt>
<b>verbosity &lt;number&gt;</b></dt>
<dd>
Change logging verbosity.</dd>
</dl>
</div>
<div class="section">
<h1>EXIT CODE</h1> The nsd-control program exits with status code 1 on error, 0 on success.</div>
<div class="section">
<h1>SET UP</h1> The setup requires a self-signed certificate and private keys for both the server and client.  The script  <i>nsd-control-setup</i> generates these in the default run directory, or with -d in another directory. If you change the access control permissions on the key files you can decide who can use nsd-control, by default owner and group but not all users. The script preserves private keys present in the directory. After running the script as root, turn on  <b>control-enable</b> in  <i>nsd.conf</i>.</div>
<div class="section">
<h1>STATISTIC COUNTERS</h1> The  <i>stats</i> command shows a number of statistic counters.<dl>
<dt>
<i>num.queries</i></dt>
<dd>
number of queries received (the tcp and udp queries added up).</dd>
</dl>
<dl>
<dt>
<i>serverX.queries</i></dt>
<dd>
number of queries handled by the server process.  The number of server processes is set with the config statement  <b>server-count</b>.</dd>
</dl>
<dl>
<dt>
<i>time.boot</i></dt>
<dd>
uptime in seconds since the server was started.  With fractional seconds.</dd>
</dl>
<dl>
<dt>
<i>time.elapsed</i></dt>
<dd>
time since the last stats report, in seconds.  With fractional seconds. Can be zero if polled quickly and the previous stats command resets the counters, so that the next gets a fully zero, and zero elapsed time, report.</dd>
</dl>
<dl>
<dt>
<i>size.db.disk</i></dt>
<dd>
size of nsd.db on disk, in bytes.</dd>
</dl>
<dl>
<dt>
<i>size.db.mem</i></dt>
<dd>
size of the DNS database in memory, in bytes.</dd>
</dl>
<dl>
<dt>
<i>size.xfrd.mem</i></dt>
<dd>
size of memory for zone transfers and notifies in xfrd process, excludes TSIG data, in bytes.</dd>
</dl>
<dl>
<dt>
<i>size.config.disk</i></dt>
<dd>
size of zonelist file on disk, excludes the nsd.conf size, in bytes.</dd>
</dl>
<dl>
<dt>
<i>size.config.mem</i></dt>
<dd>
size of config data in memory, kept twice in server and xfrd process, in bytes.</dd>
</dl>
<dl>
<dt>
<i>num.type.X</i></dt>
<dd>
number of queries with this query type.</dd>
</dl>
<dl>
<dt>
<i>num.opcode.X</i></dt>
<dd>
number of queries with this opcode.</dd>
</dl>
<dl>
<dt>
<i>num.class.X</i></dt>
<dd>
number of queries with this query class.</dd>
</dl>
<dl>
<dt>
<i>num.rcode.X</i></dt>
<dd>
number of answers that carried this return code.</dd>
</dl>
<dl>
<dt>
<i>num.edns</i></dt>
<dd>
number of queries with EDNS OPT.</dd>
</dl>
<dl>
<dt>
<i>num.ednserr</i></dt>
<dd>
number of queries which failed EDNS parse.</dd>
</dl>
<dl>
<dt>
<i>num.udp</i></dt>
<dd>
number of queries over UDP ip4.</dd>
</dl>
<dl>
<dt>
<i>num.udp6</i></dt>
<dd>
number of queries over UDP ip6.</dd>
</dl>
<dl>
<dt>
<i>num.tcp</i></dt>
<dd>
number of connections over TCP ip4.</dd>
</dl>
<dl>
<dt>
<i>num.tcp6</i></dt>
<dd>
number of connections over TCP ip6.</dd>
</dl>
<dl>
<dt>
<i>num.answer_wo_aa</i></dt>
<dd>
number of answers with NOERROR rcode and without AA flag, this includes the referrals.</dd>
</dl>
<dl>
<dt>
<i>num.rxerr</i></dt>
<dd>
number of queries for which the receive failed.</dd>
</dl>
<dl>
<dt>
<i>num.txerr</i></dt>
<dd>
number of answers for which the transmit failed.</dd>
</dl>
<dl>
<dt>
<i>num.raxfr</i></dt>
<dd>
number of AXFR requests from clients (that got served with reply).</dd>
</dl>
<dl>
<dt>
<i>num.truncated</i></dt>
<dd>
number of answers with TC flag set.</dd>
</dl>
<dl>
<dt>
<i>num.dropped</i></dt>
<dd>
number of queries that were dropped because they failed sanity check.</dd>
</dl>
<dl>
<dt>
<i>zone.master</i></dt>
<dd>
number of master zones served.  These are zones with no 'request-xfr:' entries.</dd>
</dl>
<dl>
<dt>
<i>zone.slave</i></dt>
<dd>
number of slave zones served.  These are zones with 'request-xfr' entries.</dd>
</dl>
</div>
<div class="section">
<h1>FILES</h1><dl>
<dt>
<i>/var/nsd/etc/nsd.conf</i></dt>
<dd>
nsd configuration file.</dd>
</dl>
<dl>
<dt>
<i>/var/nsd/etc</i></dt>
<dd>
directory with private keys (nsd_server.key and nsd_control.key) and self-signed certificates (nsd_server.pem and nsd_control.pem).</dd>
</dl>
</div>
<div class="section">
<h1>SEE ALSO</h1>  <i>nsd.conf</i>(5),  <i>nsd</i>(8),  <i>nsd-checkconf</i>(8)</div>
<table class="foot">
<tr>
<td class="foot-date">
December 10, 2015</td>
<td class="foot-os">
NLnet Labs</td>
</tr>
</table>
</div>
</body>
</html>

