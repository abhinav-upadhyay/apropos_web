<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
AUDIO(4)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">audio</b>, <b class="name">mixer</b> &#8212; <span class="desc">device-independent audio driver layer</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="config">audio* at ...</b><div class="spacer">
</div>
<br/>
<b class="includes">#include &lt;<a class="link-includes">sys/types.h</a>&gt;</b><br/>
<b class="includes">#include &lt;<a class="link-includes">sys/ioctl.h</a>&gt;</b><br/>
<b class="includes">#include &lt;<a class="link-includes">sys/audioio.h</a>&gt;</b><br/>
<b class="includes">#include &lt;<a class="link-includes">string.h</a>&gt;</b></div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <b class="name">audio</b> driver provides support for various audio peripherals. It provides a uniform programming interface layer above different underlying audio hardware drivers. The audio layer provides full-duplex operation if the underlying hardware configuration supports it.<div class="spacer">
</div>
There are four device files available for audio operation: <i class="file">/dev/audio</i>, <i class="file">/dev/sound</i>, <i class="file">/dev/audioctl</i>, and <i class="file">/dev/mixer</i>. <i class="file">/dev/audio</i> and <i class="file">/dev/sound</i> are used for recording or playback of digital samples. <i class="file">/dev/mixer</i> is used to manipulate volume, recording source, or other audio mixer functions. <i class="file">/dev/audioctl</i> accepts the same <a class="link-man" href="../html2/ioctl.html">ioctl(2)</a> operations as <i class="file">/dev/sound</i>, but no other operations. In contrast to <i class="file">/dev/sound</i>, which has the exclusive open property, <i class="file">/dev/audioctl</i> can be opened at any time and can be used to manipulate the <b class="name">audio</b> device while it is in use.</div>
<div class="section">
<h1 id="x53414d504c494e472044455649434553">SAMPLING DEVICES</h1> When <i class="file">/dev/audio</i> or <i class="file">/dev/sound</i> is opened, it attempts to maintain the previous audio sample format and record/playback mode. In addition, if it is opened read-only (write-only) the device is set to half-duplex record (play) mode with recording (playing) unpaused. In all respects <i class="file">/dev/audio</i> and <i class="file">/dev/sound</i> are identical.<div class="spacer">
</div>
Only one process may hold open a sampling device at a given time (although file descriptors may be shared between processes once the first open completes).<div class="spacer">
</div>
On a half-duplex device, either reads or writes are allowed, but not both. On a full-duplex device, reads and writes may operate concurrently without interference.<div class="spacer">
</div>
If a writing process does not call <a class="link-man" href="../html2/write.html">write(2)</a> frequently enough to provide samples at the pace the hardware consumes them silence is inserted. If a reading process does not call <a class="link-man" href="../html2/read.html">read(2)</a> frequently enough, it will simply miss samples.<div class="spacer">
</div>
The <b class="name">audio</b> device is accessed with <a class="link-man" href="../html2/read.html">read(2)</a> or <a class="link-man" href="../html2/write.html">write(2)</a>.<div class="spacer">
</div>
The <b class="name">audio</b> device, like most devices, can be used in <a class="link-man" href="../html2/poll.html">poll(2)</a>,<div class="spacer">
</div>
The following <a class="link-man" href="../html2/ioctl.html">ioctl(2)</a> commands are supported on the sample devices:<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">AUDIO_RERROR</span> <i class="farg">int *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">AUDIO_PERROR</span> <i class="farg">int *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Obsolete. These commands fetch the count of dropped input or output samples into the <span class="type">int *</span> argument, respectively. There is no information regarding when in the sample stream they were dropped.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">AUDIO_GETDEV</span> <i class="farg">audio_device_t *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This command fetches the current hardware device information into the <span class="type">audio_device_t *</span> argument.<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
typedef struct audio_device { 
        char name[MAX_AUDIO_DEV_LEN]; 
        char version[MAX_AUDIO_DEV_LEN]; 
        char config[MAX_AUDIO_DEV_LEN]; 
} audio_device_t;</pre>
<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">AUDIO_GETFD</span> <i class="farg">int *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This command returns 1 if in full-duplex mode, else 0.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">AUDIO_GETENC</span> <i class="farg">audio_encoding_t *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This command is used iteratively to fetch sample encoding <b class="var">name</b>s and <b class="var">format_id</b>s into the input/output <span class="type">audio_encoding_t *</span> argument.<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
typedef struct audio_encoding { 
	int index;      /* input: nth encoding */ 
	char name[MAX_AUDIO_DEV_LEN]; /* name of encoding */ 
	int encoding;   /* value for encoding parameter */ 
	int precision;  /* value for precision parameter */ 
	int bps;        /* value for bps parameter */ 
	int msb;        /* value for msb parameter */ 
} audio_encoding_t;</pre>
<div class="spacer">
</div>
To query all the supported encodings, start with an index field of 0 and continue with successive encodings (1, 2, ...) until the command returns an error.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">AUDIO_SETFD</span> <i class="farg">int *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Does nothing, left for compatibility; argument must point to a non-zero integer if the device is opened in read-write mode.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">AUDIO_GETPROPS</span> <i class="farg">int *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This command gets a bit set of hardware properties. If the hardware has a certain property, the corresponding bit is set, otherwise it is not. The properties can have the following values:<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">AUDIO_PROP_FULLDUPLEX</span></dt>
<dd class="list-tag" style="margin-left: 22.00ex;">
The device admits full-duplex operation.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">AUDIO_PROP_INDEPENDENT</span></dt>
<dd class="list-tag" style="margin-left: 22.00ex;">
The device can set playing and recording channel counts independently.</dd>
</dl>
<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">AUDIO_GETIOFFS</span> <i class="farg">audio_offset_t *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">AUDIO_GETOOFFS</span> <i class="farg">audio_offset_t *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Obsolete. These commands fetch the number of bytes played or recorded. The information is returned in the <span class="type">audio_offset</span> structure.<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
typedef struct audio_offset { 
	u_int	samples;   /* Total number of bytes transferred */ 
} audio_offset_t;</pre>
<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">AUDIO_GETINFO</span> <i class="farg">audio_info_t *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">AUDIO_SETINFO</span> <i class="farg">audio_info_t *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Get or set audio information as encoded in the <span class="type">audio_info</span> structure.<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
typedef struct audio_info { 
	struct	audio_prinfo play;   /* info for play (output) side */ 
	struct	audio_prinfo record; /* info for record (input) side */ 
	u_int	hiwat;		/* blocks count in play buffer */ 
	u_int	mode;		/* current device mode */ 
#define AUMODE_PLAY	0x01 
#define AUMODE_RECORD	0x02 
} audio_info_t;</pre>
<div class="spacer">
</div>
When setting the current state with <span class="define">AUDIO_SETINFO</span>, the <span class="type">audio_info</span> structure should first be initialized with<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">AUDIO_INITINFO(&amp;info);</code></div>
</blockquote>
<div class="spacer">
</div>
and then the particular values to be changed should be set. This allows the audio driver to only set those things that you wish to change and eliminates the need to query the device with <span class="define">AUDIO_GETINFO</span> first.<div class="spacer">
</div>
The <b class="var">mode</b> field is read-only and set to <span class="define">AUMODE_PLAY</span>, <span class="define">AUMODE_RECORD</span>, or a bitwise OR combination of the three. Only full-duplex audio devices support simultaneous record and playback.<div class="spacer">
</div>
<b class="var">hiwat</b> contains the number of blocks in the kernel play buffer. Writes to the audio devices will queue blocks until the play buffer is full, at which point any more write calls will block until space for at least one byte is available.<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
struct audio_prinfo { 
	u_int	sample_rate;	/* sample rate in bit/s */ 
	u_int	channels;	/* number of channels, usually 1 or 2 */ 
	u_int	precision;	/* number of bits/sample */ 
	u_int	bps;		/* number of bytes/sample */ 
	u_int	msb;		/* data alignment */ 
	u_int	encoding;	/* data encoding (AUDIO_ENCODING_* below) */ 
	u_int	block_size;     /* size a block */ 
	/* Current state of device: */ 
	u_char	pause;		/* non-zero if paused, zero to resume */ 
	u_char	active;		/* non-zero if I/O is currently active */ 
};</pre>
<div class="spacer">
</div>
The <b class="name">audio</b> driver requires identical playback and recording sample rates, sample encodings, and block durations.<div class="spacer">
</div>
The <b class="var">encoding</b> parameter can have the following values:<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">AUDIO_ENCODING_ULAW</span></dt>
<dd class="list-tag" style="margin-left: 25.00ex;">
mu-law encoding, 8 bits/sample</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">AUDIO_ENCODING_ALAW</span></dt>
<dd class="list-tag" style="margin-left: 25.00ex;">
A-law encoding, 8 bits/sample</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">AUDIO_ENCODING_SLINEAR_LE</span></dt>
<dd class="list-tag" style="margin-left: 25.00ex;">
two's complement signed linear encoding with little endian byte order</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">AUDIO_ENCODING_SLINEAR_BE</span></dt>
<dd class="list-tag" style="margin-left: 25.00ex;">
two's complement signed linear encoding with big endian byte order</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">AUDIO_ENCODING_ULINEAR_LE</span></dt>
<dd class="list-tag" style="margin-left: 25.00ex;">
unsigned linear encoding with little endian byte order</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">AUDIO_ENCODING_ULINEAR_BE</span></dt>
<dd class="list-tag" style="margin-left: 25.00ex;">
unsigned linear encoding with big endian byte order</dd>
</dl>
<div class="spacer">
</div>
The <b class="var">precision</b> parameter describes the number of bits of audio data per sample. The <b class="var">bps</b> parameter describes the number of bytes of audio data per sample. The <b class="var">msb</b> parameter describes the alignment of the data in the sample. It is only meaningful when <b class="var">precision</b> / NBBY &lt; <b class="var">bps</b>. A value of 1 means the data is aligned to the most significant bit.<div class="spacer">
</div>
<b class="var">block_size</b> is the block size in bytes, which determines the frequency at which blocking <a class="link-man" href="../html2/read.html">read(2)</a>, <a class="link-man" href="../html2/write.html">write(2)</a>, or <a class="link-man" href="../html2/poll.html">poll(2)</a>, wake up. The generic <b class="name">audio</b> driver layer and the hardware driver have the opportunity to adjust this block size to get it within implementation-required limits. Normally the <b class="var">block_size</b> is recalculated when other parameters changes.<div class="spacer">
</div>
It is recommended to set <b class="var">block_size</b> at the same time as, or after, all other parameters have been set.<div class="spacer">
</div>
<b class="var">pause</b> returns the current pause/unpause state for recording or playback. For <span class="define">AUDIO_SETINFO</span>, if the pause value is specified it will either pause or unpause the particular direction. In full-duplex the pause values for both directions must be equal.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">AUDIO_SETPAR</span> <i class="farg">struct audio_swpar *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">AUDIO_GETPAR</span> <i class="farg">struct audio_swpar *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Set or get audio parameters as encoded in the <span class="type">audio_swpar</span> structure.<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
struct audio_swpar { 
	unsigned int sig;	/* if 1, encoding is signed */ 
	unsigned int le;	/* if 1, encoding is little-endian */ 
	unsigned int bits;	/* bits per sample */ 
	unsigned int bps;	/* bytes per sample */ 
	unsigned int msb;	/* if 1, bits are msb-aligned */ 
	unsigned int rate;	/* common play &amp; rec sample rate */ 
	unsigned int pchan;	/* play channels */ 
	unsigned int rchan;	/* rec channels */ 
	unsigned int nblks;	/* number of blocks in play buffer */ 
	unsigned int round;	/* common frames per block */ 
};</pre>
<div class="spacer">
</div>
When setting the device parameters with <span class="define">AUDIO_SETPAR</span>, the <span class="type">audio_swpar</span> structure should first be initialized with<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
struct audio_swpar ap; 
 
AUDIO_INITPAR(&amp;ap);</pre>
<div class="spacer">
</div>
and then only the values to be changed should be set. This ensures that the software will work with future versions of the driver. The driver will attempt to set the given parameters; if the device doesn't support them, it will choose other parameters. Then the software must call <span class="define">AUDIO_GETINFO</span> to obtain the parameters in use.<div class="spacer">
</div>
The parameters are as follows:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">bits</b></dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
Number of bits per sample: must be between 1 and 32.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">bps</b></dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
Bytes per sample; if specified, it must be large enough to hold all bits. By default it's set to the smallest power of two large enough to hold <b class="var">bits</b>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">sig</b></dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
If set (i.e. non-zero) then the samples are signed, otherwise they are unsigned.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">le</b></dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
If set, then the byte order is little endian; if not it is big endian; it's meaningful only if <b class="var">bps</b> &gt; 1.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">msb</b></dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
If set, then the <b class="var">bits</b> are aligned in the packet to the most significant bit (i.e. lower bits are padded), otherwise to the least significant bit (i.e. higher bits are padded). It's meaningful only if <b class="var">bits</b> &lt; <b class="var">bps</b> * 8.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">rchan</b></dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
The number of recorded channels; meaningful only if the device is opened for reading.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">pchan</b></dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
The number of channels playing; meaningful only if the device is opened for writing.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">rate</b></dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
The sampling frequency in Hz.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">nblks</b></dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
The number of blocks in the play buffer.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">round</b></dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
The audio block size.</dd>
</dl>
<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">AUDIO_START</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Start playback and/or recording immediately. If the device is open for writing (playback), then the play buffer must be filled with the <a class="link-man" href="../html2/write.html">write(2)</a> syscall. The buffer size is obtained by multiplying the <b class="var">nblks</b>, <b class="var">round</b>, and <b class="var">bps</b> parameters obtained with <span class="define">AUDIO_GETPAR</span>.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">AUDIO_STOP</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Stop playback and recording immediately.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">AUDIO_GETPOS</span> <i class="farg">struct audio_pos *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Fetch an atomic snapshot of device timing information in the <span class="type">audio_pos</span> structure.<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
struct audio_pos { 
	unsigned int play_pos;	/* total bytes played */ 
	unsigned int play_xrun;	/* bytes of silence inserted */ 
	unsigned int rec_pos;	/* total bytes recorded */ 
	unsigned int rec_xrun;	/* bytes dropped */ 
};</pre>
<div class="spacer">
</div>
The properties have the following meaning:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">play_pos</b></dt>
<dd class="list-tag" style="margin-left: 9.00ex;">
Total number of bytes played by the device since playback started (a.k.a the device wall clock).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">play_xrun</b></dt>
<dd class="list-tag" style="margin-left: 9.00ex;">
The number of bytes corresponding to silence played because <a class="link-man" href="../html2/write.html">write(2)</a> wasn't called fast enough.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">rec_pos</b></dt>
<dd class="list-tag" style="margin-left: 9.00ex;">
Total number of bytes recorded by the device since recording started (a.k.a the device wall clock).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">rec_xrun</b></dt>
<dd class="list-tag" style="margin-left: 9.00ex;">
The number of bytes dropped because <a class="link-man" href="../html2/read.html">read(2)</a> wasn't called fast enough.</dd>
</dl>
</dd>
</dl>
</div>
<div class="section">
<h1 id="x4d4958455220444556494345">MIXER DEVICE</h1> The <b class="name">mixer</b> device, <i class="file">/dev/mixer</i>, may be manipulated with <a class="link-man" href="../html2/ioctl.html">ioctl(2)</a> but does not support <a class="link-man" href="../html2/read.html">read(2)</a> or <a class="link-man" href="../html2/write.html">write(2)</a>. It supports the following <a class="link-man" href="../html2/ioctl.html">ioctl(2)</a> commands:<div class="spacer">
</div>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">AUDIO_GETDEV</span> <i class="farg">audio_device_t *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This command is the same as described above for the sampling devices.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">AUDIO_MIXER_READ</span> <i class="farg">mixer_ctrl_t *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">AUDIO_MIXER_WRITE</span> <i class="farg">mixer_ctrl_t *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
These commands read the current mixer state or set new mixer state for the specified device <b class="var">dev</b>. <b class="var">type</b> identifies which type of value is supplied in the <span class="type">mixer_ctrl_t *</span> argument.<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
#define AUDIO_MIXER_CLASS  0 
#define AUDIO_MIXER_ENUM   1 
#define AUDIO_MIXER_SET    2 
#define AUDIO_MIXER_VALUE  3 
typedef struct mixer_ctrl { 
	int dev;			/* input: nth device */ 
	int type; 
	union { 
		int ord;		/* enum */ 
		int mask;		/* set */ 
		mixer_level_t value;	/* value */ 
	} un; 
} mixer_ctrl_t; 
 
#define AUDIO_MIN_GAIN  0 
#define AUDIO_MAX_GAIN  255 
typedef struct mixer_level { 
	int num_channels; 
	u_char level[8];		/* [num_channels] */ 
} mixer_level_t; 
#define AUDIO_MIXER_LEVEL_MONO	0 
#define AUDIO_MIXER_LEVEL_LEFT	0 
#define AUDIO_MIXER_LEVEL_RIGHT	1</pre>
<div class="spacer">
</div>
For a mixer value, the <b class="var">value</b> field specifies both the number of channels and the values for each channel. If the channel count does not match the current channel count, the attempt to change the setting may fail (depending on the hardware device driver implementation). For an enumeration value, the <b class="var">ord</b> field should be set to one of the possible values as returned by a prior <span class="define">AUDIO_MIXER_DEVINFO</span> command. The type <span class="define">AUDIO_MIXER_CLASS</span> is only used for classifying particular <b class="name">mixer</b> device types and is not used for <span class="define">AUDIO_MIXER_READ</span> or <span class="define">AUDIO_MIXER_WRITE</span>.<div class="spacer">
</div>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">AUDIO_MIXER_DEVINFO</span> <i class="farg">mixer_devinfo_t *</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This command is used iteratively to fetch audio <b class="name">mixer</b> device information into the input/output <span class="type">mixer_devinfo_t *</span> argument. To query all the supported devices, start with an index field of 0 and continue with successive devices (1, 2, ...) until the command returns an error.<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
typedef struct mixer_devinfo { 
	int index;		/* input: nth mixer device */ 
	audio_mixer_name_t label; 
	int type; 
	int mixer_class; 
	int next, prev; 
#define AUDIO_MIXER_LAST	-1 
	union { 
		struct audio_mixer_enum { 
			int num_mem; 
			struct { 
				audio_mixer_name_t label; 
				int ord; 
			} member[32]; 
		} e; 
		struct audio_mixer_set { 
			int num_mem; 
			struct { 
				audio_mixer_name_t label; 
				int mask; 
			} member[32]; 
		} s; 
		struct audio_mixer_value { 
			audio_mixer_name_t units; 
			int num_channels; 
			int delta; 
		} v; 
	} un; 
} mixer_devinfo_t;</pre>
<div class="spacer">
</div>
The <b class="var">label</b> field identifies the name of this particular mixer control. The <b class="var">index</b> field may be used as the <b class="var">dev</b> field in <span class="define">AUDIO_MIXER_READ</span> and <span class="define">AUDIO_MIXER_WRITE</span> commands. The <b class="var">type</b> field identifies the type of this mixer control. Enumeration types are typically used for on/off style controls (e.g., a mute control) or for input/output device selection (e.g., select recording input source from CD, line in, or microphone). Set types are similar to enumeration types but any combination of the mask bits can be used.<div class="spacer">
</div>
The <b class="var">mixer_class</b> field identifies what class of control this is. This value is set to the index value used to query the class itself. The (arbitrary) value set by the hardware driver may be determined by examining the <b class="var">mixer_class</b> field of the class itself, a mixer of type <span class="define">AUDIO_MIXER_CLASS</span>. For example, a mixer level controlling the input gain on the &#8220;line in&#8221; circuit would have a <b class="var">mixer_class</b> that matches an input class device with the name &#8220;inputs&#8221; (<span class="define">AudioCinputs</span>) and would have a <b class="var">label</b> of &#8220;line&#8221; (<span class="define">AudioNline</span>). Mixer controls which control audio circuitry for a particular audio source (e.g., line-in, CD in, DAC output) are collected under the input class, while those which control all audio sources (e.g., master volume, equalization controls) are under the output class. Hardware devices capable of recording typically also have a record class, for controls that only affect recording, and also a monitor class.<div class="spacer">
</div>
The <b class="var">next</b> and <b class="var">prev</b> may be used by the hardware device driver to provide hints for the next and previous devices in a related set (for example, the line in level control would have the line in mute as its &#8220;next&#8221; value). If there is no relevant next or previous value, <span class="define">AUDIO_MIXER_LAST</span> is specified.<div class="spacer">
</div>
For <span class="define">AUDIO_MIXER_ENUM</span> mixer control types, the enumeration values and their corresponding names are filled in. For example, a mute control would return appropriate values paired with <span class="define">AudioNon</span> and <span class="define">AudioNoff</span>. For the <span class="define">AUDIO_MIXER_VALUE</span> and <span class="define">AUDIO_MIXER_SET</span> mixer control types, the channel count is returned; the units name specifies what the level controls (typical values are <span class="define">AudioNvolume</span>, <span class="define">AudioNtreble</span>, and <span class="define">AudioNbass</span>).</dd>
</dl>
<div class="spacer">
</div>
By convention, all the mixer devices can be distinguished from other mixer controls because they use a name from one of the <span class="define">AudioC*</span> string values.</div>
<div class="section">
<h1 id="x46494c4553">FILES</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="file">/dev/audio</i></dt>
<dd class="list-tag" style="margin-left: 13.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="file">/dev/audioctl</i></dt>
<dd class="list-tag" style="margin-left: 13.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="file">/dev/sound</i></dt>
<dd class="list-tag" style="margin-left: 13.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="file">/dev/mixer</i></dt>
<dd class="list-tag" style="margin-left: 13.00ex;">
</dd>
</dl>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html1/aucat.html">aucat(1)</a>, <a class="link-man" href="../html1/audioctl.html">audioctl(1)</a>, <a class="link-man" href="../html1/cdio.html">cdio(1)</a>, <a class="link-man" href="../html1/mixerctl.html">mixerctl(1)</a>, <a class="link-man" href="../html2/ioctl.html">ioctl(2)</a>, <a class="link-man" href="../html3/sio_open.html">sio_open(3)</a>, <a class="link-man" href="../html4/ac97.html">ac97(4)</a>, <a class="link-man" href="../html4/uaudio.html">uaudio(4)</a>, <a class="link-man" href="../html9/audio.html">audio(9)</a></div>
</div>
</body>
</html>

