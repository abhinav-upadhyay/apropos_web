<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
DIVERT(4)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">divert</b> &#8212; <span class="desc">kernel packet diversion mechanism</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/types.h</a>&gt;</b><br/>
<b class="includes">#include &lt;<a class="link-includes">sys/socket.h</a>&gt;</b><br/>
<b class="includes">#include &lt;<a class="link-includes">netinet/in.h</a>&gt;</b><div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">socket</b>(<i class="farg" style="white-space:nowrap;">AF_INET</i>, <i class="farg" style="white-space:nowrap;">SOCK_RAW</i>, <i class="farg" style="white-space:nowrap;">IPPROTO_DIVERT</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">socket</b>(<i class="farg" style="white-space:nowrap;">AF_INET6</i>, <i class="farg" style="white-space:nowrap;">SOCK_RAW</i>, <i class="farg" style="white-space:nowrap;">IPPROTO_DIVERT</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> Divert sockets are part of a mechanism completely integrated with <a class="link-man" href="../html4/pf.html">pf(4)</a> that queues raw packets from the kernel stack to userspace applications, and vice versa.<div class="spacer">
</div>
A divert socket must be bound to a divert port through <a class="link-man" href="../html2/bind.html">bind(2)</a>, which only the superuser can do. Divert ports have their own number space, completely separated from <a class="link-man" href="../html4/tcp.html">tcp(4)</a> and <a class="link-man" href="../html4/udp.html">udp(4)</a>. When <a class="link-man" href="../html4/pf.html">pf(4)</a> processes a packet that matches a rule with the <i class="arg">divert-packet</i> parameter (see <a class="link-man" href="../html5/pf.conf.html">pf.conf(5)</a> for details) it is sent to the divert socket listening on the divert port specified in the rule. Note that <i class="arg">divert-packet</i> should not be confused with <i class="arg">divert-to</i> or <i class="arg">divert-reply</i>, which do not use divert sockets. <a class="link-man" href="../html4/pf.html">pf(4)</a> reassembles TCP streams by default (if IP reassembly is not disabled) before sending them to the divert sockets. If there are no divert sockets listening, the packets are dropped.<div class="spacer">
</div>
Packets can be read via <a class="link-man" href="../html2/read.html">read(2)</a>, <a class="link-man" href="../html2/recv.html">recv(2)</a>, or <a class="link-man" href="../html2/recvfrom.html">recvfrom(2)</a> from the divert socket. The application that is processing the packets can then reinject them into the kernel. After being reinjected, inbound and outbound packets are treated differently. Inbound packets are added to the relevant input queue and a soft interrupt is scheduled to signal that a new packet is ready to be processed; outbound ones are processed directly by the relevant IPv4/IPv6 output function. Since the userspace application could have modified the packets, upon reinjection basic sanity checks are done to ensure that the packets are still valid. The packets' IPv4 and protocol checksums (TCP, UDP, ICMP, and ICMPv6) are also recalculated.<div class="spacer">
</div>
Writing to a divert socket can be achieved using <a class="link-man" href="../html2/sendto.html">sendto(2)</a> and it will skip <a class="link-man" href="../html4/pf.html">pf(4)</a> filters to avoid loops. A diverted packet that is not reinjected into the kernel stack is lost.<div class="spacer">
</div>
Receive and send divert socket buffer space can be tuned through <a class="link-man" href="../html8/sysctl.html">sysctl(8)</a>. <a class="link-man" href="../html1/netstat.html">netstat(1)</a> shows information relevant to divert sockets.<div class="spacer">
</div>
The IP_DIVERTFL socket option on the IPPROTO_IP level controls whether both inbound and outbound packets are diverted (the default) or only packets travelling in one direction. It cannot be reset once set. Valid values are <span class="define">IPPROTO_DIVERT_INIT</span> for the direction of the initial packet of a flow, and <span class="define">IPPROTO_DIVERT_RESP</span> for the direction of the response packets.</div>
<div class="section">
<h1 id="x4558414d504c4553">EXAMPLES</h1> The following PF rule queues outbound IPv4 packets to TCP port 80, as well as the return traffic, on the em0 interface to divert port 700:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
pass out on em0 inet proto tcp to port 80 divert-packet port 700</pre>
<div class="spacer">
</div>
The following program reads packets on divert port 700 and reinjects them back into the kernel. This program does not perform any processing of the packets, apart from discarding invalid IP packets.<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
#include &lt;sys/types.h&gt; 
#include &lt;sys/socket.h&gt; 
#include &lt;netinet/in.h&gt; 
#include &lt;netinet/ip.h&gt; 
#include &lt;netinet/tcp.h&gt; 
#include &lt;arpa/inet.h&gt; 
#include &lt;stdio.h&gt; 
#include &lt;string.h&gt; 
#include &lt;err.h&gt; 
 
#define DIVERT_PORT 700 
 
int 
main(int argc, char *argv[]) 
{ 
	int fd, s; 
	struct sockaddr_in sin; 
	socklen_t sin_len; 
 
	fd = socket(AF_INET, SOCK_RAW, IPPROTO_DIVERT); 
	if (fd == -1) 
		err(1, &quot;socket&quot;); 
 
	memset(&amp;sin, 0, sizeof(sin)); 
	sin.sin_family = AF_INET; 
	sin.sin_port = htons(DIVERT_PORT); 
	sin.sin_addr.s_addr = 0; 
 
	sin_len = sizeof(struct sockaddr_in); 
 
	s = bind(fd, (struct sockaddr *) &amp;sin, sin_len); 
	if (s == -1) 
		err(1, &quot;bind&quot;); 
 
	for (;;) { 
		ssize_t n; 
		char packet[IP_MAXPACKET]; 
		struct ip *ip; 
		struct tcphdr *th; 
		int hlen; 
		char src[48], dst[48]; 
 
		memset(packet, 0, sizeof(packet)); 
		n = recvfrom(fd, packet, sizeof(packet), 0, 
		    (struct sockaddr *) &amp;sin, &amp;sin_len); 
		if (n == -1) { 
			warn(&quot;recvfrom&quot;); 
			continue; 
		} 
		if (n &lt; sizeof(struct ip)) { 
			warnx(&quot;packet is too short&quot;); 
			continue; 
		} 
 
		ip = (struct ip *) packet; 
		hlen = ip-&gt;ip_hl &lt;&lt; 2; 
		if (hlen &lt; sizeof(struct ip) || ntohs(ip-&gt;ip_len) &lt; hlen || 
		    n &lt; ntohs(ip-&gt;ip_len)) { 
			warnx(&quot;invalid IPv4 packet&quot;); 
			continue; 
		} 
 
		th = (struct tcphdr *) (packet + hlen); 
 
		if (inet_ntop(AF_INET, &amp;ip-&gt;ip_src, src, 
		    sizeof(src)) == NULL) 
			(void)strlcpy(src, &quot;?&quot;, sizeof(src)); 
 
		if (inet_ntop(AF_INET, &amp;ip-&gt;ip_dst, dst, 
		    sizeof(dst)) == NULL) 
			(void)strlcpy(dst, &quot;?&quot;, sizeof(dst)); 
 
		printf(&quot;%s:%u -&gt; %s:%u\n&quot;, 
		    src, 
		    ntohs(th-&gt;th_sport), 
		    dst, 
		    ntohs(th-&gt;th_dport) 
		); 
 
		n = sendto(fd, packet, n, 0, (struct sockaddr *) &amp;sin, 
		    sin_len); 
		if (n == -1) 
			warn(&quot;sendto&quot;); 
	} 
 
	return 0; 
}</pre>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html2/setsockopt.html">setsockopt(2)</a>, <a class="link-man" href="../html2/socket.html">socket(2)</a>, <a class="link-man" href="../html4/ip.html">ip(4)</a>, <a class="link-man" href="../html5/pf.conf.html">pf.conf(5)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The <b class="name">divert</b> protocol first appeared in <span class="unix">OpenBSD&#160;4.7</span>.</div>
</div>
</body>
</html>

