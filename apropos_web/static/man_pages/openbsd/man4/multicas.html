<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
MULTICAST(4)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">multicast</b> &#8212; <span class="desc">Multicast Routing</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="config">options MROUTING</b><div class="spacer">
</div>
<br/>
<b class="includes">#include &lt;<a class="link-includes">sys/types.h</a>&gt;</b><br/>
<b class="includes">#include &lt;<a class="link-includes">sys/socket.h</a>&gt;</b><br/>
<b class="includes">#include &lt;<a class="link-includes">netinet/in.h</a>&gt;</b><br/>
<b class="includes">#include &lt;<a class="link-includes">netinet/ip_mroute.h</a>&gt;</b><br/>
<b class="includes">#include &lt;<a class="link-includes">netinet6/ip6_mroute.h</a>&gt;</b><div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">getsockopt</b>(<i class="farg" style="white-space:nowrap;">int s</i>, <i class="farg" style="white-space:nowrap;">IPPROTO_IP</i>, <i class="farg" style="white-space:nowrap;">MRT_INIT</i>, <i class="farg" style="white-space:nowrap;">void *optval</i>, <i class="farg" style="white-space:nowrap;">socklen_t *optlen</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">setsockopt</b>(<i class="farg" style="white-space:nowrap;">int s</i>, <i class="farg" style="white-space:nowrap;">IPPROTO_IP</i>, <i class="farg" style="white-space:nowrap;">MRT_INIT</i>, <i class="farg" style="white-space:nowrap;">const void *optval</i>, <i class="farg" style="white-space:nowrap;">socklen_t optlen</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">getsockopt</b>(<i class="farg" style="white-space:nowrap;">int s</i>, <i class="farg" style="white-space:nowrap;">IPPROTO_IPV6</i>, <i class="farg" style="white-space:nowrap;">MRT6_INIT</i>, <i class="farg" style="white-space:nowrap;">void *optval</i>, <i class="farg" style="white-space:nowrap;">socklen_t *optlen</i>);<div class="spacer">
</div>
<i class="ftype">int</i><br/>
<b class="fname">setsockopt</b>(<i class="farg" style="white-space:nowrap;">int s</i>, <i class="farg" style="white-space:nowrap;">IPPROTO_IPV6</i>, <i class="farg" style="white-space:nowrap;">MRT6_INIT</i>, <i class="farg" style="white-space:nowrap;">const void *optval</i>, <i class="farg" style="white-space:nowrap;">socklen_t optlen</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> Multicast routing is used to efficiently propagate data packets to a set of multicast listeners in multipoint networks. If unicast is used to replicate the data to all listeners, then some of the network links may carry multiple copies of the same data packets. With multicast routing, the overhead is reduced to one copy (at most) per network link.<div class="spacer">
</div>
All multicast-capable routers must run a common multicast routing protocol. The Distance Vector Multicast Routing Protocol (DVMRP) was the first developed multicast routing protocol. Later, other protocols such as Multicast Extensions to OSPF (MOSPF), Core Based Trees (CBT), Protocol Independent Multicast - Sparse Mode (PIM-SM), and Protocol Independent Multicast - Dense Mode (PIM-DM) were developed as well.<div class="spacer">
</div>
To start multicast routing, the user must enable multicast forwarding via the <a class="link-man" href="../html8/sysctl.html">sysctl(8)</a> variables <b class="var">net.inet.ip.mforwarding</b> and/or <b class="var">net.inet.ip6.mforwarding</b>. The user must also run a multicast routing capable user-level process, such as <a class="link-man" href="../html8/mrouted.html">mrouted(8)</a>. From a developer's point of view, the programming guide described in the <i class="link-sec"><a class="link-sec" href="#x50726f6772616d6d696e67204775696465">Programming Guide</a></i> section should be used to control the multicast forwarding in the kernel.<div class="subsection">
<h2 id="x50726f6772616d6d696e67204775696465">Programming Guide</h2> This section provides information about the basic multicast routing API. The so-called &#8220;advanced multicast API&#8221; is described in the <i class="link-sec"><a class="link-sec" href="#x416476616e636564204d756c746963617374204150492050726f6772616d6d696e67204775696465">Advanced Multicast API Programming Guide</a></i> section.<div class="spacer">
</div>
First, a multicast routing socket must be open. That socket would be used to control the multicast forwarding in the kernel. Note that most operations below require certain privilege (i.e., root privilege):<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
/* IPv4 */ 
int mrouter_s4; 
mrouter_s4 = socket(AF_INET, SOCK_RAW, IPPROTO_IGMP);</pre>
<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
int mrouter_s6; 
mrouter_s6 = socket(AF_INET6, SOCK_RAW, IPPROTO_ICMPV6);</pre>
<div class="spacer">
</div>
Note that if the router needs to open an IGMP or ICMPv6 socket (IPv4 or IPv6, respectively) for sending or receiving of IGMP or MLD multicast group membership messages, then the same <b class="var">mrouter_s4</b> or <b class="var">mrouter_s6</b> sockets should be used for sending and receiving respectively IGMP or MLD messages. In the case of <span class="unix">-derivedBSD</span> kernels, it may be possible to open separate sockets for IGMP or MLD messages only. However, some other kernels (e.g., Linux) require that the multicast routing socket must be used for sending and receiving of IGMP or MLD messages. Therefore, for portability reasons, the multicast routing socket should be reused for IGMP and MLD messages as well.<div class="spacer">
</div>
After the multicast routing socket is open, it can be used to enable or disable multicast forwarding in the kernel:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
/* IPv4 */ 
int v = 1;        /* 1 to enable, or 0 to disable */ 
setsockopt(mrouter_s4, IPPROTO_IP, MRT_INIT, (void *)&amp;v, sizeof(v));</pre>
<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
/* IPv6 */ 
int v = 1;        /* 1 to enable, or 0 to disable */ 
setsockopt(mrouter_s6, IPPROTO_IPV6, MRT6_INIT, (void *)&amp;v, sizeof(v)); 
... 
/* If necessary, filter all ICMPv6 messages */ 
struct icmp6_filter filter; 
ICMP6_FILTER_SETBLOCKALL(&amp;filter); 
setsockopt(mrouter_s6, IPPROTO_ICMPV6, ICMP6_FILTER, (void *)&amp;filter, 
           sizeof(filter));</pre>
<div class="spacer">
</div>
After multicast forwarding is enabled, the multicast routing socket can be used to enable PIM processing in the kernel if either PIM-SM or PIM-DM are being used (see <a class="link-man" href="../html4/pim.html">pim(4)</a>).<div class="spacer">
</div>
For each network interface (e.g., physical or a virtual tunnel) that would be used for multicast forwarding, a corresponding multicast interface must be added to the kernel:<div class="spacer">
</div>
<pre style="margin-left: 3.00ex;" class="lit display">
/* IPv4 */ 
struct vifctl vc; 
memset(&amp;vc, 0, sizeof(vc)); 
/* Assign all vifctl fields as appropriate */ 
vc.vifc_vifi = vif_index; 
vc.vifc_flags = vif_flags; 
vc.vifc_threshold = min_ttl_threshold; 
vc.vifc_rate_limit = max_rate_limit; 
memcpy(&amp;vc.vifc_lcl_addr, &amp;vif_local_address, sizeof(vc.vifc_lcl_addr)); 
if (vc.vifc_flags &amp; VIFF_TUNNEL) 
    memcpy(&amp;vc.vifc_rmt_addr, &amp;vif_remote_address, 
           sizeof(vc.vifc_rmt_addr)); 
setsockopt(mrouter_s4, IPPROTO_IP, MRT_ADD_VIF, (void *)&amp;vc, 
           sizeof(vc));</pre>
<div class="spacer">
</div>
The <b class="var">vif_index</b> must be unique per vif. The <b class="var">vif_flags</b> contains the <span class="define">VIFF_*</span> flags as defined in <b class="includes">&lt;<a class="link-includes">netinet/ip_mroute.h</a>&gt;</b>. The <b class="var">min_ttl_threshold</b> contains the minimum TTL a multicast data packet must have to be forwarded on that vif. Typically, it would be 1. The <b class="var">max_rate_limit</b> contains the maximum rate (in bits/s) of the multicast data packets forwarded on that vif. A value of 0 means no limit. The <b class="var">vif_local_address</b> contains the local IP address of the corresponding local interface. The <b class="var">vif_remote_address</b> contains the remote IP address for DVMRP multicast tunnels.<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
/* IPv6 */ 
struct mif6ctl mc; 
memset(&amp;mc, 0, sizeof(mc)); 
/* Assign all mif6ctl fields as appropriate */ 
mc.mif6c_mifi = mif_index; 
mc.mif6c_flags = mif_flags; 
mc.mif6c_pifi = pif_index; 
setsockopt(mrouter_s6, IPPROTO_IPV6, MRT6_ADD_MIF, (void *)&amp;mc, 
           sizeof(mc));</pre>
<div class="spacer">
</div>
The <b class="var">mif_index</b> must be unique per vif. The <b class="var">mif_flags</b> contains the <span class="define">MIFF_*</span> flags as defined in <b class="includes">&lt;<a class="link-includes">netinet6/ip6_mroute.h</a>&gt;</b>. The <b class="var">pif_index</b> is the physical interface index of the corresponding local interface.<div class="spacer">
</div>
A multicast interface is deleted by:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
/* IPv4 */ 
vifi_t vifi = vif_index; 
setsockopt(mrouter_s4, IPPROTO_IP, MRT_DEL_VIF, (void *)&amp;vifi, 
           sizeof(vifi));</pre>
<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
/* IPv6 */ 
mifi_t mifi = mif_index; 
setsockopt(mrouter_s6, IPPROTO_IPV6, MRT6_DEL_MIF, (void *)&amp;mifi, 
           sizeof(mifi));</pre>
<div class="spacer">
</div>
After multicast forwarding is enabled, and the multicast virtual interfaces have been added, the kernel may deliver upcall messages (also called signals later in this text) on the multicast routing socket that was open earlier with <span class="define">MRT_INIT</span> or <span class="define">MRT6_INIT</span>. The IPv4 upcalls have a <span class="type">struct igmpmsg</span> header (see <b class="includes">&lt;<a class="link-includes">netinet/ip_mroute.h</a>&gt;</b>) with the <b class="var">im_mbz</b> field set to zero. Note that this header follows the structure of <span class="type">struct ip</span> with the protocol field <b class="var">ip_p</b> set to zero. The IPv6 upcalls have a <span class="type">struct mrt6msg</span> header (see <b class="includes">&lt;<a class="link-includes">netinet6/ip6_mroute.h</a>&gt;</b>) with the <b class="var">im6_mbz</b> field set to zero. Note that this header follows the structure of <span class="type">struct ip6_hdr</span> with the next header field <b class="var">ip6_nxt</b> set to zero.<div class="spacer">
</div>
The upcall header contains the <b class="var">im_msgtype</b> and <b class="var">im6_msgtype</b> fields, with the type of the upcall <span class="define">IGMPMSG_*</span> and <span class="define">MRT6MSG_*</span> for IPv4 and IPv6, respectively. The values of the rest of the upcall header fields and the body of the upcall message depend on the particular upcall type.<div class="spacer">
</div>
If the upcall message type is <span class="define">IGMPMSG_NOCACHE</span> or <span class="define">MRT6MSG_NOCACHE</span>, this is an indication that a multicast packet has reached the multicast router, but the router has no forwarding state for that packet. Typically, the upcall would be a signal for the multicast routing user-level process to install the appropriate Multicast Forwarding Cache (MFC) entry in the kernel.<div class="spacer">
</div>
An MFC entry is added by:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
/* IPv4 */ 
struct mfcctl mc; 
memset(&amp;mc, 0, sizeof(mc)); 
memcpy(&amp;mc.mfcc_origin, &amp;source_addr, sizeof(mc.mfcc_origin)); 
memcpy(&amp;mc.mfcc_mcastgrp, &amp;group_addr, sizeof(mc.mfcc_mcastgrp)); 
mc.mfcc_parent = iif_index; 
for (i = 0; i &lt; maxvifs; i++) 
    mc.mfcc_ttls[i] = oifs_ttl[i]; 
setsockopt(mrouter_s4, IPPROTO_IP, MRT_ADD_MFC, 
           (void *)&amp;mc, sizeof(mc));</pre>
<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
/* IPv6 */ 
struct mf6cctl mc; 
memset(&amp;mc, 0, sizeof(mc)); 
memcpy(&amp;mc.mf6cc_origin, &amp;source_addr, sizeof(mc.mf6cc_origin)); 
memcpy(&amp;mc.mf6cc_mcastgrp, &amp;group_addr, sizeof(mf6cc_mcastgrp)); 
mc.mf6cc_parent = iif_index; 
for (i = 0; i &lt; maxvifs; i++) 
    if (oifs_ttl[i] &gt; 0) 
        IF_SET(i, &amp;mc.mf6cc_ifset); 
setsockopt(mrouter_s4, IPPROTO_IPV6, MRT6_ADD_MFC, 
           (void *)&amp;mc, sizeof(mc));</pre>
<div class="spacer">
</div>
The <b class="var">source_addr</b> and <b class="var">group_addr</b> fields are the source and group address of the multicast packet (as set in the upcall message). The <b class="var">iif_index</b> is the virtual interface index of the multicast interface the multicast packets for this specific source and group address should be received on. The <b class="var">oifs_ttl[]</b> array contains the minimum TTL (per interface) a multicast packet should have to be forwarded on an outgoing interface. If the TTL value is zero, the corresponding interface is not included in the set of outgoing interfaces. Note that for IPv6 only the set of outgoing interfaces can be specified.<div class="spacer">
</div>
An MFC entry is deleted by:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
/* IPv4 */ 
struct mfcctl mc; 
memset(&amp;mc, 0, sizeof(mc)); 
memcpy(&amp;mc.mfcc_origin, &amp;source_addr, sizeof(mc.mfcc_origin)); 
memcpy(&amp;mc.mfcc_mcastgrp, &amp;group_addr, sizeof(mc.mfcc_mcastgrp)); 
setsockopt(mrouter_s4, IPPROTO_IP, MRT_DEL_MFC, 
           (void *)&amp;mc, sizeof(mc));</pre>
<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
/* IPv6 */ 
struct mf6cctl mc; 
memset(&amp;mc, 0, sizeof(mc)); 
memcpy(&amp;mc.mf6cc_origin, &amp;source_addr, sizeof(mc.mf6cc_origin)); 
memcpy(&amp;mc.mf6cc_mcastgrp, &amp;group_addr, sizeof(mf6cc_mcastgrp)); 
setsockopt(mrouter_s4, IPPROTO_IPV6, MRT6_DEL_MFC, 
           (void *)&amp;mc, sizeof(mc));</pre>
<div class="spacer">
</div>
The following method can be used to get various statistics per installed MFC entry in the kernel (e.g., the number of forwarded packets per source and group address):<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
/* IPv4 */ 
struct sioc_sg_req sgreq; 
memset(&amp;sgreq, 0, sizeof(sgreq)); 
memcpy(&amp;sgreq.src, &amp;source_addr, sizeof(sgreq.src)); 
memcpy(&amp;sgreq.grp, &amp;group_addr, sizeof(sgreq.grp)); 
ioctl(mrouter_s4, SIOCGETSGCNT, &amp;sgreq);</pre>
<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
/* IPv6 */ 
struct sioc_sg_req6 sgreq; 
memset(&amp;sgreq, 0, sizeof(sgreq)); 
memcpy(&amp;sgreq.src, &amp;source_addr, sizeof(sgreq.src)); 
memcpy(&amp;sgreq.grp, &amp;group_addr, sizeof(sgreq.grp)); 
ioctl(mrouter_s6, SIOCGETSGCNT_IN6, &amp;sgreq);</pre>
<div class="spacer">
</div>
The following method can be used to get various statistics per multicast virtual interface in the kernel (e.g., the number of forwarded packets per interface):<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
/* IPv4 */ 
struct sioc_vif_req vreq; 
memset(&amp;vreq, 0, sizeof(vreq)); 
vreq.vifi = vif_index; 
ioctl(mrouter_s4, SIOCGETVIFCNT, &amp;vreq);</pre>
<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
/* IPv6 */ 
struct sioc_mif_req6 mreq; 
memset(&amp;mreq, 0, sizeof(mreq)); 
mreq.mifi = vif_index; 
ioctl(mrouter_s6, SIOCGETMIFCNT_IN6, &amp;mreq);</pre>
</div>
<div class="subsection">
<h2 id="x416476616e636564204d756c746963617374204150492050726f6772616d6d696e67204775696465">Advanced Multicast API Programming Guide</h2> Adding new features to the kernel makes it difficult to preserve backward compatibility (binary and API), and at the same time to allow user-level processes to take advantage of the new features (if the kernel supports them).<div class="spacer">
</div>
One of the mechanisms that allows preserving the backward compatibility is a sort of negotiation between the user-level process and the kernel:<ol style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-enum">
<li class="list-enum" style="margin-top: 1.00em;">
The user-level process tries to enable in the kernel the set of new features (and the corresponding API) it would like to use.</li>
<li class="list-enum" style="margin-top: 1.00em;">
The kernel returns the (sub)set of features it knows about and is willing to be enabled.</li>
<li class="list-enum" style="margin-top: 1.00em;">
The user-level process uses only that set of features the kernel has agreed on.</li>
</ol>
<div class="spacer">
</div>
To support backward compatibility, if the user-level process does not ask for any new features, the kernel defaults to the basic multicast API (see the <i class="link-sec"><a class="link-sec" href="#x50726f6772616d6d696e67204775696465">Programming Guide</a></i> section). Currently, the advanced multicast API exists only for IPv4; in the future there will be IPv6 support as well.<div class="spacer">
</div>
Below is a summary of the expandable API solution. Note that all new options and structures are defined in <b class="includes">&lt;<a class="link-includes">netinet/ip_mroute.h</a>&gt;</b> and <b class="includes">&lt;<a class="link-includes">netinet6/ip6_mroute.h</a>&gt;</b>, unless stated otherwise.<div class="spacer">
</div>
The user-level process uses new <b class="fname">getsockopt</b>()/<b class="fname">setsockopt</b>() options to perform the API features negotiation with the kernel. This negotiation must be performed right after the multicast routing socket is open. The set of desired/allowed features is stored in a bitset (currently, in <span class="type">uint32_t</span> i.e., maximum of 32 new features). The new <b class="fname">getsockopt</b>()/<b class="fname">setsockopt</b>() options are <span class="define">MRT_API_SUPPORT</span> and <span class="define">MRT_API_CONFIG</span>. An example:<div class="spacer">
</div>
<pre style="margin-left: 3.00ex;" class="lit display">
uint32_t v; 
getsockopt(sock, IPPROTO_IP, MRT_API_SUPPORT, (void *)&amp;v, sizeof(v));</pre>
<div class="spacer">
</div>
This would set <b class="var">v</b> to the pre-defined bits that the kernel API supports. The eight least significant bits in <span class="type">uint32_t</span> are the same as the eight possible flags <span class="define">MRT_MFC_FLAGS_*</span> that can be used in <b class="var">mfcc_flags</b> as part of the new definition of <span class="type">struct mfcctl</span> (see below about those flags), which leaves 24 flags for other new features. The value returned by <b class="fname">getsockopt</b>(<i class="farg">MRT_API_SUPPORT</i>) is read-only; in other words, <b class="fname">setsockopt</b>(<i class="farg">MRT_API_SUPPORT</i>) would fail.<div class="spacer">
</div>
To modify the API, and to set some specific feature in the kernel, then:<div class="spacer">
</div>
<pre style="margin-left: 3.00ex;" class="lit display">
uint32_t v = MRT_MFC_FLAGS_DISABLE_WRONGVIF; 
if (setsockopt(sock, IPPROTO_IP, MRT_API_CONFIG, (void *)&amp;v, sizeof(v)) 
    != 0) { 
    return (ERROR); 
} 
if (v &amp; MRT_MFC_FLAGS_DISABLE_WRONGVIF) 
    return (OK);	/* Success */ 
else 
    return (ERROR);</pre>
<div class="spacer">
</div>
In other words, when <b class="fname">setsockopt</b>(<i class="farg">MRT_API_CONFIG</i>) is called, the argument to it specifies the desired set of features to be enabled in the API and the kernel. The return value in <b class="var">v</b> is the actual (sub)set of features that were enabled in the kernel. To obtain later the same set of features that were enabled, use:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
getsockopt(sock, IPPROTO_IP, MRT_API_CONFIG, (void *)&amp;v, sizeof(v));</pre>
<div class="spacer">
</div>
The set of enabled features is global. In other words, <b class="fname">setsockopt</b>(<i class="farg">MRT_API_CONFIG</i>) should be called right after <b class="fname">setsockopt</b>(<i class="farg">MRT_INIT</i>).<div class="spacer">
</div>
Currently, the following set of new features is defined:<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
#define	MRT_MFC_FLAGS_DISABLE_WRONGVIF (1 &lt;&lt; 0)/*disable WRONGVIF signals*/ 
#define	MRT_MFC_FLAGS_BORDER_VIF   (1 &lt;&lt; 1)  /* border vif              */ 
#define MRT_MFC_RP                 (1 &lt;&lt; 8)  /* enable RP address	*/ 
#define MRT_MFC_BW_UPCALL          (1 &lt;&lt; 9)  /* enable bw upcalls	*/</pre>
<div class="spacer">
</div>
The advanced multicast API uses a newly defined <span class="type">struct mfcctl2</span> instead of the traditional <span class="type">struct mfcctl</span>. The original <span class="type">struct mfcctl</span> is kept as is. The new <span class="type">struct mfcctl2</span> is:<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
/* 
 * The new argument structure for MRT_ADD_MFC and MRT_DEL_MFC overlays 
 * and extends the old struct mfcctl. 
 */ 
struct mfcctl2 { 
        /* the mfcctl fields */ 
        struct in_addr  mfcc_origin;       /* ip origin of mcasts       */ 
        struct in_addr  mfcc_mcastgrp;     /* multicast group associated*/ 
        vifi_t          mfcc_parent;       /* incoming vif              */ 
        u_char          mfcc_ttls[MAXVIFS];/* forwarding ttls on vifs   */ 
 
        /* extension fields */ 
        uint8_t         mfcc_flags[MAXVIFS];/* the MRT_MFC_FLAGS_* flags*/ 
        struct in_addr  mfcc_rp;            /* the RP address           */ 
};</pre>
<div class="spacer">
</div>
The new fields are <b class="var">mfcc_flags[MAXVIFS]</b> and <b class="var">mfcc_rp</b>. Note that for compatibility reasons they are added at the end.<div class="spacer">
</div>
The <b class="var">mfcc_flags[MAXVIFS]</b> field is used to set various flags per interface per (S,G) entry. Currently, the defined flags are:<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
#define	MRT_MFC_FLAGS_DISABLE_WRONGVIF (1 &lt;&lt; 0)/*disable WRONGVIF signals*/ 
#define	MRT_MFC_FLAGS_BORDER_VIF       (1 &lt;&lt; 1) /* border vif          */</pre>
<div class="spacer">
</div>
The <span class="define">MRT_MFC_FLAGS_DISABLE_WRONGVIF</span> flag is used to explicitly disable the <span class="define">IGMPMSG_WRONGVIF</span> kernel signal at the (S,G) granularity if a multicast data packet arrives on the wrong interface. Usually this signal is used to complete the shortest-path switch for PIM-SM multicast routing, or to trigger a PIM assert message. However, it should not be delivered for interfaces that are not set in the outgoing interface, and that are not expecting to become an incoming interface. Hence, if the <span class="define">MRT_MFC_FLAGS_DISABLE_WRONGVIF</span> flag is set for some of the interfaces, then a data packet that arrives on that interface for that MFC entry will NOT trigger a WRONGVIF signal. If that flag is not set, then a signal is triggered (the default action).<div class="spacer">
</div>
The <span class="define">MRT_MFC_FLAGS_BORDER_VIF</span> flag is used to specify whether the Border-bit in PIM Register messages should be set (when the Register encapsulation is performed inside the kernel). If it is set for the special PIM Register kernel virtual interface (see <a class="link-man" href="../html4/pim.html">pim(4)</a>), the Border-bit in the Register messages sent to the RP will be set.<div class="spacer">
</div>
The remaining six bits are reserved for future usage.<div class="spacer">
</div>
The <b class="var">mfcc_rp</b> field is used to specify the RP address (for PIM-SM multicast routing) for a multicast group G if we want to perform kernel-level PIM Register encapsulation. The <b class="var">mfcc_rp</b> field is used only if the <span class="define">MRT_MFC_RP</span> advanced API flag/capability has been successfully set by <b class="fname">setsockopt</b>(<i class="farg">MRT_API_CONFIG</i>).<div class="spacer">
</div>
If the <span class="define">MRT_MFC_RP</span> flag was successfully set by <b class="fname">setsockopt</b>(<i class="farg">MRT_API_CONFIG</i>), then the kernel will attempt to perform the PIM Register encapsulation itself instead of sending the multicast data packets to user level (inside <span class="define">IGMPMSG_WHOLEPKT</span> upcalls) for user-level encapsulation. The RP address would be taken from the <b class="var">mfcc_rp</b> field inside the new <span class="type">struct mfcctl2</span>. However, even if the <span class="define">MRT_MFC_RP</span> flag was successfully set, if the <b class="var">mfcc_rp</b> field was set to <span class="define">INADDR_ANY</span>, then the kernel will still deliver an <span class="define">IGMPMSG_WHOLEPKT</span> upcall with the multicast data packet to the user-level process.<div class="spacer">
</div>
In addition, if the multicast data packet is too large to fit within a single IP packet after the PIM Register encapsulation (e.g., if its size was on the order of 65500 bytes), the data packet will be fragmented, and then each of the fragments will be encapsulated separately. Note that typically a multicast data packet can be that large only if it was originated locally from the same hosts that performs the encapsulation; otherwise the transmission of the multicast data packet over Ethernet for example would have fragmented it into much smaller pieces.<div class="spacer">
</div>
Typically, a multicast routing user-level process would need to know the forwarding bandwidth for some data flow. For example, the multicast routing process may want to time out idle MFC entries, or for PIM-SM it can initiate (S,G) shortest-path switch if the bandwidth rate is above a threshold for example.<div class="spacer">
</div>
The original solution for measuring the bandwidth of a dataflow was that a user-level process would periodically query the kernel about the number of forwarded packets/bytes per (S,G), and then based on those numbers it would estimate whether a source has been idle, or whether the source's transmission bandwidth is above a threshold. That solution is far from being scalable, hence the need for a new mechanism for bandwidth monitoring.<div class="spacer">
</div>
Below is a description of the bandwidth monitoring mechanism.<ul style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-bul">
<li class="list-bul" style="margin-top: 1.00em;">
If the bandwidth of a data flow satisfies some pre-defined filter, the kernel delivers an upcall on the multicast routing socket to the multicast routing process that has installed that filter.</li>
<li class="list-bul" style="margin-top: 1.00em;">
The bandwidth-upcall filters are installed per (S,G). There can be more than one filter per (S,G).</li>
<li class="list-bul" style="margin-top: 1.00em;">
Instead of supporting all possible comparison operations (i.e., &lt; &lt;= == != &gt; &gt;= ), there is support only for the &lt;= and &gt;= operations, because this makes the kernel-level implementation simpler, and because practically we need only those two. Furthermore, the missing operations can be simulated by secondary user-level filtering of those &lt;= and &gt;= filters. For example, to simulate !=, then we need to install filter &#8220;bw &lt;= 0xffffffff&#8221;, and after an upcall is received, we need to check whether &#8220;measured_bw != expected_bw&#8221;.</li>
<li class="list-bul" style="margin-top: 1.00em;">
The bandwidth-upcall mechanism is enabled by <b class="fname">setsockopt</b>(<i class="farg">MRT_API_CONFIG</i>) for the <span class="define">MRT_MFC_BW_UPCALL</span> flag.</li>
<li class="list-bul" style="margin-top: 1.00em;">
The bandwidth-upcall filters are added/deleted by the new <b class="fname">setsockopt</b>(<i class="farg">MRT_ADD_BW_UPCALL</i>) and <b class="fname">setsockopt</b>(<i class="farg">MRT_DEL_BW_UPCALL</i>) respectively (with the appropriate <span class="type">struct bw_upcall</span> argument of course).</li>
</ul>
<div class="spacer">
</div>
From an application point of view, a developer needs to know about the following:<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
/* 
 * Structure for installing or delivering an upcall if the 
 * measured bandwidth is above or below a threshold. 
 * 
 * User programs (e.g. daemons) may have a need to know when the 
 * bandwidth used by some data flow is above or below some threshold. 
 * This interface allows the userland to specify the threshold (in 
 * bytes and/or packets) and the measurement interval. Flows are 
 * all packet with the same source and destination IP address. 
 * At the moment the code is only used for multicast destinations 
 * but there is nothing that prevents its use for unicast. 
 * 
 * The measurement interval cannot be shorter than some Tmin (3s). 
 * The threshold is set in packets and/or bytes per_interval. 
 * 
 * Measurement works as follows: 
 * 
 * For &gt;= measurements: 
 * The first packet marks the start of a measurement interval. 
 * During an interval we count packets and bytes, and when we 
 * pass the threshold we deliver an upcall and we are done. 
 * The first packet after the end of the interval resets the 
 * count and restarts the measurement. 
 * 
 * For &lt;= measurement: 
 * We start a timer to fire at the end of the interval, and 
 * then for each incoming packet we count packets and bytes. 
 * When the timer fires, we compare the value with the threshold, 
 * schedule an upcall if we are below, and restart the measurement 
 * (reschedule timer and zero counters). 
 */ 
 
struct bw_data { 
        struct timeval  b_time; 
        uint64_t        b_packets; 
        uint64_t        b_bytes; 
}; 
 
struct bw_upcall { 
        struct in_addr  bu_src;         /* source address            */ 
        struct in_addr  bu_dst;         /* destination address       */ 
        uint32_t        bu_flags;       /* misc flags (see below)    */ 
#define BW_UPCALL_UNIT_PACKETS (1 &lt;&lt; 0) /* threshold (in packets)    */ 
#define BW_UPCALL_UNIT_BYTES   (1 &lt;&lt; 1) /* threshold (in bytes)      */ 
#define BW_UPCALL_GEQ          (1 &lt;&lt; 2) /* upcall if bw &gt;= threshold */ 
#define BW_UPCALL_LEQ          (1 &lt;&lt; 3) /* upcall if bw &lt;= threshold */ 
#define BW_UPCALL_DELETE_ALL   (1 &lt;&lt; 4) /* delete all upcalls for s,d*/ 
        struct bw_data  bu_threshold;   /* the bw threshold          */ 
        struct bw_data  bu_measured;    /* the measured bw           */ 
}; 
 
/* max. number of upcalls to deliver together */ 
#define BW_UPCALLS_MAX				128 
/* min. threshold time interval for bandwidth measurement */ 
#define BW_UPCALL_THRESHOLD_INTERVAL_MIN_SEC	3 
#define BW_UPCALL_THRESHOLD_INTERVAL_MIN_USEC	0</pre>
<div class="spacer">
</div>
The <span class="type">bw_upcall</span> structure is used as an argument to <b class="fname">setsockopt</b>(<i class="farg">MRT_ADD_BW_UPCALL</i>) and <b class="fname">setsockopt</b>(<i class="farg">MRT_DEL_BW_UPCALL</i>). Each <b class="fname">setsockopt</b>(<i class="farg">MRT_ADD_BW_UPCALL</i>) installs a filter in the kernel for the source and destination address in the <span class="type">bw_upcall</span> argument, and that filter will trigger an upcall according to the following pseudo-algorithm:<div class="spacer">
</div>
<pre style="margin-left: 0.00ex;" class="lit display">
 if (bw_upcall_oper IS &quot;&gt;=&quot;) { 
    if (((bw_upcall_unit &amp; PACKETS == PACKETS) &amp;&amp; 
         (measured_packets &gt;= threshold_packets)) || 
        ((bw_upcall_unit &amp; BYTES == BYTES) &amp;&amp; 
         (measured_bytes &gt;= threshold_bytes))) 
       SEND_UPCALL(&quot;measured bandwidth is &gt;= threshold&quot;); 
  } 
  if (bw_upcall_oper IS &quot;&lt;=&quot; &amp;&amp; measured_interval &gt;= threshold_interval) { 
    if (((bw_upcall_unit &amp; PACKETS == PACKETS) &amp;&amp; 
         (measured_packets &lt;= threshold_packets)) || 
        ((bw_upcall_unit &amp; BYTES == BYTES) &amp;&amp; 
         (measured_bytes &lt;= threshold_bytes))) 
       SEND_UPCALL(&quot;measured bandwidth is &lt;= threshold&quot;); 
  }</pre>
<div class="spacer">
</div>
In the same <span class="type">bw_upcall</span>, the unit can be specified in both BYTES and PACKETS. However, the GEQ and LEQ flags are mutually exclusive.<div class="spacer">
</div>
Basically, an upcall is delivered if the measured bandwidth is &gt;= or &lt;= the threshold bandwidth (within the specified measurement interval). For practical reasons, the smallest value for the measurement interval is 3 seconds. If smaller values are allowed, then the bandwidth estimation may be less accurate, or the potentially very high frequency of the generated upcalls may introduce too much overhead. For the &gt;= operation, the answer may be known before the end of <b class="var">threshold_interval</b>, therefore the upcall may be delivered earlier. For the &lt;= operation however, we must wait until the threshold interval has expired to know the answer.</div>
</div>
<div class="section">
<h1 id="x4558414d504c4553">EXAMPLES</h1><pre style="margin-left: 5.00ex;" class="lit display">
struct bw_upcall bw_upcall; 
/* Assign all bw_upcall fields as appropriate */ 
memset(&amp;bw_upcall, 0, sizeof(bw_upcall)); 
memcpy(&amp;bw_upcall.bu_src, &amp;source, sizeof(bw_upcall.bu_src)); 
memcpy(&amp;bw_upcall.bu_dst, &amp;group, sizeof(bw_upcall.bu_dst)); 
bw_upcall.bu_threshold.b_data = threshold_interval; 
bw_upcall.bu_threshold.b_packets = threshold_packets; 
bw_upcall.bu_threshold.b_bytes = threshold_bytes; 
if (is_threshold_in_packets) 
    bw_upcall.bu_flags |= BW_UPCALL_UNIT_PACKETS; 
if (is_threshold_in_bytes) 
    bw_upcall.bu_flags |= BW_UPCALL_UNIT_BYTES; 
do { 
    if (is_geq_upcall) { 
        bw_upcall.bu_flags |= BW_UPCALL_GEQ; 
        break; 
    } 
    if (is_leq_upcall) { 
        bw_upcall.bu_flags |= BW_UPCALL_LEQ; 
        break; 
    } 
    return (ERROR); 
} while (0); 
setsockopt(mrouter_s4, IPPROTO_IP, MRT_ADD_BW_UPCALL, 
          (void *)&amp;bw_upcall, sizeof(bw_upcall));</pre>
<div class="spacer">
</div>
To delete a single filter, use <span class="define">MRT_DEL_BW_UPCALL</span>, and the fields of bw_upcall must be set to exactly same as when <span class="define">MRT_ADD_BW_UPCALL</span> was called.<div class="spacer">
</div>
To delete all bandwidth filters for a given (S,G), then only the <b class="var">bu_src</b> and <b class="var">bu_dst</b> fields in <span class="type">struct bw_upcall</span> need to be set, and then just set only the <span class="define">BW_UPCALL_DELETE_ALL</span> flag inside field <b class="var">bw_upcall.bu_flags</b>.<div class="spacer">
</div>
The bandwidth upcalls are received by aggregating them in the new upcall message:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
#define IGMPMSG_BW_UPCALL  4  /* BW monitoring upcall */</pre>
<div class="spacer">
</div>
This message is an array of <span class="type">struct bw_upcall</span> elements (up to <span class="define">BW_UPCALLS_MAX</span> = 128). The upcalls are delivered when there are 128 pending upcalls, or when 1 second has expired since the previous upcall (whichever comes first). In an <span class="type">struct upcall</span> element, the <b class="var">bu_measured</b> field is filled in to indicate the particular measured values. However, because of the way the particular intervals are measured, the user should be careful how <b class="var">bu_measured.b_time</b> is used. For example, if the filter is installed to trigger an upcall if the number of packets is &gt;= 1, then <b class="var">bu_measured</b> may have a value of zero in the upcalls after the first one, because the measured interval for &gt;= filters is &#8220;clocked&#8221; by the forwarded packets. Hence, this upcall mechanism should not be used for measuring the exact value of the bandwidth of the forwarded data. To measure the exact bandwidth, the user would need to get the forwarded packets statistics with the <b class="fname">ioctl</b>(<i class="farg">SIOCGETSGCNT</i>) mechanism (see the <i class="link-sec"><a class="link-sec" href="#x50726f6772616d6d696e67204775696465">Programming Guide</a></i> section) .<div class="spacer">
</div>
Note that the upcalls for a filter are delivered until the specific filter is deleted, but no more frequently than once per <b class="var">bu_threshold.b_time</b>. For example, if the filter is specified to deliver a signal if bw &gt;= 1 packet, the first packet will trigger a signal, but the next upcall will be triggered no earlier than <b class="var">bu_threshold.b_time</b> after the previous upcall.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html2/getsockopt.html">getsockopt(2)</a>, <a class="link-man" href="../html2/recvfrom.html">recvfrom(2)</a>, <a class="link-man" href="../html2/recvmsg.html">recvmsg(2)</a>, <a class="link-man" href="../html2/setsockopt.html">setsockopt(2)</a>, <a class="link-man" href="../html2/socket.html">socket(2)</a>, <a class="link-man" href="../html4/icmp6.html">icmp6(4)</a>, <a class="link-man" href="../html4/inet.html">inet(4)</a>, <a class="link-man" href="../html4/inet6.html">inet6(4)</a>, <a class="link-man" href="../html4/intro.html">intro(4)</a>, <a class="link-man" href="../html4/ip.html">ip(4)</a>, <a class="link-man" href="../html4/ip6.html">ip6(4)</a>, <a class="link-man" href="../html4/pim.html">pim(4)</a>, <a class="link-man" href="../html8/mrouted.html">mrouted(8)</a>, <a class="link-man" href="../html8/sysctl.html">sysctl(8)</a></div>
<div class="section">
<h1 id="x415554484f5253">AUTHORS</h1> The original multicast code was written by <span class="author">David Waitzman</span> (BBN Labs), and later modified by the following individuals: <span class="author">Steve Deering</span> (Stanford), <span class="author">Mark J. Steiglitz</span> (Stanford), <span class="author">Van Jacobson</span> (LBL), <span class="author">Ajit Thyagarajan</span> (PARC), <span class="author">Bill Fenner</span> (PARC).<div class="spacer">
</div>
The IPv6 multicast support was implemented by the KAME project (<a class="link-ext" href="http://www.kame.net">http://www.kame.net</a>), and was based on the IPv4 multicast code. The advanced multicast API and the multicast bandwidth monitoring were implemented by <span class="author">Pavlin Radoslavov</span> (ICSI) in collaboration with <span class="author">Chris Brown</span> (NextHop).<div class="spacer">
</div>
This manual page was written by <span class="author">Pavlin Radoslavov</span> (ICSI).</div>
</div>
</body>
</html>

