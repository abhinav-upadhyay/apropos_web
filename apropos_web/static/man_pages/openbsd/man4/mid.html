<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
MIDI(4)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">midi</b> &#8212; <span class="desc">raw device independent interface to MIDI ports</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="config">midi* at autri?</b><br/>
<b class="config">midi* at eap?</b><br/>
<b class="config">midi* at envy?</b><br/>
<b class="config">midi* at mpu?</b><br/>
<b class="config">midi* at sb?</b><br/>
<b class="config">midi* at umidi?</b><br/>
<b class="config">midi* at ym?</b></div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <b class="name">midi</b> driver makes MIDI ports available to user applications. A <b class="name">midi</b> device corresponds to 2 MIDI ports: one input port and one output port. Data received on the input port is not interpreted and is passed to the user program as-is. Similarly, data issued by the user program is sent as-is to the output port.<div class="spacer">
</div>
Only one process may hold open a <b class="name">midi</b> device at a given time, although file descriptors may be shared between processes once the first open completes. If it is opened read-only (write-only) only the input (output) MIDI port is available.<div class="subsection">
<h2 id="x57726974696e6720746f2074686520646576696365">Writing to the device</h2> A process can send raw MIDI data to the output port by using the <a class="link-man" href="../html2/write.html">write(2)</a> system call. Data is queued and the system call returns immediately; the data is sent as fast as possible to the output MIDI port. However, if the in-kernel buffer is full or the requested amount is too large, then <a class="link-man" href="../html2/write.html">write(2)</a> may block. The current size of the in-kernel buffer is 1024 bytes, which ensures that <a class="link-man" href="../html2/write.html">write(2)</a> isn't blocking in most situations.</div>
<div class="subsection">
<h2 id="x52656164696e672066726f6d2074686520646576696365">Reading from the device</h2> Data received from the input MIDI port is stored into the in-kernel buffer. A process can retrieve its contents by using the <a class="link-man" href="../html2/read.html">read(2)</a> system call. If there is less data than the amount requested for reading, then a shorter amount is returned. If no data is available, then the <a class="link-man" href="../html2/read.html">read(2)</a> system call will block until data is received, and then return immediately.<div class="spacer">
</div>
The MIDI protocol has been designed for real-time performance and doesn't support flow control. An application must be able to read the incoming data fast enough (the MIDI standard's maximum rate is 3125 bytes per second). The kernel can buffer up to 1024 bytes; once the buffer is full input will be silently discarded.</div>
<div class="subsection">
<h2 id="x506f6c6c696e672074686520646576696365">Polling the device</h2> A process can use the <a class="link-man" href="../html2/poll.html">poll(2)</a> system call to poll for the following events:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">POLLIN</span></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
The in-kernel input buffer isn't empty, i.e. at least one byte is available for reading. A subsequent call to <a class="link-man" href="../html2/read.html">read(2)</a> will not be blocking.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">POLLOUT</span></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
The in-kernel output buffer is empty, thus a subsequent call to <a class="link-man" href="../html2/write.html">write(2)</a> will not be blocking if a reasonable amount of data is written (currently less that 1024 bytes).</dd>
</dl>
<div class="spacer">
</div>
Using the <a class="link-man" href="../html2/poll.html">poll(2)</a> system call is the recommended way to handle multiple <b class="name">midi</b> devices in a real-time MIDI application.</div>
<div class="subsection">
<h2 id="x4e6f6e1e626c6f636b696e6720492f4f">Non-blocking I/O</h2> If the <b class="name">midi</b> device is opened with the O_NONBLOCK flag (see <a class="link-man" href="../html2/open.html">open(2)</a>), then subsequent calls to <a class="link-man" href="../html2/read.html">read(2)</a> or <a class="link-man" href="../html2/write.html">write(2)</a> will never block. The <a class="link-man" href="../html2/write.html">write(2)</a> system call may write less bytes than requested, or may return EAGAIN if no data could be sent or queued. Similarly, the <a class="link-man" href="../html2/read.html">read(2)</a> system call may return EAGAIN if no input is available.<div class="spacer">
</div>
Note that even if non-blocking I/O is not selected, <a class="link-man" href="../html2/read.html">read(2)</a> and <a class="link-man" href="../html2/write.html">write(2)</a> system calls are non-blocking when the kernel buffers permit it.</div>
</div>
<div class="section">
<h1 id="x46494c4553">FILES</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="file">/dev/rmidi*</i></dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
<b class="name">midi</b> devices</dd>
</dl>
</div>
<div class="section">
<h1 id="x4558414d504c4553">EXAMPLES</h1> The following command could record the memory dump of a synthesizer in a file:<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">$ cat -u /dev/rmidi2 &gt;dumpfile</code></div>
</blockquote>
<div class="spacer">
</div>
A MIDI keyboard could be connected to a synthesizer by the command:<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">$ cat -u /dev/rmidi1 &gt;/dev/rmidi2</code></div>
</blockquote>
<div class="spacer">
</div>
The input port could be connected to the output port by the command:<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">$ cat -u &lt;&gt;/dev/rmidi1 &gt;&amp;0</code></div>
</blockquote>
<div class="spacer">
</div>
The following example reads MIDI timing events from an input device, MIDI common and voice events from another input device, and sends the result to a third (output) device.<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
#define BUFSIZE		0x100 
#define ISTIMING(c)	((c) == 0xf8 || (c) == 0xfa || (c) == 0xfc) 
#define ISCOMMON(c)	((c) &lt; 0xf8) 
 
int ofd; 
struct pollfd ifd[2]; 
unsigned char ibuf[BUFSIZE], obuf[2 * BUFSIZE]; 
ssize_t iused, oused, i; 
 
ifd[0].events = ifd[1].events = POLLIN; 
for (;;) { 
	oused = 0; 
	if (poll(ifd, 2, -1) == -1) 
		errx(1, &quot;poll&quot;); 
	if (ifd[0].revents &amp; POLLIN) { 
		if ((iused = read(ifd[0].fd, ibuf, BUFSIZE)) == -1) 
			errx(1, &quot;read&quot;); 
		for (i = 0; i &lt; iused; i++) 
			if (ISTIMING(ibuf[i])) 
				obuf[oused++] = ibuf[i]; 
	} 
	if (ifd[1].revents &amp; POLLIN) { 
		if ((iused = read(ifd[1].fd, ibuf, BUFSIZE)) == -1) 
			errx(1, &quot;read&quot;); 
		for (i = 0; i &lt; iused; i++) 
			if (ISCOMMON(ibuf[i])) 
				obuf[oused++] = ibuf[i]; 
	} 
	if (write(ofd, obuf, oused) == -1) 
		errx(1, &quot;write&quot;); 
}</pre>
<div class="spacer">
</div>
In the above example, unless kernel buffers are full, processing is done in real-time without any noticeable latency; as expected, the only blocking system call is <a class="link-man" href="../html2/poll.html">poll(2)</a>.</div>
<div class="section">
<h1 id="x4552524f5253">ERRORS</h1> If <a class="link-man" href="../html2/open.html">open(2)</a>, <a class="link-man" href="../html2/read.html">read(2)</a>, <a class="link-man" href="../html2/write.html">write(2)</a>, or <a class="link-man" href="../html2/poll.html">poll(2)</a> fail then <a class="link-man" href="../html2/errno.html">errno(2)</a> may be set to one of:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
[<span class="errno">ENXIO</span>]</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
The device is opened read-only (write-only) but <a class="link-man" href="../html2/write.html">write(2)</a> (<a class="link-man" href="../html2/read.html">read(2)</a>) was called.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
[<span class="errno">EIO</span>]</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
The device is being detached while a process has been trying to read or write (for instance an <a class="link-man" href="../html4/umidi.html">umidi(4)</a> device has been unplugged).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
[<span class="errno">EAGAIN</span>]</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
Non-blocking I/O was selected and the output buffer is full (on writing) or the input buffer is empty (on reading).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
[<span class="errno">EBUSY</span>]</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
The device is already open by another process.</dd>
</dl>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html4/autri.html">autri(4)</a>, <a class="link-man" href="../html4/eap.html">eap(4)</a>, <a class="link-man" href="../html4/envy.html">envy(4)</a>, <a class="link-man" href="../html4/mpu.html">mpu(4)</a>, <a class="link-man" href="../html4/sb.html">sb(4)</a>, <a class="link-man" href="../html4/umidi.html">umidi(4)</a>, <a class="link-man" href="../html4/ym.html">ym(4)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The <b class="name">midi</b> driver first appeared in <span class="unix">OpenBSD&#160;2.5</span>.</div>
<div class="section">
<h1 id="x415554484f5253">AUTHORS</h1> The <b class="name">midi</b> driver was originally written by <span class="author">Lennart Augustsson</span> and later largely rewritten by <span class="author">Alexandre Ratchov</span>.</div>
<div class="section">
<h1 id="x43415645415453">CAVEATS</h1> MIDI hardware was designed for real time performance and software using such hardware must be able to process MIDI events without any noticeable latency (typically no more than 5ms, which is the time it takes for sound to propagate 1.75 meters).<div class="spacer">
</div>
The <span class="unix">OpenBSD</span> <b class="name">midi</b> driver processes data fast enough, however if a MIDI application tries to write data faster than the hardware is able to process it (typically 3125 bytes per second), then kernel buffers may become full and the application may be blocked.<div class="spacer">
</div>
The other common reason for MIDI data being delayed is the system load. Processes cannot be preempted while running in kernel mode. If there are too much processes running concurrently (especially if they are running a lot of expensive system calls) then the scheduling of a real-time MIDI application may be delayed. Even on low-end machines this delay hardly reaches a few milliseconds provided that the system load is reasonable.<div class="spacer">
</div>
A real-time MIDI application can avoid being swapped by locking its memory (see <a class="link-man" href="../html2/mlock.html">mlock(2)</a> and <a class="link-man" href="../html2/mlockall.html">mlockall(2)</a>).</div>
<div class="section">
<h1 id="x42554753">BUGS</h1> For a given device, even if the physical MIDI input and output ports are independent, there is no way for one process to use the input MIDI port and for another process to use the output MIDI port at the same time.</div>
</div>
</body>
</html>

