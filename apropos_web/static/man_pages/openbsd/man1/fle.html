<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
FLEX(1)</title>
</head>
<body>
<div class="mandoc">
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">flex</b>, <b class="name">flex++</b>, <b class="name">lex</b> &#8212; <span class="desc">fast lexical analyzer generator</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1><table class="synopsis">
<col style="width: 4.00ex;"/>
<col/>
<tbody>
<tr>
<td>
flex</td>
<td>
[<span class="opt"><b class="flag">-78BbdFfhIiLlnpsTtVvw+?</b></span>] [<span class="opt"><b class="flag">-C</b>[<span class="opt"><b class="flag">aeFfmr</b></span>]</span>] [<span class="opt"><b class="flag">-</b><b class="flag">-help</b></span>] [<span class="opt"><b class="flag">-</b><b class="flag">-version</b></span>] [<span class="opt"><b class="flag">-o</b><i class="arg">output</i></span>] [<span class="opt"><b class="flag">-P</b><i class="arg">prefix</i></span>] [<span class="opt"><b class="flag">-S</b><i class="arg">skeleton</i></span>] [<span class="opt"><i class="arg">file&#160;...</i></span>]</td>
</tr>
</tbody>
</table>
</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> <b class="name">flex</b> is a tool for generating <span class="emph">scanners</span>: programs which recognize lexical patterns in text. <b class="name">flex</b> reads the given input files, or its standard input if no file names are given, for a description of a scanner to generate. The description is in the form of pairs of regular expressions and C code, called <span class="emph">rules</span>. <b class="name">flex</b> generates as output a C source file, <i class="file">lex.yy.c</i>, which defines a routine <b class="fname">yylex</b>(). This file is compiled and linked with the <b class="flag">-lfl</b> library to produce an executable. When the executable is run, it analyzes its input for occurrences of the regular expressions. Whenever it finds one, it executes the corresponding C code.<div class="spacer">
</div>
<b class="name">lex</b> is a synonym for <b class="name">flex</b>. <b class="name">flex++</b> is a synonym for <b class="name">flex</b> <b class="flag">-+</b>.<div class="spacer">
</div>
The manual includes both tutorial and reference sections:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-ohang">
<dt class="list-ohang" style="margin-top: 1.00em;">
<span class="symb">Some Simple Examples</span></dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<span class="symb">Format of the Input File</span></dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<span class="symb">Patterns</span></dt>
<dd class="list-ohang">
The extended regular expressions used by <b class="name">flex</b>.</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<span class="symb">How the Input is Matched</span></dt>
<dd class="list-ohang">
The rules for determining what has been matched.</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<span class="symb">Actions</span></dt>
<dd class="list-ohang">
How to specify what to do when a pattern is matched.</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<span class="symb">The Generated Scanner</span></dt>
<dd class="list-ohang">
Details regarding the scanner that <b class="name">flex</b> produces; how to control the input source.</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<span class="symb">Start Conditions</span></dt>
<dd class="list-ohang">
Introducing context into scanners, and managing &#8220;mini-scanners&#8221;.</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<span class="symb">Multiple Input Buffers</span></dt>
<dd class="list-ohang">
How to manipulate multiple input sources; how to scan from strings instead of files.</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<span class="symb">End-of-File Rules</span></dt>
<dd class="list-ohang">
Special rules for matching the end of the input.</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<span class="symb">Miscellaneous Macros</span></dt>
<dd class="list-ohang">
A summary of macros available to the actions.</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<span class="symb">Values Available to the User</span></dt>
<dd class="list-ohang">
A summary of values available to the actions.</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<span class="symb">Interfacing with Yacc</span></dt>
<dd class="list-ohang">
Connecting flex scanners together with <a class="link-man" href="../html1/yacc.html">yacc(1)</a> parsers.</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<span class="symb">Options</span></dt>
<dd class="list-ohang">
<b class="name">flex</b> command-line options, and the &#8220;%option&#8221; directive.</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<span class="symb">Performance Considerations</span></dt>
<dd class="list-ohang">
How to make scanners go as fast as possible.</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<span class="symb">Generating C++ Scanners</span></dt>
<dd class="list-ohang">
The (experimental) facility for generating C++ scanner classes.</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<span class="symb">Incompatibilities with Lex and POSIX</span></dt>
<dd class="list-ohang">
How <b class="name">flex</b> differs from AT&amp;T UNIX <b class="name">lex</b> and the POSIX <b class="name">lex</b> standard.</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<span class="symb">Files</span></dt>
<dd class="list-ohang">
Files used by <b class="name">flex</b>.</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<span class="symb">Diagnostics</span></dt>
<dd class="list-ohang">
Those error messages produced by <b class="name">flex</b> (or scanners it generates) whose meanings might not be apparent.</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<span class="symb">See Also</span></dt>
<dd class="list-ohang">
Other documentation, related tools.</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<span class="symb">Authors</span></dt>
<dd class="list-ohang">
Includes contact information.</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<span class="symb">Bugs</span></dt>
<dd class="list-ohang">
Known problems with <b class="name">flex</b>.</dd>
</dl>
</div>
<div class="section">
<h1 id="x534f4d452053494d504c45204558414d504c4553">SOME SIMPLE EXAMPLES</h1> First some simple examples to get the flavor of how one uses <b class="name">flex</b>. The following <b class="name">flex</b> input specifies a scanner which whenever it encounters the string &#8220;username&#8221; will replace it with the user's login name:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
%% 
username    printf(&quot;%s&quot;, getlogin());</pre>
<div class="spacer">
</div>
By default, any text not matched by a <b class="name">flex</b> scanner is copied to the output, so the net effect of this scanner is to copy its input file to its output with each occurrence of &#8220;username&#8221; expanded. In this input, there is just one rule. &#8220;username&#8221; is the <span class="emph">pattern</span> and the &#8220;printf&#8221; is the <span class="emph">action</span>. The &#8220;%%&#8221; marks the beginning of the rules.<div class="spacer">
</div>
Here's another simple example:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
%{ 
int num_lines = 0, num_chars = 0; 
%} 
 
%% 
\n      ++num_lines; ++num_chars; 
.       ++num_chars; 
 
%% 
main() 
{ 
	yylex(); 
	printf(&quot;# of lines = %d, # of chars = %d\n&quot;, 
            num_lines, num_chars); 
}</pre>
<div class="spacer">
</div>
This scanner counts the number of characters and the number of lines in its input (it produces no output other than the final report on the counts). The first line declares two globals, &#8220;num_lines&#8221; and &#8220;num_chars&#8221;, which are accessible both inside <b class="fname">yylex</b>() and in the <b class="fname">main</b>() routine declared after the second &#8220;%%&#8221;. There are two rules, one which matches a newline (&quot;\n&quot;) and increments both the line count and the character count, and one which matches any character other than a newline (indicated by the &#8220;.&#8221; regular expression).<div class="spacer">
</div>
A somewhat more complicated example:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
/* scanner for a toy Pascal-like language */ 
 
%{ 
/* need this for the call to atof() below */ 
#include &lt;math.h&gt; 
%} 
 
DIGIT    [0-9] 
ID       [a-z][a-z0-9]* 
 
%% 
 
{DIGIT}+ { 
        printf(&quot;An integer: %s (%d)\n&quot;, yytext, 
            atoi(yytext)); 
} 
 
{DIGIT}+&quot;.&quot;{DIGIT}* { 
        printf(&quot;A float: %s (%g)\n&quot;, yytext, 
            atof(yytext)); 
} 
 
if|then|begin|end|procedure|function { 
        printf(&quot;A keyword: %s\n&quot;, yytext); 
} 
 
{ID}    printf(&quot;An identifier: %s\n&quot;, yytext); 
 
&quot;+&quot;|&quot;-&quot;|&quot;*&quot;|&quot;/&quot;   printf(&quot;An operator: %s\n&quot;, yytext); 
 
&quot;{&quot;[^}\n]*&quot;}&quot;     /* eat up one-line comments */ 
 
[ \t\n]+          /* eat up whitespace */ 
 
.       printf(&quot;Unrecognized character: %s\n&quot;, yytext); 
 
%% 
 
main(int argc, char *argv[]) 
{ 
        ++argv; --argc;  /* skip over program name */ 
        if (argc &gt; 0) 
                yyin = fopen(argv[0], &quot;r&quot;); 
        else 
                yyin = stdin; 
 
        yylex(); 
}</pre>
<div class="spacer">
</div>
This is the beginnings of a simple scanner for a language like Pascal. It identifies different types of <span class="emph">tokens</span> and reports on what it has seen.<div class="spacer">
</div>
The details of this example will be explained in the following sections.</div>
<div class="section">
<h1 id="x464f524d4154204f462054484520494e5055542046494c45">FORMAT OF THE INPUT FILE</h1> The <b class="name">flex</b> input file consists of three sections, separated by a line with just &#8220;%%&#8221; in it:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
definitions 
%% 
rules 
%% 
user code</pre>
<div class="spacer">
</div>
The <span class="emph">definitions</span> section contains declarations of simple <span class="emph">name</span> definitions to simplify the scanner specification, and declarations of <span class="emph">start conditions</span>, which are explained in a later section.<div class="spacer">
</div>
Name definitions have the form:<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
name definition</div>
</blockquote>
<div class="spacer">
</div>
The &#8220;name&#8221; is a word beginning with a letter or an underscore (&#8216;_&#8217;) followed by zero or more letters, digits, &#8216;_&#8217;, or &#8216;-&#8217; (dash). The definition is taken to begin at the first non-whitespace character following the name and continuing to the end of the line. The definition can subsequently be referred to using &#8220;{name}&#8221;, which will expand to &#8220;(definition)&#8221;. For example:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
DIGIT    [0-9] 
ID       [a-z][a-z0-9]*</pre>
<div class="spacer">
</div>
This defines &#8220;DIGIT&#8221; to be a regular expression which matches a single digit, and &#8220;ID&#8221; to be a regular expression which matches a letter followed by zero-or-more letters-or-digits. A subsequent reference to<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">{DIGIT}+&quot;.&quot;{DIGIT}*</code></div>
</blockquote>
<div class="spacer">
</div>
is identical to<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">([0-9])+&quot;.&quot;([0-9])*</code></div>
</blockquote>
<div class="spacer">
</div>
and matches one-or-more digits followed by a &#8216;.&#8217; followed by zero-or-more digits.<div class="spacer">
</div>
The <span class="emph">rules</span> section of the <b class="name">flex</b> input contains a series of rules of the form:<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">pattern	action</code></div>
</blockquote>
<div class="spacer">
</div>
The pattern must be unindented and the action must begin on the same line.<div class="spacer">
</div>
See below for a further description of patterns and actions.<div class="spacer">
</div>
Finally, the user code section is simply copied to <i class="file">lex.yy.c</i> verbatim. It is used for companion routines which call or are called by the scanner. The presence of this section is optional; if it is missing, the second &#8220;%%&#8221; in the input file may be skipped too.<div class="spacer">
</div>
In the definitions and rules sections, any indented text or text enclosed in &#8216;%{&#8217; and &#8216;%}&#8217; is copied verbatim to the output (with the %{}'s removed). The %{}'s must appear unindented on lines by themselves.<div class="spacer">
</div>
In the rules section, any indented or %{} text appearing before the first rule may be used to declare variables which are local to the scanning routine and (after the declarations) code which is to be executed whenever the scanning routine is entered. Other indented or %{} text in the rule section is still copied to the output, but its meaning is not well-defined and it may well cause compile-time errors (this feature is present for POSIX compliance; see below for other such features).<div class="spacer">
</div>
In the definitions section (but not in the rules section), an unindented comment (i.e., a line beginning with &#8220;/*&#8221;) is also copied verbatim to the output up to the next &#8220;*/&#8221;.</div>
<div class="section">
<h1 id="x5041545445524e53">PATTERNS</h1> The patterns in the input are written using an extended set of regular expressions. These are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
x</dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
Match the character &#8216;x&#8217;.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
.</dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
Any character (byte) except newline.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
[xyz]</dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
A &#8220;character class&#8221;; in this case, the pattern matches either an &#8216;x&#8217;, a &#8216;y&#8217;, or a &#8216;z&#8217;.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
[abj-oZ]</dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
A &#8220;character class&#8221; with a range in it; matches an &#8216;a&#8217;, a &#8216;b&#8217;, any letter from &#8216;j&#8217; through &#8216;o&#8217;, or a &#8216;Z&#8217;.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
[^A-Z]</dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
A &#8220;negated character class&#8221;, i.e., any character but those in the class. In this case, any character EXCEPT an uppercase letter.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
[^A-Z\n]</dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
Any character EXCEPT an uppercase letter or a newline.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
r*</dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
Zero or more r's, where &#8216;r&#8217; is any regular expression.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
r+</dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
One or more r's.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
r?</dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
Zero or one r's (that is, &#8220;an optional r&#8221;).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
r{2,5}</dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
Anywhere from two to five r's.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
r{2,}</dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
Two or more r's.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
r{4}</dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
Exactly 4 r's.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
{name}</dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
The expansion of the &#8220;name&#8221; definition (see above).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&quot;[xyz]\&quot;foo&quot;</dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
The literal string: [xyz]&quot;foo.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
\X</dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
If &#8216;X&#8217; is an &#8216;a&#8217;, &#8216;b&#8217;, &#8216;f&#8217;, &#8216;n&#8217;, &#8216;r&#8217;, &#8216;t&#8217;, or &#8216;v&#8217;, then the ANSI-C interpretation of &#8216;\X&#8217;. Otherwise, a literal &#8216;X&#8217; (used to escape operators such as &#8216;*&#8217;).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
\0</dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
A NUL character (ASCII code 0).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
\123</dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
The character with octal value 123.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
\x2a</dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
The character with hexadecimal value 2a.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
(r)</dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
Match an &#8216;r&#8217;; parentheses are used to override precedence (see below).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
rs</dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
The regular expression &#8216;r&#8217; followed by the regular expression &#8216;s&#8217;; called &#8220;concatenation&#8221;.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
r|s</dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
Either an &#8216;r&#8217; or an &#8216;s&#8217;.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
r/s</dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
An &#8216;r&#8217;, but only if it is followed by an &#8216;s&#8217;. The text matched by &#8216;s&#8217; is included when determining whether this rule is the &#8220;longest match&#8221;, but is then returned to the input before the action is executed. So the action only sees the text matched by &#8216;r&#8217;. This type of pattern is called &#8220;trailing context&#8221;. (There are some combinations of r/s that <b class="name">flex</b> cannot match correctly; see notes in the <i class="link-sec"><a class="link-sec" href="#x42554753">BUGS</a></i> section below regarding &#8220;dangerous trailing context&#8221;.)</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
^r</dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
An &#8216;r&#8217;, but only at the beginning of a line (i.e., just starting to scan, or right after a newline has been scanned).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
r$</dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
An &#8216;r&#8217;, but only at the end of a line (i.e., just before a newline). Equivalent to &#8220;r/\n&#8221;.<div class="spacer">
</div>
Note that <b class="name">flex</b>'s notion of &#8220;newline&#8221; is exactly whatever the C compiler used to compile <b class="name">flex</b> interprets &#8216;\n&#8217; as.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&lt;s&gt;r</dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
An &#8216;r&#8217;, but only in start condition &#8216;s&#8217; (see below for discussion of start conditions).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&lt;s1,s2,s3&gt;r</dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
The same, but in any of start conditions s1, s2, or s3.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&lt;*&gt;r</dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
An &#8216;r&#8217; in any start condition, even an exclusive one.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&lt;&lt;EOF&gt;&gt;</dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
An end-of-file.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&lt;s1,s2&gt;&lt;&lt;EOF&gt;&gt;</dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
An end-of-file when in start condition s1 or s2.</dd>
</dl>
<div class="spacer">
</div>
Note that inside of a character class, all regular expression operators lose their special meaning except escape (&#8216;\&#8217;) and the character class operators, &#8216;-&#8217;, &#8216;]&#8217;, and, at the beginning of the class, &#8216;^&#8217;.<div class="spacer">
</div>
The regular expressions listed above are grouped according to precedence, from highest precedence at the top to lowest at the bottom. Those grouped together have equal precedence. For example,<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
foo|bar*</div>
</blockquote>
<div class="spacer">
</div>
is the same as<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
(foo)|(ba(r*))</div>
</blockquote>
<div class="spacer">
</div>
since the &#8216;*&#8217; operator has higher precedence than concatenation, and concatenation higher than alternation (&#8216;|&#8217;). This pattern therefore matches <span class="emph">either</span> the string &#8220;foo&#8221; <span class="emph">or</span> the string &#8220;ba&#8221; followed by zero-or-more r's. To match &#8220;foo&#8221; or zero-or-more &quot;bar&quot;'s, use:<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
foo|(bar)*</div>
</blockquote>
<div class="spacer">
</div>
and to match zero-or-more &quot;foo&quot;'s-or-&quot;bar&quot;'s:<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
(foo|bar)*</div>
</blockquote>
<div class="spacer">
</div>
In addition to characters and ranges of characters, character classes can also contain character class <span class="emph">expressions</span>. These are expressions enclosed inside &#8216;[:&#8217; and &#8216;:]&#8217; delimiters (which themselves must appear between the &#8216;[&#8217; and &#8216;]&#8217; of the character class; other elements may occur inside the character class, too). The valid expressions are:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
[:alnum:] [:alpha:] [:blank:] 
[:cntrl:] [:digit:] [:graph:] 
[:lower:] [:print:] [:punct:] 
[:space:] [:upper:] [:xdigit:]</pre>
<div class="spacer">
</div>
These expressions all designate a set of characters equivalent to the corresponding standard C <b class="fname">isXXX</b>() function. For example, [:alnum:] designates those characters for which <a class="link-man" href="../html3/isalnum.html">isalnum(3)</a> returns true - i.e., any alphabetic or numeric. Some systems don't provide <a class="link-man" href="../html3/isblank.html">isblank(3)</a>, so <b class="name">flex</b> defines [:blank:] as a blank or a tab.<div class="spacer">
</div>
For example, the following character classes are all equivalent:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
[[:alnum:]] 
[[:alpha:][:digit:]] 
[[:alpha:]0-9] 
[a-zA-Z0-9]</pre>
<div class="spacer">
</div>
If the scanner is case-insensitive (the <b class="flag">-i</b> flag), then [:upper:] and [:lower:] are equivalent to [:alpha:].<div class="spacer">
</div>
Some notes on patterns:<ul style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-dash">
<li class="list-dash" style="margin-top: 1.00em;">
A negated character class such as the example &#8220;[^A-Z]&#8221; above will match a newline unless &quot;\n&quot; (or an equivalent escape sequence) is one of the characters explicitly present in the negated character class (e.g., &#8220;[^A-Z\n]&#8221;). This is unlike how many other regular expression tools treat negated character classes, but unfortunately the inconsistency is historically entrenched. Matching newlines means that a pattern like &#8220;[^&quot;]*&#8221; can match the entire input unless there's another quote in the input.</li>
<li class="list-dash" style="margin-top: 1.00em;">
A rule can have at most one instance of trailing context (the &#8216;/&#8217; operator or the &#8216;$&#8217; operator). The start condition, &#8216;^&#8217;, and &#8220;&lt;&lt;EOF&gt;&gt;&#8221; patterns can only occur at the beginning of a pattern and, as well as with &#8216;/&#8217; and &#8216;$&#8217;, cannot be grouped inside parentheses. A &#8216;^&#8217; which does not occur at the beginning of a rule or a &#8216;$&#8217; which does not occur at the end of a rule loses its special properties and is treated as a normal character.</li>
<li class="list-dash" style="margin-top: 1.00em;">
The following are illegal:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
foo/bar$ 
&lt;sc1&gt;foo&lt;sc2&gt;bar</pre>
<div class="spacer">
</div>
Note that the first of these, can be written &#8220;foo/bar\n&#8221;.</li>
<li class="list-dash" style="margin-top: 1.00em;">
The following will result in &#8216;$&#8217; or &#8216;^&#8217; being treated as a normal character:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
foo|(bar$) 
foo|^bar</pre>
<div class="spacer">
</div>
If what's wanted is a &#8220;foo&#8221; or a bar-followed-by-a-newline, the following could be used (the special &#8216;|&#8217; action is explained below):<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
foo      | 
bar$     /* action goes here */</pre>
<div class="spacer">
</div>
A similar trick will work for matching a foo or a bar-at-the-beginning-of-a-line.</li>
</ul>
</div>
<div class="section">
<h1 id="x484f572054484520494e505554204953204d415443484544">HOW THE INPUT IS MATCHED</h1> When the generated scanner is run, it analyzes its input looking for strings which match any of its patterns. If it finds more than one match, it takes the one matching the most text (for trailing context rules, this includes the length of the trailing part, even though it will then be returned to the input). If it finds two or more matches of the same length, the rule listed first in the <b class="name">flex</b> input file is chosen.<div class="spacer">
</div>
Once the match is determined, the text corresponding to the match (called the <span class="emph">token</span>) is made available in the global character pointer <i class="farg">yytext</i>, and its length in the global integer <i class="farg">yyleng</i>. The <span class="emph">action</span> corresponding to the matched pattern is then executed (a more detailed description of actions follows), and then the remaining input is scanned for another match.<div class="spacer">
</div>
If no match is found, then the default rule is executed: the next character in the input is considered matched and copied to the standard output. Thus, the simplest legal <b class="name">flex</b> input is:<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
%%</div>
</blockquote>
<div class="spacer">
</div>
which generates a scanner that simply copies its input (one character at a time) to its output.<div class="spacer">
</div>
Note that <i class="farg">yytext</i> can be defined in two different ways: either as a character pointer or as a character array. Which definition <b class="name">flex</b> uses can be controlled by including one of the special directives &#8220;%pointer&#8221; or &#8220;%array&#8221; in the first (definitions) section of flex input. The default is &#8220;%pointer&#8221;, unless the <b class="flag">-l</b> <b class="name">lex</b> compatibility option is used, in which case <i class="farg">yytext</i> will be an array. The advantage of using &#8220;%pointer&#8221; is substantially faster scanning and no buffer overflow when matching very large tokens (unless not enough dynamic memory is available). The disadvantage is that actions are restricted in how they can modify <i class="farg">yytext</i> (see the next section), and calls to the <b class="fname">unput</b>() function destroy the present contents of <i class="farg">yytext</i>, which can be a considerable porting headache when moving between different <b class="name">lex</b> versions.<div class="spacer">
</div>
The advantage of &#8220;%array&#8221; is that <i class="farg">yytext</i> can be modified as much as wanted, and calls to <b class="fname">unput</b>() do not destroy <i class="farg">yytext</i> (see below). Furthermore, existing <b class="name">lex</b> programs sometimes access <i class="farg">yytext</i> externally using declarations of the form:<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
extern char yytext[];</div>
</blockquote>
<div class="spacer">
</div>
This definition is erroneous when used with &#8220;%pointer&#8221;, but correct for &#8220;%array&#8221;.<div class="spacer">
</div>
&#8220;%array&#8221; defines <i class="farg">yytext</i> to be an array of <span class="define">YYLMAX</span> characters, which defaults to a fairly large value. The size can be changed by simply #define'ing <span class="define">YYLMAX</span> to a different value in the first section of <b class="name">flex</b> input. As mentioned above, with &#8220;%pointer&#8221; yytext grows dynamically to accommodate large tokens. While this means a &#8220;%pointer&#8221; scanner can accommodate very large tokens (such as matching entire blocks of comments), bear in mind that each time the scanner must resize <i class="farg">yytext</i> it also must rescan the entire token from the beginning, so matching such tokens can prove slow. <i class="farg">yytext</i> presently does not dynamically grow if a call to <b class="fname">unput</b>() results in too much text being pushed back; instead, a run-time error results.<div class="spacer">
</div>
Also note that &#8220;%array&#8221; cannot be used with C++ scanner classes (the c++ option; see below).</div>
<div class="section">
<h1 id="x414354494f4e53">ACTIONS</h1> Each pattern in a rule has a corresponding action, which can be any arbitrary C statement. The pattern ends at the first non-escaped whitespace character; the remainder of the line is its action. If the action is empty, then when the pattern is matched the input token is simply discarded. For example, here is the specification for a program which deletes all occurrences of &#8220;zap me&#8221; from its input:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
%% 
&quot;zap me&quot;</pre>
<div class="spacer">
</div>
(It will copy all other characters in the input to the output since they will be matched by the default rule.)<div class="spacer">
</div>
Here is a program which compresses multiple blanks and tabs down to a single blank, and throws away whitespace found at the end of a line:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
%% 
[ \t]+        putchar(' '); 
[ \t]+$       /* ignore this token */</pre>
<div class="spacer">
</div>
If the action contains a &#8216;{&#8217;, then the action spans till the balancing &#8216;}&#8217; is found, and the action may cross multiple lines. <b class="name">flex</b> knows about C strings and comments and won't be fooled by braces found within them, but also allows actions to begin with &#8216;%{&#8217; and will consider the action to be all the text up to the next &#8216;%}&#8217; (regardless of ordinary braces inside the action).<div class="spacer">
</div>
An action consisting solely of a vertical bar (&#8216;|&#8217;) means &#8220;same as the action for the next rule&#8221;. See below for an illustration.<div class="spacer">
</div>
Actions can include arbitrary C code, including return statements to return a value to whatever routine called <b class="fname">yylex</b>(). Each time <b class="fname">yylex</b>() is called, it continues processing tokens from where it last left off until it either reaches the end of the file or executes a return.<div class="spacer">
</div>
Actions are free to modify <i class="farg">yytext</i> except for lengthening it (adding characters to its end - these will overwrite later characters in the input stream). This, however, does not apply when using &#8220;%array&#8221; (see above); in that case, <i class="farg">yytext</i> may be freely modified in any way.<div class="spacer">
</div>
Actions are free to modify <i class="farg">yyleng</i> except they should not do so if the action also includes use of <b class="fname">yymore</b>() (see below).<div class="spacer">
</div>
There are a number of special directives which can be included within an action:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
ECHO</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Copies <i class="farg">yytext</i> to the scanner's output.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
BEGIN</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Followed by the name of a start condition, places the scanner in the corresponding start condition (see below).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
REJECT</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Directs the scanner to proceed on to the &#8220;second best&#8221; rule which matched the input (or a prefix of the input). The rule is chosen as described above in <i class="link-sec"><a class="link-sec" href="#x484f572054484520494e505554204953204d415443484544">HOW THE INPUT IS MATCHED</a></i>, and <i class="farg">yytext</i> and <i class="farg">yyleng</i> set up appropriately. It may either be one which matched as much text as the originally chosen rule but came later in the <b class="name">flex</b> input file, or one which matched less text. For example, the following will both count the words in the input and call the routine <b class="fname">special</b>() whenever &#8220;frob&#8221; is seen:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
int word_count = 0; 
%% 
 
frob        special(); REJECT; 
[^ \t\n]+   ++word_count;</pre>
<div class="spacer">
</div>
Without the <span class="emph">REJECT</span>, any &quot;frob&quot;'s in the input would not be counted as words, since the scanner normally executes only one action per token. Multiple <span class="emph">REJECT</span>'s are allowed, each one finding the next best choice to the currently active rule. For example, when the following scanner scans the token &#8220;abcd&#8221;, it will write &#8220;abcdabcaba&#8221; to the output:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
%% 
a        | 
ab       | 
abc      | 
abcd     ECHO; REJECT; 
.|\n     /* eat up any unmatched character */</pre>
<div class="spacer">
</div>
(The first three rules share the fourth's action since they use the special &#8216;|&#8217; action.) <span class="emph">REJECT</span> is a particularly expensive feature in terms of scanner performance; if it is used in any of the scanner's actions it will slow down all of the scanner's matching. Furthermore, <span class="emph">REJECT</span> cannot be used with the <b class="flag">-Cf</b> or <b class="flag">-CF</b> options (see below).<div class="spacer">
</div>
Note also that unlike the other special actions, <span class="emph">REJECT</span> is a <span class="emph">branch</span>; code immediately following it in the action will not be executed.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
yymore()</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Tells the scanner that the next time it matches a rule, the corresponding token should be appended onto the current value of <i class="farg">yytext</i> rather than replacing it. For example, given the input &#8220;mega-kludge&#8221; the following will write &#8220;mega-mega-kludge&#8221; to the output:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
%% 
mega-    ECHO; yymore(); 
kludge   ECHO;</pre>
<div class="spacer">
</div>
First &#8220;mega-&#8221; is matched and echoed to the output. Then &#8220;kludge&#8221; is matched, but the previous &#8220;mega-&#8221; is still hanging around at the beginning of <i class="farg">yytext</i> so the <span class="emph">ECHO</span> for the &#8220;kludge&#8221; rule will actually write &#8220;mega-kludge&#8221;.<div class="spacer">
</div>
Two notes regarding use of <b class="fname">yymore</b>(): First, <b class="fname">yymore</b>() depends on the value of <i class="farg">yyleng</i> correctly reflecting the size of the current token, so <i class="farg">yyleng</i> must not be modified when using <b class="fname">yymore</b>(). Second, the presence of <b class="fname">yymore</b>() in the scanner's action entails a minor performance penalty in the scanner's matching speed.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
yyless(n)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Returns all but the first <i class="arg">n</i> characters of the current token back to the input stream, where they will be rescanned when the scanner looks for the next match. <i class="farg">yytext</i> and <i class="farg">yyleng</i> are adjusted appropriately (e.g., <i class="farg">yyleng</i> will now be equal to <i class="arg">n</i>). For example, on the input &#8220;foobar&#8221; the following will write out &#8220;foobarbar&#8221;:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
%% 
foobar    ECHO; yyless(3); 
[a-z]+    ECHO;</pre>
<div class="spacer">
</div>
An argument of 0 to <i class="farg">yyless</i> will cause the entire current input string to be scanned again. Unless how the scanner will subsequently process its input has been changed (using <span class="emph">BEGIN</span>, for example), this will result in an endless loop.<div class="spacer">
</div>
Note that <i class="farg">yyless</i> is a macro and can only be used in the <b class="name">flex</b> input file, not from other source files.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
unput(c)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Puts the character <i class="arg">c</i> back into the input stream. It will be the next character scanned. The following action will take the current token and cause it to be rescanned enclosed in parentheses.<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
{ 
        int i; 
        char *yycopy; 
 
        /* Copy yytext because unput() trashes yytext */ 
        if ((yycopy = strdup(yytext)) == NULL) 
                err(1, NULL); 
        unput(')'); 
        for (i = yyleng - 1; i &gt;= 0; --i) 
                unput(yycopy[i]); 
        unput('('); 
        free(yycopy); 
}</pre>
<div class="spacer">
</div>
Note that since each <b class="fname">unput</b>() puts the given character back at the beginning of the input stream, pushing back strings must be done back-to-front.<div class="spacer">
</div>
An important potential problem when using <b class="fname">unput</b>() is that if using &#8220;%pointer&#8221; (the default), a call to <b class="fname">unput</b>() destroys the contents of <i class="farg">yytext</i>, starting with its rightmost character and devouring one character to the left with each call. If the value of <i class="farg">yytext</i> should be preserved after a call to <b class="fname">unput</b>() (as in the above example), it must either first be copied elsewhere, or the scanner must be built using &#8220;%array&#8221; instead (see <i class="link-sec"><a class="link-sec" href="#x484f572054484520494e505554204953204d415443484544">HOW THE INPUT IS MATCHED</a></i>).<div class="spacer">
</div>
Finally, note that EOF cannot be put back to attempt to mark the input stream with an end-of-file.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
input()</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Reads the next character from the input stream. For example, the following is one way to eat up C comments:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
%% 
&quot;/*&quot; { 
        int c; 
 
        for (;;) { 
                while ((c = input()) != '*' &amp;&amp; c != EOF) 
                        ; /* eat up text of comment */ 
 
                if (c == '*') { 
                        while ((c = input()) == '*') 
                                ; 
                        if (c == '/') 
                                break; /* found the end */ 
                } 
 
                if (c == EOF) { 
                        errx(1, &quot;EOF in comment&quot;); 
                        break; 
                } 
        } 
}</pre>
<div class="spacer">
</div>
(Note that if the scanner is compiled using C++, then <b class="fname">input</b>() is instead referred to as <b class="fname">yyinput</b>(), in order to avoid a name clash with the C++ stream by the name of input.)</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
YY_FLUSH_BUFFER</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Flushes the scanner's internal buffer so that the next time the scanner attempts to match a token, it will first refill the buffer using <span class="define">YY_INPUT</span> (see <i class="link-sec"><a class="link-sec" href="#x5448452047454e455241544544205343414e4e4552">THE GENERATED SCANNER</a></i>, below). This action is a special case of the more general <b class="fname">yy_flush_buffer</b>() function, described below in the section <i class="link-sec"><a class="link-sec" href="#x4d554c5449504c4520494e5055542042554646455253">MULTIPLE INPUT BUFFERS</a></i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
yyterminate()</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Can be used in lieu of a return statement in an action. It terminates the scanner and returns a 0 to the scanner's caller, indicating &#8220;all done&#8221;. By default, <b class="fname">yyterminate</b>() is also called when an end-of-file is encountered. It is a macro and may be redefined.</dd>
</dl>
</div>
<div class="section">
<h1 id="x5448452047454e455241544544205343414e4e4552">THE GENERATED SCANNER</h1> The output of <b class="name">flex</b> is the file <i class="file">lex.yy.c</i>, which contains the scanning routine <b class="fname">yylex</b>(), a number of tables used by it for matching tokens, and a number of auxiliary routines and macros. By default, <b class="fname">yylex</b>() is declared as follows:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
int yylex() 
{ 
    ... various definitions and the actions in here ... 
}</pre>
<div class="spacer">
</div>
(If the environment supports function prototypes, then it will be &quot;int yylex(void)&quot;.) This definition may be changed by defining the <span class="define">YY_DECL</span> macro. For example:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
#define YY_DECL float lexscan(a, b) float a, b;</pre>
<div class="spacer">
</div>
would give the scanning routine the name <span class="emph">lexscan</span>, returning a float, and taking two floats as arguments. Note that if arguments are given to the scanning routine using a K&amp;R-style/non-prototyped function declaration, the definition must be terminated with a semi-colon (&#8216;;&#8217;).<div class="spacer">
</div>
Whenever <b class="fname">yylex</b>() is called, it scans tokens from the global input file <i class="file">yyin</i> (which defaults to stdin). It continues until it either reaches an end-of-file (at which point it returns the value 0) or one of its actions executes a <span class="emph">return</span> statement.<div class="spacer">
</div>
If the scanner reaches an end-of-file, subsequent calls are undefined unless either <span class="emph">yyin</span> is pointed at a new input file (in which case scanning continues from that file), or <b class="fname">yyrestart</b>() is called. <b class="fname">yyrestart</b>() takes one argument, a <i class="farg">FILE *</i> pointer (which can be nil, if <span class="define">YY_INPUT</span> has been set up to scan from a source other than <span class="emph">yyin</span>), and initializes <span class="emph">yyin</span> for scanning from that file. Essentially there is no difference between just assigning <span class="emph">yyin</span> to a new input file or using <b class="fname">yyrestart</b>() to do so; the latter is available for compatibility with previous versions of <b class="name">flex</b>, and because it can be used to switch input files in the middle of scanning. It can also be used to throw away the current input buffer, by calling it with an argument of <span class="emph">yyin</span>; but better is to use <span class="define">YY_FLUSH_BUFFER</span> (see above). Note that <b class="fname">yyrestart</b>() does not reset the start condition to <span class="emph">INITIAL</span> (see <i class="link-sec"><a class="link-sec" href="#x535441525420434f4e444954494f4e53">START CONDITIONS</a></i>, below).<div class="spacer">
</div>
If <b class="fname">yylex</b>() stops scanning due to executing a <span class="emph">return</span> statement in one of the actions, the scanner may then be called again and it will resume scanning where it left off.<div class="spacer">
</div>
By default (and for purposes of efficiency), the scanner uses block-reads rather than simple <a class="link-man" href="../html3/getc.html">getc(3)</a> calls to read characters from <span class="emph">yyin</span>. The nature of how it gets its input can be controlled by defining the <span class="define">YY_INPUT</span> macro. <span class="define">YY_INPUT</span>'s calling sequence is &#8220;YY_INPUT(buf,result,max_size)&#8221;. Its action is to place up to <span class="define">max_size</span> characters in the character array <span class="emph">buf</span> and return in the integer variable <span class="emph">result</span> either the number of characters read or the constant <span class="define">YY_NULL</span> (0 on <span class="unix">UNIX</span> systems) to indicate <span class="define">EOF</span>. The default <span class="define">YY_INPUT</span> reads from the global file-pointer &#8220;yyin&#8221;.<div class="spacer">
</div>
A sample definition of <span class="define">YY_INPUT</span> (in the definitions section of the input file):<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
%{ 
#define YY_INPUT(buf,result,max_size) \ 
{ \ 
        int c = getchar(); \ 
        result = (c == EOF) ? YY_NULL : (buf[0] = c, 1); \ 
} 
%}</pre>
<div class="spacer">
</div>
This definition will change the input processing to occur one character at a time.<div class="spacer">
</div>
When the scanner receives an end-of-file indication from <span class="define">YY_INPUT</span>, it then checks the <b class="fname">yywrap</b>() function. If <b class="fname">yywrap</b>() returns false (zero), then it is assumed that the function has gone ahead and set up <span class="emph">yyin</span> to point to another input file, and scanning continues. If it returns true (non-zero), then the scanner terminates, returning 0 to its caller. Note that in either case, the start condition remains unchanged; it does not revert to <span class="emph">INITIAL</span>.<div class="spacer">
</div>
If you do not supply your own version of <b class="fname">yywrap</b>(), then you must either use &#8220;%option noyywrap&#8221; (in which case the scanner behaves as though <b class="fname">yywrap</b>() returned 1), or you must link with <b class="flag">-lfl</b> to obtain the default version of the routine, which always returns 1.<div class="spacer">
</div>
Three routines are available for scanning from in-memory buffers rather than files: <b class="fname">yy_scan_string</b>(), <b class="fname">yy_scan_bytes</b>(), and <b class="fname">yy_scan_buffer</b>(). See the discussion of them below in the section <i class="link-sec"><a class="link-sec" href="#x4d554c5449504c4520494e5055542042554646455253">MULTIPLE INPUT BUFFERS</a></i>.<div class="spacer">
</div>
The scanner writes its <span class="emph">ECHO</span> output to the <span class="emph">yyout</span> global (default, stdout), which may be redefined by the user simply by assigning it to some other <b class="var">FILE</b> pointer.</div>
<div class="section">
<h1 id="x535441525420434f4e444954494f4e53">START CONDITIONS</h1> <b class="name">flex</b> provides a mechanism for conditionally activating rules. Any rule whose pattern is prefixed with &#8220;&#10216;sc&#10217;&#8221; will only be active when the scanner is in the start condition named &#8220;sc&#8221;. For example,<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
&lt;STRING&gt;[^&quot;]* { /* eat up the string body ... */ 
        ... 
}</pre>
<div class="spacer">
</div>
will be active only when the scanner is in the &#8220;STRING&#8221; start condition, and<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
&lt;INITIAL,STRING,QUOTE&gt;\. { /* handle an escape ... */ 
        ... 
}</pre>
<div class="spacer">
</div>
will be active only when the current start condition is either &#8220;INITIAL&#8221;, &#8220;STRING&#8221;, or &#8220;QUOTE&#8221;.<div class="spacer">
</div>
Start conditions are declared in the definitions (first) section of the input using unindented lines beginning with either &#8216;%s&#8217; or &#8216;%x&#8217; followed by a list of names. The former declares <span class="emph">inclusive</span> start conditions, the latter <span class="emph">exclusive</span> start conditions. A start condition is activated using the <span class="emph">BEGIN</span> action. Until the next <span class="emph">BEGIN</span> action is executed, rules with the given start condition will be active and rules with other start conditions will be inactive. If the start condition is inclusive, then rules with no start conditions at all will also be active. If it is exclusive, then only rules qualified with the start condition will be active. A set of rules contingent on the same exclusive start condition describe a scanner which is independent of any of the other rules in the <b class="name">flex</b> input. Because of this, exclusive start conditions make it easy to specify &#8220;mini-scanners&#8221; which scan portions of the input that are syntactically different from the rest (e.g., comments).<div class="spacer">
</div>
If the distinction between inclusive and exclusive start conditions is still a little vague, here's a simple example illustrating the connection between the two. The set of rules:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
%s example 
%% 
 
&lt;example&gt;foo   do_something(); 
 
bar            something_else();</pre>
<div class="spacer">
</div>
is equivalent to<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
%x example 
%% 
 
&lt;example&gt;foo   do_something(); 
 
&lt;INITIAL,example&gt;bar    something_else();</pre>
<div class="spacer">
</div>
Without the &#10216;INITIAL,example&#10217; qualifier, the &#8220;bar&#8221; pattern in the second example wouldn't be active (i.e., couldn't match) when in start condition &#8220;example&#8221;. If we just used &#10216;example&#10217; to qualify &#8220;bar&#8221;, though, then it would only be active in &#8220;example&#8221; and not in <span class="emph">INITIAL</span>, while in the first example it's active in both, because in the first example the &#8220;example&#8221; start condition is an inclusive (&#8216;%s&#8217;) start condition.<div class="spacer">
</div>
Also note that the special start-condition specifier &#8216;&#10216;*&#10217;&#8217; matches every start condition. Thus, the above example could also have been written:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
%x example 
%% 
 
&lt;example&gt;foo   do_something(); 
 
&lt;*&gt;bar         something_else();</pre>
<div class="spacer">
</div>
The default rule (to <span class="emph">ECHO</span> any unmatched character) remains active in start conditions. It is equivalent to:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
&lt;*&gt;.|\n     ECHO;</pre>
<div class="spacer">
</div>
&#8220;BEGIN(0)&#8221; returns to the original state where only the rules with no start conditions are active. This state can also be referred to as the start-condition <span class="emph">INITIAL</span>, so &#8220;BEGIN(INITIAL)&#8221; is equivalent to &#8220;BEGIN(0)&#8221;. (The parentheses around the start condition name are not required but are considered good style.)<div class="spacer">
</div>
<span class="emph">BEGIN</span> actions can also be given as indented code at the beginning of the rules section. For example, the following will cause the scanner to enter the &#8220;SPECIAL&#8221; start condition whenever <b class="fname">yylex</b>() is called and the global variable <i class="farg">enter_special</i> is true:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
int enter_special; 
 
%x SPECIAL 
%% 
        if (enter_special) 
                BEGIN(SPECIAL); 
 
&lt;SPECIAL&gt;blahblahblah 
...more rules follow...</pre>
<div class="spacer">
</div>
To illustrate the uses of start conditions, here is a scanner which provides two different interpretations of a string like &#8220;123.456&#8221;. By default it will treat it as three tokens: the integer &#8220;123&#8221;, a dot (&#8216;.&#8217;), and the integer &#8220;456&#8221;. But if the string is preceded earlier in the line by the string &#8220;expect-floats&#8221; it will treat it as a single token, the floating-point number 123.456:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
%{ 
#include &lt;math.h&gt; 
%} 
%s expect 
 
%% 
expect-floats        BEGIN(expect); 
 
&lt;expect&gt;[0-9]+&quot;.&quot;[0-9]+ { 
        printf(&quot;found a float, = %f\n&quot;, 
            atof(yytext)); 
} 
&lt;expect&gt;\n { 
        /* 
         * That's the end of the line, so 
         * we need another &quot;expect-number&quot; 
         * before we'll recognize any more 
         * numbers. 
         */ 
        BEGIN(INITIAL); 
} 
 
[0-9]+ { 
        printf(&quot;found an integer, = %d\n&quot;, 
            atoi(yytext)); 
} 
 
&quot;.&quot;     printf(&quot;found a dot\n&quot;);</pre>
<div class="spacer">
</div>
Here is a scanner which recognizes (and discards) C comments while maintaining a count of the current input line:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
%x comment 
%% 
int line_num = 1; 
 
&quot;/*&quot;                    BEGIN(comment); 
 
&lt;comment&gt;[^*\n]*        /* eat anything that's not a '*' */ 
&lt;comment&gt;&quot;*&quot;+[^*/\n]*   /* eat up '*'s not followed by '/'s */ 
&lt;comment&gt;\n             ++line_num; 
&lt;comment&gt;&quot;*&quot;+&quot;/&quot;        BEGIN(INITIAL);</pre>
<div class="spacer">
</div>
This scanner goes to a bit of trouble to match as much text as possible with each rule. In general, when attempting to write a high-speed scanner try to match as much as possible in each rule, as it's a big win.<div class="spacer">
</div>
Note that start-condition names are really integer values and can be stored as such. Thus, the above could be extended in the following fashion:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
%x comment foo 
%% 
int line_num = 1; 
int comment_caller; 
 
&quot;/*&quot; { 
        comment_caller = INITIAL; 
        BEGIN(comment); 
} 
 
... 
 
&lt;foo&gt;&quot;/*&quot; { 
        comment_caller = foo; 
        BEGIN(comment); 
} 
 
&lt;comment&gt;[^*\n]*        /* eat anything that's not a '*' */ 
&lt;comment&gt;&quot;*&quot;+[^*/\n]*   /* eat up '*'s not followed by '/'s */ 
&lt;comment&gt;\n             ++line_num; 
&lt;comment&gt;&quot;*&quot;+&quot;/&quot;        BEGIN(comment_caller);</pre>
<div class="spacer">
</div>
Furthermore, the current start condition can be accessed by using the integer-valued <span class="define">YY_START</span> macro. For example, the above assignments to <span class="emph">comment_caller</span> could instead be written<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">comment_caller = YY_START;</code></div>
</blockquote>
<div class="spacer">
</div>
Flex provides <span class="define">YYSTATE</span> as an alias for <span class="define">YY_START</span> (since that is what's used by AT&amp;T UNIX <b class="name">lex</b>).<div class="spacer">
</div>
Note that start conditions do not have their own name-space; %s's and %x's declare names in the same fashion as #define's.<div class="spacer">
</div>
Finally, here's an example of how to match C-style quoted strings using exclusive start conditions, including expanded escape sequences (but not including checking for a string that's too long):<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
%x str 
 
%% 
#define MAX_STR_CONST 1024 
char string_buf[MAX_STR_CONST]; 
char *string_buf_ptr; 
 
\&quot;      string_buf_ptr = string_buf; BEGIN(str); 
 
&lt;str&gt;\&quot; { /* saw closing quote - all done */ 
        BEGIN(INITIAL); 
        *string_buf_ptr = '\0'; 
        /* 
         * return string constant token type and 
         * value to parser 
         */ 
} 
 
&lt;str&gt;\n { 
        /* error - unterminated string constant */ 
        /* generate error message */ 
} 
 
&lt;str&gt;\\[0-7]{1,3} { 
        /* octal escape sequence */ 
        int result; 
 
        (void) sscanf(yytext + 1, &quot;%o&quot;, &amp;result); 
 
        if (result &gt; 0xff) { 
                /* error, constant is out-of-bounds */ 
	} else 
	        *string_buf_ptr++ = result; 
} 
 
&lt;str&gt;\\[0-9]+ { 
        /* 
         * generate error - bad escape sequence; something 
         * like '\48' or '\0777777' 
         */ 
} 
 
&lt;str&gt;\\n  *string_buf_ptr++ = '\n'; 
&lt;str&gt;\\t  *string_buf_ptr++ = '\t'; 
&lt;str&gt;\\r  *string_buf_ptr++ = '\r'; 
&lt;str&gt;\\b  *string_buf_ptr++ = '\b'; 
&lt;str&gt;\\f  *string_buf_ptr++ = '\f'; 
 
&lt;str&gt;\\(.|\n)  *string_buf_ptr++ = yytext[1]; 
 
&lt;str&gt;[^\\\n\&quot;]+ { 
        char *yptr = yytext; 
 
        while (*yptr) 
                *string_buf_ptr++ = *yptr++; 
}</pre>
<div class="spacer">
</div>
Often, such as in some of the examples above, a whole bunch of rules are all preceded by the same start condition(s). <b class="name">flex</b> makes this a little easier and cleaner by introducing a notion of start condition <span class="emph">scope</span>. A start condition scope is begun with:<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">&lt;SCs&gt;{</code></div>
</blockquote>
<div class="spacer">
</div>
where &#8220;SCs&#8221; is a list of one or more start conditions. Inside the start condition scope, every rule automatically has the prefix &#10216;SCs&#10217; applied to it, until a &#8216;}&#8217; which matches the initial &#8216;{&#8217;. So, for example,<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
&lt;ESC&gt;{ 
    &quot;\\n&quot;   return '\n'; 
    &quot;\\r&quot;   return '\r'; 
    &quot;\\f&quot;   return '\f'; 
    &quot;\\0&quot;   return '\0'; 
}</pre>
<div class="spacer">
</div>
is equivalent to:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
&lt;ESC&gt;&quot;\\n&quot;  return '\n'; 
&lt;ESC&gt;&quot;\\r&quot;  return '\r'; 
&lt;ESC&gt;&quot;\\f&quot;  return '\f'; 
&lt;ESC&gt;&quot;\\0&quot;  return '\0';</pre>
<div class="spacer">
</div>
Start condition scopes may be nested.<div class="spacer">
</div>
Three routines are available for manipulating stacks of start conditions:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
void yy_push_state(int new_state)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Pushes the current start condition onto the top of the start condition stack and switches to <i class="farg">new_state</i> as though &#8220;BEGIN new_state&#8221; had been used (recall that start condition names are also integers).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
void yy_pop_state()</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Pops the top of the stack and switches to it via <span class="emph">BEGIN</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
int yy_top_state()</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Returns the top of the stack without altering the stack's contents.</dd>
</dl>
<div class="spacer">
</div>
The start condition stack grows dynamically and so has no built-in size limitation. If memory is exhausted, program execution aborts.<div class="spacer">
</div>
To use start condition stacks, scanners must include a &#8220;%option stack&#8221; directive (see <i class="link-sec"><a class="link-sec" href="#x4f5054494f4e53">OPTIONS</a></i> below).</div>
<div class="section">
<h1 id="x4d554c5449504c4520494e5055542042554646455253">MULTIPLE INPUT BUFFERS</h1> Some scanners (such as those which support &#8220;include&#8221; files) require reading from several input streams. As <b class="name">flex</b> scanners do a large amount of buffering, one cannot control where the next input will be read from by simply writing a <span class="define">YY_INPUT</span> which is sensitive to the scanning context. <span class="define">YY_INPUT</span> is only called when the scanner reaches the end of its buffer, which may be a long time after scanning a statement such as an &#8220;include&#8221; which requires switching the input source.<div class="spacer">
</div>
To negotiate these sorts of problems, <b class="name">flex</b> provides a mechanism for creating and switching between multiple input buffers. An input buffer is created by using:<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
YY_BUFFER_STATE yy_create_buffer(FILE *file, int size)</div>
</blockquote>
<div class="spacer">
</div>
which takes a <i class="farg">FILE</i> pointer and a <i class="farg">size</i> and creates a buffer associated with the given file and large enough to hold <i class="farg">size</i> characters (when in doubt, use <span class="define">YY_BUF_SIZE</span> for the size). It returns a <span class="define">YY_BUFFER_STATE</span> handle, which may then be passed to other routines (see below). The <span class="define">YY_BUFFER_STATE</span> type is a pointer to an opaque &#8220;struct yy_buffer_state&#8221; structure, so <span class="define">YY_BUFFER_STATE</span> variables may be safely initialized to &#8220;((YY_BUFFER_STATE) 0)&#8221; if desired, and the opaque structure can also be referred to in order to correctly declare input buffers in source files other than that of scanners. Note that the <i class="farg">FILE</i> pointer in the call to <b class="fname">yy_create_buffer</b>() is only used as the value of <i class="farg">yyin</i> seen by <span class="define">YY_INPUT</span>; if <span class="define">YY_INPUT</span> is redefined so that it no longer uses <i class="farg">yyin</i>, then a nil <i class="farg">FILE</i> pointer can safely be passed to <b class="fname">yy_create_buffer</b>(). To select a particular buffer to scan:<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer)</div>
</blockquote>
<div class="spacer">
</div>
It switches the scanner's input buffer so subsequent tokens will come from <i class="farg">new_buffer</i>. Note that <b class="fname">yy_switch_to_buffer</b>() may be used by <b class="fname">yywrap</b>() to set things up for continued scanning, instead of opening a new file and pointing <i class="farg">yyin</i> at it. Note also that switching input sources via either <b class="fname">yy_switch_to_buffer</b>() or <b class="fname">yywrap</b>() does not change the start condition.<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
void yy_delete_buffer(YY_BUFFER_STATE buffer)</div>
</blockquote>
<div class="spacer">
</div>
is used to reclaim the storage associated with a buffer. (<i class="farg">buffer</i> can be nil, in which case the routine does nothing.) To clear the current contents of a buffer:<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
void yy_flush_buffer(YY_BUFFER_STATE buffer)</div>
</blockquote>
<div class="spacer">
</div>
This function discards the buffer's contents, so the next time the scanner attempts to match a token from the buffer, it will first fill the buffer anew using <span class="define">YY_INPUT</span>.<div class="spacer">
</div>
<b class="fname">yy_new_buffer</b>() is an alias for <b class="fname">yy_create_buffer</b>(), provided for compatibility with the C++ use of <span class="emph">new</span> and <span class="emph">delete</span> for creating and destroying dynamic objects.<div class="spacer">
</div>
Finally, the <span class="define">YY_CURRENT_BUFFER</span> macro returns a <span class="define">YY_BUFFER_STATE</span> handle to the current buffer.<div class="spacer">
</div>
Here is an example of using these features for writing a scanner which expands include files (the &#10216;&#10216;EOF&#10217;&#10217; feature is discussed below):<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
/* 
 * the &quot;incl&quot; state is used for picking up the name 
 * of an include file 
 */ 
%x incl 
 
%{ 
#define MAX_INCLUDE_DEPTH 10 
YY_BUFFER_STATE include_stack[MAX_INCLUDE_DEPTH]; 
int include_stack_ptr = 0; 
%} 
 
%% 
include             BEGIN(incl); 
 
[a-z]+              ECHO; 
[^a-z\n]*\n?        ECHO; 
 
&lt;incl&gt;[ \t]*        /* eat the whitespace */ 
&lt;incl&gt;[^ \t\n]+ {   /* got the include file name */ 
        if (include_stack_ptr &gt;= MAX_INCLUDE_DEPTH) 
                errx(1, &quot;Includes nested too deeply&quot;); 
 
        include_stack[include_stack_ptr++] = 
            YY_CURRENT_BUFFER; 
 
        yyin = fopen(yytext, &quot;r&quot;); 
 
        if (yyin == NULL) 
                err(1, NULL); 
 
        yy_switch_to_buffer( 
            yy_create_buffer(yyin, YY_BUF_SIZE)); 
 
        BEGIN(INITIAL); 
} 
 
&lt;&lt;EOF&gt;&gt; { 
        if (--include_stack_ptr &lt; 0) 
                yyterminate(); 
        else { 
                yy_delete_buffer(YY_CURRENT_BUFFER); 
                yy_switch_to_buffer( 
                    include_stack[include_stack_ptr]); 
       } 
}</pre>
<div class="spacer">
</div>
Three routines are available for setting up input buffers for scanning in-memory strings instead of files. All of them create a new input buffer for scanning the string, and return a corresponding <span class="define">YY_BUFFER_STATE</span> handle (which should be deleted afterwards using <b class="fname">yy_delete_buffer</b>()). They also switch to the new buffer using <b class="fname">yy_switch_to_buffer</b>(), so the next call to <b class="fname">yylex</b>() will start scanning the string.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
yy_scan_string(const char *str)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Scans a NUL-terminated string.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
yy_scan_bytes(const char *bytes, int len)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Scans <i class="farg">len</i> bytes (including possibly NUL's) starting at location <i class="farg">bytes</i>.</dd>
</dl>
<div class="spacer">
</div>
Note that both of these functions create and scan a copy of the string or bytes. (This may be desirable, since <b class="fname">yylex</b>() modifies the contents of the buffer it is scanning.) The copy can be avoided by using:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
yy_scan_buffer(char *base, yy_size_t size)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Which scans the buffer starting at <i class="farg">base</i>, consisting of <i class="farg">size</i> bytes, the last two bytes of which must be <span class="define">YY_END_OF_BUFFER_CHAR</span> (ASCII NUL). These last two bytes are not scanned; thus, scanning consists of base[0] through base[size-2], inclusive.<div class="spacer">
</div>
If <i class="farg">base</i> is not set up in this manner (i.e., forget the final two <span class="define">YY_END_OF_BUFFER_CHAR</span> bytes), then <b class="fname">yy_scan_buffer</b>() returns a nil pointer instead of creating a new input buffer.<div class="spacer">
</div>
The type <i class="farg">yy_size_t</i> is an integral type which can be cast to an integer expression reflecting the size of the buffer.</dd>
</dl>
</div>
<div class="section">
<h1 id="x454e441e4f461e46494c452052554c4553">END-OF-FILE RULES</h1> The special rule &#8220;&#10216;&#10216;EOF&#10217;&#10217;&#8221; indicates actions which are to be taken when an end-of-file is encountered and <b class="fname">yywrap</b>() returns non-zero (i.e., indicates no further files to process). The action must finish by doing one of four things:<ul style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-dash">
<li class="list-dash" style="margin-top: 1.00em;">
Assigning <span class="emph">yyin</span> to a new input file (in previous versions of <b class="name">flex</b>, after doing the assignment, it was necessary to call the special action <span class="define">YY_NEW_FILE</span>; this is no longer necessary).</li>
<li class="list-dash" style="margin-top: 1.00em;">
Executing a <span class="emph">return</span> statement.</li>
<li class="list-dash" style="margin-top: 1.00em;">
Executing the special <b class="fname">yyterminate</b>() action.</li>
<li class="list-dash" style="margin-top: 1.00em;">
Switching to a new buffer using <b class="fname">yy_switch_to_buffer</b>() as shown in the example above.</li>
</ul>
<div class="spacer">
</div>
&#10216;&#10216;EOF&#10217;&#10217; rules may not be used with other patterns; they may only be qualified with a list of start conditions. If an unqualified &#10216;&#10216;EOF&#10217;&#10217; rule is given, it applies to all start conditions which do not already have &#10216;&#10216;EOF&#10217;&#10217; actions. To specify an &#10216;&#10216;EOF&#10217;&#10217; rule for only the initial start condition, use<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">&lt;INITIAL&gt;&lt;&lt;EOF&gt;&gt;</code></div>
</blockquote>
<div class="spacer">
</div>
These rules are useful for catching things like unclosed comments. An example:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
%x quote 
%% 
 
...other rules for dealing with quotes... 
 
&lt;quote&gt;&lt;&lt;EOF&gt;&gt; { 
         error(&quot;unterminated quote&quot;); 
         yyterminate(); 
} 
&lt;&lt;EOF&gt;&gt; { 
         if (*++filelist) 
                 yyin = fopen(*filelist, &quot;r&quot;); 
         else 
                 yyterminate(); 
}</pre>
</div>
<div class="section">
<h1 id="x4d495343454c4c414e454f5553204d4143524f53">MISCELLANEOUS MACROS</h1> The macro <span class="define">YY_USER_ACTION</span> can be defined to provide an action which is always executed prior to the matched rule's action. For example, it could be #define'd to call a routine to convert yytext to lower-case. When <span class="define">YY_USER_ACTION</span> is invoked, the variable <i class="farg">yy_act</i> gives the number of the matched rule (rules are numbered starting with 1). For example, to profile how often each rule is matched, the following would do the trick:<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">#define YY_USER_ACTION ++ctr[yy_act]</code></div>
</blockquote>
<div class="spacer">
</div>
where <i class="farg">ctr</i> is an array to hold the counts for the different rules. Note that the macro <span class="define">YY_NUM_RULES</span> gives the total number of rules (including the default rule, even if <b class="flag">-s</b> is used), so a correct declaration for <i class="farg">ctr</i> is:<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">int ctr[YY_NUM_RULES];</code></div>
</blockquote>
<div class="spacer">
</div>
The macro <span class="define">YY_USER_INIT</span> may be defined to provide an action which is always executed before the first scan (and before the scanner's internal initializations are done). For example, it could be used to call a routine to read in a data table or open a logging file.<div class="spacer">
</div>
The macro <span class="define">yy_set_interactive(is_interactive)</span> can be used to control whether the current buffer is considered <span class="emph">interactive</span>. An interactive buffer is processed more slowly, but must be used when the scanner's input source is indeed interactive to avoid problems due to waiting to fill buffers (see the discussion of the <b class="flag">-I</b> flag below). A non-zero value in the macro invocation marks the buffer as interactive, a zero value as non-interactive. Note that use of this macro overrides &#8220;%option always-interactive&#8221; or &#8220;%option never-interactive&#8221; (see <i class="link-sec"><a class="link-sec" href="#x4f5054494f4e53">OPTIONS</a></i> below). <b class="fname">yy_set_interactive</b>() must be invoked prior to beginning to scan the buffer that is (or is not) to be considered interactive.<div class="spacer">
</div>
The macro <span class="define">yy_set_bol(at_bol)</span> can be used to control whether the current buffer's scanning context for the next token match is done as though at the beginning of a line. A non-zero macro argument makes rules anchored with &#8216;^&#8217; active, while a zero argument makes &#8216;^&#8217; rules inactive.<div class="spacer">
</div>
The macro <span class="define">YY_AT_BOL</span> returns true if the next token scanned from the current buffer will have &#8216;^&#8217; rules active, false otherwise.<div class="spacer">
</div>
In the generated scanner, the actions are all gathered in one large switch statement and separated using <span class="define">YY_BREAK</span>, which may be redefined. By default, it is simply a &#8220;break&#8221;, to separate each rule's action from the following rules. Redefining <span class="define">YY_BREAK</span> allows, for example, C++ users to &#8220;#define YY_BREAK&#8221; to do nothing (while being very careful that every rule ends with a &#8220;break&#8221; or a &#8220;return&#8221;!) to avoid suffering from unreachable statement warnings where because a rule's action ends with &#8220;return&#8221;, the <span class="define">YY_BREAK</span> is inaccessible.</div>
<div class="section">
<h1 id="x56414c55455320415641494c41424c4520544f205448452055534552">VALUES AVAILABLE TO THE USER</h1> This section summarizes the various values available to the user in the rule actions.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
char *yytext</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Holds the text of the current token. It may be modified but not lengthened (characters cannot be appended to the end).<div class="spacer">
</div>
If the special directive &#8220;%array&#8221; appears in the first section of the scanner description, then <i class="farg">yytext</i> is instead declared &#8220;char yytext[YYLMAX]&#8221;, where <span class="define">YYLMAX</span> is a macro definition that can be redefined in the first section to change the default value (generally 8KB). Using &#8220;%array&#8221; results in somewhat slower scanners, but the value of <i class="farg">yytext</i> becomes immune to calls to <b class="fname">input</b>() and <b class="fname">unput</b>(), which potentially destroy its value when <i class="farg">yytext</i> is a character pointer. The opposite of &#8220;%array&#8221; is &#8220;%pointer&#8221;, which is the default.<div class="spacer">
</div>
&#8220;%array&#8221; cannot be used when generating C++ scanner classes (the <b class="flag">-+</b> flag).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
int yyleng</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Holds the length of the current token.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
FILE *yyin</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Is the file which by default <b class="name">flex</b> reads from. It may be redefined, but doing so only makes sense before scanning begins or after an <span class="define">EOF</span> has been encountered. Changing it in the midst of scanning will have unexpected results since <b class="name">flex</b> buffers its input; use <b class="fname">yyrestart</b>() instead. Once scanning terminates because an end-of-file has been seen, <i class="farg">yyin</i> can be assigned as the new input file and the scanner can be called again to continue scanning.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
void yyrestart(FILE *new_file)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
May be called to point <i class="farg">yyin</i> at the new input file. The switch-over to the new file is immediate (any previously buffered-up input is lost). Note that calling <b class="fname">yyrestart</b>() with <i class="farg">yyin</i> as an argument thus throws away the current input buffer and continues scanning the same input file.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
FILE *yyout</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Is the file to which <span class="emph">ECHO</span> actions are done. It can be reassigned by the user.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
YY_CURRENT_BUFFER</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Returns a <span class="define">YY_BUFFER_STATE</span> handle to the current buffer.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
YY_START</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Returns an integer value corresponding to the current start condition. This value can subsequently be used with <span class="emph">BEGIN</span> to return to that start condition.</dd>
</dl>
</div>
<div class="section">
<h1 id="x494e544552464143494e4720574954482059414343">INTERFACING WITH YACC</h1> One of the main uses of <b class="name">flex</b> is as a companion to the <a class="link-man" href="../html1/yacc.html">yacc(1)</a> parser-generator. yacc parsers expect to call a routine named <b class="fname">yylex</b>() to find the next input token. The routine is supposed to return the type of the next token as well as putting any associated value in the global <i class="farg">yylval</i>, which is defined externally, and can be a union or any other complex data structure. To use <b class="name">flex</b> with yacc, one specifies the <b class="flag">-d</b> option to yacc to instruct it to generate the file <i class="file">y.tab.h</i> containing definitions of all the &#8220;%tokens&#8221; appearing in the yacc input. This file is then included in the <b class="name">flex</b> scanner. For example, if one of the tokens is &#8220;TOK_NUMBER&#8221;, part of the scanner might look like:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
%{ 
#include &quot;y.tab.h&quot; 
%} 
 
%% 
 
[0-9]+        yylval = atoi(yytext); return TOK_NUMBER;</pre>
</div>
<div class="section">
<h1 id="x4f5054494f4e53">OPTIONS</h1> <b class="name">flex</b> has the following options:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">-7</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Instructs <b class="name">flex</b> to generate a 7-bit scanner, i.e., one which can only recognize 7-bit characters in its input. The advantage of using <b class="flag">-7</b> is that the scanner's tables can be up to half the size of those generated using the <b class="flag">-8</b> option (see below). The disadvantage is that such scanners often hang or crash if their input contains an 8-bit character.<div class="spacer">
</div>
Note, however, that unless generating a scanner using the <b class="flag">-Cf</b> or <b class="flag">-CF</b> table compression options, use of <b class="flag">-7</b> will save only a small amount of table space, and make the scanner considerably less portable. <b class="name">flex</b>'s default behavior is to generate an 8-bit scanner unless <b class="flag">-Cf</b> or <b class="flag">-CF</b> is specified, in which case <b class="name">flex</b> defaults to generating 7-bit scanners unless it was configured to generate 8-bit scanners (as will often be the case with non-USA sites). It is possible tell whether <b class="name">flex</b> generated a 7-bit or an 8-bit scanner by inspecting the flag summary in the <b class="flag">-v</b> output as described below.<div class="spacer">
</div>
Note that if <b class="flag">-Cfe</b> or <b class="flag">-CFe</b> are used (the table compression options, but also using equivalence classes as discussed below), <b class="name">flex</b> still defaults to generating an 8-bit scanner, since usually with these compression options full 8-bit tables are not much more expensive than 7-bit tables.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">-8</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Instructs <b class="name">flex</b> to generate an 8-bit scanner, i.e., one which can recognize 8-bit characters. This flag is only needed for scanners generated using <b class="flag">-Cf</b> or <b class="flag">-CF</b>, as otherwise <b class="name">flex</b> defaults to generating an 8-bit scanner anyway.<div class="spacer">
</div>
See the discussion of <b class="flag">-7</b> above for <b class="name">flex</b>'s default behavior and the tradeoffs between 7-bit and 8-bit scanners.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">-B</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Instructs <b class="name">flex</b> to generate a <span class="emph">batch</span> scanner, the opposite of <span class="emph">interactive</span> scanners generated by <b class="flag">-I</b> (see below). In general, <b class="flag">-B</b> is used when the scanner will never be used interactively, and you want to squeeze a little more performance out of it. If the aim is instead to squeeze out a lot more performance, use the <b class="flag">-Cf</b> or <b class="flag">-CF</b> options (discussed below), which turn on <b class="flag">-B</b> automatically anyway.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">-b</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Generate backing-up information to <i class="file">lex.backup</i>. This is a list of scanner states which require backing up and the input characters on which they do so. By adding rules one can remove backing-up states. If all backing-up states are eliminated and <b class="flag">-Cf</b> or <b class="flag">-CF</b> is used, the generated scanner will run faster (see the <b class="flag">-p</b> flag). Only users who wish to squeeze every last cycle out of their scanners need worry about this option. (See the section on <i class="link-sec"><a class="link-sec" href="#x504552464f524d414e434520434f4e53494445524154494f4e53">PERFORMANCE CONSIDERATIONS</a></i> below.)</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">-C</b>[<span class="opt"><b class="flag">aeFfmr</b></span>]</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Controls the degree of table compression and, more generally, trade-offs between small scanners and fast scanners.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">-Ca</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Instructs <b class="name">flex</b> to trade off larger tables in the generated scanner for faster performance because the elements of the tables are better aligned for memory access and computation. On some RISC architectures, fetching and manipulating longwords is more efficient than with smaller-sized units such as shortwords. This option can double the size of the tables used by the scanner.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">-Ce</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Directs <b class="name">flex</b> to construct <span class="emph">equivalence classes</span>, i.e., sets of characters which have identical lexical properties (for example, if the only appearance of digits in the <b class="name">flex</b> input is in the character class &#8220;[0-9]&#8221; then the digits &#8216;0&#8217;, &#8216;1&#8217;, &#8216;...&#8217;, &#8216;9&#8217; will all be put in the same equivalence class). Equivalence classes usually give dramatic reductions in the final table/object file sizes (typically a factor of 2-5) and are pretty cheap performance-wise (one array look-up per character scanned).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">-CF</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Specifies that the alternate fast scanner representation (described below under the <b class="flag">-F</b> option) should be used. This option cannot be used with <b class="flag">-+</b>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">-Cf</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Specifies that the <span class="emph">full</span> scanner tables should be generated - <b class="name">flex</b> should not compress the tables by taking advantage of similar transition functions for different states.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">-Cm</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Directs <b class="name">flex</b> to construct <span class="emph">meta-equivalence classes</span>, which are sets of equivalence classes (or characters, if equivalence classes are not being used) that are commonly used together. Meta-equivalence classes are often a big win when using compressed tables, but they have a moderate performance impact (one or two &#8220;if&#8221; tests and one array look-up per character scanned).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">-Cr</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Causes the generated scanner to <span class="emph">bypass</span> use of the standard I/O library (stdio) for input. Instead of calling <a class="link-man" href="../html3/fread.html">fread(3)</a> or <a class="link-man" href="../html3/getc.html">getc(3)</a>, the scanner will use the <a class="link-man" href="../html2/read.html">read(2)</a> system call, resulting in a performance gain which varies from system to system, but in general is probably negligible unless <b class="flag">-Cf</b> or <b class="flag">-CF</b> are being used. Using <b class="flag">-Cr</b> can cause strange behavior if, for example, reading from <i class="farg">yyin</i> using stdio prior to calling the scanner (because the scanner will miss whatever text previous reads left in the stdio input buffer).<div class="spacer">
</div>
<b class="flag">-Cr</b> has no effect if <span class="define">YY_INPUT</span> is defined (see <i class="link-sec"><a class="link-sec" href="#x5448452047454e455241544544205343414e4e4552">THE GENERATED SCANNER</a></i> above).</dd>
</dl>
<div class="spacer">
</div>
A lone <b class="flag">-C</b> specifies that the scanner tables should be compressed but neither equivalence classes nor meta-equivalence classes should be used.<div class="spacer">
</div>
The options <b class="flag">-Cf</b> or <b class="flag">-CF</b> and <b class="flag">-Cm</b> do not make sense together - there is no opportunity for meta-equivalence classes if the table is not being compressed. Otherwise the options may be freely mixed, and are cumulative.<div class="spacer">
</div>
The default setting is <b class="flag">-Cem</b> which specifies that <b class="name">flex</b> should generate equivalence classes and meta-equivalence classes. This setting provides the highest degree of table compression. It is possible to trade off faster-executing scanners at the cost of larger tables with the following generally being true:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
slowest &amp; smallest 
      -Cem 
      -Cm 
      -Ce 
      -C 
      -C{f,F}e 
      -C{f,F} 
      -C{f,F}a 
fastest &amp; largest</pre>
<div class="spacer">
</div>
Note that scanners with the smallest tables are usually generated and compiled the quickest, so during development the default is usually best, maximal compression.<div class="spacer">
</div>
<b class="flag">-Cfe</b> is often a good compromise between speed and size for production scanners.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">-d</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Makes the generated scanner run in debug mode. Whenever a pattern is recognized and the global <i class="farg">yy_flex_debug</i> is non-zero (which is the default), the scanner will write to stderr a line of the form:<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
--accepting rule at line 53 (&quot;the matched text&quot;)</div>
</blockquote>
<div class="spacer">
</div>
The line number refers to the location of the rule in the file defining the scanner (i.e., the file that was fed to <b class="name">flex</b>). Messages are also generated when the scanner backs up, accepts the default rule, reaches the end of its input buffer (or encounters a NUL; at this point, the two look the same as far as the scanner's concerned), or reaches an end-of-file.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">-F</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Specifies that the fast scanner table representation should be used (and stdio bypassed). This representation is about as fast as the full table representation (<b class="flag">-f</b>), and for some sets of patterns will be considerably smaller (and for others, larger). In general, if the pattern set contains both &#8220;keywords&#8221; and a catch-all, &#8220;identifier&#8221; rule, such as in the set:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
&quot;case&quot;    return TOK_CASE; 
&quot;switch&quot;  return TOK_SWITCH; 
... 
&quot;default&quot; return TOK_DEFAULT; 
[a-z]+    return TOK_ID;</pre>
<div class="spacer">
</div>
then it's better to use the full table representation. If only the &#8220;identifier&#8221; rule is present and a hash table or some such is used to detect the keywords, it's better to use <b class="flag">-F</b>.<div class="spacer">
</div>
This option is equivalent to <b class="flag">-CFr</b> (see above). It cannot be used with <b class="flag">-+</b>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">-f</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Specifies <span class="emph">fast scanner</span>. No table compression is done and stdio is bypassed. The result is large but fast. This option is equivalent to <b class="flag">-Cfr</b> (see above).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">-h</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Generates a help summary of <b class="name">flex</b>'s options to stdout and then exits. <b class="flag">-?</b> and <b class="flag">-</b><b class="flag">-help</b> are synonyms for <b class="flag">-h</b>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">-I</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Instructs <b class="name">flex</b> to generate an <span class="emph">interactive</span> scanner. An interactive scanner is one that only looks ahead to decide what token has been matched if it absolutely must. It turns out that always looking one extra character ahead, even if the scanner has already seen enough text to disambiguate the current token, is a bit faster than only looking ahead when necessary. But scanners that always look ahead give dreadful interactive performance; for example, when a user types a newline, it is not recognized as a newline token until they enter <span class="emph">another</span> token, which often means typing in another whole line.<div class="spacer">
</div>
<b class="name">flex</b> scanners default to <span class="emph">interactive</span> unless <b class="flag">-Cf</b> or <b class="flag">-CF</b> table-compression options are specified (see above). That's because if high-performance is most important, one of these options should be used, so if they weren't, <b class="name">flex</b> assumes it is preferable to trade off a bit of run-time performance for intuitive interactive behavior. Note also that <b class="flag">-I</b> cannot be used in conjunction with <b class="flag">-Cf</b> or <b class="flag">-CF</b>. Thus, this option is not really needed; it is on by default for all those cases in which it is allowed.<div class="spacer">
</div>
A scanner can be forced to not be interactive by using <b class="flag">-B</b> (see above).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">-i</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Instructs <b class="name">flex</b> to generate a case-insensitive scanner. The case of letters given in the <b class="name">flex</b> input patterns will be ignored, and tokens in the input will be matched regardless of case. The matched text given in <i class="farg">yytext</i> will have the preserved case (i.e., it will not be folded).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">-L</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Instructs <b class="name">flex</b> not to generate &#8220;#line&#8221; directives. Without this option, <b class="name">flex</b> peppers the generated scanner with #line directives so error messages in the actions will be correctly located with respect to either the original <b class="name">flex</b> input file (if the errors are due to code in the input file), or <i class="file">lex.yy.c</i> (if the errors are <b class="name">flex</b>'s fault - these sorts of errors should be reported to the email address given below).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">-l</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Turns on maximum compatibility with the original AT&amp;T UNIX <b class="name">lex</b> implementation. Note that this does not mean full compatibility. Use of this option costs a considerable amount of performance, and it cannot be used with the <b class="flag">-+</b>, <b class="flag">-f</b>, <b class="flag">-F</b>, <b class="flag">-Cf</b>, or <b class="flag">-CF</b> options. For details on the compatibilities it provides, see the section <i class="link-sec"><a class="link-sec" href="#x494e434f4d5041544942494c49544945532057495448204c455820414e4420504f534958">INCOMPATIBILITIES WITH LEX AND POSIX</a></i> below. This option also results in the name <span class="define">YY_FLEX_LEX_COMPAT</span> being #define'd in the generated scanner.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">-n</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Another do-nothing, deprecated option included only for POSIX compliance.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">-o</b><i class="arg">output</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Directs <b class="name">flex</b> to write the scanner to the file <i class="arg">output</i> instead of <i class="file">lex.yy.c</i>. If <b class="flag">-o</b> is combined with the <b class="flag">-t</b> option, then the scanner is written to stdout but its &#8220;#line&#8221; directives (see the <b class="flag">-L</b> option above) refer to the file <i class="arg">output</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">-P</b><i class="arg">prefix</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Changes the default &#8220;yy&#8221; prefix used by <b class="name">flex</b> for all globally visible variable and function names to instead be <i class="arg">prefix</i>. For example, <b class="flag">-P</b><i class="arg">foo</i> changes the name of <i class="farg">yytext</i> to <i class="farg">footext</i>. It also changes the name of the default output file from <i class="file">lex.yy.c</i> to <i class="file">lex.foo.c</i>. Here are all of the names affected:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
yy_create_buffer 
yy_delete_buffer 
yy_flex_debug 
yy_init_buffer 
yy_flush_buffer 
yy_load_buffer_state 
yy_switch_to_buffer 
yyin 
yyleng 
yylex 
yylineno 
yyout 
yyrestart 
yytext 
yywrap</pre>
<div class="spacer">
</div>
(If using a C++ scanner, then only <i class="farg">yywrap</i> and <i class="farg">yyFlexLexer</i> are affected.) Within the scanner itself, it is still possible to refer to the global variables and functions using either version of their name; but externally, they have the modified name.<div class="spacer">
</div>
This option allows multiple <b class="name">flex</b> programs to be easily linked together into the same executable. Note, though, that using this option also renames <b class="fname">yywrap</b>(), so now either an (appropriately named) version of the routine for the scanner must be supplied, or &#8220;%option noyywrap&#8221; must be used, as linking with <b class="flag">-lfl</b> no longer provides one by default.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">-p</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Generates a performance report to stderr. The report consists of comments regarding features of the <b class="name">flex</b> input file which will cause a serious loss of performance in the resulting scanner. If the flag is specified twice, comments regarding features that lead to minor performance losses will also be reported&gt;<div class="spacer">
</div>
Note that the use of <span class="emph">REJECT</span>, &#8220;%option yylineno&#8221;, and variable trailing context (see the <i class="link-sec"><a class="link-sec" href="#x42554753">BUGS</a></i> section below) entails a substantial performance penalty; use of <b class="fname">yymore</b>(), the &#8216;^&#8217; operator, and the <b class="flag">-I</b> flag entail minor performance penalties.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">-S</b><i class="arg">skeleton</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Overrides the default skeleton file from which <b class="name">flex</b> constructs its scanners. This option is needed only for <b class="name">flex</b> maintenance or development.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">-s</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Causes the default rule (that unmatched scanner input is echoed to stdout) to be suppressed. If the scanner encounters input that does not match any of its rules, it aborts with an error. This option is useful for finding holes in a scanner's rule set.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">-T</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Makes <b class="name">flex</b> run in <span class="emph">trace</span> mode. It will generate a lot of messages to stderr concerning the form of the input and the resultant non-deterministic and deterministic finite automata. This option is mostly for use in maintaining <b class="name">flex</b>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">-t</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Instructs <b class="name">flex</b> to write the scanner it generates to standard output instead of <i class="file">lex.yy.c</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">-V</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Prints the version number to stdout and exits. <b class="flag">-</b><b class="flag">-version</b> is a synonym for <b class="flag">-V</b>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">-v</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Specifies that <b class="name">flex</b> should write to stderr a summary of statistics regarding the scanner it generates. Most of the statistics are meaningless to the casual <b class="name">flex</b> user, but the first line identifies the version of <b class="name">flex</b> (same as reported by <b class="flag">-V</b>), and the next line the flags used when generating the scanner, including those that are on by default.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">-w</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Suppresses warning messages.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">-+</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Specifies that <b class="name">flex</b> should generate a C++ scanner class. See the section on <i class="link-sec"><a class="link-sec" href="#x47454e45524154494e4720432b2b205343414e4e455253">GENERATING C++ SCANNERS</a></i> below for details.</dd>
</dl>
<div class="spacer">
</div>
<b class="name">flex</b> also provides a mechanism for controlling options within the scanner specification itself, rather than from the <b class="name">flex</b> command line. This is done by including &#8220;%option&#8221; directives in the first section of the scanner specification. Multiple options can be specified with a single &#8220;%option&#8221; directive, and multiple directives in the first section of the <b class="name">flex</b> input file.<div class="spacer">
</div>
Most options are given simply as names, optionally preceded by the word &#8220;no&#8221; (with no intervening whitespace) to negate their meaning. A number are equivalent to <b class="name">flex</b> flags or their negation:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
7bit            -7 option 
8bit            -8 option 
align           -Ca option 
backup          -b option 
batch           -B option 
c++             -+ option 
 
caseful or 
case-sensitive  opposite of -i (default) 
 
case-insensitive or 
caseless        -i option 
 
debug           -d option 
default         opposite of -s option 
ecs             -Ce option 
fast            -F option 
full            -f option 
interactive     -I option 
lex-compat      -l option 
meta-ecs        -Cm option 
perf-report     -p option 
read            -Cr option 
stdout          -t option 
verbose         -v option 
warn            opposite of -w option 
                (use &quot;%option nowarn&quot; for -w) 
 
array           equivalent to &quot;%array&quot; 
pointer         equivalent to &quot;%pointer&quot; (default)</pre>
<div class="spacer">
</div>
Some %option's provide features otherwise not available:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
always-interactive</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Instructs <b class="name">flex</b> to generate a scanner which always considers its input &#8220;interactive&#8221;. Normally, on each new input file the scanner calls <b class="fname">isatty</b>() in an attempt to determine whether the scanner's input source is interactive and thus should be read a character at a time. When this option is used, however, no such call is made.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
main</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Directs <b class="name">flex</b> to provide a default <b class="fname">main</b>() program for the scanner, which simply calls <b class="fname">yylex</b>(). This option implies &#8220;noyywrap&#8221; (see below).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
never-interactive</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Instructs <b class="name">flex</b> to generate a scanner which never considers its input &#8220;interactive&#8221; (again, no call made to <b class="fname">isatty</b>()). This is the opposite of &#8220;always-interactive&#8221;.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
stack</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Enables the use of start condition stacks (see <i class="link-sec"><a class="link-sec" href="#x535441525420434f4e444954494f4e53">START CONDITIONS</a></i> above).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
stdinit</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
If set (i.e., &#8220;%option stdinit&#8221;), initializes <i class="farg">yyin</i> and <i class="farg">yyout</i> to stdin and stdout, instead of the default of &#8220;nil&#8221;. Some existing <b class="name">lex</b> programs depend on this behavior, even though it is not compliant with ANSI C, which does not require stdin and stdout to be compile-time constant.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
yylineno</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Directs <b class="name">flex</b> to generate a scanner that maintains the number of the current line read from its input in the global variable <i class="farg">yylineno</i>. This option is implied by &#8220;%option lex-compat&#8221;.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
yywrap</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
If unset (i.e., &#8220;%option noyywrap&#8221;), makes the scanner not call <b class="fname">yywrap</b>() upon an end-of-file, but simply assume that there are no more files to scan (until the user points <i class="farg">yyin</i> at a new file and calls <b class="fname">yylex</b>() again).</dd>
</dl>
<div class="spacer">
</div>
<b class="name">flex</b> scans rule actions to determine whether the <span class="emph">REJECT</span> or <b class="fname">yymore</b>() features are being used. The &#8220;reject&#8221; and &#8220;yymore&#8221; options are available to override its decision as to whether to use the options, either by setting them (e.g., &#8220;%option reject&#8221;) to indicate the feature is indeed used, or unsetting them to indicate it actually is not used (e.g., &#8220;%option noyymore&#8221;).<div class="spacer">
</div>
Three options take string-delimited values, offset with &#8216;=&#8217;:<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
%option outfile=&quot;ABC&quot;</div>
</blockquote>
<div class="spacer">
</div>
is equivalent to <b class="flag">-o</b><i class="arg">ABC</i>, and<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
%option prefix=&quot;XYZ&quot;</div>
</blockquote>
<div class="spacer">
</div>
is equivalent to <b class="flag">-P</b><i class="arg">XYZ</i>. Finally,<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
%option yyclass=&quot;foo&quot;</div>
</blockquote>
<div class="spacer">
</div>
only applies when generating a C++ scanner (<b class="flag">-+</b> option). It informs <b class="name">flex</b> that &#8220;foo&#8221; has been derived as a subclass of yyFlexLexer, so <b class="name">flex</b> will place actions in the member function &#8220;foo::yylex()&#8221; instead of &#8220;yyFlexLexer::yylex()&#8221;. It also generates a &#8220;yyFlexLexer::yylex()&#8221; member function that emits a run-time error (by invoking &#8220;yyFlexLexer::LexerError()&#8221;) if called. See <i class="link-sec"><a class="link-sec" href="#x47454e45524154494e4720432b2b205343414e4e455253">GENERATING C++ SCANNERS</a></i>, below, for additional information.<div class="spacer">
</div>
A number of options are available for lint purists who want to suppress the appearance of unneeded routines in the generated scanner. Each of the following, if unset (e.g., &#8220;%option nounput&#8221;), results in the corresponding routine not appearing in the generated scanner:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
input, unput 
yy_push_state, yy_pop_state, yy_top_state 
yy_scan_buffer, yy_scan_bytes, yy_scan_string</pre>
<div class="spacer">
</div>
(though <b class="fname">yy_push_state</b>() and friends won't appear anyway unless &#8220;%option stack&#8221; is being used).</div>
<div class="section">
<h1 id="x504552464f524d414e434520434f4e53494445524154494f4e53">PERFORMANCE CONSIDERATIONS</h1> The main design goal of <b class="name">flex</b> is that it generate high-performance scanners. It has been optimized for dealing well with large sets of rules. Aside from the effects on scanner speed of the table compression <b class="flag">-C</b> options outlined above, there are a number of options/actions which degrade performance. These are, from most expensive to least:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
REJECT 
%option yylineno 
arbitrary trailing context 
 
pattern sets that require backing up 
%array 
%option interactive 
%option always-interactive 
 
'^' beginning-of-line operator 
yymore()</pre>
<div class="spacer">
</div>
with the first three all being quite expensive and the last two being quite cheap. Note also that <b class="fname">unput</b>() is implemented as a routine call that potentially does quite a bit of work, while <b class="fname">yyless</b>() is a quite-cheap macro; so if just putting back some excess text, use <b class="fname">yyless</b>().<div class="spacer">
</div>
<span class="emph">REJECT</span> should be avoided at all costs when performance is important. It is a particularly expensive option.<div class="spacer">
</div>
Getting rid of backing up is messy and often may be an enormous amount of work for a complicated scanner. In principal, one begins by using the <b class="flag">-b</b> flag to generate a <i class="file">lex.backup</i> file. For example, on the input<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
%% 
foo        return TOK_KEYWORD; 
foobar     return TOK_KEYWORD;</pre>
<div class="spacer">
</div>
the file looks like:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
State #6 is non-accepting - 
 associated rule line numbers: 
       2       3 
 out-transitions: [ o ] 
 jam-transitions: EOF [ \001-n  p-\177 ] 
 
State #8 is non-accepting - 
 associated rule line numbers: 
       3 
 out-transitions: [ a ] 
 jam-transitions: EOF [ \001-`  b-\177 ] 
 
State #9 is non-accepting - 
 associated rule line numbers: 
       3 
 out-transitions: [ r ] 
 jam-transitions: EOF [ \001-q  s-\177 ] 
 
Compressed tables always back up.</pre>
<div class="spacer">
</div>
The first few lines tell us that there's a scanner state in which it can make a transition on an &#8216;o&#8217; but not on any other character, and that in that state the currently scanned text does not match any rule. The state occurs when trying to match the rules found at lines 2 and 3 in the input file. If the scanner is in that state and then reads something other than an &#8216;o&#8217;, it will have to back up to find a rule which is matched. With a bit of headscratching one can see that this must be the state it's in when it has seen &#8216;fo&#8217;. When this has happened, if anything other than another &#8216;o&#8217; is seen, the scanner will have to back up to simply match the &#8216;f&#8217; (by the default rule).<div class="spacer">
</div>
The comment regarding State #8 indicates there's a problem when &#8220;foob&#8221; has been scanned. Indeed, on any character other than an &#8216;a&#8217;, the scanner will have to back up to accept &#8220;foo&#8221;. Similarly, the comment for State #9 concerns when &#8220;fooba&#8221; has been scanned and an &#8216;r&#8217; does not follow.<div class="spacer">
</div>
The final comment reminds us that there's no point going to all the trouble of removing backing up from the rules unless we're using <b class="flag">-Cf</b> or <b class="flag">-CF</b>, since there's no performance gain doing so with compressed scanners.<div class="spacer">
</div>
The way to remove the backing up is to add &#8220;error&#8221; rules:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
%% 
foo    return TOK_KEYWORD; 
foobar return TOK_KEYWORD; 
 
fooba  | 
foob   | 
fo { 
        /* false alarm, not really a keyword */ 
        return TOK_ID; 
}</pre>
<div class="spacer">
</div>
Eliminating backing up among a list of keywords can also be done using a &#8220;catch-all&#8221; rule:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
%% 
foo    return TOK_KEYWORD; 
foobar return TOK_KEYWORD; 
 
[a-z]+ return TOK_ID;</pre>
<div class="spacer">
</div>
This is usually the best solution when appropriate.<div class="spacer">
</div>
Backing up messages tend to cascade. With a complicated set of rules it's not uncommon to get hundreds of messages. If one can decipher them, though, it often only takes a dozen or so rules to eliminate the backing up (though it's easy to make a mistake and have an error rule accidentally match a valid token; a possible future <b class="name">flex</b> feature will be to automatically add rules to eliminate backing up).<div class="spacer">
</div>
It's important to keep in mind that the benefits of eliminating backing up are gained only if <span class="emph">every</span> instance of backing up is eliminated. Leaving just one gains nothing.<div class="spacer">
</div>
<span class="emph">Variable</span> trailing context (where both the leading and trailing parts do not have a fixed length) entails almost the same performance loss as <span class="emph">REJECT</span> (i.e., substantial). So when possible a rule like:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
%% 
mouse|rat/(cat|dog)   run();</pre>
<div class="spacer">
</div>
is better written:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
%% 
mouse/cat|dog         run(); 
rat/cat|dog           run();</pre>
<div class="spacer">
</div>
or as<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
%% 
mouse|rat/cat         run(); 
mouse|rat/dog         run();</pre>
<div class="spacer">
</div>
Note that here the special &#8216;|&#8217; action does not provide any savings, and can even make things worse (see <i class="link-sec"><a class="link-sec" href="#x42554753">BUGS</a></i> below).<div class="spacer">
</div>
Another area where the user can increase a scanner's performance (and one that's easier to implement) arises from the fact that the longer the tokens matched, the faster the scanner will run. This is because with long tokens the processing of most input characters takes place in the (short) inner scanning loop, and does not often have to go through the additional work of setting up the scanning environment (e.g., <i class="farg">yytext</i>) for the action. Recall the scanner for C comments:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
%x comment 
%% 
int line_num = 1; 
 
&quot;/*&quot;                    BEGIN(comment); 
 
&lt;comment&gt;[^*\n]* 
&lt;comment&gt;&quot;*&quot;+[^*/\n]* 
&lt;comment&gt;\n             ++line_num; 
&lt;comment&gt;&quot;*&quot;+&quot;/&quot;        BEGIN(INITIAL);</pre>
<div class="spacer">
</div>
This could be sped up by writing it as:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
%x comment 
%% 
int line_num = 1; 
 
&quot;/*&quot;                    BEGIN(comment); 
 
&lt;comment&gt;[^*\n]* 
&lt;comment&gt;[^*\n]*\n      ++line_num; 
&lt;comment&gt;&quot;*&quot;+[^*/\n]* 
&lt;comment&gt;&quot;*&quot;+[^*/\n]*\n ++line_num; 
&lt;comment&gt;&quot;*&quot;+&quot;/&quot;        BEGIN(INITIAL);</pre>
<div class="spacer">
</div>
Now instead of each newline requiring the processing of another action, recognizing the newlines is &#8220;distributed&#8221; over the other rules to keep the matched text as long as possible. Note that adding rules does <span class="emph">not</span> slow down the scanner! The speed of the scanner is independent of the number of rules or (modulo the considerations given at the beginning of this section) how complicated the rules are with regard to operators such as &#8216;*&#8217; and &#8216;|&#8217;.<div class="spacer">
</div>
A final example in speeding up a scanner: scan through a file containing identifiers and keywords, one per line and with no other extraneous characters, and recognize all the keywords. A natural first approach is:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
%% 
asm      | 
auto     | 
break    | 
... etc ... 
volatile | 
while    /* it's a keyword */ 
 
.|\n     /* it's not a keyword */</pre>
<div class="spacer">
</div>
To eliminate the back-tracking, introduce a catch-all rule:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
%% 
asm      | 
auto     | 
break    | 
... etc ... 
volatile | 
while    /* it's a keyword */ 
 
[a-z]+   | 
.|\n     /* it's not a keyword */</pre>
<div class="spacer">
</div>
Now, if it's guaranteed that there's exactly one word per line, then we can reduce the total number of matches by a half by merging in the recognition of newlines with that of the other tokens:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
%% 
asm\n      | 
auto\n     | 
break\n    | 
... etc ... 
volatile\n | 
while\n    /* it's a keyword */ 
 
[a-z]+\n   | 
.|\n       /* it's not a keyword */</pre>
<div class="spacer">
</div>
One has to be careful here, as we have now reintroduced backing up into the scanner. In particular, while we know that there will never be any characters in the input stream other than letters or newlines, <b class="name">flex</b> can't figure this out, and it will plan for possibly needing to back up when it has scanned a token like &#8220;auto&#8221; and then the next character is something other than a newline or a letter. Previously it would then just match the &#8220;auto&#8221; rule and be done, but now it has no &#8220;auto&#8221; rule, only an &#8220;auto\n&#8221; rule. To eliminate the possibility of backing up, we could either duplicate all rules but without final newlines or, since we never expect to encounter such an input and therefore don't how it's classified, we can introduce one more catch-all rule, this one which doesn't include a newline:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
%% 
asm\n      | 
auto\n     | 
break\n    | 
... etc ... 
volatile\n | 
while\n    /* it's a keyword */ 
 
[a-z]+\n   | 
[a-z]+     | 
.|\n       /* it's not a keyword */</pre>
<div class="spacer">
</div>
Compiled with <b class="flag">-Cf</b>, this is about as fast as one can get a <b class="name">flex</b> scanner to go for this particular problem.<div class="spacer">
</div>
A final note: <b class="name">flex</b> is slow when matching NUL's, particularly when a token contains multiple NUL's. It's best to write rules which match short amounts of text if it's anticipated that the text will often include NUL's.<div class="spacer">
</div>
Another final note regarding performance: as mentioned above in the section <i class="link-sec"><a class="link-sec" href="#x484f572054484520494e505554204953204d415443484544">HOW THE INPUT IS MATCHED</a></i>, dynamically resizing <i class="farg">yytext</i> to accommodate huge tokens is a slow process because it presently requires that the (huge) token be rescanned from the beginning. Thus if performance is vital, it is better to attempt to match &#8220;large&#8221; quantities of text but not &#8220;huge&#8221; quantities, where the cutoff between the two is at about 8K characters/token.</div>
<div class="section">
<h1 id="x47454e45524154494e4720432b2b205343414e4e455253">GENERATING C++ SCANNERS</h1> <b class="name">flex</b> provides two different ways to generate scanners for use with C++. The first way is to simply compile a scanner generated by <b class="name">flex</b> using a C++ compiler instead of a C compiler. This should not generate any compilation errors (please report any found to the email address given in the <i class="link-sec"><a class="link-sec" href="#x415554484f5253">AUTHORS</a></i> section below). C++ code can then be used in rule actions instead of C code. Note that the default input source for scanners remains <i class="farg">yyin</i>, and default echoing is still done to <i class="farg">yyout</i>. Both of these remain <i class="farg">FILE *</i> variables and not C++ streams.<div class="spacer">
</div>
<b class="name">flex</b> can also be used to generate a C++ scanner class, using the <b class="flag">-+</b> option (or, equivalently, &#8220;%option c++&#8221;), which is automatically specified if the name of the flex executable ends in a &#8216;+&#8217;, such as <b class="name">flex++</b>. When using this option, <b class="name">flex</b> defaults to generating the scanner to the file <i class="file">lex.yy.cc</i> instead of <i class="file">lex.yy.c</i>. The generated scanner includes the header file <b class="includes">&lt;<a class="link-includes">g++/FlexLexer.h</a>&gt;</b>, which defines the interface to two C++ classes.<div class="spacer">
</div>
The first class, <span class="emph">FlexLexer</span>, provides an abstract base class defining the general scanner class interface. It provides the following member functions:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
const char* YYText()</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Returns the text of the most recently matched token, the equivalent of <i class="farg">yytext</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
int YYLeng()</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Returns the length of the most recently matched token, the equivalent of <i class="farg">yyleng</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
int lineno() const</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Returns the current input line number (see &#8220;%option yylineno&#8221;), or 1 if &#8220;%option yylineno&#8221; was not used.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
void set_debug(int flag)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Sets the debugging flag for the scanner, equivalent to assigning to <i class="farg">yy_flex_debug</i> (see the <i class="link-sec"><a class="link-sec" href="#x4f5054494f4e53">OPTIONS</a></i> section above). Note that the scanner must be built using &#8220;%option debug&#8221; to include debugging information in it.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
int debug() const</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Returns the current setting of the debugging flag.</dd>
</dl>
<div class="spacer">
</div>
Also provided are member functions equivalent to <b class="fname">yy_switch_to_buffer</b>(), <b class="fname">yy_create_buffer</b>() (though the first argument is an <i class="farg">std::istream*</i> object pointer and not a <i class="farg">FILE*</i>), <b class="fname">yy_flush_buffer</b>(), <b class="fname">yy_delete_buffer</b>(), and <b class="fname">yyrestart</b>() (again, the first argument is an <i class="farg">std::istream*</i> object pointer).<div class="spacer">
</div>
The second class defined in <b class="includes">&lt;<a class="link-includes">g++/FlexLexer.h</a>&gt;</b> is <i class="farg">yyFlexLexer</i>, which is derived from <i class="farg">FlexLexer</i>. It defines the following additional member functions:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
yyFlexLexer(std::istream* arg_yyin = 0, std::ostream* arg_yyout = 0)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Constructs a <i class="farg">yyFlexLexer</i> object using the given streams for input and output. If not specified, the streams default to <i class="farg">cin</i> and <i class="farg">cout</i>, respectively.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
virtual int yylex()</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Performs the same role as <b class="fname">yylex</b>() does for ordinary flex scanners: it scans the input stream, consuming tokens, until a rule's action returns a value. If subclass &#8216;S&#8217; is derived from <i class="farg">yyFlexLexer</i>, in order to access the member functions and variables of &#8216;S&#8217; inside <b class="fname">yylex</b>(), use &#8220;%option yyclass=&quot;S&quot;&#8221; to inform <b class="name">flex</b> that the &#8216;S&#8217; subclass will be used instead of <i class="farg">yyFlexLexer</i>. In this case, rather than generating &#8220;yyFlexLexer::yylex()&#8221;, <b class="name">flex</b> generates &#8220;S::yylex()&#8221; (and also generates a dummy &#8220;yyFlexLexer::yylex()&#8221; that calls &#8220;yyFlexLexer::LexerError()&#8221; if called).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
virtual void switch_streams(std::istream* new_in = 0, std::ostream* new_out = 0)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Reassigns <i class="farg">yyin</i> to <i class="farg">new_in</i> (if non-nil) and <i class="farg">yyout</i> to <i class="farg">new_out</i> (ditto), deleting the previous input buffer if <i class="farg">yyin</i> is reassigned.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
int yylex(std::istream* new_in, std::ostream* new_out = 0)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
First switches the input streams via &#8220;switch_streams(new_in, new_out)&#8221; and then returns the value of <b class="fname">yylex</b>().</dd>
</dl>
<div class="spacer">
</div>
In addition, <i class="farg">yyFlexLexer</i> defines the following protected virtual functions which can be redefined in derived classes to tailor the scanner:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
virtual int LexerInput(char* buf, int max_size)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Reads up to <i class="farg">max_size</i> characters into <i class="farg">buf</i> and returns the number of characters read. To indicate end-of-input, return 0 characters. Note that &#8220;interactive&#8221; scanners (see the <b class="flag">-B</b> and <b class="flag">-I</b> flags) define the macro <span class="define">YY_INTERACTIVE</span>. If <b class="fname">LexerInput</b>() has been redefined, and it's necessary to take different actions depending on whether or not the scanner might be scanning an interactive input source, it's possible to test for the presence of this name via &#8220;#ifdef&#8221;.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
virtual void LexerOutput(const char* buf, int size)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Writes out <i class="farg">size</i> characters from the buffer <i class="farg">buf</i>, which, while NUL-terminated, may also contain &#8220;internal&#8221; NUL's if the scanner's rules can match text with NUL's in them.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
virtual void LexerError(const char* msg)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Reports a fatal error message. The default version of this function writes the message to the stream <i class="farg">cerr</i> and exits.</dd>
</dl>
<div class="spacer">
</div>
Note that a <i class="farg">yyFlexLexer</i> object contains its entire scanning state. Thus such objects can be used to create reentrant scanners. Multiple instances of the same <i class="farg">yyFlexLexer</i> class can be instantiated, and multiple C++ scanner classes can be combined in the same program using the <b class="flag">-P</b> option discussed above.<div class="spacer">
</div>
Finally, note that the &#8220;%array&#8221; feature is not available to C++ scanner classes; &#8220;%pointer&#8221; must be used (the default).<div class="spacer">
</div>
Here is an example of a simple C++ scanner:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
// An example of using the flex C++ scanner class. 
 
%{ 
#include &lt;errno.h&gt; 
int mylineno = 0; 
%} 
 
string  \&quot;[^\n&quot;]+\&quot; 
 
ws      [ \t]+ 
 
alpha   [A-Za-z] 
dig     [0-9] 
name    ({alpha}|{dig}|\$)({alpha}|{dig}|[_.\-/$])* 
num1    [-+]?{dig}+\.?([eE][-+]?{dig}+)? 
num2    [-+]?{dig}*\.{dig}+([eE][-+]?{dig}+)? 
number  {num1}|{num2} 
 
%% 
 
{ws}    /* skip blanks and tabs */ 
 
&quot;/*&quot; { 
        int c; 
 
        while ((c = yyinput()) != 0) { 
                if(c == '\n') 
                    ++mylineno; 
                else if(c == '*') { 
                    if ((c = yyinput()) == '/') 
                        break; 
                    else 
                        unput(c); 
                } 
        } 
} 
 
{number}  cout &lt;&lt; &quot;number &quot; &lt;&lt; YYText() &lt;&lt; '\n'; 
 
\n        mylineno++; 
 
{name}    cout &lt;&lt; &quot;name &quot; &lt;&lt; YYText() &lt;&lt; '\n'; 
 
{string}  cout &lt;&lt; &quot;string &quot; &lt;&lt; YYText() &lt;&lt; '\n'; 
 
%% 
 
int main(int /* argc */, char** /* argv */) 
{ 
	FlexLexer* lexer = new yyFlexLexer; 
	while(lexer-&gt;yylex() != 0) 
	    ; 
	return 0; 
}</pre>
<div class="spacer">
</div>
To create multiple (different) lexer classes, use the <b class="flag">-P</b> flag (or the &#8220;prefix=&#8221; option) to rename each <i class="farg">yyFlexLexer</i> to some other <i class="farg">xxFlexLexer</i>. <b class="includes">&lt;<a class="link-includes">g++/FlexLexer.h</a>&gt;</b> can then be included in other sources once per lexer class, first renaming <i class="farg">yyFlexLexer</i> as follows:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
#undef yyFlexLexer 
#define yyFlexLexer xxFlexLexer 
#include &lt;g++/FlexLexer.h&gt; 
 
#undef yyFlexLexer 
#define yyFlexLexer zzFlexLexer 
#include &lt;g++/FlexLexer.h&gt;</pre>
<div class="spacer">
</div>
If, for example, &#8220;%option prefix=&quot;xx&quot;&#8221; is used for one scanner and &#8220;%option prefix=&quot;zz&quot;&#8221; is used for the other.<div class="spacer">
</div>
<span class="symb">IMPORTANT</span>: the present form of the scanning class is experimental and may change considerably between major releases.</div>
<div class="section">
<h1 id="x494e434f4d5041544942494c49544945532057495448204c455820414e4420504f534958">INCOMPATIBILITIES WITH LEX AND POSIX</h1> <b class="name">flex</b> is a rewrite of the AT&amp;T UNIX <b class="name">lex</b> tool (the two implementations do not share any code, though), with some extensions and incompatibilities, both of which are of concern to those who wish to write scanners acceptable to either implementation. <b class="name">flex</b> is fully compliant with the POSIX <b class="name">lex</b> specification, except that when using &#8220;%pointer&#8221; (the default), a call to <b class="fname">unput</b>() destroys the contents of <i class="farg">yytext</i>, which is counter to the POSIX specification.<div class="spacer">
</div>
In this section we discuss all of the known areas of incompatibility between <b class="name">flex</b>, AT&amp;T UNIX <b class="name">lex</b>, and the POSIX specification.<div class="spacer">
</div>
<b class="name">flex</b>'s <b class="flag">-l</b> option turns on maximum compatibility with the original AT&amp;T UNIX <b class="name">lex</b> implementation, at the cost of a major loss in the generated scanner's performance. We note below which incompatibilities can be overcome using the <b class="flag">-l</b> option.<div class="spacer">
</div>
<b class="name">flex</b> is fully compatible with <b class="name">lex</b> with the following exceptions:<ul style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-dash">
<li class="list-dash" style="margin-top: 1.00em;">
The undocumented <b class="name">lex</b> scanner internal variable <i class="farg">yylineno</i> is not supported unless <b class="flag">-l</b> or &#8220;%option yylineno&#8221; is used.<div class="spacer">
</div>
<i class="farg">yylineno</i> should be maintained on a per-buffer basis, rather than a per-scanner (single global variable) basis.<div class="spacer">
</div>
<i class="farg">yylineno</i> is not part of the POSIX specification.</li>
<li class="list-dash" style="margin-top: 1.00em;">
The <b class="fname">input</b>() routine is not redefinable, though it may be called to read characters following whatever has been matched by a rule. If <b class="fname">input</b>() encounters an end-of-file, the normal <b class="fname">yywrap</b>() processing is done. A &#8220;real&#8221; end-of-file is returned by <b class="fname">input</b>() as <span class="define">EOF</span>.<div class="spacer">
</div>
Input is instead controlled by defining the <span class="define">YY_INPUT</span> macro.<div class="spacer">
</div>
The <b class="name">flex</b> restriction that <b class="fname">input</b>() cannot be redefined is in accordance with the POSIX specification, which simply does not specify any way of controlling the scanner's input other than by making an initial assignment to <i class="farg">yyin</i>.</li>
<li class="list-dash" style="margin-top: 1.00em;">
The <b class="fname">unput</b>() routine is not redefinable. This restriction is in accordance with POSIX.</li>
<li class="list-dash" style="margin-top: 1.00em;">
<b class="name">flex</b> scanners are not as reentrant as <b class="name">lex</b> scanners. In particular, if a scanner is interactive and an interrupt handler long-jumps out of the scanner, and the scanner is subsequently called again, the following error message may be displayed:<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
fatal flex scanner internal error--end of buffer missed</div>
</blockquote>
<div class="spacer">
</div>
To reenter the scanner, first use<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">yyrestart(yyin);</code></div>
</blockquote>
<div class="spacer">
</div>
Note that this call will throw away any buffered input; usually this isn't a problem with an interactive scanner.<div class="spacer">
</div>
Also note that flex C++ scanner classes are reentrant, so if using C++ is an option , they should be used instead. See <i class="link-sec"><a class="link-sec" href="#x47454e45524154494e4720432b2b205343414e4e455253">GENERATING C++ SCANNERS</a></i> above for details.</li>
<li class="list-dash" style="margin-top: 1.00em;">
<b class="fname">output</b>() is not supported. Output from the <span class="emph">ECHO</span> macro is done to the file-pointer <i class="farg">yyout</i> (default stdout).<div class="spacer">
</div>
<b class="fname">output</b>() is not part of the POSIX specification.</li>
<li class="list-dash" style="margin-top: 1.00em;">
<b class="name">lex</b> does not support exclusive start conditions (%x), though they are in the POSIX specification.</li>
<li class="list-dash" style="margin-top: 1.00em;">
When definitions are expanded, <b class="name">flex</b> encloses them in parentheses. With <b class="name">lex</b>, the following:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
NAME    [A-Z][A-Z0-9]* 
%% 
foo{NAME}?      printf(&quot;Found it\n&quot;); 
%%</pre>
<div class="spacer">
</div>
will not match the string &#8220;foo&#8221; because when the macro is expanded the rule is equivalent to &#8220;foo[A-Z][A-Z0-9]*?&#8221; and the precedence is such that the &#8216;?&#8217; is associated with &#8220;[A-Z0-9]*&#8221;. With <b class="name">flex</b>, the rule will be expanded to &#8220;foo([A-Z][A-Z0-9]*)?&#8221; and so the string &#8220;foo&#8221; will match.<div class="spacer">
</div>
Note that if the definition begins with &#8216;^&#8217; or ends with &#8216;$&#8217; then it is not expanded with parentheses, to allow these operators to appear in definitions without losing their special meanings. But the &#8216;&#10216;s&#10217;&#8217;, &#8216;/&#8217;, and &#10216;&#10216;EOF&#10217;&#10217; operators cannot be used in a <b class="name">flex</b> definition.<div class="spacer">
</div>
Using <b class="flag">-l</b> results in the <b class="name">lex</b> behavior of no parentheses around the definition.<div class="spacer">
</div>
The POSIX specification is that the definition be enclosed in parentheses.</li>
<li class="list-dash" style="margin-top: 1.00em;">
Some implementations of <b class="name">lex</b> allow a rule's action to begin on a separate line, if the rule's pattern has trailing whitespace:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
%% 
foo|bar&lt;space here&gt; 
  { foobar_action(); }</pre>
<div class="spacer">
</div>
<b class="name">flex</b> does not support this feature.</li>
<li class="list-dash" style="margin-top: 1.00em;">
The <b class="name">lex</b> &#8216;%r&#8217; (generate a Ratfor scanner) option is not supported. It is not part of the POSIX specification.</li>
<li class="list-dash" style="margin-top: 1.00em;">
After a call to <b class="fname">unput</b>(), <i class="farg">yytext</i> is undefined until the next token is matched, unless the scanner was built using &#8220;%array&#8221;. This is not the case with <b class="name">lex</b> or the POSIX specification. The <b class="flag">-l</b> option does away with this incompatibility.</li>
<li class="list-dash" style="margin-top: 1.00em;">
The precedence of the &#8216;{}&#8217; (numeric range) operator is different. <b class="name">lex</b> interprets &#8220;abc{1,3}&#8221; as match one, two, or three occurrences of &#8216;abc&#8217;, whereas <b class="name">flex</b> interprets it as match &#8216;ab&#8217; followed by one, two, or three occurrences of &#8216;c&#8217;. The latter is in agreement with the POSIX specification.</li>
<li class="list-dash" style="margin-top: 1.00em;">
The precedence of the &#8216;^&#8217; operator is different. <b class="name">lex</b> interprets &#8220;^foo|bar&#8221; as match either &#8216;foo&#8217; at the beginning of a line, or &#8216;bar&#8217; anywhere, whereas <b class="name">flex</b> interprets it as match either &#8216;foo&#8217; or &#8216;bar&#8217; if they come at the beginning of a line. The latter is in agreement with the POSIX specification.</li>
<li class="list-dash" style="margin-top: 1.00em;">
The special table-size declarations such as &#8216;%a&#8217; supported by <b class="name">lex</b> are not required by <b class="name">flex</b> scanners; <b class="name">flex</b> ignores them.</li>
<li class="list-dash" style="margin-top: 1.00em;">
The name <span class="define">FLEX_SCANNER</span> is #define'd so scanners may be written for use with either <b class="name">flex</b> or <b class="name">lex</b>. Scanners also include <span class="define">YY_FLEX_MAJOR_VERSION</span> and <span class="define">YY_FLEX_MINOR_VERSION</span> indicating which version of <b class="name">flex</b> generated the scanner (for example, for the 2.5 release, these defines would be 2 and 5, respectively).</li>
</ul>
<div class="spacer">
</div>
The following <b class="name">flex</b> features are not included in <b class="name">lex</b> or the POSIX specification:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
C++ scanners 
%option 
start condition scopes 
start condition stacks 
interactive/non-interactive scanners 
yy_scan_string() and friends 
yyterminate() 
yy_set_interactive() 
yy_set_bol() 
YY_AT_BOL() 
&lt;&lt;EOF&gt;&gt; 
&lt;*&gt; 
YY_DECL 
YY_START 
YY_USER_ACTION 
YY_USER_INIT 
#line directives 
%{}'s around actions 
multiple actions on a line</pre>
<div class="spacer">
</div>
plus almost all of the <b class="name">flex</b> flags. The last feature in the list refers to the fact that with <b class="name">flex</b> multiple actions can be placed on the same line, separated with semi-colons, while with <b class="name">lex</b>, the following<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">foo handle_foo(); ++num_foos_seen;</code></div>
</blockquote>
<div class="spacer">
</div>
is (rather surprisingly) truncated to<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">foo handle_foo();</code></div>
</blockquote>
<div class="spacer">
</div>
<b class="name">flex</b> does not truncate the action. Actions that are not enclosed in braces are simply terminated at the end of the line.</div>
<div class="section">
<h1 id="x46494c4553">FILES</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="file">flex.skl</i></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
Skeleton scanner. This file is only used when building flex, not when <b class="name">flex</b> executes.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="file">lex.backup</i></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
Backing-up information for the <b class="flag">-b</b> flag (called <i class="file">lex.bck</i> on some systems).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="file">lex.yy.c</i></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
Generated scanner (called <i class="file">lexyy.c</i> on some systems).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="file">lex.yy.cc</i></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
Generated C++ scanner class, when using <b class="flag">-+</b>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="includes">&lt;<a class="link-includes">g++/FlexLexer.h</a>&gt;</b></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
Header file defining the C++ scanner base class, <i class="farg">FlexLexer</i>, and its derived class, <i class="farg">yyFlexLexer</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="file">/usr/lib/libl.*</i></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
<b class="name">flex</b> libraries. The <i class="file">/usr/lib/libfl.*</i> libraries are links to these. Scanners must be linked using either <b class="flag">-ll</b> or <b class="flag">-lfl</b>.</dd>
</dl>
</div>
<div class="section">
<h1 id="x4558495420535441545553">EXIT STATUS</h1> The <b class="utility">flex</b> utility exits&#160;0 on success, and&#160;&gt;0 if an error occurs.</div>
<div class="section">
<h1 id="x444941474e4f5354494353">DIAGNOSTICS</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-diag">
<dt class="list-diag" style="margin-top: 1.00em;">
<b class="diag">warning, rule cannot be matched</b></dt>
<dd class="list-diag">
Indicates that the given rule cannot be matched because it follows other rules that will always match the same text as it. For example, in the following &#8220;foo&#8221; cannot be matched because it comes after an identifier &#8220;catch-all&#8221; rule:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
[a-z]+    got_identifier(); 
foo       got_foo();</pre>
<div class="spacer">
</div>
Using <span class="emph">REJECT</span> in a scanner suppresses this warning.</dd>
<dt class="list-diag" style="margin-top: 1.00em;">
<b class="diag">warning, -s option given but default rule can be matched</b></dt>
<dd class="list-diag">
Means that it is possible (perhaps only in a particular start condition) that the default rule (match any single character) is the only one that will match a particular input. Since <b class="flag">-s</b> was given, presumably this is not intended.</dd>
<dt class="list-diag" style="margin-top: 1.00em;">
<b class="diag">reject_used_but_not_detected undefined</b></dt>
<dd class="list-diag">
</dd>
<dt class="list-diag" style="margin-top: 1.00em;">
<b class="diag">yymore_used_but_not_detected undefined</b></dt>
<dd class="list-diag">
These errors can occur at compile time. They indicate that the scanner uses <span class="emph">REJECT</span> or <b class="fname">yymore</b>() but that <b class="name">flex</b> failed to notice the fact, meaning that <b class="name">flex</b> scanned the first two sections looking for occurrences of these actions and failed to find any, but somehow they snuck in (via an #include file, for example). Use &#8220;%option reject&#8221; or &#8220;%option yymore&#8221; to indicate to <b class="name">flex</b> that these features are really needed.</dd>
<dt class="list-diag" style="margin-top: 1.00em;">
<b class="diag">flex scanner jammed</b></dt>
<dd class="list-diag">
A scanner compiled with <b class="flag">-s</b> has encountered an input string which wasn't matched by any of its rules. This error can also occur due to internal problems.</dd>
<dt class="list-diag" style="margin-top: 1.00em;">
<b class="diag">token too large, exceeds YYLMAX</b></dt>
<dd class="list-diag">
The scanner uses &#8220;%array&#8221; and one of its rules matched a string longer than the <span class="define">YYLMAX</span> constant (8K bytes by default). The value can be increased by #define'ing <span class="define">YYLMAX</span> in the definitions section of <b class="name">flex</b> input.</dd>
<dt class="list-diag" style="margin-top: 1.00em;">
<b class="diag">scanner requires -8 flag to use the character 'x'</b></dt>
<dd class="list-diag">
The scanner specification includes recognizing the 8-bit character &#8216;x&#8217; and the <b class="flag">-8</b> flag was not specified, and defaulted to 7-bit because the <b class="flag">-Cf</b> or <b class="flag">-CF</b> table compression options were used. See the discussion of the <b class="flag">-7</b> flag for details.</dd>
<dt class="list-diag" style="margin-top: 1.00em;">
<b class="diag">flex scanner push-back overflow</b></dt>
<dd class="list-diag">
unput() was used to push back so much text that the scanner's buffer could not hold both the pushed-back text and the current token in <i class="farg">yytext</i>. Ideally the scanner should dynamically resize the buffer in this case, but at present it does not.</dd>
<dt class="list-diag" style="margin-top: 1.00em;">
<b class="diag">input buffer overflow, can't enlarge buffer because scanner uses REJECT</b></dt>
<dd class="list-diag">
The scanner was working on matching an extremely large token and needed to expand the input buffer. This doesn't work with scanners that use <span class="emph">REJECT</span>.</dd>
<dt class="list-diag" style="margin-top: 1.00em;">
<b class="diag">fatal flex scanner internal error--end of buffer missed</b></dt>
<dd class="list-diag">
This can occur in an scanner which is reentered after a long-jump has jumped out (or over) the scanner's activation frame. Before reentering the scanner, use:<div class="spacer">
</div>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">yyrestart(yyin);</code></div>
</blockquote>
<div class="spacer">
</div>
or, as noted above, switch to using the C++ scanner class.</dd>
<dt class="list-diag" style="margin-top: 1.00em;">
<b class="diag">too many start conditions in &lt;&gt; construct!</b></dt>
<dd class="list-diag">
More start conditions than exist were listed in a &lt;&gt; construct (so at least one of them must have been listed twice).</dd>
</dl>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html1/awk.html">awk(1)</a>, <a class="link-man" href="../html1/sed.html">sed(1)</a>, <a class="link-man" href="../html1/yacc.html">yacc(1)</a><div class="spacer">
</div>
<span class="ref"><span class="ref-auth">John Levine</span>, <span class="ref-auth">Tony Mason</span>, and <span class="ref-auth">Doug Brown</span>, <i class="ref-book">Lex &amp; Yacc</i>, <i class="ref-issue">O'Reilly and Associates</i>, <span class="ref-num">2nd edition</span>.</span><div class="spacer">
</div>
<span class="ref"><span class="ref-auth">Alfred Aho</span>, <span class="ref-auth">Ravi Sethi</span>, and <span class="ref-auth">Jeffrey Ullman</span>, <i class="ref-book">Compilers: Principles, Techniques and Tools</i>, <i class="ref-issue">Addison-Wesley</i>, <span class="ref-date">1986</span>, <span class="ref-opt">Describes the pattern-matching techniques used by flex (deterministic finite automata)</span>.</span></div>
<div class="section">
<h1 id="x5354414e4441524453">STANDARDS</h1> The <b class="name">lex</b> utility is compliant with the IEEE Std 1003.1-2008 (&#8220;POSIX.1&#8221;) specification, though its presence is optional.<div class="spacer">
</div>
The flags [<span class="opt"><b class="flag">-78BbCdFfhIiLloPpSsTVw+?</b></span>], [<span class="opt"><b class="flag">--help</b></span>], and [<span class="opt"><b class="flag">--version</b></span>] are extensions to that specification.<div class="spacer">
</div>
See also the <i class="link-sec"><a class="link-sec" href="#x494e434f4d5041544942494c49544945532057495448204c455820414e4420504f534958">INCOMPATIBILITIES WITH LEX AND POSIX</a></i> section, above.</div>
<div class="section">
<h1 id="x415554484f5253">AUTHORS</h1> Vern Paxson, with the help of many ideas and much inspiration from Van Jacobson. Original version by Jef Poskanzer. The fast table representation is a partial implementation of a design done by Van Jacobson. The implementation was done by Kevin Gong and Vern Paxson.<div class="spacer">
</div>
Thanks to the many <b class="name">flex</b> beta-testers, feedbackers, and contributors, especially Francois Pinard, Casey Leedom, Robert Abramovitz, Stan Adermann, Terry Allen, David Barker-Plummer, John Basrai, Neal Becker, Nelson H.F. Beebe, <a class="link-mail" href="mailto:benson@odi.com">benson@odi.com</a>, Karl Berry, Peter A. Bigot, Simon Blanchard, Keith Bostic, Frederic Brehm, Ian Brockbank, Kin Cho, Nick Christopher, Brian Clapper, J.T. Conklin, Jason Coughlin, Bill Cox, Nick Cropper, Dave Curtis, Scott David Daniels, Chris G. Demetriou, Theo de Raadt, Mike Donahue, Chuck Doucette, Tom Epperly, Leo Eskin, Chris Faylor, Chris Flatters, Jon Forrest, Jeffrey Friedl, Joe Gayda, Kaveh R. Ghazi, Wolfgang Glunz, Eric Goldman, Christopher M. Gould, Ulrich Grepel, Peer Griebel, Jan Hajic, Charles Hemphill, NORO Hideo, Jarkko Hietaniemi, Scott Hofmann, Jeff Honig, Dana Hudes, Eric Hughes, John Interrante, Ceriel Jacobs, Michal Jaegermann, Sakari Jalovaara, Jeffrey R. Jones, Henry Juengst, Klaus Kaempf, Jonathan I. Kamens, Terrence O Kane, Amir Katz, <a class="link-mail" href="mailto:ken@ken.hilco.com">ken@ken.hilco.com</a>, Kevin B. Kenny, Steve Kirsch, Winfried Koenig, Marq Kole, Ronald Lamprecht, Greg Lee, Rohan Lenard, Craig Leres, John Levine, Steve Liddle, David Loffredo, Mike Long, Mohamed el Lozy, Brian Madsen, Malte, Joe Marshall, Bengt Martensson, Chris Metcalf, Luke Mewburn, Jim Meyering, R. Alexander Milowski, Erik Naggum, G.T. Nicol, Landon Noll, James Nordby, Marc Nozell, Richard Ohnemus, Karsten Pahnke, Sven Panne, Roland Pesch, Walter Pelissero, Gaumond Pierre, Esmond Pitt, Jef Poskanzer, Joe Rahmeh, Jarmo Raiha, Frederic Raimbault, Pat Rankin, Rick Richardson, Kevin Rodgers, Kai Uwe Rommel, Jim Roskind, Alberto Santini, Andreas Scherer, Darrell Schiebel, Raf Schietekat, Doug Schmidt, Philippe Schnoebelen, Andreas Schwab, Larry Schwimmer, Alex Siegel, Eckehard Stolz, Jan-Erik Strvmquist, Mike Stump, Paul Stuart, Dave Tallman, Ian Lance Taylor, Chris Thewalt, Richard M. Timoney, Jodi Tsai, Paul Tuinenga, Gary Weik, Frank Whaley, Gerhard Wilhelms, Kent Williams, Ken Yap, Ron Zellar, Nathan Zelle, David Zuhn, and those whose names have slipped my marginal mail-archiving skills but whose contributions are appreciated all the same.<div class="spacer">
</div>
Thanks to Keith Bostic, Jon Forrest, Noah Friedman, John Gilmore, Craig Leres, John Levine, Bob Mulcahy, G.T. Nicol, Francois Pinard, Rich Salz, and Richard Stallman for help with various distribution headaches.<div class="spacer">
</div>
Thanks to Esmond Pitt and Earle Horton for 8-bit character support; to Benson Margulies and Fred Burke for C++ support; to Kent Williams and Tom Epperly for C++ class support; to Ove Ewerlid for support of NUL's; and to Eric Hughes for support of multiple buffers.<div class="spacer">
</div>
This work was primarily done when I was with the Real Time Systems Group at the Lawrence Berkeley Laboratory in Berkeley, CA. Many thanks to all there for the support I received.<div class="spacer">
</div>
Send comments to &lt;<a class="link-mail" href="mailto:vern@ee.lbl.gov">vern@ee.lbl.gov</a>&gt;.</div>
<div class="section">
<h1 id="x42554753">BUGS</h1> Some trailing context patterns cannot be properly matched and generate warning messages (dangerous trailing context). These are patterns where the ending of the first part of the rule matches the beginning of the second part, such as &#8220;zx*/xy*&#8221;, where the &#8216;x*&#8217; matches the &#8216;x&#8217; at the beginning of the trailing context. (Note that the POSIX draft states that the text matched by such patterns is undefined.)<div class="spacer">
</div>
For some trailing context rules, parts which are actually fixed-length are not recognized as such, leading to the above mentioned performance loss. In particular, parts using &#8216;|&#8217; or &#8216;{n}&#8217; (such as &#8220;foo{3}&#8221;) are always considered variable-length.<div class="spacer">
</div>
Combining trailing context with the special &#8216;|&#8217; action can result in fixed trailing context being turned into the more expensive variable trailing context. For example, in the following:<div class="spacer">
</div>
<pre style="margin-left: 5.00ex;" class="lit display">
%% 
abc      | 
xyz/def</pre>
<div class="spacer">
</div>
Use of <b class="fname">unput</b>() invalidates yytext and yyleng, unless the &#8220;%array&#8221; directive or the <b class="flag">-l</b> option has been used.<div class="spacer">
</div>
Pattern-matching of NUL's is substantially slower than matching other characters.<div class="spacer">
</div>
Dynamic resizing of the input buffer is slow, as it entails rescanning all the text matched so far by the current (generally huge) token.<div class="spacer">
</div>
Due to both buffering of input and read-ahead, it is not possible to intermix calls to <b class="includes">&lt;<a class="link-includes">stdio.h</a>&gt;</b> routines, such as, for example, <b class="fname">getchar</b>(), with <b class="name">flex</b> rules and expect it to work. Call <b class="fname">input</b>() instead.<div class="spacer">
</div>
The total table entries listed by the <b class="flag">-v</b> flag excludes the number of table entries needed to determine what rule has been matched. The number of entries is equal to the number of DFA states if the scanner does not use <span class="emph">REJECT</span>, and somewhat greater than the number of states if it does.<div class="spacer">
</div>
<span class="emph">REJECT</span> cannot be used with the <b class="flag">-f</b> or <b class="flag">-F</b> options.<div class="spacer">
</div>
The <b class="name">flex</b> internal algorithms need documentation.</div>
</div>
</body>
</html>

