<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
PERL5DB(1)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
PERL5DB(1)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
PERL5DB(1)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> perl5db.pl - the perl debugger</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
    perl -d  your_Perl_script<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> &quot;perl5db.pl&quot; is the perl debugger. It is loaded automatically by Perl when you invoke a script with &quot;perl -d&quot;. This documentation tries to outline the structure and services provided by &quot;perl5db.pl&quot;, and to describe how you can use them.</div>
<div class="section">
<h1>GENERAL NOTES</h1> The debugger can look pretty forbidding to many Perl programmers. There are a number of reasons for this, many stemming out of the debugger's history.<div class="spacer">
</div>
When the debugger was first written, Perl didn't have a lot of its nicer features - no references, no lexical variables, no closures, no object-oriented programming. So a lot of the things one would normally have done using such features was done using global variables, globs and the &quot;local()&quot; operator in creative ways.<div class="spacer">
</div>
Some of these have survived into the current debugger; a few of the more interesting and still-useful idioms are noted in this section, along with notes on the comments themselves.<div class="subsection">
<h2>Why not use more lexicals?</h2> Experienced Perl programmers will note that the debugger code tends to use mostly package globals rather than lexically-scoped variables. This is done to allow a significant amount of control of the debugger from outside the debugger itself.<div class="spacer">
</div>
Unfortunately, though the variables are accessible, they're not well documented, so it's generally been a decision that hasn't made a lot of difference to most users. Where appropriate, comments have been added to make variables more accessible and usable, with the understanding that these  <i>are</i> debugger internals, and are therefore subject to change. Future development should probably attempt to replace the globals with a well-defined API, but for now, the variables are what we've got.</div>
<div class="subsection">
<h2>Automated variable stacking via &quot;local()&quot;</h2> As you may recall from reading &quot;perlfunc&quot;, the &quot;local()&quot; operator makes a temporary copy of a variable in the current scope. When the scope ends, the old copy is restored. This is often used in the debugger to handle the automatic stacking of variables during recursive calls:<div class="spacer">
</div>
<br/>
     sub foo {<br/>
        local $some_global++;<br/>
<br/>
        # Do some stuff, then ...<br/>
        return;<br/>
     }<br/>
<div class="spacer">
</div>
What happens is that on entry to the subroutine, $some_global is localized, then altered. When the subroutine returns, Perl automatically undoes the localization, restoring the previous value. Voila, automatic stack management.<div class="spacer">
</div>
The debugger uses this trick a <i>lot</i>. Of particular note is &quot;DB::eval&quot;, which lets the debugger get control inside of &quot;eval&quot;'ed code. The debugger localizes a saved copy of $@ inside the subroutine, which allows it to keep $@ safe until it &quot;DB::eval&quot; returns, at which point the previous value of $@ is restored. This makes it simple (well,  <i>simpler</i>) to keep track of $@ inside &quot;eval&quot;s which &quot;eval&quot; other &quot;eval's&quot;.<div class="spacer">
</div>
In any case, watch for this pattern. It occurs fairly often.</div>
<div class="subsection">
<h2>The &quot;^&quot; trick</h2> This is used to cleverly reverse the sense of a logical test depending on the value of an auxiliary variable. For instance, the debugger's &quot;S&quot; (search for subroutines by pattern) allows you to negate the pattern like this:<div class="spacer">
</div>
<br/>
   # Find all non-'foo' subs:<br/>
   S !/foo/<br/>
<div class="spacer">
</div>
Boolean algebra states that the truth table for XOR looks like this:<dl>
<dt>
&#8226;</dt>
<dd>
0 ^ 0 = 0<div style="height: 1.00em;">
&#160;</div>
(! not present and no match) --&gt; false, don't print</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
0 ^ 1 = 1<div style="height: 1.00em;">
&#160;</div>
(! not present and matches) --&gt; true, print</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
1 ^ 0 = 1<div style="height: 1.00em;">
&#160;</div>
(! present and no match) --&gt; true, print</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
1 ^ 1 = 0<div style="height: 1.00em;">
&#160;</div>
(! present and matches) --&gt; false, don't print</dd>
</dl>
<div class="spacer">
</div>
As you can see, the first pair applies when &quot;!&quot; isn't supplied, and the second pair applies when it is. The XOR simply allows us to compact a more complicated if-then-elseif-else into a more elegant (but perhaps overly clever) single test. After all, it needed this explanation...</div>
<div class="subsection">
<h2>FLAGS, FLAGS, FLAGS</h2> There is a certain C programming legacy in the debugger. Some variables, such as $single, $trace, and $frame, have  <i>magical</i> values composed of 1, 2, 4, etc. (powers of 2) OR'ed together. This allows several pieces of state to be stored independently in a single scalar.<div class="spacer">
</div>
A test like<div class="spacer">
</div>
<br/>
    if ($scalar &amp; 4) ...<br/>
<div class="spacer">
</div>
is checking to see if the appropriate bit is on. Since each bit can be &quot;addressed&quot; independently in this way, $scalar is acting sort of like an array of bits. Obviously, since the contents of $scalar are just a bit-pattern, we can save and restore it easily (it will just look like a number).<div class="spacer">
</div>
The problem, is of course, that this tends to leave magic numbers scattered all over your program whenever a bit is set, cleared, or checked. So why do it?<dl>
<dt>
&#8226;</dt>
<dd>
First, doing an arithmetical or bitwise operation on a scalar is just about the fastest thing you can do in Perl: &quot;use constant&quot; actually creates a subroutine call, and array and hash lookups are much slower. Is this over-optimization at the expense of readability? Possibly, but the debugger accesses these  variables a  <i>lot</i>. Any rewrite of the code will probably have to benchmark alternate implementations and see which is the best balance of readability and speed, and then document how it actually works.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Second, it's very easy to serialize a scalar number. This is done in the restart code; the debugger state variables are saved in %ENV and then restored when the debugger is restarted. Having them be just numbers makes this trivial.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Third, some of these variables are being shared with the Perl core smack in the middle of the interpreter's execution loop. It's much faster for a C program (like the interpreter) to check a bit in a scalar than to access several different variables (or a Perl array).</dd>
</dl>
</div>
<div class="subsection">
<h2>What are those &quot;XXX&quot; comments for?</h2> Any comment containing &quot;XXX&quot; means that the comment is either somewhat speculative - it's not exactly clear what a given variable or chunk of code is doing, or that it is incomplete - the basics may be clear, but the subtleties are not completely documented.<div class="spacer">
</div>
Send in a patch if you can clear up, fill out, or clarify an &quot;XXX&quot;.</div>
</div>
<div class="section">
<h1>DATA STRUCTURES MAINTAINED BY CORE</h1> There are a number of special data structures provided to the debugger by the Perl interpreter.<div class="spacer">
</div>
The array &quot;@{$main::{'_&lt;'.$filename}}&quot; (aliased locally to @dbline via glob assignment) contains the text from $filename, with each element corresponding to a single line of $filename. Additionally, breakable lines will be dualvars with the numeric component being the memory address of a COP node. Non-breakable lines are dualvar to 0.<div class="spacer">
</div>
The hash &quot;%{'_&lt;'.$filename}&quot; (aliased locally to %dbline via glob assignment) contains breakpoints and actions.  The keys are line numbers; you can set individual values, but not the whole hash. The Perl interpreter uses this hash to determine where breakpoints have been set. Any true value is considered to be a breakpoint; &quot;perl5db.pl&quot; uses &quot;$break_condition\0$action&quot;. Values are magical in numeric context: 1 if the line is breakable, 0 if not.<div class="spacer">
</div>
The scalar &quot;${&quot;_&lt;$filename&quot;}&quot; simply contains the string $filename. This is also the case for evaluated strings that contain subroutines, or which are currently being executed.  The $filename for &quot;eval&quot;ed strings looks like &quot;(eval 34).&quot;</div>
<div class="section">
<h1>DEBUGGER STARTUP</h1> When &quot;perl5db.pl&quot; starts, it reads an rcfile (&quot;perl5db.ini&quot; for non-interactive sessions, &quot;.perldb&quot; for interactive ones) that can set a number of options. In addition, this file may define a subroutine &amp;afterinit that will be executed (in the debugger's context) after the debugger has initialized itself.<div class="spacer">
</div>
Next, it checks the &quot;PERLDB_OPTS&quot; environment variable and treats its contents as the argument of a &quot;o&quot; command in the debugger.<div class="subsection">
<h2>STARTUP-ONLY OPTIONS</h2> The following options can only be specified at startup. To set them in your rcfile, add a call to &quot;&amp;parse_options(&quot;optionName=new_value&quot;)&quot;.<dl>
<dt>
&#8226;</dt>
<dd>
TTY<div style="height: 1.00em;">
&#160;</div>
the TTY to use for debugging i/o.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
noTTY<div style="height: 1.00em;">
&#160;</div>
if set, goes in NonStop mode.  On interrupt, if TTY is not set, uses the value of noTTY or  <i></i><i>$HOME</i><i>/.perldbtty$$</i> to find TTY using Term::Rendezvous.  Current variant is to have the name of TTY in this file.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
ReadLine<div style="height: 1.00em;">
&#160;</div>
if false, a dummy ReadLine is used, so you can debug ReadLine applications.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
NonStop<div style="height: 1.00em;">
&#160;</div>
if true, no i/o is performed until interrupt.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
LineInfo<div style="height: 1.00em;">
&#160;</div>
file or pipe to print line number info to.  If it is a pipe, a short &quot;emacs like&quot; message is used.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
RemotePort<div style="height: 1.00em;">
&#160;</div>
host:port to connect to on remote host for remote debugging.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
HistFile<div style="height: 1.00em;">
&#160;</div>
file to store session history to. There is no default and so no history file is written unless this variable is explicitly set.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
HistSize<div style="height: 1.00em;">
&#160;</div>
number of commands to store to the file specified in &quot;HistFile&quot;. Default is 100.</dd>
</dl>
<div class="spacer">
</div>
<i>SAMPLE RCFILE</i><div class="spacer">
</div>
<br/>
 &amp;parse_options(&quot;NonStop=1 LineInfo=db.out&quot;);<br/>
  sub afterinit { $trace = 1; }<br/>
<div class="spacer">
</div>
The script will run without human intervention, putting trace information into &quot;db.out&quot;.  (If you interrupt it, you had better reset &quot;LineInfo&quot; to something  <i>interactive</i>!)</div>
</div>
<div class="section">
<h1>INTERNALS DESCRIPTION</h1><div class="subsection">
<h2>DEBUGGER INTERFACE VARIABLES</h2> Perl supplies the values for %sub.  It effectively inserts a &quot;&amp;DB::DB();&quot; in front of each place that can have a breakpoint. At each subroutine call, it calls &amp;DB::sub with $DB::sub set to the called subroutine. It also inserts a &quot;BEGIN {require 'perl5db.pl'}&quot; before the first line.<div class="spacer">
</div>
After each &quot;require&quot;d file is compiled, but before it is executed, a call to &quot;&amp;DB::postponed($main::{'_&lt;'.$filename})&quot; is done. $filename is the expanded name of the &quot;require&quot;d file (as found via %INC).<div class="spacer">
</div>
<i>IMPORTANT INTERNAL VARIABLES</i><div class="spacer">
</div>
$CreateTTY<div class="spacer">
</div>
Used to control when the debugger will attempt to acquire another TTY to be used for input.<dl>
<dt>
&#8226;</dt>
<dd>
1 -  on &quot;fork()&quot;</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
2 - debugger is started inside debugger</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
4 -  on startup</dd>
</dl>
<div class="spacer">
</div>
$doret<div class="spacer">
</div>
The value -2 indicates that no return value should be printed. Any other positive value causes &quot;DB::sub&quot; to print return values.<div class="spacer">
</div>
$evalarg<div class="spacer">
</div>
The item to be eval'ed by &quot;DB::eval&quot;. Used to prevent messing with the current contents of @_ when &quot;DB::eval&quot; is called.<div class="spacer">
</div>
$frame<div class="spacer">
</div>
Determines what messages (if any) will get printed when a subroutine (or eval) is entered or exited.<dl>
<dt>
&#8226;</dt>
<dd>
0 -  No enter/exit messages</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
1 - Print <i>entering</i> messages on subroutine entry</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
2 - Adds exit messages on subroutine exit. If no other flag is on, acts like 1+2.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
4 - Extended messages: &quot;&lt;in|out&gt; <i>context</i>=<i>fully-qualified sub name</i> from <i>file</i>:<i>line</i>&quot;. If no other flag is on, acts like 1+4.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
8 - Adds parameter information to messages, and overloaded stringify and tied FETCH is enabled on the printed arguments. Ignored if 4 is not on.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
16 - Adds &quot;<i>context</i> return from <i>subname</i>: <i>value</i>&quot; messages on subroutine/eval exit. Ignored if 4 is not on.</dd>
</dl>
<div class="spacer">
</div>
To get everything, use &quot;$frame=30&quot; (or &quot;o f=30&quot; as a debugger command). The debugger internally juggles the value of $frame during execution to protect external modules that the debugger uses from getting traced.<div class="spacer">
</div>
$level<div class="spacer">
</div>
Tracks current debugger nesting level. Used to figure out how many &quot;&lt;&gt;&quot; pairs to surround the line number with when the debugger outputs a prompt. Also used to help determine if the program has finished during command parsing.<div class="spacer">
</div>
$onetimeDump<div class="spacer">
</div>
Controls what (if anything) &quot;DB::eval()&quot; will print after evaluating an expression.<dl>
<dt>
&#8226;</dt>
<dd>
&quot;undef&quot; - don't print anything</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;dump&quot; - use &quot;dumpvar.pl&quot; to display the value returned</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;methods&quot; - print the methods callable on the first item returned</dd>
</dl>
<div class="spacer">
</div>
$onetimeDumpDepth<div class="spacer">
</div>
Controls how far down &quot;dumpvar.pl&quot; will go before printing &quot;...&quot; while dumping a structure. Numeric. If &quot;undef&quot;, print all levels.<div class="spacer">
</div>
$signal<div class="spacer">
</div>
Used to track whether or not an &quot;INT&quot; signal has been detected. &quot;DB::DB()&quot;, which is called before every statement, checks this and puts the user into command mode if it finds $signal set to a true value.<div class="spacer">
</div>
$single<div class="spacer">
</div>
Controls behavior during single-stepping. Stacked in @stack on entry to each subroutine; popped again at the end of each subroutine.<dl>
<dt>
&#8226;</dt>
<dd>
0 - run continuously.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
1 - single-step, go into subs. The &quot;s&quot; command.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
2 - single-step, don't go into subs. The &quot;n&quot; command.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
4 - print current sub depth (turned on to force this when &quot;too much recursion&quot; occurs.</dd>
</dl>
<div class="spacer">
</div>
$trace<div class="spacer">
</div>
Controls the output of trace information.<dl>
<dt>
&#8226;</dt>
<dd>
1 - The &quot;t&quot; command was entered to turn on tracing (every line executed is printed)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
2 - watch expressions are active</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
4 - user defined a &quot;watchfunction()&quot; in &quot;afterinit()&quot;</dd>
</dl>
<div class="spacer">
</div>
$slave_editor<div class="spacer">
</div>
1 if &quot;LINEINFO&quot; was directed to a pipe; 0 otherwise.<div class="spacer">
</div>
@cmdfhs<div class="spacer">
</div>
Stack of filehandles that &quot;DB::readline()&quot; will read commands from. Manipulated by the debugger's &quot;source&quot; command and &quot;DB::readline()&quot; itself.<div class="spacer">
</div>
@dbline<div class="spacer">
</div>
Local alias to the magical line array, &quot;@{$main::{'_&lt;'.$filename}}&quot; , supplied by the Perl interpreter to the debugger. Contains the source.<div class="spacer">
</div>
@old_watch<div class="spacer">
</div>
Previous values of watch expressions. First set when the expression is entered; reset whenever the watch expression changes.<div class="spacer">
</div>
@saved<div class="spacer">
</div>
Saves important globals ($@, $!, $^E, $,, $/, &quot;$\&quot;, $^W) so that the debugger can substitute safe values while it's running, and restore them when it returns control.<div class="spacer">
</div>
@stack<div class="spacer">
</div>
Saves the current value of $single on entry to a subroutine. Manipulated by the &quot;c&quot; command to turn off tracing in all subs above the current one.<div class="spacer">
</div>
@to_watch<div class="spacer">
</div>
The 'watch' expressions: to be evaluated before each line is executed.<div class="spacer">
</div>
@typeahead<div class="spacer">
</div>
The typeahead buffer, used by &quot;DB::readline&quot;.<div class="spacer">
</div>
%alias<div class="spacer">
</div>
Command aliases. Stored as character strings to be substituted for a command entered.<div class="spacer">
</div>
%break_on_load<div class="spacer">
</div>
Keys are file names, values are 1 (break when this file is loaded) or undef (don't break when it is loaded).<div class="spacer">
</div>
%dbline<div class="spacer">
</div>
Keys are line numbers, values are &quot;condition\0action&quot;. If used in numeric context, values are 0 if not breakable, 1 if breakable, no matter what is in the actual hash entry.<div class="spacer">
</div>
%had_breakpoints<div class="spacer">
</div>
Keys are file names; values are bitfields:<dl>
<dt>
&#8226;</dt>
<dd>
1 - file has a breakpoint in it.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
2 - file has an action in it.</dd>
</dl>
<div class="spacer">
</div>
A zero or undefined value means this file has neither.<div class="spacer">
</div>
%option<div class="spacer">
</div>
Stores the debugger options. These are character string values.<div class="spacer">
</div>
%postponed<div class="spacer">
</div>
Saves breakpoints for code that hasn't been compiled yet. Keys are subroutine names, values are:<dl>
<dt>
&#8226;</dt>
<dd>
&quot;compile&quot; - break when this sub is compiled</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;break +0 if &lt;condition&gt;&quot; - break (conditionally) at the start of this routine. The condition will be '1' if no condition was specified.</dd>
</dl>
<div class="spacer">
</div>
%postponed_file<div class="spacer">
</div>
This hash keeps track of breakpoints that need to be set for files that have not yet been compiled. Keys are filenames; values are references to hashes. Each of these hashes is keyed by line number, and its values are breakpoint definitions (&quot;condition\0action&quot;).</div>
</div>
<div class="section">
<h1>DEBUGGER INITIALIZATION</h1> The debugger's initialization actually jumps all over the place inside this package. This is because there are several BEGIN blocks (which of course execute immediately) spread through the code. Why is that?<div class="spacer">
</div>
The debugger needs to be able to change some things and set some things up before the debugger code is compiled; most notably, the $deep variable that &quot;DB::sub&quot; uses to tell when a program has recursed deeply. In addition, the debugger has to turn off warnings while the debugger code is compiled, but then restore them to their original setting before the program being debugged begins executing.<div class="spacer">
</div>
The first &quot;BEGIN&quot; block simply turns off warnings by saving the current setting of $^W and then setting it to zero. The second one initializes the debugger variables that are needed before the debugger begins executing. The third one puts $^X back to its former value.<div class="spacer">
</div>
We'll detail the second &quot;BEGIN&quot; block later; just remember that if you need to initialize something before the debugger starts really executing, that's where it has to go.</div>
<div class="section">
<h1>DEBUGGER ROUTINES</h1><div class="subsection">
<h2>&quot;DB::eval()&quot;</h2> This function replaces straight &quot;eval()&quot; inside the debugger; it simplifies the process of evaluating code in the user's context.<div class="spacer">
</div>
The code to be evaluated is passed via the package global variable $DB::evalarg; this is done to avoid fiddling with the contents of @_.<div class="spacer">
</div>
Before we do the &quot;eval()&quot;, we preserve the current settings of $trace, $single, $^D and $usercontext.  The latter contains the preserved values of $@, $!, $^E, $,, $/, &quot;$\&quot;, $^W and the user's current package, grabbed when &quot;DB::DB&quot; got control.  This causes the proper context to be used when the eval is actually done.  Afterward, we restore $trace, $single, and $^D.<div class="spacer">
</div>
Next we need to handle $@ without getting confused. We save $@ in a local lexical, localize $saved[0] (which is where &quot;save()&quot; will put $@), and then call &quot;save()&quot; to capture $@, $!, $^E, $,, $/, &quot;$\&quot;, and $^W) and set $,, $/, &quot;$\&quot;, and $^W to values considered sane by the debugger. If there was an &quot;eval()&quot; error, we print it on the debugger's output. If $onetimedump is defined, we call &quot;dumpit&quot; if it's set to 'dump', or &quot;methods&quot; if it's set to 'methods'. Setting it to something else causes the debugger to do the eval but not print the result - handy if you want to do something else with it (the &quot;watch expressions&quot; code does this to get the value of the watch expression but not show it unless it matters).<div class="spacer">
</div>
In any case, we then return the list of output from &quot;eval&quot; to the caller, and unwinding restores the former version of $@ in @saved as well (the localization of $saved[0] goes away at the end of this scope).<div class="spacer">
</div>
<i>Parameters and variables influencing execution of </i><i>DB::eval()</i><i></i><div class="spacer">
</div>
&quot;DB::eval&quot; isn't parameterized in the standard way; this is to keep the debugger's calls to &quot;DB::eval()&quot; from mucking with @_, among other things. The variables listed below influence &quot;DB::eval()&quot;'s execution directly.<dl>
<dt>
$evalarg - the thing to actually be eval'ed</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$trace - Current state of execution tracing</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$single - Current state of single-stepping</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$onetimeDump - what is to be displayed after the evaluation</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$onetimeDumpDepth - how deep &quot;dumpit()&quot; should go when dumping results</dt>
<dd>
</dd>
</dl>
<div class="spacer">
</div>
The following variables are altered by &quot;DB::eval()&quot; during its execution. They are &quot;stacked&quot; via &quot;local()&quot;, enabling recursive calls to &quot;DB::eval()&quot;.<dl>
<dt>
@res - used to capture output from actual &quot;eval&quot;.</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$otrace - saved value of $trace.</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$osingle - saved value of $single.</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$od - saved value of $^D.</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$saved[0] - saved value of $@.</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$\ - for output of $@ if there is an evaluation error.</dt>
<dd>
</dd>
</dl>
<div class="spacer">
</div>
<i>The problem of lexicals</i><div class="spacer">
</div>
The context of &quot;DB::eval()&quot; presents us with some problems. Obviously, we want to be 'sandboxed' away from the debugger's internals when we do the eval, but we need some way to control how punctuation variables and debugger globals are used.<div class="spacer">
</div>
We can't use local, because the code inside &quot;DB::eval&quot; can see localized variables; and we can't use &quot;my&quot; either for the same reason. The code in this routine compromises and uses &quot;my&quot;.<div class="spacer">
</div>
After this routine is over, we don't have user code executing in the debugger's context, so we can use &quot;my&quot; freely.</div>
</div>
<div class="section">
<h1>DEBUGGER INITIALIZATION</h1> The debugger starts up in phases.<div class="subsection">
<h2>BASIC SETUP</h2> First, it initializes the environment it wants to run in: turning off warnings during its own compilation, defining variables which it will need to avoid warnings later, setting itself up to not exit when the program terminates, and defaulting to printing return values for the &quot;r&quot; command.</div>
<div class="subsection">
<h2>THREADS SUPPORT</h2> If we are running under a threaded Perl, we require threads and threads::shared if the environment variable &quot;PERL5DB_THREADED&quot; is set, to enable proper threaded debugger control.  &quot;-dt&quot; can also be used to set this.<div class="spacer">
</div>
Each new thread will be announced and the debugger prompt will always inform you of each new thread created.  It will also indicate the thread id in which we are currently running within the prompt like this:<div class="spacer">
</div>
<br/>
    [tid] DB&lt;$i&gt;<br/>
<div class="spacer">
</div>
Where &quot;[tid]&quot; is an integer thread id and $i is the familiar debugger command prompt.  The prompt will show: &quot;[0]&quot; when running under threads, but not actually in a thread.  &quot;[tid]&quot; is consistent with &quot;gdb&quot; usage.<div class="spacer">
</div>
While running under threads, when you set or delete a breakpoint (etc.), this will apply to all threads, not just the currently running one.  When you are in a currently executing thread, you will stay there until it completes.  With the current implementation it is not currently possible to hop from one thread to another.<div class="spacer">
</div>
The &quot;e&quot; and &quot;E&quot; commands are currently fairly minimal - see &quot;h e&quot; and &quot;h E&quot;.<div class="spacer">
</div>
Note that threading support was built into the debugger as of Perl version 5.8.6 and debugger version 1.2.8.</div>
</div>
<div class="section">
<h1>OPTION PROCESSING</h1> The debugger's options are actually spread out over the debugger itself and &quot;dumpvar.pl&quot;; some of these are variables to be set, while others are subs to be called with a value. To try to make this a little easier to manage, the debugger uses a few data structures to define what options are legal and how they are to be processed.<div class="spacer">
</div>
First, the @options array defines the <i>names</i> of all the options that are to be accepted.<div class="spacer">
</div>
Second, &quot;optionVars&quot; lists the variables that each option uses to save its state.<div class="spacer">
</div>
Third, %optionAction defines the subroutine to be called to process each option.<div class="spacer">
</div>
Last, the %optionRequire notes modules that must be &quot;require&quot;d if an option is used.<div class="spacer">
</div>
There are a number of initialization-related variables which can be set by putting code to set them in a BEGIN block in the &quot;PERL5DB&quot; environment variable. These are:<dl>
<dt>
$rl - readline control XXX needs more explanation</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$warnLevel - whether or not debugger takes over warning handling</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$dieLevel - whether or not debugger takes over die handling</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$signalLevel - whether or not debugger takes over signal handling</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$pre - preprompt actions (array reference)</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$post - postprompt actions (array reference)</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$pretype</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$CreateTTY - whether or not to create a new TTY for this debugger</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$CommandSet - which command set to use (defaults to new, documented set)</dt>
<dd>
</dd>
</dl>
<div class="spacer">
</div>
The default &quot;die&quot;, &quot;warn&quot;, and &quot;signal&quot; handlers are set up.<div class="spacer">
</div>
The pager to be used is needed next. We try to get it from the environment first.  If it's not defined there, we try to find it in the Perl &quot;Config.pm&quot;.  If it's not there, we default to &quot;more&quot;. We then call the &quot;pager()&quot; function to save the pager name.<div class="spacer">
</div>
We set up the command to be used to access the man pages, the command recall character (&quot;!&quot; unless otherwise defined) and the shell escape character (&quot;!&quot; unless otherwise defined). Yes, these do conflict, and neither works in the debugger at the moment.<div class="spacer">
</div>
We then set up the gigantic string containing the debugger help. We also set the limit on the number of arguments we'll display during a trace.<div class="subsection">
<h2>SETTING UP THE DEBUGGER GREETING</h2> The debugger  <i>greeting</i> helps to inform the user how many debuggers are running, and whether the current debugger is the primary or a child.<div class="spacer">
</div>
If we are the primary, we just hang onto our pid so we'll have it when or if we start a child debugger. If we are a child, we'll set things up so we'll have a unique greeting and so the parent will give us our own TTY later.<div class="spacer">
</div>
We save the current contents of the &quot;PERLDB_PIDS&quot; environment variable because we mess around with it. We'll also need to hang onto it because we'll need it if we restart.<div class="spacer">
</div>
Child debuggers make a label out of the current PID structure recorded in PERLDB_PIDS plus the new PID. They also mark themselves as not having a TTY yet so the parent will give them one later via &quot;resetterm()&quot;.</div>
<div class="subsection">
<h2>READING THE RC FILE</h2> The debugger will read a file of initialization options if supplied. If running interactively, this is &quot;.perldb&quot;; if not, it's &quot;perldb.ini&quot;.<div class="spacer">
</div>
The debugger does a safety test of the file to be read. It must be owned either by the current user or root, and must only be writable by the owner.<div class="spacer">
</div>
The last thing we do during initialization is determine which subroutine is to be used to obtain a new terminal when a new debugger is started. Right now, the debugger only handles TCP sockets, X11, OS/2, amd Mac OS X (darwin).</div>
<div class="subsection">
<h2>RESTART PROCESSING</h2> This section handles the restart command. When the &quot;R&quot; command is invoked, it tries to capture all of the state it can into environment variables, and then sets &quot;PERLDB_RESTART&quot;. When we start executing again, we check to see if &quot;PERLDB_RESTART&quot; is there; if so, we reload all the information that the R command stuffed into the environment variables.<div class="spacer">
</div>
<br/>
  PERLDB_RESTART   - flag only, contains no restart data itself.<br/>
  PERLDB_HIST      - command history, if it's available<br/>
  PERLDB_ON_LOAD   - breakpoints set by the rc file<br/>
  PERLDB_POSTPONE  - subs that have been loaded/not executed,<br/>
                     and have actions<br/>
  PERLDB_VISITED   - files that had breakpoints<br/>
  PERLDB_FILE_...  - breakpoints for a file<br/>
  PERLDB_OPT       - active options<br/>
  PERLDB_INC       - the original @INC<br/>
  PERLDB_PRETYPE   - preprompt debugger actions<br/>
  PERLDB_PRE       - preprompt Perl code<br/>
  PERLDB_POST      - post-prompt Perl code<br/>
  PERLDB_TYPEAHEAD - typeahead captured by readline()<br/>
<div class="spacer">
</div>
We chug through all these variables and plug the values saved in them back into the appropriate spots in the debugger.</div>
<div class="subsection">
<h2>SETTING UP THE TERMINAL</h2> Now, we'll decide how the debugger is going to interact with the user. If there's no TTY, we set the debugger to run non-stop; there's not going to be anyone there to enter commands.<div class="spacer">
</div>
If there is a TTY, we have to determine who it belongs to before we can proceed. If this is a slave editor or graphical debugger (denoted by the first command-line switch being '-emacs'), we shift this off and set $rl to 0 (XXX ostensibly to do straight reads).<div class="spacer">
</div>
We then determine what the console should be on various systems:<dl>
<dt>
&#8226;</dt>
<dd>
Cygwin - We use &quot;stdin&quot; instead of a separate device.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Unix - use <i>/dev/tty</i>.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Windows or MSDOS - use &quot;con&quot;.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
VMS - use &quot;sys$command&quot;.</dd>
</dl>
<div class="spacer">
</div>
Several other systems don't use a specific console. We &quot;undef $console&quot; for those (Windows using a slave editor/graphical debugger, NetWare, OS/2 with a slave editor).<div class="spacer">
</div>
If there is a TTY hanging around from a parent, we use that as the console.</div>
<div class="subsection">
<h2>SOCKET HANDLING</h2> The debugger is capable of opening a socket and carrying out a debugging session over the socket.<div class="spacer">
</div>
If &quot;RemotePort&quot; was defined in the options, the debugger assumes that it should try to start a debugging session on that port. It builds the socket and then tries to connect the input and output filehandles to it.<div class="spacer">
</div>
If no &quot;RemotePort&quot; was defined, and we want to create a TTY on startup, this is probably a situation where multiple debuggers are running (for example, a backticked command that starts up another debugger). We create a new IN and OUT filehandle, and do the necessary mojo to create a new TTY if we know how and if we can.<div class="spacer">
</div>
To finish initialization, we show the debugger greeting, and then call the &quot;afterinit()&quot; subroutine if there is one.</div>
</div>
<div class="section">
<h1>SUBROUTINES</h1><div class="subsection">
<h2>DB</h2> This gigantic subroutine is the heart of the debugger. Called before every statement, its job is to determine if a breakpoint has been reached, and stop if so; read commands from the user, parse them, and execute them, and then send execution off to the next statement.<div class="spacer">
</div>
Note that the order in which the commands are processed is very important; some commands earlier in the loop will actually alter the $cmd variable to create other commands to be executed later. This is all highly  <i>optimized</i> but can be confusing. Check the comments for each &quot;$cmd ... &amp;&amp; do {}&quot; to see what's happening in any given command.</div>
<div class="subsection">
<h2>&quot;watchfunction()&quot;</h2> &quot;watchfunction()&quot; is a function that can be defined by the user; it is a function which will be run on each entry to &quot;DB::DB&quot;; it gets the current package, filename, and line as its parameters.<div class="spacer">
</div>
The watchfunction can do anything it likes; it is executing in the debugger's context, so it has access to all of the debugger's internal data structures and functions.<div class="spacer">
</div>
&quot;watchfunction()&quot; can control the debugger's actions. Any of the following will cause the debugger to return control to the user's program after &quot;watchfunction()&quot; executes:<dl>
<dt>
&#8226;</dt>
<dd>
Returning a false value from the &quot;watchfunction()&quot; itself.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Altering $single to a false value.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Altering $signal to a false value.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Turning off the 4 bit in $trace (this also disables the check for &quot;watchfunction()&quot;. This can be done with<div style="height: 1.00em;">
&#160;</div>
<br/>
    $trace &amp;= ~4;<br/>
</dd>
</dl>
</div>
<div class="subsection">
<h2>GETTING READY TO EXECUTE COMMANDS</h2> The debugger decides to take control if single-step mode is on, the &quot;t&quot; command was entered, or the user generated a signal. If the program has fallen off the end, we set things up so that entering further commands won't cause trouble, and we say that the program is over.<div class="spacer">
</div>
If there's an action to be executed for the line we stopped at, execute it. If there are any preprompt actions, execute those as well.</div>
<div class="subsection">
<h2>WHERE ARE WE?</h2> XXX Relocate this section?<div class="spacer">
</div>
The debugger normally shows the line corresponding to the current line of execution. Sometimes, though, we want to see the next line, or to move elsewhere in the file. This is done via the $incr, $start, and $max variables.<div class="spacer">
</div>
$incr controls by how many lines the <i>current</i> line should move forward after a command is executed. If set to -1, this indicates that the  <i>current</i> line shouldn't change.<div class="spacer">
</div>
$start is the <i>current</i> line. It is used for things like knowing where to move forwards or backwards from when doing an &quot;L&quot; or &quot;-&quot; command.<div class="spacer">
</div>
$max tells the debugger where the last line of the current file is. It's used to terminate loops most often.</div>
<div class="subsection">
<h2>THE COMMAND LOOP</h2> Most of &quot;DB::DB&quot; is actually a command parsing and dispatch loop. It comes in two parts:<dl>
<dt>
&#8226;</dt>
<dd>
The outer part of the loop, starting at the &quot;CMD&quot; label. This loop reads a command and then executes it.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
The inner part of the loop, starting at the &quot;PIPE&quot; label. This part is wholly contained inside the &quot;CMD&quot; block and only executes a command. Used to handle commands running inside a pager.</dd>
</dl>
<div class="spacer">
</div>
So why have two labels to restart the loop? Because sometimes, it's easier to have a command  <i>generate</i> another command and then re-execute the loop to do the new command. This is faster, but perhaps a bit more convoluted.<div class="spacer">
</div>
The null command<div class="spacer">
</div>
A newline entered by itself means <i>re-execute the last command</i>. We grab the command out of $laststep (where it was recorded previously), and copy it back into $cmd to be executed below. If there wasn't any previous command, we'll do nothing below (no command will match). If there was, we also save it in the command history and fall through to allow the command parsing to pick it up.<div class="spacer">
</div>
<i>COMMAND ALIASES</i><div class="spacer">
</div>
The debugger can create aliases for commands (these are stored in the %alias hash). Before a command is executed, the command loop looks it up in the alias hash and substitutes the contents of the alias for the command, completely replacing it.<div class="spacer">
</div>
<i>MAIN-LINE COMMANDS</i><div class="spacer">
</div>
All of these commands work up to and after the program being debugged has terminated.<div class="spacer">
</div>
&quot;q&quot; - quit<div class="spacer">
</div>
Quit the debugger. This entails setting the $fall_off_end flag, so we don't try to execute further, cleaning any restart-related stuff out of the environment, and executing with the last value of $?.<div class="spacer">
</div>
&quot;t&quot; - trace [n]<div class="spacer">
</div>
Turn tracing on or off. Inverts the appropriate bit in $trace (q.v.). If level is specified, set $trace_to_depth.<div class="spacer">
</div>
&quot;S&quot; - list subroutines matching/not matching a pattern<div class="spacer">
</div>
Walks through %sub, checking to see whether or not to print the name.<div class="spacer">
</div>
&quot;X&quot; - list variables in current package<div class="spacer">
</div>
Since the &quot;V&quot; command actually processes this, just change this to the appropriate &quot;V&quot; command and fall through.<div class="spacer">
</div>
&quot;V&quot; - list variables<div class="spacer">
</div>
Uses &quot;dumpvar.pl&quot; to dump out the current values for selected variables.<div class="spacer">
</div>
&quot;x&quot; - evaluate and print an expression<div class="spacer">
</div>
Hands the expression off to &quot;DB::eval&quot;, setting it up to print the value via &quot;dumpvar.pl&quot; instead of just printing it directly.<div class="spacer">
</div>
&quot;m&quot; - print methods<div class="spacer">
</div>
Just uses &quot;DB::methods&quot; to determine what methods are available.<div class="spacer">
</div>
&quot;f&quot; - switch files<div class="spacer">
</div>
Switch to a different filename.<div class="spacer">
</div>
&quot;.&quot; - return to last-executed line.<div class="spacer">
</div>
We set $incr to -1 to indicate that the debugger shouldn't move ahead, and then we look up the line in the magical %dbline hash.<div class="spacer">
</div>
&quot;-&quot; - back one window<div class="spacer">
</div>
We change $start to be one window back; if we go back past the first line, we set it to be the first line. We ser $incr to put us back at the currently-executing line, and then put a &quot;l $start +&quot; (list one window from $start) in $cmd to be executed later.<div class="spacer">
</div>
<i>PRE-580 COMMANDS VS. NEW COMMANDS: </i><i>&quot;a, A, b, B, h, l, L, M, o, O, P, v, w, W, &lt;, &lt;&lt;, {, {{&quot;</i><i></i><div class="spacer">
</div>
In Perl 5.8.0, a realignment of the commands was done to fix up a number of problems, most notably that the default case of several commands destroying the user's work in setting watchpoints, actions, etc. We wanted, however, to retain the old commands for those who were used to using them or who preferred them. At this point, we check for the new commands and call &quot;cmd_wrapper&quot; to deal with them instead of processing them in-line.<div class="spacer">
</div>
&quot;y&quot; - List lexicals in higher scope<div class="spacer">
</div>
Uses &quot;PadWalker&quot; to find the lexicals supplied as arguments in a scope above the current one and then displays then using &quot;dumpvar.pl&quot;.<div class="spacer">
</div>
<i>COMMANDS NOT WORKING AFTER PROGRAM ENDS</i><div class="spacer">
</div>
All of the commands below this point don't work after the program being debugged has ended. All of them check to see if the program has ended; this allows the commands to be relocated without worrying about a 'line of demarcation' above which commands can be entered anytime, and below which they can't.<div class="spacer">
</div>
&quot;n&quot; - single step, but don't trace down into subs<div class="spacer">
</div>
Done by setting $single to 2, which forces subs to execute straight through when entered (see &quot;DB::sub&quot;). We also save the &quot;n&quot; command in $laststep, so a null command knows what to re-execute.<div class="spacer">
</div>
&quot;s&quot; - single-step, entering subs<div class="spacer">
</div>
Sets $single to 1, which causes &quot;DB::sub&quot; to continue tracing inside subs. Also saves &quot;s&quot; as $lastcmd.<div class="spacer">
</div>
&quot;c&quot; - run continuously, setting an optional breakpoint<div class="spacer">
</div>
Most of the code for this command is taken up with locating the optional breakpoint, which is either a subroutine name or a line number. We set the appropriate one-time-break in @dbline and then turn off single-stepping in this and all call levels above this one.<div class="spacer">
</div>
&quot;r&quot; - return from a subroutine<div class="spacer">
</div>
For &quot;r&quot; to work properly, the debugger has to stop execution again immediately after the return is executed. This is done by forcing single-stepping to be on in the call level above the current one. If we are printing return values when a &quot;r&quot; is executed, set $doret appropriately, and force us out of the command loop.<div class="spacer">
</div>
&quot;T&quot; - stack trace<div class="spacer">
</div>
Just calls &quot;DB::print_trace&quot;.<div class="spacer">
</div>
&quot;w&quot; - List window around current line.<div class="spacer">
</div>
Just calls &quot;DB::cmd_w&quot;.<div class="spacer">
</div>
&quot;W&quot; - watch-expression processing.<div class="spacer">
</div>
Just calls &quot;DB::cmd_W&quot;.<div class="spacer">
</div>
&quot;/&quot; - search forward for a string in the source<div class="spacer">
</div>
We take the argument and treat it as a pattern. If it turns out to be a bad one, we return the error we got from trying to &quot;eval&quot; it and exit. If not, we create some code to do the search and &quot;eval&quot; it so it can't mess us up.<div class="spacer">
</div>
&quot;?&quot; - search backward for a string in the source<div class="spacer">
</div>
Same as for &quot;/&quot;, except the loop runs backwards.<div class="spacer">
</div>
$rc - Recall command<div class="spacer">
</div>
Manages the commands in @hist (which is created if &quot;Term::ReadLine&quot; reports that the terminal supports history). It finds the command required, puts it into $cmd, and redoes the loop to execute it.<div class="spacer">
</div>
&quot;$sh$sh&quot; - &quot;system()&quot; command<div class="spacer">
</div>
Calls the &quot;_db_system()&quot; to handle the command. This keeps the &quot;STDIN&quot; and &quot;STDOUT&quot; from getting messed up.<div class="spacer">
</div>
&quot;$rc <i>pattern</i> $rc&quot; - Search command history<div class="spacer">
</div>
Another command to manipulate @hist: this one searches it with a pattern. If a command is found, it is placed in $cmd and executed via &quot;redo&quot;.<div class="spacer">
</div>
$sh - Invoke a shell<div class="spacer">
</div>
Uses &quot;_db_system()&quot; to invoke a shell.<div class="spacer">
</div>
&quot;$sh <i>command</i>&quot; - Force execution of a command in a shell<div class="spacer">
</div>
Like the above, but the command is passed to the shell. Again, we use &quot;_db_system()&quot; to avoid problems with &quot;STDIN&quot; and &quot;STDOUT&quot;.<div class="spacer">
</div>
&quot;H&quot; - display commands in history<div class="spacer">
</div>
Prints the contents of @hist (if any).<div class="spacer">
</div>
&quot;man, doc, perldoc&quot; - look up documentation<div class="spacer">
</div>
Just calls &quot;runman()&quot; to print the appropriate document.<div class="spacer">
</div>
&quot;p&quot; - print<div class="spacer">
</div>
Builds a &quot;print EXPR&quot; expression in the $cmd; this will get executed at the bottom of the loop.<div class="spacer">
</div>
&quot;=&quot; - define command alias<div class="spacer">
</div>
Manipulates %alias to add or list command aliases.<div class="spacer">
</div>
&quot;source&quot; - read commands from a file.<div class="spacer">
</div>
Opens a lexical filehandle and stacks it on @cmdfhs; &quot;DB::readline&quot; will pick it up.<div class="spacer">
</div>
&quot;enable&quot; &quot;disable&quot; - enable or disable breakpoints<div class="spacer">
</div>
This enables or disables breakpoints.<div class="spacer">
</div>
&quot;save&quot; - send current history to a file<div class="spacer">
</div>
Takes the complete history, (not the shrunken version you see with &quot;H&quot;), and saves it to the given filename, so it can be replayed using &quot;source&quot;.<div class="spacer">
</div>
Note that all &quot;^(save|source)&quot;'s are commented out with a view to minimise recursion.<div class="spacer">
</div>
&quot;R&quot; - restart<div class="spacer">
</div>
Restart the debugger session.<div class="spacer">
</div>
&quot;rerun&quot; - rerun the current session<div class="spacer">
</div>
Return to any given position in the <b>true</b>-history list<div class="spacer">
</div>
&quot;|, ||&quot; - pipe output through the pager.<div class="spacer">
</div>
For &quot;|&quot;, we save &quot;OUT&quot; (the debugger's output filehandle) and &quot;STDOUT&quot; (the program's standard output). For &quot;||&quot;, we only save &quot;OUT&quot;. We open a pipe to the pager (restoring the output filehandles if this fails). If this is the &quot;|&quot; command, we also set up a &quot;SIGPIPE&quot; handler which will simply set $signal, sending us back into the debugger.<div class="spacer">
</div>
We then trim off the pipe symbols and &quot;redo&quot; the command loop at the &quot;PIPE&quot; label, causing us to evaluate the command in $cmd without reading another.<div class="spacer">
</div>
<i>END OF COMMAND PARSING</i><div class="spacer">
</div>
Anything left in $cmd at this point is a Perl expression that we want to evaluate. We'll always evaluate in the user's context, and fully qualify any variables we might want to address in the &quot;DB&quot; package.<div class="spacer">
</div>
<i>POST-COMMAND PROCESSING</i><div class="spacer">
</div>
After each command, we check to see if the command output was piped anywhere. If so, we go through the necessary code to unhook the pipe and go back to our standard filehandles for input and output.<div class="spacer">
</div>
<i>COMMAND LOOP TERMINATION</i><div class="spacer">
</div>
When commands have finished executing, we come here. If the user closed the input filehandle, we turn on $fall_off_end to emulate a &quot;q&quot; command. We evaluate any post-prompt items. We restore $@, $!, $^E, $,, $/, &quot;$\&quot;, and $^W, and return a null list as expected by the Perl interpreter. The interpreter will then execute the next line and then return control to us again.<div class="spacer">
</div>
Special check: if we're in package &quot;DB::fake&quot;, we've gone through the &quot;END&quot; block at least once. We set up everything so that we can continue to enter commands and have a valid context to be in.<div class="spacer">
</div>
If the program hasn't finished executing, we scan forward to the next executable line, print that out, build the prompt from the file and line number information, and print that.</div>
<div class="subsection">
<h2>sub</h2> &quot;sub&quot; is called whenever a subroutine call happens in the program being debugged. The variable $DB::sub contains the name of the subroutine being called.<div class="spacer">
</div>
The core function of this subroutine is to actually call the sub in the proper context, capturing its output. This of course causes &quot;DB::DB&quot; to get called again, repeating until the subroutine ends and returns control to &quot;DB::sub&quot; again. Once control returns, &quot;DB::sub&quot; figures out whether or not to dump the return value, and returns its captured copy of the return value as its own return value. The value then feeds back into the program being debugged as if &quot;DB::sub&quot; hadn't been there at all.<div class="spacer">
</div>
&quot;sub&quot; does all the work of printing the subroutine entry and exit messages enabled by setting $frame. It notes what sub the autoloader got called for, and also prints the return value if needed (for the &quot;r&quot; command and if the 16 bit is set in $frame).<div class="spacer">
</div>
It also tracks the subroutine call depth by saving the current setting of $single in the @stack package global; if this exceeds the value in $deep, &quot;sub&quot; automatically turns on printing of the current depth by setting the 4 bit in $single. In any case, it keeps the current setting of stop/don't stop on entry to subs set as it currently is set.<div class="spacer">
</div>
<i></i><i>&quot;caller()&quot;</i><i> support</i><div class="spacer">
</div>
If &quot;caller()&quot; is called from the package &quot;DB&quot;, it provides some additional data, in the following order:<dl>
<dt>
&#8226;</dt>
<dd>
$package<div style="height: 1.00em;">
&#160;</div>
The package name the sub was in</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
$filename<div style="height: 1.00em;">
&#160;</div>
The filename it was defined in</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
$line<div style="height: 1.00em;">
&#160;</div>
The line number it was defined on</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
$subroutine<div style="height: 1.00em;">
&#160;</div>
The subroutine name; &quot;(eval)&quot; if an &quot;eval&quot;().</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
$hasargs<div style="height: 1.00em;">
&#160;</div>
1 if it has arguments, 0 if not</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
$wantarray<div style="height: 1.00em;">
&#160;</div>
1 if array context, 0 if scalar context</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
$evaltext<div style="height: 1.00em;">
&#160;</div>
The &quot;eval&quot;() text, if any (undefined for &quot;eval BLOCK&quot;)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
$is_require<div style="height: 1.00em;">
&#160;</div>
frame was created by a &quot;use&quot; or &quot;require&quot; statement</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
$hints<div style="height: 1.00em;">
&#160;</div>
pragma information; subject to change between versions</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
$bitmask<div style="height: 1.00em;">
&#160;</div>
pragma information; subject to change between versions</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
@DB::args<div style="height: 1.00em;">
&#160;</div>
arguments with which the subroutine was invoked</dd>
</dl>
</div>
</div>
<div class="section">
<h1>EXTENDED COMMAND HANDLING AND THE COMMAND API</h1> In Perl 5.8.0, there was a major realignment of the commands and what they did, Most of the changes were to systematize the command structure and to eliminate commands that threw away user input without checking.<div class="spacer">
</div>
The following sections describe the code added to make it easy to support multiple command sets with conflicting command names. This section is a start at unifying all command processing to make it simpler to develop commands.<div class="spacer">
</div>
Note that all the cmd_[a-zA-Z] subroutines require the command name, a line number, and $dbline (the current line) as arguments.<div class="spacer">
</div>
Support functions in this section which have multiple modes of failure &quot;die&quot; on error; the rest simply return a false value.<div class="spacer">
</div>
The user-interface functions (all of the &quot;cmd_*&quot; functions) just output error messages.<div class="subsection">
<h2>%set</h2> The %set hash defines the mapping from command letter to subroutine name suffix.<div class="spacer">
</div>
%set is a two-level hash, indexed by set name and then by command name. Note that trying to set the CommandSet to &quot;foobar&quot; simply results in the 5.8.0 command set being used, since there's no top-level entry for &quot;foobar&quot;.</div>
<div class="subsection">
<h2>&quot;cmd_wrapper()&quot; (API)</h2> &quot;cmd_wrapper()&quot; allows the debugger to switch command sets depending on the value of the &quot;CommandSet&quot; option.<div class="spacer">
</div>
It tries to look up the command in the %set package-level <i>lexical</i> (which means external entities can't fiddle with it) and create the name of the sub to call based on the value found in the hash (if it's there).  <i>All</i> of the commands to be handled in a set have to be added to %set; if they aren't found, the 5.8.0 equivalent is called (if there is one).<div class="spacer">
</div>
This code uses symbolic references.<div class="spacer">
</div>
<i></i><i>&quot;cmd_a&quot;</i><i> (command)</i><div class="spacer">
</div>
The &quot;a&quot; command handles pre-execution actions. These are associated with a particular line, so they're stored in %dbline. We default to the current line if none is specified.<div class="spacer">
</div>
<i></i><i>&quot;cmd_A&quot;</i><i> (command)</i><div class="spacer">
</div>
Delete actions. Similar to above, except the delete code is in a separate subroutine, &quot;delete_action&quot;.<div class="spacer">
</div>
<i></i><i>&quot;delete_action&quot;</i><i> (API)</i><div class="spacer">
</div>
&quot;delete_action&quot; accepts either a line number or &quot;undef&quot;. If a line number is specified, we check for the line being executable (if it's not, it couldn't have had an  action). If it is, we just take the action off (this will get any kind of an action, including breakpoints).<div class="spacer">
</div>
<i></i><i>&quot;cmd_b&quot;</i><i> (command)</i><div class="spacer">
</div>
Set breakpoints. Since breakpoints can be set in so many places, in so many ways, conditionally or not, the breakpoint code is kind of complex. Mostly, we try to parse the command type, and then shuttle it off to an appropriate subroutine to actually do the work of setting the breakpoint in the right place.<div class="spacer">
</div>
<i></i><i>&quot;break_on_load&quot;</i><i> (API)</i><div class="spacer">
</div>
We want to break when this file is loaded. Mark this file in the %break_on_load hash, and note that it has a breakpoint in %had_breakpoints.<div class="spacer">
</div>
<i></i><i>&quot;report_break_on_load&quot;</i><i> (API)</i><div class="spacer">
</div>
Gives us an array of filenames that are set to break on load. Note that only files with break-on-load are in here, so simply showing the keys suffices.<div class="spacer">
</div>
<i></i><i>&quot;cmd_b_load&quot;</i><i> (command)</i><div class="spacer">
</div>
We take the file passed in and try to find it in %INC (which maps modules to files they came from). We mark those files for break-on-load via &quot;break_on_load&quot; and then report that it was done.<div class="spacer">
</div>
<i></i><i>$filename_error</i><i> (API package global)</i><div class="spacer">
</div>
Several of the functions we need to implement in the API need to work both on the current file and on other files. We don't want to duplicate code, so $filename_error is used to contain the name of the file that's being worked on (if it's not the current one).<div class="spacer">
</div>
We can now build functions in pairs: the basic function works on the current file, and uses $filename_error as part of its error message. Since this is initialized to &quot;&quot;, no filename will appear when we are working on the current file.<div class="spacer">
</div>
The second function is a wrapper which does the following:<dl>
<dt>
&#8226;</dt>
<dd>
Localizes $filename_error and sets it to the name of the file to be processed.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Localizes the *dbline glob and reassigns it to point to the file we want to process.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Calls the first function.<div style="height: 1.00em;">
&#160;</div>
The first function works on the <i>current</i> file (i.e., the one we changed to), and prints $filename_error in the error message (the name of the other file) if it needs to. When the functions return, *dbline is restored to point to the actual current file (the one we're executing in) and $filename_error is restored to &quot;&quot;. This restores everything to the way it was before the second function was called at all.<div style="height: 1.00em;">
&#160;</div>
See the comments in &quot;breakable_line&quot; and &quot;breakable_line_in_file&quot; for more details.</dd>
</dl>
<div class="spacer">
</div>
<i>breakable_line(from, to) (API)</i><div class="spacer">
</div>
The subroutine decides whether or not a line in the current file is breakable. It walks through @dbline within the range of lines specified, looking for the first line that is breakable.<div class="spacer">
</div>
If $to is greater than $from, the search moves forwards, finding the first line  <i>after</i> $to that's breakable, if there is one.<div class="spacer">
</div>
If $from is greater than $to, the search goes <i>backwards</i>, finding the first line  <i>before</i> $to that's breakable, if there is one.<div class="spacer">
</div>
<i>breakable_line_in_filename(file, from, to) (API)</i><div class="spacer">
</div>
Like &quot;breakable_line&quot;, but look in another file.<div class="spacer">
</div>
<i>break_on_line(lineno, [condition]) (API)</i><div class="spacer">
</div>
Adds a breakpoint with the specified condition (or 1 if no condition was specified) to the specified line. Dies if it can't.<div class="spacer">
</div>
<i>cmd_b_line(line, [condition]) (command)</i><div class="spacer">
</div>
Wrapper for &quot;break_on_line&quot;. Prints the failure message if it doesn't work.<div class="spacer">
</div>
<i>cmd_b_filename_line(line, [condition]) (command)</i><div class="spacer">
</div>
Wrapper for &quot;break_on_filename_line&quot;. Prints the failure message if it doesn't work.<div class="spacer">
</div>
<i>break_on_filename_line(file, line, [condition]) (API)</i><div class="spacer">
</div>
Switches to the file specified and then calls &quot;break_on_line&quot; to set the breakpoint.<div class="spacer">
</div>
<i>break_on_filename_line_range(file, from, to, [condition]) (API)</i><div class="spacer">
</div>
Switch to another file, search the range of lines specified for an executable one, and put a breakpoint on the first one you find.<div class="spacer">
</div>
<i>subroutine_filename_lines(subname, [condition]) (API)</i><div class="spacer">
</div>
Search for a subroutine within a given file. The condition is ignored. Uses &quot;find_sub&quot; to locate the desired subroutine.<div class="spacer">
</div>
<i>break_subroutine(subname) (API)</i><div class="spacer">
</div>
Places a break on the first line possible in the specified subroutine. Uses &quot;subroutine_filename_lines&quot; to find the subroutine, and &quot;break_on_filename_line_range&quot; to place the break.<div class="spacer">
</div>
<i>cmd_b_sub(subname, [condition]) (command)</i><div class="spacer">
</div>
We take the incoming subroutine name and fully-qualify it as best we can.<dl>
<dt>
1. If it's already fully-qualified, leave it alone.</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
2. Try putting it in the current package.</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
3. If it's not there, try putting it in CORE::GLOBAL if it exists there.</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
4. If it starts with '::', put it in 'main::'.</dt>
<dd>
</dd>
</dl>
<div class="spacer">
</div>
After all this cleanup, we call &quot;break_subroutine&quot; to try to set the breakpoint.<div class="spacer">
</div>
<i></i><i>&quot;cmd_B&quot;</i><i> - delete breakpoint(s) (command)</i><div class="spacer">
</div>
The command mostly parses the command line and tries to turn the argument into a line spec. If it can't, it uses the current line. It then calls &quot;delete_breakpoint&quot; to actually do the work.<div class="spacer">
</div>
If &quot;*&quot; is  specified, &quot;cmd_B&quot; calls &quot;delete_breakpoint&quot; with no arguments, thereby deleting all the breakpoints.<div class="spacer">
</div>
<i>delete_breakpoint([line]) (API)</i><div class="spacer">
</div>
This actually does the work of deleting either a single breakpoint, or all of them.<div class="spacer">
</div>
For a single line, we look for it in @dbline. If it's nonbreakable, we just drop out with a message saying so. If it is, we remove the condition part of the 'condition\0action' that says there's a breakpoint here. If, after we've done that, there's nothing left, we delete the corresponding line in %dbline to signal that no action needs to be taken for this line.<div class="spacer">
</div>
For all breakpoints, we iterate through the keys of %had_breakpoints, which lists all currently-loaded files which have breakpoints. We then look at each line in each of these files, temporarily switching the %dbline and @dbline structures to point to the files in question, and do what we did in the single line case: delete the condition in @dbline, and delete the key in %dbline if nothing's left.<div class="spacer">
</div>
We then wholesale delete %postponed, %postponed_file, and %break_on_load, because these structures contain breakpoints for files and code that haven't been loaded yet. We can just kill these off because there are no magical debugger structures associated with them.<div class="spacer">
</div>
<i>cmd_stop (command)</i><div class="spacer">
</div>
This is meant to be part of the new command API, but it isn't called or used anywhere else in the debugger. XXX It is probably meant for use in development of new commands.<div class="spacer">
</div>
<i></i><i>&quot;cmd_e&quot;</i><i> - threads</i><div class="spacer">
</div>
Display the current thread id:<div class="spacer">
</div>
<br/>
    e<br/>
<div class="spacer">
</div>
This could be how (when implemented) to send commands to this thread id (e cmd) or that thread id (e tid cmd).<div class="spacer">
</div>
<i></i><i>&quot;cmd_E&quot;</i><i> - list of thread ids</i><div class="spacer">
</div>
Display the list of available thread ids:<div class="spacer">
</div>
<br/>
    E<br/>
<div class="spacer">
</div>
This could be used (when implemented) to send commands to all threads (E cmd).<div class="spacer">
</div>
<i></i><i>&quot;cmd_h&quot;</i><i> - help command (command)</i><div class="spacer">
</div>
Does the work of either<dl>
<dt>
&#8226;</dt>
<dd>
Showing all the debugger help</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Showing help for a specific command</dd>
</dl>
<div class="spacer">
</div>
<i></i><i>&quot;cmd_i&quot;</i><i> - inheritance display</i><div class="spacer">
</div>
Display the (nested) parentage of the module or object given.<div class="spacer">
</div>
<i></i><i>&quot;cmd_l&quot;</i><i> - list lines (command)</i><div class="spacer">
</div>
Most of the command is taken up with transforming all the different line specification syntaxes into 'start-stop'. After that is done, the command runs a loop over @dbline for the specified range of lines. It handles the printing of each line and any markers (&quot;==&gt;&quot; for current line, &quot;b&quot; for break on this line, &quot;a&quot; for action on this line, &quot;:&quot; for this line breakable).<div class="spacer">
</div>
We save the last line listed in the $start global for further listing later.<div class="spacer">
</div>
<i></i><i>&quot;cmd_L&quot;</i><i> - list breakpoints, actions, and watch expressions (command)</i><div class="spacer">
</div>
To list breakpoints, the command has to look determine where all of them are first. It starts a %had_breakpoints, which tells us what all files have breakpoints and/or actions. For each file, we switch the *dbline glob (the magic source and breakpoint data structures) to the file, and then look through %dbline for lines with breakpoints and/or actions, listing them out. We look through %postponed not-yet-compiled subroutines that have breakpoints, and through %postponed_file for not-yet-&quot;require&quot;'d files that have breakpoints.<div class="spacer">
</div>
Watchpoints are simpler: we just list the entries in @to_watch.<div class="spacer">
</div>
<i></i><i>&quot;cmd_M&quot;</i><i> - list modules (command)</i><div class="spacer">
</div>
Just call &quot;list_modules&quot;.<div class="spacer">
</div>
<i></i><i>&quot;cmd_o&quot;</i><i> - options (command)</i><div class="spacer">
</div>
If this is just &quot;o&quot; by itself, we list the current settings via &quot;dump_option&quot;. If there's a nonblank value following it, we pass that on to &quot;parse_options&quot; for processing.<div class="spacer">
</div>
<i></i><i>&quot;cmd_O&quot;</i><i> - nonexistent in 5.8.x (command)</i><div class="spacer">
</div>
Advises the user that the O command has been renamed.<div class="spacer">
</div>
<i></i><i>&quot;cmd_v&quot;</i><i> - view window (command)</i><div class="spacer">
</div>
Uses the $preview variable set in the second &quot;BEGIN&quot; block (q.v.) to move back a few lines to list the selected line in context. Uses &quot;cmd_l&quot; to do the actual listing after figuring out the range of line to request.<div class="spacer">
</div>
<i></i><i>&quot;cmd_w&quot;</i><i> - add a watch expression (command)</i><div class="spacer">
</div>
The 5.8 version of this command adds a watch expression if one is specified; it does nothing if entered with no operands.<div class="spacer">
</div>
We extract the expression, save it, evaluate it in the user's context, and save the value. We'll re-evaluate it each time the debugger passes a line, and will stop (see the code at the top of the command loop) if the value of any of the expressions changes.<div class="spacer">
</div>
<i></i><i>&quot;cmd_W&quot;</i><i> - delete watch expressions (command)</i><div class="spacer">
</div>
This command accepts either a watch expression to be removed from the list of watch expressions, or &quot;*&quot; to delete them all.<div class="spacer">
</div>
If &quot;*&quot; is specified, we simply empty the watch expression list and the watch expression value list. We also turn off the bit that says we've got watch expressions.<div class="spacer">
</div>
If an expression (or partial expression) is specified, we pattern-match through the expressions and remove the ones that match. We also discard the corresponding values. If no watch expressions are left, we turn off the  <i>watching expressions</i> bit.</div>
</div>
<div class="section">
<h1>SUPPORT ROUTINES</h1> These are general support routines that are used in a number of places throughout the debugger.<div class="subsection">
<h2>save</h2>  <i>save()</i> saves the user's versions of globals that would mess us up in @saved, and installs the versions we like better.</div>
<div class="subsection">
<h2>&quot;print_lineinfo&quot; - show where we are now</h2> print_lineinfo prints whatever it is that it is handed; it prints it to the $LINEINFO filehandle instead of just printing it to STDOUT. This allows us to feed line information to a slave editor without messing up the debugger output.</div>
<div class="subsection">
<h2>&quot;postponed_sub&quot;</h2> Handles setting postponed breakpoints in subroutines once they're compiled. For breakpoints, we use &quot;DB::find_sub&quot; to locate the source file and line range for the subroutine, then mark the file as having a breakpoint, temporarily switch the *dbline glob over to the source file, and then search the given range of lines to find a breakable line. If we find one, we set the breakpoint on it, deleting the breakpoint from %postponed.</div>
<div class="subsection">
<h2>&quot;postponed&quot;</h2> Called after each required file is compiled, but before it is executed; also called if the name of a just-compiled subroutine is a key of %postponed. Propagates saved breakpoints (from &quot;b compile&quot;, &quot;b load&quot;, etc.) into the just-compiled code.<div class="spacer">
</div>
If this is a &quot;require&quot;'d file, the incoming parameter is the glob &quot;*{&quot;_&lt;$filename&quot;}&quot;, with $filename the name of the &quot;require&quot;'d file.<div class="spacer">
</div>
If it's a subroutine, the incoming parameter is the subroutine name.</div>
<div class="subsection">
<h2>&quot;dumpit&quot;</h2> &quot;dumpit&quot; is the debugger's wrapper around dumpvar.pl.<div class="spacer">
</div>
It gets a filehandle (to which &quot;dumpvar.pl&quot;'s output will be directed) and a reference to a variable (the thing to be dumped) as its input.<div class="spacer">
</div>
The incoming filehandle is selected for output (&quot;dumpvar.pl&quot; is printing to the currently-selected filehandle, thank you very much). The current values of the package globals $single and $trace are backed up in lexicals, and they are turned off (this keeps the debugger from trying to single-step through &quot;dumpvar.pl&quot; (I think.)). $frame is localized to preserve its current value and it is set to zero to prevent entry/exit messages from printing, and $doret is localized as well and set to -2 to prevent return values from being shown.<div class="spacer">
</div>
&quot;dumpit()&quot; then checks to see if it needs to load &quot;dumpvar.pl&quot; and tries to load it (note: if you have a &quot;dumpvar.pl&quot;  ahead of the installed version in @INC, yours will be used instead. Possible security problem?).<div class="spacer">
</div>
It then checks to see if the subroutine &quot;main::dumpValue&quot; is now defined it should have been defined by &quot;dumpvar.pl&quot;). If it has, &quot;dumpit()&quot; localizes the globals necessary for things to be sane when &quot;main::dumpValue()&quot; is called, and picks up the variable to be dumped from the parameter list.<div class="spacer">
</div>
It checks the package global %options to see if there's a &quot;dumpDepth&quot; specified. If not, -1 is assumed; if so, the supplied value gets passed on to &quot;dumpvar.pl&quot;. This tells &quot;dumpvar.pl&quot; where to leave off when dumping a structure: -1 means dump everything.<div class="spacer">
</div>
&quot;dumpValue()&quot; is then called if possible; if not, &quot;dumpit()&quot;just prints a warning.<div class="spacer">
</div>
In either case, $single, $trace, $frame, and $doret are restored and we then return to the caller.</div>
<div class="subsection">
<h2>&quot;print_trace&quot;</h2> &quot;print_trace&quot;'s job is to print a stack trace. It does this via the &quot;dump_trace&quot; routine, which actually does all the ferreting-out of the stack trace data. &quot;print_trace&quot; takes care of formatting it nicely and printing it to the proper filehandle.<div class="spacer">
</div>
Parameters:<dl>
<dt>
&#8226;</dt>
<dd>
The filehandle to print to.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
How many frames to skip before starting trace.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
How many frames to print.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
A flag: if true, print a <i>short</i> trace without filenames, line numbers, or arguments</dd>
</dl>
<div class="spacer">
</div>
The original comment below seems to be noting that the traceback may not be correct if this routine is called in a tied method.</div>
<div class="subsection">
<h2>dump_trace(skip[,count])</h2> Actually collect the traceback information available via &quot;caller()&quot;. It does some filtering and cleanup of the data, but mostly it just collects it to make &quot;print_trace()&quot;'s job easier.<div class="spacer">
</div>
&quot;skip&quot; defines the number of stack frames to be skipped, working backwards from the most current. &quot;count&quot; determines the total number of frames to be returned; all of them (well, the first 10^9) are returned if &quot;count&quot; is omitted.<div class="spacer">
</div>
This routine returns a list of hashes, from most-recent to least-recent stack frame. Each has the following keys and values:<dl>
<dt>
&#8226;</dt>
<dd>
&quot;context&quot; - &quot;.&quot; (null), &quot;$&quot; (scalar), or &quot;@&quot; (array)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;sub&quot; - subroutine name, or &quot;eval&quot; information</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;args&quot; - undef, or a reference to an array of arguments</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;file&quot; - the file in which this item was defined (if any)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;line&quot; - the line on which it was defined</dd>
</dl>
</div>
<div class="subsection">
<h2>&quot;action()&quot;</h2> &quot;action()&quot; takes input provided as the argument to an add-action command, either pre- or post-, and makes sure it's a complete command. It doesn't do any fancy parsing; it just keeps reading input until it gets a string without a trailing backslash.</div>
<div class="subsection">
<h2>unbalanced</h2> This routine mostly just packages up a regular expression to be used to check that the thing it's being matched against has properly-matched curly braces.<div class="spacer">
</div>
Of note is the definition of the $balanced_brace_re global via &quot;||=&quot;, which speeds things up by only creating the qr//'ed expression once; if it's already defined, we don't try to define it again. A speed hack.</div>
<div class="subsection">
<h2>&quot;gets()&quot;</h2> &quot;gets()&quot; is a primitive (very primitive) routine to read continuations. It was devised for reading continuations for actions. it just reads more input with &quot;readline()&quot; and returns it.</div>
<div class="subsection">
<h2>&quot;_db_system()&quot; - handle calls to&lt;<i>system()</i>&gt; without messing up the debugger</h2> The &quot;system()&quot; function assumes that it can just go ahead and use STDIN and STDOUT, but under the debugger, we want it to use the debugger's input and outout filehandles.<div class="spacer">
</div>
&quot;_db_system()&quot; socks away the program's STDIN and STDOUT, and then substitutes the debugger's IN and OUT filehandles for them. It does the &quot;system()&quot; call, and then puts everything back again.</div>
</div>
<div class="section">
<h1>TTY MANAGEMENT</h1> The subs here do some of the terminal management for multiple debuggers.<div class="subsection">
<h2>setterm</h2> Top-level function called when we want to set up a new terminal for use by the debugger.<div class="spacer">
</div>
If the &quot;noTTY&quot; debugger option was set, we'll either use the terminal supplied (the value of the &quot;noTTY&quot; option), or we'll use &quot;Term::Rendezvous&quot; to find one. If we're a forked debugger, we call &quot;resetterm&quot; to try to get a whole new terminal if we can.<div class="spacer">
</div>
In either case, we set up the terminal next. If the &quot;ReadLine&quot; option was true, we'll get a &quot;Term::ReadLine&quot; object for the current terminal and save the appropriate attributes. We then</div>
</div>
<div class="section">
<h1>GET_FORK_TTY EXAMPLE FUNCTIONS</h1> When the process being debugged forks, or the process invokes a command via &quot;system()&quot; which starts a new debugger, we need to be able to get a new &quot;IN&quot; and &quot;OUT&quot; filehandle for the new debugger. Otherwise, the two processes fight over the terminal, and you can never quite be sure who's going to get the input you're typing.<div class="spacer">
</div>
&quot;get_fork_TTY&quot; is a glob-aliased function which calls the real function that is tasked with doing all the necessary operating system mojo to get a new TTY (and probably another window) and to direct the new debugger to read and write there.<div class="spacer">
</div>
The debugger provides &quot;get_fork_TTY&quot; functions which work for TCP socket servers, X11, OS/2, and Mac OS X. Other systems are not supported. You are encouraged to write &quot;get_fork_TTY&quot; functions which work for  <i>your</i> platform and contribute them.<div class="spacer">
</div>
<i></i><i>&quot;socket_get_fork_TTY&quot;</i><i></i><div class="spacer">
</div>
<i></i><i>&quot;xterm_get_fork_TTY&quot;</i><i></i><div class="spacer">
</div>
This function provides the &quot;get_fork_TTY&quot; function for X11. If a program running under the debugger forks, a new &lt;xterm&gt; window is opened and the subsidiary debugger is directed there.<div class="spacer">
</div>
The &quot;open()&quot; call is of particular note here. We have the new &quot;xterm&quot; we're spawning route file number 3 to STDOUT, and then execute the &quot;tty&quot; command (which prints the device name of the TTY we'll want to use for input and output to STDOUT, then &quot;sleep&quot; for a very long time, routing this output to file number 3. This way we can simply read from the &lt;XT&gt; filehandle (which is STDOUT from the  <i>commands</i> we ran) to get the TTY we want to use.<div class="spacer">
</div>
Only works if &quot;xterm&quot; is in your path and $ENV{DISPLAY}, etc. are properly set up.<div class="spacer">
</div>
<i></i><i>&quot;os2_get_fork_TTY&quot;</i><i></i><div class="spacer">
</div>
XXX It behooves an OS/2 expert to write the necessary documentation for this!<div class="spacer">
</div>
<i></i><i>&quot;macosx_get_fork_TTY&quot;</i><i></i><div class="spacer">
</div>
The Mac OS X version uses AppleScript to tell Terminal.app to create a new window.<div class="subsection">
<h2>&quot;create_IN_OUT($flags)&quot;</h2> Create a new pair of filehandles, pointing to a new TTY. If impossible, try to diagnose why.<div class="spacer">
</div>
Flags are:<dl>
<dt>
&#8226;</dt>
<dd>
1 - Don't know how to create a new TTY.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
2 - Debugger has forked, but we can't get a new TTY.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
4 - standard debugger startup is happening.</dd>
</dl>
</div>
<div class="subsection">
<h2>&quot;resetterm&quot;</h2> Handles rejiggering the prompt when we've forked off a new debugger.<div class="spacer">
</div>
If the new debugger happened because of a &quot;system()&quot; that invoked a program under the debugger, the arrow between the old pid and the new in the prompt has  <i>two</i> dashes instead of one.<div class="spacer">
</div>
We take the current list of pids and add this one to the end. If there isn't any list yet, we make one up out of the initial pid associated with the terminal and our new pid, sticking an arrow (either one-dashed or two dashed) in between them.<div class="spacer">
</div>
If &quot;CreateTTY&quot; is off, or &quot;resetterm&quot; was called with no arguments, we don't try to create a new IN and OUT filehandle. Otherwise, we go ahead and try to do that.</div>
<div class="subsection">
<h2>&quot;readline&quot;</h2> First, we handle stuff in the typeahead buffer. If there is any, we shift off the next line, print a message saying we got it, add it to the terminal history (if possible), and return it.<div class="spacer">
</div>
If there's nothing in the typeahead buffer, check the command filehandle stack. If there are any filehandles there, read from the last one, and return the line if we got one. If not, we pop the filehandle off and close it, and try the next one up the stack.<div class="spacer">
</div>
If we've emptied the filehandle stack, we check to see if we've got a socket open, and we read that and return it if we do. If we don't, we just call the core &quot;readline()&quot; and return its value.</div>
</div>
<div class="section">
<h1>OPTIONS SUPPORT ROUTINES</h1> These routines handle listing and setting option values.<div class="subsection">
<h2>&quot;dump_option&quot; - list the current value of an option setting</h2> This routine uses &quot;option_val&quot; to look up the value for an option. It cleans up escaped single-quotes and then displays the option and its value.</div>
<div class="subsection">
<h2>&quot;option_val&quot; - find the current value of an option</h2> This can't just be a simple hash lookup because of the indirect way that the option values are stored. Some are retrieved by calling a subroutine, some are just variables.<div class="spacer">
</div>
You must supply a default value to be used in case the option isn't set.</div>
<div class="subsection">
<h2>&quot;parse_options&quot;</h2> Handles the parsing and execution of option setting/displaying commands.<div class="spacer">
</div>
An option entered by itself is assumed to be <i>set me to 1</i> (the default value) if the option is a boolean one. If not, the user is prompted to enter a valid value or to query the current value (via &quot;option? &quot;).<div class="spacer">
</div>
If &quot;option=value&quot; is entered, we try to extract a quoted string from the value (if it is quoted). If it's not, we just use the whole value as-is.<div class="spacer">
</div>
We load any modules required to service this option, and then we set it: if it just gets stuck in a variable, we do that; if there's a subroutine to handle setting the option, we call that.<div class="spacer">
</div>
Finally, if we're running in interactive mode, we display the effect of the user's command back to the terminal, skipping this if we're setting things during initialization.</div>
</div>
<div class="section">
<h1>RESTART SUPPORT</h1> These routines are used to store (and restore) lists of items in environment variables during a restart.<div class="subsection">
<h2>set_list</h2> Set_list packages up items to be stored in a set of environment variables (VAR_n, containing the number of items, and VAR_0, VAR_1, etc., containing the values). Values outside the standard ASCII charset are stored by encoding then as hexadecimal values.</div>
<div class="subsection">
<h2>get_list</h2> Reverse the set_list operation: grab VAR_n to see how many we should be getting back, and then pull VAR_0, VAR_1. etc. back out.</div>
</div>
<div class="section">
<h1>MISCELLANEOUS SIGNAL AND I/O MANAGEMENT</h1><div class="subsection">
<h2><i>catch()</i></h2> The &quot;catch()&quot; subroutine is the essence of fast and low-impact. We simply set an already-existing global scalar variable to a constant value. This avoids allocating any memory possibly in the middle of something that will get all confused if we do, particularly under  <i>unsafe signals</i>.</div>
<div class="subsection">
<h2>&quot;warn()&quot;</h2> &quot;warn&quot; emits a warning, by joining together its arguments and printing them, with couple of fillips.<div class="spacer">
</div>
If the composited message <i>doesn't</i> end with a newline, we automatically add $! and a newline to the end of the message. The subroutine expects $OUT to be set to the filehandle to be used to output warnings; it makes no assumptions about what filehandles are available.</div>
</div>
<div class="section">
<h1>INITIALIZATION TTY SUPPORT</h1><div class="subsection">
<h2>&quot;reset_IN_OUT&quot;</h2> This routine handles restoring the debugger's input and output filehandles after we've tried and failed to move them elsewhere.  In addition, it assigns the debugger's output filehandle to $LINEINFO if it was already open there.</div>
</div>
<div class="section">
<h1>OPTION SUPPORT ROUTINES</h1> The following routines are used to process some of the more complicated debugger options.<div class="subsection">
<h2>&quot;TTY&quot;</h2> Sets the input and output filehandles to the specified files or pipes. If the terminal supports switching, we go ahead and do it. If not, and there's already a terminal in place, we save the information to take effect on restart.<div class="spacer">
</div>
If there's no terminal yet (for instance, during debugger initialization), we go ahead and set $console and $tty to the file indicated.</div>
<div class="subsection">
<h2>&quot;noTTY&quot;</h2> Sets the $notty global, controlling whether or not the debugger tries to get a terminal to read from. If called after a terminal is already in place, we save the value to use it if we're restarted.</div>
<div class="subsection">
<h2>&quot;ReadLine&quot;</h2> Sets the $rl option variable. If 0, we use &quot;Term::ReadLine::Stub&quot; (essentially, no &quot;readline&quot; processing on this  <i>terminal</i>). Otherwise, we use &quot;Term::ReadLine&quot;. Can't be changed after a terminal's in place; we save the value in case a restart is done so we can change it then.</div>
<div class="subsection">
<h2>&quot;RemotePort&quot;</h2> Sets the port that the debugger will try to connect to when starting up. If the terminal's already been set up, we can't do it, but we remember the setting in case the user does a restart.</div>
<div class="subsection">
<h2>&quot;tkRunning&quot;</h2> Checks with the terminal to see if &quot;Tk&quot; is running, and returns true or false. Returns false if the current terminal doesn't support &quot;readline&quot;.</div>
<div class="subsection">
<h2>&quot;NonStop&quot;</h2> Sets nonstop mode. If a terminal's already been set up, it's too late; the debugger remembers the setting in case you restart, though.</div>
<div class="subsection">
<h2>&quot;pager&quot;</h2> Set up the $pager variable. Adds a pipe to the front unless there's one there already.</div>
<div class="subsection">
<h2>&quot;shellBang&quot;</h2> Sets the shell escape command, and generates a printable copy to be used in the help.</div>
<div class="subsection">
<h2>&quot;ornaments&quot;</h2> If the terminal has its own ornaments, fetch them. Otherwise accept whatever was passed as the argument. (This means you can't override the terminal's ornaments.)</div>
<div class="subsection">
<h2>&quot;recallCommand&quot;</h2> Sets the recall command, and builds a printable version which will appear in the help text.</div>
<div class="subsection">
<h2>&quot;LineInfo&quot; - where the line number information goes</h2> Called with no arguments, returns the file or pipe that line info should go to.<div class="spacer">
</div>
Called with an argument (a file or a pipe), it opens that onto the &quot;LINEINFO&quot; filehandle, unbuffers the filehandle, and then returns the file or pipe again to the caller.</div>
</div>
<div class="section">
<h1>COMMAND SUPPORT ROUTINES</h1> These subroutines provide functionality for various commands.<div class="subsection">
<h2>&quot;list_modules&quot;</h2> For the &quot;M&quot; command: list modules loaded and their versions. Essentially just runs through the keys in %INC, picks each package's $VERSION variable, gets the file name, and formats the information for output.</div>
<div class="subsection">
<h2>&quot;sethelp()&quot;</h2> Sets up the monster string used to format and print the help.<div class="spacer">
</div>
<i>HELP MESSAGE FORMAT</i><div class="spacer">
</div>
The help message is a peculiar format unto itself; it mixes &quot;pod&quot; <i>ornaments</i> (&quot; <b></b>&quot; &quot;<i></i>&quot;) with tabs to come up with a format that's fairly easy to parse and portable, but which still allows the help to be a little nicer than just plain text.<div class="spacer">
</div>
Essentially, you define the command name (usually marked up with &quot;<b></b>&quot; and &quot; <i></i>&quot;), followed by a tab, and then the descriptive text, ending in a newline. The descriptive text can also be marked up in the same way. If you need to continue the descriptive text to another line, start that line with just tabs and then enter the marked-up text.<div class="spacer">
</div>
If you are modifying the help text, <i>be careful</i>. The help-string parser is not very sophisticated, and if you don't follow these rules it will mangle the help beyond hope until you fix the string.</div>
<div class="subsection">
<h2>&quot;print_help()&quot;</h2> Most of what &quot;print_help&quot; does is just text formatting. It finds the &quot;B&quot; and &quot;I&quot; ornaments, cleans them off, and substitutes the proper terminal control characters to simulate them (courtesy of &quot;Term::ReadLine::TermCap&quot;).</div>
<div class="subsection">
<h2>&quot;fix_less&quot;</h2> This routine does a lot of gyrations to be sure that the pager is &quot;less&quot;. It checks for &quot;less&quot; masquerading as &quot;more&quot; and records the result in $fixed_less so we don't have to go through doing the stats again.</div>
</div>
<div class="section">
<h1>DIE AND WARN MANAGEMENT</h1><div class="subsection">
<h2>&quot;diesignal&quot;</h2> &quot;diesignal&quot; is a just-drop-dead &quot;die&quot; handler. It's most useful when trying to debug a debugger problem.<div class="spacer">
</div>
It does its best to report the error that occurred, and then forces the program, debugger, and everything to die.</div>
<div class="subsection">
<h2>&quot;dbwarn&quot;</h2> The debugger's own default $SIG{__WARN__} handler. We load &quot;Carp&quot; to be able to get a stack trace, and output the warning message vi &quot;DB::dbwarn()&quot;.</div>
<div class="subsection">
<h2>&quot;dbdie&quot;</h2> The debugger's own $SIG{__DIE__} handler. Handles providing a stack trace by loading &quot;Carp&quot; and calling &quot;Carp::longmess()&quot; to get it. We turn off single stepping and tracing during the call to &quot;Carp::longmess&quot; to avoid debugging it - we just want to use it.<div class="spacer">
</div>
If &quot;dieLevel&quot; is zero, we let the program being debugged handle the exceptions. If it's 1, you get backtraces for any exception. If it's 2, the debugger takes over all exception handling, printing a backtrace and displaying the exception via its &quot;dbwarn()&quot; routine.</div>
<div class="subsection">
<h2>&quot;warnlevel()&quot;</h2> Set the $DB::warnLevel variable that stores the value of the &quot;warnLevel&quot; option. Calling &quot;warnLevel()&quot; with a positive value results in the debugger taking over all warning handlers. Setting &quot;warnLevel&quot; to zero leaves any warning handlers set up by the program being debugged in place.</div>
<div class="subsection">
<h2>&quot;dielevel&quot;</h2> Similar to &quot;warnLevel&quot;. Non-zero values for &quot;dieLevel&quot; result in the &quot;DB::dbdie()&quot; function overriding any other &quot;die()&quot; handler. Setting it to zero lets you use your own &quot;die()&quot; handler.</div>
<div class="subsection">
<h2>&quot;signalLevel&quot;</h2> Number three in a series: set &quot;signalLevel&quot; to zero to keep your own signal handler for &quot;SIGSEGV&quot; and/or &quot;SIGBUS&quot;. Otherwise, the debugger takes over and handles them with &quot;DB::diesignal()&quot;.</div>
</div>
<div class="section">
<h1>SUBROUTINE DECODING SUPPORT</h1> These subroutines are used during the &quot;x&quot; and &quot;X&quot; commands to try to produce as much information as possible about a code reference. They use Devel::Peek to try to find the glob in which this code reference lives (if it does) - this allows us to actually code references which correspond to named subroutines (including those aliased via glob assignment).<div class="subsection">
<h2>&quot;CvGV_name()&quot;</h2> Wrapper for &quot;CvGV_name_or_bust&quot;; tries to get the name of a reference via that routine. If this fails, return the reference again (when the reference is stringified, it'll come out as &quot;SOMETHING(0x...)&quot;).</div>
<div class="subsection">
<h2>&quot;CvGV_name_or_bust&quot; <i>coderef</i></h2> Calls Devel::Peek to try to find the glob the ref lives in; returns &quot;undef&quot; if Devel::Peek can't be loaded, or if &quot;Devel::Peek::CvGV&quot; can't find a glob for this ref.<div class="spacer">
</div>
Returns &quot;<i>package</i>::<i>glob name</i>&quot; if the code ref is found in a glob.</div>
<div class="subsection">
<h2>&quot;find_sub&quot;</h2> A utility routine used in various places; finds the file where a subroutine was defined, and returns that filename and a line-number range.<div class="spacer">
</div>
Tries to use @sub first; if it can't find it there, it tries building a reference to the subroutine and uses &quot;CvGV_name_or_bust&quot; to locate it, loading it into @sub as a side effect (XXX I think). If it can't find it this way, it brute-force searches %sub, checking for identical references.</div>
<div class="subsection">
<h2>&quot;methods&quot;</h2> A subroutine that uses the utility function &quot;methods_via&quot; to find all the methods in the class corresponding to the current reference and in &quot;UNIVERSAL&quot;.</div>
<div class="subsection">
<h2>&quot;methods_via($class, $prefix, $crawl_upward)&quot;</h2> &quot;methods_via&quot; does the work of crawling up the @ISA tree and reporting all the parent class methods. $class is the name of the next class to try; $prefix is the message prefix, which gets built up as we go up the @ISA tree to show parentage; $crawl_upward is 1 if we should try to go higher in the @ISA tree, 0 if we should stop.</div>
<div class="subsection">
<h2>&quot;setman&quot; - figure out which command to use to show documentation</h2> Just checks the contents of $^O and sets the $doccmd global accordingly.</div>
<div class="subsection">
<h2>&quot;runman&quot; - run the appropriate command to show documentation</h2> Accepts a man page name; runs the appropriate command to display it (set up during debugger initialization). Uses &quot;_db_system()&quot; to avoid mucking up the program's STDIN and STDOUT.</div>
</div>
<div class="section">
<h1>DEBUGGER INITIALIZATION - THE SECOND BEGIN BLOCK</h1> Because of the way the debugger interface to the Perl core is designed, any debugger package globals that &quot;DB::sub()&quot; requires have to be defined before any subroutines can be called. These are defined in the second &quot;BEGIN&quot; block.<div class="spacer">
</div>
This block sets things up so that (basically) the world is sane before the debugger starts executing. We set up various variables that the debugger has to have set up before the Perl core starts running:<dl>
<dt>
&#8226;</dt>
<dd>
The debugger's own filehandles (copies of STD and STDOUT for now).</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Characters for shell escapes, the recall command, and the history command.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
The maximum recursion depth.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
The size of a &quot;w&quot; command's window.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
The before-this-line context to be printed in a &quot;v&quot; (view a window around this line) command.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
The fact that we're not in a sub at all right now.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
The default SIGINT handler for the debugger.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
The appropriate value of the flag in $^D that says the debugger is running</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
The current debugger recursion level</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
The list of postponed items and the $single stack (XXX define this)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
That we want no return values and no subroutine entry/exit trace.</dd>
</dl>
</div>
<div class="section">
<h1>READLINE SUPPORT - COMPLETION FUNCTION</h1><div class="subsection">
<h2>db_complete</h2> &quot;readline&quot; support - adds command completion to basic &quot;readline&quot;.<div class="spacer">
</div>
Returns a list of possible completions to &quot;readline&quot; when invoked. &quot;readline&quot; will print the longest common substring following the text already entered.<div class="spacer">
</div>
If there is only a single possible completion, &quot;readline&quot; will use it in full.<div class="spacer">
</div>
This code uses &quot;map&quot; and &quot;grep&quot; heavily to create lists of possible completion. Think LISP in this section.<div class="spacer">
</div>
<i></i><i>&quot;b postpone|compile&quot;</i><i></i><dl>
<dt>
&#8226;</dt>
<dd>
Find all the subroutines that might match in this package</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Add &quot;postpone&quot;, &quot;load&quot;, and &quot;compile&quot; as possibles (we may be completing the keyword itself)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Include all the rest of the subs that are known</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;grep&quot; out the ones that match the text we have so far</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Return this as the list of possible completions</dd>
</dl>
<div class="spacer">
</div>
<i></i><i>&quot;b load&quot;</i><i></i><div class="spacer">
</div>
Get all the possible files from @INC as it currently stands and select the ones that match the text so far.<div class="spacer">
</div>
<i></i><i>&quot;V&quot;</i><i> (list variable) and </i><i>&quot;m&quot;</i><i> (list modules)</i><div class="spacer">
</div>
There are two entry points for these commands:<div class="spacer">
</div>
Unqualified package names<div class="spacer">
</div>
Get the top-level packages and grab everything that matches the text so far. For each match, recursively complete the partial packages to get all possible matching packages. Return this sorted list.<div class="spacer">
</div>
Qualified package names<div class="spacer">
</div>
Take a partially-qualified package and find all subpackages for it by getting all the subpackages for the package so far, matching all the subpackages against the text, and discarding all of them which start with 'main::'. Return this list.<div class="spacer">
</div>
<i></i><i>&quot;f&quot;</i><i> - switch files</i><div class="spacer">
</div>
Here, we want to get a fully-qualified filename for the &quot;f&quot; command. Possibilities are:<dl>
<dt>
1. The original source file itself</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
2. A file from @INC</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
3. An &quot;eval&quot; (the debugger gets a &quot;(eval N)&quot; fake file for each &quot;eval&quot;).</dt>
<dd>
</dd>
</dl>
<div class="spacer">
</div>
Under the debugger, source files are represented as &quot;_&lt;/fullpath/to/file&quot; (&quot;eval&quot;s are &quot;_&lt;(eval NNN)&quot;) keys in %main::. We pull all of these out of %main::, add the initial source file, and extract the ones that match the completion text so far.<div class="spacer">
</div>
<i>Subroutine name completion</i><div class="spacer">
</div>
We look through all of the defined subs (the keys of %sub) and return both all the possible matches to the subroutine name plus all the matches qualified to the current package.<div class="spacer">
</div>
<i>Scalar, array, and hash completion: partially qualified package</i><div class="spacer">
</div>
Much like the above, except we have to do a little more cleanup:<dl>
<dt>
&#8226;</dt>
<dd>
Determine the package that the symbol is in. Put it in &quot;::&quot; (effectively &quot;main::&quot;) if no package is specified.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Figure out the prefix vs. what needs completing.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Look through all the symbols in the package. &quot;grep&quot; out all the possible hashes/arrays/scalars, and then &quot;grep&quot; the possible matches out of those. &quot;map&quot; the prefix onto all the possibilities.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
If there's only one hit, and it's a package qualifier, and it's not equal to the initial text, re-complete it using the symbol we actually found.</dd>
</dl>
<div class="spacer">
</div>
<i>Symbol completion: current package or package </i><i>&quot;main&quot;</i><i>.</i><dl>
<dt>
&#8226;</dt>
<dd>
If it's &quot;main&quot;, delete main to just get &quot;::&quot; leading.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
We set the prefix to the item's sigil, and trim off the sigil to get the text to be completed.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
We look for the lexical scope above DB::DB and auto-complete lexical variables if PadWalker could be loaded.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
If the package is &quot;::&quot; (&quot;main&quot;), create an empty list; if it's something else, create a list of all the packages known.  Append whichever list to a list of all the possible symbols in the current package. &quot;grep&quot; out the matches to the text entered so far, then &quot;map&quot; the prefix back onto the symbols.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
If there's only one hit, it's a package qualifier, and it's not equal to the initial text, recomplete using this symbol.</dd>
</dl>
<div class="spacer">
</div>
<i>Options</i><div class="spacer">
</div>
We use &quot;option_val()&quot; to look up the current value of the option. If there's only a single value, we complete the command in such a way that it is a complete command for setting the option in question. If there are multiple possible values, we generate a command consisting of the option plus a trailing question mark, which, if executed, will list the current value of the option.<div class="spacer">
</div>
<i>Filename completion</i><div class="spacer">
</div>
For entering filenames. We simply call &quot;readline&quot;'s &quot;filename_list()&quot; method with the completion text to get the possible completions.</div>
</div>
<div class="section">
<h1>MISCELLANEOUS SUPPORT FUNCTIONS</h1> Functions that possibly ought to be somewhere else.<div class="subsection">
<h2>end_report</h2> Say we're done.</div>
<div class="subsection">
<h2>clean_ENV</h2> If we have $ini_pids, save it in the environment; else remove it from the environment. Used by the &quot;R&quot; (restart) command.<dl>
<dt>
rerun</dt>
<dd>
Rerun the current session to:<div style="height: 1.00em;">
&#160;</div>
<br/>
    rerun        current position<br/>
<br/>
    rerun 4      command number 4<br/>
<br/>
    rerun -4     current command minus 4 (go back 4 steps)<br/>
<div style="height: 1.00em;">
&#160;</div>
Whether this always makes sense, in the current context is unknowable, and is in part left as a useful exercise for the reader.  This sub returns the appropriate arguments to rerun the current session.</dd>
</dl>
<dl>
<dt>
restart</dt>
<dd>
Restarting the debugger is a complex operation that occurs in several phases. First, we try to reconstruct the command line that was used to invoke Perl and the debugger.<div style="height: 1.00em;">
&#160;</div>
After the command line  has been reconstructed, the next step is to save the debugger's status in environment variables. The &quot;DB::set_list&quot; routine is used to save aggregate variables (both hashes and arrays); scalars are just popped into environment variables directly.<div style="height: 1.00em;">
&#160;</div>
The most complex part of this is the saving of all of the breakpoints. They can live in an awful lot of places, and we have to go through all of them, find the breakpoints, and then save them in the appropriate environment variable via &quot;DB::set_list&quot;.<div style="height: 1.00em;">
&#160;</div>
After all the debugger status has been saved, we take the command we built up and then return it, so we can &quot;exec()&quot; it. The debugger will spot the &quot;PERLDB_RESTART&quot; environment variable and realize it needs to reload its state from the environment.</dd>
</dl>
</div>
</div>
<div class="section">
<h1>END PROCESSING - THE &quot;END&quot; BLOCK</h1> Come here at the very end of processing. We want to go into a loop where we allow the user to enter commands and interact with the debugger, but we don't want anything else to execute.<div class="spacer">
</div>
First we set the $finished variable, so that some commands that shouldn't be run after the end of program quit working.<div class="spacer">
</div>
We then figure out whether we're truly done (as in the user entered a &quot;q&quot; command, or we finished execution while running nonstop). If we aren't, we set $single to 1 (causing the debugger to get control again).<div class="spacer">
</div>
We then call &quot;DB::fake::at_exit()&quot;, which returns the &quot;Use 'q' to quit ...&quot; message and returns control to the debugger. Repeat.<div class="spacer">
</div>
When the user finally enters a &quot;q&quot; command, $fall_off_end is set to 1 and the &quot;END&quot; block simply exits with $single set to 0 (don't break, run to completion.).</div>
<div class="section">
<h1>PRE-5.8 COMMANDS</h1> Some of the commands changed function quite a bit in the 5.8 command realignment, so much so that the old code had to be replaced completely. Because we wanted to retain the option of being able to go back to the former command set, we moved the old code off to this section.<div class="spacer">
</div>
There's an awful lot of duplicated code here. We've duplicated the comments to keep things clear.<div class="subsection">
<h2>Null command</h2> Does nothing. Used to  <i>turn off</i> commands.</div>
<div class="subsection">
<h2>Old &quot;a&quot; command.</h2> This version added actions if you supplied them, and deleted them if you didn't.</div>
<div class="subsection">
<h2>Old &quot;b&quot; command</h2> Add breakpoints.</div>
<div class="subsection">
<h2>Old &quot;D&quot; command.</h2> Delete all breakpoints unconditionally.</div>
<div class="subsection">
<h2>Old &quot;h&quot; command</h2> Print help. Defaults to printing the long-form help; the 5.8 version prints the summary by default.</div>
<div class="subsection">
<h2>Old &quot;W&quot; command</h2> &quot;W &lt;expr&gt;&quot; adds a watch expression, &quot;W&quot; deletes them all.</div>
</div>
<div class="section">
<h1>PRE-AND-POST-PROMPT COMMANDS AND ACTIONS</h1> The debugger used to have a bunch of nearly-identical code to handle the pre-and-post-prompt action commands. &quot;cmd_pre590_prepost&quot; and &quot;cmd_prepost&quot; unify all this into one set of code to handle the appropriate actions.<div class="subsection">
<h2>&quot;cmd_pre590_prepost&quot;</h2> A small wrapper around &quot;cmd_prepost&quot;; it makes sure that the default doesn't do something destructive. In pre 5.8 debuggers, the default action was to delete all the actions.</div>
<div class="subsection">
<h2>&quot;cmd_prepost&quot;</h2> Actually does all the handling for &quot;&lt;&quot;, &quot;&gt;&quot;, &quot;{{&quot;, &quot;{&quot;, etc. Since the lists of actions are all held in arrays that are pointed to by references anyway, all we have to do is pick the right array reference and then use generic code to all, delete, or list actions.</div>
</div>
<div class="section">
<h1>&quot;DB::fake&quot;</h1> Contains the &quot;at_exit&quot; routine that the debugger uses to issue the &quot;Debugged program terminated ...&quot; message after the program completes. See the &quot;END&quot; block documentation for more details.</div>
<table class="foot">
<tr>
<td class="foot-date">
2014-11-17</td>
<td class="foot-os">
perl v5.20.2</td>
</tr>
</table>
</div>
</body>
</html>

