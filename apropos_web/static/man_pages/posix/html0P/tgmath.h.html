<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
&lt;tgmath.h&gt;(0P)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
&lt;tgmath.h&gt;(0P)</td>
<td class="head-vol">
POSIX Programmer's Manual</td>
<td class="head-rtitle">
&lt;tgmath.h&gt;(0P)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> tgmath.h - type-generic macros</div>
<div class="section">
<h1>SYNOPSIS</h1>  <b>#include &lt;tgmath.h&gt;</b></div>
<div class="section">
<h1>DESCRIPTION</h1> The  <i>&lt;tgmath.h&gt;</i> header shall include the headers <i>&lt;math.h&gt;</i> and  <i>&lt;complex.h&gt;</i> and shall define several type-generic macros.<div class="spacer">
</div>
Of the functions contained within the <i>&lt;math.h&gt;</i> and <i>&lt;complex.h&gt;</i> headers without an  <i>f</i> ( <b>float</b>) or <i>l</i> ( <b>long</b>  <b>double</b>) suffix, several have one or more parameters whose corresponding real type is  <b>double</b>. For each such function, except  <i>modf</i>(), there shall be a corresponding type-generic macro. The parameters whose corresponding real type is  <b>double</b> in the function synopsis are generic parameters. Use of the macro invokes a function whose corresponding real type and type domain are determined by the arguments for the generic parameters.<div class="spacer">
</div>
Use of the macro invokes a function whose generic parameters have the corresponding real type determined as follows:<dl>
<dt>
 *</dt>
<dd>
First, if any argument for generic parameters has type <b>long double</b>, the type determined is  <b>long double</b>.</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
Otherwise, if any argument for generic parameters has type <b>double</b> or is of integer type, the type determined is  <b>double</b>.</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
Otherwise, the type determined is <b>float</b>.</dd>
</dl>
<div class="spacer">
</div>
For each unsuffixed function in the <i>&lt;math.h&gt;</i> header for which there is a function in the  <i>&lt;complex.h&gt;</i> header with the same name except for a  <i>c</i> prefix, the corresponding type-generic macro (for both functions) has the same name as the function in the  <i>&lt;math.h&gt;</i> header. The corresponding type-generic macro for  <i>fabs</i>() and <i>cabs</i>() is  <i>fabs</i>().<table class="tbl">
<col style="width: 14.00ex;"/>
<col style="width: 17.00ex;"/>
<col style="width: 18.00ex;"/>
<tbody>
<tr>
<td>
<b>&lt;math.h&gt;</b></td>
<td>
<b>&lt;complex.h&gt;</b></td>
<td>
<b>Type-Generic</b></td>
</tr>
<tr>
<td>
<b>Function</b></td>
<td>
<b>Function</b></td>
<td>
<b>Macro</b></td>
</tr>
<tr>
<td>
<i>acos</i>()</td>
<td>
<i>cacos</i>()</td>
<td>
<i>acos</i>()</td>
</tr>
<tr>
<td>
<i>asin</i>()</td>
<td>
<i>casin</i>()</td>
<td>
<i>asin</i>()</td>
</tr>
<tr>
<td>
<i>atan</i>()</td>
<td>
<i>catan</i>()</td>
<td>
<i>atan</i>()</td>
</tr>
<tr>
<td>
<i>acosh</i>()</td>
<td>
<i>cacosh</i>()</td>
<td>
<i>acosh</i>()</td>
</tr>
<tr>
<td>
<i>asinh</i>()</td>
<td>
<i>casinh</i>()</td>
<td>
<i>asinh</i>()</td>
</tr>
<tr>
<td>
<i>atanh</i>()</td>
<td>
<i>catanh</i>()</td>
<td>
<i>atanh</i>()</td>
</tr>
<tr>
<td>
<i>cos</i>()</td>
<td>
<i>ccos</i>()</td>
<td>
<i>cos</i>()</td>
</tr>
<tr>
<td>
<i>sin</i>()</td>
<td>
<i>csin</i>()</td>
<td>
<i>sin</i>()</td>
</tr>
<tr>
<td>
<i>tan</i>()</td>
<td>
<i>ctan</i>()</td>
<td>
<i>tan</i>()</td>
</tr>
<tr>
<td>
<i>cosh</i>()</td>
<td>
<i>ccosh</i>()</td>
<td>
<i>cosh</i>()</td>
</tr>
<tr>
<td>
<i>sinh</i>()</td>
<td>
<i>csinh</i>()</td>
<td>
<i>sinh</i>()</td>
</tr>
<tr>
<td>
<i>tanh</i>()</td>
<td>
<i>ctanh</i>()</td>
<td>
<i>tanh</i>()</td>
</tr>
<tr>
<td>
<i>exp</i>()</td>
<td>
<i>cexp</i>()</td>
<td>
<i>exp</i>()</td>
</tr>
<tr>
<td>
<i>log</i>()</td>
<td>
<i>clog</i>()</td>
<td>
<i>log</i>()</td>
</tr>
<tr>
<td>
<i>pow</i>()</td>
<td>
<i>cpow</i>()</td>
<td>
<i>pow</i>()</td>
</tr>
<tr>
<td>
<i>sqrt</i>()</td>
<td>
<i>csqrt</i>()</td>
<td>
<i>sqrt</i>()</td>
</tr>
<tr>
<td>
<i>fabs</i>()</td>
<td>
<i>cabs</i>()</td>
<td>
<i>fabs</i>()</td>
</tr>
</tbody>
</table>
<div class="spacer">
</div>
If at least one argument for a generic parameter is complex, then use of the macro invokes a complex function; otherwise, use of the macro invokes a real function.<div class="spacer">
</div>
For each unsuffixed function in the <i>&lt;math.h&gt;</i> header without a  <i>c</i>-prefixed counterpart in the <i>&lt;complex.h&gt;</i> header, the corresponding type-generic macro has the same name as the function. These type-generic macros are:<table class="tbl">
<col style="width: 149.00ex;"/>
<col style="width: 150.00ex;"/>
<col style="width: 167.00ex;"/>
<col style="width: 131.00ex;"/>
<tbody>
<tr>
<td>
 <i>atan2</i>()  <i>cbrt</i>()  <i>ceil</i>()  <i>copysign</i>()  <i>erf</i>()  <i>erfc</i>()  <i>exp2</i>()  <i>expm1</i>()  <i>fdim</i>()  <i>floor</i>()  &#160;</td>
<td>
 <i>fma</i>()  <i>fmax</i>()  <i>fmin</i>()  <i>fmod</i>()  <i>frexp</i>()  <i>hypot</i>()  <i>ilogb</i>()  <i>ldexp</i>()  <i>lgamma</i>()  <i>llrint</i>()  &#160;</td>
<td>
 <i>llround</i>()  <i>log10</i>()  <i>log1p</i>()  <i>log2</i>()  <i>logb</i>()  <i>lrint</i>()  <i>lround</i>()  <i>nearbyint</i>()  <i>nextafter</i>()  <i>nexttoward</i>()  &#160;</td>
<td>
 <i>remainder</i>()  <i>remquo</i>()  <i>rint</i>()  <i>round</i>()  <i>scalbn</i>()  <i>scalbln</i>()  <i>tgamma</i>()  <i>trunc</i>()  &#160;</td>
</tr>
</tbody>
</table>
<div class="spacer">
</div>
If all arguments for generic parameters are real, then use of the macro invokes a real function; otherwise, use of the macro results in undefined behavior.<div class="spacer">
</div>
For each unsuffixed function in the <i>&lt;complex.h&gt;</i> header that is not a  <i>c</i>-prefixed counterpart to a function in the <i>&lt;math.h&gt;</i> header, the corresponding type-generic macro has the same name as the function. These type-generic macros are:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<i>carg</i>()<br/>
<i>cimag</i>()<br/>
<i>conj</i>()<br/>
<i>cproj</i>()<br/>
<i>creal</i>()<br/>
</div>
<div class="spacer">
</div>
Use of the macro with any real or complex argument invokes a complex function.<div class="spacer">
</div>
<i>The following sections are informative.</i></div>
<div class="section">
<h1>APPLICATION USAGE</h1> With the declarations:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>#include &lt;tgmath.h&gt;</b><br/>
<b>int n;</b><br/>
<b>float f;</b><br/>
<b>double d;</b><br/>
<b>long double ld;</b><br/>
<b>float complex fc;</b><br/>
<b>double complex dc;</b><br/>
<b>long double complex ldc;</b><br/>
<b></b><br/>
</div>
<div class="spacer">
</div>
functions invoked by use of type-generic macros are shown in the following table:<table class="tbl">
<col style="width: 28.00ex;"/>
<col style="width: 41.00ex;"/>
<tbody>
<tr>
<td>
<b>Macro</b></td>
<td>
<b>Use Invokes</b></td>
</tr>
<tr>
<td>
<i>exp</i>(<i>n</i>)</td>
<td>
<i>exp</i>(<i>n</i>), the function</td>
</tr>
<tr>
<td>
<i>acosh</i>(<i>f</i>)</td>
<td>
<i>acoshf</i>(<i>f</i>)</td>
</tr>
<tr>
<td>
<i>sin</i>(<i>d</i>)</td>
<td>
<i>sin</i>(<i>d</i>), the function</td>
</tr>
<tr>
<td>
<i>atan</i>(<i>ld</i>)</td>
<td>
<i>atanl</i>(<i>ld</i>)</td>
</tr>
<tr>
<td>
<i>log</i>(<i>fc</i>)</td>
<td>
<i>clogf</i>(<i>fc</i>)</td>
</tr>
<tr>
<td>
<i>sqrt</i>(<i>dc</i>)</td>
<td>
<i>csqrt</i>(<i>dc</i>)</td>
</tr>
<tr>
<td>
<i>pow</i>(<i>ldc,f</i>)</td>
<td>
<i>cpowl</i>(<i>ldc, f</i>)</td>
</tr>
<tr>
<td>
<i>remainder</i>(<i>n,n</i>)</td>
<td>
<i>remainder</i>(<i>n, n</i>), the function</td>
</tr>
<tr>
<td>
<i>nextafter</i>(<i>d,f</i>)</td>
<td>
<i>nextafter</i>(<i>d, f</i>), the function</td>
</tr>
<tr>
<td>
<i>nexttoward</i>(<i>f,ld</i>)</td>
<td>
<i>nexttowardf</i>(<i>f, ld</i>)</td>
</tr>
<tr>
<td>
<i>copysign</i>(<i>n,ld</i>)</td>
<td>
<i>copysignl</i>(<i>n, ld</i>)</td>
</tr>
<tr>
<td>
<i>ceil</i>(<i>fc</i>)</td>
<td>
Undefined behavior</td>
</tr>
<tr>
<td>
<i>rint</i>(<i>dc</i>)</td>
<td>
Undefined behavior</td>
</tr>
<tr>
<td>
<i>fmax</i>(<i>ldc,ld</i>)</td>
<td>
Undefined behavior</td>
</tr>
<tr>
<td>
<i>carg</i>(<i>n</i>)</td>
<td>
<i>carg</i>(<i>n</i>), the function</td>
</tr>
<tr>
<td>
<i>cproj</i>(<i>f</i>)</td>
<td>
<i>cprojf</i>(<i>f</i>)</td>
</tr>
<tr>
<td>
<i>creal</i>(<i>d</i>)</td>
<td>
<i>creal</i>(<i>d</i>), the function</td>
</tr>
<tr>
<td>
<i>cimag</i>(<i>ld</i>)</td>
<td>
<i>cimagl</i>(<i>ld</i>)</td>
</tr>
<tr>
<td>
<i>cabs</i>(<i>fc</i>)</td>
<td>
<i>cabsf</i>(<i>fc</i>)</td>
</tr>
<tr>
<td>
<i>carg</i>(<i>dc</i>)</td>
<td>
<i>carg</i>(<i>dc</i>), the function</td>
</tr>
<tr>
<td>
<i>cproj</i>(<i>ldc</i>)</td>
<td>
<i>cprojl</i>(<i>ldc</i>)</td>
</tr>
</tbody>
</table>
</div>
<div class="section">
<h1>RATIONALE</h1> Type-generic macros allow calling a function whose type is determined by the argument type, as is the case for C operators such as  <b>'+'</b> and <b>'*'</b> . For example, with a type-generic <i>cos</i>() macro, the expression  <i>cos</i>(( <b>float</b>) <i>x</i>) will have type <b>float</b>. This feature enables writing more portably efficient code and alleviates need for awkward casting and suffixing in the process of porting or adjusting precision. Generic math functions are a widely appreciated feature of Fortran.<div class="spacer">
</div>
The only arguments that affect the type resolution are the arguments corresponding to the parameters that have type  <b>double</b> in the synopsis. Hence the type of a type-generic call to  <i>nexttoward</i>(), whose second parameter is <b>long double</b> in the synopsis, is determined solely by the type of the first argument.<div class="spacer">
</div>
The term &quot;type-generic&quot; was chosen over the proposed alternatives of intrinsic and overloading. The term is more specific than intrinsic, which already is widely used with a more general meaning, and reflects a closer match to Fortran's generic functions than to C++ overloading.<div class="spacer">
</div>
The macros are placed in their own header in order not to silently break old programs that include the  <i>&lt;math.h&gt;</i> header; for example, with:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>printf (&quot;%e&quot;, sin(x))</b><br/>
<b></b><br/>
</div>
<div class="spacer">
</div>
<i>modf</i>( <b>double</b>, <b>double *</b>) is excluded because no way was seen to make it safe without complicating the type resolution.<div class="spacer">
</div>
The implementation might, as an extension, endow appropriate ones of the macros that IEEE&#160;Std&#160;1003.1-2001 specifies only for real arguments with the ability to invoke the complex functions.<div class="spacer">
</div>
IEEE&#160;Std&#160;1003.1-2001 does not prescribe any particular implementation mechanism for generic macros. It could be implemented simply with built-in macros. The generic macro for  <i>sqrt</i>(), for example, could be implemented with:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>#undef sqrt</b><br/>
<b>#define sqrt(x) __BUILTIN_GENERIC_sqrt(x)</b><br/>
<b></b><br/>
</div>
<div class="spacer">
</div>
Generic macros are designed for a useful level of consistency with C++ overloaded math functions.<div class="spacer">
</div>
The great majority of existing C programs are expected to be unaffected when the  <i>&lt;tgmath.h&gt;</i> header is included instead of the  <i>&lt;math.h&gt;</i> or <i>&lt;complex.h&gt;</i> headers. Generic macros are similar to the ISO/IEC&#160;9899:1999 standard library masking macros, though the semantic types of return values differ.<div class="spacer">
</div>
The ability to overload on integer as well as floating types would have been useful for some functions; for example,  <i>copysign</i>(). Overloading with different numbers of arguments would have allowed reusing names; for example,  <i>remainder</i>() for <i>remquo</i>(). However, these facilities would have complicated the specification; and their natural consistent use, such as for a floating  <i>abs</i>() or a two-argument  <i>atan</i>(), would have introduced further inconsistencies with the ISO/IEC&#160;9899:1999 standard for insufficient benefit.<div class="spacer">
</div>
The ISO&#160;C standard in no way limits the implementation's options for efficiency, including inlining library functions.</div>
<div class="section">
<h1>FUTURE DIRECTIONS</h1> None.</div>
<div class="section">
<h1>SEE ALSO</h1>  <i>&lt;math.h&gt;</i>, <i>&lt;complex.h&gt;</i>, the System Interfaces volume of IEEE&#160;Std&#160;1003.1-2001,  <i>cabs</i>(), <i>fabs</i>(), <i>modf</i>()</div>
<div class="section">
<h1>COPYRIGHT</h1> Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1, 2003 Edition, Standard for Information Technology -- Portable Operating System Interface (POSIX), The Open Group Base Specifications Issue 6, Copyright (C) 2001-2003 by the Institute of Electrical and Electronics Engineers, Inc and The Open Group. In the event of any discrepancy between this version and the original IEEE and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document. The original Standard can be obtained online at http://www.opengroup.org/unix/online.html .</div>
<table class="foot">
<tr>
<td class="foot-date">
2003</td>
<td class="foot-os">
IEEE/The Open Group</td>
</tr>
</table>
</div>
</body>
</html>

