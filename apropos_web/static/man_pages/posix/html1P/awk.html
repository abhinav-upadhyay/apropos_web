<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
AWK(1P)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
AWK(1P)</td>
<td class="head-vol">
POSIX Programmer's Manual</td>
<td class="head-rtitle">
AWK(1P)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>PROLOG</h1> This manual page is part of the POSIX Programmer's Manual. The Linux implementation of this interface may differ (consult the corresponding Linux manual page for details of Linux behavior), or the interface may not be implemented on Linux.</div>
<div class="section">
<h1>NAME</h1> awk - pattern scanning and processing language</div>
<div class="section">
<h1>SYNOPSIS</h1>  <b>awk</b> <b>[</b><b>-F</b> <i>ERE</i><b>][</b><b>-v</b> <i>assignment</i><b>]</b>  <b>...</b> <i>program</i>  <b>[</b><i>argument</i> <b>...</b><b>]</b><b></b><div style="height: 0.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
awk<b> </b><b>[</b><b></b><b>-F</b><b> </b><i>ERE</i><b></b><b>]</b><b> </b><b>-f</b><b> </b><i>progfile</i><b> </b><b>...</b><b></b>  <b></b><b>[</b><b></b><b>-v</b><b></b>  <b></b><i>assignment</i><b></b><b>]</b><b> </b><b>...</b><b></b><b>[</b><b></b><i>argument</i><b> </b><b>...</b><b></b><b>]</b><b></b><b></b><div style="height: 0.00em;">
&#160;</div>
<b></b></div>
<div class="section">
<h1>DESCRIPTION</h1> The  <i>awk</i> utility shall execute programs written in the <i>awk</i> programming language, which is specialized for textual data manipulation. An  <i>awk</i> program is a sequence of patterns and corresponding actions. When input is read that matches a pattern, the action associated with that pattern is carried out.<div class="spacer">
</div>
Input shall be interpreted as a sequence of records. By default, a record is a line, less its terminating &lt;newline&gt;, but this can be changed by using the  <b>RS</b> built-in variable. Each record of input shall be matched in turn against each pattern in the program. For each pattern matched, the associated action shall be executed.<div class="spacer">
</div>
The <i>awk</i> utility shall interpret each input record as a sequence of fields where, by default, a field is a string of non- &lt;blank&gt;s. This default white-space field delimiter can be changed by using the  <b>FS</b> built-in variable or <b>-F</b>  <i>ERE</i>. The <i>awk</i> utility shall denote the first field in a record $1, the second $2, and so on. The symbol $0 shall refer to the entire record; setting any other field causes the re-evaluation of $0. Assigning to $0 shall reset the values of all other fields and the  <b>NF</b> built-in variable.</div>
<div class="section">
<h1>OPTIONS</h1> The  <i>awk</i> utility shall conform to the Base Definitions volume of IEEE&#160;Std&#160;1003.1-2001, Section 12.2, Utility Syntax Guidelines.<div class="spacer">
</div>
The following options shall be supported:<dl>
<dt>
<b>-F&#160;</b> <i>ERE</i></dt>
<dd>
Define the input field separator to be the extended regular expression  <i>ERE</i>, before any input is read; see Regular Expressions .</dd>
</dl>
<dl>
<dt>
<b>-f&#160;</b> <i>progfile</i></dt>
<dd>
Specify the pathname of the file <i>progfile</i> containing an <i>awk</i> program. If multiple instances of this option are specified, the concatenation of the files specified as  <i>progfile</i> in the order specified shall be the  <i>awk</i> program. The  <i>awk</i> program can alternatively be specified in the command line as a single argument.</dd>
</dl>
<dl>
<dt>
<b>-v&#160;</b> <i>assignment</i></dt>
<dd>
The application shall ensure that the <i>assignment</i> argument is in the same form as an  <i>assignment</i> operand. The specified variable assignment shall occur prior to executing the  <i>awk</i> program, including the actions associated with  <b>BEGIN</b> patterns (if any). Multiple occurrences of this option can be specified.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
</div>
<div class="section">
<h1>OPERANDS</h1> The following operands shall be supported:<dl>
<dt>
<i>program</i></dt>
<dd>
If no <b>-f</b> option is specified, the first operand to <i>awk</i> shall be the text of the  <i>awk</i> program. The application shall supply the  <i>program</i> operand as a single argument to  <i>awk</i>. If the text does not end in a &lt;newline&gt;,  <i>awk</i> shall interpret the text as if it did.</dd>
</dl>
<dl>
<dt>
<i>argument</i></dt>
<dd>
Either of the following two types of <i>argument</i> can be intermixed:</dd>
</dl>
<dl>
<dt>
<i>file</i></dt>
<dd>
</dd>
</dl>
<div style="margin-left: 5.00ex;">
A pathname of a file that contains the input to be read, which is matched against the set of patterns in the program. If no  <i>file</i> operands are specified, or if a <i>file</i> operand is <b>'-'</b>, the standard input shall be used.</div>
<dl>
<dt>
<i>assignment</i></dt>
<dd>
</dd>
</dl>
<div style="margin-left: 5.00ex;">
An operand that begins with an underscore or alphabetic character from the portable character set (see the table in the Base Definitions volume of IEEE&#160;Std&#160;1003.1-2001, Section 6.1, Portable Character Set), followed by a sequence of underscores, digits, and alphabetics from the portable character set, followed by the  <b>'='</b> character, shall specify a variable assignment rather than a pathname. The characters before the  <b>'='</b> represent the name of an  <i>awk</i> variable; if that name is an <i>awk</i> reserved word (see Grammar ) the behavior is undefined. The characters following the equal sign shall be interpreted as if they appeared in the  <i>awk</i> program preceded and followed by a double-quote (  <b>' )'</b> character, as a <b>STRING</b> token (see Grammar ), except that if the last character is an unescaped backslash, it shall be interpreted as a literal backslash rather than as the first character of the sequence  <b>&quot;\&quot;&quot;</b> . The variable shall be assigned the value of that  <b>STRING</b> token and, if appropriate, shall be considered a  <i>numeric string</i> (see Expressions in awk ), the variable shall also be assigned its numeric value. Each such variable assignment shall occur just prior to the processing of the following  <i>file</i>, if any. Thus, an assignment before the first  <i>file</i> argument shall be executed after the  <b>BEGIN</b> actions (if any), while an assignment after the last  <i>file</i> argument shall occur before the  <b>END</b> actions (if any). If there are no <i>file</i> arguments, assignments shall be executed before processing the standard input.</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>STDIN</h1> The standard input shall be used only if no  <i>file</i> operands are specified, or if a  <i>file</i> operand is <b>'-'</b> ; see the INPUT FILES section. If the  <i>awk</i> program contains no actions and no patterns, but is otherwise a valid  <i>awk</i> program, standard input and any  <i>file</i> operands shall not be read and  <i>awk</i> shall exit with a return status of zero.</div>
<div class="section">
<h1>INPUT FILES</h1> Input files to the  <i>awk</i> program from any of the following sources shall be text files:<dl>
<dt>
 *</dt>
<dd>
Any <i>file</i> operands or their equivalents, achieved by modifying the  <i>awk</i> variables <b>ARGV</b> and <b>ARGC</b></dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
Standard input in the absence of any <i>file</i> operands</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
Arguments to the <b>getline</b> function</dd>
</dl>
<div class="spacer">
</div>
Whether the variable <b>RS</b> is set to a value other than a &lt;newline&gt; or not, for these files, implementations shall support records terminated with the specified separator up to {LINE_MAX} bytes and may support longer records.<div class="spacer">
</div>
If <b>-f</b> <i>progfile</i> is specified, the application shall ensure that the files named by each of the  <i>progfile</i> option-arguments are text files and their concatenation, in the same order as they appear in the arguments, is an  <i>awk</i> program.</div>
<div class="section">
<h1>ENVIRONMENT VARIABLES</h1> The following environment variables shall affect the execution of  <i>awk</i>:<dl>
<dt>
<i>LANG</i></dt>
<dd>
Provide a default value for the internationalization variables that are unset or null. (See the Base Definitions volume of IEEE&#160;Std&#160;1003.1-2001, Section 8.2, Internationalization Variables for the precedence of internationalization variables used to determine the values of locale categories.)</dd>
</dl>
<dl>
<dt>
<i>LC_ALL</i></dt>
<dd>
If set to a non-empty string value, override the values of all the other internationalization variables.</dd>
</dl>
<dl>
<dt>
<i>LC_COLLATE</i></dt>
<dd>
Determine the locale for the behavior of ranges, equivalence classes, and multi-character collating elements within regular expressions and in comparisons of string values.</dd>
</dl>
<dl>
<dt>
<i>LC_CTYPE</i></dt>
<dd>
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as opposed to multi-byte characters in arguments and input files), the behavior of character classes within regular expressions, the identification of characters as letters, and the mapping of uppercase and lowercase characters for the  <b>toupper</b> and  <b>tolower</b> functions.</dd>
</dl>
<dl>
<dt>
<i>LC_MESSAGES</i></dt>
<dd>
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.</dd>
</dl>
<dl>
<dt>
<i>LC_NUMERIC</i></dt>
<dd>
Determine the radix character used when interpreting numeric input, performing conversions between numeric and string values, and formatting numeric output. Regardless of locale, the period character (the decimal-point character of the POSIX locale) is the decimal-point character recognized in processing  <i>awk</i> programs (including assignments in command line arguments).</dd>
</dl>
<dl>
<dt>
<i>NLSPATH</i></dt>
<dd>
Determine the location of message catalogs for the processing of <i>LC_MESSAGES</i>  <i>.</i></dd>
</dl>
<dl>
<dt>
<i>PATH</i></dt>
<dd>
Determine the search path when looking for commands executed by <i>system</i>(<i>expr</i>), or input and output pipes; see the Base Definitions volume of IEEE&#160;Std&#160;1003.1-2001, Chapter 8, Environment Variables.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<div class="spacer">
</div>
In addition, all environment variables shall be visible via the <i>awk</i> variable  <b>ENVIRON</b>.</div>
<div class="section">
<h1>ASYNCHRONOUS EVENTS</h1> Default.</div>
<div class="section">
<h1>STDOUT</h1> The nature of the output files depends on the  <i>awk</i> program.</div>
<div class="section">
<h1>STDERR</h1> The standard error shall be used only for diagnostic messages.</div>
<div class="section">
<h1>OUTPUT FILES</h1> The nature of the output files depends on the  <i>awk</i> program.</div>
<div class="section">
<h1>EXTENDED DESCRIPTION</h1><div class="subsection">
<h2>Overall Program Structure</h2> An  <i>awk</i> program is composed of pairs of the form:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<i>pattern</i> <b>{</b> <i>action</i> <b>}</b><br/>
<b></b><br/>
</div>
<div class="spacer">
</div>
Either the pattern or the action (including the enclosing brace characters) can be omitted.<div class="spacer">
</div>
A missing pattern shall match any record of input, and a missing action shall be equivalent to:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>{ print }</b><br/>
<b></b><br/>
</div>
<div class="spacer">
</div>
Execution of the <i>awk</i> program shall start by first executing the actions associated with all  <b>BEGIN</b> patterns in the order they occur in the program. Then each  <i>file</i> operand (or standard input if no files were specified) shall be processed in turn by reading data from the file until a record separator is seen ( &lt;newline&gt; by default). Before the first reference to a field in the record is evaluated, the record shall be split into fields, according to the rules in Regular Expressions, using the value of  <b>FS</b> that was current at the time the record was read. Each pattern in the program then shall be evaluated in the order of occurrence, and the action associated with each pattern that matches the current record executed. The action for a matching pattern shall be executed before evaluating subsequent patterns. Finally, the actions associated with all  <b>END</b> patterns shall be executed in the order they occur in the program.</div>
<div class="subsection">
<h2>Expressions in awk</h2> Expressions describe computations used in  <i>patterns</i> and <i>actions</i>. In the following table, valid expression operations are given in groups from highest precedence first to lowest precedence last, with equal-precedence operators grouped between horizontal lines. In expression evaluation, where the grammar is formally ambiguous, higher precedence operators shall be evaluated before lower precedence operators. In this table  <i>expr</i>,  <i>expr1</i>, <i>expr2</i>, and <i>expr3</i> represent any expression, while lvalue represents any entity that can be assigned to (that is, on the left side of an assignment operator). The precise syntax of expressions is given in Grammar .<div style="height: 1.00em;">
&#160;</div>
<b>Table: Expressions in Decreasing Precedence in </b><i>awk</i><b></b><i></i><table class="tbl">
<col style="width: 39.00ex;"/>
<col style="width: 25.00ex;"/>
<col style="width: 26.00ex;"/>
<col style="width: 19.00ex;"/>
<tbody>
<tr>
<td>
<i></i><b>Syntax</b><i></i></td>
<td>
<i></i><b>Name</b><i></i></td>
<td>
<i></i><b>Type of Result</b><i></i></td>
<td>
<i></i><b>Associativity</b><i></i></td>
</tr>
<tr>
<td>
<i>( </i><i>expr</i><i> )</i></td>
<td>
<i>Grouping</i></td>
<td>
<i>Type of </i><i>expr</i><i></i></td>
<td>
<i>N/A</i></td>
</tr>
<tr>
<td>
<i>$</i><i>expr</i><i></i></td>
<td>
<i>Field reference</i></td>
<td>
<i>String</i></td>
<td>
<i>N/A</i></td>
</tr>
<tr>
<td>
<i>++ lvalue</i></td>
<td>
<i>Pre-increment</i></td>
<td>
<i>Numeric</i></td>
<td>
<i>N/A</i></td>
</tr>
<tr>
<td>
<i>-- lvalue</i></td>
<td>
<i>Pre-decrement</i></td>
<td>
<i>Numeric</i></td>
<td>
<i>N/A</i></td>
</tr>
<tr>
<td>
<i>lvalue ++</i></td>
<td>
<i>Post-increment</i></td>
<td>
<i>Numeric</i></td>
<td>
<i>N/A</i></td>
</tr>
<tr>
<td>
<i>lvalue --</i></td>
<td>
<i>Post-decrement</i></td>
<td>
<i>Numeric</i></td>
<td>
<i>N/A</i></td>
</tr>
<tr>
<td>
<i></i><i>expr</i><i> ^ </i><i>expr</i><i></i></td>
<td>
<i>Exponentiation</i></td>
<td>
<i>Numeric</i></td>
<td>
<i>Right</i></td>
</tr>
<tr>
<td>
<i>! </i><i>expr</i><i></i></td>
<td>
<i>Logical not</i></td>
<td>
<i>Numeric</i></td>
<td>
<i>N/A</i></td>
</tr>
<tr>
<td>
<i>+ </i><i>expr</i><i></i></td>
<td>
<i>Unary plus</i></td>
<td>
<i>Numeric</i></td>
<td>
<i>N/A</i></td>
</tr>
<tr>
<td>
<i>- </i><i>expr</i><i></i></td>
<td>
<i>Unary minus</i></td>
<td>
<i>Numeric</i></td>
<td>
<i>N/A</i></td>
</tr>
<tr>
<td>
<i></i><i>expr</i><i> * </i><i>expr</i><i></i></td>
<td>
<i>Multiplication</i></td>
<td>
<i>Numeric</i></td>
<td>
<i>Left</i></td>
</tr>
<tr>
<td>
<i></i><i>expr</i><i> / </i><i>expr</i><i></i></td>
<td>
<i>Division</i></td>
<td>
<i>Numeric</i></td>
<td>
<i>Left</i></td>
</tr>
<tr>
<td>
<i></i><i>expr</i><i> % </i><i>expr</i><i></i></td>
<td>
<i>Modulus</i></td>
<td>
<i>Numeric</i></td>
<td>
<i>Left</i></td>
</tr>
<tr>
<td>
<i></i><i>expr</i><i> + </i><i>expr</i><i></i></td>
<td>
<i>Addition</i></td>
<td>
<i>Numeric</i></td>
<td>
<i>Left</i></td>
</tr>
<tr>
<td>
<i></i><i>expr</i><i> - </i><i>expr</i><i></i></td>
<td>
<i>Subtraction</i></td>
<td>
<i>Numeric</i></td>
<td>
<i>Left</i></td>
</tr>
<tr>
<td>
<i></i><i>expr</i><i> </i><i>expr</i><i></i></td>
<td>
<i>String concatenation</i></td>
<td>
<i>String</i></td>
<td>
<i>Left</i></td>
</tr>
<tr>
<td>
<i></i><i>expr</i><i> &lt; </i><i>expr</i><i></i></td>
<td>
<i>Less than</i></td>
<td>
<i>Numeric</i></td>
<td>
<i>None</i></td>
</tr>
<tr>
<td>
<i></i><i>expr</i><i> &lt;= </i><i>expr</i><i></i></td>
<td>
<i>Less than or equal to</i></td>
<td>
<i>Numeric</i></td>
<td>
<i>None</i></td>
</tr>
<tr>
<td>
<i></i><i>expr</i><i> != </i><i>expr</i><i></i></td>
<td>
<i>Not equal to</i></td>
<td>
<i>Numeric</i></td>
<td>
<i>None</i></td>
</tr>
<tr>
<td>
<i></i><i>expr</i><i> == </i><i>expr</i><i></i></td>
<td>
<i>Equal to</i></td>
<td>
<i>Numeric</i></td>
<td>
<i>None</i></td>
</tr>
<tr>
<td>
<i></i><i>expr</i><i> &gt; </i><i>expr</i><i></i></td>
<td>
<i>Greater than</i></td>
<td>
<i>Numeric</i></td>
<td>
<i>None</i></td>
</tr>
<tr>
<td>
<i></i><i>expr</i><i> &gt;= </i><i>expr</i><i></i></td>
<td>
<i>Greater than or equal to</i></td>
<td>
<i>Numeric</i></td>
<td>
<i>None</i></td>
</tr>
<tr>
<td>
<i></i><i>expr</i><i> ~ </i><i>expr</i><i></i></td>
<td>
<i>ERE match</i></td>
<td>
<i>Numeric</i></td>
<td>
<i>None</i></td>
</tr>
<tr>
<td>
<i></i><i>expr</i><i> !~ </i><i>expr</i><i></i></td>
<td>
<i>ERE non-match</i></td>
<td>
<i>Numeric</i></td>
<td>
<i>None</i></td>
</tr>
<tr>
<td>
<i></i><i>expr</i><i> in array</i></td>
<td>
<i>Array membership</i></td>
<td>
<i>Numeric</i></td>
<td>
<i>Left</i></td>
</tr>
<tr>
<td>
<i>( </i><i>index</i><i> ) in </i><i>array</i><i></i></td>
<td>
<i>Multi-dimension array</i></td>
<td>
<i>Numeric</i></td>
<td>
<i>Left</i></td>
</tr>
<tr>
<td>
<i>&#160;</i></td>
<td>
<i>membership</i></td>
<td>
<i>&#160;</i></td>
<td>
<i>&#160;</i></td>
</tr>
<tr>
<td>
<i></i><i>expr</i><i> &amp;&amp; </i><i>expr</i><i></i></td>
<td>
<i>Logical AND</i></td>
<td>
<i>Numeric</i></td>
<td>
<i>Left</i></td>
</tr>
<tr>
<td>
<i></i><i>expr</i><i> || </i><i>expr</i><i></i></td>
<td>
<i>Logical OR</i></td>
<td>
<i>Numeric</i></td>
<td>
<i>Left</i></td>
</tr>
<tr>
<td>
<i></i><i>expr1</i><i> ? </i><i>expr2</i><i> : </i><i>expr3</i><i></i></td>
<td>
<i>Conditional expression</i></td>
<td>
<i>Type of selected</i></td>
<td>
<i>Right</i></td>
</tr>
<tr>
<td>
<i>&#160;</i></td>
<td>
<i>&#160;</i></td>
<td>
<i></i><i>expr2</i><i> or </i><i>expr3</i><i></i></td>
<td>
<i>&#160;</i></td>
</tr>
<tr>
<td>
<i>lvalue ^= </i><i>expr</i><i></i></td>
<td>
<i>Exponentiation assignment</i></td>
<td>
<i>Numeric</i></td>
<td>
<i>Right</i></td>
</tr>
<tr>
<td>
<i>lvalue %= </i><i>expr</i><i></i></td>
<td>
<i>Modulus assignment</i></td>
<td>
<i>Numeric</i></td>
<td>
<i>Right</i></td>
</tr>
<tr>
<td>
<i>lvalue *= </i><i>expr</i><i></i></td>
<td>
<i>Multiplication assignment</i></td>
<td>
<i>Numeric</i></td>
<td>
<i>Right</i></td>
</tr>
<tr>
<td>
<i>lvalue /= </i><i>expr</i><i></i></td>
<td>
<i>Division assignment</i></td>
<td>
<i>Numeric</i></td>
<td>
<i>Right</i></td>
</tr>
<tr>
<td>
<i>lvalue += </i><i>expr</i><i></i></td>
<td>
<i>Addition assignment</i></td>
<td>
<i>Numeric</i></td>
<td>
<i>Right</i></td>
</tr>
<tr>
<td>
<i>lvalue -= </i><i>expr</i><i></i></td>
<td>
<i>Subtraction assignment</i></td>
<td>
<i>Numeric</i></td>
<td>
<i>Right</i></td>
</tr>
<tr>
<td>
<i>lvalue = </i><i>expr</i><i></i></td>
<td>
<i>Assignment</i></td>
<td>
<i>Type of </i><i>expr</i><i></i></td>
<td>
<i>Right</i></td>
</tr>
</tbody>
</table>
<div class="spacer">
</div>
Each expression shall have either a string value, a numeric value, or both. Except as stated for specific contexts, the value of an expression shall be implicitly converted to the type needed for the context in which it is used. A string value shall be converted to a numeric value by the equivalent of the following calls to functions defined by the ISO&#160;C standard:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>setlocale(LC_NUMERIC, &quot;&quot;);</b><br/>
<b></b><i>numeric_value</i> <b>= atof(</b><i>string_value</i><b>);</b><br/>
<b></b><br/>
</div>
<div class="spacer">
</div>
A numeric value that is exactly equal to the value of an integer (see  <i>Concepts Derived</i>  <i>from the ISO C Standard</i> ) shall be converted to a string by the equivalent of a call to the  <b>sprintf</b> function (see String Functions ) with the string  <b>&quot;%d&quot;</b> as the <i>fmt</i> argument and the numeric value being converted as the first and only  <i>expr</i> argument. Any other numeric value shall be converted to a string by the equivalent of a call to the  <b>sprintf</b> function with the value of the variable  <b>CONVFMT</b> as the <i>fmt</i> argument and the numeric value being converted as the first and only  <i>expr</i> argument. The result of the conversion is unspecified if the value of  <b>CONVFMT</b> is not a floating-point format specification. This volume of IEEE&#160;Std&#160;1003.1-2001 specifies no explicit conversions between numbers and strings. An application can force an expression to be treated as a number by adding zero to it, or can force it to be treated as a string by concatenating the null string (  <b>&quot;&quot;</b> ) to it.<div class="spacer">
</div>
A string value shall be considered a <i>numeric string</i> if it comes from one of the following:<dl>
<dt>
 1.</dt>
<dd>
Field variables</dd>
</dl>
<dl>
<dt>
 2.</dt>
<dd>
Input from the <i>getline</i>() function</dd>
</dl>
<dl>
<dt>
 3.</dt>
<dd>
<b>FILENAME</b></dd>
</dl>
<dl>
<dt>
 4.</dt>
<dd>
<b>ARGV</b> array elements</dd>
</dl>
<dl>
<dt>
 5.</dt>
<dd>
<b>ENVIRON</b> array elements</dd>
</dl>
<dl>
<dt>
 6.</dt>
<dd>
Array elements created by the <i>split</i>() function</dd>
</dl>
<dl>
<dt>
 7.</dt>
<dd>
A command line variable assignment</dd>
</dl>
<dl>
<dt>
 8.</dt>
<dd>
Variable assignment from another numeric string variable</dd>
</dl>
<div class="spacer">
</div>
and after all the following conversions have been applied, the resulting string would lexically be recognized as a  <b>NUMBER</b> token as described by the lexical conventions in Grammar :<dl>
<dt>
 *</dt>
<dd>
All leading and trailing &lt;blank&gt;s are discarded.</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
If the first non- &lt;blank&gt; is <b>'+'</b> or <b>'-'</b>, it is discarded.</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
Changing each occurrence of the decimal point character from the current locale to a period.</dd>
</dl>
<div class="spacer">
</div>
If a <b>'-'</b> character is ignored in the preceding description, the numeric value of the  <i>numeric string</i> shall be the negation of the numeric value of the recognized  <b>NUMBER</b> token. Otherwise, the numeric value of the  <i>numeric string</i> shall be the numeric value of the recognized  <b>NUMBER</b> token. Whether or not a string is a  <i>numeric string</i> shall be relevant only in contexts where that term is used in this section.<div class="spacer">
</div>
When an expression is used in a Boolean context, if it has a numeric value, a value of zero shall be treated as false and any other value shall be treated as true. Otherwise, a string value of the null string shall be treated as false and any other value shall be treated as true. A Boolean context shall be one of the following:<dl>
<dt>
 *</dt>
<dd>
The first subexpression of a conditional expression</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
An expression operated on by logical NOT, logical AND, or logical OR</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
The second expression of a <b>for</b> statement</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
The expression of an <b>if</b> statement</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
The expression of the <b>while</b> clause in either a <b>while</b> or  <b>do</b>... <b>while</b> statement</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
An expression used as a pattern (as in Overall Program Structure)</dd>
</dl>
<div class="spacer">
</div>
All arithmetic shall follow the semantics of floating-point arithmetic as specified by the ISO&#160;C standard (see  <i>Concepts Derived from</i>  <i>the ISO C Standard</i> ).<div class="spacer">
</div>
The value of the expression:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<i>expr1</i> <b>^</b> <i>expr2</i><br/>
</div>
<div class="spacer">
</div>
shall be equivalent to the value returned by the ISO&#160;C standard function call:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>pow(</b><i>expr1</i><b>,</b> <i>expr2</i><b>)</b><br/>
<b></b><br/>
</div>
<div class="spacer">
</div>
The expression:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>lvalue ^=</b> <i>expr</i><br/>
</div>
<div class="spacer">
</div>
shall be equivalent to the ISO&#160;C standard expression:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>lvalue = pow(lvalue,</b> <i>expr</i><b>)</b><br/>
<b></b><br/>
</div>
<div class="spacer">
</div>
except that lvalue shall be evaluated only once. The value of the expression:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<i>expr1</i> <b>%</b> <i>expr2</i><br/>
</div>
<div class="spacer">
</div>
shall be equivalent to the value returned by the ISO&#160;C standard function call:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>fmod(</b><i>expr1</i><b>,</b> <i>expr2</i><b>)</b><br/>
<b></b><br/>
</div>
<div class="spacer">
</div>
The expression:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>lvalue %=</b> <i>expr</i><br/>
</div>
<div class="spacer">
</div>
shall be equivalent to the ISO&#160;C standard expression:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>lvalue = fmod(lvalue,</b> <i>expr</i><b>)</b><br/>
<b></b><br/>
</div>
<div class="spacer">
</div>
except that lvalue shall be evaluated only once.<div class="spacer">
</div>
Variables and fields shall be set by the assignment statement:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>lvalue =</b> <i>expression</i><br/>
</div>
<div class="spacer">
</div>
and the type of <i>expression</i> shall determine the resulting variable type. The assignment includes the arithmetic assignments (  <b>&quot;+=&quot;</b>, <b>&quot;-=&quot;</b>, <b>&quot;*=&quot;</b>, <b>&quot;/=&quot;</b>,  <b>&quot;%=&quot;</b>, <b>&quot;^=&quot;</b>, <b>&quot;++&quot;</b>,  <b>&quot;--&quot;</b> ) all of which shall produce a numeric result. The left-hand side of an assignment and the target of increment and decrement operators can be one of a variable, an array with index, or a field selector.<div class="spacer">
</div>
The <i>awk</i> language supplies arrays that are used for storing numbers or strings. Arrays need not be declared. They shall initially be empty, and their sizes shall change dynamically. The subscripts, or element identifiers, are strings, providing a type of associative array capability. An array name followed by a subscript within square brackets can be used as an lvalue and thus as an expression, as described in the grammar; see Grammar . Unsubscripted array names can be used in only the following contexts:<dl>
<dt>
 *</dt>
<dd>
A parameter in a function definition or function call</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
The <b>NAME</b> token following any use of the keyword <b>in</b> as specified in the grammar (see Grammar ); if the name used in this context is not an array name, the behavior is undefined</dd>
</dl>
<div class="spacer">
</div>
A valid array <i>index</i> shall consist of one or more comma-separated expressions, similar to the way in which multi-dimensional arrays are indexed in some programming languages. Because  <i>awk</i> arrays are really one-dimensional, such a comma-separated list shall be converted to a single string by concatenating the string values of the separate expressions, each separated from the other by the value of the  <b>SUBSEP</b> variable. Thus, the following two index operations shall be equivalent:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<i>var</i><b>[</b><i>expr1</i><b>,</b> <i>expr2</i><b>, ...</b> <i>exprn</i><b>]</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
<b></b><i>var</i><b></b><b>[</b><b></b><i>expr1</i><b> </b><b>SUBSEP</b><b> </b><i>expr2</i><b> </b><b>SUBSEP ... SUBSEP</b><b> </b><i>exprn</i><b></b><b>]</b><b></b><br/>
</div>
<div class="spacer">
</div>
The application shall ensure that a multi-dimensioned <i>index</i> used with the  <b>in</b> operator is parenthesized. The  <b>in</b> operator, which tests for the existence of a particular array element, shall not cause that element to exist. Any other reference to a nonexistent array element shall automatically create it.<div class="spacer">
</div>
Comparisons (with the <b>'&lt;'</b>, <b>&quot;&lt;=&quot;</b>, <b>&quot;!=&quot;</b>, <b>&quot;==&quot;</b>,  <b>'&gt;'</b>, and  <b>&quot;&gt;=&quot;</b> operators) shall be made numerically if both operands are numeric, if one is numeric and the other has a string value that is a numeric string, or if one is numeric and the other has the uninitialized value. Otherwise, operands shall be converted to strings as required and a string comparison shall be made using the locale-specific collation sequence. The value of the comparison expression shall be 1 if the relation is true, or 0 if the relation is false.</div>
<div class="subsection">
<h2>Variables and Special Variables</h2> Variables can be used in an  <i>awk</i> program by referencing them. With the exception of function parameters (see User-Defined Functions ), they are not explicitly declared. Function parameter names shall be local to the function; all other variable names shall be global. The same name shall not be used as both a function parameter name and as the name of a function or a special  <i>awk</i> variable. The same name shall not be used both as a variable name with global scope and as the name of a function. The same name shall not be used within the same scope both as a scalar variable and as an array. Uninitialized variables, including scalar variables, array elements, and field variables, shall have an uninitialized value. An uninitialized value shall have both a numeric value of zero and a string value of the empty string. Evaluation of variables with an uninitialized value, to either string or numeric, shall be determined by the context in which they are used.<div class="spacer">
</div>
Field variables shall be designated by a <b>'$'</b> followed by a number or numerical expression. The effect of the field number  <i>expression</i> evaluating to anything other than a non-negative integer is unspecified; uninitialized variables or string values need not be converted to numeric values in this context. New field variables can be created by assigning a value to them. References to nonexistent fields (that is, fields after $ <b>NF</b>), shall evaluate to the uninitialized value. Such references shall not create new fields. However, assigning to a nonexistent field (for example, $( <b>NF</b>+2)=5) shall increase the value of  <b>NF</b>; create any intervening fields with the uninitialized value; and cause the value of $0 to be recomputed, with the fields being separated by the value of  <b>OFS</b>. Each field variable shall have a string value or an uninitialized value when created. Field variables shall have the uninitialized value when created from $0 using  <b>FS</b> and the variable does not contain any characters. If appropriate, the field variable shall be considered a numeric string (see Expressions in awk ).<div class="spacer">
</div>
Implementations shall support the following other special variables that are set by  <i>awk</i>:<dl>
<dt>
<b>ARGC</b></dt>
<dd>
The number of elements in the <b>ARGV</b> array.</dd>
</dl>
<dl>
<dt>
<b>ARGV</b></dt>
<dd>
An array of command line arguments, excluding options and the <i>program</i> argument, numbered from zero to  <b>ARGC</b>-1.</dd>
</dl>
<div class="spacer">
</div>
The arguments in <b>ARGV</b> can be modified or added to; <b>ARGC</b> can be altered. As each input file ends,  <i>awk</i> shall treat the next non-null element of  <b>ARGV</b>, up to the current value of  <b>ARGC</b>-1, inclusive, as the name of the next input file. Thus, setting an element of  <b>ARGV</b> to null means that it shall not be treated as an input file. The name  <b>'-'</b> indicates the standard input. If an argument matches the format of an  <i>assignment</i> operand, this argument shall be treated as an  <i>assignment</i> rather than a <i>file</i> argument.<dl>
<dt>
<b>CONVFMT</b></dt>
<dd>
The <b>printf</b> format for converting numbers to strings (except for output statements, where  <b>OFMT</b> is used);  <b>&quot;%.6g&quot;</b> by default.</dd>
</dl>
<dl>
<dt>
<b>ENVIRON</b></dt>
<dd>
An array representing the value of the environment, as described in the  <i>exec</i> functions defined in the System Interfaces volume of IEEE&#160;Std&#160;1003.1-2001. The indices of the array shall be strings consisting of the names of the environment variables, and the value of each array element shall be a string consisting of the value of that variable. If appropriate, the environment variable shall be considered a  <i>numeric string</i> (see Expressions in awk ); the array element shall also have its numeric value.</dd>
</dl>
<div class="spacer">
</div>
In all cases where the behavior of <i>awk</i> is affected by environment variables (including the environment of any commands that  <i>awk</i> executes via the <b>system</b> function or via pipeline redirections with the  <b>print</b> statement, the  <b>printf</b> statement, or the <b>getline</b> function), the environment used shall be the environment at the time  <i>awk</i> began executing; it is implementation-defined whether any modification of  <b>ENVIRON</b> affects this environment.<dl>
<dt>
<b>FILENAME</b></dt>
<dd>
A pathname of the current input file. Inside a <b>BEGIN</b> action the value is undefined. Inside an  <b>END</b> action the value shall be the name of the last input file processed.</dd>
</dl>
<dl>
<dt>
<b>FNR</b></dt>
<dd>
The ordinal number of the current record in the current file. Inside a  <b>BEGIN</b> action the value shall be zero. Inside an  <b>END</b> action the value shall be the number of the last record processed in the last file processed.</dd>
</dl>
<dl>
<dt>
<b>FS</b></dt>
<dd>
Input field separator regular expression; a &lt;space&gt; by default.</dd>
</dl>
<dl>
<dt>
<b>NF</b></dt>
<dd>
The number of fields in the current record. Inside a <b>BEGIN</b> action, the use of  <b>NF</b> is undefined unless a  <b>getline</b> function without a <i>var</i> argument is executed previously. Inside an  <b>END</b> action, <b>NF</b> shall retain the value it had for the last record read, unless a subsequent, redirected,  <b>getline</b> function without a <i>var</i> argument is performed prior to entering the  <b>END</b> action.</dd>
</dl>
<dl>
<dt>
<b>NR</b></dt>
<dd>
The ordinal number of the current record from the start of input. Inside a  <b>BEGIN</b> action the value shall be zero. Inside an  <b>END</b> action the value shall be the number of the last record processed.</dd>
</dl>
<dl>
<dt>
<b>OFMT</b></dt>
<dd>
The <b>printf</b> format for converting numbers to strings in output statements (see Output Statements );  <b>&quot;%.6g&quot;</b> by default. The result of the conversion is unspecified if the value of  <b>OFMT</b> is not a floating-point format specification.</dd>
</dl>
<dl>
<dt>
<b>OFS</b></dt>
<dd>
The <b>print</b> statement output field separation; &lt;space&gt; by default.</dd>
</dl>
<dl>
<dt>
<b>ORS</b></dt>
<dd>
The <b>print</b> statement output record separator; a &lt;newline&gt; by default.</dd>
</dl>
<dl>
<dt>
<b>RLENGTH</b></dt>
<dd>
The length of the string matched by the <b>match</b> function.</dd>
</dl>
<dl>
<dt>
<b>RS</b></dt>
<dd>
The first character of the string value of <b>RS</b> shall be the input record separator; a &lt;newline&gt; by default. If  <b>RS</b> contains more than one character, the results are unspecified. If  <b>RS</b> is null, then records are separated by sequences consisting of a &lt;newline&gt; plus one or more blank lines, leading or trailing blank lines shall not result in empty records at the beginning or end of the input, and a &lt;newline&gt; shall always be a field separator, no matter what the value of  <b>FS</b> is.</dd>
</dl>
<dl>
<dt>
<b>RSTART</b></dt>
<dd>
The starting position of the string matched by the <b>match</b> function, numbering from 1. This shall always be equivalent to the return value of the  <b>match</b> function.</dd>
</dl>
<dl>
<dt>
<b>SUBSEP</b></dt>
<dd>
The subscript separator string for multi-dimensional arrays; the default value is implementation-defined.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
</div>
<div class="subsection">
<h2>Regular Expressions</h2> The  <i>awk</i> utility shall make use of the extended regular expression notation (see the Base Definitions volume of IEEE&#160;Std&#160;1003.1-2001, Section 9.4, Extended Regular Expressions) except that it shall allow the use of C-language conventions for escaping special characters within the EREs, as specified in the table in the Base Definitions volume of IEEE&#160;Std&#160;1003.1-2001, Chapter 5, File Format Notation (  <b>'\\'</b>, <b>'\a'</b>, <b>'\b'</b>, <b>'\f'</b>,  <b>'\n'</b>, <b>'\r'</b>, <b>'\t'</b>,  <b>'\v'</b> ) and the following table; these escape sequences shall be recognized both inside and outside bracket expressions. Note that records need not be separated by &lt;newline&gt;s and string constants can contain &lt;newline&gt;s, so even the  <b>&quot;\n&quot;</b> sequence is valid in <i>awk</i> EREs. Using a slash character within an ERE requires the escaping shown in the following table.<div style="height: 0.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>Table: Escape Sequences in </b><i>awk</i><b></b><i></i><table class="tbl">
<col style="width: 14.00ex;"/>
<col style="width: 290.00ex;"/>
<col style="width: 222.00ex;"/>
<tbody>
<tr>
<td>
<i></i><b>Escape</b><i></i></td>
<td>
<i></i><b>&#160;</b><i></i></td>
<td>
<i></i><b>&#160;</b><i></i></td>
</tr>
<tr>
<td>
<i></i><b>Sequence</b><i></i></td>
<td>
<i></i><b>Description</b><i></i></td>
<td>
<i></i><b>Meaning</b><i></i></td>
</tr>
<tr>
<td>
<i>\&quot;</i></td>
<td>
<i>Backslash quotation-mark</i></td>
<td>
<i>Quotation-mark character</i></td>
</tr>
<tr>
<td>
<i>\/</i></td>
<td>
<i>Backslash slash</i></td>
<td>
<i>Slash character</i></td>
</tr>
<tr>
<td>
<i>\ddd</i></td>
<td>
<i>A backslash character followed by the longest sequence of one, two, or three octal-digit characters (01234567). If all of the digits are 0 (that is, representation of the NUL character), the behavior is undefined.</i></td>
<td>
<i>The character whose encoding is represented by the one, two, or three-digit octal integer. Multi-byte characters require multiple, concatenated escape sequences of this type, including the leading </i><b>'\'</b><i> for each byte.</i></td>
</tr>
<tr>
<td>
<i>\c</i></td>
<td>
<i>A backslash character followed by any character not described in this table or in the table in the Base Definitions volume of IEEE&#160;Std&#160;1003.1-2001, Chapter 5, File Format Notation ( </i><b>'\\'</b><i>, </i><b>'\a'</b><i>, </i><b>'\b'</b><i>, </i><b>'\f'</b><i>, </i><b>'\n'</b><i>, </i><b>'\r'</b><i>, </i><b>'\t'</b><i>, </i><b>'\v'</b><i> ).</i></td>
<td>
<i>Undefined</i></td>
</tr>
</tbody>
</table>
<div class="spacer">
</div>
A regular expression can be matched against a specific field or string by using one of the two regular expression matching operators,  <b>'~'</b> and <b>&quot;!~&quot;</b> . These operators shall interpret their right-hand operand as a regular expression and their left-hand operand as a string. If the regular expression matches the string, the  <b>'~'</b> expression shall evaluate to a value of 1, and the  <b>&quot;!~&quot;</b> expression shall evaluate to a value of 0. (The regular expression matching operation is as defined by the term matched in the Base Definitions volume of IEEE&#160;Std&#160;1003.1-2001, Section 9.1, Regular Expression Definitions, where a match occurs on any part of the string unless the regular expression is limited with the circumflex or dollar sign special characters.) If the regular expression does not match the string, the  <b>'~'</b> expression shall evaluate to a value of 0, and the  <b>&quot;!~&quot;</b> expression shall evaluate to a value of 1. If the right-hand operand is any expression other than the lexical token  <b>ERE</b>, the string value of the expression shall be interpreted as an extended regular expression, including the escape conventions described above. Note that these same escape conventions shall also be applied in determining the value of a string literal (the lexical token  <b>STRING</b>), and thus shall be applied a second time when a string literal is used in this context.<div class="spacer">
</div>
When an <b>ERE</b> token appears as an expression in any context other than as the right-hand of the  <b>'~'</b> or  <b>&quot;!~&quot;</b> operator or as one of the built-in function arguments described below, the value of the resulting expression shall be the equivalent of:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>$0 ~ /</b><i>ere</i><b>/</b><br/>
<b></b><br/>
</div>
<div class="spacer">
</div>
The <i>ere</i> argument to the <b>gsub</b>, <b>match</b>, <b>sub</b> functions, and the  <i>fs</i> argument to the <b>split</b> function (see String Functions ) shall be interpreted as extended regular expressions. These can be either  <b>ERE</b> tokens or arbitrary expressions, and shall be interpreted in the same manner as the right-hand side of the  <b>'~'</b> or <b>&quot;!~&quot;</b> operator.<div class="spacer">
</div>
An extended regular expression can be used to separate fields by using the  <b>-F</b> <i>ERE</i> option or by assigning a string containing the expression to the built-in variable  <b>FS</b>. The default value of the  <b>FS</b> variable shall be a single &lt;space&gt;. The following describes  <b>FS</b> behavior:<dl>
<dt>
 1.</dt>
<dd>
If <b>FS</b> is a null string, the behavior is unspecified.</dd>
</dl>
<dl>
<dt>
 2.</dt>
<dd>
If <b>FS</b> is a single character:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl>
<dt>
 a.</dt>
<dd>
If <b>FS</b> is &lt;space&gt;, skip leading and trailing &lt;blank&gt;s; fields shall be delimited by sets of one or more &lt;blank&gt;s.</dd>
</dl>
<dl>
<dt>
 b.</dt>
<dd>
Otherwise, if <b>FS</b> is any other character <i>c</i>, fields shall be delimited by each single occurrence of  <i>c</i>.</dd>
</dl>
</div>
<dl>
<dt>
 3.</dt>
<dd>
Otherwise, the string value of <b>FS</b> shall be considered to be an extended regular expression. Each occurrence of a sequence matching the extended regular expression shall delimit fields.</dd>
</dl>
<div class="spacer">
</div>
Except for the <b>'~'</b> and <b>&quot;!~&quot;</b> operators, and in the <b>gsub</b>,  <b>match</b>, <b>split</b>, and  <b>sub</b> built-in functions, ERE matching shall be based on input records; that is, record separator characters (the first character of the value of the variable  <b>RS</b>, &lt;newline&gt; by default) cannot be embedded in the expression, and no expression shall match the record separator character. If the record separator is not &lt;newline&gt;, &lt;newline&gt;s embedded in the expression can be matched. For the  <b>'~'</b> and <b>&quot;!~&quot;</b> operators, and in those four built-in functions, ERE matching shall be based on text strings; that is, any character (including &lt;newline&gt; and the record separator) can be embedded in the pattern, and an appropriate pattern shall match any character. However, in all  <i>awk</i> ERE matching, the use of one or more NUL characters in the pattern, input record, or text string produces undefined results.</div>
<div class="subsection">
<h2>Patterns</h2> A  <i>pattern</i> is any valid <i>expression</i>, a range specified by two expressions separated by a comma, or one of the two special patterns  <b>BEGIN</b> or <b>END</b>.</div>
<div class="subsection">
<h2>Special Patterns</h2> The  <i>awk</i> utility shall recognize two special patterns, <b>BEGIN</b> and  <b>END</b>. Each <b>BEGIN</b> pattern shall be matched once and its associated action executed before the first record of input is read (except possibly by use of the  <b>getline</b> function-see Input/Output and General Functions - in a prior  <b>BEGIN</b> action) and before command line assignment is done. Each  <b>END</b> pattern shall be matched once and its associated action executed after the last record of input has been read. These two patterns shall have associated actions.<div class="spacer">
</div>
<b>BEGIN</b> and <b>END</b> shall not combine with other patterns. Multiple  <b>BEGIN</b> and <b>END</b> patterns shall be allowed. The actions associated with the  <b>BEGIN</b> patterns shall be executed in the order specified in the program, as are the  <b>END</b> actions. An <b>END</b> pattern can precede a <b>BEGIN</b> pattern in a program.<div class="spacer">
</div>
If an <i>awk</i> program consists of only actions with the pattern  <b>BEGIN</b>, and the <b>BEGIN</b> action contains no  <b>getline</b> function, <i>awk</i> shall exit without reading its input when the last statement in the last  <b>BEGIN</b> action is executed. If an  <i>awk</i> program consists of only actions with the pattern  <b>END</b> or only actions with the patterns  <b>BEGIN</b> and <b>END</b>, the input shall be read before the statements in the  <b>END</b> actions are executed.</div>
<div class="subsection">
<h2>Expression Patterns</h2> An expression pattern shall be evaluated as if it were an expression in a Boolean context. If the result is true, the pattern shall be considered to match, and the associated action (if any) shall be executed. If the result is false, the action shall not be executed.</div>
<div class="subsection">
<h2>Pattern Ranges</h2> A pattern range consists of two expressions separated by a comma; in this case, the action shall be performed for all records between a match of the first expression and the following match of the second expression, inclusive. At this point, the pattern range can be repeated starting at input records subsequent to the end of the matched range.</div>
<div class="subsection">
<h2>Actions</h2> An action is a sequence of statements as shown in the grammar in Grammar . Any single statement can be replaced by a statement list enclosed in braces. The application shall ensure that statements in a statement list are separated by &lt;newline&gt;s or semicolons. Statements in a statement list shall be executed sequentially in the order that they appear.<div class="spacer">
</div>
The <i>expression</i> acting as the conditional in an <b>if</b> statement shall be evaluated and if it is non-zero or non-null, the following statement shall be executed; otherwise, if  <b>else</b> is present, the statement following the  <b>else</b> shall be executed.<div class="spacer">
</div>
The <b>if</b>, <b>while</b>, <b>do</b>... <b>while</b>, <b>for</b>, <b>break</b>, and  <b>continue</b> statements are based on the ISO&#160;C standard (see  <i>Concepts Derived from the ISO C Standard</i> ), except that the Boolean expressions shall be treated as described in Expressions in awk , and except in the case of:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>for (</b><i>variable</i> <b>in</b> <i>array</i><b>)</b><br/>
<b></b><br/>
</div>
<div class="spacer">
</div>
which shall iterate, assigning each <i>index</i> of <i>array</i> to  <i>variable</i> in an unspecified order. The results of adding new elements to  <i>array</i> within such a <b>for</b> loop are undefined. If a  <b>break</b> or <b>continue</b> statement occurs outside of a loop, the behavior is undefined.<div class="spacer">
</div>
The <b>delete</b> statement shall remove an individual array element. Thus, the following code deletes an entire array:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>for (index in array)</b><br/>
<b>    delete array[index]</b><br/>
<b></b><br/>
</div>
<div class="spacer">
</div>
The <b>next</b> statement shall cause all further processing of the current input record to be abandoned. The behavior is undefined if a  <b>next</b> statement appears or is invoked in a <b>BEGIN</b> or  <b>END</b> action.<div class="spacer">
</div>
The <b>exit</b> statement shall invoke all <b>END</b> actions in the order in which they occur in the program source and then terminate the program without reading further input. An  <b>exit</b> statement inside an  <b>END</b> action shall terminate the program without further execution of  <b>END</b> actions. If an expression is specified in an  <b>exit</b> statement, its numeric value shall be the exit status of  <i>awk</i>, unless subsequent errors are encountered or a subsequent  <b>exit</b> statement with an expression is executed.</div>
<div class="subsection">
<h2>Output Statements</h2> Both  <b>print</b> and <b>printf</b> statements shall write to standard output by default. The output shall be written to the location specified by  <i>output_redirection</i> if one is supplied, as follows:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>&gt;</b> <i>expression</i><b>&gt;&gt;</b> <i>expression</i><b>|</b> <i>expression</i><br/>
</div>
<div class="spacer">
</div>
In all cases, the <i>expression</i> shall be evaluated to produce a string that is used as a pathname into which to write (for  <b>'&gt;'</b> or <b>&quot;&gt;&gt;&quot;</b> ) or as a command to be executed (for <b>'|'</b> ). Using the first two forms, if the file of that name is not currently open, it shall be opened, creating it if necessary and using the first form, truncating the file. The output then shall be appended to the file. As long as the file remains open, subsequent calls in which  <i>expression</i> evaluates to the same string value shall simply append output to the file. The file remains open until the  <b>close</b> function (see Input/Output and General Functions ) is called with an expression that evaluates to the same string value.<div class="spacer">
</div>
The third form shall write output onto a stream piped to the input of a command. The stream shall be created if no stream is currently open with the value of  <i>expression</i> as its command name. The stream created shall be equivalent to one created by a call to the  <i>popen</i>() function defined in the System Interfaces volume of IEEE&#160;Std&#160;1003.1-2001 with the value of  <i>expression</i> as the <i>command</i> argument and a value of  <i>w</i> as the  <i>mode</i> argument. As long as the stream remains open, subsequent calls in which  <i>expression</i> evaluates to the same string value shall write output to the existing stream. The stream shall remain open until the  <b>close</b> function (see Input/Output and General Functions ) is called with an expression that evaluates to the same string value. At that time, the stream shall be closed as if by a call to the  <i>pclose</i>() function defined in the System Interfaces volume of IEEE&#160;Std&#160;1003.1-2001.<div class="spacer">
</div>
As described in detail by the grammar in Grammar , these output statements shall take a comma-separated list of  <i>expression</i>s referred to in the grammar by the non-terminal symbols  <b>expr_list</b>,  <b>print_expr_list</b>, or <b>print_expr_list_opt</b>. This list is referred to here as the  <i>expression list</i>, and each member is referred to as an  <i>expression argument</i>.<div class="spacer">
</div>
The <b>print</b> statement shall write the value of each expression argument onto the indicated output stream separated by the current output field separator (see variable  <b>OFS</b> above), and terminated by the output record separator (see variable  <b>ORS</b> above). All expression arguments shall be taken as strings, being converted if necessary; this conversion shall be as described in Expressions in awk , with the exception that the  <b>printf</b> format in  <b>OFMT</b> shall be used instead of the value in  <b>CONVFMT</b>. An empty expression list shall stand for the whole input record ($0).<div class="spacer">
</div>
The <b>printf</b> statement shall produce output based on a notation similar to the File Format Notation used to describe file formats in this volume of IEEE&#160;Std&#160;1003.1-2001 (see the Base Definitions volume of IEEE&#160;Std&#160;1003.1-2001, Chapter 5, File Format Notation). Output shall be produced as specified with the first  <i>expression</i> argument as the string <i>format</i> and subsequent  <i>expression</i> arguments as the strings <i>arg1</i> to  <i>argn</i>, inclusive, with the following exceptions:<dl>
<dt>
 1.</dt>
<dd>
The <i>format</i> shall be an actual character string rather than a graphical representation. Therefore, it cannot contain empty character positions. The &lt;space&gt; in the  <i>format</i> string, in any context other than a  <i>flag</i> of a conversion specification, shall be treated as an ordinary character that is copied to the output.</dd>
</dl>
<dl>
<dt>
 2.</dt>
<dd>
If the character set contains a <b>' '</b> character and that character appears in the  <i>format</i> string, it shall be treated as an ordinary character that is copied to the output.</dd>
</dl>
<dl>
<dt>
 3.</dt>
<dd>
The <i>escape sequences</i> beginning with a backslash character shall be treated as sequences of ordinary characters that are copied to the output. Note that these same sequences shall be interpreted lexically by  <i>awk</i> when they appear in literal strings, but they shall not be treated specially by the  <b>printf</b> statement.</dd>
</dl>
<dl>
<dt>
 4.</dt>
<dd>
A <i>field width</i> or <i>precision</i> can be specified as the <b>'*'</b> character instead of a digit string. In this case the next argument from the expression list shall be fetched and its numeric value taken as the field width or precision.</dd>
</dl>
<dl>
<dt>
 5.</dt>
<dd>
The implementation shall not precede or follow output from the <b>d</b> or  <b>u</b> conversion specifier characters with &lt;blank&gt;s not specified by the  <i>format</i> string.</dd>
</dl>
<dl>
<dt>
 6.</dt>
<dd>
The implementation shall not precede output from the <b>o</b> conversion specifier character with leading zeros not specified by the  <i>format</i> string.</dd>
</dl>
<dl>
<dt>
 7.</dt>
<dd>
For the <b>c</b> conversion specifier character: if the argument has a numeric value, the character whose encoding is that value shall be output. If the value is zero or is not the encoding of any character in the character set, the behavior is undefined. If the argument does not have a numeric value, the first character of the string value shall be output; if the string does not contain any characters, the behavior is undefined.</dd>
</dl>
<dl>
<dt>
 8.</dt>
<dd>
For each conversion specification that consumes an argument, the next expression argument shall be evaluated. With the exception of the  <b>c</b> conversion specifier character, the value shall be converted (according to the rules specified in Expressions in awk ) to the appropriate type for the conversion specification.</dd>
</dl>
<dl>
<dt>
 9.</dt>
<dd>
If there are insufficient expression arguments to satisfy all the conversion specifications in the  <i>format</i> string, the behavior is undefined.</dd>
</dl>
<dl>
<dt>
10.</dt>
<dd>
If any character sequence in the <i>format</i> string begins with a  <b>'%'</b> character, but does not form a valid conversion specification, the behavior is unspecified.</dd>
</dl>
<div class="spacer">
</div>
Both <b>print</b> and <b>printf</b> can output at least {LINE_MAX} bytes.</div>
<div class="subsection">
<h2>Functions</h2> The  <i>awk</i> language has a variety of built-in functions: arithmetic, string, input/output, and general.</div>
<div class="subsection">
<h2>Arithmetic Functions</h2> The arithmetic functions, except for  <b>int</b>, shall be based on the ISO&#160;C standard (see  <i>Concepts Derived from the ISO C Standard</i> ). The behavior is undefined in cases where the ISO&#160;C standard specifies that an error be returned or that the behavior is undefined. Although the grammar (see Grammar ) permits built-in functions to appear with no arguments or parentheses, unless the argument or parentheses are indicated as optional in the following list (by displaying them within the  <b>&quot;[]&quot;</b> brackets), such use is undefined.<dl>
<dt>
<b>atan2</b>(<i>y</i>,<i>x</i>)</dt>
<dd>
Return arctangent of <i>y</i>/<i>x</i> in radians in the range [-pi,pi].</dd>
</dl>
<dl>
<dt>
<b>cos</b>(<i>x</i>)</dt>
<dd>
Return cosine of <i>x</i>, where <i>x</i> is in radians.</dd>
</dl>
<dl>
<dt>
<b>sin</b>(<i>x</i>)</dt>
<dd>
Return sine of <i>x</i>, where <i>x</i> is in radians.</dd>
</dl>
<dl>
<dt>
<b>exp</b>(<i>x</i>)</dt>
<dd>
Return the exponential function of <i>x</i>.</dd>
</dl>
<dl>
<dt>
<b>log</b>(<i>x</i>)</dt>
<dd>
Return the natural logarithm of <i>x</i>.</dd>
</dl>
<dl>
<dt>
<b>sqrt</b>(<i>x</i>)</dt>
<dd>
Return the square root of <i>x</i>.</dd>
</dl>
<dl>
<dt>
<b>int</b>(<i>x</i>)</dt>
<dd>
Return the argument truncated to an integer. Truncation shall be toward 0 when  <i>x</i>&gt;0.</dd>
</dl>
<dl>
<dt>
<b>rand</b>()</dt>
<dd>
Return a random number <i>n</i>, such that 0&lt;=<i>n</i>&lt;1.</dd>
</dl>
<dl>
<dt>
<b>srand</b>(<b>[</b><i>expr</i><b>]</b>)</dt>
<dd>
Set the seed value for <i>rand</i> to <i>expr</i> or use the time of day if  <i>expr</i> is omitted. The previous seed value shall be returned.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
</div>
<div class="subsection">
<h2>String Functions</h2> The string functions in the following list shall be supported. Although the grammar (see Grammar ) permits built-in functions to appear with no arguments or parentheses, unless the argument or parentheses are indicated as optional in the following list (by displaying them within the  <b>&quot;[]&quot;</b> brackets), such use is undefined.<dl>
<dt>
<b>gsub</b>(<i>ere</i>,&#160;<i>repl</i><b>[</b>,&#160;<i>in</i><b>]</b>)</dt>
<dd>
Behave like <b>sub</b> (see below), except that it shall replace all occurrences of the regular expression (like the  <i>ed</i> utility global substitute) in $0 or in the  <i>in</i> argument, when specified.</dd>
</dl>
<dl>
<dt>
<b>index</b>(<i>s</i>,&#160;<i>t</i>)</dt>
<dd>
Return the position, in characters, numbering from 1, in string <i>s</i> where string  <i>t</i> first occurs, or zero if it does not occur at all.</dd>
</dl>
<dl>
<dt>
<b>length[</b>(<b>[</b><i>s</i><b>]</b>)<b>]</b></dt>
<dd>
Return the length, in characters, of its argument taken as a string, or of the whole record, $0, if there is no argument.</dd>
</dl>
<dl>
<dt>
<b>match</b>(<i>s</i>,&#160;<i>ere</i>)</dt>
<dd>
Return the position, in characters, numbering from 1, in string <i>s</i> where the extended regular expression  <i>ere</i> occurs, or zero if it does not occur at all. RSTART shall be set to the starting position (which is the same as the returned value), zero if no match is found; RLENGTH shall be set to the length of the matched string, -1 if no match is found.</dd>
</dl>
<dl>
<dt>
<b>split</b>(<i>s</i>,&#160;<i>a</i><b>[</b>,&#160;<i>fs&#160;</i> <b>]</b>)</dt>
<dd>
Split the string <i>s</i> into array elements <i>a</i>[1], <i>a</i>[2], ...,  <i>a</i>[<i>n</i>], and return <i>n</i>. All elements of the array shall be deleted before the split is performed. The separation shall be done with the ERE  <i>fs</i> or with the field separator  <b>FS</b> if <i>fs</i> is not given. Each array element shall have a string value when created and, if appropriate, the array element shall be considered a numeric string (see Expressions in awk ). The effect of a null string as the value of  <i>fs</i> is unspecified.</dd>
</dl>
<dl>
<dt>
<b>sprintf</b>(<i>fmt</i>,&#160;<i>expr</i>,&#160;<i>expr</i>,&#160;...)</dt>
<dd>
Format the expressions according to the <b>printf</b> format given by  <i>fmt</i> and return the resulting string.</dd>
</dl>
<dl>
<dt>
<b>sub(</b><i>ere</i>,&#160;<i>repl</i><b>[</b>,&#160;<i>in&#160;</i> <b>]</b>)</dt>
<dd>
Substitute the string <i>repl</i> in place of the first instance of the extended regular expression  <i>ERE</i> in string <i>in</i> and return the number of substitutions. An ampersand (  <b>'&amp;'</b> ) appearing in the string  <i>repl</i> shall be replaced by the string from  <i>in</i> that matches the ERE. An ampersand preceded with a backslash (  <b>'\'</b> ) shall be interpreted as the literal ampersand character. An occurrence of two consecutive backslashes shall be interpreted as just a single literal backslash character. Any other occurrence of a backslash (for example, preceding any other character) shall be treated as a literal backslash character. Note that if  <i>repl</i> is a string literal (the lexical token  <b>STRING</b>; see Grammar ), the handling of the ampersand character occurs after any lexical processing, including any lexical backslash escape sequence processing. If  <i>in</i> is specified and it is not an lvalue (see Expressions in awk ), the behavior is undefined. If  <i>in</i> is omitted, <i>awk</i> shall use the current record ($0) in its place.</dd>
</dl>
<dl>
<dt>
<b>substr</b>(<i>s</i>,&#160;<i>m</i><b>[</b>,&#160;<i>n&#160;</i> <b>]</b>)</dt>
<dd>
Return the at most <i>n</i>-character substring of <i>s</i> that begins at position  <i>m</i>, numbering from 1. If <i>n</i> is omitted, or if  <i>n</i> specifies more characters than are left in the string, the length of the substring shall be limited by the length of the string  <i>s</i>.</dd>
</dl>
<dl>
<dt>
<b>tolower</b>(<i>s</i>)</dt>
<dd>
Return a string based on the string <i>s</i>. Each character in <i>s</i> that is an uppercase letter specified to have a  <b>tolower</b> mapping by the <i>LC_CTYPE</i> category of the current locale shall be replaced in the returned string by the lowercase letter specified by the mapping. Other characters in  <i>s</i> shall be unchanged in the returned string.</dd>
</dl>
<dl>
<dt>
<b>toupper</b>(<i>s</i>)</dt>
<dd>
Return a string based on the string <i>s</i>. Each character in <i>s</i> that is a lowercase letter specified to have a  <b>toupper</b> mapping by the <i>LC_CTYPE</i> category of the current locale is replaced in the returned string by the uppercase letter specified by the mapping. Other characters in  <i>s</i> are unchanged in the returned string.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<div class="spacer">
</div>
All of the preceding functions that take <i>ERE</i> as a parameter expect a pattern or a string valued expression that is a regular expression as defined in Regular Expressions .</div>
<div class="subsection">
<h2>Input/Output and General Functions</h2> The input/output and general functions are:<dl>
<dt>
<b>close</b>(<i>expression</i>)</dt>
<dd>
Close the file or pipe opened by a <b>print</b> or <b>printf</b> statement or a call to  <b>getline</b> with the same string-valued  <i>expression</i>. The limit on the number of open <i>expression</i> arguments is implementation-defined. If the close was successful, the function shall return zero; otherwise, it shall return non-zero.</dd>
</dl>
<dl>
<dt>
<i>expression&#160;|&#160;</i> <b>getline&#160;[</b><i>var</i><b>]</b></dt>
<dd>
Read a record of input from a stream piped from the output of a command. The stream shall be created if no stream is currently open with the value of  <i>expression</i> as its command name. The stream created shall be equivalent to one created by a call to the  <i>popen</i>() function with the value of  <i>expression</i> as the <i>command</i> argument and a value of  <i>r</i> as the <i>mode</i> argument. As long as the stream remains open, subsequent calls in which  <i>expression</i> evaluates to the same string value shall read subsequent records from the stream. The stream shall remain open until the  <b>close</b> function is called with an expression that evaluates to the same string value. At that time, the stream shall be closed as if by a call to the  <i>pclose</i>() function. If <i>var</i> is omitted, $0 and  <b>NF</b> shall be set; otherwise, <i>var</i> shall be set and, if appropriate, it shall be considered a numeric string (see Expressions in awk ).</dd>
</dl>
<div class="spacer">
</div>
The <b>getline</b> operator can form ambiguous constructs when there are unparenthesized operators (including concatenate) to the left of the  <b>'|'</b> (to the beginning of the expression containing  <b>getline</b>). In the context of the <b>'$'</b> operator,  <b>'|'</b> shall behave as if it had a lower precedence than  <b>'$'</b> . The result of evaluating other operators is unspecified, and conforming applications shall parenthesize properly all such usages.<dl>
<dt>
<b>getline</b></dt>
<dd>
Set $0 to the next input record from the current input file. This form of  <b>getline</b> shall set the <b>NF</b>, <b>NR</b>, and  <b>FNR</b> variables.</dd>
</dl>
<dl>
<dt>
<b>getline&#160;</b> <i>var</i></dt>
<dd>
Set variable <i>var</i> to the next input record from the current input file and, if appropriate,  <i>var</i> shall be considered a numeric string (see Expressions in awk ). This form of  <b>getline</b> shall set the  <b>FNR</b> and <b>NR</b> variables.</dd>
</dl>
<dl>
<dt>
<b>getline&#160;[</b><i>var</i><b>]&#160;</b> &lt;&#160;<i>expression</i></dt>
<dd>
Read the next record of input from a named file. The <i>expression</i> shall be evaluated to produce a string that is used as a pathname. If the file of that name is not currently open, it shall be opened. As long as the stream remains open, subsequent calls in which  <i>expression</i> evaluates to the same string value shall read subsequent records from the file. The file shall remain open until the  <b>close</b> function is called with an expression that evaluates to the same string value. If  <i>var</i> is omitted, $0 and  <b>NF</b> shall be set; otherwise, <i>var</i> shall be set and, if appropriate, it shall be considered a numeric string (see Expressions in awk ).</dd>
</dl>
<div class="spacer">
</div>
The <b>getline</b> operator can form ambiguous constructs when there are unparenthesized binary operators (including concatenate) to the right of the  <b>'&lt;'</b> (up to the end of the expression containing the  <b>getline</b>). The result of evaluating such a construct is unspecified, and conforming applications shall parenthesize properly all such usages.<dl>
<dt>
<b>system</b>(<i>expression</i>)</dt>
<dd>
Execute the command given by <i>expression</i> in a manner equivalent to the  <i>system</i>() function defined in the System Interfaces volume of IEEE&#160;Std&#160;1003.1-2001 and return the exit status of the command.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<div class="spacer">
</div>
All forms of <b>getline</b> shall return 1 for successful input, zero for end-of-file, and -1 for an error.<div class="spacer">
</div>
Where strings are used as the name of a file or pipeline, the application shall ensure that the strings are textually identical. The terminology &quot;same string value&quot; implies that &quot;equivalent strings&quot;, even those that differ only by &lt;space&gt;s, represent different files.</div>
<div class="subsection">
<h2>User-Defined Functions</h2> The  <i>awk</i> language also provides user-defined functions. Such functions can be defined as:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>function</b> <i>name</i><b>(</b><b>[</b><i>parameter</i><b>, ...</b><b>]</b><b>) {</b> <i>statements</i> <b>}</b><br/>
<b></b><br/>
</div>
<div class="spacer">
</div>
A function can be referred to anywhere in an <i>awk</i> program; in particular, its use can precede its definition. The scope of a function is global.<div class="spacer">
</div>
Function parameters, if present, can be either scalars or arrays; the behavior is undefined if an array name is passed as a parameter that the function uses as a scalar, or if a scalar expression is passed as a parameter that the function uses as an array. Function parameters shall be passed by value if scalar and by reference if array name.<div class="spacer">
</div>
The number of parameters in the function definition need not match the number of parameters in the function call. Excess formal parameters can be used as local variables. If fewer arguments are supplied in a function call than are in the function definition, the extra parameters that are used in the function body as scalars shall evaluate to the uninitialized value until they are otherwise initialized, and the extra parameters that are used in the function body as arrays shall be treated as uninitialized arrays where each element evaluates to the uninitialized value until otherwise initialized.<div class="spacer">
</div>
When invoking a function, no white space can be placed between the function name and the opening parenthesis. Function calls can be nested and recursive calls can be made upon functions. Upon return from any nested or recursive function call, the values of all of the calling function's parameters shall be unchanged, except for array parameters passed by reference. The  <b>return</b> statement can be used to return a value. If a  <b>return</b> statement appears outside of a function definition, the behavior is undefined.<div class="spacer">
</div>
In the function definition, &lt;newline&gt;s shall be optional before the opening brace and after the closing brace. Function definitions can appear anywhere in the program where a  <i>pattern-action</i> pair is allowed.</div>
<div class="subsection">
<h2>Grammar</h2> The grammar in this section and the lexical conventions in the following section shall together describe the syntax for  <i>awk</i> programs. The general conventions for this style of grammar are described in  <i>Grammar Conventions</i> . A valid program can be represented as the non-terminal symbol  <i>program</i> in the grammar. This formal syntax shall take precedence over the preceding text syntax description.<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>%token NAME NUMBER STRING ERE</b><br/>
<b>%token FUNC_NAME   /* Name followed by '(' without white space. */</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
/* Keywords  */<br/>
%token       Begin   End<br/>
/*          'BEGIN' 'END'                            */<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
%token       Break   Continue   Delete   Do   Else<br/>
/*          'break' 'continue' 'delete' 'do' 'else'  */<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
%token       Exit   For   Function   If   In<br/>
/*          'exit' 'for' 'function' 'if' 'in'        */<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
%token       Next   Print   Printf   Return   While<br/>
/*          'next' 'print' 'printf' 'return' 'while' */<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
/* Reserved function names */<br/>
%token BUILTIN_FUNC_NAME<br/>
            /* One token for the following:<br/>
             * atan2 cos sin exp log sqrt int rand srand<br/>
             * gsub index length match split sprintf sub<br/>
             * substr tolower toupper close system<br/>
             */<br/>
%token GETLINE<br/>
            /* Syntactically different from other built-ins. */<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
/* Two-character tokens. */<br/>
%token ADD_ASSIGN SUB_ASSIGN MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN POW_ASSIGN<br/>
/*     '+='       '-='       '*='       '/='       '%='       '^=' */<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
%token OR   AND  NO_MATCH   EQ   LE   GE   NE   INCR  DECR  APPEND<br/>
/*     '||' '&amp;&amp;' '!~' '==' '&lt;=' '&gt;=' '!=' '++'  '--'  '&gt;&gt;'   */<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
/* One-character tokens. */<br/>
%token '{' '}' '(' ')' '[' ']' ',' ';' NEWLINE<br/>
%token '+' '-' '*' '%' '^' '!' '&gt;' '&lt;' '|' '?' ':' '~' '$' '='<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
%start program<br/>
%%<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
program          : item_list<br/>
                 | actionless_item_list<br/>
                 ;<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
item_list        : newline_opt<br/>
                 | actionless_item_list item terminator<br/>
                 | item_list            item terminator<br/>
                 | item_list          action terminator<br/>
                 ;<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
actionless_item_list : item_list            pattern terminator<br/>
                 | actionless_item_list pattern terminator<br/>
                 ;<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
item             : pattern action<br/>
                 | Function NAME      '(' param_list_opt ')'<br/>
                       newline_opt action<br/>
                 | Function FUNC_NAME '(' param_list_opt ')'<br/>
                       newline_opt action<br/>
                 ;<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
param_list_opt   : /* empty */<br/>
                 | param_list<br/>
                 ;<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
param_list       : NAME<br/>
                 | param_list ',' NAME<br/>
                 ;<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
pattern          : Begin<br/>
                 | End<br/>
                 | expr<br/>
                 | expr ',' newline_opt expr<br/>
                 ;<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
action           : '{' newline_opt                             '}'<br/>
                 | '{' newline_opt terminated_statement_list   '}'<br/>
                 | '{' newline_opt unterminated_statement_list '}'<br/>
                 ;<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
terminator       : terminator ';'<br/>
                 | terminator NEWLINE<br/>
                 |            ';'<br/>
                 |            NEWLINE<br/>
                 ;<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
terminated_statement_list : terminated_statement<br/>
                 | terminated_statement_list terminated_statement<br/>
                 ;<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
unterminated_statement_list : unterminated_statement<br/>
                 | terminated_statement_list unterminated_statement<br/>
                 ;<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
terminated_statement : action newline_opt<br/>
                 | If '(' expr ')' newline_opt terminated_statement<br/>
                 | If '(' expr ')' newline_opt terminated_statement<br/>
                       Else newline_opt terminated_statement<br/>
                 | While '(' expr ')' newline_opt terminated_statement<br/>
                 | For '(' simple_statement_opt ';'<br/>
                      expr_opt ';' simple_statement_opt ')' newline_opt<br/>
                      terminated_statement<br/>
                 | For '(' NAME In NAME ')' newline_opt<br/>
                      terminated_statement<br/>
                 | ';' newline_opt<br/>
                 | terminatable_statement NEWLINE newline_opt<br/>
                 | terminatable_statement ';'     newline_opt<br/>
                 ;<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
unterminated_statement : terminatable_statement<br/>
                 | If '(' expr ')' newline_opt unterminated_statement<br/>
                 | If '(' expr ')' newline_opt terminated_statement<br/>
                      Else newline_opt unterminated_statement<br/>
                 | While '(' expr ')' newline_opt unterminated_statement<br/>
                 | For '(' simple_statement_opt ';'<br/>
                  expr_opt ';' simple_statement_opt ')' newline_opt<br/>
                      unterminated_statement<br/>
                 | For '(' NAME In NAME ')' newline_opt<br/>
                      unterminated_statement<br/>
                 ;<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
terminatable_statement : simple_statement<br/>
                 | Break<br/>
                 | Continue<br/>
                 | Next<br/>
                 | Exit expr_opt<br/>
                 | Return expr_opt<br/>
                 | Do newline_opt terminated_statement While '(' expr ')'<br/>
                 ;<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
simple_statement_opt : /* empty */<br/>
                 | simple_statement<br/>
                 ;<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
simple_statement : Delete NAME '[' expr_list ']'<br/>
                 | expr<br/>
                 | print_statement<br/>
                 ;<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
print_statement  : simple_print_statement<br/>
                 | simple_print_statement output_redirection<br/>
                 ;<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
simple_print_statement : Print  print_expr_list_opt<br/>
                 | Print  '(' multiple_expr_list ')'<br/>
                 | Printf print_expr_list<br/>
                 | Printf '(' multiple_expr_list ')'<br/>
                 ;<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
output_redirection : '&gt;'    expr<br/>
                 | APPEND expr<br/>
                 | '|'    expr<br/>
                 ;<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
expr_list_opt    : /* empty */<br/>
                 | expr_list<br/>
                 ;<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
expr_list        : expr<br/>
                 | multiple_expr_list<br/>
                 ;<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
multiple_expr_list : expr ',' newline_opt expr<br/>
                 | multiple_expr_list ',' newline_opt expr<br/>
                 ;<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
expr_opt         : /* empty */<br/>
                 | expr<br/>
                 ;<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
expr             : unary_expr<br/>
                 | non_unary_expr<br/>
                 ;<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
unary_expr       : '+' expr<br/>
                 | '-' expr<br/>
                 | unary_expr '^'      expr<br/>
                 | unary_expr '*'      expr<br/>
                 | unary_expr '/'      expr<br/>
                 | unary_expr '%'      expr<br/>
                 | unary_expr '+'      expr<br/>
                 | unary_expr '-'      expr<br/>
                 | unary_expr          non_unary_expr<br/>
                 | unary_expr '&lt;'      expr<br/>
                 | unary_expr LE       expr<br/>
                 | unary_expr NE       expr<br/>
                 | unary_expr EQ       expr<br/>
                 | unary_expr '&gt;'      expr<br/>
                 | unary_expr GE       expr<br/>
                 | unary_expr '~'      expr<br/>
                 | unary_expr NO_MATCH expr<br/>
                 | unary_expr In NAME<br/>
                 | unary_expr AND newline_opt expr<br/>
                 | unary_expr OR  newline_opt expr<br/>
                 | unary_expr '?' expr ':' expr<br/>
                 | unary_input_function<br/>
                 ;<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
non_unary_expr   : '(' expr ')'<br/>
                 | '!' expr<br/>
                 | non_unary_expr '^'      expr<br/>
                 | non_unary_expr '*'      expr<br/>
                 | non_unary_expr '/'      expr<br/>
                 | non_unary_expr '%'      expr<br/>
                 | non_unary_expr '+'      expr<br/>
                 | non_unary_expr '-'      expr<br/>
                 | non_unary_expr          non_unary_expr<br/>
                 | non_unary_expr '&lt;'      expr<br/>
                 | non_unary_expr LE       expr<br/>
                 | non_unary_expr NE       expr<br/>
                 | non_unary_expr EQ       expr<br/>
                 | non_unary_expr '&gt;'      expr<br/>
                 | non_unary_expr GE       expr<br/>
                 | non_unary_expr '~'      expr<br/>
                 | non_unary_expr NO_MATCH expr<br/>
                 | non_unary_expr In NAME<br/>
                 | '(' multiple_expr_list ')' In NAME<br/>
                 | non_unary_expr AND newline_opt expr<br/>
                 | non_unary_expr OR  newline_opt expr<br/>
                 | non_unary_expr '?' expr ':' expr<br/>
                 | NUMBER<br/>
                 | STRING<br/>
                 | lvalue<br/>
                 | ERE<br/>
                 | lvalue INCR<br/>
                 | lvalue DECR<br/>
                 | INCR lvalue<br/>
                 | DECR lvalue<br/>
                 | lvalue POW_ASSIGN expr<br/>
                 | lvalue MOD_ASSIGN expr<br/>
                 | lvalue MUL_ASSIGN expr<br/>
                 | lvalue DIV_ASSIGN expr<br/>
                 | lvalue ADD_ASSIGN expr<br/>
                 | lvalue SUB_ASSIGN expr<br/>
                 | lvalue '=' expr<br/>
                 | FUNC_NAME '(' expr_list_opt ')'<br/>
                      /* no white space allowed before '(' */<br/>
                 | BUILTIN_FUNC_NAME '(' expr_list_opt ')'<br/>
                 | BUILTIN_FUNC_NAME<br/>
                 | non_unary_input_function<br/>
                 ;<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
print_expr_list_opt : /* empty */<br/>
                 | print_expr_list<br/>
                 ;<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
print_expr_list  : print_expr<br/>
                 | print_expr_list ',' newline_opt print_expr<br/>
                 ;<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
print_expr       : unary_print_expr<br/>
                 | non_unary_print_expr<br/>
                 ;<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
unary_print_expr : '+' print_expr<br/>
                 | '-' print_expr<br/>
                 | unary_print_expr '^'      print_expr<br/>
                 | unary_print_expr '*'      print_expr<br/>
                 | unary_print_expr '/'      print_expr<br/>
                 | unary_print_expr '%'      print_expr<br/>
                 | unary_print_expr '+'      print_expr<br/>
                 | unary_print_expr '-'      print_expr<br/>
                 | unary_print_expr          non_unary_print_expr<br/>
                 | unary_print_expr '~'      print_expr<br/>
                 | unary_print_expr NO_MATCH print_expr<br/>
                 | unary_print_expr In NAME<br/>
                 | unary_print_expr AND newline_opt print_expr<br/>
                 | unary_print_expr OR  newline_opt print_expr<br/>
                 | unary_print_expr '?' print_expr ':' print_expr<br/>
                 ;<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
non_unary_print_expr : '(' expr ')'<br/>
                 | '!' print_expr<br/>
                 | non_unary_print_expr '^'      print_expr<br/>
                 | non_unary_print_expr '*'      print_expr<br/>
                 | non_unary_print_expr '/'      print_expr<br/>
                 | non_unary_print_expr '%'      print_expr<br/>
                 | non_unary_print_expr '+'      print_expr<br/>
                 | non_unary_print_expr '-'      print_expr<br/>
                 | non_unary_print_expr          non_unary_print_expr<br/>
                 | non_unary_print_expr '~'      print_expr<br/>
                 | non_unary_print_expr NO_MATCH print_expr<br/>
                 | non_unary_print_expr In NAME<br/>
                 | '(' multiple_expr_list ')' In NAME<br/>
                 | non_unary_print_expr AND newline_opt print_expr<br/>
                 | non_unary_print_expr OR  newline_opt print_expr<br/>
                 | non_unary_print_expr '?' print_expr ':' print_expr<br/>
                 | NUMBER<br/>
                 | STRING<br/>
                 | lvalue<br/>
                 | ERE<br/>
                 | lvalue INCR<br/>
                 | lvalue DECR<br/>
                 | INCR lvalue<br/>
                 | DECR lvalue<br/>
                 | lvalue POW_ASSIGN print_expr<br/>
                 | lvalue MOD_ASSIGN print_expr<br/>
                 | lvalue MUL_ASSIGN print_expr<br/>
                 | lvalue DIV_ASSIGN print_expr<br/>
                 | lvalue ADD_ASSIGN print_expr<br/>
                 | lvalue SUB_ASSIGN print_expr<br/>
                 | lvalue '=' print_expr<br/>
                 | FUNC_NAME '(' expr_list_opt ')'<br/>
                     /* no white space allowed before '(' */<br/>
                 | BUILTIN_FUNC_NAME '(' expr_list_opt ')'<br/>
                 | BUILTIN_FUNC_NAME<br/>
                 ;<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
lvalue           : NAME<br/>
                 | NAME '[' expr_list ']'<br/>
                 | '$' expr<br/>
                 ;<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
non_unary_input_function : simple_get<br/>
                 | simple_get '&lt;' expr<br/>
                 | non_unary_expr '|' simple_get<br/>
                 ;<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
unary_input_function : unary_expr '|' simple_get<br/>
                 ;<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
simple_get       : GETLINE<br/>
                 | GETLINE lvalue<br/>
                 ;<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
newline_opt      : /* empty */<br/>
                 | newline_opt NEWLINE<br/>
                 ;<br/>
<b></b><br/>
</div>
<div class="spacer">
</div>
This grammar has several ambiguities that shall be resolved as follows:<dl>
<dt>
 *</dt>
<dd>
Operator precedence and associativity shall be as described in Expressions in Decreasing Precedence in  <i>awk</i> .</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
In case of ambiguity, an <b>else</b> shall be associated with the most immediately preceding  <b>if</b> that would satisfy the grammar.</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
In some contexts, a slash ( <b>'/'</b> ) that is used to surround an ERE could also be the division operator. This shall be resolved in such a way that wherever the division operator could appear, a slash is assumed to be the division operator. (There is no unary division operator.)</dd>
</dl>
<div class="spacer">
</div>
One convention that might not be obvious from the formal grammar is where &lt;newline&gt;s are acceptable. There are several obvious placements such as terminating a statement, and a backslash can be used to escape &lt;newline&gt;s between any lexical tokens. In addition, &lt;newline&gt;s without backslashes can follow a comma, an open brace, logical AND operator (  <b>&quot;&amp;&amp;&quot;</b> ), logical OR operator ( <b>&quot;||&quot;</b> ), the <b>do</b> keyword, the  <b>else</b> keyword, and the closing parenthesis of an  <b>if</b>, <b>for</b>, or <b>while</b> statement. For example:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>{ print  $1,</b><br/>
<b>         $2 }</b><br/>
<b></b><br/>
</div>
</div>
<div class="subsection">
<h2>Lexical Conventions</h2> The lexical conventions for  <i>awk</i> programs, with respect to the preceding grammar, shall be as follows:<dl>
<dt>
 1.</dt>
<dd>
Except as noted, <i>awk</i> shall recognize the longest possible token or delimiter beginning at a given point.</dd>
</dl>
<dl>
<dt>
 2.</dt>
<dd>
A comment shall consist of any characters beginning with the number sign character and terminated by, but excluding the next occurrence of, a &lt;newline&gt;. Comments shall have no effect, except to delimit lexical tokens.</dd>
</dl>
<dl>
<dt>
 3.</dt>
<dd>
The &lt;newline&gt; shall be recognized as the token <b>NEWLINE</b>.</dd>
</dl>
<dl>
<dt>
 4.</dt>
<dd>
A backslash character immediately followed by a &lt;newline&gt; shall have no effect.</dd>
</dl>
<dl>
<dt>
 5.</dt>
<dd>
The token <b>STRING</b> shall represent a string constant. A string constant shall begin with the character  <b>' .'</b> Within a string constant, a backslash character shall be considered to begin an escape sequence as specified in the table in the Base Definitions volume of IEEE&#160;Std&#160;1003.1-2001, Chapter 5, File Format Notation (  <b>'\\'</b>, <b>'\a'</b>, <b>'\b'</b>, <b>'\f'</b>, <b>'\n'</b>,  <b>'\r'</b>, <b>'\t'</b>, <b>'\v'</b> ). In addition, the escape sequences in Expressions in Decreasing Precedence in  <i>awk</i> shall be recognized. A &lt;newline&gt; shall not occur within a string constant. A string constant shall be terminated by the first unescaped occurrence of the character  <b>''</b> after the one that begins the string constant. The value of the string shall be the sequence of all unescaped characters and values of escape sequences between, but not including, the two delimiting  <b>''</b> characters.</dd>
</dl>
<dl>
<dt>
 6.</dt>
<dd>
The token <b>ERE</b> represents an extended regular expression constant. An ERE constant shall begin with the slash character. Within an ERE constant, a backslash character shall be considered to begin an escape sequence as specified in the table in the Base Definitions volume of IEEE&#160;Std&#160;1003.1-2001, Chapter 5, File Format Notation. In addition, the escape sequences in Expressions in Decreasing Precedence in  <i>awk</i> shall be recognized. The application shall ensure that a &lt;newline&gt; does not occur within an ERE constant. An ERE constant shall be terminated by the first unescaped occurrence of the slash character after the one that begins the ERE constant. The extended regular expression represented by the ERE constant shall be the sequence of all unescaped characters and values of escape sequences between, but not including, the two delimiting slash characters.</dd>
</dl>
<dl>
<dt>
 7.</dt>
<dd>
A &lt;blank&gt; shall have no effect, except to delimit lexical tokens or within  <b>STRING</b> or <b>ERE</b> tokens.</dd>
</dl>
<dl>
<dt>
 8.</dt>
<dd>
The token <b>NUMBER</b> shall represent a numeric constant. Its form and numeric value shall be equivalent to either of the tokens  <b>floating-constant</b> or <b>integer-constant</b> as specified by the ISO&#160;C standard, with the following exceptions:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl>
<dt>
 a.</dt>
<dd>
An integer constant cannot begin with 0x or include the hexadecimal digits  <b>'a'</b>, <b>'b'</b>, <b>'c'</b>,  <b>'d'</b>, <b>'e'</b>, <b>'f'</b>, <b>'A'</b>, <b>'B'</b>, <b>'C'</b>,  <b>'D'</b>, <b>'E'</b>, or  <b>'F'</b> .</dd>
</dl>
<dl>
<dt>
 b.</dt>
<dd>
The value of an integer constant beginning with 0 shall be taken in decimal rather than octal.</dd>
</dl>
<dl>
<dt>
 c.</dt>
<dd>
An integer constant cannot include a suffix ( <b>'u'</b>, <b>'U'</b>,  <b>'l'</b>, or <b>'L'</b> ).</dd>
</dl>
<dl>
<dt>
 d.</dt>
<dd>
A floating constant cannot include a suffix ( <b>'f'</b>, <b>'F'</b>,  <b>'l'</b>, or <b>'L'</b> ).</dd>
</dl>
</div>
<div class="spacer">
</div>
If the value is too large or too small to be representable (see <i>Concepts</i>  <i>Derived from</i>  <i>the ISO C Standard</i> ), the behavior is undefined.<dl>
<dt>
 9.</dt>
<dd>
A sequence of underscores, digits, and alphabetics from the portable character set (see the Base Definitions volume of IEEE&#160;Std&#160;1003.1-2001, Section 6.1, Portable Character Set), beginning with an underscore or alphabetic, shall be considered a word.</dd>
</dl>
<dl>
<dt>
10.</dt>
<dd>
The following words are keywords that shall be recognized as individual tokens; the name of the token is the same as the keyword:<table class="tbl">
<col style="width: 32.00ex;"/>
<col style="width: 26.00ex;"/>
<col style="width: 24.00ex;"/>
<col style="width: 31.00ex;"/>
<col style="width: 25.00ex;"/>
<col style="width: 31.00ex;"/>
<tbody>
<tr>
<td>
<b>  BEGIN  break  continue  </b></td>
<td>
<b>  delete  do  else  </b></td>
<td>
<b>  END  exit  for  </b></td>
<td>
<b>  function  getline  if  </b></td>
<td>
<b>  in  next  print  </b></td>
<td>
<b>  printf  return  while  </b></td>
</tr>
</tbody>
</table>
</dd>
</dl>
<dl>
<dt>
11.</dt>
<dd>
The following words are names of built-in functions and shall be recognized as the token  <b>BUILTIN_FUNC_NAME</b>:<table class="tbl">
<col style="width: 32.00ex;"/>
<col style="width: 34.00ex;"/>
<col style="width: 31.00ex;"/>
<col style="width: 37.00ex;"/>
<col style="width: 38.00ex;"/>
<col style="width: 17.00ex;"/>
<tbody>
<tr>
<td>
<b>  atan2  close  cos  exp  </b></td>
<td>
<b>  gsub  index  int  length  </b></td>
<td>
<b>  log  match  rand  sin  </b></td>
<td>
<b>  split  sprintf  sqrt  srand  </b></td>
<td>
<b>  sub  substr  system  tolower  </b></td>
<td>
<b>  toupper  </b></td>
</tr>
</tbody>
</table>
</dd>
</dl>
<div class="spacer">
</div>
The above-listed keywords and names of built-in functions are considered reserved words.<dl>
<dt>
12.</dt>
<dd>
The token <b>NAME</b> shall consist of a word that is not a keyword or a name of a built-in function and is not followed immediately (without any delimiters) by the  <b>'('</b> character.</dd>
</dl>
<dl>
<dt>
13.</dt>
<dd>
The token <b>FUNC_NAME</b> shall consist of a word that is not a keyword or a name of a built-in function, followed immediately (without any delimiters) by the  <b>'('</b> character. The <b>'('</b> character shall not be included as part of the token.</dd>
</dl>
<dl>
<dt>
14.</dt>
<dd>
The following two-character sequences shall be recognized as the named tokens:<table class="tbl">
<col style="width: 16.00ex;"/>
<col style="width: 14.00ex;"/>
<col style="width: 16.00ex;"/>
<col style="width: 14.00ex;"/>
<tbody>
<tr>
<td>
<b>Token Name</b></td>
<td>
<b>Sequence</b></td>
<td>
<b>Token Name</b></td>
<td>
<b>Sequence</b></td>
</tr>
<tr>
<td>
<b>ADD_ASSIGN</b></td>
<td>
+=</td>
<td>
<b>NO_MATCH</b></td>
<td>
!~</td>
</tr>
<tr>
<td>
<b>SUB_ASSIGN</b></td>
<td>
-=</td>
<td>
<b>EQ</b></td>
<td>
==</td>
</tr>
<tr>
<td>
<b>MUL_ASSIGN</b></td>
<td>
*=</td>
<td>
<b>LE</b></td>
<td>
&lt;=</td>
</tr>
<tr>
<td>
<b>DIV_ASSIGN</b></td>
<td>
/=</td>
<td>
<b>GE</b></td>
<td>
&gt;=</td>
</tr>
<tr>
<td>
<b>MOD_ASSIGN</b></td>
<td>
%=</td>
<td>
<b>NE</b></td>
<td>
!=</td>
</tr>
<tr>
<td>
<b>POW_ASSIGN</b></td>
<td>
^=</td>
<td>
<b>INCR</b></td>
<td>
++</td>
</tr>
<tr>
<td>
<b>OR</b></td>
<td>
||</td>
<td>
<b>DECR</b></td>
<td>
--</td>
</tr>
<tr>
<td>
<b>AND</b></td>
<td>
&amp;&amp;</td>
<td>
<b>APPEND</b></td>
<td>
&gt;&gt;</td>
</tr>
</tbody>
</table>
</dd>
</dl>
<dl>
<dt>
15.</dt>
<dd>
The following single characters shall be recognized as tokens whose names are the character:<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>&lt;newline&gt; { } ( ) [ ] , ; + - * % ^ ! &gt; &lt; | ? : ~ $ =</b><br/>
<b></b><br/>
</div>
<div class="spacer">
</div>
There is a lexical ambiguity between the token <b>ERE</b> and the tokens  <b>'/'</b> and <b>DIV_ASSIGN</b>. When an input sequence begins with a slash character in any syntactic context where the token  <b>'/'</b> or <b>DIV_ASSIGN</b> could appear as the next token in a valid program, the longer of those two tokens that can be recognized shall be recognized. In any other syntactic context where the token  <b>ERE</b> could appear as the next token in a valid program, the token  <b>ERE</b> shall be recognized.</div>
</div>
<div class="section">
<h1>EXIT STATUS</h1> The following exit values shall be returned:<dl>
<dt>
&#160;0</dt>
<dd>
All input files were processed successfully.</dd>
</dl>
<dl>
<dt>
&gt;0</dt>
<dd>
An error occurred.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<div class="spacer">
</div>
The exit status can be altered within the program by using an <b>exit</b> expression.</div>
<div class="section">
<h1>CONSEQUENCES OF ERRORS</h1> If any  <i>file</i> operand is specified and the named file cannot be accessed,  <i>awk</i> shall write a diagnostic message to standard error and terminate without any further action.<div class="spacer">
</div>
If the program specified by either the <i>program</i> operand or a  <i>progfile</i> operand is not a valid <i>awk</i> program (as specified in the EXTENDED DESCRIPTION section), the behavior is undefined.<div class="spacer">
</div>
<i>The following sections are informative.</i></div>
<div class="section">
<h1>APPLICATION USAGE</h1> The  <b>index</b>, <b>length</b>, <b>match</b>, and <b>substr</b> functions should not be confused with similar functions in the ISO&#160;C standard; the  <i>awk</i> versions deal with characters, while the ISO&#160;C standard deals with bytes.<div class="spacer">
</div>
Because the concatenation operation is represented by adjacent expressions rather than an explicit operator, it is often necessary to use parentheses to enforce the proper evaluation precedence.</div>
<div class="section">
<h1>EXAMPLES</h1> The  <i>awk</i> program specified in the command line is most easily specified within single-quotes (for example, programs commonly contain characters that are special to the shell, including double-quotes. In the cases where an  <i>awk</i> program contains single-quote characters, it is usually easiest to specify most of the program as strings within single-quotes concatenated by the shell with quoted single-quote characters. For example:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>awk '/'\''/ { print &quot;quote:&quot;, $0 }'</b><br/>
<b></b><br/>
</div>
<div class="spacer">
</div>
prints all lines from the standard input containing a single-quote character, prefixed with  <i>quote</i>:.<div class="spacer">
</div>
The following are examples of simple <i>awk</i> programs:<dl>
<dt>
 1.</dt>
<dd>
Write to the standard output all input lines for which field 3 is greater than 5:<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>$3 &gt; 5</b><br/>
<b></b><br/>
</div>
<dl>
<dt>
 2.</dt>
<dd>
Write every tenth line:<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>(NR % 10) == 0</b><br/>
<b></b><br/>
</div>
<dl>
<dt>
 3.</dt>
<dd>
Write any line with a substring matching the regular expression:<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>/(G|D)(2[0-9][[:alpha:]]*)/</b><br/>
<b></b><br/>
</div>
<dl>
<dt>
 4.</dt>
<dd>
Print any line with a substring containing a <b>'G'</b> or <b>'D'</b>, followed by a sequence of digits and characters. This example uses character classes  <b>digit</b> and <b>alpha</b> to match language-independent digit and alphabetic characters respectively:<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>/(G|D)([[:digit:][:alpha:]]*)/</b><br/>
<b></b><br/>
</div>
<dl>
<dt>
 5.</dt>
<dd>
Write any line in which the second field matches the regular expression and the fourth field does not:<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>$2 ~ /xyz/ &amp;&amp; $4 !~ /xyz/</b><br/>
<b></b><br/>
</div>
<dl>
<dt>
 6.</dt>
<dd>
Write any line in which the second field contains a backslash:<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>$2 ~ /\\/</b><br/>
<b></b><br/>
</div>
<dl>
<dt>
 7.</dt>
<dd>
Write any line in which the second field contains a backslash. Note that backslash escapes are interpreted twice; once in lexical processing of the string and once in processing the regular expression:<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>$2 ~ &quot;\\\\&quot;</b><br/>
<b></b><br/>
</div>
<dl>
<dt>
 8.</dt>
<dd>
Write the second to the last and the last field in each line. Separate the fields by a colon:<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>{OFS=&quot;:&quot;;print $(NF-1), $NF}</b><br/>
<b></b><br/>
</div>
<dl>
<dt>
 9.</dt>
<dd>
Write the line number and number of fields in each line. The three strings representing the line number, the colon, and the number of fields are concatenated and that string is written to standard output:<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>{print NR &quot;:&quot; NF}</b><br/>
<b></b><br/>
</div>
<dl>
<dt>
10.</dt>
<dd>
Write lines longer than 72 characters:<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>length($0) &gt; 72</b><br/>
<b></b><br/>
</div>
<dl>
<dt>
11.</dt>
<dd>
Write the first two fields in opposite order separated by <b>OFS</b>:<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>{ print $2, $1 }</b><br/>
<b></b><br/>
</div>
<dl>
<dt>
12.</dt>
<dd>
Same, with input fields separated by a comma or &lt;space&gt;s and &lt;tab&gt;s, or both:<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>BEGIN { FS = &quot;,[ \t]*|[ \t]+&quot; }</b><br/>
<b>      { print $2, $1 }</b><br/>
<b></b><br/>
</div>
<dl>
<dt>
13.</dt>
<dd>
Add up the first column, print sum, and average:<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>     {s += $1 }</b><br/>
<b>END   {print &quot;sum is &quot;, s, &quot; average is&quot;, s/NR}</b><br/>
<b></b><br/>
</div>
<dl>
<dt>
14.</dt>
<dd>
Write fields in reverse order, one per line (many lines out for each line in):<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>{ for (i = NF; i &gt; 0; --i) print $i }</b><br/>
<b></b><br/>
</div>
<dl>
<dt>
15.</dt>
<dd>
Write all lines between occurrences of the strings <b>start</b> and  <b>stop</b>:<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>/start/, /stop/</b><br/>
<b></b><br/>
</div>
<dl>
<dt>
16.</dt>
<dd>
Write all lines whose first field is different from the previous one:<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>$1 != prev { print; prev = $1 }</b><br/>
<b></b><br/>
</div>
<dl>
<dt>
17.</dt>
<dd>
Simulate <i>echo</i>:<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>BEGIN  {</b><br/>
<b>        for (i = 1; i &lt; ARGC; ++i)</b><br/>
<b>        printf(&quot;%s%s&quot;, ARGV[i], i==ARGC-1?&quot;\n&quot;:&quot; &quot;)</b><br/>
<b>}</b><br/>
<b></b><br/>
</div>
<dl>
<dt>
18.</dt>
<dd>
Write the path prefixes contained in the <i>PATH</i> environment variable, one per line:<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>BEGIN  {</b><br/>
<b>        n = split (ENVIRON[&quot;PATH&quot;], path, &quot;:&quot;)</b><br/>
<b>        for (i = 1; i &lt;= n; ++i)</b><br/>
<b>        print path[i]</b><br/>
<b>}</b><br/>
<b></b><br/>
</div>
<dl>
<dt>
19.</dt>
<dd>
If there is a file named <b>input</b> containing page headers of the form:<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
Page #<br/>
</div>
<div class="spacer">
</div>
and a file named <b>program</b> that contains:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>/Page/   { $2 = n++; }</b><br/>
<b>         { print }</b><br/>
<b></b><br/>
</div>
<div class="spacer">
</div>
then the command line:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>awk -f program n=5 input</b><br/>
<b></b><br/>
</div>
<div class="spacer">
</div>
prints the file <b>input</b>, filling in page numbers starting at 5.</div>
<div class="section">
<h1>RATIONALE</h1> This description is based on the new  <i>awk</i>, &quot;nawk&quot;, (see the referenced  <i>The AWK Programming Language</i>), which introduced a number of new features to the historical  <i>awk</i>:<dl>
<dt>
 1.</dt>
<dd>
New keywords: <b>delete</b>, <b>do</b>, <b>function</b>, <b>return</b></dd>
</dl>
<dl>
<dt>
 2.</dt>
<dd>
New built-in functions: <b>atan2</b>, <b>close</b>, <b>cos</b>, <b>gsub</b>,  <b>match</b>, <b>rand</b>, <b>sin</b>,  <b>srand</b>, <b>sub</b>, <b>system</b></dd>
</dl>
<dl>
<dt>
 3.</dt>
<dd>
New predefined variables: <b>FNR</b>, <b>ARGC</b>, <b>ARGV</b>, <b>RSTART</b>,  <b>RLENGTH</b>, <b>SUBSEP</b></dd>
</dl>
<dl>
<dt>
 4.</dt>
<dd>
New expression operators: <b>?</b>, <b>:</b>, <b>,</b>, <b>^</b></dd>
</dl>
<dl>
<dt>
 5.</dt>
<dd>
The <b>FS</b> variable and the third argument to <b>split</b>, now treated as extended regular expressions.</dd>
</dl>
<dl>
<dt>
 6.</dt>
<dd>
The operator precedence, changed to more closely match the C language. Two examples of code that operate differently are:<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>while ( n /= 10 &gt; 1) ...</b><br/>
<b>if (!&quot;wk&quot; ~ /bwk/) ...</b><br/>
<b></b><br/>
</div>
<div class="spacer">
</div>
Several features have been added based on newer implementations of  <i>awk</i>:<dl>
<dt>
 *</dt>
<dd>
Multiple instances of <b>-f</b> <i>progfile</i> are permitted.</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
The new option <b>-v</b> <i>assignment.</i></dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
The new predefined variable <b>ENVIRON</b>.</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
New built-in functions <b>toupper</b> and <b>tolower</b>.</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
More formatting capabilities are added to <b>printf</b> to match the ISO&#160;C standard.</dd>
</dl>
<div class="spacer">
</div>
The overall <i>awk</i> syntax has always been based on the C language, with a few features from the shell command language and other sources. Because of this, it is not completely compatible with any other language, which has caused confusion for some users. It is not the intent of the standard developers to address such issues. A few relatively minor changes toward making the language more compatible with the ISO&#160;C standard were made; most of these changes are based on similar changes in recent implementations, as described above. There remain several C-language conventions that are not in  <i>awk</i>. One of the notable ones is the comma operator, which is commonly used to specify multiple expressions in the C language  <b>for</b> statement. Also, there are various places where  <i>awk</i> is more restrictive than the C language regarding the type of expression that can be used in a given context. These limitations are due to the different features that the  <i>awk</i> language does provide.<div class="spacer">
</div>
Regular expressions in <i>awk</i> have been extended somewhat from historical implementations to make them a pure superset of extended regular expressions, as defined by IEEE&#160;Std&#160;1003.1-2001 (see the Base Definitions volume of IEEE&#160;Std&#160;1003.1-2001, Section 9.4, Extended Regular Expressions). The main extensions are internationalization features and interval expressions. Historical implementations of  <i>awk</i> have long supported backslash escape sequences as an extension to extended regular expressions, and this extension has been retained despite inconsistency with other utilities. The number of escape sequences recognized in both extended regular expressions and strings has varied (generally increasing with time) among implementations. The set specified by IEEE&#160;Std&#160;1003.1-2001 includes most sequences known to be supported by popular implementations and by the ISO&#160;C standard. One sequence that is not supported is hexadecimal value escapes beginning with  <b>'\x'</b> . This would allow values expressed in more than 9 bits to be used within  <i>awk</i> as in the ISO&#160;C standard. However, because this syntax has a non-deterministic length, it does not permit the subsequent character to be a hexadecimal digit. This limitation can be dealt with in the C language by the use of lexical string concatenation. In the  <i>awk</i> language, concatenation could also be a solution for strings, but not for extended regular expressions (either lexical ERE tokens or strings used dynamically as regular expressions). Because of this limitation, the feature has not been added to IEEE&#160;Std&#160;1003.1-2001.<div class="spacer">
</div>
When a string variable is used in a context where an extended regular expression normally appears (where the lexical token ERE is used in the grammar) the string does not contain the literal slashes.<div class="spacer">
</div>
Some versions of <i>awk</i> allow the form:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>func name(args, ... ) { statements }</b><br/>
<b></b><br/>
</div>
<div class="spacer">
</div>
This has been deprecated by the authors of the language, who asked that it not be specified.<div class="spacer">
</div>
Historical implementations of <i>awk</i> produce an error if a <b>next</b> statement is executed in a  <b>BEGIN</b> action, and cause  <i>awk</i> to terminate if a <b>next</b> statement is executed in an  <b>END</b> action. This behavior has not been documented, and it was not believed that it was necessary to standardize it.<div class="spacer">
</div>
The specification of conversions between string and numeric values is much more detailed than in the documentation of historical implementations or in the referenced  <i>The AWK Programming Language</i>. Although most of the behavior is designed to be intuitive, the details are necessary to ensure compatible behavior from different implementations. This is especially important in relational expressions since the types of the operands determine whether a string or numeric comparison is performed. From the perspective of an application writer, it is usually sufficient to expect intuitive behavior and to force conversions (by adding zero or concatenating a null string) when the type of an expression does not obviously match what is needed. The intent has been to specify historical practice in almost all cases. The one exception is that, in historical implementations, variables and constants maintain both string and numeric values after their original value is converted by any use. This means that referencing a variable or constant can have unexpected side effects. For example, with historical implementations the following program:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>{</b><br/>
<b>    a = &quot;+2&quot;</b><br/>
<b>    b = 2</b><br/>
<b>    if (NR % 2)</b><br/>
<b>        c = a + b</b><br/>
<b>    if (a == b)</b><br/>
<b>        print &quot;numeric comparison&quot;</b><br/>
<b>    else</b><br/>
<b>        print &quot;string comparison&quot;</b><br/>
<b>}</b><br/>
<b></b><br/>
</div>
<div class="spacer">
</div>
would perform a numeric comparison (and output numeric comparison) for each odd-numbered line, but perform a string comparison (and output string comparison) for each even-numbered line. IEEE&#160;Std&#160;1003.1-2001 ensures that comparisons will be numeric if necessary. With historical implementations, the following program:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>BEGIN {</b><br/>
<b>    OFMT = &quot;%e&quot;</b><br/>
<b>    print 3.14</b><br/>
<b>    OFMT = &quot;%f&quot;</b><br/>
<b>    print 3.14</b><br/>
<b>}</b><br/>
<b></b><br/>
</div>
<div class="spacer">
</div>
would output <b>&quot;3.140000e+00&quot;</b> twice, because in the second <b>print</b> statement the constant  <b>&quot;3.14&quot;</b> would have a string value from the previous conversion. IEEE&#160;Std&#160;1003.1-2001 requires that the output of the second  <b>print</b> statement be  <b>&quot;3.140000&quot;</b> . The behavior of historical implementations was seen as too unintuitive and unpredictable.<div class="spacer">
</div>
It was pointed out that with the rules contained in early drafts, the following script would print nothing:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>BEGIN {</b><br/>
<b>    y[1.5] = 1</b><br/>
<b>    OFMT = &quot;%e&quot;</b><br/>
<b>    print y[1.5]</b><br/>
<b>}</b><br/>
<b></b><br/>
</div>
<div class="spacer">
</div>
Therefore, a new variable, <b>CONVFMT</b>, was introduced. The <b>OFMT</b> variable is now restricted to affecting output conversions of numbers to strings and  <b>CONVFMT</b> is used for internal conversions, such as comparisons or array indexing. The default value is the same as that for  <b>OFMT</b>, so unless a program changes  <b>CONVFMT</b> (which no historical program would do), it will receive the historical behavior associated with internal string conversions.<div class="spacer">
</div>
The POSIX <i>awk</i> lexical and syntactic conventions are specified more formally than in other sources. Again the intent has been to specify historical practice. One convention that may not be obvious from the formal grammar as in other verbal descriptions is where &lt;newline&gt;s are acceptable. There are several obvious placements such as terminating a statement, and a backslash can be used to escape &lt;newline&gt;s between any lexical tokens. In addition, &lt;newline&gt;s without backslashes can follow a comma, an open brace, a logical AND operator (  <b>&quot;&amp;&amp;&quot;</b> ), a logical OR operator (  <b>&quot;||&quot;</b> ), the <b>do</b> keyword, the  <b>else</b> keyword, and the closing parenthesis of an  <b>if</b>, <b>for</b>, or <b>while</b> statement. For example:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>{ print $1,</b><br/>
<b>        $2 }</b><br/>
<b></b><br/>
</div>
<div class="spacer">
</div>
The requirement that <i>awk</i> add a trailing &lt;newline&gt; to the program argument text is to simplify the grammar, making it match a text file in form. There is no way for an application or test suite to determine whether a literal &lt;newline&gt; is added or whether  <i>awk</i> simply acts as if it did.<div class="spacer">
</div>
IEEE&#160;Std&#160;1003.1-2001 requires several changes from historical implementations in order to support internationalization. Probably the most subtle of these is the use of the decimal-point character, defined by the  <i>LC_NUMERIC</i> category of the locale, in representations of floating-point numbers. This locale-specific character is used in recognizing numeric input, in converting between strings and numeric values, and in formatting output. However, regardless of locale, the period character (the decimal-point character of the POSIX locale) is the decimal-point character recognized in processing  <i>awk</i> programs (including assignments in command line arguments). This is essentially the same convention as the one used in the ISO&#160;C standard. The difference is that the C language includes the  <i>setlocale</i>() function, which permits an application to modify its locale. Because of this capability, a C application begins executing with its locale set to the C locale, and only executes in the environment-specified locale after an explicit call to  <i>setlocale</i>(). However, adding such an elaborate new feature to the  <i>awk</i> language was seen as inappropriate for IEEE&#160;Std&#160;1003.1-2001. It is possible to execute an  <i>awk</i> program explicitly in any desired locale by setting the environment in the shell.<div class="spacer">
</div>
The undefined behavior resulting from NULs in extended regular expressions allows future extensions for the GNU  <i>gawk</i> program to process binary data.<div class="spacer">
</div>
The behavior in the case of invalid <i>awk</i> programs (including lexical, syntactic, and semantic errors) is undefined because it was considered overly limiting on implementations to specify. In most cases such errors can be expected to produce a diagnostic and a non-zero exit status. However, some implementations may choose to extend the language in ways that make use of certain invalid constructs. Other invalid constructs might be deemed worthy of a warning, but otherwise cause some reasonable behavior. Still other constructs may be very difficult to detect in some implementations. Also, different implementations might detect a given error during an initial parsing of the program (before reading any input files) while others might detect it when executing the program after reading some input. Implementors should be aware that diagnosing errors as early as possible and producing useful diagnostics can ease debugging of applications, and thus make an implementation more usable.<div class="spacer">
</div>
The unspecified behavior from using multi-character <b>RS</b> values is to allow possible future extensions based on extended regular expressions used for record separators. Historical implementations take the first character of the string and ignore the others.<div class="spacer">
</div>
Unspecified behavior when <i>split</i>( <i>string</i>, <i>array</i>, &lt;null&gt;) is used is to allow a proposed future extension that would split up a string into an array of individual characters.<div class="spacer">
</div>
In the context of the <b>getline</b> function, equally good arguments for different precedences of the  <b>|</b> and <b>&lt;</b> operators can be made. Historical practice has been that:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>getline &lt; &quot;a&quot; &quot;b&quot;</b><br/>
<b></b><br/>
</div>
<div class="spacer">
</div>
is parsed as:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>( getline &lt; &quot;a&quot; ) &quot;b&quot;</b><br/>
<b></b><br/>
</div>
<div class="spacer">
</div>
although many would argue that the intent was that the file <b>ab</b> should be read. However:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>getline &lt; &quot;x&quot; + 1</b><br/>
<b></b><br/>
</div>
<div class="spacer">
</div>
parses as:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>getline &lt; ( &quot;x&quot; + 1 )</b><br/>
<b></b><br/>
</div>
<div class="spacer">
</div>
Similar problems occur with the <b>|</b> version of <b>getline</b>, particularly in combination with  <b>$</b>. For example:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>$&quot;echo hi&quot; | getline</b><br/>
<b></b><br/>
</div>
<div class="spacer">
</div>
(This situation is particularly problematic when used in a <b>print</b> statement, where the  <b>|getline</b> part might be a redirection of the  <b>print</b>.)<div class="spacer">
</div>
Since in most cases such constructs are not (or at least should not) be used (because they have a natural ambiguity for which there is no conventional parsing), the meaning of these constructs has been made explicitly unspecified. (The effect is that a conforming application that runs into the problem must parenthesize to resolve the ambiguity.) There appeared to be few if any actual uses of such constructs.<div class="spacer">
</div>
Grammars can be written that would cause an error under these circumstances. Where backwards-compatibility is not a large consideration, implementors may wish to use such grammars.<div class="spacer">
</div>
Some historical implementations have allowed some built-in functions to be called without an argument list, the result being a default argument list chosen in some &quot;reasonable&quot; way. Use of  <b>length</b> as a synonym for  <b>length($0)</b> is the only one of these forms that is thought to be widely known or widely used; this particular form is documented in various places (for example, most historical  <i>awk</i> reference pages, although not in the referenced  <i>The AWK Programming Language</i>) as legitimate practice. With this exception, default argument lists have always been undocumented and vaguely defined, and it is not at all clear how (or if) they should be generalized to user-defined functions. They add no useful functionality and preclude possible future extensions that might need to name functions without calling them. Not standardizing them seems the simplest course. The standard developers considered that  <b>length</b> merited special treatment, however, since it has been documented in the past and sees possibly substantial use in historical programs. Accordingly, this usage has been made legitimate, but Issue&#160;5 removed the obsolescent marking for XSI-conforming implementations and many otherwise conforming applications depend on this feature.<div class="spacer">
</div>
In <b>sub</b> and <b>gsub</b>, if <i>repl</i> is a string literal (the lexical token  <b>STRING</b>), then two consecutive backslash characters should be used in the string to ensure a single backslash will precede the ampersand when the resultant string is passed to the function. (For example, to specify one literal ampersand in the replacement string, use  <b>gsub</b>( <b>ERE</b>,  <b>&quot;\\&amp;&quot;</b> ).)<div class="spacer">
</div>
Historically the only special character in the <i>repl</i> argument of  <b>sub</b> and <b>gsub</b> string functions was the ampersand (  <b>'&amp;'</b> ) character and preceding it with the backslash character was used to turn off its special meaning.<div class="spacer">
</div>
The description in the ISO&#160;POSIX-2:1993 standard introduced behavior such that the backslash character was another special character and it was unspecified whether there were any other special characters. This description introduced several portability problems, some of which are described below, and so it has been replaced with the more historical description. Some of the problems include:<dl>
<dt>
 *</dt>
<dd>
Historically, to create the replacement string, a script could use  <b>gsub</b>( <b>ERE</b>, <b>&quot;\\&amp;&quot;</b> ), but with the ISO&#160;POSIX-2:1993 standard wording, it was necessary to use  <b>gsub</b>(  <b>ERE</b>, <b>&quot;\\\\&amp;&quot;</b> ). Backslash characters are doubled here because all string literals are subject to lexical analysis, which would reduce each pair of backslash characters to a single backslash before being passed to  <b>gsub</b>.</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
Since it was unspecified what the special characters were, for portable scripts to guarantee that characters are printed literally, each character had to be preceded with a backslash. (For example, a portable script had to use  <b>gsub</b>( <b>ERE</b>,  <b>&quot;\\h\\i&quot;</b> ) to produce a replacement string of <b>&quot;hi&quot;</b> .)</dd>
</dl>
<div class="spacer">
</div>
The description for comparisons in the ISO&#160;POSIX-2:1993 standard did not properly describe historical practice because of the way numeric strings are compared as numbers. The current rules cause the following code:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>if (0 == &quot;000&quot;)</b><br/>
<b>    print &quot;strange, but true&quot;</b><br/>
<b>else</b><br/>
<b>    print &quot;not true&quot;</b><br/>
<b></b><br/>
</div>
<div class="spacer">
</div>
to do a numeric comparison, causing the <b>if</b> to succeed. It should be intuitively obvious that this is incorrect behavior, and indeed, no historical implementation of  <i>awk</i> actually behaves this way.<div class="spacer">
</div>
To fix this problem, the definition of <i>numeric string</i> was enhanced to include only those values obtained from specific circumstances (mostly external sources) where it is not possible to determine unambiguously whether the value is intended to be a string or a numeric.<div class="spacer">
</div>
Variables that are assigned to a numeric string shall also be treated as a numeric string. (For example, the notion of a numeric string can be propagated across assignments.) In comparisons, all variables having the uninitialized value are to be treated as a numeric operand evaluating to the numeric value zero.<div class="spacer">
</div>
Uninitialized variables include all types of variables including scalars, array elements, and fields. The definition of an uninitialized value in Variables and Special Variables is necessary to describe the value placed on uninitialized variables and on fields that are valid (for example,  <b>&lt;</b> <b>$NF</b>) but have no characters in them and to describe how these variables are to be used in comparisons. A valid field, such as  <b>$1</b>, that has no characters in it can be obtained from an input line of  <b>&quot;\t\t&quot;</b> when <b>FS=</b> <b>'\t'</b> . Historically, the comparison (  <b>$1&lt;</b>10) was done numerically after evaluating  <b>$1</b> to the value zero.<div class="spacer">
</div>
The phrase &quot;... also shall have the numeric value of the numeric string&quot; was removed from several sections of the ISO&#160;POSIX-2:1993 standard because is specifies an unnecessary implementation detail. It is not necessary for IEEE&#160;Std&#160;1003.1-2001 to specify that these objects be assigned two different values. It is only necessary to specify that these objects may evaluate to two different values depending on context.<div class="spacer">
</div>
The description of numeric string processing is based on the behavior of the  <i>atof</i>() function in the ISO&#160;C standard. While it is not a requirement for an implementation to use this function, many historical implementations of  <i>awk</i> do. In the ISO&#160;C standard, floating-point constants use a period as a decimal point character for the language itself, independent of the current locale, but the  <i>atof</i>() function and the associated  <i>strtod</i>() function use the decimal point character of the current locale when converting strings to numeric values. Similarly in  <i>awk</i>, floating-point constants in an  <i>awk</i> script use a period independent of the locale, but input strings use the decimal point character of the locale.</div>
<div class="section">
<h1>FUTURE DIRECTIONS</h1> None.</div>
<div class="section">
<h1>SEE ALSO</h1>  <i>Grammar Conventions</i>, <i>grep</i>, <i>lex</i>, <i>sed</i>, the System Interfaces volume of IEEE&#160;Std&#160;1003.1-2001,  <i>atof</i>(),  <i>exec</i>, <i>popen</i>(), <i>setlocale</i>(), <i>strtod</i>()</div>
<div class="section">
<h1>COPYRIGHT</h1> Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1, 2003 Edition, Standard for Information Technology -- Portable Operating System Interface (POSIX), The Open Group Base Specifications Issue 6, Copyright (C) 2001-2003 by the Institute of Electrical and Electronics Engineers, Inc and The Open Group. In the event of any discrepancy between this version and the original IEEE and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document. The original Standard can be obtained online at http://www.opengroup.org/unix/online.html .</div>
<table class="foot">
<tr>
<td class="foot-date">
2003</td>
<td class="foot-os">
IEEE/The Open Group</td>
</tr>
</table>
</div>
</body>
</html>

