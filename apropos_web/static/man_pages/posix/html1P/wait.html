<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/posix/style.css" type="text/css" media="all"/>
<title>
WAIT(1P)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
WAIT(1P)</td>
<td class="head-vol">
POSIX Programmer's Manual</td>
<td class="head-rtitle">
WAIT(1P)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>PROLOG</h1> This manual page is part of the POSIX Programmer's Manual. The Linux implementation of this interface may differ (consult the corresponding Linux manual page for details of Linux behavior), or the interface may not be implemented on Linux.</div>
<div class="section">
<h1>NAME</h1> wait - await process completion</div>
<div class="section">
<h1>SYNOPSIS</h1>  <b>wait</b> <b>[</b><i>pid</i><b>...</b><b>]</b></div>
<div class="section">
<h1>DESCRIPTION</h1> When an asynchronous list (see  <i>Asynchronous Lists</i> ) is started by the shell, the process ID of the last command in each element of the asynchronous list shall become known in the current shell execution environment; see  <i>Shell Execution Environment</i> .<div class="spacer">
</div>
If the <i>wait</i> utility is invoked with no operands, it shall wait until all process IDs known to the invoking shell have terminated and exit with a zero exit status.<div class="spacer">
</div>
If one or more <i>pid</i> operands are specified that represent known process IDs, the  <i>wait</i> utility shall wait until all of them have terminated. If one or more  <i>pid</i> operands are specified that represent unknown process IDs,  <i>wait</i> shall treat them as if they were known process IDs that exited with exit status 127. The exit status returned by the  <i>wait</i> utility shall be the exit status of the process requested by the last  <i>pid</i> operand.<div class="spacer">
</div>
The known process IDs are applicable only for invocations of <i>wait</i> in the current shell execution environment.</div>
<div class="section">
<h1>OPTIONS</h1> None.</div>
<div class="section">
<h1>OPERANDS</h1> The following operand shall be supported:<dl>
<dt>
<i>pid</i></dt>
<dd>
One of the following:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl>
<dt>
 1.</dt>
<dd>
The unsigned decimal integer process ID of a command, for which the utility is to wait for the termination.</dd>
</dl>
<dl>
<dt>
 2.</dt>
<dd>
A job control job ID (see the Base Definitions volume of IEEE&#160;Std&#160;1003.1-2001, Section 3.203, Job Control Job ID) that identifies a background process group to be waited for. The job control job ID notation is applicable only for invocations of  <i>wait</i> in the current shell execution environment; see  <i>Shell Execution Environment</i> . The exit status of  <i>wait</i> shall be determined by the last command in the pipeline.</dd>
</dl>
<dl>
<dt>
<b>Note:</b></dt>
<dd>
<div style="margin-left: 5.00ex;">
The job control job ID type of <i>pid</i> is only available on systems supporting the User Portability Utilities option.</div>
<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>STDIN</h1> Not used.</div>
<div class="section">
<h1>INPUT FILES</h1> None.</div>
<div class="section">
<h1>ENVIRONMENT VARIABLES</h1> The following environment variables shall affect the execution of  <i>wait</i>:<dl>
<dt>
<i>LANG</i></dt>
<dd>
Provide a default value for the internationalization variables that are unset or null. (See the Base Definitions volume of IEEE&#160;Std&#160;1003.1-2001, Section 8.2, Internationalization Variables for the precedence of internationalization variables used to determine the values of locale categories.)</dd>
</dl>
<dl>
<dt>
<i>LC_ALL</i></dt>
<dd>
If set to a non-empty string value, override the values of all the other internationalization variables.</dd>
</dl>
<dl>
<dt>
<i>LC_CTYPE</i></dt>
<dd>
Determine the locale for the interpretation of sequences of bytes of text data as characters (for example, single-byte as opposed to multi-byte characters in arguments).</dd>
</dl>
<dl>
<dt>
<i>LC_MESSAGES</i></dt>
<dd>
Determine the locale that should be used to affect the format and contents of diagnostic messages written to standard error.</dd>
</dl>
<dl>
<dt>
<i>NLSPATH</i></dt>
<dd>
Determine the location of message catalogs for the processing of <i>LC_MESSAGES</i>  <i>.</i><div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
</div>
<div class="section">
<h1>ASYNCHRONOUS EVENTS</h1> Default.</div>
<div class="section">
<h1>STDOUT</h1> Not used.</div>
<div class="section">
<h1>STDERR</h1> The standard error shall be used only for diagnostic messages.</div>
<div class="section">
<h1>OUTPUT FILES</h1> None.</div>
<div class="section">
<h1>EXTENDED DESCRIPTION</h1> None.</div>
<div class="section">
<h1>EXIT STATUS</h1> If one or more operands were specified, all of them have terminated or were not known by the invoking shell, and the status of the last operand specified is known, then the exit status of  <i>wait</i> shall be the exit status information of the command indicated by the last operand specified. If the process terminated abnormally due to the receipt of a signal, the exit status shall be greater than 128 and shall be distinct from the exit status generated by other signals, but the exact value is unspecified. (See the  <i>kill</i> <b>-l</b> option.) Otherwise, the <i>wait</i> utility shall exit with one of the following values:<dl>
<dt>
&#160;&#160;&#160;&#160;0</dt>
<dd>
The <i>wait</i> utility was invoked with no operands and all process IDs known by the invoking shell have terminated.</dd>
</dl>
<dl>
<dt>
1-126</dt>
<dd>
The <i>wait</i> utility detected an error.</dd>
</dl>
<dl>
<dt>
&#160;&#160;127</dt>
<dd>
The command identified by the last <i>pid</i> operand specified is unknown.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
</div>
<div class="section">
<h1>CONSEQUENCES OF ERRORS</h1> Default.<div class="spacer">
</div>
<i>The following sections are informative.</i></div>
<div class="section">
<h1>APPLICATION USAGE</h1> On most implementations,  <i>wait</i> is a shell built-in. If it is called in a subshell or separate utility execution environment, such as one of the following:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>(wait)</b><br/>
<b>nohup wait ...</b><br/>
<b>find . -exec wait ... \;</b><br/>
<b></b><br/>
</div>
<div class="spacer">
</div>
it returns immediately because there are no known process IDs to wait for in those environments.<div class="spacer">
</div>
Historical implementations of interactive shells have discarded the exit status of terminated background processes before each shell prompt. Therefore, the status of background processes was usually lost unless it terminated while  <i>wait</i> was waiting for it. This could be a serious problem when a job that was expected to run for a long time actually terminated quickly with a syntax or initialization error because the exit status returned was usually zero if the requested process ID was not found. This volume of IEEE&#160;Std&#160;1003.1-2001 requires the implementation to keep the status of terminated jobs available until the status is requested, so that scripts like:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>j1&amp;</b><br/>
<b>p1=$!</b><br/>
<b>j2&amp;</b><br/>
<b>wait $p1</b><br/>
<b>echo Job 1 exited with status $?</b><br/>
<b>wait $!</b><br/>
<b>echo Job 2 exited with status $?</b><br/>
<b></b><br/>
</div>
<div class="spacer">
</div>
work without losing status on any of the jobs. The shell is allowed to discard the status of any process if it determines that the application cannot get the process ID for that process from the shell. It is also required to remember only {CHILD_MAX} number of processes in this way. Since the only way to get the process ID from the shell is by using the  <b>'!'</b> shell parameter, the shell is allowed to discard the status of an asynchronous list if  <b>&quot;$!&quot;</b> was not referenced before another asynchronous list was started. (This means that the shell only has to keep the status of the last asynchronous list started if the application did not reference  <b>&quot;$!&quot;</b> . If the implementation of the shell is smart enough to determine that a reference to  <b>&quot;$!&quot;</b> was not saved anywhere that the application can retrieve it later, it can use this information to trim the list of saved information. Note also that a successful call to  <i>wait</i> with no operands discards the exit status of all asynchronous lists.)<div class="spacer">
</div>
If the exit status of <i>wait</i> is greater than 128, there is no way for the application to know if the waited-for process exited with that value or was killed by a signal. Since most utilities exit with small values, there is seldom any ambiguity. Even in the ambiguous cases, most applications just need to know that the asynchronous job failed; it does not matter whether it detected an error and failed or was killed and did not complete its job normally.</div>
<div class="section">
<h1>EXAMPLES</h1> Although the exact value used when a process is terminated by a signal is unspecified, if it is known that a signal terminated a process, a script can still reliably determine which signal by using  <i>kill</i> as shown by the following script:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>sleep 1000&amp;</b><br/>
<b>pid=$!</b><br/>
<b>kill -kill $pid</b><br/>
<b>wait $pid</b><br/>
<b>echo $pid was terminated by a SIG$(kill -l $?) signal.</b><br/>
<b></b><br/>
</div>
<div class="spacer">
</div>
If the following sequence of commands is run in less than 31 seconds:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>sleep 257 | sleep 31 &amp;</b><br/>
<b>jobs -l %%</b><br/>
<b></b><br/>
</div>
<div class="spacer">
</div>
either of the following commands returns the exit status of the second  <i>sleep</i> in the pipeline:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>wait</b> <i>&lt;pid of sleep 31&gt;</i><b>wait %%</b><br/>
<b></b><br/>
</div>
</div>
<div class="section">
<h1>RATIONALE</h1> The description of  <i>wait</i> does not refer to the <i>waitpid</i>() function from the System Interfaces volume of IEEE&#160;Std&#160;1003.1-2001 because that would needlessly overspecify this interface. However, the wording means that  <i>wait</i> is required to wait for an explicit process when it is given an argument so that the status information of other processes is not consumed. Historical implementations use the  <i>wait</i>() function defined in the System Interfaces volume of IEEE&#160;Std&#160;1003.1-2001 until  <i>wait</i>() returns the requested process ID or finds that the requested process does not exist. Because this means that a shell script could not reliably get the status of all background children if a second background job was ever started before the first job finished, it is recommended that the  <i>wait</i> utility use a method such as the functionality provided by the  <i>waitpid</i>() function.<div class="spacer">
</div>
The ability to wait for multiple <i>pid</i> operands was adopted from the KornShell.<div class="spacer">
</div>
This new functionality was added because it is needed to determine the exit status of any asynchronous list accurately. The only compatibility problem that this change creates is for a script like<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>while sleep 60 do</b><br/>
<b>    job&amp; echo Job started $(date) as $!  done</b><br/>
<b></b><br/>
</div>
<div class="spacer">
</div>
which causes the shell to monitor all of the jobs started until the script terminates or runs out of memory. This would not be a problem if the loop did not reference  <b>&quot;$!&quot;</b> or if the script would occasionally  <i>wait</i> for jobs it started.</div>
<div class="section">
<h1>FUTURE DIRECTIONS</h1> None.</div>
<div class="section">
<h1>SEE ALSO</h1>  <i>Shell Command Language</i>, <i>kill</i>(), <i>sh</i>, the System Interfaces volume of IEEE&#160;Std&#160;1003.1-2001,  <i>wait</i>(), <i>waitpid</i>()</div>
<div class="section">
<h1>COPYRIGHT</h1> Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1, 2003 Edition, Standard for Information Technology -- Portable Operating System Interface (POSIX), The Open Group Base Specifications Issue 6, Copyright (C) 2001-2003 by the Institute of Electrical and Electronics Engineers, Inc and The Open Group. In the event of any discrepancy between this version and the original IEEE and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document. The original Standard can be obtained online at http://www.opengroup.org/unix/online.html .</div>
<table class="foot">
<tr>
<td class="foot-date">
2003</td>
<td class="foot-os">
IEEE/The Open Group</td>
</tr>
</table>
</div>
</body>
</html>

