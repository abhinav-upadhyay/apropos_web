<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Man page of GETOPT</TITLE>
</HEAD><BODY>
<H1>GETOPT</H1>
Section: POSIX Programmer's Manual (3P)<BR>Updated: 2003<BR><A HREF="#index">Index</A>
<A HREF="/cgi-bin/man/man2html">Return to Main Contents</A><HR>


<A NAME="lbAB">&nbsp;</A>
<H2>PROLOG</H2>

This manual page is part of the POSIX Programmer's Manual.
The Linux implementation of this interface may differ (consult
the corresponding Linux manual page for details of Linux behavior),
or the interface may not be implemented on Linux.
<A NAME="lbAC">&nbsp;</A>
<H2>NAME</H2>

getopt, optarg, opterr, optind, optopt - command option parsing
<A NAME="lbAD">&nbsp;</A>
<H2>SYNOPSIS</H2>

<P>

<B>#include &lt;<A HREF="file:///usr/include/unistd.h">unistd.h</A>&gt;
<BR>

<P>
int getopt(int</B> <I>argc</I><B>, char * const</B> <I>argv</I><B>[],
const char *</B><I>optstring</I><B>);
<BR>

extern char *optarg;
<BR>

extern int optind, opterr, optopt;
<BR>

</B>
<A NAME="lbAE">&nbsp;</A>
<H2>DESCRIPTION</H2>

<P>

The <I>getopt</I>() function is a command-line parser that shall follow
Utility Syntax Guidelines 3, 4, 5, 6, 7, 9, and 10 in
the Base Definitions volume of IEEE&nbsp;Std&nbsp;1003.1-2001, Section 12.2,
Utility Syntax Guidelines.
<P>

The parameters <I>argc</I> and <I>argv</I> are the argument count and
argument array as passed to <I>main</I>() (see <I>exec</I>()). The
argument <I>optstring</I> is a string of recognized
option characters; if a character is followed by a colon, the option
takes an argument. All option characters allowed by Utility
Syntax Guideline 3 are allowed in <I>optstring</I>. The implementation
may accept other characters as an extension.
<P>

The variable <I>optind</I> is the index of the next element of the
<I>argv</I>[] vector to be processed. It shall be initialized
to 1 by the system, and <I>getopt</I>() shall update it when it finishes
with each element of <I>argv</I>[]. When an element of
<I>argv</I>[] contains multiple option characters, it is unspecified
how <I>getopt</I>() determines which options have already been
processed.
<P>

The <I>getopt</I>() function shall return the next option character
(if one is found) from <I>argv</I> that matches a character
in <I>optstring</I>, if there is one that matches. If the option takes
an argument, <I>getopt</I>() shall set the variable
<I>optarg</I> to point to the option-argument as follows:
<DL COMPACT>
<DT> 1.<DD>
If the option was the last character in the string pointed to by an
element of <I>argv</I>, then <I>optarg</I> shall contain the
next element of <I>argv</I>, and <I>optind</I> shall be incremented
by 2. If the resulting value of <I>optind</I> is greater than
<I>argc</I>, this indicates a missing option-argument, and <I>getopt</I>()
shall return an error indication.
</DL>
<P>

<DL COMPACT>
<DT> 2.<DD>
Otherwise, <I>optarg</I> shall point to the string following the option
character in that element of <I>argv</I>, and
<I>optind</I> shall be incremented by 1.
</DL>
<P>

<P>

If, when <I>getopt</I>() is called:
<P>
<DL COMPACT><DT><DD>
<PRE>

<I>argv</I><B>[optind]</B>  is a null pointer<B>*</B>
<I>argv</I><B>[optind]</B>  is not the character <B>- </B> 
<I>argv</I><B>[optind]</B>  points to the string <B>&quot;-&quot;</B>
</PRE>

</DL>

<P>

<I>getopt</I>() shall return -1 without changing <I>optind</I>. If:
<P>
<DL COMPACT><DT><DD>
<PRE>

<I>argv</I><B>[optind] </B>  points to the string <B>&quot;--&quot;
</B>
</PRE>

</DL>

<P>

<I>getopt</I>() shall return -1 after incrementing <I>optind</I>.
<P>

If <I>getopt</I>() encounters an option character that is not contained
in <I>optstring</I>, it shall return the question-mark (
<B>'?'</B> ) character. If it detects a missing option-argument, it
shall return the colon character ( <B>':'</B> ) if the
first character of <I>optstring</I> was a colon, or a question-mark
character ( <B>'?'</B> ) otherwise. In either case,
<I>getopt</I>() shall set the variable <I>optopt</I> to the option character
that caused the error. If the application has not set
the variable <I>opterr</I> to 0 and the first character of <I>optstring</I>
is not a colon, <I>getopt</I>() shall also print a
diagnostic message to <I>stderr</I> in the format specified for the
<I>getopts</I>
utility.
<P>

The <I>getopt</I>() function need not be reentrant. A function that
is not required to be reentrant is not required to be
thread-safe.
<A NAME="lbAF">&nbsp;</A>
<H2>RETURN VALUE</H2>

<P>

The <I>getopt</I>() function shall return the next option character
specified on the command line.
<P>

A colon ( <B>':'</B> ) shall be returned if <I>getopt</I>() detects
a missing argument and the first character of
<I>optstring</I> was a colon ( <B>':'</B> ).
<P>

A question mark ( <B>'?'</B> ) shall be returned if <I>getopt</I>()
encounters an option character not in <I>optstring</I> or
detects a missing argument and the first character of <I>optstring</I>
was not a colon ( <B>':'</B> ).
<P>

Otherwise, <I>getopt</I>() shall return -1 when all command line options
are parsed.
<A NAME="lbAG">&nbsp;</A>
<H2>ERRORS</H2>

<P>

No errors are defined.
<P>

<I>The following sections are informative.</I>
<A NAME="lbAH">&nbsp;</A>
<H2>EXAMPLES</H2>

<A NAME="lbAI">&nbsp;</A>
<H3>Parsing Command Line Options</H3>

<P>

The following code fragment shows how you might process the arguments
for a utility that can take the mutually-exclusive options
<I>a</I> and <I>b</I> and the options <I>f</I> and <I>o</I>, both of which
require arguments:
<P>
<DL COMPACT><DT><DD>
<PRE>

<B>#include &lt;<A HREF="file:///usr/include/unistd.h">unistd.h</A>&gt;


int
main(int argc, char *argv[ ])
{
    int c;
    int bflg, aflg, errflg;
    char *ifile;
    char *ofile;
    extern char *optarg;
    extern int optind, optopt;
    . . .
    while ((c = getopt(argc, argv, &quot;:abf:o:&quot;)) != -1) {
        switch(c) {
        case 'a':
            if (bflg)
                errflg++;
            else
                aflg++;
            break;
        case 'b':
            if (aflg)
                errflg++;
            else {
                bflg++;
                bproc();
            }
            break;
        case 'f':
            ifile = optarg;
            break;
        case 'o':
            ofile = optarg;
            break;
            case ':':       /* -f or -o without operand */
                    fprintf(stderr,
                            &quot;Option -%c requires an operand\n&quot;, optopt);
                    errflg++;
                    break;
        case '?':
                    fprintf(stderr,
                            &quot;Unrecognized option: -%c\n&quot;, optopt);
            errflg++;
        }
    }
    if (errflg) {
        fprintf(stderr, &quot;usage: . . . &quot;);
        <A HREF="/cgi-bin/man/man2html?2+exit">exit</A>(2);
    }
    for ( ; optind &lt; argc; optind++) {
        if (access(argv[optind], R_OK)) {
    . . .
}
</B>
</PRE>

</DL>

<P>

This code accepts any of the following as equivalent:
<P>
<DL COMPACT><DT><DD>
<PRE>

<B>cmd -ao arg path path
cmd -a -o arg path path
cmd -o arg -a path path
cmd -a -o arg -- path path
cmd -a -oarg path path
cmd -aoarg path path
</B>
</PRE>

</DL>

<A NAME="lbAJ">&nbsp;</A>
<H3>Checking Options and Arguments</H3>

<P>

The following example parses a set of command line options and prints
messages to standard output for each option and argument
that it encounters.
<P>
<DL COMPACT><DT><DD>
<PRE>

<B>#include &lt;<A HREF="file:///usr/include/unistd.h">unistd.h</A>&gt;
#include &lt;<A HREF="file:///usr/include/stdio.h">stdio.h</A>&gt;
...
int c;
char *filename;
extern char *optarg;
extern int optind, optopt, opterr;
...
while ((c = getopt(argc, argv, &quot;:abf:&quot;)) != -1) {
    switch(c) {
    case 'a':
        printf(&quot;a is set\n&quot;);
        break;
    case 'b':
        printf(&quot;b is set\n&quot;);
        break;
    case 'f':
        filename = optarg;
        printf(&quot;filename is %s\n&quot;, filename);
        break;
    case ':':
        printf(&quot;-%c without filename\n&quot;, optopt);
        break;
    case '?':
        printf(&quot;unknown arg %c\n&quot;, optopt);
        break;
    }
}
</B>
</PRE>

</DL>

<A NAME="lbAK">&nbsp;</A>
<H3>Selecting Options from the Command Line</H3>

<P>

The following example selects the type of database routines the user
wants to use based on the <I>Options</I> argument.
<P>
<DL COMPACT><DT><DD>
<PRE>

<B>#include &lt;<A HREF="file:///usr/include/unistd.h">unistd.h</A>&gt;
#include &lt;<A HREF="file:///usr/include/string.h">string.h</A>&gt;
...
char *Options = &quot;hdbtl&quot;;
...
int dbtype, i;
char c;
char *st;
...
dbtype = 0;
while ((c = getopt(argc, argv, Options)) != -1) {
    if ((st = strchr(Options, c)) != NULL) {
        dbtype = st - Options;
        break;
    }
}
</B>
</PRE>

</DL>

<A NAME="lbAL">&nbsp;</A>
<H2>APPLICATION USAGE</H2>

<P>

The <I>getopt</I>() function is only required to support option characters
included in Utility Syntax Guideline 3. Many
historical implementations of <I>getopt</I>() support other characters
as options. This is an allowed extension, but applications
that use extensions are not maximally portable. Note that support
for multi-byte option characters is only possible when such
characters can be represented as type <B>int</B>.
<A NAME="lbAM">&nbsp;</A>
<H2>RATIONALE</H2>

<P>

The <I>optopt</I> variable represents historical practice and allows
the application to obtain the identity of the invalid
option.
<P>

The description has been written to make it clear that <I>getopt</I>(),
like the <I>getopts</I> utility, deals with option-arguments whether
separated from the option by
&lt;blank&gt;s or not. Note that the requirements on <I>getopt</I>() and
<I>getopts</I> are
more stringent than the Utility Syntax Guidelines.
<P>

The <I>getopt</I>() function shall return -1, rather than EOF, so that
<I>&lt;<A HREF="file:///usr/include/stdio.h">stdio.h</A>&gt;</I> is not required.
<P>

The special significance of a colon as the first character of <I>optstring</I>
makes <I>getopt</I>() consistent with the <I>getopts</I> utility. It
allows an application to make a distinction between a missing
argument and an incorrect option letter without having to examine
the option letter. It is true that a missing argument can only be
detected in one case, but that is a case that has to be considered.
<A NAME="lbAN">&nbsp;</A>
<H2>FUTURE DIRECTIONS</H2>

<P>

None.
<A NAME="lbAO">&nbsp;</A>
<H2>SEE ALSO</H2>

<P>

<I>exec</I>(), the Base Definitions volume of
IEEE&nbsp;Std&nbsp;1003.1-2001, <I>&lt;<A HREF="file:///usr/include/unistd.h">unistd.h</A>&gt;</I>, the Shell and Utilities
volume of
IEEE&nbsp;Std&nbsp;1003.1-2001
<A NAME="lbAP">&nbsp;</A>
<H2>COPYRIGHT</H2>

Portions of this text are reprinted and reproduced in electronic form
from IEEE Std 1003.1, 2003 Edition, Standard for Information Technology
-- Portable Operating System Interface (POSIX), The Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by the Institute of
Electrical and Electronics Engineers, Inc and The Open Group. In the
event of any discrepancy between this version and the original IEEE and
The Open Group Standard, the original IEEE and The Open Group Standard
is the referee document. The original Standard can be obtained online at
<A HREF="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</A> .
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">PROLOG</A><DD>
<DT><A HREF="#lbAC">NAME</A><DD>
<DT><A HREF="#lbAD">SYNOPSIS</A><DD>
<DT><A HREF="#lbAE">DESCRIPTION</A><DD>
<DT><A HREF="#lbAF">RETURN VALUE</A><DD>
<DT><A HREF="#lbAG">ERRORS</A><DD>
<DT><A HREF="#lbAH">EXAMPLES</A><DD>
<DL>
<DT><A HREF="#lbAI">Parsing Command Line Options</A><DD>
<DT><A HREF="#lbAJ">Checking Options and Arguments</A><DD>
<DT><A HREF="#lbAK">Selecting Options from the Command Line</A><DD>
</DL>
<DT><A HREF="#lbAL">APPLICATION USAGE</A><DD>
<DT><A HREF="#lbAM">RATIONALE</A><DD>
<DT><A HREF="#lbAN">FUTURE DIRECTIONS</A><DD>
<DT><A HREF="#lbAO">SEE ALSO</A><DD>
<DT><A HREF="#lbAP">COPYRIGHT</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/cgi-bin/man/man2html">man2html</A>,
using the manual pages.<BR>
Time: 12:41:34 GMT, April 18, 2016
</BODY>
</HTML>
