<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Man page of INSQUE</TITLE>
</HEAD><BODY>
<H1>INSQUE</H1>
Section: POSIX Programmer's Manual (3P)<BR>Updated: 2003<BR><A HREF="#index">Index</A>
<A HREF="/cgi-bin/man/man2html">Return to Main Contents</A><HR>


<A NAME="lbAB">&nbsp;</A>
<H2>PROLOG</H2>

This manual page is part of the POSIX Programmer's Manual.
The Linux implementation of this interface may differ (consult
the corresponding Linux manual page for details of Linux behavior),
or the interface may not be implemented on Linux.
<A NAME="lbAC">&nbsp;</A>
<H2>NAME</H2>

insque, remque - insert or remove an element in a queue
<A NAME="lbAD">&nbsp;</A>
<H2>SYNOPSIS</H2>

<P>

<B>#include &lt;<A HREF="file:///usr/include/search.h">search.h</A>&gt;
<BR>

<P>
void insque(void *</B><I>element</I><B>, void *</B><I>pred</I><B>);
<BR>

void remque(void *</B><I>element</I><B>); </B>
<B>
<BR>

</B>
<A NAME="lbAE">&nbsp;</A>
<H2>DESCRIPTION</H2>

<P>

The <I>insque</I>() and <I>remque</I>() functions shall manipulate queues
built from doubly-linked lists. The queue can be
either circular or linear. An application using <I>insque</I>() or
<I>remque</I>() shall ensure it defines a structure in which the
first two members of the structure are pointers to the same type of
structure, and any further members are application-specific.
The first member of the structure is a forward pointer to the next
entry in the queue. The second member is a backward pointer to
the previous entry in the queue. If the queue is linear, the queue
is terminated with null pointers. The names of the structure and
of the pointer members are not subject to any special restriction.
<P>

The <I>insque</I>() function shall insert the element pointed to by
<I>element</I> into a queue immediately after the element
pointed to by <I>pred</I>.
<P>

The <I>remque</I>() function shall remove the element pointed to by
<I>element</I> from a queue.
<P>

If the queue is to be used as a linear list, invoking <I>insque</I>(&amp;<I>element</I>,
NULL), where <I>element</I> is the
initial element of the queue, shall initialize the forward and backward
pointers of <I>element</I> to null pointers.
<P>

If the queue is to be used as a circular list, the application shall
ensure it initializes the forward pointer and the backward
pointer of the initial element of the queue to the element's own address.
<A NAME="lbAF">&nbsp;</A>
<H2>RETURN VALUE</H2>

<P>

The <I>insque</I>() and <I>remque</I>() functions do not return a value.
<A NAME="lbAG">&nbsp;</A>
<H2>ERRORS</H2>

<P>

No errors are defined.
<P>

<I>The following sections are informative.</I>
<A NAME="lbAH">&nbsp;</A>
<H2>EXAMPLES</H2>

<A NAME="lbAI">&nbsp;</A>
<H3>Creating a Linear Linked List</H3>

<P>

The following example creates a linear linked list.
<P>
<DL COMPACT><DT><DD>
<PRE>

<B>#include &lt;<A HREF="file:///usr/include/search.h">search.h</A>&gt;
...
struct myque element1;
struct myque element2;


char *data1 = &quot;DATA1&quot;;
char *data2 = &quot;DATA2&quot;;
...
element1.data = data1;
element2.data = data2;


insque (&amp;element1, NULL);
insque (&amp;element2, &amp;element1);
</B>
</PRE>

</DL>

<A NAME="lbAJ">&nbsp;</A>
<H3>Creating a Circular Linked List</H3>

<P>

The following example creates a circular linked list.
<P>
<DL COMPACT><DT><DD>
<PRE>

<B>#include &lt;<A HREF="file:///usr/include/search.h">search.h</A>&gt;
...
struct myque element1;
struct myque element2;


char *data1 = &quot;DATA1&quot;;
char *data2 = &quot;DATA2&quot;;
...
element1.data = data1;
element2.data = data2;


element1.fwd = &amp;element1;
element1.bck = &amp;element1;


insque (&amp;element2, &amp;element1);
</B>
</PRE>

</DL>

<A NAME="lbAK">&nbsp;</A>
<H3>Removing an Element</H3>

<P>

The following example removes the element pointed to by <I>element1</I>.
<P>
<DL COMPACT><DT><DD>
<PRE>

<B>#include &lt;<A HREF="file:///usr/include/search.h">search.h</A>&gt;
...
struct myque element1;
...
remque (&amp;element1);
</B>
</PRE>

</DL>

<A NAME="lbAL">&nbsp;</A>
<H2>APPLICATION USAGE</H2>

<P>

The historical implementations of these functions described the arguments
as being of type <B>struct qelem *</B> rather than as
being of type <B>void *</B> as defined here. In those implementations,
<B>struct qelem</B> was commonly defined in <I>&lt;<A HREF="file:///usr/include/search.h">search.h</A>&gt;</I> as:
<P>
<DL COMPACT><DT><DD>
<PRE>

<B>struct qelem {
    struct qelem  *q_forw;
    struct qelem  *q_back;
};
</B>
</PRE>

</DL>

<P>

Applications using these functions, however, were never able to use
this structure directly since it provided no room for the
actual data contained in the elements. Most applications defined structures
that contained the two pointers as the initial elements
and also provided space for, or pointers to, the object's data. Applications
that used these functions to update more than one type
of table also had the problem of specifying two or more different
structures with the same name, if they literally used <B>struct
qelem</B> as specified.
<P>

As described here, the implementations were actually expecting a structure
type where the first two members were forward and
backward pointers to structures. With C compilers that didn't provide
function prototypes, applications used structures as
specified in the DESCRIPTION above and the compiler did what the application
expected.
<P>

If this method had been carried forward with an ISO&nbsp;C standard compiler
and the historical function prototype, most
applications would have to be modified to cast pointers to the structures
actually used to be pointers to <B>struct qelem</B> to
avoid compilation warnings. By specifying <B>void *</B> as the argument
type, applications do not need to change (unless they
specifically referenced <B>struct qelem</B> and depended on it being
defined in <I>&lt;<A HREF="file:///usr/include/search.h">search.h</A>&gt;</I>).
<A NAME="lbAM">&nbsp;</A>
<H2>RATIONALE</H2>

<P>

None.
<A NAME="lbAN">&nbsp;</A>
<H2>FUTURE DIRECTIONS</H2>

<P>

None.
<A NAME="lbAO">&nbsp;</A>
<H2>SEE ALSO</H2>

<P>

The Base Definitions volume of IEEE&nbsp;Std&nbsp;1003.1-2001, <I>&lt;<A HREF="file:///usr/include/search.h">search.h</A>&gt;</I>
<A NAME="lbAP">&nbsp;</A>
<H2>COPYRIGHT</H2>

Portions of this text are reprinted and reproduced in electronic form
from IEEE Std 1003.1, 2003 Edition, Standard for Information Technology
-- Portable Operating System Interface (POSIX), The Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by the Institute of
Electrical and Electronics Engineers, Inc and The Open Group. In the
event of any discrepancy between this version and the original IEEE and
The Open Group Standard, the original IEEE and The Open Group Standard
is the referee document. The original Standard can be obtained online at
<A HREF="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</A> .
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">PROLOG</A><DD>
<DT><A HREF="#lbAC">NAME</A><DD>
<DT><A HREF="#lbAD">SYNOPSIS</A><DD>
<DT><A HREF="#lbAE">DESCRIPTION</A><DD>
<DT><A HREF="#lbAF">RETURN VALUE</A><DD>
<DT><A HREF="#lbAG">ERRORS</A><DD>
<DT><A HREF="#lbAH">EXAMPLES</A><DD>
<DL>
<DT><A HREF="#lbAI">Creating a Linear Linked List</A><DD>
<DT><A HREF="#lbAJ">Creating a Circular Linked List</A><DD>
<DT><A HREF="#lbAK">Removing an Element</A><DD>
</DL>
<DT><A HREF="#lbAL">APPLICATION USAGE</A><DD>
<DT><A HREF="#lbAM">RATIONALE</A><DD>
<DT><A HREF="#lbAN">FUTURE DIRECTIONS</A><DD>
<DT><A HREF="#lbAO">SEE ALSO</A><DD>
<DT><A HREF="#lbAP">COPYRIGHT</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/cgi-bin/man/man2html">man2html</A>,
using the manual pages.<BR>
Time: 12:41:35 GMT, April 18, 2016
</BODY>
</HTML>
