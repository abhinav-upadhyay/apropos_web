<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Man page of EXEC</TITLE>
</HEAD><BODY>
<H1>EXEC</H1>
Section: POSIX Programmer's Manual (3P)<BR>Updated: 2003<BR><A HREF="#index">Index</A>
<A HREF="/cgi-bin/man/man2html">Return to Main Contents</A><HR>


<A NAME="lbAB">&nbsp;</A>
<H2>PROLOG</H2>

This manual page is part of the POSIX Programmer's Manual.
The Linux implementation of this interface may differ (consult
the corresponding Linux manual page for details of Linux behavior),
or the interface may not be implemented on Linux.
<A NAME="lbAC">&nbsp;</A>
<H2>NAME</H2>

environ, execl, execv, execle, execve, execlp, execvp - execute a
file
<A NAME="lbAD">&nbsp;</A>
<H2>SYNOPSIS</H2>

<P>

<B>#include &lt;<A HREF="file:///usr/include/unistd.h">unistd.h</A>&gt;
<BR>

<P>
extern char **environ;
<BR>

int execl(const char *</B><I>path</I><B>, const char *</B><I>arg0</I><B>,
... /*, (char *)0 */);
<BR>

int execv(const char *</B><I>path</I><B>, char *const</B> <I>argv</I><B>[]);
<BR>

int execle(const char *</B><I>path</I><B>, const char *</B><I>arg0</I><B>,
... /*,
<BR>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (char *)0, char *const</B> <I>envp</I><B>[]*/);
<BR>

int execve(const char *</B><I>path</I><B>, char *const</B> <I>argv</I><B>[],
char *const</B> <I>envp</I><B>[]);
<BR>

int execlp(const char *</B><I>file</I><B>, const char *</B><I>arg0</I><B>,
... /*, (char *)0 */);
<BR>

int execvp(const char *</B><I>file</I><B>, char *const</B> <I>argv</I><B>[]);
<BR>

</B>
<A NAME="lbAE">&nbsp;</A>
<H2>DESCRIPTION</H2>

<P>

The <I>exec</I> family of functions shall replace the current process
image with a new process image. The new image shall be
constructed from a regular, executable file called the <I>new process
image file</I>. There shall be no return from a successful
<I>exec</I>, because the calling process image is overlaid by the new
process image.
<P>

When a C-language program is executed as a result of this call, it
shall be entered as a C-language function call as
follows:
<P>
<DL COMPACT><DT><DD>
<PRE>

<B>int main (</B><I>int argc, char *argv</I><B>[]);
</B>
</PRE>

</DL>

<P>

where <I>argc</I> is the argument count and <I>argv</I> is an array
of character pointers to the arguments themselves. In
addition, the following variable:
<P>
<DL COMPACT><DT><DD>
<PRE>

<B>extern char **environ;
</B>
</PRE>

</DL>

<P>

is initialized as a pointer to an array of character pointers to the
environment strings. The <I>argv</I> and <I>environ</I>
arrays are each terminated by a null pointer. The null pointer terminating
the <I>argv</I> array is not counted in <I>argc</I>.
<P>

Conforming multi-threaded applications shall not use the <I>environ</I>
variable to access or modify any environment variable while
any other thread is concurrently modifying any environment variable.
A call to any function dependent on any environment variable
shall be considered a use of the <I>environ</I> variable to access
that environment variable. 
<P>

The arguments specified by a program with one of the <I>exec</I> functions
shall be passed on to the new process image in the
corresponding <I>main</I>() arguments.
<P>

The argument <I>path</I> points to a pathname that identifies the new
process image file.
<P>

The argument <I>file</I> is used to construct a pathname that identifies
the new process image file. If the <I>file</I> argument
contains a slash character, the <I>file</I> argument shall be used
as the pathname for this file. Otherwise, the path prefix for
this file is obtained by a search of the directories passed as the
environment variable <I>PATH</I> (see the Base Definitions
volume of IEEE&nbsp;Std&nbsp;1003.1-2001, Chapter 8, Environment Variables).
If this
environment variable is not present, the results of the search are
implementation-defined.
<P>

There are two distinct ways in which the contents of the process image
file may cause the execution to fail, distinguished by
the setting of <I>errno</I> to either [ENOEXEC] or [EINVAL] (see the
ERRORS section). In the cases where the other members of the
<I>exec</I> family of functions would fail and set <I>errno</I> to [ENOEXEC],
the <I>execlp</I>() and <I>execvp</I>() functions
shall execute a command interpreter and the environment of the executed
command shall be as if the process invoked the <I>sh</I> utility using
<I>execl</I>() as follows:
<P>
<DL COMPACT><DT><DD>
<PRE>

<B>execl(&lt;shell path&gt;, arg0, file, arg1, ..., (char *)0);
</B>
</PRE>

</DL>

<P>

where &lt;<I>shell&nbsp;path</I>&gt; is an unspecified pathname for the <I>sh</I>
utility,
<I>file</I> is the process image file, and for <I>execvp</I>(), where
<I>arg</I>0, <I>arg</I>1, and so on correspond to the values
passed to <I>execvp</I>() in <I>argv</I>[0], <I>argv</I>[1], and so on.
<P>

The arguments represented by <I>arg0</I>,... are pointers to null-terminated
character strings. These strings shall constitute
the argument list available to the new process image. The list is
terminated by a null pointer. The argument <I>arg0</I> should
point to a filename that is associated with the process being started
by one of the <I>exec</I> functions.
<P>

The argument <I>argv</I> is an array of character pointers to null-terminated
strings. The application shall ensure that the
last member of this array is a null pointer. These strings shall constitute
the argument list available to the new process image.
The value in <I>argv</I>[0] should point to a filename that is associated
with the process being started by one of the <I>exec</I>
functions.
<P>

The argument <I>envp</I> is an array of character pointers to null-terminated
strings. These strings shall constitute the
environment for the new process image. The <I>envp</I> array is terminated
by a null pointer.
<P>

For those forms not containing an <I>envp</I> pointer ( <I>execl</I>(),
<I>execv</I>(), <I>execlp</I>(), and <I>execvp</I>()),
the environment for the new process image shall be taken from the
external variable <I>environ</I> in the calling process.
<P>

The number of bytes available for the new process' combined argument
and environment lists is {ARG_MAX}. It is
implementation-defined whether null terminators, pointers, and/or
any alignment bytes are included in this total.
<P>

File descriptors open in the calling process image shall remain open
in the new process image, except for those whose close-on-
<I>exec</I> flag FD_CLOEXEC is set. For those file descriptors that
remain open, all attributes of the open file description remain
unchanged. For any file descriptor that is closed for this reason,
file locks are removed as a result of the close as described in
<I>close</I>(). Locks that are not removed by closing of file descriptors
remain unchanged.
<P>

If file descriptors 0, 1, and 2 would otherwise be closed after a
successful call to one of the <I>exec</I> family of functions,
and the new process image file has the set-user-ID or set-group-ID
file mode bits set,  and the
ST_NOSUID bit is not set for the file system containing the new process
image file,  implementations may open an unspecified file for each
of these file descriptors in the new process
image.
<P>

Directory streams open in the calling process image shall be closed
in the new process image.
<P>

The state of the floating-point environment in the new process image
shall be set to the default.
<P>

The state of conversion descriptors and message catalog descriptors
in the new process image is undefined. For the new process image,
the equivalent of:
<P>
<DL COMPACT><DT><DD>
<PRE>

<B>setlocale(LC_ALL, &quot;C&quot;)
</B>
</PRE>

</DL>

<P>

shall be executed at start-up.
<P>

Signals set to the default action (SIG_DFL) in the calling process
image shall be set to the default action in the new process
image. Except for SIGCHLD, signals set to be ignored (SIG_IGN) by
the calling process image shall be set to be ignored by the new
process image. Signals set to be caught by the calling process image
shall be set to the default action in the new process image
(see <I>&lt;<A HREF="file:///usr/include/signal.h">signal.h</A>&gt;</I>). If the SIGCHLD signal is set to be ignored
by the calling
process image, it is unspecified whether the SIGCHLD signal is set
to be ignored or to the default action in the new process image.
&nbsp;After a successful call to any of the <I>exec</I> functions, alternate
signal stacks are not preserved and the SA_ONSTACK
flag shall be cleared for all signals. 
<P>

After a successful call to any of the <I>exec</I> functions, any functions
previously registered by <I>atexit</I>() are no longer registered.
<P>

If the ST_NOSUID bit is set for the file system containing the new
process image file, then the effective user ID, effective group
ID, saved set-user-ID, and saved set-group-ID are unchanged in the
new process image. Otherwise,  if the set-user-ID mode bit of the
new process image file is set, the effective user ID of the new
process image shall be set to the user ID of the new process image
file. Similarly, if the set-group-ID mode bit of the new process
image file is set, the effective group ID of the new process image
shall be set to the group ID of the new process image file. The
real user ID, real group ID, and supplementary group IDs of the new
process image shall remain the same as those of the calling
process image. The effective user ID and effective group ID of the
new process image shall be saved (as the saved set-user-ID and
the saved set-group-ID) for use by <I>setuid</I>().
<P>

Any shared memory segments attached to the calling process image shall
not be attached to the new process image. 
<P>

Any named semaphores open in the calling process shall be closed as
if by appropriate calls to <I>sem_close</I>(). 
<P>

Any blocks of typed memory that were mapped in the calling process
are unmapped, as if <I>munmap</I>() was implicitly called to unmap
them. 
<P>

Memory locks established by the calling process via calls to <I>mlockall</I>()
or <I>mlock</I>() shall be removed. If locked pages in the address
space of the calling process are also
mapped into the address spaces of other processes and are locked by
those processes, the locks established by the other processes
shall be unaffected by the call by this process to the <I>exec</I>
function. If the <I>exec</I> function fails, the effect on
memory locks is unspecified. 
<P>

Memory mappings created in the process are unmapped before the address
space is rebuilt for the new process image. 
<P>

For
the SCHED_FIFO and SCHED_RR scheduling policies, the policy and priority
settings shall not be changed by a call to an <I>exec</I>
function. For other scheduling policies, the policy and priority settings
on <I>exec</I> are implementation-defined. 
<P>

Per-process timers created by the calling process shall be deleted
before replacing the current process image with the new process
image. 
<P>

All open message queue descriptors in the calling process shall be
closed, as described in <I>mq_close</I>(). 
<P>

Any outstanding asynchronous I/O operations may be canceled. Those
asynchronous I/O operations that are not canceled shall complete
as if the <I>exec</I> function had not yet occurred, but any associated
signal notifications shall be suppressed. It is unspecified
whether the <I>exec</I> function itself blocks awaiting such I/O completion.
In no event, however, shall the new process image
created by the <I>exec</I> function be affected by the presence of
outstanding asynchronous I/O operations at the time the
<I>exec</I> function is called. Whether any I/O is canceled, and which
I/O may be canceled upon <I>exec</I>, is
implementation-defined. 
<P>

The new process image shall inherit the CPU-time clock of the calling
process image. This inheritance means that the process
CPU-time clock of the process being <I>exec</I>-ed shall not be reinitialized
or altered as a result of the <I>exec</I> function
other than to reflect the time spent by the process executing the
<I>exec</I> function itself. 
<P>

The initial value of the CPU-time clock of the initial thread of the
new process image shall be set to zero. 
<P>

If the calling process is being traced, the new process image shall
continue to be traced into the same trace stream as the
original process image, but the new process image shall not inherit
the mapping of trace event names to trace event type
identifiers that was defined by calls to the <I>posix_trace_eventid_open</I>()
or the <I>posix_trace_trid_eventid_open</I>() functions in the calling
process
image.
<P>

If the calling process is a trace controller process, any trace streams
that were created by the calling process shall be shut
down as described in the <I>posix_trace_shutdown</I>() function. 
<P>

The new process shall inherit at least the following attributes from
the calling process image:
<DL COMPACT>
<DT> *<DD>
Nice value (see <I>nice</I>()) 
</DL>
<P>

<DL COMPACT>
<DT> *<DD>
<I>semadj</I> values (see <I>semop</I>()) 
</DL>
<P>

<DL COMPACT>
<DT> *<DD>
Process ID
</DL>
<P>

<DL COMPACT>
<DT> *<DD>
Parent process ID
</DL>
<P>

<DL COMPACT>
<DT> *<DD>
Process group ID
</DL>
<P>

<DL COMPACT>
<DT> *<DD>
Session membership
</DL>
<P>

<DL COMPACT>
<DT> *<DD>
Real user ID
</DL>
<P>

<DL COMPACT>
<DT> *<DD>
Real group ID
</DL>
<P>

<DL COMPACT>
<DT> *<DD>
Supplementary group IDs
</DL>
<P>

<DL COMPACT>
<DT> *<DD>
Time left until an alarm clock signal (see <I>alarm</I>())
</DL>
<P>

<DL COMPACT>
<DT> *<DD>
Current working directory
</DL>
<P>

<DL COMPACT>
<DT> *<DD>
Root directory
</DL>
<P>

<DL COMPACT>
<DT> *<DD>
File mode creation mask (see <I>umask</I>())
</DL>
<P>

<DL COMPACT>
<DT> *<DD>
File size limit (see <I>ulimit</I>()) 
</DL>
<P>

<DL COMPACT>
<DT> *<DD>
Process signal mask (see <I>sigprocmask</I>())
</DL>
<P>

<DL COMPACT>
<DT> *<DD>
Pending signal (see <I>sigpending</I>())
</DL>
<P>

<DL COMPACT>
<DT> *<DD>
<I>tms_utime</I>, <I>tms_stime</I>, <I>tms_cutime</I>, and <I>tms_cstime</I>
(see <I>times</I>())
</DL>
<P>

<DL COMPACT>
<DT> *<DD>
Resource limits 
</DL>
<P>

<DL COMPACT>
<DT> *<DD>
Controlling terminal 
</DL>
<P>

<DL COMPACT>
<DT> *<DD>
Interval timers 
</DL>
<P>

<P>

All other process attributes defined in this volume of IEEE&nbsp;Std&nbsp;1003.1-2001
shall be the same in the new and old
process images. The inheritance of process attributes not defined
by this volume of IEEE&nbsp;Std&nbsp;1003.1-2001 is
implementation-defined.
<P>

A call to any <I>exec</I> function from a process with more than one
thread shall result in all threads being terminated and the
new executable image being loaded and executed. No destructor functions
shall be called.
<P>

Upon successful completion, the <I>exec</I> functions shall mark for
update the <I>st_atime</I> field of the file. If an
<I>exec</I> function failed but was able to locate the process image
file, whether the <I>st_atime</I> field is marked for update
is unspecified. Should the <I>exec</I> function succeed, the process
image file shall be considered to have been opened with <I>open</I>().
The corresponding <I>close</I>() shall be
considered to occur at a time after this open, but before process
termination or successful completion of a subsequent call to one
of the <I>exec</I> functions, <I>posix_spawn</I>(), or <I>posix_spawnp</I>().
The <I>argv</I>[] and <I>envp</I>[] arrays of pointers and the strings
to which those arrays point shall not be modified by a call to one
of the <I>exec</I> functions, except as a consequence of
replacing the process image.
<P>

The saved resource limits in the new process image are set to be a
copy of the process' corresponding hard and soft limits. 
<A NAME="lbAF">&nbsp;</A>
<H2>RETURN VALUE</H2>

<P>

If one of the <I>exec</I> functions returns to the calling process
image, an error has occurred; the return value shall be -1,
and <I>errno</I> shall be set to indicate the error.
<A NAME="lbAG">&nbsp;</A>
<H2>ERRORS</H2>

<P>

The <I>exec</I> functions shall fail if:
<DL COMPACT>
<DT><B>E2BIG</B>

<DD>
The number of bytes used by the new process image's argument list
and environment list is greater than the system-imposed limit
of {ARG_MAX} bytes.
<DT><B>EACCES</B>

<DD>
Search permission is denied for a directory listed in the new process
image file's path prefix, or the new process image file
denies execution permission, or the new process image file is not
a regular file and the implementation does not support execution
of files of its type.
<DT><B>EINVAL</B>

<DD>
The new process image file has the appropriate permission and has
a recognized executable binary format, but the system does
not support execution of a file with this format.
<DT><B>ELOOP</B>

<DD>
A loop exists in symbolic links encountered during resolution of the
<I>path</I> or <I>file</I> argument.
<DT><B>ENAMETOOLONG</B>

<DD>
The length of the <I>path</I> or <I>file</I> arguments exceeds {PATH_MAX}
or a pathname component is longer than {NAME_MAX}.
<DT><B>ENOENT</B>

<DD>
A component of <I>path</I> or <I>file</I> does not name an existing
file or <I>path</I> or <I>file</I> is an empty string.
<DT><B>ENOTDIR</B>

<DD>
A component of the new process image file's path prefix is not a directory.
<P>
</DL>
<P>

The <I>exec</I> functions, except for <I>execlp</I>() and <I>execvp</I>(),
shall fail if:
<DL COMPACT>
<DT><B>ENOEXEC</B>

<DD>
The new process image file has the appropriate access permission but
has an unrecognized format.
<P>
</DL>
<P>

The <I>exec</I> functions may fail if:
<DL COMPACT>
<DT><B>ELOOP</B>

<DD>
More than {SYMLOOP_MAX} symbolic links were encountered during resolution
of the <I>path</I> or <I>file</I> argument.
<DT><B>ENAMETOOLONG</B>

<DD>
As a result of encountering a symbolic link in resolution of the <I>path</I>
argument, the length of the substituted pathname
string exceeded {PATH_MAX}.
<DT><B>ENOMEM</B>

<DD>
The new process image requires more memory than is allowed by the
hardware or system-imposed memory management
constraints.
<DT><B>ETXTBSY</B>

<DD>
The new process image file is a pure procedure (shared text) file
that is currently open for writing by some process.
<P>
</DL>
<P>

<I>The following sections are informative.</I>
<A NAME="lbAH">&nbsp;</A>
<H2>EXAMPLES</H2>

<A NAME="lbAI">&nbsp;</A>
<H3>Using execl()</H3>

<P>

The following example executes the <I>ls</I> command, specifying the
pathname of the
executable ( <B>/bin/ls</B>) and using arguments supplied directly
to the command to produce single-column output.
<P>
<DL COMPACT><DT><DD>
<PRE>

<B>#include &lt;<A HREF="file:///usr/include/unistd.h">unistd.h</A>&gt;


int ret;
...
ret = execl (&quot;/bin/ls&quot;, &quot;ls&quot;, &quot;-1&quot;, (char *)0);
</B>
</PRE>

</DL>

<A NAME="lbAJ">&nbsp;</A>
<H3>Using execle()</H3>

<P>

The following example is similar to Using execl() . In addition, it
specifies the environment
for the new process image using the <I>env</I> argument.
<P>
<DL COMPACT><DT><DD>
<PRE>

<B>#include &lt;<A HREF="file:///usr/include/unistd.h">unistd.h</A>&gt;


int ret;
char *env[] = { &quot;HOME=/usr/home&quot;, &quot;LOGNAME=home&quot;, (char *)0 };
...
ret = execle (&quot;/bin/ls&quot;, &quot;ls&quot;, &quot;-l&quot;, (char *)0, env);
</B>
</PRE>

</DL>

<A NAME="lbAK">&nbsp;</A>
<H3>Using execlp()</H3>

<P>

The following example searches for the location of the <I>ls</I> command
among the
directories specified by the <I>PATH</I> environment variable.
<P>
<DL COMPACT><DT><DD>
<PRE>

<B>#include &lt;<A HREF="file:///usr/include/unistd.h">unistd.h</A>&gt;


int ret;
...
ret = execlp (&quot;ls&quot;, &quot;ls&quot;, &quot;-l&quot;, (char *)0);
</B>
</PRE>

</DL>

<A NAME="lbAL">&nbsp;</A>
<H3>Using execv()</H3>

<P>

The following example passes arguments to the <I>ls</I> command in
the <I>cmd</I> array.
<P>
<DL COMPACT><DT><DD>
<PRE>

<B>#include &lt;<A HREF="file:///usr/include/unistd.h">unistd.h</A>&gt;


int ret;
char *cmd[] = { &quot;ls&quot;, &quot;-l&quot;, (char *)0 };
...
ret = execv (&quot;/bin/ls&quot;, cmd);
</B>
</PRE>

</DL>

<A NAME="lbAM">&nbsp;</A>
<H3>Using execve()</H3>

<P>

The following example passes arguments to the <I>ls</I> command in
the <I>cmd</I> array, and
specifies the environment for the new process image using the <I>env</I>
argument.
<P>
<DL COMPACT><DT><DD>
<PRE>

<B>#include &lt;<A HREF="file:///usr/include/unistd.h">unistd.h</A>&gt;


int ret;
char *cmd[] = { &quot;ls&quot;, &quot;-l&quot;, (char *)0 };
char *env[] = { &quot;HOME=/usr/home&quot;, &quot;LOGNAME=home&quot;, (char *)0 };
...
ret = execve (&quot;/bin/ls&quot;, cmd, env);
</B>
</PRE>

</DL>

<A NAME="lbAN">&nbsp;</A>
<H3>Using execvp()</H3>

<P>

The following example searches for the location of the <I>ls</I> command
among the
directories specified by the <I>PATH</I> environment variable, and
passes arguments to the <I>ls</I> command in the <I>cmd</I> array.
<P>
<DL COMPACT><DT><DD>
<PRE>

<B>#include &lt;<A HREF="file:///usr/include/unistd.h">unistd.h</A>&gt;


int ret;
char *cmd[] = { &quot;ls&quot;, &quot;-l&quot;, (char *)0 };
...
ret = execvp (&quot;ls&quot;, cmd);
</B>
</PRE>

</DL>

<A NAME="lbAO">&nbsp;</A>
<H2>APPLICATION USAGE</H2>

<P>

As the state of conversion descriptors and message catalog descriptors
in the new process image is undefined, conforming
applications should not rely on their use and should close them prior
to calling one of the <I>exec</I> functions.
<P>

Applications that require other than the default POSIX locale should
call <I>setlocale</I>() with the appropriate parameters to establish
the locale of the new
process.
<P>

The <I>environ</I> array should not be accessed directly by the application.
<P>

Applications should not depend on file descriptors 0, 1, and 2 being
closed after an <I>exec</I>. A future version may allow
these file descriptors to be automatically opened for any process.
<A NAME="lbAP">&nbsp;</A>
<H2>RATIONALE</H2>

<P>

Early proposals required that the value of <I>argc</I> passed to <I>main</I>()
be &quot;one or greater&quot;. This was driven by the
same requirement in drafts of the ISO&nbsp;C standard. In fact, historical
implementations have passed a value of zero when no
arguments are supplied to the caller of the <I>exec</I> functions.
This requirement was removed from the ISO&nbsp;C standard and
subsequently removed from this volume of IEEE&nbsp;Std&nbsp;1003.1-2001 as
well. The wording, in particular the use of the word
<I>should</I>, requires a Strictly Conforming POSIX Application to
pass at least one argument to the <I>exec</I> function, thus
guaranteeing that <I>argc</I> be one or greater when invoked by such
an application. In fact, this is good practice, since many
existing applications reference <I>argv</I>[0] without first checking
the value of <I>argc</I>.
<P>

The requirement on a Strictly Conforming POSIX Application also states
that the value passed as the first argument be a filename
associated with the process being started. Although some existing
applications pass a pathname rather than a filename in some
circumstances, a filename is more generally useful, since the common
usage of <I>argv</I>[0] is in printing diagnostics. In some
cases the filename passed is not the actual filename of the file;
for example, many implementations of the <I>login</I> utility use
a convention of prefixing a hyphen ( <B>'-'</B> ) to the actual filename,
which indicates to the command interpreter being
invoked that it is a &quot;login shell&quot;.
<P>

Historically there have been two ways that implementations can <I>exec</I>
shell scripts.
<P>

One common historical implementation is that the <I>execl</I>(), <I>execv</I>(),
<I>execle</I>(), and <I>execve</I>() functions
return an [ENOEXEC] error for any file not recognizable as executable,
including a shell script. When the <I>execlp</I>() and
<I>execvp</I>() functions encounter such a file, they assume the file
to be a shell script and invoke a known command interpreter
to interpret such files. This is now required by IEEE&nbsp;Std&nbsp;1003.1-2001.
These implementations of <I>execvp</I>() and
<I>execlp</I>() only give the [ENOEXEC] error in the rare case of a
problem with the command interpreter's executable file. Because
of these implementations, the [ENOEXEC] error is not mentioned for
<I>execlp</I>() or <I>execvp</I>(), although implementations can
still give it.
<P>

Another way that some historical implementations handle shell scripts
is by recognizing the first two bytes of the file as the
character string <B>&quot;#!&quot;</B> and using the remainder of the first line
of the file as the name of the command interpreter to
execute.
<P>

One potential source of confusion noted by the standard developers
is over how the contents of a process image file affect the
behavior of the <I>exec</I> family of functions. The following is a
description of the actions taken:
<DL COMPACT>
<DT> 1.<DD>
If the process image file is a valid executable (in a format that
is executable and valid and having appropriate permission) for
this system, then the system executes the file.
</DL>
<P>

<DL COMPACT>
<DT> 2.<DD>
If the process image file has appropriate permission and is in a format
that is executable but not valid for this system (such
as a recognized binary for another architecture), then this is an
error and <I>errno</I> is set to [EINVAL] (see later RATIONALE on
[EINVAL]).
</DL>
<P>

<DL COMPACT>
<DT> 3.<DD>
If the process image file has appropriate permission but is not otherwise
recognized:
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT> a.<DD>
If this is a call to <I>execlp</I>() or <I>execvp</I>(), then they invoke
a command interpreter assuming that the process image
file is a shell script.
</DL>
<P>

<DL COMPACT>
<DT> b.<DD>
If this is not a call to <I>execlp</I>() or <I>execvp</I>(), then an
error occurs and <I>errno</I> is set to [ENOEXEC].
</DL>
<P>

</DL>

</DL>
<P>

<P>

Applications that do not require to access their arguments may use
the form:
<P>
<DL COMPACT><DT><DD>
<PRE>

<B>main(void)
</B>
</PRE>

</DL>

as specified in the ISO&nbsp;C standard. However, the implementation will
always provide the two arguments <I>argc</I> and
<I>argv</I>, even if they are not used. 
<P>

Some implementations provide a third argument to <I>main</I>() called
<I>envp</I>. This is defined as a pointer to the
environment. The ISO&nbsp;C standard specifies invoking <I>main</I>() with
two arguments, so implementations must support
applications written this way. Since this volume of IEEE&nbsp;Std&nbsp;1003.1-2001
defines the global variable <I>environ</I>,
which is also provided by historical implementations and can be used
anywhere that <I>envp</I> could be used, there is no
functional need for the <I>envp</I> argument. Applications should use
the <I>getenv</I>()
function rather than accessing the environment directly via either
<I>envp</I> or <I>environ</I>. Implementations are required to
support the two-argument calling sequence, but this does not prohibit
an implementation from supporting <I>envp</I> as an optional
third argument.
<P>

This volume of IEEE&nbsp;Std&nbsp;1003.1-2001 specifies that signals set to
SIG_IGN remain set to SIG_IGN, and that the process
signal mask be unchanged across an <I>exec</I>. This is consistent
with historical implementations, and it permits some useful
functionality, such as the <I>nohup</I> command. However, it should
be noted that many
existing applications wrongly assume that they start with certain
signals set to the default action and/or unblocked. In
particular, applications written with a simpler signal model that
does not include blocking of signals, such as the one in the
ISO&nbsp;C standard, may not behave properly if invoked with some signals
blocked. Therefore, it is best not to block or ignore
signals across <I>exec</I>s without explicit reason to do so, and especially
not to block signals across <I>exec</I>s of arbitrary
(not closely co-operating) programs.
<P>

The <I>exec</I> functions always save the value of the effective user
ID and effective group ID of the process at the completion
of the <I>exec</I>, whether or not the set-user-ID or the set-group-ID
bit of the process image file is set.
<P>

The statement about <I>argv</I>[] and <I>envp</I>[] being constants
is included to make explicit to future writers of language
bindings that these objects are completely constant. Due to a limitation
of the ISO&nbsp;C standard, it is not possible to state
that idea in standard C. Specifying two levels of <I>const</I>- <I>qualification</I>
for the <I>argv</I>[] and <I>envp</I>[]
parameters for the <I>exec</I> functions may seem to be the natural
choice, given that these functions do not modify either the
array of pointers or the characters to which the function points,
but this would disallow existing correct code. Instead, only the
array of pointers is noted as constant. The table of assignment compatibility
for <I>dst</I>= <I>src</I> derived from the
ISO&nbsp;C standard summarizes the compatibility:
<TABLE>
<TR VALIGN=top><TD ALIGN=center><I>dst</I>:</TD><TD ALIGN=right><B>char *[]</B>&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD ALIGN=right><B>const char *[]</B></TD><TD><B>char *const[]</B>&nbsp;</TD><TD><B>const char *const[]</B>&nbsp;</TD><TD>&nbsp;</TD><TD>&nbsp;</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD ALIGN=center><B></B><I>src</I>:</TD><TD ALIGN=right>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD ALIGN=right>&nbsp;</TD><TD>&nbsp;&nbsp;</TD><TD>&nbsp;&nbsp;</TD><TD>&nbsp;</TD><TD>&nbsp;</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD ALIGN=center><B>char *[]</B></TD><TD ALIGN=right>VALID&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD ALIGN=right>-</TD><TD>VALID&nbsp;</TD><TD>-&nbsp;</TD><TD>&nbsp;</TD><TD>&nbsp;</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD ALIGN=center><B>const char *[]</B></TD><TD ALIGN=right>-&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD ALIGN=right>VALID</TD><TD>-&nbsp;</TD><TD>VALID&nbsp;</TD><TD>&nbsp;</TD><TD>&nbsp;</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD ALIGN=center><B>char * const []</B></TD><TD ALIGN=right>-&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD ALIGN=right>-</TD><TD>VALID&nbsp;</TD><TD>-&nbsp;</TD><TD>&nbsp;</TD><TD>&nbsp;</TD><TD><BR></TD></TR>
<TR VALIGN=top><TD ALIGN=center><B>const char *const[]</B></TD><TD ALIGN=right>-&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD ALIGN=right>-</TD><TD>-&nbsp;</TD><TD>VALID&nbsp;</TD><TD>&nbsp;</TD><TD>&nbsp;</TD><TD><BR></TD></TR>
</TABLE>

<P>

Since all existing code has a source type matching the first row,
the column that gives the most valid combinations is the third
column. The only other possibility is the fourth column, but using
it would require a cast on the <I>argv</I> or <I>envp</I>
arguments. It is unfortunate that the fourth column cannot be used,
because the declaration a non-expert would naturally use would
be that in the second row.
<P>

The ISO&nbsp;C standard and this volume of IEEE&nbsp;Std&nbsp;1003.1-2001 do not
conflict on the use of <I>environ</I>, but some
historical implementations of <I>environ</I> may cause a conflict.
As long as <I>environ</I> is treated in the same way as an entry
point (for example, <I>fork</I>()), it conforms to both standards.
A library can contain <I>fork</I>(), but if there is a user-provided
<I>fork</I>(), that <I>fork</I>() is given precedence and no
problem ensues. The situation is similar for <I>environ</I>: the definition
in this volume of IEEE&nbsp;Std&nbsp;1003.1-2001 is to
be used if there is no user-provided <I>environ</I> to take precedence.
At least three implementations are known to exist that
solve this problem.
<DL COMPACT>
<DT><B>E2BIG</B>

<DD>
The limit {ARG_MAX} applies not just to the size of the argument list,
but to the sum of that and the size of the environment
list.
<DT><B>EFAULT</B>

<DD>
Some historical systems return [EFAULT] rather than [ENOEXEC] when
the new process image file is corrupted. They are
non-conforming.
<DT><B>EINVAL</B>

<DD>
This error condition was added to IEEE&nbsp;Std&nbsp;1003.1-2001 to allow
an implementation to detect executable files
generated for different architectures, and indicate this situation
to the application. Historical implementations of shells,
<I>execvp</I>(), and <I>execlp</I>() that encounter an [ENOEXEC] error
will execute a shell on the assumption that the file is a
shell script. This will not produce the desired effect when the file
is a valid executable for a different architecture. An
implementation may now choose to avoid this problem by returning [EINVAL]
when a valid executable for a different architecture is
encountered. Some historical implementations return [EINVAL] to indicate
that the <I>path</I> argument contains a character with
the high order bit set. The standard developers chose to deviate from
historical practice for the following reasons: 
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT> 1.<DD>
The new utilization of [EINVAL] will provide some measure of utility
to the user community.
</DL>
<P>

<DL COMPACT>
<DT> 2.<DD>
Historical use of [EINVAL] is not acceptable in an internationalized
operating environment.
</DL>
<P>

</DL>

<DT><B>ENAMETOOLONG</B>

<DD>
Since the file pathname may be constructed by taking elements in the
<I>PATH</I> variable and putting them together with the
filename, the [ENAMETOOLONG] error condition could also be reached
this way.
<DT><B>ETXTBSY</B>

<DD>
System V returns this error when the executable file is currently
open for writing by some process. This volume of
IEEE&nbsp;Std&nbsp;1003.1-2001 neither requires nor prohibits this behavior.
<P>
</DL>
<P>

Other systems (such as System V) may return [EINTR] from <I>exec</I>.
This is not addressed by this volume of
IEEE&nbsp;Std&nbsp;1003.1-2001, but implementations may have a window between
the call to <I>exec</I> and the time that a signal
could cause one of the <I>exec</I> calls to return with [EINTR].
<P>

An explicit statement regarding the floating-point environment (as
defined in the <I>&lt;<A HREF="file:///usr/include/fenv.h">fenv.h</A>&gt;</I> header) was added to make it clear that
the floating-point environment is set
to its default when a call to one of the <I>exec</I> functions succeeds.
The requirements for inheritance or setting to the default
for other process and thread start-up functions is covered by more
generic statements in their descriptions and can be summarized
as follows:
<DL COMPACT>
<DT><I>posix_spawn</I>()<DD>
Set to default.
<DT><I>fork</I>()<DD>
Inherit.
<DT><I>pthread_create</I>()<DD>
Inherit.
<P>
</DL>
<A NAME="lbAQ">&nbsp;</A>
<H2>FUTURE DIRECTIONS</H2>

<P>

None.
<A NAME="lbAR">&nbsp;</A>
<H2>SEE ALSO</H2>

<P>

<I>alarm</I>(), <I>atexit</I>(), <I>chmod</I>(),
<I>close</I>(), <I>exit</I>(), <I>fcntl</I>(), <I>fork</I>(), <I>fstatvfs</I>(),
<I>getenv</I>(), <I>getitimer</I>(), <I>getrlimit</I>(), <I>mmap</I>(),
<I>nice</I>(), <I>posix_spawn</I>(), <I>posix_trace_eventid_open</I>(),
<I>posix_trace_shutdown</I>(), <I>posix_trace_trid_eventid_open</I>(),
<I>putenv</I>(), <I>semop</I>(), <I>setlocale</I>(), <I>shmat</I>()
,
<I>sigaction</I>(), <I>sigaltstack</I>(), <I>sigpending</I>(), <I>sigprocmask</I>(),
<I>system</I>(), <I>times</I>(), <I>ulimit</I>(), <I>umask</I>(),
the Base Definitions volume of IEEE&nbsp;Std&nbsp;1003.1-2001, Chapter 11,
General Terminal Interface, <I>&lt;<A HREF="file:///usr/include/unistd.h">unistd.h</A>&gt;</I>
<A NAME="lbAS">&nbsp;</A>
<H2>COPYRIGHT</H2>

Portions of this text are reprinted and reproduced in electronic form
from IEEE Std 1003.1, 2003 Edition, Standard for Information Technology
-- Portable Operating System Interface (POSIX), The Open Group Base
Specifications Issue 6, Copyright (C) 2001-2003 by the Institute of
Electrical and Electronics Engineers, Inc and The Open Group. In the
event of any discrepancy between this version and the original IEEE and
The Open Group Standard, the original IEEE and The Open Group Standard
is the referee document. The original Standard can be obtained online at
<A HREF="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</A> .
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">PROLOG</A><DD>
<DT><A HREF="#lbAC">NAME</A><DD>
<DT><A HREF="#lbAD">SYNOPSIS</A><DD>
<DT><A HREF="#lbAE">DESCRIPTION</A><DD>
<DT><A HREF="#lbAF">RETURN VALUE</A><DD>
<DT><A HREF="#lbAG">ERRORS</A><DD>
<DT><A HREF="#lbAH">EXAMPLES</A><DD>
<DL>
<DT><A HREF="#lbAI">Using execl()</A><DD>
<DT><A HREF="#lbAJ">Using execle()</A><DD>
<DT><A HREF="#lbAK">Using execlp()</A><DD>
<DT><A HREF="#lbAL">Using execv()</A><DD>
<DT><A HREF="#lbAM">Using execve()</A><DD>
<DT><A HREF="#lbAN">Using execvp()</A><DD>
</DL>
<DT><A HREF="#lbAO">APPLICATION USAGE</A><DD>
<DT><A HREF="#lbAP">RATIONALE</A><DD>
<DT><A HREF="#lbAQ">FUTURE DIRECTIONS</A><DD>
<DT><A HREF="#lbAR">SEE ALSO</A><DD>
<DT><A HREF="#lbAS">COPYRIGHT</A><DD>
</DL>
<HR>
This document was created by
<A HREF="/cgi-bin/man/man2html">man2html</A>,
using the manual pages.<BR>
Time: 12:41:35 GMT, April 18, 2016
</BODY>
</HTML>
