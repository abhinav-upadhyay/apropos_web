<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
PF.CONF(5)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
PF.CONF(5)</td>
<td class="head-vol" align="center">
File Formats Manual</td>
<td class="head-rtitle" align="right">
PF.CONF(5)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">pf.conf</b> &#8212; <span class="desc">packet filter configuration file</span></div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <a class="link-man" href="../html4/pf.html">pf(4)</a> packet filter modifies, drops or passes packets according to rules or definitions specified in <b class="name">pf.conf</b>.</div>
<div class="section">
<h1 id="x53544154454d454e54204f52444552">STATEMENT ORDER</h1> There are seven types of statements in <b class="name">pf.conf</b>:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">Macros</b></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
User-defined variables may be defined and used later, simplifying the configuration file. Macros must be defined before they are referenced in <b class="name">pf.conf</b>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">Tables</b></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Tables provide a mechanism for increasing the performance and flexibility of rules with large numbers of source or destination addresses.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">Options</b></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Options tune the behaviour of the packet filtering engine.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">Traffic Normalization</b> <code class="lit">(e.g.</code> <span class="emph">scrub</span>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Traffic normalization protects internal machines against inconsistencies in Internet protocols and implementations.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">Queueing</b></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Queueing provides rule-based bandwidth control.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">Translation</b> <code class="lit">(Various forms of NAT)</code></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Translation rules specify how addresses are to be mapped or redirected to other addresses.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">Packet Filtering</b></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Packet filtering provides rule-based blocking or passing of packets.</dd>
</dl>
<p>
With the exception of <b class="flag">macros</b> and <b class="flag">tables</b>, the types of statements should be grouped and appear in <b class="name">pf.conf</b> in the order shown above, as this matches the operation of the underlying packet filtering engine. By default <a class="link-man" href="../html8/pfctl.html">pfctl(8)</a> enforces this order (see <i class="arg">set require-order</i> below).</div>
<div class="section">
<h1 id="x4d4143524f53">MACROS</h1> Macros can be defined that will later be expanded in context. Macro names must start with a letter, and may contain letters, digits and underscores. Macro names may not be reserved words (for example <i class="arg">pass</i>, <i class="arg">in</i>, <i class="arg">out</i>). Macros are not expanded inside quotes.<p>
For example,<p>
<pre style="margin-left: 5.00ex;" class="lit display">
ext_if = "kue0" 
all_ifs = "{" $ext_if lo0 "}" 
pass out on $ext_if from any to any 
pass in  on $ext_if proto tcp from any to any port 25</pre>
</div>
<div class="section">
<h1 id="x5441424c4553">TABLES</h1> Tables are named structures which can hold a collection of addresses and networks. Lookups against tables in <a class="link-man" href="../html4/pf.html">pf(4)</a> are relatively fast, making a single rule with tables much more efficient, in terms of processor usage and memory consumption, than a large number of rules which differ only in IP address (either created explicitly or automatically by rule expansion).<p>
Tables can be used as the source or destination of filter rules, <i class="arg">scrub</i> rules or translation rules such as <i class="arg">nat</i> or <i class="arg">rdr</i> (see below for details on the various rule types). Tables can also be used for the redirect address of <i class="arg">nat</i> and <i class="arg">rdr</i> rules and in the routing options of filter rules, but only for <i class="arg">round-robin</i> pools.<p>
Tables can be defined with any of the following <a class="link-man" href="../html8/pfctl.html">pfctl(8)</a> mechanisms. As with macros, reserved words may not be used as table names.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">manually</i></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
Persistent tables can be manually created with the <i class="arg">add</i> or <i class="arg">replace</i> option of <a class="link-man" href="../html8/pfctl.html">pfctl(8)</a>, before or after the ruleset has been loaded.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="file">pf.conf</i></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
Table definitions can be placed directly in this file, and loaded at the same time as other rules are loaded, atomically. Table definitions inside <b class="name">pf.conf</b> use the <i class="arg">table</i> statement, and are especially useful to define non-persistent tables. The contents of a pre-existing table defined without a list of addresses to initialize it is not altered when <b class="name">pf.conf</b> is loaded. A table initialized with the empty list, <code class="lit">{ }</code>, will be cleared on load.</dd>
</dl>
<p>
Tables may be defined with the following two attributes:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">persist</i></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
The <i class="arg">persist</i> flag forces the kernel to keep the table even when no rules refer to it. If the flag is not set, the kernel will automatically remove the table when the last rule referring to it is flushed.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">const</i></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
The <i class="arg">const</i> flag prevents the user from altering the contents of the table once it has been created. Without that flag, <a class="link-man" href="../html8/pfctl.html">pfctl(8)</a> can be used to add or remove addresses from the table at any time, even when running with securelevel = 2.</dd>
</dl>
<p>
For example,<p>
<pre style="margin-left: 5.00ex;" class="lit display">
table &lt;private&gt; const { 10/8, 172.16/12, 192.168/16 } 
table &lt;badhosts&gt; persist 
block on fxp0 from { &lt;private&gt;, &lt;badhosts&gt; } to any</pre>
<p>
creates a table called private, to hold RFC 1918 private network blocks, and a table called badhosts, which is initially empty. A filter rule is set up to block all traffic coming from addresses listed in either table. The private table cannot have its contents changed and the badhosts table will exist even when no active filter rules reference it. Addresses may later be added to the badhosts table, so that traffic from these hosts can be blocked by using<p>
<pre style="margin-left: 5.00ex;" class="lit display">
# pfctl -t badhosts -Tadd 204.92.77.111</pre>
<p>
A table can also be initialized with an address list specified in one or more external files, using the following syntax:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
table &lt;spam&gt; persist file "/etc/spammers" file "/etc/openrelays" 
block on fxp0 from &lt;spam&gt; to any</pre>
<p>
The files <i class="file">/etc/spammers</i> and <i class="file">/etc/openrelays</i> list IP addresses, one per line. Any lines beginning with a # are treated as comments and ignored. In addition to being specified by IP address, hosts may also be specified by their hostname. When the resolver is called to add a hostname to a table, <span class="emph">all</span> resulting IPv4 and IPv6 addresses are placed into the table. IP addresses can also be entered in a table by specifying a valid interface name, a valid interface group or the <span class="emph">self</span> keyword, in which case all addresses assigned to the interface(s) will be added to the table.</div>
<div class="section">
<h1 id="x4f5054494f4e53">OPTIONS</h1> <a class="link-man" href="../html4/pf.html">pf(4)</a> may be tuned for various situations using the <i class="arg">set</i> command.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">set timeout</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
<p>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">interval</i></dt>
<dd class="list-tag" style="margin-left: 9.00ex;">
Interval between purging expired states and fragments.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">frag</i></dt>
<dd class="list-tag" style="margin-left: 9.00ex;">
Seconds before an unassembled fragment is expired.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">src.track</i></dt>
<dd class="list-tag" style="margin-left: 9.00ex;">
Length of time to retain a source tracking entry after the last state expires.</dd>
</dl>
<p>
When a packet matches a stateful connection, the seconds to live for the connection will be updated to that of the <i class="arg">proto.modifier</i> which corresponds to the connection state. Each packet which matches this state will reset the TTL. Tuning these values may improve the performance of the firewall at the risk of dropping valid idle connections.<p>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">tcp.first</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The state after the first packet.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">tcp.opening</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The state before the destination host ever sends a packet.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">tcp.established</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The fully established state.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">tcp.closing</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The state after the first FIN has been sent.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">tcp.finwait</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The state after both FINs have been exchanged and the connection is closed. Some hosts (notably web servers on Solaris) send TCP packets even after closing the connection. Increasing <i class="arg">tcp.finwait</i> (and possibly <i class="arg">tcp.closing</i>) can prevent blocking of such packets.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">tcp.closed</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The state after one endpoint sends an RST.</dd>
</dl>
<p>
ICMP and UDP are handled in a fashion similar to TCP, but with a much more limited set of states:<p>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">udp.first</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The state after the first packet.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">udp.single</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The state if the source host sends more than one packet but the destination host has never sent one back.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">udp.multiple</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The state if both hosts have sent packets.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">icmp.first</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The state after the first packet.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">icmp.error</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The state after an ICMP error came back in response to an ICMP packet.</dd>
</dl>
<p>
Other protocols are handled similarly to UDP:<p>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">other.first</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">other.single</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">other.multiple</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
</dd>
</dl>
<p>
Timeout values can be reduced adaptively as the number of state table entries grows.<p>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">adaptive.start</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
When the number of state entries exceeds this value, adaptive scaling begins. All timeout values are scaled linearly with factor (adaptive.end - number of states) / (adaptive.end - adaptive.start).</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">adaptive.end</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
When reaching this number of state entries, all timeout values become zero, effectively purging all state entries immediately. This value is used to define the scale factor, it should not actually be reached (set a lower state limit, see below).</dd>
</dl>
<p>
Adaptive timeouts are enabled by default, with an adaptive.start value equal to 60% of the state limit, and an adaptive.end value equal to 120% of the state limit. They can be disabled by setting both adaptive.start and adaptive.end to 0.<p>
The adaptive timeout values can be defined both globally and for each rule. When used on a per-rule basis, the values relate to the number of states created by the rule, otherwise to the total number of states.<p>
For example:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
set timeout tcp.first 120 
set timeout tcp.established 86400 
set timeout { adaptive.start 6000, adaptive.end 12000 } 
set limit states 10000</pre>
<p>
With 9000 state table entries, the timeout values are scaled to 50% (tcp.first 60, tcp.established 43200).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">set loginterface</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Enable collection of packet and byte count statistics for the given interface. These statistics can be viewed using<p>
<pre style="margin-left: 5.00ex;" class="lit display">
# pfctl -s info</pre>
<p>
In this example <a class="link-man" href="../html4/pf.html">pf(4)</a> collects statistics on the interface named dc0:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
set loginterface dc0</pre>
<p>
One can disable the loginterface using:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
set loginterface none</pre>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">set limit</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Sets hard limits on the memory pools used by the packet filter. See <a class="link-man" href="../html9/pool.html">pool(9)</a> for an explanation of memory pools.<p>
For example,<p>
<pre style="margin-left: 5.00ex;" class="lit display">
set limit states 20000</pre>
<p>
sets the maximum number of entries in the memory pool used by state table entries (generated by <i class="arg">pass</i> rules which do not specify <i class="arg">no state</i>) to 20000. Using<p>
<pre style="margin-left: 5.00ex;" class="lit display">
set limit frags 20000</pre>
<p>
sets the maximum number of entries in the memory pool used for fragment reassembly (generated by <i class="arg">scrub</i> rules) to 20000. Using<p>
<pre style="margin-left: 5.00ex;" class="lit display">
set limit src-nodes 2000</pre>
<p>
sets the maximum number of entries in the memory pool used for tracking source IP addresses (generated by the <i class="arg">sticky-address</i> and <i class="arg">src.track</i> options) to 2000. Using<p>
<pre style="margin-left: 5.00ex;" class="lit display">
set limit tables 1000 
set limit table-entries 100000</pre>
<p>
sets limits on the memory pools used by tables. The first limits the number of tables that can exist to 1000. The second limits the overall number of addresses that can be stored in tables to 100000.<p>
Various limits can be combined on a single line:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
set limit { states 20000, frags 20000, src-nodes 2000 }</pre>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">set ruleset-optimization</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">none</i></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
Disable the ruleset optimizer.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">basic</i></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
Enable basic ruleset optimization. This is the default behaviour. Basic ruleset optimization does four things to improve the performance of ruleset evaluations:<p>
<ol style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-enum">
<li class="list-enum" style="margin-top: 0.00em;">
remove duplicate rules</li>
<li class="list-enum" style="margin-top: 0.00em;">
remove rules that are a subset of another rule</li>
<li class="list-enum" style="margin-top: 0.00em;">
combine multiple rules into a table when advantageous</li>
<li class="list-enum" style="margin-top: 0.00em;">
re-order the rules to improve evaluation performance</li>
</ol>
<p>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">profile</i></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
Uses the currently loaded ruleset as a feedback profile to tailor the ordering of quick rules to actual network traffic.</dd>
</dl>
<p>
It is important to note that the ruleset optimizer will modify the ruleset to improve performance. A side effect of the ruleset modification is that per-rule accounting statistics will have different meanings than before. If per-rule accounting is important for billing purposes or whatnot, either the ruleset optimizer should not be used or a label field should be added to all of the accounting rules to act as optimization barriers.<p>
Optimization can also be set as a command-line argument to <a class="link-man" href="../html8/pfctl.html">pfctl(8)</a>, overriding the settings in <b class="name">pf.conf</b>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">set optimization</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Optimize state timeouts for one of the following network environments:<p>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">normal</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
A normal network environment. Suitable for almost all networks.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">high-latency</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
A high-latency environment (such as a satellite connection).</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">satellite</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Alias for <i class="arg">high-latency</i>.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">aggressive</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Aggressively expire connections. This can greatly reduce the memory usage of the firewall at the cost of dropping idle connections early.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">conservative</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Extremely conservative settings. Avoid dropping legitimate connections at the expense of greater memory utilization (possibly much greater on a busy network) and slightly increased processor utilization.</dd>
</dl>
<p>
For example:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
set optimization aggressive</pre>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">set block-policy</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The <i class="arg">block-policy</i> option sets the default behaviour for the packet <i class="arg">block</i> action:<p>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">drop</i></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
Packet is silently dropped.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">return</i></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
A TCP RST is returned for blocked TCP packets, an ICMP UNREACHABLE is returned for blocked UDP packets, and all other packets are silently dropped.</dd>
</dl>
<p>
For example:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
set block-policy return</pre>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">set state-policy</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The <i class="arg">state-policy</i> option sets the default behaviour for states:<p>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">if-bound</i></dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
States are bound to interface.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">floating</i></dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
States can match packets on any interfaces (the default).</dd>
</dl>
<p>
For example:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
set state-policy if-bound</pre>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">set hostid</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The 32-bit <i class="arg">hostid</i> identifies this firewall's state table entries to other firewalls in a <a class="link-man" href="../html4/pfsync.html">pfsync(4)</a> failover cluster. By default the hostid is set to a pseudo-random value, however it may be desirable to manually configure it, for example to more easily identify the source of state table entries.<p>
<pre style="margin-left: 5.00ex;" class="lit display">
set hostid 1</pre>
<p>
The hostid may be specified in either decimal or hexadecimal.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">set require-order</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
By default <a class="link-man" href="../html8/pfctl.html">pfctl(8)</a> enforces an ordering of the statement types in the ruleset to: <span class="emph">options</span>, <span class="emph">normalization</span>, <span class="emph">queueing</span>, <span class="emph">translation</span>, <span class="emph">filtering</span>. Setting this option to <i class="arg">no</i> disables this enforcement. There may be non-trivial and non-obvious implications to an out of order ruleset. Consider carefully before disabling the order enforcement.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">set fingerprints</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Load fingerprints of known operating systems from the given filename. By default fingerprints of known operating systems are automatically loaded from <a class="link-man" href="../html5/pf.os.html">pf.os(5)</a> in <i class="file">/etc</i> but can be overridden via this option. Setting this option may leave a small period of time where the fingerprints referenced by the currently active ruleset are inconsistent until the new ruleset finishes loading.<p>
For example:<p>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">set fingerprints "/etc/pf.os.devel"</code></div>
</blockquote>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">set skip on</i> &#60;<i class="arg">ifspec</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
List interfaces for which packets should not be filtered. Packets passing in or out on such interfaces are passed as if pf was disabled, i.e. pf does not process them in any way. This can be useful on loopback and other virtual interfaces, when packet filtering is not desired and can have unexpected effects. For example:<p>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">set skip on lo0</code></div>
</blockquote>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">set debug</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Set the debug <i class="arg">level</i> to one of the following:<p>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">none</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Don't generate debug messages.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">urgent</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Generate debug messages only for serious errors.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">misc</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Generate debug messages for various errors.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">loud</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Generate debug messages for common conditions.</dd>
</dl>
</dd>
</dl>
</div>
<div class="section">
<h1 id="x54524146464943204e4f524d414c495a4154494f4e">TRAFFIC NORMALIZATION</h1> Traffic normalization is used to sanitize packet content in such a way that there are no ambiguities in packet interpretation on the receiving side. The normalizer does IP fragment reassembly to prevent attacks that confuse intrusion detection systems by sending overlapping IP fragments. Packet normalization is invoked with the <i class="arg">scrub</i> directive.<p>
<i class="arg">scrub</i> has the following options:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">no-df</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Clears the <i class="arg">dont-fragment</i> bit from a matching IP packet. Some operating systems are known to generate fragmented packets with the <i class="arg">dont-fragment</i> bit set. This is particularly true with NFS. <i class="arg">Scrub</i> will drop such fragmented <i class="arg">dont-fragment</i> packets unless <i class="arg">no-df</i> is specified.<p>
Unfortunately some operating systems also generate their <i class="arg">dont-fragment</i> packets with a zero IP identification field. Clearing the <i class="arg">dont-fragment</i> bit on packets with a zero IP ID may cause deleterious results if an upstream router later fragments the packet. Using the <i class="arg">random-id</i> modifier (see below) is recommended in combination with the <i class="arg">no-df</i> modifier to ensure unique IP identifiers.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">min-ttl</i> &#60;<i class="arg">number</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Enforces a minimum TTL for matching IP packets.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">max-mss</i> &#60;<i class="arg">number</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Enforces a maximum MSS for matching TCP packets.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">random-id</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Replaces the IP identification field with random values to compensate for predictable values generated by many hosts. This option only applies to packets that are not fragmented after the optional fragment reassembly.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">fragment reassemble</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Using <i class="arg">scrub</i> rules, fragments can be reassembled by normalization. In this case, fragments are buffered until they form a complete packet, and only the completed packet is passed on to the filter. The advantage is that filter rules have to deal only with complete packets, and can ignore fragments. The drawback of caching fragments is the additional memory cost. But the full reassembly method is the only method that currently works with NAT. This is the default behavior of a <i class="arg">scrub</i> rule if no fragmentation modifier is supplied.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">fragment crop</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The default fragment reassembly method is expensive, hence the option to crop is provided. In this case, <a class="link-man" href="../html4/pf.html">pf(4)</a> will track the fragments and cache a small range descriptor. Duplicate fragments are dropped and overlaps are cropped. Thus data will only occur once on the wire with ambiguities resolving to the first occurrence. Unlike the <i class="arg">fragment reassemble</i> modifier, fragments are not buffered, they are passed as soon as they are received. The <i class="arg">fragment crop</i> reassembly mechanism does not yet work with NAT.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">fragment drop-ovl</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
This option is similar to the <i class="arg">fragment crop</i> modifier except that all overlapping or duplicate fragments will be dropped, and all further corresponding fragments will be dropped as well.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">reassemble tcp</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Statefully normalizes TCP connections. <i class="arg">scrub reassemble tcp</i> rules may not have the direction (in/out) specified. <i class="arg">reassemble tcp</i> performs the following normalizations:<p>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
ttl</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Neither side of the connection is allowed to reduce their IP TTL. An attacker may send a packet such that it reaches the firewall, affects the firewall state, and expires before reaching the destination host. <i class="arg">reassemble tcp</i> will raise the TTL of all packets back up to the highest value seen on the connection.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
timestamp modulation</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Modern TCP stacks will send a timestamp on every TCP packet and echo the other endpoint's timestamp back to them. Many operating systems will merely start the timestamp at zero when first booted, and increment it several times a second. The uptime of the host can be deduced by reading the timestamp and multiplying by a constant. Also observing several different timestamps can be used to count hosts behind a NAT device. And spoofing TCP packets into a connection requires knowing or guessing valid timestamps. Timestamps merely need to be monotonically increasing and not derived off a guessable base time. <i class="arg">reassemble tcp</i> will cause <i class="arg">scrub</i> to modulate the TCP timestamps with a random number.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
extended PAWS checks</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
There is a problem with TCP on long fat pipes, in that a packet might get delayed for longer than it takes the connection to wrap its 32-bit sequence space. In such an occurrence, the old packet would be indistinguishable from a new packet and would be accepted as such. The solution to this is called PAWS: Protection Against Wrapped Sequence numbers. It protects against it by making sure the timestamp on each packet does not go backwards. <i class="arg">reassemble tcp</i> also makes sure the timestamp on the packet does not go forward more than the RFC allows. By doing this, <a class="link-man" href="../html4/pf.html">pf(4)</a> artificially extends the security of TCP sequence numbers by 10 to 18 bits when the host uses appropriately randomized timestamps, since a blind attacker would have to guess the timestamp as well.</dd>
</dl>
</dd>
</dl>
<p>
For example,<p>
<pre style="margin-left: 5.00ex;" class="lit display">
scrub in on $ext_if all fragment reassemble</pre>
<p>
The <i class="arg">no</i> option prefixed to a scrub rule causes matching packets to remain unscrubbed, much in the same way as <i class="arg">drop quick</i> works in the packet filter (see below). This mechanism should be used when it is necessary to exclude specific packets from broader scrub rules.</div>
<div class="section">
<h1 id="x5155455545494e47">QUEUEING</h1> Packets can be assigned to queues for the purpose of bandwidth control. At least two declarations are required to configure queues, and later any packet filtering rule can reference the defined queues by name. During the filtering component of <b class="name">pf.conf</b>, the last referenced <i class="arg">queue</i> name is where any packets from <i class="arg">pass</i> rules will be queued, while for <i class="arg">block</i> rules it specifies where any resulting ICMP or TCP RST packets should be queued. The <i class="arg">scheduler</i> defines the algorithm used to decide which packets get delayed, dropped, or sent out immediately. There are three <i class="arg">schedulers</i> currently supported.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">cbq</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Class Based Queueing. <i class="arg">Queues</i> attached to an interface build a tree, thus each <i class="arg">queue</i> can have further child <i class="arg">queues</i>. Each queue can have a <i class="arg">priority</i> and a <i class="arg">bandwidth</i> assigned. <i class="arg">Priority</i> mainly controls the time packets take to get sent out, while <i class="arg">bandwidth</i> has primarily effects on throughput. <i class="arg">cbq</i> achieves both partitioning and sharing of link bandwidth by hierarchically structured classes. Each class has its own <i class="arg">queue</i> and is assigned its share of <i class="arg">bandwidth</i>. A child class can borrow bandwidth from its parent class as long as excess bandwidth is available (see the option <i class="arg">borrow</i>, below).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">priq</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Priority Queueing. <i class="arg">Queues</i> are flat attached to the interface, thus, <i class="arg">queues</i> cannot have further child <i class="arg">queues</i>. Each <i class="arg">queue</i> has a unique <i class="arg">priority</i> assigned, ranging from 0 to 15. Packets in the <i class="arg">queue</i> with the highest <i class="arg">priority</i> are processed first.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">hfsc</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Hierarchical Fair Service Curve. <i class="arg">Queues</i> attached to an interface build a tree, thus each <i class="arg">queue</i> can have further child <i class="arg">queues</i>. Each queue can have a <i class="arg">priority</i> and a <i class="arg">bandwidth</i> assigned. <i class="arg">Priority</i> mainly controls the time packets take to get sent out, while <i class="arg">bandwidth</i> has primarily effects on throughput. <i class="arg">hfsc</i> supports both link-sharing and guaranteed real-time services. It employs a service curve based QoS model, and its unique feature is an ability to decouple <i class="arg">delay</i> and <i class="arg">bandwidth</i> allocation.</dd>
</dl>
<p>
The interfaces on which queueing should be activated are declared using the <i class="arg">altq on</i> declaration. <i class="arg">altq on</i> has the following keywords:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
&#60;<i class="arg">interface</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Queueing is enabled on the named interface.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#60;<i class="arg">scheduler</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Specifies which queueing scheduler to use. Currently supported values are <i class="arg">cbq</i> for Class Based Queueing, <i class="arg">priq</i> for Priority Queueing and <i class="arg">hfsc</i> for the Hierarchical Fair Service Curve scheduler.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">bandwidth</i> &#60;<i class="arg">bw</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The maximum bitrate for all queues on an interface may be specified using the <i class="arg">bandwidth</i> keyword. The value can be specified as an absolute value or as a percentage of the interface bandwidth. When using an absolute value, the suffixes <i class="arg">b</i>, <i class="arg">Kb</i>, <i class="arg">Mb</i>, and <i class="arg">Gb</i> are used to represent bits, kilobits, megabits, and gigabits per second, respectively. The value must not exceed the interface bandwidth. If <i class="arg">bandwidth</i> is not specified, the interface bandwidth is used (but take note that some interfaces do not know their bandwidth, or can adapt their bandwidth rates).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">qlimit</i> &#60;<i class="arg">limit</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The maximum number of packets held in the queue. The default is 50.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">tbrsize</i> &#60;<i class="arg">size</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Adjusts the size, in bytes, of the token bucket regulator. If not specified, heuristics based on the interface bandwidth are used to determine the size.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">queue</i> &#60;<i class="arg">list</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Defines a list of subqueues to create on an interface.</dd>
</dl>
<p>
In the following example, the interface dc0 should queue up to 5 Mbit/s in four second-level queues using Class Based Queueing. Those four queues will be shown in a later example.<p>
<pre style="margin-left: 5.00ex;" class="lit display">
altq on dc0 cbq bandwidth 5Mb queue { std, http, mail, ssh }</pre>
<p>
Once interfaces are activated for queueing using the <i class="arg">altq</i> directive, a sequence of <i class="arg">queue</i> directives may be defined. The name associated with a <i class="arg">queue</i> must match a queue defined in the <i class="arg">altq</i> directive (e.g. mail), or, except for the <i class="arg">priq</i> <i class="arg">scheduler</i>, in a parent <i class="arg">queue</i> declaration. The following keywords can be used:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">on</i> &#60;<i class="arg">interface</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Specifies the interface the queue operates on. If not given, it operates on all matching interfaces.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">bandwidth</i> &#60;<i class="arg">bw</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Specifies the maximum bitrate to be processed by the queue. This value must not exceed the value of the parent <i class="arg">queue</i> and can be specified as an absolute value or a percentage of the parent queue's bandwidth. If not specified, defaults to 100% of the parent queue's bandwidth. The <i class="arg">priq</i> scheduler does not support bandwidth specification.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">priority</i> &#60;<i class="arg">level</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Between queues a priority level can be set. For <i class="arg">cbq</i> and <i class="arg">hfsc</i>, the range is 0 to 7 and for <i class="arg">priq</i>, the range is 0 to 15. The default for all is 1. <i class="arg">Priq</i> queues with a higher priority are always served first. <i class="arg">Cbq</i> and <i class="arg">Hfsc</i> queues with a higher priority are preferred in the case of overload.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">qlimit</i> &#60;<i class="arg">limit</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The maximum number of packets held in the queue. The default is 50.</dd>
</dl>
<p>
The <i class="arg">scheduler</i> can get additional parameters with &#60;<i class="arg">scheduler</i>&#62; (&#60;<i class="arg">parameters</i>&#62;). Parameters are as follows:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">default</i></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Packets not matched by another queue are assigned to this one. Exactly one default queue is required.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">red</i></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Enable RED (Random Early Detection) on this queue. RED drops packets with a probability proportional to the average queue length.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">rio</i></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Enables RIO on this queue. RIO is RED with IN/OUT, thus running RED two times more than RIO would achieve the same effect. RIO is currently not supported in the GENERIC kernel.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">ecn</i></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Enables ECN (Explicit Congestion Notification) on this queue. ECN implies RED.</dd>
</dl>
<p>
The <i class="arg">cbq</i> <i class="arg">scheduler</i> supports an additional option:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">borrow</i></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
The queue can borrow bandwidth from the parent.</dd>
</dl>
<p>
The <i class="arg">hfsc</i> <i class="arg">scheduler</i> supports some additional options:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">realtime</i> &#60;<i class="arg">sc</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
The minimum required bandwidth for the queue.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">upperlimit</i> &#60;<i class="arg">sc</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
The maximum allowed bandwidth for the queue.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">linkshare</i> &#60;<i class="arg">sc</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
The bandwidth share of a backlogged queue.</dd>
</dl>
<p>
&#60;<i class="arg">sc</i>&#62; is an acronym for <i class="arg">service curve</i>.<p>
The format for service curve specifications is (<i class="arg">m1</i>, <i class="arg">d</i>, <i class="arg">m2</i>). <i class="arg">m2</i> controls the bandwidth assigned to the queue. <i class="arg">m1</i> and <i class="arg">d</i> are optional and can be used to control the initial bandwidth assignment. For the first <i class="arg">d</i> milliseconds the queue gets the bandwidth given as <i class="arg">m1</i>, afterwards the value given in <i class="arg">m2</i>.<p>
Furthermore, with <i class="arg">cbq</i> and <i class="arg">hfsc</i>, child queues can be specified as in an <i class="arg">altq</i> declaration, thus building a tree of queues using a part of their parent's bandwidth.<p>
Packets can be assigned to queues based on filter rules by using the <i class="arg">queue</i> keyword. Normally only one <i class="arg">queue</i> is specified; when a second one is specified it will instead be used for packets which have a <span class="emph">TOS</span> of <span class="emph">lowdelay</span> and for TCP ACKs with no data payload.<p>
To continue the previous example, the examples below would specify the four referenced queues, plus a few child queues. Interactive <a class="link-man" href="../html1/ssh.html">ssh(1)</a> sessions get priority over bulk transfers like <a class="link-man" href="../html1/scp.html">scp(1)</a> and <a class="link-man" href="../html1/sftp.html">sftp(1)</a>. The queues may then be referenced by filtering rules (see <i class="link-sec"><a class="link-sec" href="#x5041434b45542046494c544552494e47">PACKET FILTERING</a></i> below).<p>
<pre style="margin-left: 0.00ex;" class="lit display">
queue std bandwidth 10% cbq(default) 
queue http bandwidth 60% priority 2 cbq(borrow red) &#92; 
      { employees, developers } 
queue  developers bandwidth 75% cbq(borrow) 
queue  employees bandwidth 15% 
queue mail bandwidth 10% priority 0 cbq(borrow ecn) 
queue ssh bandwidth 20% cbq(borrow) { ssh_interactive, ssh_bulk } 
queue  ssh_interactive bandwidth 50% priority 7 cbq(borrow) 
queue  ssh_bulk bandwidth 50% priority 0 cbq(borrow) 
 
block return out on dc0 inet all queue std 
pass out on dc0 inet proto tcp from $developerhosts to any port 80 &#92; 
      queue developers 
pass out on dc0 inet proto tcp from $employeehosts to any port 80 &#92; 
      queue employees 
pass out on dc0 inet proto tcp from any to any port 22 &#92; 
      queue(ssh_bulk, ssh_interactive) 
pass out on dc0 inet proto tcp from any to any port 25 &#92; 
      queue mail</pre>
</div>
<div class="section">
<h1 id="x5452414e534c4154494f4e">TRANSLATION</h1> Translation rules modify either the source or destination address of the packets associated with a stateful connection. A stateful connection is automatically created to track packets matching such a rule as long as they are not blocked by the filtering section of <b class="name">pf.conf</b>. The translation engine modifies the specified address and/or port in the packet, recalculates IP, TCP and UDP checksums as necessary, and passes it to the packet filter for evaluation.<p>
Since translation occurs before filtering the filter engine will see packets as they look after any addresses and ports have been translated. Filter rules will therefore have to filter based on the translated address and port number. Packets that match a translation rule are only automatically passed if the <i class="arg">pass</i> modifier is given, otherwise they are still subject to <i class="arg">block</i> and <i class="arg">pass</i> rules.<p>
The state entry created permits <a class="link-man" href="../html4/pf.html">pf(4)</a> to keep track of the original address for traffic associated with that state and correctly direct return traffic for that connection.<p>
Various types of translation are possible with pf:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">binat</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
A <i class="arg">binat</i> rule specifies a bidirectional mapping between an external IP netblock and an internal IP netblock.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">nat</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
A <i class="arg">nat</i> rule specifies that IP addresses are to be changed as the packet traverses the given interface. This technique allows one or more IP addresses on the translating host to support network traffic for a larger range of machines on an "inside" network. Although in theory any IP address can be used on the inside, it is strongly recommended that one of the address ranges defined by RFC 1918 be used. These netblocks are:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
10.0.0.0 - 10.255.255.255 (all of net 10, i.e., 10/8) 
172.16.0.0 - 172.31.255.255 (i.e., 172.16/12) 
192.168.0.0 - 192.168.255.255 (i.e., 192.168/16)</pre>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="file">rdr</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The packet is redirected to another destination and possibly a different port. <i class="arg">rdr</i> rules can optionally specify port ranges instead of single ports. rdr ... port 2000:2999 -&gt; ... port 4000 redirects ports 2000 to 2999 (inclusive) to port 4000. rdr ... port 2000:2999 -&gt; ... port 4000:* redirects port 2000 to 4000, 2001 to 4001, ..., 2999 to 4999.</dd>
</dl>
<p>
In addition to modifying the address, some translation rules may modify source or destination ports for <a class="link-man" href="../html4/tcp.html">tcp(4)</a> or <a class="link-man" href="../html4/udp.html">udp(4)</a> connections; implicitly in the case of <i class="arg">nat</i> rules and explicitly in the case of <i class="arg">rdr</i> rules. Port numbers are never translated with a <i class="arg">binat</i> rule.<p>
Evaluation order of the translation rules is dependent on the type of the translation rules and of the direction of a packet. <i class="arg">binat</i> rules are always evaluated first. Then either the <i class="arg">rdr</i> rules are evaluated on an inbound packet or the <i class="arg">nat</i> rules on an outbound packet. Rules of the same type are evaluated in the same order in which they appear in the ruleset. The first matching rule decides what action is taken.<p>
The <i class="arg">no</i> option prefixed to a translation rule causes packets to remain untranslated, much in the same way as <i class="arg">drop quick</i> works in the packet filter (see below). If no rule matches the packet it is passed to the filter engine unmodified.<p>
Translation rules apply only to packets that pass through the specified interface, and if no interface is specified, translation is applied to packets on all interfaces. For instance, redirecting port 80 on an external interface to an internal web server will only work for connections originating from the outside. Connections to the address of the external interface from local hosts will not be redirected, since such packets do not actually pass through the external interface. Redirections cannot reflect packets back through the interface they arrive on, they can only be redirected to hosts connected to different interfaces or to the firewall itself.<p>
Note that redirecting external incoming connections to the loopback address, as in<p>
<pre style="margin-left: 5.00ex;" class="lit display">
rdr on ne3 inet proto tcp to port spamd -&gt; 127.0.0.1 port smtp</pre>
<p>
will effectively allow an external host to connect to daemons bound solely to the loopback address, circumventing the traditional blocking of such connections on a real interface. Unless this effect is desired, any of the local non-loopback addresses should be used as redirection target instead, which allows external connections only to daemons bound to this address or not bound to any address.<p>
See <i class="link-sec"><a class="link-sec" href="#x5452414e534c4154494f4e204558414d504c4553">TRANSLATION EXAMPLES</a></i> below.</div>
<div class="section">
<h1 id="x5041434b45542046494c544552494e47">PACKET FILTERING</h1> <a class="link-man" href="../html4/pf.html">pf(4)</a> has the ability to <i class="arg">block</i> and <i class="arg">pass</i> packets based on attributes of their layer 3 (see <a class="link-man" href="../html4/ip.html">ip(4)</a> and <a class="link-man" href="../html4/ip6.html">ip6(4)</a>) and layer 4 (see <a class="link-man" href="../html4/icmp.html">icmp(4)</a>, <a class="link-man" href="../html4/icmp6.html">icmp6(4)</a>, <a class="link-man" href="../html4/tcp.html">tcp(4)</a>, <a class="link-man" href="../html4/udp.html">udp(4)</a>) headers. In addition, packets may also be assigned to queues for the purpose of bandwidth control.<p>
For each packet processed by the packet filter, the filter rules are evaluated in sequential order, from first to last. The last matching rule decides what action is taken. If no rule matches the packet, the default action is to pass the packet.<p>
The following actions can be used in the filter:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">block</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The packet is blocked. There are a number of ways in which a <i class="arg">block</i> rule can behave when blocking a packet. The default behaviour is to <i class="arg">drop</i> packets silently, however this can be overridden or made explicit either globally, by setting the <i class="arg">block-policy</i> option, or on a per-rule basis with one of the following options:<p>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">drop</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The packet is silently dropped.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">return-rst</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
This applies only to <a class="link-man" href="../html4/tcp.html">tcp(4)</a> packets, and issues a TCP RST which closes the connection.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">return-icmp</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">return-icmp6</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
This causes ICMP messages to be returned for packets which match the rule. By default this is an ICMP UNREACHABLE message, however this can be overridden by specifying a message as a code or number.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">return</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
This causes a TCP RST to be returned for <a class="link-man" href="../html4/tcp.html">tcp(4)</a> packets and an ICMP UNREACHABLE for UDP and other packets.</dd>
</dl>
<p>
Options returning ICMP packets currently have no effect if <a class="link-man" href="../html4/pf.html">pf(4)</a> operates on a <a class="link-man" href="../html4/bridge.html">bridge(4)</a>, as the code to support this feature has not yet been implemented.<p>
The simplest mechanism to block everything by default and only pass packets that match explicit rules is specify a first filter rule of:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
block all</pre>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">pass</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The packet is passed; state is created unless the <i class="arg">no state</i> option is specified.</dd>
</dl>
<p>
By default <a class="link-man" href="../html4/pf.html">pf(4)</a> filters packets statefully; the first time a packet matches a <i class="arg">pass</i> rule, a state entry is created; for subsequent packets the filter checks whether the packet matches any state. If it does, the packet is passed without evaluation of any rules. After the connection is closed or times out, the state entry is automatically removed.<p>
This has several advantages. For TCP connections, comparing a packet to a state involves checking its sequence numbers, as well as TCP timestamps if a <i class="arg">scrub reassemble tcp</i> rule applies to the connection. If these values are outside the narrow windows of expected values, the packet is dropped. This prevents spoofing attacks, such as when an attacker sends packets with a fake source address/port but does not know the connection's sequence numbers. Similarly, <a class="link-man" href="../html4/pf.html">pf(4)</a> knows how to match ICMP replies to states. For example,<p>
<pre style="margin-left: 5.00ex;" class="lit display">
pass out inet proto icmp all icmp-type echoreq</pre>
<p>
allows echo requests (such as those created by <a class="link-man" href="../html8/ping.html">ping(8)</a>) out statefully, and matches incoming echo replies correctly to states.<p>
Also, looking up states is usually faster than evaluating rules. If there are 50 rules, all of them are evaluated sequentially in O(n). Even with 50000 states, only 16 comparisons are needed to match a state, since states are stored in a binary search tree that allows searches in O(log2 n).<p>
Furthermore, correct handling of ICMP error messages is critical to many protocols, particularly TCP. <a class="link-man" href="../html4/pf.html">pf(4)</a> matches ICMP error messages to the correct connection, checks them against connection parameters, and passes them if appropriate. For example if an ICMP source quench message referring to a stateful TCP connection arrives, it will be matched to the state and get passed.<p>
Finally, state tracking is required for <i class="arg">nat</i>, <i class="arg">binat</i> and <i class="arg">rdr</i> rules, in order to track address and port translations and reverse the translation on returning packets.<p>
<a class="link-man" href="../html4/pf.html">pf(4)</a> will also create state for other protocols which are effectively stateless by nature. UDP packets are matched to states using only host addresses and ports, and other protocols are matched to states using only the host addresses.<p>
If stateless filtering of individual packets is desired, the <i class="arg">no state</i> keyword can be used to specify that state will not be created if this is the last matching rule. A number of parameters can also be set to affect how <a class="link-man" href="../html4/pf.html">pf(4)</a> handles state tracking. See <i class="link-sec"><a class="link-sec" href="#x535441544546554c20545241434b494e47204f5054494f4e53">STATEFUL TRACKING OPTIONS</a></i> below for further details.</div>
<div class="section">
<h1 id="x504152414d4554455253">PARAMETERS</h1> The rule parameters specify the packets to which a rule applies. A packet always comes in on, or goes out through, one interface. Most parameters are optional. If a parameter is specified, the rule only applies to packets with matching attributes. Certain parameters can be expressed as lists, in which case <a class="link-man" href="../html8/pfctl.html">pfctl(8)</a> generates all needed rule combinations.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">in</i> or <i class="arg">out</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
This rule applies to incoming or outgoing packets. If neither <i class="arg">in</i> nor <i class="arg">out</i> are specified, the rule will match packets in both directions.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">log</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
In addition to the action specified, a log message is generated. Only the packet that establishes the state is logged, unless the <i class="arg">no state</i> option is specified. The logged packets are sent to a <a class="link-man" href="../html4/pflog.html">pflog(4)</a> interface, by default <i class="arg">pflog0</i>. This interface is monitored by the <a class="link-man" href="../html8/pflogd.html">pflogd(8)</a> logging daemon, which dumps the logged packets to the file <i class="file">/var/log/pflog</i> in <a class="link-man" href="../html3/pcap.html">pcap(3)</a> binary format.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">log (all)</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Used to force logging of all packets for a connection. This is not necessary when <i class="arg">no state</i> is explicitly specified. As with <i class="arg">log</i>, packets are logged to <a class="link-man" href="../html4/pflog.html">pflog(4)</a>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">log (user)</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Logs the <span class="unix">UNIX</span> user ID of the user that owns the socket and the PID of the process that has the socket open where the packet is sourced from or destined to (depending on which socket is local). This is in addition to the normal information logged.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">log (to</i> &#60;<i class="arg">interface</i>&#62;)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Send logs to the specified <a class="link-man" href="../html4/pflog.html">pflog(4)</a> interface instead of <i class="arg">pflog0</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">quick</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
If a packet matches a rule which has the <i class="arg">quick</i> option set, this rule is considered the last matching rule, and evaluation of subsequent rules is skipped.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">on</i> &#60;<i class="arg">interface</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
This rule applies only to packets coming in on, or going out through, this particular interface or interface group. For more information on interface groups, see the <b class="cmd">group</b> keyword in <a class="link-man" href="../html8/ifconfig.html">ifconfig(8)</a>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#60;<i class="arg">af</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
This rule applies only to packets of this address family. Supported values are <i class="arg">inet</i> and <i class="arg">inet6</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">proto</i> &#60;<i class="arg">protocol</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
This rule applies only to packets of this protocol. Common protocols are <a class="link-man" href="../html4/icmp.html">icmp(4)</a>, <a class="link-man" href="../html4/icmp6.html">icmp6(4)</a>, <a class="link-man" href="../html4/tcp.html">tcp(4)</a>, and <a class="link-man" href="../html4/udp.html">udp(4)</a>. For a list of all the protocol name to number mappings used by <a class="link-man" href="../html8/pfctl.html">pfctl(8)</a>, see the file <span class="emph">/etc/protocols</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">from</i> &#60;<i class="arg">source</i>&#62; <i class="arg">port</i> &#60;<i class="arg">source</i>&#62; <i class="arg">os</i> &#60;<i class="arg">source</i>&#62; <i class="arg">to</i> &#60;<i class="arg">dest</i>&#62; <i class="arg">port</i> &#60;<i class="arg">dest</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
This rule applies only to packets with the specified source and destination addresses and ports.<p>
Addresses can be specified in CIDR notation (matching netblocks), as symbolic host names, interface names or interface group names, or as any of the following keywords:<p>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">any</i></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
Any address.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">route</i> &#60;<i class="arg">label</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
Any address whose associated route has label &#60;<i class="arg">label</i>&#62;. See <a class="link-man" href="../html4/route.html">route(4)</a> and <a class="link-man" href="../html8/route.html">route(8)</a>.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">no-route</i></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
Any address which is not currently routable.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">urpf-failed</i></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
Any source address that fails a unicast reverse path forwarding (URPF) check, i.e. packets coming in on an interface other than that which holds the route back to the packet's source address.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
&#60;<i class="arg">table</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
Any address that matches the given table.</dd>
</dl>
<p>
Interface names and interface group names can have modifiers appended:<p>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">:network</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Translates to the network(s) attached to the interface.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">:broadcast</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Translates to the interface's broadcast address(es).</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">:peer</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Translates to the point to point interface's peer address(es).</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">:0</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Do not include interface aliases.</dd>
</dl>
<p>
Host names may also have the <i class="arg">:0</i> option appended to restrict the name resolution to the first of each v4 and v6 address found.<p>
Host name resolution and interface to address translation are done at ruleset load-time. When the address of an interface (or host name) changes (under DHCP or PPP, for instance), the ruleset must be reloaded for the change to be reflected in the kernel. Surrounding the interface name (and optional modifiers) in parentheses changes this behaviour. When the interface name is surrounded by parentheses, the rule is automatically updated whenever the interface changes its address. The ruleset does not need to be reloaded. This is especially useful with <i class="arg">nat</i>.<p>
Ports can be specified either by number or by name. For example, port 80 can be specified as <span class="emph">www</span>. For a list of all port name to number mappings used by <a class="link-man" href="../html8/pfctl.html">pfctl(8)</a>, see the file <i class="file">/etc/services</i>.<p>
Ports and ranges of ports are specified by using these operators:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
=	(equal) 
!=	(unequal) 
&lt;	(less than) 
&#8804;	(less than or equal) 
&gt;	(greater than) 
&#8805;	(greater than or equal) 
:	(range including boundaries) 
&gt;&lt;	(range excluding boundaries) 
&lt;&gt;	(except range)</pre>
<p>
&#8216;&gt;&lt;&#8217;, &#8216;&lt;&gt;&#8217; and &#8216;:&#8217; are binary operators (they take two arguments). For instance:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">port 2000:2004</i></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
means &#8216;all ports &#8805; 2000 and &#8804; 2004&#8217;, hence ports 2000, 2001, 2002, 2003 and 2004.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">port 2000 &gt;&lt; 2004</i></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
means &#8216;all ports &gt; 2000 and &lt; 2004&#8217;, hence ports 2001, 2002 and 2003.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">port 2000 &lt;&gt; 2004</i></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
means &#8216;all ports &lt; 2000 or &gt; 2004&#8217;, hence ports 1-1999 and 2005-65535.</dd>
</dl>
<p>
The operating system of the source host can be specified in the case of TCP rules with the <i class="arg">OS</i> modifier. See the <i class="link-sec"><a class="link-sec" href="#x4f5045524154494e472053595354454d2046494e4745525052494e54494e47">OPERATING SYSTEM FINGERPRINTING</a></i> section for more information.<p>
The host, port and OS specifications are optional, as in the following examples:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
pass in all 
pass in from any to any 
pass in proto tcp from any port &#8804; 1024 to any 
pass in proto tcp from any to any port 25 
pass in proto tcp from 10.0.0.0/8 port &gt; 1024 &#92; 
      to ! 10.1.2.3 port != ssh 
pass in proto tcp from any os "OpenBSD" 
pass in proto tcp from route "DTAG"</pre>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">all</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
This is equivalent to "from any to any".</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">group</i> &#60;<i class="arg">group</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
This functionality is not supported in this version of <span class="unix">NetBSD</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">user</i> &#60;<i class="arg">user</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
This rule only applies to packets of sockets owned by the specified user. For outgoing connections initiated from the firewall, this is the user that opened the connection. For incoming connections to the firewall itself, this is the user that listens on the destination port. For forwarded connections, where the firewall is not a connection endpoint, the user and group are <span class="emph">unknown</span>.<p>
All packets, both outgoing and incoming, of one connection are associated with the same user and group. Only TCP and UDP packets can be associated with users; for other protocols these parameters are ignored.<p>
User and group refer to the effective (as opposed to the real) IDs, in case the socket is created by a setuid/setgid process. User and group IDs are stored when a socket is created; when a process creates a listening socket as root (for instance, by binding to a privileged port) and subsequently changes to another user ID (to drop privileges), the credentials will remain root.<p>
User and group IDs can be specified as either numbers or names. The syntax is similar to the one for ports. The value <span class="emph">unknown</span> matches packets of forwarded connections. <span class="emph">unknown</span> can only be used with the operators <b class="flag">=</b> and <b class="flag">!=</b>. Other constructs like <b class="flag">user &#8805; unknown</b> are invalid. Forwarded packets with unknown user and group ID match only rules that explicitly compare against <span class="emph">unknown</span> with the operators <b class="flag">=</b> or <b class="flag">!=</b>. For instance <b class="flag">user &#8805; 0</b> does not match forwarded packets. The following example allows only selected users to open outgoing connections:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
block out proto { tcp, udp } all 
pass  out proto { tcp, udp } all user { &lt; 1000, dhartmei }</pre>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">flags</i> &#60;<i class="arg">a</i>&#62; /&#60;<i class="arg">b</i>&#62; | /&#60;<i class="arg">b</i>&#62; | any</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
This rule only applies to TCP packets that have the flags &#60;<i class="arg">a</i>&#62; set out of set &#60;<i class="arg">b</i>&#62;. Flags not specified in &#60;<i class="arg">b</i>&#62; are ignored. For stateful connections, the default is <i class="arg">flags S/SA</i>. To indicate that flags should not be checked at all, specify <i class="arg">flags any</i>. The flags are: (F)IN, (S)YN, (R)ST, (P)USH, (A)CK, (U)RG, (E)CE, and C(W)R.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">flags S/S</i></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Flag SYN is set. The other flags are ignored.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">flags S/SA</i></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
This is the default setting for stateful connections. Out of SYN and ACK, exactly SYN may be set. SYN, SYN+PSH and SYN+RST match, but SYN+ACK, ACK and ACK+RST do not. This is more restrictive than the previous example.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">flags /SFRA</i></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
If the first set is not specified, it defaults to none. All of SYN, FIN, RST and ACK must be unset.</dd>
</dl>
<p>
Because <i class="arg">flags S/SA</i> is applied by default (unless <i class="arg">no state</i> is specified), only the initial SYN packet of a TCP handshake will create a state for a TCP connection. It is possible to be less restrictive, and allow state creation from intermediate (non-SYN) packets, by specifying <i class="arg">flags any</i>. This will cause <a class="link-man" href="../html4/pf.html">pf(4)</a> to synchronize to existing connections, for instance if one flushes the state table. However, states created from such intermediate packets may be missing connection details such as the TCP window scaling factor. States which modify the packet flow, such as those affected by <i class="arg">nat</i>, <i class="arg">binat</i> or <i class="arg">rdr</i> rules, <i class="arg">modulate</i> or <i class="arg">synproxy state</i> options, or scrubbed with <i class="arg">reassemble tcp</i> will also not be recoverable from intermediate packets. Such connections will stall and time out.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">icmp-type</i> &#60;<i class="arg">type</i>&#62; <i class="arg">code</i> &#60;<i class="arg">code</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">icmp6-type</i> &#60;<i class="arg">type</i>&#62; <i class="arg">code</i> &#60;<i class="arg">code</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
This rule only applies to ICMP or ICMPv6 packets with the specified type and code. Text names for ICMP types and codes are listed in <a class="link-man" href="../html4/icmp.html">icmp(4)</a> and <a class="link-man" href="../html4/icmp6.html">icmp6(4)</a>. This parameter is only valid for rules that cover protocols ICMP or ICMP6. The protocol and the ICMP type indicator (<i class="arg">icmp-type</i> or <i class="arg">icmp6-type</i>) must match.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">tos</i> &#60;<i class="arg">string</i>&#62; | &#60;<i class="arg">number</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
This rule applies to packets with the specified <span class="emph">TOS</span> bits set. <span class="emph">TOS</span> may be given as one of <i class="arg">lowdelay</i>, <i class="arg">throughput</i>, <i class="arg">reliability</i>, or as either hex or decimal.<p>
For example, the following rules are identical:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
pass all tos lowdelay 
pass all tos 0x10 
pass all tos 16</pre>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">allow-opts</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
By default, IPv4 packets with IP options or IPv6 packets with routing extension headers are blocked. When <i class="arg">allow-opts</i> is specified for a <i class="arg">pass</i> rule, packets that pass the filter based on that rule (last matching) do so even if they contain IP options or routing extension headers. For packets that match state, the rule that initially created the state is used. The implicit <i class="arg">pass</i> rule that is used when a packet does not match any rules does not allow IP options.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">label</i> &#60;<i class="arg">string</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Adds a label (name) to the rule, which can be used to identify the rule. For instance, pfctl -s labels shows per-rule statistics for rules that have labels.<p>
The following macros can be used in labels:<p>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">$if</i></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
The interface.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">$srcaddr</i></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
The source IP address.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">$dstaddr</i></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
The destination IP address.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">$srcport</i></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
The source port specification.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">$dstport</i></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
The destination port specification.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">$proto</i></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
The protocol name.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">$nr</i></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
The rule number.</dd>
</dl>
<p>
For example:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
ips = "{ 1.2.3.4, 1.2.3.5 }" 
pass in proto tcp from any to $ips &#92; 
      port &gt; 1023 label "$dstaddr:$dstport"</pre>
<p>
expands to<p>
<pre style="margin-left: 5.00ex;" class="lit display">
pass in inet proto tcp from any to 1.2.3.4 &#92; 
      port &gt; 1023 label "1.2.3.4:&gt;1023" 
pass in inet proto tcp from any to 1.2.3.5 &#92; 
      port &gt; 1023 label "1.2.3.5:&gt;1023"</pre>
<p>
The macro expansion for the <i class="arg">label</i> directive occurs only at configuration file parse time, not during runtime.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">queue</i> &#60;<i class="arg">queue</i>&#62; | (&#60;<i class="arg">queue</i>&#62;, &#60;<i class="arg">queue</i>&#62;)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Packets matching this rule will be assigned to the specified queue. If two queues are given, packets which have a <span class="emph">TOS</span> of <span class="emph">lowdelay</span> and TCP ACKs with no data payload will be assigned to the second one. See <i class="link-sec"><a class="link-sec" href="#x5155455545494e47">QUEUEING</a></i> for setup details.<p>
For example:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
pass in proto tcp to port 25 queue mail 
pass in proto tcp to port 22 queue(ssh_bulk, ssh_prio)</pre>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">tag</i> &#60;<i class="arg">string</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Packets matching this rule will be tagged with the specified string. The tag acts as an internal marker that can be used to identify these packets later on. This can be used, for example, to provide trust between interfaces and to determine if packets have been processed by translation rules. Tags are &#8220;sticky&#8221;, meaning that the packet will be tagged even if the rule is not the last matching rule. Further matching rules can replace the tag with a new one but will not remove a previously applied tag. A packet is only ever assigned one tag at a time. Packet tagging can be done during <i class="arg">nat</i>, <i class="arg">rdr</i>, or <i class="arg">binat</i> rules in addition to filter rules. Tags take the same macros as labels (see above).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">tagged</i> &#60;<i class="arg">string</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Used with filter or translation rules to specify that packets must already be tagged with the given tag in order to match the rule. Inverse tag matching can also be done by specifying the <b class="flag">!</b> operator before the <i class="arg">tagged</i> keyword.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">rtable</i> &#60;<i class="arg">number</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Used to select an alternate routing table for the routing lookup. Only effective before the route lookup happened, i.e. when filtering inbound.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">probability</i> &#60;<i class="arg">number</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
A probability attribute can be attached to a rule, with a value set between 0 and 1, bounds not included. In that case, the rule will be honoured using the given probability value only. For example, the following rule will drop 20% of incoming ICMP packets:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
block in proto icmp probability 20%</pre>
</dd>
</dl>
</div>
<div class="section">
<h1 id="x524f5554494e47">ROUTING</h1> If a packet matches a rule with a route option set, the packet filter will route the packet according to the type of route option. When such a rule creates state, the route option is also applied to all packets matching the same connection.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">fastroute</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The <i class="arg">fastroute</i> option does a normal route lookup to find the next hop for the packet.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">route-to</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The <i class="arg">route-to</i> option routes the packet to the specified interface with an optional address for the next hop. When a <i class="arg">route-to</i> rule creates state, only packets that pass in the same direction as the filter rule specifies will be routed in this way. Packets passing in the opposite direction (replies) are not affected and are routed normally.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">reply-to</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The <i class="arg">reply-to</i> option is similar to <i class="arg">route-to</i>, but routes packets that pass in the opposite direction (replies) to the specified interface. Opposite direction is only defined in the context of a state entry, and <i class="arg">reply-to</i> is useful only in rules that create state. It can be used on systems with multiple external connections to route all outgoing packets of a connection through the interface the incoming connection arrived through (symmetric routing enforcement).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">dup-to</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The <i class="arg">dup-to</i> option creates a duplicate of the packet and routes it like <i class="arg">route-to</i>. The original packet gets routed as it normally would.</dd>
</dl>
</div>
<div class="section">
<h1 id="x504f4f4c204f5054494f4e53">POOL OPTIONS</h1> For <i class="arg">nat</i> and <i class="arg">rdr</i> rules, (as well as for the <i class="arg">route-to</i>, <i class="arg">reply-to</i> and <i class="arg">dup-to</i> rule options) for which there is a single redirection address which has a subnet mask smaller than 32 for IPv4 or 128 for IPv6 (more than one IP address), a variety of different methods for assigning this address can be used:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">bitmask</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The <i class="arg">bitmask</i> option applies the network portion of the redirection address to the address to be modified (source with <i class="arg">nat</i>, destination with <i class="arg">rdr</i>).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">random</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The <i class="arg">random</i> option selects an address at random within the defined block of addresses.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">source-hash</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The <i class="arg">source-hash</i> option uses a hash of the source address to determine the redirection address, ensuring that the redirection address is always the same for a given source. An optional key can be specified after this keyword either in hex or as a string; by default <a class="link-man" href="../html8/pfctl.html">pfctl(8)</a> randomly generates a key for source-hash every time the ruleset is reloaded.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">round-robin</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The <i class="arg">round-robin</i> option loops through the redirection address(es).<p>
When more than one redirection address is specified, <i class="arg">round-robin</i> is the only permitted pool type.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">static-port</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
With <i class="arg">nat</i> rules, the <i class="arg">static-port</i> option prevents <a class="link-man" href="../html4/pf.html">pf(4)</a> from modifying the source port on TCP and UDP packets.</dd>
</dl>
<p>
Additionally, the <i class="arg">sticky-address</i> option can be specified to help ensure that multiple connections from the same source are mapped to the same redirection address. This option can be used with the <i class="arg">random</i> and <i class="arg">round-robin</i> pool options. Note that by default these associations are destroyed as soon as there are no longer states which refer to them; in order to make the mappings last beyond the lifetime of the states, increase the global options with <i class="arg">set timeout src.track</i>. See <i class="link-sec"><a class="link-sec" href="#x535441544546554c20545241434b494e47204f5054494f4e53">STATEFUL TRACKING OPTIONS</a></i> for more ways to control the source tracking.</div>
<div class="section">
<h1 id="x5354415445204d4f44554c4154494f4e">STATE MODULATION</h1> Much of the security derived from TCP is attributable to how well the initial sequence numbers (ISNs) are chosen. Some popular stack implementations choose <span class="emph">very</span> poor ISNs and thus are normally susceptible to ISN prediction exploits. By applying a <i class="arg">modulate state</i> rule to a TCP connection, <a class="link-man" href="../html4/pf.html">pf(4)</a> will create a high quality random sequence number for each connection endpoint.<p>
The <i class="arg">modulate state</i> directive implicitly keeps state on the rule and is only applicable to TCP connections.<p>
For instance:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
block all 
pass out proto tcp from any to any modulate state 
pass in  proto tcp from any to any port 25 flags S/SFRA modulate state</pre>
<p>
Note that modulated connections will not recover when the state table is lost (firewall reboot, flushing the state table, etc...). <a class="link-man" href="../html4/pf.html">pf(4)</a> will not be able to infer a connection again after the state table flushes the connection's modulator. When the state is lost, the connection may be left dangling until the respective endpoints time out the connection. It is possible on a fast local network for the endpoints to start an ACK storm while trying to resynchronize after the loss of the modulator. The default <i class="arg">flags</i> settings (or a more strict equivalent) should be used on <i class="arg">modulate state</i> rules to prevent ACK storms.<p>
Note that alternative methods are available to prevent loss of the state table and allow for firewall failover. See <a class="link-man" href="../html4/carp.html">carp(4)</a> and <a class="link-man" href="../html4/pfsync.html">pfsync(4)</a> for further information.</div>
<div class="section">
<h1 id="x53594e2050524f5859">SYN PROXY</h1> By default, <a class="link-man" href="../html4/pf.html">pf(4)</a> passes packets that are part of a <a class="link-man" href="../html4/tcp.html">tcp(4)</a> handshake between the endpoints. The <i class="arg">synproxy state</i> option can be used to cause <a class="link-man" href="../html4/pf.html">pf(4)</a> itself to complete the handshake with the active endpoint, perform a handshake with the passive endpoint, and then forward packets between the endpoints.<p>
No packets are sent to the passive endpoint before the active endpoint has completed the handshake, hence so-called SYN floods with spoofed source addresses will not reach the passive endpoint, as the sender can't complete the handshake.<p>
The proxy is transparent to both endpoints, they each see a single connection from/to the other endpoint. <a class="link-man" href="../html4/pf.html">pf(4)</a> chooses random initial sequence numbers for both handshakes. Once the handshakes are completed, the sequence number modulators (see previous section) are used to translate further packets of the connection. <i class="arg">synproxy state</i> includes <i class="arg">modulate state</i>.<p>
Rules with <i class="arg">synproxy</i> will not work if <a class="link-man" href="../html4/pf.html">pf(4)</a> operates on a <a class="link-man" href="../html4/bridge.html">bridge(4)</a>.<p>
Example:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
pass in proto tcp from any to any port www synproxy state</pre>
</div>
<div class="section">
<h1 id="x535441544546554c20545241434b494e47204f5054494f4e53">STATEFUL TRACKING OPTIONS</h1> A number of options related to stateful tracking can be applied on a per-rule basis. <i class="arg">keep state</i>, <i class="arg">modulate state</i> and <i class="arg">synproxy state</i> support these options, and <i class="arg">keep state</i> must be specified explicitly to apply options to a rule.<p>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">max</i> &#60;<i class="arg">number</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Limits the number of concurrent states the rule may create. When this limit is reached, further packets matching the rule that would create state are dropped, until existing states time out.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
&#60;<i class="arg">timeout</i>&#62; &#60;<i class="arg">seconds</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Changes the timeout values used for states created by this rule. For a list of all valid timeout names, see <i class="link-sec"><a class="link-sec" href="#x4f5054494f4e53">OPTIONS</a></i> above.</dd>
</dl>
<p>
Multiple options can be specified, separated by commas:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
pass in proto tcp from any to any &#92; 
      port www keep state &#92; 
      (max 100, source-track rule, max-src-nodes 75, &#92; 
      max-src-states 3, tcp.established 60, tcp.closing 5)</pre>
<p>
When the <i class="arg">source-track</i> keyword is specified, the number of states per source IP is tracked.<p>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">source-track rule</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The maximum number of states created by this rule is limited by the rule's <i class="arg">max-src-nodes</i> and <i class="arg">max-src-states</i> options. Only state entries created by this particular rule count toward the rule's limits.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">source-track global</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The number of states created by all rules that use this option is limited. Each rule can specify different <i class="arg">max-src-nodes</i> and <i class="arg">max-src-states</i> options, however state entries created by any participating rule count towards each individual rule's limits.</dd>
</dl>
<p>
The following limits can be set:<p>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">max-src-nodes</i> &#60;<i class="arg">number</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Limits the maximum number of source addresses which can simultaneously have state table entries.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">max-src-states</i> &#60;<i class="arg">number</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Limits the maximum number of simultaneous state entries that a single source address can create with this rule.</dd>
</dl>
<p>
For stateful TCP connections, limits on established connections (connections which have completed the TCP 3-way handshake) can also be enforced per source IP.<p>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">max-src-conn</i> &#60;<i class="arg">number</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Limits the maximum number of simultaneous TCP connections which have completed the 3-way handshake that a single host can make.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">max-src-conn-rate</i> &#60;<i class="arg">number</i>&#62; / &#60;<i class="arg">seconds</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Limit the rate of new connections over a time interval. The connection rate is an approximation calculated as a moving average.</dd>
</dl>
<p>
Because the 3-way handshake ensures that the source address is not being spoofed, more aggressive action can be taken based on these limits. With the <i class="arg">overload</i> &#60;<i class="arg">table</i>&#62; state option, source IP addresses which hit either of the limits on established connections will be added to the named table. This table can be used in the ruleset to block further activity from the offending host, redirect it to a tarpit process, or restrict its bandwidth.<p>
The optional <i class="arg">flush</i> keyword kills all states created by the matching rule which originate from the host which exceeds these limits. The <i class="arg">global</i> modifier to the flush command kills all states originating from the offending host, regardless of which rule created the state.<p>
For example, the following rules will protect the webserver against hosts making more than 100 connections in 10 seconds. Any host which connects faster than this rate will have its address added to the &#60;bad_hosts&#62; table and have all states originating from it flushed. Any new packets arriving from this host will be dropped unconditionally by the block rule.<p>
<pre style="margin-left: 5.00ex;" class="lit display">
block quick from &lt;bad_hosts&gt; 
pass in on $ext_if proto tcp to $webserver port www keep state &#92; 
	(max-src-conn-rate 100/10, overload &lt;bad_hosts&gt; flush global)</pre>
<p>
You can adjust the state policy on individual <i class="arg">nat</i> and <i class="arg">rdr</i> translation rules by adding a keyword <i class="arg">if-bound</i>, <i class="arg">group-bound</i> or <i class="arg">floating</i> at the end of the rule. For example, a rule such as this,<p>
<pre style="margin-left: 5.00ex;" class="lit display">
nat on sip0 from 10/8 to ! 10/8 -&gt; 192.168.1.4/32 if-bound</pre>
<p>
will create states that only match packets on sip0.</div>
<div class="section">
<h1 id="x4f5045524154494e472053595354454d2046494e4745525052494e54494e47">OPERATING SYSTEM FINGERPRINTING</h1> Passive OS Fingerprinting is a mechanism to inspect nuances of a TCP connection's initial SYN packet and guess at the host's operating system. Unfortunately these nuances are easily spoofed by an attacker so the fingerprint is not useful in making security decisions. But the fingerprint is typically accurate enough to make policy decisions upon.<p>
The fingerprints may be specified by operating system class, by version, or by subtype/patchlevel. The class of an operating system is typically the vendor or genre and would be <span class="unix">OpenBSD</span> for the <a class="link-man" href="../html4/pf.html">pf(4)</a> firewall itself. The version of the oldest available <span class="unix">OpenBSD</span> release on the main FTP site would be 2.6 and the fingerprint would be written<p>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">"OpenBSD 2.6"</code></div>
</blockquote>
<p>
The subtype of an operating system is typically used to describe the patchlevel if that patch led to changes in the TCP stack behavior. In the case of <span class="unix">OpenBSD</span>, the only subtype is for a fingerprint that was normalized by the <i class="arg">no-df</i> scrub option and would be specified as<p>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">"OpenBSD 3.3 no-df"</code></div>
</blockquote>
<p>
Fingerprints for most popular operating systems are provided by <a class="link-man" href="../html5/pf.os.html">pf.os(5)</a>. Once <a class="link-man" href="../html4/pf.html">pf(4)</a> is running, a complete list of known operating system fingerprints may be listed by running:<p>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit"># pfctl -so</code></div>
</blockquote>
<p>
Filter rules can enforce policy at any level of operating system specification assuming a fingerprint is present. Policy could limit traffic to approved operating systems or even ban traffic from hosts that aren't at the latest service pack.<p>
The <i class="arg">unknown</i> class can also be used as the fingerprint which will match packets for which no operating system fingerprint is known.<p>
Examples:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
pass  out proto tcp from any os OpenBSD 
block out proto tcp from any os Doors 
block out proto tcp from any os "Doors PT" 
block out proto tcp from any os "Doors PT SP3" 
block out from any os "unknown" 
pass on lo0 proto tcp from any os "OpenBSD 3.3 lo0"</pre>
<p>
Operating system fingerprinting is limited only to the TCP SYN packet. This means that it will not work on other protocols and will not match a currently established connection.<p>
Caveat: operating system fingerprints are occasionally wrong. There are three problems: an attacker can trivially craft his packets to appear as any operating system he chooses; an operating system patch could change the stack behavior and no fingerprints will match it until the database is updated; and multiple operating systems may have the same fingerprint.</div>
<div class="section">
<h1 id="x424c4f434b494e472053504f4f4645442054524146464943">BLOCKING SPOOFED TRAFFIC</h1> "Spoofing" is the faking of IP addresses, typically for malicious purposes. The <i class="arg">antispoof</i> directive expands to a set of filter rules which will block all traffic with a source IP from the network(s) directly connected to the specified interface(s) from entering the system through any other interface.<p>
For example, the line<p>
<pre style="margin-left: 5.00ex;" class="lit display">
antispoof for lo0</pre>
<p>
expands to<p>
<pre style="margin-left: 5.00ex;" class="lit display">
block drop in on ! lo0 inet from 127.0.0.1/8 to any 
block drop in on ! lo0 inet6 from ::1 to any</pre>
<p>
For non-loopback interfaces, there are additional rules to block incoming packets with a source IP address identical to the interface's IP(s). For example, assuming the interface wi0 had an IP address of 10.0.0.1 and a netmask of 255.255.255.0, the line<p>
<pre style="margin-left: 5.00ex;" class="lit display">
antispoof for wi0 inet</pre>
<p>
expands to<p>
<pre style="margin-left: 5.00ex;" class="lit display">
block drop in on ! wi0 inet from 10.0.0.0/24 to any 
block drop in inet from 10.0.0.1 to any</pre>
<p>
Caveat: Rules created by the <i class="arg">antispoof</i> directive interfere with packets sent over loopback interfaces to local addresses. One should pass these explicitly.</div>
<div class="section">
<h1 id="x465241474d454e542048414e444c494e47">FRAGMENT HANDLING</h1> The size of IP datagrams (packets) can be significantly larger than the maximum transmission unit (MTU) of the network. In cases when it is necessary or more efficient to send such large packets, the large packet will be fragmented into many smaller packets that will each fit onto the wire. Unfortunately for a firewalling device, only the first logical fragment will contain the necessary header information for the subprotocol that allows <a class="link-man" href="../html4/pf.html">pf(4)</a> to filter on things such as TCP ports or to perform NAT.<p>
Besides the use of <i class="arg">scrub</i> rules as described in <i class="link-sec"><a class="link-sec" href="#x54524146464943204e4f524d414c495a4154494f4e">TRAFFIC NORMALIZATION</a></i> above, there are three options for handling fragments in the packet filter.<p>
One alternative is to filter individual fragments with filter rules. If no <i class="arg">scrub</i> rule applies to a fragment, it is passed to the filter. Filter rules with matching IP header parameters decide whether the fragment is passed or blocked, in the same way as complete packets are filtered. Without reassembly, fragments can only be filtered based on IP header fields (source/destination address, protocol), since subprotocol header fields are not available (TCP/UDP port numbers, ICMP code/type). The <i class="arg">fragment</i> option can be used to restrict filter rules to apply only to fragments, but not complete packets. Filter rules without the <i class="arg">fragment</i> option still apply to fragments, if they only specify IP header fields. For instance, the rule<p>
<pre style="margin-left: 5.00ex;" class="lit display">
pass in proto tcp from any to any port 80</pre>
<p>
never applies to a fragment, even if the fragment is part of a TCP packet with destination port 80, because without reassembly this information is not available for each fragment. This also means that fragments cannot create new or match existing state table entries, which makes stateful filtering and address translation (NAT, redirection) for fragments impossible.<p>
It's also possible to reassemble only certain fragments by specifying source or destination addresses or protocols as parameters in <i class="arg">scrub</i> rules.<p>
In most cases, the benefits of reassembly outweigh the additional memory cost, and it's recommended to use <i class="arg">scrub</i> rules to reassemble all fragments via the <i class="arg">fragment reassemble</i> modifier.<p>
The memory allocated for fragment caching can be limited using <a class="link-man" href="../html8/pfctl.html">pfctl(8)</a>. Once this limit is reached, fragments that would have to be cached are dropped until other entries time out. The timeout value can also be adjusted.<p>
Currently, only IPv4 fragments are supported and IPv6 fragments are blocked unconditionally.</div>
<div class="section">
<h1 id="x414e43484f5253">ANCHORS</h1> Besides the main ruleset, <a class="link-man" href="../html8/pfctl.html">pfctl(8)</a> can load rulesets into <i class="arg">anchor</i> attachment points. An <i class="arg">anchor</i> is a container that can hold rules, address tables, and other anchors.<p>
An <i class="arg">anchor</i> has a name which specifies the path where <a class="link-man" href="../html8/pfctl.html">pfctl(8)</a> can be used to access the anchor to perform operations on it, such as attaching child anchors to it or loading rules into it. Anchors may be nested, with components separated by &#8216;/&#8217; characters, similar to how file system hierarchies are laid out. The main ruleset is actually the default anchor, so filter and translation rules, for example, may also be contained in any anchor.<p>
An anchor can reference another <i class="arg">anchor</i> attachment point using the following kinds of rules:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">nat-anchor</i> &#60;<i class="arg">name</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Evaluates the <i class="arg">nat</i> rules in the specified <i class="arg">anchor</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">rdr-anchor</i> &#60;<i class="arg">name</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Evaluates the <i class="arg">rdr</i> rules in the specified <i class="arg">anchor</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">binat-anchor</i> &#60;<i class="arg">name</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Evaluates the <i class="arg">binat</i> rules in the specified <i class="arg">anchor</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">anchor</i> &#60;<i class="arg">name</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Evaluates the filter rules in the specified <i class="arg">anchor</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="arg">load anchor</i> &#60;<i class="arg">name</i>&#62; <i class="arg">from</i> &#60;<i class="arg">file</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Loads the rules from the specified file into the anchor <i class="arg">name</i>.</dd>
</dl>
<p>
When evaluation of the main ruleset reaches an <i class="arg">anchor</i> rule, <a class="link-man" href="../html4/pf.html">pf(4)</a> will proceed to evaluate all rules specified in that anchor.<p>
Matching filter and translation rules marked with the <i class="arg">quick</i> option are final and abort the evaluation of the rules in other anchors and the main ruleset. If the <i class="arg">anchor</i> itself is marked with the <i class="arg">quick</i> option, ruleset evaluation will terminate when the anchor is exited if the packet is matched by any rule within the anchor.<p>
<i class="arg">anchor</i> rules are evaluated relative to the anchor in which they are contained. For example, all <i class="arg">anchor</i> rules specified in the main ruleset will reference anchor attachment points underneath the main ruleset, and <i class="arg">anchor</i> rules specified in a file loaded from a <i class="arg">load anchor</i> rule will be attached under that anchor point.<p>
Rules may be contained in <i class="arg">anchor</i> attachment points which do not contain any rules when the main ruleset is loaded, and later such anchors can be manipulated through <a class="link-man" href="../html8/pfctl.html">pfctl(8)</a> without reloading the main ruleset or other anchors. For example,<p>
<pre style="margin-left: 5.00ex;" class="lit display">
ext_if = "kue0" 
block on $ext_if all 
anchor spam 
pass out on $ext_if all 
pass in on $ext_if proto tcp from any &#92; 
      to $ext_if port smtp</pre>
<p>
blocks all packets on the external interface by default, then evaluates all rules in the <i class="arg">anchor</i> named "spam", and finally passes all outgoing connections and incoming connections to port 25.<p>
<pre style="margin-left: 5.00ex;" class="lit display">
# echo "block in quick from 1.2.3.4 to any" | &#92; 
      pfctl -a spam -f -</pre>
<p>
This loads a single rule into the <i class="arg">anchor</i>, which blocks all packets from a specific address.<p>
The anchor can also be populated by adding a <i class="arg">load anchor</i> rule after the <i class="arg">anchor</i> rule:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
anchor spam 
load anchor spam from "/etc/pf-spam.conf"</pre>
<p>
When <a class="link-man" href="../html8/pfctl.html">pfctl(8)</a> loads <b class="name">pf.conf</b>, it will also load all the rules from the file <i class="file">/etc/pf-spam.conf</i> into the anchor.<p>
Optionally, <i class="arg">anchor</i> rules can specify the parameter's direction, interface, address family, protocol and source/destination address/port using the same syntax as filter rules. When parameters are used, the <i class="arg">anchor</i> rule is only evaluated for matching packets. This allows conditional evaluation of anchors, like:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
block on $ext_if all 
anchor spam proto tcp from any to any port smtp 
pass out on $ext_if all 
pass in on $ext_if proto tcp from any to $ext_if port smtp</pre>
<p>
The rules inside <i class="arg">anchor</i> spam are only evaluated for <i class="arg">tcp</i> packets with destination port 25. Hence,<p>
<pre style="margin-left: 5.00ex;" class="lit display">
# echo "block in quick from 1.2.3.4 to any" | &#92; 
      pfctl -a spam -f -</pre>
<p>
will only block connections from 1.2.3.4 to port 25.<p>
Anchors may end with the asterisk (&#8216;*&#8217;) character, which signifies that all anchors attached at that point should be evaluated in the alphabetical ordering of their anchor name. For example,<p>
<pre style="margin-left: 5.00ex;" class="lit display">
anchor "spam/*"</pre>
<p>
will evaluate each rule in each anchor attached to the <code class="lit">spam</code> anchor. Note that it will only evaluate anchors that are directly attached to the <code class="lit">spam</code> anchor, and will not descend to evaluate anchors recursively.<p>
Since anchors are evaluated relative to the anchor in which they are contained, there is a mechanism for accessing the parent and ancestor anchors of a given anchor. Similar to file system path name resolution, if the sequence &#8220;..&#8221; appears as an anchor path component, the parent anchor of the current anchor in the path evaluation at that point will become the new current anchor. As an example, consider the following:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
# echo ' anchor "spam/allowed" ' | pfctl -f - 
# echo -e ' anchor "../banned" &#92;n pass' | &#92; 
      pfctl -a spam/allowed -f -</pre>
<p>
Evaluation of the main ruleset will lead into the <code class="lit">spam/allowed</code> anchor, which will evaluate the rules in the <code class="lit">spam/banned</code> anchor, if any, before finally evaluating the <i class="arg">pass</i> rule.<p>
Filter rule <i class="arg">anchors</i> can also be loaded inline in the ruleset within a brace ('{' '}') delimited block. Brace delimited blocks may contain rules or other brace-delimited blocks. When anchors are loaded this way the anchor name becomes optional.<p>
<pre style="margin-left: 5.00ex;" class="lit display">
anchor "external" on egress { 
	block 
	anchor out { 
		pass proto tcp from any to port { 25, 80, 443 } 
	} 
	pass in proto tcp to any port 22 
}</pre>
<p>
Since the parser specification for anchor names is a string, any reference to an anchor name containing solidus (&#8216;/&#8217;) characters will require double quote (&#8216;"&#8217;) characters around the anchor name.</div>
<div class="section">
<h1 id="x5452414e534c4154494f4e204558414d504c4553">TRANSLATION EXAMPLES</h1> This example maps incoming requests on port 80 to port 8080, on which a daemon is running (because, for example, it is not run as root, and therefore lacks permission to bind to port 80).<p>
<pre style="margin-left: 0.00ex;" class="lit display">
# use a macro for the interface name, so it can be changed easily 
ext_if = "ne3" 
 
# map daemon on 8080 to appear to be on 80 
rdr on $ext_if proto tcp from any to any port 80 -&gt; 127.0.0.1 port 8080</pre>
<p>
If the <i class="arg">pass</i> modifier is given, packets matching the translation rule are passed without inspecting the filter rules:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
rdr pass on $ext_if proto tcp from any to any port 80 -&gt; 127.0.0.1 &#92; 
      port 8080</pre>
<p>
In the example below, vlan12 is configured as 192.168.168.1; the machine translates all packets coming from 192.168.168.0/24 to 204.92.77.111 when they are going out any interface except vlan12. This has the net effect of making traffic from the 192.168.168.0/24 network appear as though it is the Internet routable address 204.92.77.111 to nodes behind any interface on the router except for the nodes on vlan12. (Thus, 192.168.168.1 can talk to the 192.168.168.0/24 nodes.)<p>
<pre style="margin-left: 0.00ex;" class="lit display">
nat on ! vlan12 from 192.168.168.0/24 to any -&gt; 204.92.77.111</pre>
<p>
In the example below, the machine sits between a fake internal 144.19.74.* network, and a routable external IP of 204.92.77.100. The <i class="arg">no nat</i> rule excludes protocol AH from being translated.<p>
<pre style="margin-left: 0.00ex;" class="lit display">
# NO NAT 
no nat on $ext_if proto ah from 144.19.74.0/24 to any 
nat on $ext_if from 144.19.74.0/24 to any -&gt; 204.92.77.100</pre>
<p>
In the example below, packets bound for one specific server, as well as those generated by the sysadmins are not proxied; all other connections are.<p>
<pre style="margin-left: 0.00ex;" class="lit display">
# NO RDR 
no rdr on $int_if proto { tcp, udp } from any to $server port 80 
no rdr on $int_if proto { tcp, udp } from $sysadmins to any port 80 
rdr on $int_if proto { tcp, udp } from any to any port 80 -&gt; 127.0.0.1 &#92; 
      port 80</pre>
<p>
This longer example uses both a NAT and a redirection. The external interface has the address 157.161.48.183. On localhost, we are running <a class="link-man" href="../html8/ftp-proxy.html">ftp-proxy(8)</a>, waiting for FTP sessions to be redirected to it. The three mandatory anchors for <a class="link-man" href="../html8/ftp-proxy.html">ftp-proxy(8)</a> are omitted from this example; see the <a class="link-man" href="../html8/ftp-proxy.html">ftp-proxy(8)</a> manpage.<p>
<pre style="margin-left: 0.00ex;" class="lit display">
# NAT 
# Translate outgoing packets' source addresses (any protocol). 
# In this case, any address but the gateway's external address is mapped. 
nat on $ext_if inet from ! ($ext_if) to any -&gt; ($ext_if) 
 
# NAT PROXYING 
# Map outgoing packets' source port to an assigned proxy port instead of 
# an arbitrary port. 
# In this case, proxy outgoing isakmp with port 500 on the gateway. 
nat on $ext_if inet proto udp from any port = isakmp to any -&gt; ($ext_if) &#92; 
      port 500 
 
# BINAT 
# Translate outgoing packets' source address (any protocol). 
# Translate incoming packets' destination address to an internal machine 
# (bidirectional). 
binat on $ext_if from 10.1.2.150 to any -&gt; $ext_if 
 
# RDR 
# Translate incoming packets' destination addresses. 
# As an example, redirect a TCP and UDP port to an internal machine. 
rdr on $ext_if inet proto tcp from any to ($ext_if) port 8080 &#92; 
      -&gt; 10.1.2.151 port 22 
rdr on $ext_if inet proto udp from any to ($ext_if) port 8080 &#92; 
      -&gt; 10.1.2.151 port 53 
 
# RDR 
# Translate outgoing ftp control connections to send them to localhost 
# for proxying with ftp-proxy(8) running on port 8021. 
rdr on $int_if proto tcp from any to any port 21 -&gt; 127.0.0.1 port 8021</pre>
<p>
In this example, a NAT gateway is set up to translate internal addresses using a pool of public addresses (192.0.2.16/28) and to redirect incoming web server connections to a group of web servers on the internal network.<p>
<pre style="margin-left: 0.00ex;" class="lit display">
# NAT LOAD BALANCE 
# Translate outgoing packets' source addresses using an address pool. 
# A given source address is always translated to the same pool address by 
# using the source-hash keyword. 
nat on $ext_if inet from any to any -&gt; 192.0.2.16/28 source-hash 
 
# RDR ROUND ROBIN 
# Translate incoming web server connections to a group of web servers on 
# the internal network. 
rdr on $ext_if proto tcp from any to any port 80 &#92; 
      -&gt; { 10.1.2.155, 10.1.2.160, 10.1.2.161 } round-robin</pre>
</div>
<div class="section">
<h1 id="x46494c544552204558414d504c4553">FILTER EXAMPLES</h1><pre style="margin-left: 0.00ex;" class="lit display">
# The external interface is kue0 
# (157.161.48.183, the only routable address) 
# and the private network is 10.0.0.0/8, for which we are doing NAT. 
 
# use a macro for the interface name, so it can be changed easily 
ext_if = "kue0" 
 
# normalize all incoming traffic 
scrub in on $ext_if all fragment reassemble 
 
# block and log everything by default 
block return log on $ext_if all 
 
# block anything coming from source we have no back routes for 
block in from no-route to any 
 
# block packets whose ingress interface does not match the one in 
# the route back to their source address 
block in from urpf-failed to any 
 
# block and log outgoing packets that do not have our address as source, 
# they are either spoofed or something is misconfigured (NAT disabled, 
# for instance), we want to be nice and do not send out garbage. 
block out log quick on $ext_if from ! 157.161.48.183 to any 
 
# silently drop broadcasts (cable modem noise) 
block in quick on $ext_if from any to 255.255.255.255 
 
# block and log incoming packets from reserved address space and invalid 
# addresses, they are either spoofed or misconfigured, we cannot reply to 
# them anyway (hence, no return-rst). 
block in log quick on $ext_if from { 10.0.0.0/8, 172.16.0.0/12, &#92; 
      192.168.0.0/16, 255.255.255.255/32 } to any 
 
# ICMP 
 
# pass out/in certain ICMP queries and keep state (ping) 
# state matching is done on host addresses and ICMP id (not type/code), 
# so replies (like 0/0 for 8/0) will match queries 
# ICMP error messages (which always refer to a TCP/UDP packet) are 
# handled by the TCP/UDP states 
pass on $ext_if inet proto icmp all icmp-type 8 code 0 
 
# UDP 
 
# pass out all UDP connections and keep state 
pass out on $ext_if proto udp all 
 
# pass in certain UDP connections and keep state (DNS) 
pass in on $ext_if proto udp from any to any port domain 
 
# TCP 
 
# pass out all TCP connections and modulate state 
pass out on $ext_if proto tcp all modulate state 
 
# pass in certain TCP connections and keep state (SSH, SMTP, DNS, IDENT) 
pass in on $ext_if proto tcp from any to any port { ssh, smtp, domain, &#92; 
      auth } 
 
# Do not allow Windows 9x SMTP connections since they are typically 
# a viral worm. Alternately we could limit these OSes to 1 connection each. 
block in on $ext_if proto tcp from any os {"Windows 95", "Windows 98"} &#92; 
      to any port smtp 
 
# IPv6 
# pass in/out all IPv6 traffic: note that we have to enable this in two 
# different ways, on both our physical interface and our tunnel 
pass quick on gif0 inet6 
pass quick on $ext_if proto ipv6 
 
# Packet Tagging 
 
# three interfaces: $int_if, $ext_if, and $wifi_if (wireless). NAT is 
# being done on $ext_if for all outgoing packets. tag packets in on 
# $int_if and pass those tagged packets out on $ext_if.  all other 
# outgoing packets (i.e., packets from the wireless network) are only 
# permitted to access port 80. 
 
pass in on $int_if from any to any tag INTNET 
pass in on $wifi_if from any to any 
 
block out on $ext_if from any to any 
pass out quick on $ext_if tagged INTNET 
pass out on $ext_if proto tcp from any to any port 80 
 
# tag incoming packets as they are redirected to spamd(8). use the tag 
# to pass those packets through the packet filter. 
 
rdr on $ext_if inet proto tcp from &lt;spammers&gt; to port smtp &#92; 
	tag SPAMD -&gt; 127.0.0.1 port spamd 
 
block in on $ext_if 
pass in on $ext_if inet proto tcp tagged SPAMD</pre>
</div>
<div class="section">
<h1 id="x4752414d4d4152">GRAMMAR</h1> Syntax for <b class="name">pf.conf</b> in BNF:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
line           = ( option | pf-rule | nat-rule | binat-rule | rdr-rule | 
                 antispoof-rule | altq-rule | queue-rule | trans-anchors | 
		 anchor-rule | anchor-close | load-anchor | table-rule | ) 
 
option         = "set" ( [ "timeout" ( timeout | "{" timeout-list "}" ) ] | 
		 [ "ruleset-optimization" [ "none" | "basic" | "profile" ]] | 
                 [ "optimization" [ "default" | "normal" | 
                 "high-latency" | "satellite" | 
                 "aggressive" | "conservative" ] ] 
                 [ "limit" ( limit-item | "{" limit-list "}" ) ] | 
                 [ "loginterface" ( interface-name | "none" ) ] | 
                 [ "block-policy" ( "drop" | "return" ) ] | 
                 [ "state-policy" ( "if-bound" | "floating" ) ] 
                 [ "require-order" ( "yes" | "no" ) ] 
                 [ "fingerprints" filename ] | 
                 [ "skip on" ifspec ] | 
                 [ "debug" ( "none" | "urgent" | "misc" | "loud" ) ] ) 
 
pf-rule        = action [ ( "in" | "out" ) ] 
                 [ "log" [ "(" logopts ")"] ] [ "quick" ] 
                 [ "on" ifspec ] [ "fastroute" | route ] [ af ] [ protospec ] 
                 hosts [ filteropt-list ] 
 
logopts        = logopt [ "," logopts ] 
logopt         = "all" | "user" | "to" interface-name 
 
filteropt-list = filteropt-list filteropt | filteropt 
filteropt      = user | group | flags | icmp-type | icmp6-type | tos | 
                 ( "no" | "keep" | "modulate" | "synproxy" ) "state" 
                 [ "(" state-opts ")" ] | 
                 "fragment" | "no-df" | "min-ttl" number | 
                 "max-mss" number | "random-id" | "reassemble tcp" | 
                 fragmentation | "allow-opts" | 
                 "label" string | "tag" string | [ ! ] "tagged" string | 
                 "queue" ( string | "(" string [ [ "," ] string ] ")" ) | 
                 "rtable" number | "probability" number"%" 
 
nat-rule       = [ "no" ] "nat" [ "pass" [ "log" [ "(" logopts ")" ] ] ] 
                 [ "on" ifspec ] [ af ] 
                 [ protospec ] hosts [ "tag" string ] [ "tagged" string ] 
                 [ "-&gt;" ( redirhost | "{" redirhost-list "}" ) 
                 [ portspec ] [ pooltype ] [ "static-port" ] ] 
                 [ ( "if-bound" | "group-bound" | "floating" ) ] 
 
binat-rule     = [ "no" ] "binat" [ "pass" [ "log" [ "(" logopts ")" ] ] ] 
                 [ "on" interface-name ] [ af ] 
                 [ "proto" ( proto-name | proto-number ) ] 
                 "from" address [ "/" mask-bits ] "to" ipspec 
                 [ "tag" string ] [ "tagged" string ] 
                 [ "-&gt;" address [ "/" mask-bits ] ] 
 
rdr-rule       = [ "no" ] "rdr" [ "pass" [ "log" [ "(" logopts ")" ] ] ] 
                 [ "on" ifspec ] [ af ] 
                 [ protospec ] hosts [ "tag" string ] [ "tagged" string ] 
                 [ "-&gt;" ( redirhost | "{" redirhost-list "}" ) 
                 [ portspec ] [ pooltype ] ] 
                 [ ( "if-bound" | "group-bound" | "floating" ) ] 
 
antispoof-rule = "antispoof" [ "log" ] [ "quick" ] 
                 "for" ifspec [ af ] [ "label" string ] 
 
table-rule     = "table" "&lt;" string "&gt;" [ tableopts-list ] 
tableopts-list = tableopts-list tableopts | tableopts 
tableopts      = "persist" | "const" | "file" string | 
                 "{" [ tableaddr-list ] "}" 
tableaddr-list = tableaddr-list [ "," ] tableaddr-spec | tableaddr-spec 
tableaddr-spec = [ "!" ] tableaddr [ "/" mask-bits ] 
tableaddr      = hostname | ifspec | "self" | 
                 ipv4-dotted-quad | ipv6-coloned-hex 
 
altq-rule      = "altq on" interface-name queueopts-list 
                 "queue" subqueue 
queue-rule     = "queue" string [ "on" interface-name ] queueopts-list 
                 subqueue 
 
anchor-rule    = "anchor" [ string ] [ ( "in" | "out" ) ] [ "on" ifspec ] 
                 [ af ] [ protospec ] [ hosts ] [ "{" ] 
 
anchor-close   = "}" 
 
trans-anchors  = ( "nat-anchor" | "rdr-anchor" | "binat-anchor" ) string 
                 [ "on" ifspec ] [ af ] [ "proto" ] [ protospec ] [ hosts ] 
 
load-anchor    = "load anchor" string "from" filename 
 
queueopts-list = queueopts-list queueopts | queueopts 
queueopts      = [ "bandwidth" bandwidth-spec ] | 
                 [ "qlimit" number ] | [ "tbrsize" number ] | 
                 [ "priority" number ] | [ schedulers ] 
schedulers     = ( cbq-def | priq-def | hfsc-def ) 
bandwidth-spec = "number" ( "b" | "Kb" | "Mb" | "Gb" | "%" ) 
 
action         = "pass" | "block" [ return ] | [ "no" ] "scrub" 
return         = "drop" | "return" | "return-rst" [ "( ttl" number ")" ] | 
                 "return-icmp" [ "(" icmpcode [ [ "," ] icmp6code ] ")" ] | 
                 "return-icmp6" [ "(" icmp6code ")" ] 
icmpcode       = ( icmp-code-name | icmp-code-number ) 
icmp6code      = ( icmp6-code-name | icmp6-code-number ) 
 
ifspec         = ( [ "!" ] ( interface-name | interface-group ) ) | 
                 "{" interface-list "}" 
interface-list = [ "!" ] ( interface-name | interface-group ) 
                 [ [ "," ] interface-list ] 
route          = ( "route-to" | "reply-to" | "dup-to" ) 
                 ( routehost | "{" routehost-list "}" ) 
                 [ pooltype ] 
af             = "inet" | "inet6" 
 
protospec      = "proto" ( proto-name | proto-number | 
                 "{" proto-list "}" ) 
proto-list     = ( proto-name | proto-number ) [ [ "," ] proto-list ] 
 
hosts          = "all" | 
                 "from" ( "any" | "no-route" | "urpf-failed" | "self" | host | 
                 "{" host-list "}" | "route" string ) [ port ] [ os ] 
                 "to"   ( "any" | "no-route" | "self" | host | 
                 "{" host-list "}" | "route" string ) [ port ] 
 
ipspec         = "any" | host | "{" host-list "}" 
host           = [ "!" ] ( address [ "/" mask-bits ] | "&lt;" string "&gt;" ) 
redirhost      = address [ "/" mask-bits ] 
routehost      = "(" interface-name [ address [ "/" mask-bits ] ] ")" 
address        = ( interface-name | interface-group | 
                 "(" ( interface-name | interface-group ) ")" | 
                 hostname | ipv4-dotted-quad | ipv6-coloned-hex ) 
host-list      = host [ [ "," ] host-list ] 
redirhost-list = redirhost [ [ "," ] redirhost-list ] 
routehost-list = routehost [ [ "," ] routehost-list ] 
 
port           = "port" ( unary-op | binary-op | "{" op-list "}" ) 
portspec       = "port" ( number | name ) [ ":" ( "*" | number | name ) ] 
os             = "os"  ( os-name | "{" os-list "}" ) 
user           = "user" ( unary-op | binary-op | "{" op-list "}" ) 
 
unary-op       = [ "=" | "!=" | "&lt;" | "&#8804;" | "&gt;" | "&#8805;" ] 
                 ( name | number ) 
binary-op      = number ( "&lt;&gt;" | "&gt;&lt;" | ":" ) number 
op-list        = ( unary-op | binary-op ) [ [ "," ] op-list ] 
 
os-name        = operating-system-name 
os-list        = os-name [ [ "," ] os-list ] 
 
flags          = "flags" ( [ flag-set ] "/"  flag-set | "any" ) 
flag-set       = [ "F" ] [ "S" ] [ "R" ] [ "P" ] [ "A" ] [ "U" ] [ "E" ] 
                 [ "W" ] 
 
icmp-type      = "icmp-type" ( icmp-type-code | "{" icmp-list "}" ) 
icmp6-type     = "icmp6-type" ( icmp-type-code | "{" icmp-list "}" ) 
icmp-type-code = ( icmp-type-name | icmp-type-number ) 
                 [ "code" ( icmp-code-name | icmp-code-number ) ] 
icmp-list      = icmp-type-code [ [ "," ] icmp-list ] 
 
tos            = "tos" ( "lowdelay" | "throughput" | "reliability" | 
                 [ "0x" ] number ) 
 
state-opts     = state-opt [ [ "," ] state-opts ] 
state-opt      = ( "max" number | timeout | 
                 "source-track" [ ( "rule" | "global" ) ] | 
                 "max-src-nodes" number | "max-src-states" number | 
                 "max-src-conn" number | 
                 "max-src-conn-rate" number "/" number | 
                 "overload" "&lt;" string "&gt;" [ "flush" ] | 
                 "if-bound" | "floating" ) 
 
fragmentation  = [ "fragment reassemble" | "fragment crop" | 
                 "fragment drop-ovl" ] 
 
timeout-list   = timeout [ [ "," ] timeout-list ] 
timeout        = ( "tcp.first" | "tcp.opening" | "tcp.established" | 
                 "tcp.closing" | "tcp.finwait" | "tcp.closed" | 
                 "udp.first" | "udp.single" | "udp.multiple" | 
                 "icmp.first" | "icmp.error" | 
                 "other.first" | "other.single" | "other.multiple" | 
                 "frag" | "interval" | "src.track" | 
                 "adaptive.start" | "adaptive.end" ) number 
 
limit-list     = limit-item [ [ "," ] limit-list ] 
limit-item     = ( "states" | "frags" | "src-nodes" ) number 
 
pooltype       = ( "bitmask" | "random" | 
                 "source-hash" [ ( hex-key | string-key ) ] | 
                 "round-robin" ) [ sticky-address ] 
 
subqueue       = string | "{" queue-list "}" 
queue-list     = string [ [ "," ] string ] 
cbq-def        = "cbq" [ "(" cbq-opt [ [ "," ] cbq-opt ] ")" ] 
priq-def       = "priq" [ "(" priq-opt [ [ "," ] priq-opt ] ")" ] 
hfsc-def       = "hfsc" [ "(" hfsc-opt [ [ "," ] hfsc-opt ] ")" ] 
cbq-opt        = ( "default" | "borrow" | "red" | "ecn" | "rio" ) 
priq-opt       = ( "default" | "red" | "ecn" | "rio" ) 
hfsc-opt       = ( "default" | "red" | "ecn" | "rio" | 
                 linkshare-sc | realtime-sc | upperlimit-sc ) 
linkshare-sc   = "linkshare" sc-spec 
realtime-sc    = "realtime" sc-spec 
upperlimit-sc  = "upperlimit" sc-spec 
sc-spec        = ( bandwidth-spec | 
                 "(" bandwidth-spec number bandwidth-spec ")" )</pre>
</div>
<div class="section">
<h1 id="x46494c4553">FILES</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="file">/etc/hosts</i></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
Host name database.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="file">/etc/pf.conf</i></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
Default location of the ruleset file.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="file">/etc/pf.os</i></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
Default location of OS fingerprints.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="file">/etc/protocols</i></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
Protocol name database.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="file">/etc/services</i></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
Service name database.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="file">/usr/share/examples/pf</i></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
Example rulesets.</dd>
</dl>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html4/carp.html">carp(4)</a>, <a class="link-man" href="../html4/icmp.html">icmp(4)</a>, <a class="link-man" href="../html4/icmp6.html">icmp6(4)</a>, <a class="link-man" href="../html4/ip.html">ip(4)</a>, <a class="link-man" href="../html4/ip6.html">ip6(4)</a>, <a class="link-man" href="../html4/pf.html">pf(4)</a>, <a class="link-man" href="../html4/route.html">route(4)</a>, <a class="link-man" href="../html4/tcp.html">tcp(4)</a>, <a class="link-man" href="../html4/udp.html">udp(4)</a>, <a class="link-man" href="../html5/hosts.html">hosts(5)</a>, <a class="link-man" href="../html5/pf.os.html">pf.os(5)</a>, <a class="link-man" href="../html5/protocols.html">protocols(5)</a>, <a class="link-man" href="../html5/services.html">services(5)</a>, <a class="link-man" href="../html8/ftp-proxy.html">ftp-proxy(8)</a>, <a class="link-man" href="../html8/pfctl.html">pfctl(8)</a>, <a class="link-man" href="../html8/pflogd.html">pflogd(8)</a>, <a class="link-man" href="../html8/route.html">route(8)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The <b class="name">pf.conf</b> file format first appeared in <span class="unix">OpenBSD&#160;3.0</span>.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
June 26, 2007</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

