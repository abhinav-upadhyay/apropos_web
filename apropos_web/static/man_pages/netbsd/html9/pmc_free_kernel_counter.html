<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
PMC(9)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
PMC(9)</td>
<td class="head-vol" align="center">
Kernel Developer's Manual</td>
<td class="head-rtitle" align="right">
PMC(9)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">pmc</b>, <b class="name">pmc_get_num_counters</b>, <b class="name">pmc_get_counter_type</b>, <b class="name">pmc_save_context</b>, <b class="name">pmc_restore_context</b>, <b class="name">pmc_enable_counter</b>, <b class="name">pmc_disable_counter</b>, <b class="name">pmc_counter_isrunning</b>, <b class="name">pmc_counter_isconfigured</b>, <b class="name">pmc_configure_counter</b>, <b class="name">pmc_get_counter_value</b>, <b class="name">pmc_accumulate</b>, <b class="name">pmc_alloc_kernel_counter</b>, <b class="name">pmc_free_kernel_counter</b>, <b class="name">pmc_start_profiling</b>, <b class="name">pmc_stop_profiling</b>, <b class="name">PMC_ENABLED</b> &#8212; <span class="desc">Hardware Performance Monitoring Interface</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/pmc.h</a>&gt;</b><p>
<i class="ftype">int</i><br>
<b class="fname">pmc_get_num_counters</b>(<i class="farg" style="white-space:nowrap;">void</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">pmc_get_counter_type</b>(<i class="farg" style="white-space:nowrap;">int ctr</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">pmc_save_context</b>(<i class="farg" style="white-space:nowrap;">struct lwp *l</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">pmc_restore_context</b>(<i class="farg" style="white-space:nowrap;">struct lwp *l</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">pmc_enable_counter</b>(<i class="farg" style="white-space:nowrap;">struct lwp *l</i>, <i class="farg" style="white-space:nowrap;">int ctr</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">pmc_disable_counter</b>(<i class="farg" style="white-space:nowrap;">struct lwp *l</i>, <i class="farg" style="white-space:nowrap;">int ctr</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">pmc_counter_isrunning</b>(<i class="farg" style="white-space:nowrap;">struct lwp *l</i>, <i class="farg" style="white-space:nowrap;">int ctr</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">pmc_counter_isconfigured</b>(<i class="farg" style="white-space:nowrap;">struct lwp *l</i>, <i class="farg" style="white-space:nowrap;">int ctr</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">pmc_configure_counter</b>(<i class="farg" style="white-space:nowrap;">struct lwp *l</i>, <i class="farg" style="white-space:nowrap;">int ctr</i>, <i class="farg" style="white-space:nowrap;">struct pmc_counter_cfg *cfg</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">pmc_get_counter_value</b>(<i class="farg" style="white-space:nowrap;">struct lwp *l</i>, <i class="farg" style="white-space:nowrap;">int ctr</i>, <i class="farg" style="white-space:nowrap;">int flags</i>, <i class="farg" style="white-space:nowrap;">uint64_t *pval</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">pmc_accumulate</b>(<i class="farg" style="white-space:nowrap;">struct lwp *l_parent</i>, <i class="farg" style="white-space:nowrap;">struct lwp *l_exiting</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">pmc_alloc_kernel_counter</b>(<i class="farg" style="white-space:nowrap;">int ctr</i>, <i class="farg" style="white-space:nowrap;">struct pmc_counter_cfg *cfg</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">pmc_free_kernel_counter</b>(<i class="farg" style="white-space:nowrap;">int ctr</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">pmc_start_profiling</b>(<i class="farg" style="white-space:nowrap;">int ctr</i>, <i class="farg" style="white-space:nowrap;">struct pmc_counter_cfg *cfg</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">pmc_stop_profiling</b>(<i class="farg" style="white-space:nowrap;">int ctr</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">PMC_ENABLED</b>(<i class="farg" style="white-space:nowrap;">struct lwp *l</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> Provides a machine-independent interface to the hardware performance counters which are available on several CPU families. The capabilities of these counters vary from CPU to CPU, but they basically count hardware events such as data cache hits or misses, branches taken, branched mispredicted, and so forth. Some can interrupt the processor when a certain threshold has been reached. Some can count events in user space and kernel space independently.<p>
The <b class="name">pmc</b> interface is intended to allow monitoring from within the kernel as well as monitoring of userland applications. If the hardware can interrupt the CPU in a specific implementation, then it may also be used as a profiling source instead of the clock.</div>
<div class="section">
<h1 id="x494d504c454d454e544154494f4e204e4f544553">IMPLEMENTATION NOTES</h1> All function calls in this interface may be defined as <a class="link-man" href="../1/cpp">cpp(1)</a> macros. If any function is not implemented as a macro, its prototype must be defined by the port-specific header <b class="includes">&lt;<a class="link-includes">machine/pmc.h</a>&gt;</b>.<p>
Counters are numbered from 0 to <span class="define">N&#45;1</span> where <span class="define">N</span> is the number of counters available on the system (see <b class="fname">pmc_get_num_counters</b>() below).<p>
Upon a process fork, implementations must<ul style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-bul">
<li class="list-bul" style="margin-top: 1.00em;">
Zero performance counters for the new process, and</li>
<li class="list-bul" style="margin-top: 1.00em;">
Inherit any enabled performance counters.</li>
</ul>
</div>
<div class="section">
<h1 id="x44415441205459504553">DATA TYPES</h1> Each implementation must specify two new types:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">pmc_evid_t</i></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
An integer type which can contain the event IDs for a given processor.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">pmc_ctr_t</i></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
An integer type defining the value which may be contained in a given counter register.</dd>
</dl>
<p>
Counters are configured with the <i class="farg">struct pmc_counter_cfg</i>. This structure is defined as<p>
<pre style="margin-left: 0.00ex;" class="lit display">
struct pmc_counter_cfg { 
	pmc_evid_t	event_id; 
	pmc_ctr_t	reset_value; 
	uint32_t	flags; 
};</pre>
<p>
<i class="farg">flags</i> are currently unused.</div>
<div class="section">
<h1 id="x46554e4354494f4e53">FUNCTIONS</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pmc_get_num_counters</b>(<i class="farg">void</i>)</dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
Returns the number of counters present on the current system. Valid values for <i class="farg">ctr</i> in the interface entry points below are from zero to one less than the return value from this function.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pmc_get_counter_type</b>(<i class="farg">int ctr</i>)</dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
Returns an implementation-dependent type describing the specified counter. If <i class="farg">ctr</i> is specified as &#45;1, returns a machine-dependent type describing the CPU or counter configuration. For example, on an ia32 architecture, it may distinguish between 586-, 686-, and K7-style counters.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pmc_save_context</b>(<i class="farg">struct lwp *l</i>)</dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
Saves the PMC context for the current process. This is called just before <a class="link-man" href="../9/cpu_switchto">cpu_switchto(9)</a>. If there is kernel PMC state, it must be maintained across this call.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pmc_restore_context</b>(<i class="farg">struct lwp *l</i>)</dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
Restores the PMC context for the current process. This is called just after <a class="link-man" href="../9/cpu_switchto">cpu_switchto(9)</a> returns. If there is kernel PMC state, it must be maintained across this call.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pmc_enable_counter</b>(<i class="farg">struct lwp *l</i>, <i class="farg">int ctr</i>)</dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
Enables counter <i class="farg">ctr</i> for the specified process. The counter should have already been configured with a call to <b class="fname">pmc_configure_counter</b>(). This starts the counter running if it is not already started and enables any interrupts, as appropriate.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pmc_disable_counter</b>(<i class="farg">struct lwp *l</i>, <i class="farg">int ctr</i>)</dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
Disables counter <i class="farg">ctr</i> for the specified process. This stops the counter from running, and disables any interrupts, as appropriate.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pmc_counter_isrunning</b>(<i class="farg">struct lwp *l</i>, <i class="farg">int ctr</i>)</dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
Returns non-zero if the specified counter in the specified process is running or if the counter is running in the kernel.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pmc_counter_isconfigured</b>(<i class="farg">struct lwp *l</i>, <i class="farg">int ctr</i>)</dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
Returns non-zero if the specified counter in the specified process is configured or if the counter is in use by the kernel.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pmc_configure_counter</b>(<i class="farg">struct lwp *l</i>, <i class="farg">int ctr</i>, <i class="farg">struct pmc_counter_cfg *cfg</i>)</dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
Configures counter <i class="farg">ctr</i> according to the configuration information stored in <i class="farg">cfg</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pmc_get_counter_value</b>(<i class="farg">struct lwp *l</i>, <i class="farg">int ctr</i>, <i class="farg">int flags</i>, <i class="farg">uint64_t *pval</i>)</dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
Returns the value of counter <i class="farg">ctr</i> in the space pointed to by <i class="farg">pval</i>. The only recognized flag is <i class="farg">PMC_VALUE_FLAGS_CHILDREN</i> which specifies that the returned counts should be accumulated values for any exited child processes.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pmc_accumulate</b>(<i class="farg">struct lwp *l_parent</i>, <i class="farg">struct lwp *l_exiting</i>)</dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
Accumulates any counter data from the exiting process <i class="farg">p_exiting</i> into the counters for the parent process <i class="farg">p_parent</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pmc_alloc_kernel_counter</b>(<i class="farg">int ctr</i>, <i class="farg">struct pmc_counter_cfg *cfg</i>)</dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
Allocates counter <i class="farg">ctr</i> for use by the kernel and configures it with <i class="farg">cfg</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pmc_free_kernel_counter</b>(<i class="farg">int ctr</i>)</dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
Returns counter <i class="farg">ctr</i> to the available pool of counters that may be used by processes.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pmc_start_profiling</b>(<i class="farg">int ctr</i>, <i class="farg">struct pmc_counter_cfg *cfg</i>)</dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
Allocates counter <i class="farg">ctr</i> for use by the kernel for profiling and configures it with <i class="farg">cfg</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pmc_stop_profiling</b>(<i class="farg">int ctr</i>)</dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
Stops profiling with counter <i class="farg">ctr</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">PMC_ENABLED</b>(<i class="farg">struct lwp *l</i>)</dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
Returns non-zero if the given process or the kernel is using the PMC at all.</dd>
</dl>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../1/pmc">pmc(1)</a>, <a class="link-man" href="../2/pmc_control">pmc_control(2)</a>, <a class="link-man" href="../2/pmc_get_info">pmc_get_info(2)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The <b class="name">pmc</b> interface appeared in <span class="unix">NetBSD&#160;2.0</span>.</div>
<div class="section">
<h1 id="x415554484f5253">AUTHORS</h1> The <b class="name">pmc</b> interface was designed and implemented by Allen Briggs for Wasabi Systems, Inc. Additional input on the <b class="name">pmc</b> design was provided by Jason R. Thorpe.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
May 14, 2010</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

