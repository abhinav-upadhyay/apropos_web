<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
CALLOUT(9)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
CALLOUT(9)</td>
<td class="head-vol" align="center">
Kernel Developer's Manual</td>
<td class="head-rtitle" align="right">
CALLOUT(9)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">callout_init</b>, <b class="name">callout_destroy</b>, <b class="name">callout_halt</b>, <b class="name">callout_reset</b>, <b class="name">callout_schedule</b>, <b class="name">callout_setfunc</b>, <b class="name">callout_stop</b>, <b class="name">callout_pending</b>, <b class="name">callout_expired</b>, <b class="name">callout_invoking</b>, <b class="name">callout_ack</b> &#8212; <span class="desc">execute a function after a specified length of time</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/callout.h</a>&gt;</b><p>
<i class="ftype">void</i><br>
<b class="fname">callout_init</b>(<i class="farg" style="white-space:nowrap;">callout_t *c</i>, <i class="farg" style="white-space:nowrap;">u_int flags</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">callout_destroy</b>(<i class="farg" style="white-space:nowrap;">callout_t *c</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">callout_reset</b>(<i class="farg" style="white-space:nowrap;">callout_t *c</i>, <i class="farg" style="white-space:nowrap;">int ticks</i>, <i class="farg" style="white-space:nowrap;">void (*func)(void *)</i>, <i class="farg" style="white-space:nowrap;">void *arg</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">callout_schedule</b>(<i class="farg" style="white-space:nowrap;">callout_t *c</i>, <i class="farg" style="white-space:nowrap;">int ticks</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">callout_setfunc</b>(<i class="farg" style="white-space:nowrap;">callout_t *c</i>, <i class="farg" style="white-space:nowrap;">void (*func)(void *)</i>, <i class="farg" style="white-space:nowrap;">void *arg</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">callout_stop</b>(<i class="farg" style="white-space:nowrap;">callout_t *c</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">callout_halt</b>(<i class="farg" style="white-space:nowrap;">callout_t *c</i>, <i class="farg" style="white-space:nowrap;">kmutex_t *interlock</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">callout_pending</b>(<i class="farg" style="white-space:nowrap;">callout_t *c</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">callout_expired</b>(<i class="farg" style="white-space:nowrap;">callout_t *c</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">callout_active</b>(<i class="farg" style="white-space:nowrap;">callout_t *c</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">callout_invoking</b>(<i class="farg" style="white-space:nowrap;">callout_t *c</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">callout_ack</b>(<i class="farg" style="white-space:nowrap;">callout_t *c</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <b class="name">callout</b> facility provides a mechanism to execute a function at a given time. The timer is based on the hardclock timer which ticks <span class="define">hz</span> times per second. The function is called at softclock interrupt level.<p>
Clients of the <b class="name">callout</b> facility are responsible for providing pre-allocated callout structures, or &#8220;handles&#8221;. The <b class="name">callout</b> facility replaces the historic <span class="unix">UNIX</span> functions <b class="fname">timeout</b>() and <b class="fname">untimeout</b>().</div>
<div class="section">
<h1 id="x46554e4354494f4e53">FUNCTIONS</h1> The <b class="fname">callout_init</b>() function initializes the callout handle <i class="farg">c</i> for use. No operations can be performed on the callout before it is initialized. If the <i class="farg">flags</i> argument is <span class="define">CALLOUT_MPSAFE</span>, the handler will be called without getting the global kernel lock. In this case it should only use functions that are multiprocessor safe.<p>
<b class="fname">callout_destroy</b>() destroys the callout, preventing further use. It is provided as a diagnostic facility intended to catch bugs. To ensure future compatibility, <b class="fname">callout_destroy</b>() should always be called when the callout is no longer required (for instance, when a device is being detached). The callout should be stopped before <b class="fname">callout_destroy</b>() is called by calling <b class="fname">callout_halt</b>(). Note that <b class="fname">callout_stop</b>() shouldn't be used for this purpose.<p>
The <b class="fname">callout_reset</b>() function resets and starts the timer associated with the callout handle <i class="farg">c</i>. When the timer expires after <i class="farg">ticks</i>/hz seconds, the function specified by <i class="farg">func</i> will be called with the argument <i class="farg">arg</i>. If the timer associated with the callout handle is already running, the callout will simply be rescheduled to execute at the newly specified time. Once the timer is started, the callout handle is marked as <span class="emph">PENDING</span>. Once the timer expires, the handle is marked as <span class="emph">EXPIRED</span> and <span class="emph">INVOKING</span>, and the <span class="emph">PENDING</span> status is cleared.<p>
The <b class="fname">callout_setfunc</b>() function sets the function and argument of the callout handle <i class="farg">c</i> to <i class="farg">func</i> and <i class="farg">arg</i> respectively. The callout handle must already be initialized. If a callout will always be used with the same function and argument, then <b class="fname">callout_setfunc</b>() used in conjunction with <b class="fname">callout_schedule</b>() is slightly more efficient than using <b class="fname">callout_reset</b>().<p>
The <b class="fname">callout_stop</b>() function requests that the timer associated with the callout handle <i class="farg">c</i> be stopped. The <span class="emph">PENDING</span> and <span class="emph">EXPIRED</span> status for the callout handle is cleared. It is safe to call <b class="fname">callout_stop</b>() on a callout handle that is not pending, so long as it is initialized. <b class="fname">callout_stop</b>() will return a non-zero value if the callout was <span class="emph">EXPIRED</span>. Note that <b class="fname">callout_stop</b>() can return while the callout is running on a different CPU or at a different interrupt priority level on the current CPU. It can only be said to prevent the callout from firing in the future, unless explicitly re-scheduled. To stop a callout and wait for completion, use <b class="fname">callout_halt</b>().<p>
<b class="fname">callout_halt</b>() acts much like <b class="fname">callout_stop</b>(), but waits for the callout to complete if it is currently in-flight. <b class="fname">callout_halt</b>() may not be called from a hard interrupt handler as it will sleep if the callout is currently executing. If the callout can take locks (such as mutexes or RW locks), the caller of <b class="fname">callout_halt</b>() must not hold any of those locks, otherwise the two could deadlock. To facilitate this, <b class="fname">callout_halt</b>() can optionally release a single mutex specified by the <i class="farg">interlock</i> parameter. If <i class="farg">interlock</i> is not <span class="define">NULL</span> and the calling thread must wait for the callout to complete, <i class="farg">interlock</i> will be released before waiting and re-acquired before returning. If no wait is required, <i class="farg">interlock</i> will not be released. However, to avoid race conditions the caller should always assume that <i class="farg">interlock</i> has been released and reacquired, and act accordingly.<p>
The <b class="fname">callout_pending</b>() function tests the <span class="emph">PENDING</span> status of the callout handle <i class="farg">c</i>. A <span class="emph">PENDING</span> callout is one that has been started and whose function has not yet been called. Note that it is possible for a callout's timer to have expired without its function being called if interrupt level has not dropped low enough to let softclock interrupts through. Note that it is only safe to test <span class="emph">PENDING</span> status when at softclock interrupt level or higher.<p>
The <b class="fname">callout_expired</b>() function tests to see if the callout's timer has expired and its function called.<p>
The <b class="fname">callout_active</b>() function returns true if a timer has been started but not explicitly stopped, even if it has already fired. <b class="fname">callout_active</b>(<i class="farg">foo</i>) is logically the same as <b class="fname">callout_pending</b>(<i class="farg">foo</i>) || <b class="fname">callout_expired</b>(<i class="farg">foo</i>); it is implemented as a separate function for compatibility with <span class="unix">FreeBSD</span> and for the special case of <b class="fname">TCP_TIMER_ISARMED</b>(). Its use is not recommended.<p>
The <b class="fname">callout_invoking</b>() function tests the <span class="emph">INVOKING</span> status of the callout handle <i class="farg">c</i>. This flag is set just before a callout's function is being called. Since the priority level is lowered prior to invocation of the callout function, other pending higher-priority code may run before the callout function is allowed to run. This may create a race condition if this higher-priority code deallocates storage containing one or more callout structures whose callout functions are about to be run. In such cases, one technique to prevent references to deallocated storage would be to test whether any callout functions are in the <span class="emph">INVOKING</span> state using <b class="fname">callout_invoking</b>(), and if so, to mark the data structure and defer storage deallocation until the callout function is allowed to run. For this handshake protocol to work, the callout function will have to use the <b class="fname">callout_ack</b>() function to clear this flag.<p>
The <b class="fname">callout_ack</b>() function clears the <span class="emph">INVOKING</span> state in the callout handle <i class="farg">c</i>. This is used in situations where it is necessary to protect against the race condition described under <b class="fname">callout_invoking</b>().</div>
<div class="section">
<h1 id="x434f4e43555252454e4359">CONCURRENCY</h1> The callout facility performs locking internally in order to guarantee the atomicity of individual operations performed on callouts. It does not provide life cycle management of user-provided callout data structures, nor does it ensure that groups of operations (multiple function calls) are performed atomically. These aspects of callout management are the responsibility of the user of the callout facility.<p>
Scheduled callouts may be active concurrently in a context different to the user of the callout facility: on another CPU, or at a different interrupt priority level or thread on the current CPU. The callout facility provides only one guarantee in this regard: any given callout will never have multiple concurrent invocations.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html9/condvar.html">condvar(9)</a>, <a class="link-man" href="../html9/hz.html">hz(9)</a>, <a class="link-man" href="../html9/softint.html">softint(9)</a>, <a class="link-man" href="../html9/workqueue.html">workqueue(9)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The <b class="name">callout</b> facility was implemented by Artur Grabowski and Thomas Nordin, based on the work of G. Varghese and A. Lauck, described in the paper Hashed and Hierarchical Timing Wheels: Data Structures for the Efficient Implementation of a Timer Facility in the Proceedings of the 11th ACM Annual Symposium on Operating System Principles, Austin, Texas, November 1987. It was adapted to the <span class="unix">NetBSD</span> kernel by Jason R. Thorpe.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
November 21, 2014</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

