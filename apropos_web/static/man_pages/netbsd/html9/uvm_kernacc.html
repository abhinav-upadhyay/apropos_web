<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="/static/man_pages/netbsd/style.css" type="text/css" media="all">
<title>
UVM(9)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
UVM(9)</td>
<td class="head-vol" align="center">
Kernel Developer's Manual</td>
<td class="head-rtitle" align="right">
UVM(9)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">uvm</b> &#8212; <span class="desc">virtual memory system external interface</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/param.h</a>&gt;</b><br>
<b class="includes">#include &lt;<a class="link-includes">uvm/uvm.h</a>&gt;</b></div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The UVM virtual memory system manages access to the computer's memory resources. User processes and the kernel access these resources through UVM's external interface. UVM's external interface includes functions that:<p>
<ul style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-hyph">
<li class="list-hyph" style="margin-top: 0.00em;">
initialize UVM sub-systems</li>
<li class="list-hyph" style="margin-top: 0.00em;">
manage virtual address spaces</li>
<li class="list-hyph" style="margin-top: 0.00em;">
resolve page faults</li>
<li class="list-hyph" style="margin-top: 0.00em;">
memory map files and devices</li>
<li class="list-hyph" style="margin-top: 0.00em;">
perform uio-based I/O to virtual memory</li>
<li class="list-hyph" style="margin-top: 0.00em;">
allocate and free kernel virtual memory</li>
<li class="list-hyph" style="margin-top: 0.00em;">
allocate and free physical memory</li>
</ul>
<p>
In addition to exporting these services, UVM has two kernel-level processes: pagedaemon and swapper. The pagedaemon process sleeps until physical memory becomes scarce. When that happens, pagedaemon is awoken. It scans physical memory, paging out and freeing memory that has not been recently used. The swapper process swaps in runnable processes that are currently swapped out, if there is room.<p>
There are also several miscellaneous functions.</div>
<div class="section">
<h1 id="x494e495449414c495a4154494f4e">INITIALIZATION</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-ohang">
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">void</i></dt>
<dd class="list-ohang">
<b class="fname">uvm_init</b>(<i class="farg">void</i>);</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">void</i></dt>
<dd class="list-ohang">
<b class="fname">uvm_init_limits</b>(<i class="farg">struct lwp *l</i>);</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">void</i></dt>
<dd class="list-ohang">
<b class="fname">uvm_setpagesize</b>(<i class="farg">void</i>);</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">void</i></dt>
<dd class="list-ohang">
<b class="fname">uvm_swap_init</b>(<i class="farg">void</i>);</dd>
</dl>
<p>
<b class="fname">uvm_init</b>() sets up the UVM system at system boot time, after the console has been setup. It initializes global state, the page, map, kernel virtual memory state, machine-dependent physical map, kernel memory allocator, pager and anonymous memory sub-systems, and then enables paging of kernel objects.<p>
<b class="fname">uvm_init_limits</b>() initializes process limits for the named process. This is for use by the system startup for process zero, before any other processes are created.<p>
<b class="fname">uvm_setpagesize</b>() initializes the uvmexp members pagesize (if not already done by machine-dependent code), pageshift and pagemask. It should be called by machine-dependent code early in the <b class="fname">pmap_init</b>() call (see <a class="link-man" href="../9/pmap">pmap(9)</a>).<p>
<b class="fname">uvm_swap_init</b>() initializes the swap sub-system.</div>
<div class="section">
<h1 id="x5649525455414c2041444452455353205350414345204d414e4147454d454e54">VIRTUAL ADDRESS SPACE MANAGEMENT</h1> See <a class="link-man" href="../9/uvm_map">uvm_map(9)</a>.</div>
<div class="section">
<h1 id="x50414745204641554c542048414e444c494e47">PAGE FAULT HANDLING</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-ohang">
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">int</i></dt>
<dd class="list-ohang">
<b class="fname">uvm_fault</b>(<i class="farg">struct vm_map *orig_map</i>, <i class="farg">vaddr_t vaddr</i>, <i class="farg">vm_prot_t access_type</i>);</dd>
</dl>
<p>
<b class="fname">uvm_fault</b>() is the main entry point for faults. It takes <i class="farg">orig_map</i> as the map the fault originated in, a <i class="farg">vaddr</i> offset into the map the fault occurred, and <i class="farg">access_type</i> describing the type of access requested. <b class="fname">uvm_fault</b>() returns a standard UVM return value.</div>
<div class="section">
<h1 id="x4d454d4f5259204d415050494e472046494c455320414e442044455649434553">MEMORY MAPPING FILES AND DEVICES</h1> See <a class="link-man" href="../9/ubc">ubc(9)</a>.</div>
<div class="section">
<h1 id="x5649525455414c204d454d4f525920492f4f">VIRTUAL MEMORY I/O</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-ohang">
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">int</i></dt>
<dd class="list-ohang">
<b class="fname">uvm_io</b>(<i class="farg">struct vm_map *map</i>, <i class="farg">struct uio *uio</i>);</dd>
</dl>
<p>
<b class="fname">uvm_io</b>() performs the I/O described in <i class="farg">uio</i> on the memory described in <i class="farg">map</i>.</div>
<div class="section">
<h1 id="x414c4c4f434154494f4e204f46204b45524e454c204d454d4f5259">ALLOCATION OF KERNEL MEMORY</h1> See <a class="link-man" href="../9/uvm_km">uvm_km(9)</a>.</div>
<div class="section">
<h1 id="x414c4c4f434154494f4e204f4620504859534943414c204d454d4f5259">ALLOCATION OF PHYSICAL MEMORY</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-ohang">
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">struct vm_page *</i></dt>
<dd class="list-ohang">
<b class="fname">uvm_pagealloc</b>(<i class="farg">struct uvm_object *uobj</i>, <i class="farg">voff_t off</i>, <i class="farg">struct vm_anon *anon</i>, <i class="farg">int flags</i>);</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">void</i></dt>
<dd class="list-ohang">
<b class="fname">uvm_pagerealloc</b>(<i class="farg">struct vm_page *pg</i>, <i class="farg">struct uvm_object *newobj</i>, <i class="farg">voff_t newoff</i>);</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">void</i></dt>
<dd class="list-ohang">
<b class="fname">uvm_pagefree</b>(<i class="farg">struct vm_page *pg</i>);</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">int</i></dt>
<dd class="list-ohang">
<b class="fname">uvm_pglistalloc</b>(<i class="farg">psize_t size</i>, <i class="farg">paddr_t low</i>, <i class="farg">paddr_t high</i>, <i class="farg">paddr_t alignment</i>, <i class="farg">paddr_t boundary</i>, <i class="farg">struct pglist *rlist</i>, <i class="farg">int nsegs</i>, <i class="farg">int waitok</i>);</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">void</i></dt>
<dd class="list-ohang">
<b class="fname">uvm_pglistfree</b>(<i class="farg">struct pglist *list</i>);</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">void</i></dt>
<dd class="list-ohang">
<b class="fname">uvm_page_physload</b>(<i class="farg">paddr_t start</i>, <i class="farg">paddr_t end</i>, <i class="farg">paddr_t avail_start</i>, <i class="farg">paddr_t avail_end</i>, <i class="farg">int free_list</i>);</dd>
</dl>
<p>
<b class="fname">uvm_pagealloc</b>() allocates a page of memory at virtual address <i class="farg">off</i> in either the object <i class="farg">uobj</i> or the anonymous memory <i class="farg">anon</i>, which must be locked by the caller. Only one of <i class="farg">uobj</i> and <i class="farg">anon</i> can be non <span class="define">NULL</span>. Returns <span class="define">NULL</span> when no page can be found. The flags can be any of<p>
<pre style="margin-left: 0.00ex;" class="lit display">
#define UVM_PGA_USERESERVE      0x0001  /* ok to use reserve pages */ 
#define UVM_PGA_ZERO            0x0002  /* returned page must be zero'd */</pre>
<p>
<span class="define">UVM_PGA_USERESERVE</span> means to allocate a page even if that will result in the number of free pages being lower than <span class="define">uvmexp.reserve_pagedaemon</span> (if the current thread is the pagedaemon) or <span class="define">uvmexp.reserve_kernel</span> (if the current thread is not the pagedaemon). <span class="define">UVM_PGA_ZERO</span> causes the returned page to be filled with zeroes, either by allocating it from a pool of pre-zeroed pages or by zeroing it in-line as necessary.<p>
<b class="fname">uvm_pagerealloc</b>() reallocates page <i class="farg">pg</i> to a new object <i class="farg">newobj</i>, at a new offset <i class="farg">newoff</i>.<p>
<b class="fname">uvm_pagefree</b>() frees the physical page <i class="farg">pg</i>. If the content of the page is known to be zero-filled, caller should set <span class="define">PG_ZERO</span> in pg-&gt;flags so that the page allocator will use the page to serve future <span class="define">UVM_PGA_ZERO</span> requests efficiently.<p>
<b class="fname">uvm_pglistalloc</b>() allocates a list of pages for size <i class="farg">size</i> byte under various constraints. <i class="farg">low</i> and <i class="farg">high</i> describe the lowest and highest addresses acceptable for the list. If <i class="farg">alignment</i> is non-zero, it describes the required alignment of the list, in power-of-two notation. If <i class="farg">boundary</i> is non-zero, no segment of the list may cross this power-of-two boundary, relative to zero. <i class="farg">nsegs</i> is the maximum number of physically contiguous segments. If <i class="farg">waitok</i> is non-zero, the function may sleep until enough memory is available. (It also may give up in some situations, so a non-zero <i class="farg">waitok</i> does not imply that <b class="fname">uvm_pglistalloc</b>() cannot return an error.) The allocated memory is returned in the <i class="farg">rlist</i> list; the caller has to provide storage only, the list is initialized by <b class="fname">uvm_pglistalloc</b>().<p>
<b class="fname">uvm_pglistfree</b>() frees the list of pages pointed to by <i class="farg">list</i>. If the content of the page is known to be zero-filled, caller should set <span class="define">PG_ZERO</span> in pg-&gt;flags so that the page allocator will use the page to serve future <span class="define">UVM_PGA_ZERO</span> requests efficiently.<p>
<b class="fname">uvm_page_physload</b>() loads physical memory segments into VM space on the specified <i class="farg">free_list</i>. It must be called at system boot time to set up physical memory management pages. The arguments describe the <i class="farg">start</i> and <i class="farg">end</i> of the physical addresses of the segment, and the available start and end addresses of pages not already in use. If a system has memory banks of different speeds the slower memory should be given a higher <i class="farg">free_list</i> value.</div>
<div class="section">
<h1 id="x50524f434553534553">PROCESSES</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-ohang">
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">void</i></dt>
<dd class="list-ohang">
<b class="fname">uvm_pageout</b>(<i class="farg">void</i>);</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">void</i></dt>
<dd class="list-ohang">
<b class="fname">uvm_scheduler</b>(<i class="farg">void</i>);</dd>
</dl>
<p>
<b class="fname">uvm_pageout</b>() is the main loop for the page daemon.<p>
<b class="fname">uvm_scheduler</b>() is the process zero main loop, which is to be called after the system has finished starting other processes. It handles the swapping in of runnable, swapped out processes in priority order.</div>
<div class="section">
<h1 id="x50414745204c4f414e">PAGE LOAN</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-ohang">
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">int</i></dt>
<dd class="list-ohang">
<b class="fname">uvm_loan</b>(<i class="farg">struct vm_map *map</i>, <i class="farg">vaddr_t start</i>, <i class="farg">vsize_t len</i>, <i class="farg">void *v</i>, <i class="farg">int flags</i>);</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">void</i></dt>
<dd class="list-ohang">
<b class="fname">uvm_unloan</b>(<i class="farg">void *v</i>, <i class="farg">int npages</i>, <i class="farg">int flags</i>);</dd>
</dl>
<p>
<b class="fname">uvm_loan</b>() loans pages in a map out to anons or to the kernel. <i class="farg">map</i> should be unlocked, <i class="farg">start</i> and <i class="farg">len</i> should be multiples of <span class="define">PAGE_SIZE</span>. Argument <i class="farg">flags</i> should be one of<p>
<pre style="margin-left: 0.00ex;" class="lit display">
#define UVM_LOAN_TOANON       0x01    /* loan to anons */ 
#define UVM_LOAN_TOPAGE       0x02    /* loan to kernel */</pre>
<p>
<i class="farg">v</i> should be pointer to array of pointers to <code class="lit">struct anon</code> or <code class="lit">struct vm_page</code>, as appropriate. The caller has to allocate memory for the array and ensure it's big enough to hold <i class="farg">len / PAGE_SIZE</i> pointers. Returns 0 for success, or appropriate error number otherwise. Note that wired pages can't be loaned out and <b class="fname">uvm_loan</b>() will fail in that case.<p>
<b class="fname">uvm_unloan</b>() kills loans on pages or anons. The <i class="farg">v</i> must point to the array of pointers initialized by previous call to <b class="fname">uvm_loan</b>(). <i class="farg">npages</i> should match number of pages allocated for loan, this also matches number of items in the array. Argument <i class="farg">flags</i> should be one of<p>
<pre style="margin-left: 0.00ex;" class="lit display">
#define UVM_LOAN_TOANON       0x01    /* loan to anons */ 
#define UVM_LOAN_TOPAGE       0x02    /* loan to kernel */</pre>
<p>
and should match what was used for previous call to <b class="fname">uvm_loan</b>().</div>
<div class="section">
<h1 id="x4d495343454c4c414e454f55532046554e4354494f4e53">MISCELLANEOUS FUNCTIONS</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-ohang">
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">struct uvm_object *</i></dt>
<dd class="list-ohang">
<b class="fname">uao_create</b>(<i class="farg">vsize_t size</i>, <i class="farg">int flags</i>);</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">void</i></dt>
<dd class="list-ohang">
<b class="fname">uao_detach</b>(<i class="farg">struct uvm_object *uobj</i>);</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">void</i></dt>
<dd class="list-ohang">
<b class="fname">uao_reference</b>(<i class="farg">struct uvm_object *uobj</i>);</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">bool</i></dt>
<dd class="list-ohang">
<b class="fname">uvm_chgkprot</b>(<i class="farg">void *addr</i>, <i class="farg">size_t len</i>, <i class="farg">int rw</i>);</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">void</i></dt>
<dd class="list-ohang">
<b class="fname">uvm_kernacc</b>(<i class="farg">void *addr</i>, <i class="farg">size_t len</i>, <i class="farg">int rw</i>);</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">int</i></dt>
<dd class="list-ohang">
<b class="fname">uvm_vslock</b>(<i class="farg">struct vmspace *vs</i>, <i class="farg">void *addr</i>, <i class="farg">size_t len</i>, <i class="farg">vm_prot_t prot</i>);</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">void</i></dt>
<dd class="list-ohang">
<b class="fname">uvm_vsunlock</b>(<i class="farg">struct vmspace *vs</i>, <i class="farg">void *addr</i>, <i class="farg">size_t len</i>);</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">void</i></dt>
<dd class="list-ohang">
<b class="fname">uvm_meter</b>(<i class="farg">void</i>);</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">void</i></dt>
<dd class="list-ohang">
<b class="fname">uvm_proc_fork</b>(<i class="farg">struct proc *p1</i>, <i class="farg">struct proc *p2</i>, <i class="farg">bool shared</i>);</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">int</i></dt>
<dd class="list-ohang">
<b class="fname">uvm_grow</b>(<i class="farg">struct proc *p</i>, <i class="farg">vaddr_t sp</i>);</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">void</i></dt>
<dd class="list-ohang">
<b class="fname">uvn_findpages</b>(<i class="farg">struct uvm_object *uobj</i>, <i class="farg">voff_t offset</i>, <i class="farg">int *npagesp</i>, <i class="farg">struct vm_page **pps</i>, <i class="farg">int flags</i>);</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">void</i></dt>
<dd class="list-ohang">
<b class="fname">uvm_vnp_setsize</b>(<i class="farg">struct vnode *vp</i>, <i class="farg">voff_t newsize</i>);</dd>
</dl>
<p>
The <b class="fname">uao_create</b>(), <b class="fname">uao_detach</b>(), and <b class="fname">uao_reference</b>() functions operate on anonymous memory objects, such as those used to support System V shared memory. <b class="fname">uao_create</b>() returns an object of size <i class="farg">size</i> with flags:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
#define UAO_FLAG_KERNOBJ        0x1     /* create kernel object */ 
#define UAO_FLAG_KERNSWAP       0x2     /* enable kernel swap */</pre>
<p>
which can only be used once each at system boot time. <b class="fname">uao_reference</b>() creates an additional reference to the named anonymous memory object. <b class="fname">uao_detach</b>() removes a reference from the named anonymous memory object, destroying it if removing the last reference.<p>
<b class="fname">uvm_chgkprot</b>() changes the protection of kernel memory from <i class="farg">addr</i> to <i class="farg">addr + len</i> to the value of <i class="farg">rw</i>. This is primarily useful for debuggers, for setting breakpoints. This function is only available with options <span class="define">KGDB</span>.<p>
<b class="fname">uvm_kernacc</b>() checks the access at address <i class="farg">addr</i> to <i class="farg">addr + len</i> for <i class="farg">rw</i> access in the kernel address space.<p>
<b class="fname">uvm_vslock</b>() and <b class="fname">uvm_vsunlock</b>() control the wiring and unwiring of pages for process <i class="farg">p</i> from <i class="farg">addr</i> to <i class="farg">addr + len</i>. These functions are normally used to wire memory for I/O.<p>
<b class="fname">uvm_meter</b>() calculates the load average.<p>
<b class="fname">uvm_proc_fork</b>() forks a virtual address space for process' (old) <i class="farg">p1</i> and (new) <i class="farg">p2</i>. If the <i class="farg">shared</i> argument is non zero, p1 shares its address space with p2, otherwise a new address space is created. This function currently has no return value, and thus cannot fail. In the future, this function will be changed to allow it to fail in low memory conditions.<p>
<b class="fname">uvm_grow</b>() increases the stack segment of process <i class="farg">p</i> to include <i class="farg">sp</i>.<p>
<b class="fname">uvn_findpages</b>() looks up or creates pages in <i class="farg">uobj</i> at offset <i class="farg">offset</i>, marks them busy and returns them in the <i class="farg">pps</i> array. Currently <i class="farg">uobj</i> must be a vnode object. The number of pages requested is pointed to by <i class="farg">npagesp</i>, and this value is updated with the actual number of pages returned. The flags can be any bitwise inclusive-or of:<p>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 4.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UFP_ALL</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Zero pseudo-flag meaning return all pages.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UFP_NOWAIT</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Don't sleep -- yield <span class="define">NULL</span> for busy pages or for uncached pages for which allocation would sleep.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UFP_NOALLOC</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Don't allocate -- yield <span class="define">NULL</span> for uncached pages.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UFP_NOCACHE</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Don't use cached pages -- yield <span class="define">NULL</span> instead.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UFP_NORDONLY</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Don't yield read-only pages -- yield <span class="define">NULL</span> for pages marked <span class="define">PG_READONLY</span>.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UFP_DIRTYONLY</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Don't yield clean pages -- stop early at the first clean one. As a side effect, mark yielded dirty pages clean. Caller must write them to permanent storage before unbusying.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UFP_BACKWARD</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Traverse pages in reverse order. If <b class="fname">uvn_findpages</b>() returns early, it will have filled <code class="lit">*</code><i class="farg">npagesp</i> entries at the end of <i class="farg">pps</i> rather than the beginning.</dd>
</dl>
<p>
<b class="fname">uvm_vnp_setsize</b>() sets the size of vnode <i class="farg">vp</i> to <i class="farg">newsize</i>. Caller must hold a reference to the vnode. If the vnode shrinks, pages no longer used are discarded.</div>
<div class="section">
<h1 id="x4d495343454c4c414e454f5553204d4143524f53">MISCELLANEOUS MACROS</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-ohang">
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">paddr_t</i></dt>
<dd class="list-ohang">
<b class="fname">atop</b>(<i class="farg">paddr_t pa</i>);</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">paddr_t</i></dt>
<dd class="list-ohang">
<b class="fname">ptoa</b>(<i class="farg">paddr_t pn</i>);</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">paddr_t</i></dt>
<dd class="list-ohang">
<b class="fname">round_page</b>(<i class="farg">address</i>);</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">paddr_t</i></dt>
<dd class="list-ohang">
<b class="fname">trunc_page</b>(<i class="farg">address</i>);</dd>
</dl>
<p>
The <b class="fname">atop</b>() macro converts a physical address <i class="farg">pa</i> into a page number. The <b class="fname">ptoa</b>() macro does the opposite by converting a page number <i class="farg">pn</i> into a physical address.<p>
<b class="fname">round_page</b>() and <b class="fname">trunc_page</b>() macros return a page address boundary from rounding <i class="farg">address</i> up and down, respectively, to the nearest page boundary. These macros work for either addresses or byte counts.</div>
<div class="section">
<h1 id="x53595343544c">SYSCTL</h1> UVM provides support for the <span class="define">CTL_VM</span> domain of the <a class="link-man" href="../3/sysctl">sysctl(3)</a> hierarchy. It handles the <span class="define">VM_LOADAVG</span>, <span class="define">VM_METER</span>, <span class="define">VM_UVMEXP</span>, and <span class="define">VM_UVMEXP2</span> nodes, which return the current load averages, calculates current VM totals, returns the uvmexp structure, and a kernel version independent view of the uvmexp structure, respectively. It also exports a number of tunables that control how much VM space is allowed to be consumed by various tasks. The load averages are typically accessed from userland using the <a class="link-man" href="../3/getloadavg">getloadavg(3)</a> function. The uvmexp structure has all global state of the UVM system, and has the following members:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
/* vm_page constants */ 
int pagesize;   /* size of a page (PAGE_SIZE): must be power of 2 */ 
int pagemask;   /* page mask */ 
int pageshift;  /* page shift */ 
 
/* vm_page counters */ 
int npages;     /* number of pages we manage */ 
int free;       /* number of free pages */ 
int paging;     /* number of pages in the process of being paged out */ 
int wired;      /* number of wired pages */ 
int reserve_pagedaemon; /* number of pages reserved for pagedaemon */ 
int reserve_kernel; /* number of pages reserved for kernel */ 
 
/* pageout params */ 
int freemin;    /* min number of free pages */ 
int freetarg;   /* target number of free pages */ 
int inactarg;   /* target number of inactive pages */ 
int wiredmax;   /* max number of wired pages */ 
 
/* swap */ 
int nswapdev;   /* number of configured swap devices in system */ 
int swpages;    /* number of PAGE_SIZE'ed swap pages */ 
int swpginuse;  /* number of swap pages in use */ 
int nswget;     /* number of times fault calls uvm_swap_get() */ 
int nanon;      /* number total of anon's in system */ 
int nfreeanon;  /* number of free anon's */ 
 
/* stat counters */ 
int faults;             /* page fault count */ 
int traps;              /* trap count */ 
int intrs;              /* interrupt count */ 
int swtch;              /* context switch count */ 
int softs;              /* software interrupt count */ 
int syscalls;           /* system calls */ 
int pageins;            /* pagein operation count */ 
                        /* pageouts are in pdpageouts below */ 
int pgswapin;           /* pages swapped in */ 
int pgswapout;          /* pages swapped out */ 
int forks;              /* forks */ 
int forks_ppwait;       /* forks where parent waits */ 
int forks_sharevm;      /* forks where vmspace is shared */ 
 
/* fault subcounters */ 
int fltnoram;   /* number of times fault was out of ram */ 
int fltnoanon;  /* number of times fault was out of anons */ 
int fltpgwait;  /* number of times fault had to wait on a page */ 
int fltpgrele;  /* number of times fault found a released page */ 
int fltrelck;   /* number of times fault relock called */ 
int fltrelckok; /* number of times fault relock is a success */ 
int fltanget;   /* number of times fault gets anon page */ 
int fltanretry; /* number of times fault retrys an anon get */ 
int fltamcopy;  /* number of times fault clears "needs copy" */ 
int fltnamap;   /* number of times fault maps a neighbor anon page */ 
int fltnomap;   /* number of times fault maps a neighbor obj page */ 
int fltlget;    /* number of times fault does a locked pgo_get */ 
int fltget;     /* number of times fault does an unlocked get */ 
int flt_anon;   /* number of times fault anon (case 1a) */ 
int flt_acow;   /* number of times fault anon cow (case 1b) */ 
int flt_obj;    /* number of times fault is on object page (2a) */ 
int flt_prcopy; /* number of times fault promotes with copy (2b) */ 
int flt_przero; /* number of times fault promotes with zerofill (2b) */ 
 
/* daemon counters */ 
int pdwoke;     /* number of times daemon woke up */ 
int pdrevs;     /* number of times daemon rev'd clock hand */ 
int pdfreed;    /* number of pages daemon freed since boot */ 
int pdscans;    /* number of pages daemon scanned since boot */ 
int pdanscan;   /* number of anonymous pages scanned by daemon */ 
int pdobscan;   /* number of object pages scanned by daemon */ 
int pdreact;    /* number of pages daemon reactivated since boot */ 
int pdbusy;     /* number of times daemon found a busy page */ 
int pdpageouts; /* number of times daemon started a pageout */ 
int pdpending;  /* number of times daemon got a pending pageout */ 
int pddeact;    /* number of pages daemon deactivates */</pre>
</div>
<div class="section">
<h1 id="x4e4f544553">NOTES</h1> <b class="fname">uvm_chgkprot</b>() is only available if the kernel has been compiled with options <span class="define">KGDB</span>.<p>
All structure and types whose names begin with &#8220;vm_&#8221; will be renamed to &#8220;uvm_&#8221;.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../2/swapctl">swapctl(2)</a>, <a class="link-man" href="../3/getloadavg">getloadavg(3)</a>, <a class="link-man" href="../3/kvm">kvm(3)</a>, <a class="link-man" href="../3/sysctl">sysctl(3)</a>, <a class="link-man" href="../4/ddb">ddb(4)</a>, <a class="link-man" href="../4/options">options(4)</a>, <a class="link-man" href="../9/memoryallocators">memoryallocators(9)</a>, <a class="link-man" href="../9/pmap">pmap(9)</a>, <a class="link-man" href="../9/ubc">ubc(9)</a>, <a class="link-man" href="../9/uvm_km">uvm_km(9)</a>, <a class="link-man" href="../9/uvm_map">uvm_map(9)</a><p>
<span class="ref"><span class="ref-auth">Charles D. Cranor</span> and <span class="ref-auth">Gurudatta M. Parulkar</span>, <span class="ref-title">The UVM Virtual Memory System</span>, <i class="ref-book">Proceedings of the USENIX Annual Technical Conference</i>, <i class="ref-issue">USENIX Association</i>, <a class="link-ref" href="http://www.usenix.org/event/usenix99/full_papers/cranor/cranor.pdf">http://www.usenix.org/event/usenix99/full_papers/cranor/cranor.pdf</a>, <span class="ref-page">117-130</span>, <span class="ref-date">June 6-11, 1999</span>.</span></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> UVM is a new VM system developed at Washington University in St. Louis (Missouri). UVM's roots lie partly in the Mach-based <span class="unix">4.4BSD</span> VM system, the <span class="unix">FreeBSD</span> VM system, and the SunOS 4 VM system. UVM's basic structure is based on the <span class="unix">4.4BSD</span> VM system. UVM's new anonymous memory system is based on the anonymous memory system found in the SunOS 4 VM (as described in papers published by Sun Microsystems, Inc.). UVM also includes a number of features new to <span class="unix">BSD</span> including page loanout, map entry passing, simplified copy-on-write, and clustered anonymous memory pageout. UVM is also further documented in an August 1998 dissertation by Charles D. Cranor.<p>
UVM appeared in <span class="unix">NetBSD&#160;1.4</span>.</div>
<div class="section">
<h1 id="x415554484f5253">AUTHORS</h1> <span class="author"></span><span class="author">Charles D. Cranor</span> &#60;<a class="link-mail" href="mailto:chuck@ccrc.wustl.edu">chuck@ccrc.wustl.edu</a>&#62; designed and implemented UVM.<p>
<span class="author">Matthew Green</span> &#60;<a class="link-mail" href="mailto:mrg@eterna.com.au">mrg@eterna.com.au</a>&#62; wrote the swap-space management code and handled the logistical issues involved with merging UVM into the <span class="unix">NetBSD</span> source tree.<p>
<span class="author">Chuck Silvers</span> &#60;<a class="link-mail" href="mailto:chuq@chuq.com">chuq@chuq.com</a>&#62; implemented the aobj pager, thus allowing UVM to support System V shared memory and process swapping.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
March 23, 2015</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

