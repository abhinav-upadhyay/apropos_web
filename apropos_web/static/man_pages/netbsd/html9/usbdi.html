<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="/static/man_pages/netbsd/style.css" type="text/css" media="all">
<title>
USBDI(9)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
USBDI(9)</td>
<td class="head-vol" align="center">
Kernel Developer's Manual</td>
<td class="head-rtitle" align="right">
USBDI(9)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">usbdi</b> &#8212; <span class="desc">USB device drivers interface</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">dev/usb/usb.h</a>&gt;</b><br>
<b class="includes">#include &lt;<a class="link-includes">dev/usb/usbdi.h</a>&gt;</b><br>
<b class="includes">#include &lt;<a class="link-includes">dev/usb/usbdi_util.h</a>&gt;</b><div class="subsection">
<h2 id="x46756e6374696f6e73206f6666657265642062792075736264692e68">Functions offered by usbdi.h</h2> <i class="ftype">usbd_status</i><br>
<b class="fname">usbd_open_pipe</b>(<i class="farg" style="white-space:nowrap;">usbd_interface_handle iface</i>, <i class="farg" style="white-space:nowrap;">uint8_t address</i>, <i class="farg" style="white-space:nowrap;">uint8_t flags</i>, <i class="farg" style="white-space:nowrap;">usbd_pipe_handle *pipe</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_close_pipe</b>(<i class="farg" style="white-space:nowrap;">usbd_pipe_handle pipe</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_transfer</b>(<i class="farg" style="white-space:nowrap;">usbd_xfer_handle xfer</i>);<p>
<i class="ftype">usbd_xfer_handle</i><br>
<b class="fname">usbd_alloc_xfer</b>(<i class="farg" style="white-space:nowrap;">usbd_device_handle dev</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_free_xfer</b>(<i class="farg" style="white-space:nowrap;">usbd_xfer_handle xfer</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">usbd_setup_xfer</b>(<i class="farg" style="white-space:nowrap;">usbd_xfer_handle xfer</i>, <i class="farg" style="white-space:nowrap;">usbd_pipe_handle pipe</i>, <i class="farg" style="white-space:nowrap;">usbd_private_handle priv</i>, <i class="farg" style="white-space:nowrap;">void *buffer</i>, <i class="farg" style="white-space:nowrap;">uint32_t length</i>, <i class="farg" style="white-space:nowrap;">uint16_t flags</i>, <i class="farg" style="white-space:nowrap;">uint32_t timeout</i>, <i class="farg" style="white-space:nowrap;">usbd_callback</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">usbd_setup_default_xfer</b>(<i class="farg" style="white-space:nowrap;">usbd_xfer_handle xfer</i>, <i class="farg" style="white-space:nowrap;">usbd_device_handle dev</i>, <i class="farg" style="white-space:nowrap;">usbd_private_handle priv</i>, <i class="farg" style="white-space:nowrap;">uint32_t timeout</i>, <i class="farg" style="white-space:nowrap;">usb_device_request_t *req</i>, <i class="farg" style="white-space:nowrap;"> void *buffer</i>, <i class="farg" style="white-space:nowrap;">uint32_t length</i>, <i class="farg" style="white-space:nowrap;">uint16_t flags</i>, <i class="farg" style="white-space:nowrap;">usbd_callback</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">usbd_setup_isoc_xfer</b>(<i class="farg" style="white-space:nowrap;">usbd_xfer_handle xfer</i>, <i class="farg" style="white-space:nowrap;">usbd_pipe_handle pipe</i>, <i class="farg" style="white-space:nowrap;">usbd_private_handle priv</i>, <i class="farg" style="white-space:nowrap;">uint16_t *frlengths</i>, <i class="farg" style="white-space:nowrap;">uint32_t nframes</i>, <i class="farg" style="white-space:nowrap;">uint16_t flags</i>, <i class="farg" style="white-space:nowrap;">usbd_callback</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">usbd_get_xfer_status</b>(<i class="farg" style="white-space:nowrap;">usbd_xfer_handle xfer</i>, <i class="farg" style="white-space:nowrap;">usbd_private_handle *priv</i>, <i class="farg" style="white-space:nowrap;">void **buffer</i>, <i class="farg" style="white-space:nowrap;">uint32_t *count</i>, <i class="farg" style="white-space:nowrap;">usbd_status *status</i>);<p>
<i class="ftype">usb_endpoint_descriptor_t *</i><br>
<b class="fname">usbd_interface2endpoint_descriptor</b>(<i class="farg" style="white-space:nowrap;">usbd_interface_handle iface</i>, <i class="farg" style="white-space:nowrap;">uint8_t address</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_abort_pipe</b>(<i class="farg" style="white-space:nowrap;">usbd_pipe_handle pipe</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_abort_default_pipe</b>(<i class="farg" style="white-space:nowrap;">usbd_device_handle dev</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_clear_endpoint_stall</b>(<i class="farg" style="white-space:nowrap;">usbd_pipe_handle pipe</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_clear_endpoint_stall_async</b>(<i class="farg" style="white-space:nowrap;">usbd_pipe_handle pipe</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">usbd_clear_endpoint_toggle</b>(<i class="farg" style="white-space:nowrap;">usbd_pipe_handle pipe</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_endpoint_count</b>(<i class="farg" style="white-space:nowrap;">usbd_interface_handle dev</i>, <i class="farg" style="white-space:nowrap;">uint8_t *count</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_interface_count</b>(<i class="farg" style="white-space:nowrap;">usbd_device_handle dev</i>, <i class="farg" style="white-space:nowrap;">uint8_t *count</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_interface2device_handle</b>(<i class="farg" style="white-space:nowrap;">usbd_interface_handle iface</i>, <i class="farg" style="white-space:nowrap;">usbd_device_handle *dev</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_device2interface_handle</b>(<i class="farg" style="white-space:nowrap;">usbd_device_handle dev</i>, <i class="farg" style="white-space:nowrap;">uint8_t ifaceno</i>, <i class="farg" style="white-space:nowrap;">usbd_interface_handle *iface</i>);<p>
<br>
<i class="ftype">usbd_device_handle</i><br>
<b class="fname">usbd_pipe2device_handle</b>(<i class="farg" style="white-space:nowrap;">usbd_pipe_handle pipe</i>);<p>
<i class="ftype">void *</i><br>
<b class="fname">usbd_alloc_buffer</b>(<i class="farg" style="white-space:nowrap;">usbd_xfer_handle req</i>, <i class="farg" style="white-space:nowrap;">uint32_t size</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">usbd_free_buffer</b>(<i class="farg" style="white-space:nowrap;">usbd_xfer_handle req</i>);<p>
<i class="ftype">void *</i><br>
<b class="fname">usbd_get_buffer</b>(<i class="farg" style="white-space:nowrap;">usbd_xfer_handle xfer</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_sync_transfer</b>(<i class="farg" style="white-space:nowrap;">usbd_xfer_handle req</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_sync_transfer_sig</b>(<i class="farg" style="white-space:nowrap;">usbd_xfer_handle req</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_open_pipe_intr</b>(<i class="farg" style="white-space:nowrap;">usbd_interface_handle iface</i>, <i class="farg" style="white-space:nowrap;">uint8_t address</i>, <i class="farg" style="white-space:nowrap;">uint8_t flags</i>, <i class="farg" style="white-space:nowrap;">usbd_pipe_handle *pipe</i>, <i class="farg" style="white-space:nowrap;">usbd_private_handle priv</i>, <i class="farg" style="white-space:nowrap;">void *buffer</i>, <i class="farg" style="white-space:nowrap;">uint32_t length</i>, <i class="farg" style="white-space:nowrap;">usbd_callback callback</i>, <i class="farg" style="white-space:nowrap;">int interval</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_do_request</b>(<i class="farg" style="white-space:nowrap;">usbd_device_handle dev</i>, <i class="farg" style="white-space:nowrap;">usb_device_request_t *req</i>, <i class="farg" style="white-space:nowrap;">void *data</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_do_request_flags</b>(<i class="farg" style="white-space:nowrap;">usbd_device_handle dev</i>, <i class="farg" style="white-space:nowrap;">usb_device_request_t *req</i>, <i class="farg" style="white-space:nowrap;">void *data</i>, <i class="farg" style="white-space:nowrap;">uint16_t flags</i>, <i class="farg" style="white-space:nowrap;">int *actlen</i>, <i class="farg" style="white-space:nowrap;">u_int32_t timo</i>);<p>
<i class="ftype">usb_interface_descriptor_t *</i><br>
<b class="fname">usbd_get_interface_descriptor</b>(<i class="farg" style="white-space:nowrap;">usbd_interface_handle iface</i>);<p>
<i class="ftype">usb_config_descriptor_t *</i><br>
<b class="fname">usbd_get_config_descriptor</b>(<i class="farg" style="white-space:nowrap;">usbd_device_handle dev</i>);<p>
<i class="ftype">usb_device_descriptor_t *</i><br>
<b class="fname">usbd_get_device_descriptor</b>(<i class="farg" style="white-space:nowrap;">usbd_device_handle dev</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_set_interface</b>(<i class="farg" style="white-space:nowrap;">usbd_interface_handle iface</i>, <i class="farg" style="white-space:nowrap;">int altidx</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">usbd_get_no_alts</b>(<i class="farg" style="white-space:nowrap;">usb_config_descriptor_t *iface</i>, <i class="farg" style="white-space:nowrap;">int ifaceno</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_fill_deviceinfo</b>(<i class="farg" style="white-space:nowrap;">usbd_device_handle dev</i>, <i class="farg" style="white-space:nowrap;">struct usb_device_info *di</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">usbd_get_interface_altindex</b>(<i class="farg" style="white-space:nowrap;">usbd_interface_handle iface</i>);<p>
<i class="ftype">usb_endpoint_descriptor_t *</i><br>
<b class="fname">usbd_get_endpoint_descriptor</b>(<i class="farg" style="white-space:nowrap;">usbd_interface_handle dev</i>, <i class="farg" style="white-space:nowrap;">u_int8_t address</i>);<p>
<i class="ftype">usb_interface_descriptor_t *</i><br>
<b class="fname">usbd_find_idesc</b>(<i class="farg" style="white-space:nowrap;">usb_config_descriptor_t *cd</i>, <i class="farg" style="white-space:nowrap;">int iindex</i>, <i class="farg" style="white-space:nowrap;">int ano</i>);<p>
<i class="ftype">usb_endpoint_descriptor_t *</i><br>
<b class="fname">usbd_find_edesc</b>(<i class="farg" style="white-space:nowrap;">usb_config_descriptor_t *cd</i>, <i class="farg" style="white-space:nowrap;">int ifaceidx</i>, <i class="farg" style="white-space:nowrap;">int altidx</i>, <i class="farg" style="white-space:nowrap;">int endptidx</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">usbd_dopoll</b>(<i class="farg" style="white-space:nowrap;">usbd_interface_handle iface</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">usbd_set_polling</b>(<i class="farg" style="white-space:nowrap;">usbd_device_handle iface</i>, <i class="farg" style="white-space:nowrap;">int val</i>);<p>
<i class="ftype">const char *</i><br>
<b class="fname">usbd_errstr</b>(<i class="farg" style="white-space:nowrap;">usbd_status err</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">usbd_add_dev_event</b>(<i class="farg" style="white-space:nowrap;">int type</i>, <i class="farg" style="white-space:nowrap;">usbd_device_handle iface</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">usbd_add_drv_event</b>(<i class="farg" style="white-space:nowrap;">int type</i>, <i class="farg" style="white-space:nowrap;">usbd_device_handle iface</i>, <i class="farg" style="white-space:nowrap;">device_t dv</i>);<p>
<i class="ftype">char *</i><br>
<b class="fname">usbd_devinfo_alloc</b>(<i class="farg" style="white-space:nowrap;">usbd_device_handle iface</i>, <i class="farg" style="white-space:nowrap;">int showclass</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">usbd_devinfo_free</b>(<i class="farg" style="white-space:nowrap;">char *str</i>);<p>
<i class="ftype">const struct usbd_quirks *</i><br>
<b class="fname">usbd_get_quirks</b>(<i class="farg" style="white-space:nowrap;">usbd_device_handle iface</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_reload_device_desc</b>(<i class="farg" style="white-space:nowrap;">usbd_device_handle iface</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">usbd_ratecheck</b>(<i class="farg" style="white-space:nowrap;">struct timeval *tv</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_get_string</b>(<i class="farg" style="white-space:nowrap;">usbd_device_handle iface</i>, <i class="farg" style="white-space:nowrap;">int si</i>, <i class="farg" style="white-space:nowrap;">char *buf</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_get_string0</b>(<i class="farg" style="white-space:nowrap;">usbd_device_handle iface</i>, <i class="farg" style="white-space:nowrap;">int si</i>, <i class="farg" style="white-space:nowrap;">char *buf</i>, <i class="farg" style="white-space:nowrap;">int unicode</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">usb_desc_iter_init</b>(<i class="farg" style="white-space:nowrap;">usbd_device_handle iface</i>, <i class="farg" style="white-space:nowrap;">usbd_desc_iter_t *iter</i>);<p>
<i class="ftype">const usb_descriptor_t *</i><br>
<b class="fname">usb_desc_iter_next</b>(<i class="farg" style="white-space:nowrap;">usbd_desc_iter_t *iter</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">usb_add_task</b>(<i class="farg" style="white-space:nowrap;">usbd_device_handle iface</i>, <i class="farg" style="white-space:nowrap;">struct usb_task *task</i>, <i class="farg" style="white-space:nowrap;">int queue</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">usb_rem_task</b>(<i class="farg" style="white-space:nowrap;">usbd_device_handle iface</i>, <i class="farg" style="white-space:nowrap;">struct usb_task *task</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">usb_init_task</b>(<i class="farg" style="white-space:nowrap;">struct usb_task *task</i>, <i class="farg" style="white-space:nowrap;">void (*func)(void *)</i>, <i class="farg" style="white-space:nowrap;">void *arg</i>, <i class="farg" style="white-space:nowrap;">uint8_t</i>, <i class="farg" style="white-space:nowrap;">flags</i>);<p>
<i class="ftype">const struct usb_devno *</i><br>
<b class="fname">usb_lookup</b>(<i class="farg" style="white-space:nowrap;">const struct usb_devno *tbl</i>, <i class="farg" style="white-space:nowrap;">u_int16_t vendor</i>, <i class="farg" style="white-space:nowrap;">u_int16_t product</i>);</div>
<div class="subsection">
<h2 id="x5574696c69746965732066726f6d2075736264695f7574696c2e68">Utilities from usbdi_util.h</h2> Based on the routines in <span class="define">usbdi.h</span> a number of utility functions have been defined that are accessible through <span class="define">usbdi_util.h</span>.<br>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_get_desc</b>(<i class="farg" style="white-space:nowrap;">usbd_device_handle dev</i>, <i class="farg" style="white-space:nowrap;">int type</i>, <i class="farg" style="white-space:nowrap;">int index</i>, <i class="farg" style="white-space:nowrap;">int len</i>, <i class="farg" style="white-space:nowrap;">void *desc</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_get_config_desc</b>(<i class="farg" style="white-space:nowrap;">usbd_device_handle dev</i>, <i class="farg" style="white-space:nowrap;">int confidx</i>, <i class="farg" style="white-space:nowrap;">usb_config_descriptor_t *d</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_get_config_desc_full</b>(<i class="farg" style="white-space:nowrap;">usbd_device_handle</i>, <i class="farg" style="white-space:nowrap;">int dev</i>, <i class="farg" style="white-space:nowrap;">void *d</i>, <i class="farg" style="white-space:nowrap;">int size</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_get_device_desc</b>(<i class="farg" style="white-space:nowrap;">usbd_device_handle dev</i>, <i class="farg" style="white-space:nowrap;">usb_device_descriptor_t *d</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_set_address</b>(<i class="farg" style="white-space:nowrap;">usbd_device_handle dev</i>, <i class="farg" style="white-space:nowrap;">int addr</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_get_port_status</b>(<i class="farg" style="white-space:nowrap;">usbd_device_handle dev</i>, <i class="farg" style="white-space:nowrap;">int port</i>, <i class="farg" style="white-space:nowrap;">usb_port_status_t *ps</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_set_hub_feature</b>(<i class="farg" style="white-space:nowrap;">usbd_device_handle dev</i>, <i class="farg" style="white-space:nowrap;">int sel</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_clear_hub_feature</b>(<i class="farg" style="white-space:nowrap;">usbd_device_handle dev</i>, <i class="farg" style="white-space:nowrap;">int sel</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_set_port_feature</b>(<i class="farg" style="white-space:nowrap;">usbd_device_handle dev</i>, <i class="farg" style="white-space:nowrap;">int port</i>, <i class="farg" style="white-space:nowrap;">int sel</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_clear_port_feature</b>(<i class="farg" style="white-space:nowrap;">usbd_device_handle dev</i>, <i class="farg" style="white-space:nowrap;">int port</i>, <i class="farg" style="white-space:nowrap;">int sel</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_get_device_status</b>(<i class="farg" style="white-space:nowrap;">usbd_device_handle dev</i>, <i class="farg" style="white-space:nowrap;">usb_status_t *st</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_get_hub_status</b>(<i class="farg" style="white-space:nowrap;">usbd_device_handle dev</i>, <i class="farg" style="white-space:nowrap;">usb_hub_status_t *st</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_set_protocol</b>(<i class="farg" style="white-space:nowrap;">usbd_interface_handle dev</i>, <i class="farg" style="white-space:nowrap;">int report</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_get_report_descriptor</b>(<i class="farg" style="white-space:nowrap;">usbd_device_handle dev</i>, <i class="farg" style="white-space:nowrap;">int ifcno</i>, <i class="farg" style="white-space:nowrap;">int repid</i>, <i class="farg" style="white-space:nowrap;">int size</i>, <i class="farg" style="white-space:nowrap;">void *d</i>);<p>
<i class="ftype">struct usb_hid_descriptor *</i><br>
<b class="fname">usbd_get_hid_descriptor</b>(<i class="farg" style="white-space:nowrap;">usbd_interface_handle ifc</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_set_report</b>(<i class="farg" style="white-space:nowrap;">usbd_interface_handle iface</i>, <i class="farg" style="white-space:nowrap;">int type</i>, <i class="farg" style="white-space:nowrap;">int id</i>, <i class="farg" style="white-space:nowrap;">void *data</i>, <i class="farg" style="white-space:nowrap;">int len</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_set_report_async</b>(<i class="farg" style="white-space:nowrap;">usbd_interface_handle iface</i>, <i class="farg" style="white-space:nowrap;">int type</i>, <i class="farg" style="white-space:nowrap;">int id</i>, <i class="farg" style="white-space:nowrap;">void *data</i>, <i class="farg" style="white-space:nowrap;">int len</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_get_report</b>(<i class="farg" style="white-space:nowrap;">usbd_interface_handle iface</i>, <i class="farg" style="white-space:nowrap;">int type</i>, <i class="farg" style="white-space:nowrap;">int id</i>, <i class="farg" style="white-space:nowrap;">void *data</i>, <i class="farg" style="white-space:nowrap;">int len</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_set_idle</b>(<i class="farg" style="white-space:nowrap;">usbd_interface_handle iface</i>, <i class="farg" style="white-space:nowrap;">int duration</i>, <i class="farg" style="white-space:nowrap;">int id</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_alloc_report_desc</b>(<i class="farg" style="white-space:nowrap;">usbd_interface_handle ifc</i>, <i class="farg" style="white-space:nowrap;">void **descp</i>, <i class="farg" style="white-space:nowrap;">int *sizep</i>, <i class="farg" style="white-space:nowrap;">int mem</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_get_string_desc</b>(<i class="farg" style="white-space:nowrap;">usbd_device_handle dev</i>, <i class="farg" style="white-space:nowrap;">int sindex</i>, <i class="farg" style="white-space:nowrap;">int langid</i>, <i class="farg" style="white-space:nowrap;">usb_string_descriptor_t *sdesc</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">usbd_delay_ms</b>(<i class="farg" style="white-space:nowrap;">usbd_device_handle dev</i>, <i class="farg" style="white-space:nowrap;">u_int ms</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_set_config_no</b>(<i class="farg" style="white-space:nowrap;">usbd_device_handle dev</i>, <i class="farg" style="white-space:nowrap;">int no</i>, <i class="farg" style="white-space:nowrap;">int msg</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_set_config_index</b>(<i class="farg" style="white-space:nowrap;">usbd_device_handle dev</i>, <i class="farg" style="white-space:nowrap;">int index</i>, <i class="farg" style="white-space:nowrap;">int msg</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_bulk_transfer</b>(<i class="farg" style="white-space:nowrap;">usbd_xfer_handle xfer</i>, <i class="farg" style="white-space:nowrap;">usbd_pipe_handle pipe</i>, <i class="farg" style="white-space:nowrap;">uint16_t flags</i>, <i class="farg" style="white-space:nowrap;">uint32_t timeout</i>, <i class="farg" style="white-space:nowrap;">void *buf</i>, <i class="farg" style="white-space:nowrap;">uint32_t *size</i>, <i class="farg" style="white-space:nowrap;">char *lbl</i>);<p>
<i class="ftype">usbd_status</i><br>
<b class="fname">usbd_intr_transfer</b>(<i class="farg" style="white-space:nowrap;">usbd_xfer_handle xfer</i>, <i class="farg" style="white-space:nowrap;">usbd_pipe_handle pipe</i>, <i class="farg" style="white-space:nowrap;">uint16_t flags</i>, <i class="farg" style="white-space:nowrap;">uint32_t timeout</i>, <i class="farg" style="white-space:nowrap;">void *buf</i>, <i class="farg" style="white-space:nowrap;">uint32_t *size</i>, <i class="farg" style="white-space:nowrap;">char *lbl</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">usb_detach_waitold</b>(<i class="farg" style="white-space:nowrap;">device_t dv</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">usb_detach_wakeupold</b>(<i class="farg" style="white-space:nowrap;">device_t dv</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">usb_detach_wait</b>(<i class="farg" style="white-space:nowrap;">device_t dv</i>, <i class="farg" style="white-space:nowrap;">kcondvar_t *cv</i>, <i class="farg" style="white-space:nowrap;">kmutex_t *lk</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">usb_detach_broadcast</b>(<i class="farg" style="white-space:nowrap;">device_t dv</i>, <i class="farg" style="white-space:nowrap;">kcondvar_t *cv</i>);</div>
</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> Device driver access to the USB bus centers around transfers. A transfer describes a communication with a USB device. A transfer is an abstract concept that can result in several physical packets being transferred to or from a device. A transfer is described by the <b class="var">usbd_xfer_handle</b> cookie. A pipe is a logical connection to a USB device. It is described by the <b class="var">usbd_pipe_handle</b> cookie. See the <i class="link-sec"><a class="link-sec" href="#x5452414e5346455253">TRANSFERS</a></i> and <i class="link-sec"><a class="link-sec" href="#x5049504553">PIPES</a></i> sections for more details.<p>
There are a number of functions to obtain a handle, descriptor of resource count:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">usbd_device2interface_handle</b>(<i class="farg">dev</i>, <i class="farg">ifaceno</i>, <i class="farg">iface</i>)</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Fills in <i class="farg">iface</i> with the <i class="ftype">usbd_interface_handle</i> for the USB device <i class="farg">dev</i> on interface number <i class="farg">ifaceno</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">usbd_interface2device_handle</b>(<i class="farg">iface</i>, <i class="farg">dev</i>)</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Fills in <i class="farg">dev</i> with the <i class="ftype">usbd_device_handle</i> pointer for interface <i class="farg">iface</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">usbd_pipe2device_handle</b>(<i class="farg">pipe</i>)</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Returns the <i class="ftype">usbd_device_handle</i> associated with <i class="farg">pipe</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">usbd_interface2endpoint_descriptor</b>(<i class="farg">iface</i>, <i class="farg">address</i>)</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Returns the <i class="ftype">usb_endpoint_descriptor_t *</i> for the particular interface <i class="farg">iface</i> at address <i class="farg">address</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">usbd_endpoint_count</b>(<i class="farg">dev</i>, <i class="farg">count</i>)</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">usbd_interface_count</b>(<i class="farg">dev</i>, <i class="farg">count</i>)</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Fills in <i class="farg">count</i> with the number of endpoint or interfaces the USB device <i class="farg">dev</i> has.</dd>
</dl>
<p>
Error handling and other return values are described in <a class="link-man" href="../9/usbd_status">usbd_status(9)</a>.<p>
Additional comments on particular functions:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">usbd_errstr</b>(<i class="farg">err</i>)</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Returns the string associated with <i class="farg">err</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">usbd_add_dev_event</b>(<i class="farg">type</i>, <i class="farg">iface</i>)</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
The <i class="arg">type</i> must be one of <span class="define">USB_EVENT_CTRLR_ATTACH</span>, <span class="define">USB_EVENT_CTRLR_DETACH</span>, <span class="define">USB_EVENT_DEVICE_ATTACH</span> and <span class="define">USB_EVENT_DEVICE_DETACH</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">usbd_add_drv_event</b>(<i class="farg">type</i>, <i class="farg">iface</i>, <i class="farg">dv</i>)</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
The <i class="farg">type</i> must be one of <span class="define">USB_EVENT_DRIVER_ATTACH</span> and <span class="define">USB_EVENT_DRIVER_DETACH</span>. The <i class="farg">dv</i> corresponds with the <i class="ftype">device_t</i> associated with the device attached or detached.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">usb_lookup</b>(<i class="farg">tbl</i>, <i class="farg">vendor</i>, <i class="farg">product</i>)</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Lookup a USB device. The returned <b class="var">struct usb_devno</b> pointer has these members:<ul style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-item">
<li class="list-item" style="margin-top: 0.00em;">
<span class="type">u_int16_t ud_vendor</span>;</li>
<li class="list-item" style="margin-top: 0.00em;">
<span class="type">u_int16_t ud_product</span>;</li>
</ul>
The <span class="define">USB_PRODUCT_ANY</span> macro can be used to match any USB product by a particular vendor.</dd>
</dl>
</div>
<div class="section">
<h1 id="x5049504553">PIPES</h1> Pipes are created and destroyed by using the <b class="fname">usbd_open_pipe</b>(), <b class="fname">usbd_open_pipe_intr</b>() and <b class="fname">usbd_close_pipe</b>() functions. The open functions take the interface handle <i class="farg">iface</i>, the <i class="farg">address</i> of this pipe and <i class="farg">flags</i> for this pipe which currently may be 0, or a combination of <span class="define">USBD_EXCLUSIVE_USE</span>, to enable exclusive access to this interface and address, and <span class="define">USBD_MPSAFE</span>, to allow running transfer callbacks on this pipe without first acquiring <span class="define">kernel_lock</span>. The <b class="fname">usbd_open_pipe_intr</b>() takes additional arguments <i class="farg">priv</i> to set the default private handle. <i class="farg">buffer</i> and <i class="farg">len</i> to describe the buffer to be used, <i class="farg">callback</i> for the function to call at interrupt time, and finally the <i class="farg">interval</i> for interrupts to be delivered in milliseconds. The <i class="farg">interval</i> may be set to <span class="define">USBD_DEFAULT_INTERVAL</span> use the default interval, specified by the ep. description. It is common to have more than one pipe per device.</div>
<div class="section">
<h1 id="x5452414e5346455253">TRANSFERS</h1> Transfers are allocated and deallocated with <b class="fname">usbd_alloc_xfer</b>() and <b class="fname">usbd_free_xfer</b>(), respectively, and are associated with a pipe at their creation time.<p>
The data describing the transfer is filled by either <b class="fname">usbd_setup_default_xfer</b>() for control pipe transfers, by <b class="fname">usbd_setup_xfer</b>() for bulk and interrupt transfers, and by <b class="fname">usbd_setup_isoc_xfer</b>() for isochronous transfers. Private data may be passed between setup and completion or status calls using the <i class="ftype">usbd_private_handle priv</i> argument, which must be an integral type.<p>
Arguments to the setup functions include the newly allocated <i class="farg">xfer</i>, the <i class="farg">pipe</i> to associate this transfer with, the private data <i class="farg">priv</i>, the <i class="farg">timeout</i> in milliseconds, for control, bulk and interrupt transfers <i class="farg">buffer</i> the data to transfer and its <i class="farg">length</i> and for isochronous transfers the frame length <i class="farg">frlengths</i> and number of frames <i class="farg">nframes</i>, and for default transfers a USB request structure <i class="farg">req</i> must be presented. See the <i class="link-sec"><a class="link-sec" href="#x494e495449414c4953494e4720555342205245515545535453">INITIALISING USB REQUESTS</a></i> section for more details on USB requests.<p>
The transfer specific <i class="farg">flags</i> that can be set are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">USBD_NO_COPY</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Do not copy data to DMA buffer</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">USBD_SYNCHRONOUS</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Wait for completion</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">USBD_SYNCHRONOUS_SIG</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
When waiting for completion, allow signals to trigger wake up.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">USBD_SHORT_XFER_OK</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Short reads are not an error</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">USBD_FORCE_SHORT_XFER</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Force last short packet on write</dd>
</dl>
<p>
To allocate buffers suitable for USB tranfers (i.e., DMA capable), the <b class="fname">usbd_alloc_buffer</b>() function should be used on the specified <i class="farg">xfer</i> for <i class="farg">size</i> bytes of space. The <b class="fname">usbd_free_buffer</b>() function can be used to free the buffer after use. The <b class="fname">usbd_get_buffer</b>() function returns the current kernel address for the DMA-capable buffer in <i class="farg">xfer</i>.<p>
Upon completion the <i class="farg">callback</i> function is called, which takes the completed <i class="farg">xfer</i>, the private data <i class="farg">priv</i> originally assocated with this transfer, and <i class="farg">status</i> the status of this transfer.<p>
Transfers are initiated by calling <b class="fname">usbd_transfer</b>(), and their results made be later obtained by calling <i class="farg">usbd_get_xfer_status</i>, which fills in the private data <i class="farg">priv</i>, original buffer location <i class="farg">buffer</i>, the length <i class="farg">length</i>, and the <i class="farg">status</i> of this request.<p>
The <b class="fname">usbd_bulk_transfer</b>() and <b class="fname">usbd_intr_transfer</b>() functions are used to transfer data in either an interrupt or bulk fashion, and are front-ends to the <b class="fname">usbd_setup_xfer</b>(), <b class="fname">usbd_transfer</b>() and <b class="fname">usbd_get_xfer_status</b>(), as well as associated error handling. The <i class="farg">lbl</i> option is deprecated and will be removed. The <b class="fname">usbd_sync_transfer</b>() is identical to <b class="fname">usbd_transfer</b>() with the <span class="define">USBD_SYNCHRONOUS</span> flag set. The <b class="fname">usbd_sync_transfer_sig</b>() is identical to <b class="fname">usbd_transfer</b>() with the <span class="define">USBD_SYNCHRONOUS</span> and <span class="define">USBD_SYNCHRONOUS_SIG</span> flags set.<p>
Transfers are aborted via this pipe with <b class="fname">usbd_abort_pipe</b>() and <b class="fname">usbd_abort_default_pipe</b>().<p>
The <b class="fname">usbd_clear_endpoint_stall</b>() and <b class="fname">usbd_clear_endpoint_stall_async</b>() functions are used to clear endpoint halt in either a synchronous or asynchronous fashion. To clear the toggle state of an endpoint the <b class="fname">usbd_clear_endpoint_toggle</b>() function should be used.<p>
A request is described by a <b class="var">usb_device_request_t</b> which must be initialised as necessary before calling either <b class="fname">usbd_do_request</b>() or <b class="fname">usbd_do_request_flags</b>() to submit the request. For both these functions <i class="farg">dev</i> is the handle of the USB device the request is for, <i class="farg">req</i> is the USB request, as described in the <i class="link-sec"><a class="link-sec" href="#x494e495449414c4953494e4720555342205245515545535453">INITIALISING USB REQUESTS</a></i> section, and then <i class="farg">data</i> is a buffer containing the data for the request. For the <b class="fname">usbd_do_request_flags</b>() function there are additional <i class="farg">flags</i> passed to the <i class="farg">usbd_setup</i> function, <i class="farg">actlen</i> a pointer to fill in with the actual length of this request, and <i class="farg">timo</i>, the number of milliseconds to wait before timing out this request.</div>
<div class="section">
<h1 id="x494e495449414c4953494e4720555342205245515545535453">INITIALISING USB REQUESTS</h1> There are 5 members of a <b class="var">usb_device_request_t</b> that must be initialised:<p>
<ul style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-item">
<li class="list-item" style="margin-top: 0.00em;">
<span class="type">uByte bmRequestType</span>;</li>
<li class="list-item" style="margin-top: 0.00em;">
<span class="type">uByte bRequest</span>;</li>
<li class="list-item" style="margin-top: 0.00em;">
<span class="type">uWord wValue</span>;</li>
<li class="list-item" style="margin-top: 0.00em;">
<span class="type">uWord wIndex</span>;</li>
<li class="list-item" style="margin-top: 0.00em;">
<span class="type">uWord wLength</span>;</li>
</ul>
<p>
The first two are normal byte values that may be simply assigned, but the last three must be initialised with the <b class="fname">USETW</b>() macro.<p>
The <i class="farg">bmRequestType</i> holds the request type of this USB request, which describes the indended recipient of the request.<p>
This may be one of:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UT_WRITE</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UT_READ</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
</dd>
</dl>
<p>
with one of:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UT_STANDARD</span></dt>
<dd class="list-tag" style="margin-left: 13.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UT_CLASS</span></dt>
<dd class="list-tag" style="margin-left: 13.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UT_VENDOR</span></dt>
<dd class="list-tag" style="margin-left: 13.00ex;">
</dd>
</dl>
<p>
and with one of:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UT_DEVICE</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UT_INTERFACE</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UT_ENDPOINT</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UT_OTHER</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
</dd>
</dl>
<p>
These are also in combinations as:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UT_READ_DEVICE</span></dt>
<dd class="list-tag" style="margin-left: 27.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UT_READ_INTERFACE</span></dt>
<dd class="list-tag" style="margin-left: 27.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UT_READ_ENDPOINT</span></dt>
<dd class="list-tag" style="margin-left: 27.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UT_WRITE_DEVICE</span></dt>
<dd class="list-tag" style="margin-left: 27.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UT_WRITE_INTERFACE</span></dt>
<dd class="list-tag" style="margin-left: 27.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UT_WRITE_ENDPOINT</span></dt>
<dd class="list-tag" style="margin-left: 27.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UT_READ_CLASS_DEVICE</span></dt>
<dd class="list-tag" style="margin-left: 27.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UT_READ_CLASS_INTERFACE</span></dt>
<dd class="list-tag" style="margin-left: 27.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UT_READ_CLASS_OTHER</span></dt>
<dd class="list-tag" style="margin-left: 27.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UT_READ_CLASS_ENDPOINT</span></dt>
<dd class="list-tag" style="margin-left: 27.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UT_WRITE_CLASS_DEVICE</span></dt>
<dd class="list-tag" style="margin-left: 27.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UT_WRITE_CLASS_INTERFACE</span></dt>
<dd class="list-tag" style="margin-left: 27.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UT_WRITE_CLASS_OTHER</span></dt>
<dd class="list-tag" style="margin-left: 27.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UT_WRITE_CLASS_ENDPOINT</span></dt>
<dd class="list-tag" style="margin-left: 27.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UT_READ_VENDOR_DEVICE</span></dt>
<dd class="list-tag" style="margin-left: 27.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UT_READ_VENDOR_INTERFACE</span></dt>
<dd class="list-tag" style="margin-left: 27.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UT_READ_VENDOR_OTHER</span></dt>
<dd class="list-tag" style="margin-left: 27.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UT_READ_VENDOR_ENDPOINT</span></dt>
<dd class="list-tag" style="margin-left: 27.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UT_WRITE_VENDOR_DEVICE</span></dt>
<dd class="list-tag" style="margin-left: 27.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UT_WRITE_VENDOR_INTERFACE</span></dt>
<dd class="list-tag" style="margin-left: 27.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UT_WRITE_VENDOR_OTHER</span></dt>
<dd class="list-tag" style="margin-left: 27.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UT_WRITE_VENDOR_ENDPOINT</span></dt>
<dd class="list-tag" style="margin-left: 27.00ex;">
</dd>
</dl>
<p>
The <i class="farg">bRequest</i> describes which request is being made. The available values are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UR_GET_STATUS</span></dt>
<dd class="list-tag" style="margin-left: 19.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UR_CLEAR_FEATURE</span></dt>
<dd class="list-tag" style="margin-left: 19.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UR_SET_FEATURE</span></dt>
<dd class="list-tag" style="margin-left: 19.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UR_SET_ADDRESS</span></dt>
<dd class="list-tag" style="margin-left: 19.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UR_GET_DESCRIPTOR</span></dt>
<dd class="list-tag" style="margin-left: 19.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UR_SET_DESCRIPTOR</span></dt>
<dd class="list-tag" style="margin-left: 19.00ex;">
</dd>
</dl>
<p>
The <i class="farg">wValue</i>, <i class="farg">wIndex</i> and <i class="farg">wLength</i> are device-specific values and must be initialised with the <b class="fname">USETW</b>() macro.</div>
<div class="section">
<h1 id="x555342205245515545535420545950455320414e442053545255435455524553">USB REQUEST TYPES AND STRUCTURES</h1> The <span class="define">UR_GET_STATUS</span> request operates on a <b class="var">usb_status_t</b> structure, which has this member:<ul style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-item">
<li class="list-item" style="margin-top: 0.00em;">
<span class="type">uWord wStatus</span>;</li>
</ul>
<p>
For device status requests the <i class="farg">wStatus</i> member may have either of these bit flags set:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UDS_SELF_POWERED</span></dt>
<dd class="list-tag" style="margin-left: 19.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UDS_REMOTE_WAKEUP</span></dt>
<dd class="list-tag" style="margin-left: 19.00ex;">
</dd>
</dl>
<p>
For endpoint status requests the <i class="farg">wStatus</i> member may have this bit flag set:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UES_HALT</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
</dd>
</dl>
<p>
The <span class="define">UR_CLEAR_FEATURE</span> and <span class="define">UR_SET_FEATURE</span> requests clear or set special features on USB devices. The values for <b class="var">wValue</b>, <b class="var">wIndex</b> and <b class="var">wLength</b> depend upon the device and device type.<p>
The <span class="define">UR_SET_ADDRESS</span> request sets the virtual USB address of a port using the <b class="var">wValue</b>.<p>
The <span class="define">UR_GET_DESCRIPTOR</span> and <span class="define">UR_SET_DESCRIPTOR</span> requests operate on a <b class="var">usb_descriptor_t</b> structure, which has these members:<ul style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-item">
<li class="list-item" style="margin-top: 0.00em;">
<span class="type">uByte bLength</span>;</li>
<li class="list-item" style="margin-top: 0.00em;">
<span class="type">uByte bDescriptorType</span>;</li>
</ul>
<p>
The <i class="farg">bDescriptorType</i> member may be one of the following values:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 6.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UDESC_DEVICE</span></dt>
<dd class="list-tag" style="margin-left: 33.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UDESC_CONFIG</span></dt>
<dd class="list-tag" style="margin-left: 33.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UDESC_STRING</span></dt>
<dd class="list-tag" style="margin-left: 33.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UDESC_INTERFACE</span></dt>
<dd class="list-tag" style="margin-left: 33.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UDESC_ENDPOINT</span></dt>
<dd class="list-tag" style="margin-left: 33.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UDESC_DEVICE_QUALIFIER</span></dt>
<dd class="list-tag" style="margin-left: 33.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UDESC_OTHER_SPEED_CONFIGURATION</span></dt>
<dd class="list-tag" style="margin-left: 33.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UDESC_INTERFACE_POWER</span></dt>
<dd class="list-tag" style="margin-left: 33.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UDESC_OTG</span></dt>
<dd class="list-tag" style="margin-left: 33.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UDESC_DEBUG</span></dt>
<dd class="list-tag" style="margin-left: 33.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UDESC_INTERFACE_ASSOC</span></dt>
<dd class="list-tag" style="margin-left: 33.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UDESC_CS_DEVICE</span></dt>
<dd class="list-tag" style="margin-left: 33.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UDESC_CS_CONFIG</span></dt>
<dd class="list-tag" style="margin-left: 33.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UDESC_CS_STRING</span></dt>
<dd class="list-tag" style="margin-left: 33.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UDESC_CS_INTERFACE</span></dt>
<dd class="list-tag" style="margin-left: 33.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UDESC_CS_ENDPOINT</span></dt>
<dd class="list-tag" style="margin-left: 33.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">UDESC_HUB</span></dt>
<dd class="list-tag" style="margin-left: 33.00ex;">
</dd>
</dl>
<p>
The <b class="fname">usbd_set_interface</b>() function can be used to change the index used for transfers on this interface as obtained via <b class="fname">usbd_device2interface_handle</b>().</div>
<div class="section">
<h1 id="x55534220444556494345204445544143484d454e54">USB DEVICE DETACHMENT</h1> There are two functions available to ease the detach of active devices. Typically a reference count is maintained on syscall activity. When a USB device is to be detached, the reference count should be decremented and if it is greater or equal to zero, <b class="fname">usb_detach_wait</b>() should be called on the <i class="ftype">dv</i> associated with this USB device and, typically, a device-specific condition variable <i class="farg">cv</i>. and mutex <i class="farg">lk</i> protecting this reference count state. At the end of each syscall function, if the reference count is decremented to less than zero, then <b class="fname">usb_detach_broadcast</b>() must be called on the <i class="ftype">dv</i> and <i class="farg">cv</i> that is being waited on with <b class="fname">usb_detach_wait</b>().<p>
The are another pair of functions with similar functionality that do not use a condition variable or mutex and should be avoided in new code. The <b class="fname">usb_detach_waitold</b>() function works like <b class="fname">usb_detach_wait</b>(), and the <b class="fname">usb_detach_wakeupold</b>() function works like <b class="fname">usb_detach_broadcast</b>().</div>
<div class="section">
<h1 id="x555342205441534b204d414e4147454d454e54">USB TASK MANAGEMENT</h1> The USB stack provides a task management framework to execute tasks in a thread context at the soonest opportunity. Typically this is used by network drivers to handle periodic updates or status change requests, or other operations that need to run in a normal context.<p>
The <b class="fname">usb_init_task</b>() function takes a pointer to a <i class="ftype">struct usb_task</i> that will be initalised, a function to call for this task <i class="farg">func</i>, the argument to pass to <i class="farg">func</i>, <i class="farg">arg</i>, and the task flags <i class="farg">flags</i>. If the <i class="farg">flags</i> argument is <span class="define">USB_TASKQ_MPSAFE</span>, the <i class="farg">func</i> function will be called without first acquiring <span class="define">kernel_lock</span>.<p>
To invoke the task callback the <b class="fname">usb_add_task</b>() function should be called with the <i class="farg">iface</i> associated with this device, the task structure <i class="farg">task</i>, and the <i class="farg">queue</i> to run against, either <span class="define">USB_TASKQ_HC</span> for operations initiated by host controllers or <span class="define">USB_TASKQ_DRIVER</span> for operations initiated by USB drivers.<p>
To deschedule a potentially running task the <b class="fname">usb_rem_task</b>() function should be called.<p>
The driver using these facilities is expected to provide the necessary serialisation between <b class="fname">usb_init_task</b>(), <b class="fname">usb_add_task</b>() and <b class="fname">usb_rem_task</b>() for each specific <i class="ftype">struct usb_task</i>.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../4/usb">usb(4)</a>, <a class="link-man" href="../9/usbd_status">usbd_status(9)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> This <b class="name">usbdi</b> interface first appeared in <span class="unix">NetBSD&#160;1.4</span>. The interface is based on an early definition from the OpenUSBDI group within the USB organisation. Right after this definition the OpenUSBDI development got closed for open source developers, so this interface has not followed the further changes. The OpenUSBDI specification is now available again, but looks different.</div>
<div class="section">
<h1 id="x42554753">BUGS</h1> This manual is under development, so its biggest shortcoming is incompleteness.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
June 29, 2015</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

