<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="/static/man_pages/netbsd/style.css" type="text/css" media="all">
<title>
SYSCTL(9)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
SYSCTL(9)</td>
<td class="head-vol" align="center">
Kernel Developer's Manual</td>
<td class="head-rtitle" align="right">
SYSCTL(9)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">sysctl</b> &#8212; <span class="desc">system variable control interfaces</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/param.h</a>&gt;</b><br>
<b class="includes">#include &lt;<a class="link-includes">sys/sysctl.h</a>&gt;</b><p>
Primary external interfaces:<br>
<i class="ftype">void</i><br>
<b class="fname">sysctl_init</b>(<i class="farg" style="white-space:nowrap;">void</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">sysctl_lock</b>(<i class="farg" style="white-space:nowrap;">struct lwp *l</i>, <i class="farg" style="white-space:nowrap;">void *oldp</i>, <i class="farg" style="white-space:nowrap;">size_t savelen</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">sysctl_dispatch</b>(<i class="farg" style="white-space:nowrap;">const int *name</i>, <i class="farg" style="white-space:nowrap;">u_int namelen</i>, <i class="farg" style="white-space:nowrap;">void *oldp</i>, <i class="farg" style="white-space:nowrap;">size_t *oldlenp</i>, <i class="farg" style="white-space:nowrap;">const void *newp</i>, <i class="farg" style="white-space:nowrap;">size_t newlen</i>, <i class="farg" style="white-space:nowrap;">const int *oname</i>, <i class="farg" style="white-space:nowrap;">struct lwp *l</i>, <i class="farg" style="white-space:nowrap;">const struct sysctlnode *rnode</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">sysctl_unlock</b>(<i class="farg" style="white-space:nowrap;">struct lwp *l</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">sysctl_createv</b>(<i class="farg" style="white-space:nowrap;">struct sysctllog **log</i>, <i class="farg" style="white-space:nowrap;">int cflags</i>, <i class="farg" style="white-space:nowrap;">const struct sysctlnode **rnode</i>, <i class="farg" style="white-space:nowrap;">const struct sysctlnode **cnode</i>, <i class="farg" style="white-space:nowrap;">int flags</i>, <i class="farg" style="white-space:nowrap;">int type</i>, <i class="farg" style="white-space:nowrap;">const char *namep</i>, <i class="farg" style="white-space:nowrap;">const char *desc</i>, <i class="farg" style="white-space:nowrap;">sysctlfn func</i>, <i class="farg" style="white-space:nowrap;">u_quad_t qv</i>, <i class="farg" style="white-space:nowrap;">void *newp</i>, <i class="farg" style="white-space:nowrap;">size_t newlen</i>, <i class="farg" style="white-space:nowrap;">...</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">sysctl_destroyv</b>(<i class="farg" style="white-space:nowrap;">struct sysctlnode *rnode</i>, <i class="farg" style="white-space:nowrap;">...</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">sysctl_free</b>(<i class="farg" style="white-space:nowrap;">struct sysctlnode *rnode</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">sysctl_teardown</b>(<i class="farg" style="white-space:nowrap;">struct sysctllog **</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">old_sysctl</b>(<i class="farg" style="white-space:nowrap;">int *name</i>, <i class="farg" style="white-space:nowrap;">u_int namelen</i>, <i class="farg" style="white-space:nowrap;">void *oldp</i>, <i class="farg" style="white-space:nowrap;">size_t *oldlenp</i>, <i class="farg" style="white-space:nowrap;">void *newp</i>, <i class="farg" style="white-space:nowrap;">size_t newlen</i>, <i class="farg" style="white-space:nowrap;">struct lwp *l</i>);<p>
Core internal functions:<br>
<i class="ftype">int</i><br>
<b class="fname">sysctl_locate</b>(<i class="farg" style="white-space:nowrap;">struct lwp *l</i>, <i class="farg" style="white-space:nowrap;">const int *name</i>, <i class="farg" style="white-space:nowrap;">u_int namelen</i>, <i class="farg" style="white-space:nowrap;">const struct sysctlnode **rnode</i>, <i class="farg" style="white-space:nowrap;">int *nip</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">sysctl_lookup</b>(<i class="farg" style="white-space:nowrap;">const int *name</i>, <i class="farg" style="white-space:nowrap;">u_int namelen</i>, <i class="farg" style="white-space:nowrap;">void *oldp</i>, <i class="farg" style="white-space:nowrap;">size_t *oldlenp</i>, <i class="farg" style="white-space:nowrap;">const void *newp</i>, <i class="farg" style="white-space:nowrap;">size_t newlen</i>, <i class="farg" style="white-space:nowrap;">const int *oname</i>, <i class="farg" style="white-space:nowrap;">struct lwp *l</i>, <i class="farg" style="white-space:nowrap;">const struct sysctlnode *rnode</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">sysctl_create</b>(<i class="farg" style="white-space:nowrap;">const int *name</i>, <i class="farg" style="white-space:nowrap;">u_int namelen</i>, <i class="farg" style="white-space:nowrap;">void *oldp</i>, <i class="farg" style="white-space:nowrap;">size_t *oldlenp</i>, <i class="farg" style="white-space:nowrap;">const void *newp</i>, <i class="farg" style="white-space:nowrap;">size_t newlen</i>, <i class="farg" style="white-space:nowrap;">const int *oname</i>, <i class="farg" style="white-space:nowrap;">struct lwp *l</i>, <i class="farg" style="white-space:nowrap;">const struct sysctlnode *rnode</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">sysctl_destroy</b>(<i class="farg" style="white-space:nowrap;">const int *name</i>, <i class="farg" style="white-space:nowrap;">u_int namelen</i>, <i class="farg" style="white-space:nowrap;">void *oldp</i>, <i class="farg" style="white-space:nowrap;">size_t *oldlenp</i>, <i class="farg" style="white-space:nowrap;">const void *newp</i>, <i class="farg" style="white-space:nowrap;">size_t newlen</i>, <i class="farg" style="white-space:nowrap;">const int *oname</i>, <i class="farg" style="white-space:nowrap;">struct lwp *l</i>, <i class="farg" style="white-space:nowrap;">const struct sysctlnode *rnode</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">sysctl_query</b>(<i class="farg" style="white-space:nowrap;">const int *name</i>, <i class="farg" style="white-space:nowrap;">u_int namelen</i>, <i class="farg" style="white-space:nowrap;">void *oldp</i>, <i class="farg" style="white-space:nowrap;">size_t *oldlenp</i>, <i class="farg" style="white-space:nowrap;">const void *newp</i>, <i class="farg" style="white-space:nowrap;">size_t newlen</i>, <i class="farg" style="white-space:nowrap;">const int *oname</i>, <i class="farg" style="white-space:nowrap;">struct lwp *l</i>, <i class="farg" style="white-space:nowrap;">const struct sysctlnode *rnode</i>);<p>
Simple &#8220;helper&#8221; functions:<br>
<i class="ftype">int</i><br>
<b class="fname">sysctl_needfunc</b>(<i class="farg" style="white-space:nowrap;">const int *name</i>, <i class="farg" style="white-space:nowrap;">u_int namelen</i>, <i class="farg" style="white-space:nowrap;">void *oldp</i>, <i class="farg" style="white-space:nowrap;">size_t *oldlenp</i>, <i class="farg" style="white-space:nowrap;">const void *newp</i>, <i class="farg" style="white-space:nowrap;">size_t newlen</i>, <i class="farg" style="white-space:nowrap;">const int *oname</i>, <i class="farg" style="white-space:nowrap;">struct lwp *l</i>, <i class="farg" style="white-space:nowrap;">const struct sysctlnode *rnode</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">sysctl_notavail</b>(<i class="farg" style="white-space:nowrap;">const int *name</i>, <i class="farg" style="white-space:nowrap;">u_int namelen</i>, <i class="farg" style="white-space:nowrap;">void *oldp</i>, <i class="farg" style="white-space:nowrap;">size_t *oldlenp</i>, <i class="farg" style="white-space:nowrap;">const void *newp</i>, <i class="farg" style="white-space:nowrap;">size_t newlen</i>, <i class="farg" style="white-space:nowrap;">const int *oname</i>, <i class="farg" style="white-space:nowrap;">struct lwp *l</i>, <i class="farg" style="white-space:nowrap;">const struct sysctlnode *rnode</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">sysctl_null</b>(<i class="farg" style="white-space:nowrap;">const int *name</i>, <i class="farg" style="white-space:nowrap;">u_int namelen</i>, <i class="farg" style="white-space:nowrap;">void *oldp</i>, <i class="farg" style="white-space:nowrap;">size_t *oldlenp</i>, <i class="farg" style="white-space:nowrap;">const void *newp</i>, <i class="farg" style="white-space:nowrap;">size_t newlen</i>, <i class="farg" style="white-space:nowrap;">const int *oname</i>, <i class="farg" style="white-space:nowrap;">struct lwp *l</i>, <i class="farg" style="white-space:nowrap;">const struct sysctlnode *rnode</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The SYSCTL subsystem instruments a number of kernel tunables and other data structures via a simple MIB-like interface, primarily for consumption by userland programs, but also for use internally by the kernel.</div>
<div class="section">
<h1 id="x4c4f434b494e47">LOCKING</h1> All operations on the SYSCTL tree must be protected by acquiring the main SYSCTL lock. The only functions that can be called when the lock is not held are <b class="fname">sysctl_lock</b>(), <b class="fname">sysctl_createv</b>(), <b class="fname">sysctl_destroyv</b>(), and <b class="fname">old_sysctl</b>(). All other functions require the tree to be locked. This is to prevent other users of the tree from moving nodes around during an add operation, or from destroying nodes or subtrees that are actively being used. The lock is acquired by calling <b class="fname">sysctl_lock</b>() with a pointer to the process's lwp <i class="farg">l</i> (<span class="define">NULL</span> may be passed to all functions as the lwp pointer if no lwp is appropriate, though any changes made via <b class="fname">sysctl_create</b>(), <b class="fname">sysctl_destroy</b>(), <b class="fname">sysctl_lookup</b>(), or by any helper function will be done with effective superuser privileges).<p>
The <i class="farg">oldp</i> and <i class="farg">savelen</i> arguments are a pointer to and the size of the memory region the caller will be using to collect data from SYSCTL. These may also be <span class="define">NULL</span> and 0, respectively.<p>
The memory region will be locked via <b class="fname">uvm_vslock</b>() if it is a region in userspace. The address and size of the region are recorded so that when the SYSCTL lock is to be released via <b class="fname">sysctl_unlock</b>(), only the lwp pointer <i class="farg">l</i> is required.</div>
<div class="section">
<h1 id="x4c4f4f4b555053">LOOKUPS</h1> Once the lock has been acquired, it is typical to call <b class="fname">sysctl_dispatch</b>() to handle the request. <b class="fname">sysctl_dispatch</b>() will examine the contents of <i class="farg">name</i>, an array of integers at least <i class="farg">namelen</i> long, which is to be located in kernel space, in order to determine which function to call to handle the specific request.<p>
The following algorithm is used by <b class="fname">sysctl_dispatch</b>() to determine the function to call:<ul style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-bul">
<li class="list-bul" style="margin-top: 1.00em;">
Scan the tree using <b class="fname">sysctl_locate</b>().</li>
<li class="list-bul" style="margin-top: 1.00em;">
If the node returned has a &#8220;helper&#8221; function, call it.</li>
<li class="list-bul" style="margin-top: 1.00em;">
If the requested node was found but has no function, call <b class="fname">sysctl_lookup</b>().</li>
<li class="list-bul" style="margin-top: 1.00em;">
If the node was not found and <i class="farg">name</i> specifies one of <b class="fname">sysctl_query</b>(), <b class="fname">sysctl_create</b>(), or <b class="fname">sysctl_destroy</b>(), call the appropriate function.</li>
<li class="list-bul" style="margin-top: 1.00em;">
If none of these options applies and no other error was yet recorded, return <span class="errno">EOPNOTSUPP</span>.</li>
</ul>
<p>
The <i class="farg">oldp</i> and <i class="farg">oldlenp</i> arguments to <b class="fname">sysctl_dispatch</b>(), as with all the other core functions, describe an area into which the current or requested value may be copied. <i class="farg">oldp</i> may or may not be a pointer into userspace (as dictated by whether <i class="farg">l</i> is <span class="define">NULL</span> or not). <i class="farg">oldlenp</i> is a non-<span class="define">NULL</span> pointer to a size_t. <i class="farg">newp</i> and <i class="farg">newlen</i> describe an area where the new value for the request may be found; <i class="farg">newp</i> may also be a pointer into userspace. The <i class="farg">oname</i> argument is a non-<span class="define">NULL</span> pointer to the base of the request currently being processed. By simple arithmetic on <i class="farg">name</i>, <i class="farg">namelen</i>, and <i class="farg">oname</i>, one can easily determine the entire original request and <i class="farg">namelen</i> values, if needed. The <i class="farg">rnode</i> value, as passed to <b class="fname">sysctl_dispatch</b>() represents the root of the tree into which the current request is to be dispatched. If <span class="define">NULL</span>, the main tree will be used.<p>
The <b class="fname">sysctl_locate</b>() function scans a tree for the node most specific to a request. If the pointer referenced by <i class="farg">rnode</i> is not <span class="define">NULL</span>, the tree indicated is searched, otherwise the main tree will be used. The address of the most relevant node will be returned via <i class="farg">rnode</i> and the number of MIB entries consumed will be returned via <i class="farg">nip</i>, if it is not <span class="define">NULL</span>.<p>
The <b class="fname">sysctl_lookup</b>() function takes the same arguments as <b class="fname">sysctl_dispatch</b>() with the caveat that the value for <i class="farg">namelen</i> must be zero in order to indicate that the node referenced by the <i class="farg">rnode</i> argument is the one to which the lookup is being applied.</div>
<div class="section">
<h1 id="x4352454154494f4e20414e44204445535452554354494f4e204f46204e4f444553">CREATION AND DESTRUCTION OF NODES</h1> New nodes are created and destroyed by the <b class="fname">sysctl_create</b>() and <b class="fname">sysctl_destroy</b>() functions. These functions take the same arguments as <b class="fname">sysctl_dispatch</b>() with the additional requirement that the <i class="farg">namelen</i> argument must be 1 and the <i class="farg">name</i> argument must point to an integer valued either <span class="define">CTL_CREATE</span> or <span class="define">CTL_CREATESYM</span> when creating a new node, or <span class="define">CTL_DESTROY</span> when destroying a node.<p>
The <i class="farg">newp</i> and <i class="farg">newlen</i> arguments should point to a copy of the node to be created or destroyed. If the create or destroy operation was successful, a copy of the node created or destroyed will be placed in the space indicated by <i class="farg">oldp</i> and <i class="farg">oldlenp</i>. If the create operation fails because of a conflict with an existing node, a copy of that node will be returned instead.<p>
In order to facilitate the creation and destruction of nodes from a given tree by kernel subsystems, the functions <b class="fname">sysctl_createv</b>() and <b class="fname">sysctl_destroyv</b>() are provided. These functions take care of the overhead of filling in the contents of the create or destroy request, dealing with locking, locating the appropriate parent node, etc.<p>
The arguments to <b class="fname">sysctl_createv</b>() are used to construct the new node. If the <i class="farg">log</i> argument is not <span class="define">NULL</span>, a <span class="emph">sysctllog</span> structure will be allocated and the pointer referenced will be changed to address it. The same log may be used for any number of nodes, provided they are all inserted into the same tree. This allows for a series of nodes to be created and later removed from the tree in a single transaction (via <b class="fname">sysctl_teardown</b>()) without the need for any record keeping on the caller's part.<p>
The <i class="farg">cflags</i> argument is currently unused and must be zero. The <i class="farg">rnode</i> argument must either be <span class="define">NULL</span> or a valid pointer to a reference to the root of the tree into which the new node must be placed. If it is <span class="define">NULL</span>, the main tree will be used. It is illegal for <i class="farg">rnode</i> to refer to a <span class="define">NULL</span> pointer. If the <i class="farg">cnode</i> argument is not <span class="define">NULL</span>, on return it will be adjusted to point to the address of the new node.<p>
The <i class="farg">flags</i> and <i class="farg">type</i> arguments are combined into the <i class="farg">sysctl_flags</i> field, and the current value for <span class="define">SYSCTL_VERSION</span> is added in. The following types are defined:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">CTLTYPE_NODE</span></dt>
<dd class="list-tag" style="margin-left: 22.00ex;">
A node intended to be a parent for other nodes.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">CTLTYPE_INT</span></dt>
<dd class="list-tag" style="margin-left: 22.00ex;">
A signed integer.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">CTLTYPE_STRING</span></dt>
<dd class="list-tag" style="margin-left: 22.00ex;">
A NUL-terminated string.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">CTLTYPE_QUAD</span></dt>
<dd class="list-tag" style="margin-left: 22.00ex;">
An unsigned 64-bit integer.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">CTLTYPE_STRUCT</span></dt>
<dd class="list-tag" style="margin-left: 22.00ex;">
A structure.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">CTLTYPE_BOOL</span></dt>
<dd class="list-tag" style="margin-left: 22.00ex;">
A boolean.</dd>
</dl>
<p>
The <i class="farg">namep</i> argument is copied into the <i class="farg">sysctl_name</i> field and must be less than <span class="define">SYSCTL_NAMELEN</span> characters in length. The string indicated by <i class="farg">desc</i> will be copied if the <span class="define">CTLFLAG_OWNDESC</span> flag is set, and will be used as the node's description.<p>
Two additional remarks:<ol style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-enum">
<li class="list-enum" style="margin-top: 1.00em;">
The <span class="define">CTLFLAG_PERMANENT</span> flag can only be set from SYSCTL setup routines (see <i class="link-sec"><a class="link-sec" href="#x53455455502046554e4354494f4e53">SETUP FUNCTIONS</a></i>) as called by <b class="fname">sysctl_init</b>().</li>
<li class="list-enum" style="margin-top: 1.00em;">
If <b class="fname">sysctl_destroyv</b>() attempts to delete a node that does not own its own description (and is not marked as permanent), but the deletion fails, the description will be copied and <b class="fname">sysctl_destroyv</b>() will set the <span class="define">CTLFLAG_OWNDESC</span> flag.</li>
</ol>
<p>
The <i class="farg">func</i> argument is the name of a &#8220;helper&#8221; function (see <i class="link-sec"><a class="link-sec" href="#x48454c5045522046554e4354494f4e5320414e44204d4143524f53">HELPER FUNCTIONS AND MACROS</a></i>). If the <span class="define">CTLFLAG_IMMEDIATE</span> flag is set, the <i class="farg">qv</i> argument will be interpreted as the initial value for the new &#8220;bool&#8221;, &#8220;int&#8221; or &#8220;quad&#8221; node. This flag does not apply to any other type of node. The <i class="farg">newp</i> and <i class="farg">newlen</i> arguments describe the data external to SYSCTL that is to be instrumented. One of <i class="farg">func</i>, <i class="farg">qv</i> and the <span class="define">CTLFLAG_IMMEDIATE</span> flag, or <i class="farg">newp</i> and <i class="farg">newlen</i> must be given for nodes that instrument data, otherwise an error is returned.<p>
The remaining arguments are a list of integers specifying the path through the MIB to the node being created. The list must be terminated by the <span class="define">CTL_EOL</span> value. The penultimate value in the list may be <span class="define">CTL_CREATE</span> if a dynamic MIB entry is to be made for this node. <b class="fname">sysctl_createv</b>() specifically does not support <span class="define">CTL_CREATESYM</span>, since setup routines are expected to be able to use the in-kernel <a class="link-man" href="../4/ksyms">ksyms(4)</a> interface to discover the location of the data to be instrumented. If the node to be created matches a node that already exists, a return code of 0 is given, indicating success.<p>
When using <b class="fname">sysctl_destroyv</b>() to destroy a given node, the <i class="farg">rnode</i> argument, if not <span class="define">NULL</span>, is taken to be the root of the tree from which the node is to be destroyed, otherwise the main tree is used. The rest of the arguments are a list of integers specifying the path through the MIB to the node being destroyed. If the node being destroyed does not exist, a successful return code is given. Nodes marked with the <span class="define">CTLFLAG_PERMANENT</span> flag cannot be destroyed.</div>
<div class="section">
<h1 id="x48454c5045522046554e4354494f4e5320414e44204d4143524f53">HELPER FUNCTIONS AND MACROS</h1> Helper functions are invoked with the same common argument set as <b class="fname">sysctl_dispatch</b>() except that the <i class="farg">rnode</i> argument will never be <span class="define">NULL</span>. It will be set to point to the node that corresponds most closely to the current request. Helpers are forbidden from modifying the node they are passed; they should instead copy the structure if changes are required in order to effect access control or other checks. The &#8220;helper&#8221; prototype and function that needs to ensure that a newly assigned value is within a certain range (presuming external data) would look like the following:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
static int sysctl_helper(SYSCTLFN_PROTO); 
 
static int 
sysctl_helper(SYSCTLFN_ARGS) 
{ 
	struct sysctlnode node; 
	int t, error; 
 
	t = *(int *)rnode-&gt;sysctl_data; 
 
	node = *rnode; 
	node.sysctl_data = &amp;t; 
	error = sysctl_lookup(SYSCTLFN_CALL(&amp;node)); 
	if (error || newp == NULL) 
		return (error); 
 
	if (t &lt; 0 || t &gt; 20) 
		return (EINVAL); 
 
	*(int *)rnode-&gt;sysctl_data = t; 
	return (0); 
}</pre>
<p>
The use of the <span class="define">SYSCTLFN_PROTO</span>, <span class="define">SYSCTLFN_ARGS, and</span> <span class="define">SYSCTLFN_CALL</span><br>
 macros ensure that all arguments are passed properly. The single argument to the <span class="define">SYSCTLFN_CALL</span> macro is the pointer to the node being examined.<p>
Three basic helper functions are available for use. <b class="fname">sysctl_needfunc</b>() will emit a warning to the system console whenever it is invoked and provides a simplistic read-only interface to the given node. <b class="fname">sysctl_notavail</b>() will forward &#8220;queries&#8221; to <b class="fname">sysctl_query</b>() so that subtrees can be discovered, but will return <span class="errno">EOPNOTSUPP</span> for any other condition. <b class="fname">sysctl_null</b>() specifically ignores any arguments given, sets the value indicated by <i class="farg">oldlenp</i> to zero, and returns success.</div>
<div class="section">
<h1 id="x53455455502046554e4354494f4e53">SETUP FUNCTIONS</h1> Though nodes can be added to the SYSCTL tree at any time, in order to add nodes during the kernel bootstrap phase, a proper &#8220;setup&#8221; function must be used. Setup functions are declared using the <span class="define">SYSCTL_SETUP</span> macro, which takes the name of the function and a short string description of the function as arguments. (See the <span class="define">SYSCTL_DEBUG_SETUP</span> kernel configuration in <a class="link-man" href="../4/options">options(4)</a>.) The address of the function is added to a list of functions that <b class="fname">sysctl_init</b>() traverses during initialization.<p>
Setup functions do not have to add nodes to the main tree, but can set up their own trees for emulation or other purposes. Emulations that require use of a main tree but with some nodes changed to suit their own purposes can arrange to overlay a sparse private tree onto their main tree by making the <i class="farg">e_sysctlovly</i> member of their struct emul definition point to the overlaid tree.<p>
Setup functions should take care to create all nodes from the root down to the subtree they are creating, since the order in which setup functions are called is arbitrary (the order in which setup functions are called is only determined by the ordering of the object files as passed to the linker when the kernel is built).</div>
<div class="section">
<h1 id="x4d495343454c4c414e454f55532046554e4354494f4e53">MISCELLANEOUS FUNCTIONS</h1> <b class="fname">sysctl_init</b>() is called early in the kernel bootstrap process. It initializes the SYSCTL lock, calls all the registered setup functions, and marks the tree as permanent.<p>
<b class="fname">sysctl_free</b>() will unconditionally delete any and all nodes below the given node. Its intended use is for the deletion of entire trees, not subtrees. If a subtree is to be removed, <b class="fname">sysctl_destroy</b>() or <b class="fname">sysctl_destroyv</b>() should be used to ensure that nodes not owned by the sub-system being deactivated are not mistakenly destroyed. The SYSCTL lock must be held when calling this function.<p>
<b class="fname">sysctl_teardown</b>() unwinds a <span class="emph">sysctllog</span> and deletes the nodes in the opposite order in which they were created.<p>
<b class="fname">old_sysctl</b>() provides an interface similar to the old SYSCTL implementation, with the exception that access checks on a per-node basis are performed if the <i class="farg">l</i> argument is non-<span class="define">NULL</span>. If called with a <span class="define">NULL</span> argument, the values for <i class="farg">newp</i> and <i class="farg">oldp</i> are interpreted as kernel addresses, and access is performed as for the superuser.</div>
<div class="section">
<h1 id="x4e4f544553">NOTES</h1> It is expected that nodes will be added to (or removed from) the tree during the following stages of a machine's lifetime:<p>
<ul style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-bul">
<li class="list-bul" style="margin-top: 0.00em;">
initialization -- when the kernel is booting</li>
<li class="list-bul" style="margin-top: 0.00em;">
autoconfiguration -- when devices are being probed at boot time</li>
<li class="list-bul" style="margin-top: 0.00em;">
&#8220;plug and play&#8221; device attachment -- when a PC-Card, USB, or other device is plugged in or attached</li>
<li class="list-bul" style="margin-top: 0.00em;">
module initialization -- when a module is being loaded</li>
<li class="list-bul" style="margin-top: 0.00em;">
&#8220;run-time&#8221; -- when a process creates a node via the <a class="link-man" href="../3/sysctl">sysctl(3)</a> interface</li>
</ul>
<p>
Nodes marked with <span class="define">CTLFLAG_PERMANENT</span> can only be added to a tree during the first or initialization phase, and can never be removed. The initialization phase terminates when the main tree's root is marked with the <span class="define">CTLFLAG_PERMANENT</span> flag. Once the main tree is marked in this manner, no nodes can be added to any tree that is marked with <span class="define">CTLFLAG_READONLY</span> at its root, and no nodes can be added at all if the main tree's root is so marked.<p>
Nodes added by device drivers, modules, and at device insertion time can be added to (and removed from) &#8220;read-only&#8221; parent nodes.<p>
Nodes created by processes can only be added to &#8220;writable&#8221; parent nodes. See <a class="link-man" href="../3/sysctl">sysctl(3)</a> for a description of the flags that are allowed to be used by when creating nodes.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../3/sysctl">sysctl(3)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The dynamic SYSCTL implementation first appeared in <span class="unix">NetBSD&#160;2.0</span>.</div>
<div class="section">
<h1 id="x415554484f5253">AUTHORS</h1> <span class="author">Andrew Brown</span> &#60;atatat@NetBSD.org&#62; designed and implemented the dynamic SYSCTL implementation.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
December 4, 2011</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

