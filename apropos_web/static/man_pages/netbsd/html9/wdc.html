<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
WDC(9)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
WDC(9)</td>
<td class="head-vol" align="center">
Kernel Developer's Manual</td>
<td class="head-rtitle" align="right">
WDC(9)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">wdc</b> &#8212; <span class="desc">machine-independent IDE/ATAPI driver</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">dev/ata/atavar.h</a>&gt;</b><br>
<b class="includes">#include &lt;<a class="link-includes">sys/dev/ic/wdcvar.h</a>&gt;</b><p>
<i class="ftype">int</i><br>
<b class="fname">wdcprobe</b>(<i class="farg" style="white-space:nowrap;">struct channel_softc * chp</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">wdcattach</b>(<i class="farg" style="white-space:nowrap;">struct channel_softc * chp</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <b class="name">wdc</b> driver provides the machine independent core functions for driving IDE devices. IDE devices-specific drivers (<a class="link-man" href="../html4/wd.html">wd(4)</a> or <a class="link-man" href="../html4/atapibus.html">atapibus(4)</a>) will use services provided by <b class="name">wdc</b>.<p>
The machine-dependent bus front-end provides information to <b class="name">wdc</b> with the <b class="var">wdc_softc</b> and <b class="var">channel_softc</b> structures. The first one defines global controller properties, and the second contains per-channel information. <b class="name">wdc</b> returns information about the attached devices in the <b class="var">ata_drive_datas</b> structure.<p>
<pre style="margin-left: 0.00ex;" class="lit display">
struct wdc_softc { /* Per controller state */ 
        struct device sc_dev; 
        int           cap; 
#define WDC_CAPABILITY_DATA16 0x0001 
#define WDC_CAPABILITY_DATA32 0x0002 
#define WDC_CAPABILITY_MODE   0x0004 
#define WDC_CAPABILITY_DMA    0x0008 
#define WDC_CAPABILITY_UDMA   0x0010 
#define WDC_CAPABILITY_HWLOCK 0x0020 
#define WDC_CAPABILITY_ATA_NOSTREAM 0x0040 
#define WDC_CAPABILITY_ATAPI_NOSTREAM 0x0080 
#define WDC_CAPABILITY_NO_EXTRA_RESETS 0x0100 
#define WDC_CAPABILITY_PREATA 0x0200 
#define WDC_CAPABILITY_IRQACK 0x0400 
#define WDC_CAPABILITY_SINGLE_DRIVE 0x0800 
#define WDC_CAPABILITY_NOIRQ  0x1000 
#define WDC_CAPABILITY_SELECT  0x2000 
        uint8_t      pio_mode; 
        uint8_t      dma_mode; 
        int nchannels; 
        struct channel_softc *channels; 
 
        void            *dma_arg; 
        int            (*dma_init)(void *, int, int, void *, size_t, int); 
        void           (*dma_start)(void *, int, int, int); 
        int            (*dma_finish)(void *, int, int, int); 
#define WDC_DMA_READ 0x01 
#define WDC_DMA_POLL 0x02 
 
        int            (*claim_hw)(void *, int); 
        void            (*free_hw)(void *); 
}; 
 
struct channel_softc { /* Per channel data */ 
        int channel; 
        struct wdc_softc *wdc; 
        bus_space_tag_t       cmd_iot; 
        bus_space_handle_t    cmd_ioh; 
        bus_space_tag_t       ctl_iot; 
        bus_space_handle_t    ctl_ioh; 
        bus_space_tag_t       data32iot; 
        bus_space_handle_t    data32ioh; 
        int ch_flags; 
#define WDCF_ACTIVE   0x01 
#define WDCF_IRQ_WAIT 0x10 
        uint8_t ch_status; 
        uint8_t ch_error; 
        struct ata_drive_datas ch_drive[2]; 
        struct channel_queue *ch_queue; 
}; 
 
struct ata_drive_datas { 
    uint8_t drive; 
    uint8_t drive_flags; 
#define DRIVE_ATA   0x01 
#define DRIVE_ATAPI 0x02 
#define DRIVE (DRIVE_ATA|DRIVE_ATAPI) 
#define DRIVE_CAP32 0x04 
#define DRIVE_DMA   0x08 
#define DRIVE_UDMA  0x10 
#define DRIVE_MODE 0x20 
    uint8_t PIO_mode; 
    uint8_t DMA_mode; 
    uint8_t UDMA_mode; 
    uint8_t state; 
 
    struct device *drv_softc; 
    void* chnl_softc; 
};</pre>
<p>
The bus front-end needs to fill in the following elements of <b class="var">wdc_softc</b>:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 4.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
cap</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
supports one or more of the WDC_CAPABILITY flags</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
nchannels</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
number of channels supported by this controller</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
channels</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
array of <b class="var">struct channel_softc</b> of size <b class="var">nchannels</b> properly initialised</dd>
</dl>
The following elements are optional:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 4.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
pio_mode</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
dma_mode</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
dma_arg</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
dma_init</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
dma_start</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
dma_finish</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
claim_hw</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
free_hw</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
</dd>
</dl>
<p>
The <span class="define">WDC_CAPABILITY_DATA16</span> and <span class="define">WDC_CAPABILITY_DATA32</span> flags informs <b class="name">wdc</b> whether the controller supports 16- or 32-bit I/O accesses on the data port. If both are set, a test will be done for each drive using the ATA or ATAPI IDENTIFY command, to automatically select the working mode.<p>
The <span class="define">WDC_CAPABILITY_DMA</span> and <span class="define">WDC_CAPABILITY_UDMA</span> flags are set for controllers supporting the DMA and Ultra-DMA modes. The bus front-end needs to provide the <b class="fname">dma_init</b>(), <b class="fname">dma_start</b>() and <b class="fname">dma_finish</b>() functions. <b class="fname">dma_init</b>() is called just before issuing a DMA command to the IDE device. The arguments are, respectively: <b class="var">dma_arg</b>, the channel number, the drive number on this channel, the virtual address of the DMA buffer, the size of the transfer, and the <span class="define">WDC_DMA</span> flags. <b class="fname">dma_start</b>() is called just after issuing a DMA command to the IDE device. The arguments are, respectively: <b class="var">dma_arg</b>, the channel number, the drive number on this channel, and the <span class="define">WDC_DMA</span> flags. <b class="fname">dma_finish</b>() is called once the transfer is complete. The arguments are, respectively: <b class="var">dma_arg</b>, the channel number, the drive number on this channel, and the <span class="define">WDC_DMA</span> flags. <span class="define">WDC_DMA_READ</span> indicates the direction of the data transfer, and <span class="define">WDC_DMA_POLL</span> indicates if the transfer will use (or used) interrupts.<p>
The <span class="define">WDC_CAPABILITY_MODE</span> flag means that the bus front-end can program the PIO and DMA modes, so <b class="name">wdc</b> needs to provide back the supported modes for each drive, and set the drives modes. The <b class="var">pio_mode</b> and <b class="var">dma_mode</b> needs to be set to the highest PIO and DMA mode supported. If <span class="define">WDC_CAPABILITY_UDMA</span> is set, then <b class="var">dma_mode</b> must be set to the highest Ultra-DMA mode supported. If <span class="define">WDC_CAPABILITY_MODE</span> is not set, <b class="name">wdc</b> will not attempt to change the current drive's settings, assuming the host's firmware has done it right.<p>
The <span class="define">WDC_CAPABILITY_HWLOCK</span> flag is set for controllers needing hardware looking before accessing the I/O ports. If this flag is set, the bus front-end needs to provide the <b class="fname">claim_hw</b>() and <b class="fname">free_hw</b>() functions. <b class="fname">claim_hw</b>() will be called when the driver wants to access the controller ports. The second parameter is set to 1 when it is possible to sleep waiting for the lock, 0 otherwise. It should return 1 when access has been granted, 0 otherwise. When access has not been granted and sleep is not allowed, the bus front-end shall call <b class="fname">wdcrestart</b>() with the first argument passed to <b class="fname">claim_hw</b>() as argument. This arguments will also be the one passed to <b class="fname">free_hw</b>(). This function is called once the transfer is complete, so that the lock can be released.<p>
Accesses to the data port are done by using the bus_space stream functions, unless the <span class="define">WDC_CAPABILITY_ATA_NOSTREAM</span> or <span class="define">WDC_CAPABILITY_ATAPI_NOSTREAM</span> flags are set. This should not be used, unless the data bus is not wired properly (which seems common on big-endian systems), and byte-order needs to be preserved for compatibility with the host's firmware. Also note that the IDE bus is a little-endian bus, so the bus_space functions used for the bus_space tag passed in the <b class="var">channel_softc</b> have to do the appropriate byte-swapping for big-endian systems.<p>
<span class="define">WDC_CAPABILITY_NO_EXTRA_RESETS</span> avoid the controller reset at the end of the disks probe. This reset is needed for some controllers, but causes problems with some others.<p>
<span class="define">WDC_CAPABILITY_NOIRQ</span> tells the driver that this controller doesn't have its interrupt lines wired up usefully, so it should always use polled transfers.<p>
The bus front-end needs to fill in the following elements of <b class="var">channel_softc</b>:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 4.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
channel</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
The channel number on the controller</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
wdc</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
A pointer to the controller's wdc_softc</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
cmd_iot, cmd_ioh</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Bus-space tag and handle for access to the command block registers (which includes the 16-bit data port)</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
ctl_iot, ctl_ioh</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Bus-space tag and handle for access to the control block registers</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
ch_queue</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
A pointer to a <b class="var">struct channel_queue</b>. This will hold the queues of outstanding commands for this controller.</dd>
</dl>
The following elements are optional:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 4.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
data32iot, data32ioh</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Bus-space tag and handle for 32-bit data accesses. Only needed if <span class="define">WDC_CAPABILITY_DATA32</span> is set in the controller's <b class="var">wdc_softc</b>.</dd>
</dl>
<p>
<b class="var">ch_queue</b> can point to a common <b class="var">struct channel_queue</b> if the controller doesn't support concurrent access to its different channels. If all channels are independent, it is recommended that each channel has its own <b class="var">ch_queue</b> (for better performance).<p>
The bus-specific front-end can use the <b class="fname">wdcprobe</b>() function, with a properly initialised <b class="var">struct channel_softc</b> as argument ( <b class="var">wdc</b> can be set to NULL. This allows <b class="fname">wdcprobe</b>() to be easily used in bus front-end probe functions). This function will return an integer where bit 0 will be set if the master device has been found, and 1 if the slave device has been found.<p>
The bus-specific attach function has to call <b class="fname">wdcattach</b>() for each channel, with a pointer to a properly initialised <b class="var">channel softc</b> as argument. This will probe devices attached to the IDE channel and attach them. Once this function returns, the <b class="var">ch_drive</b> array of the <b class="var">channel_softc</b> will contain the drive's capabilities. This can be used to properly initialise the controller's mode, or disable a channel without drives.<p>
The elements of interest in <b class="var">ata_drive_datas</b> for a bus front-end are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 4.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
drive</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
The drive number</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
drive_flags</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Flags indicating the drive capabilities. A null <b class="var">drive_flags</b> indicate either that no drive is here, or that no driver was found for this device.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
PIO_mode, DMA_mode, UDMA_mode</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
the highest supported modes for this drive compatible with the controller's capabilities. Needs to be reset to the mode to use by the drive, if known.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
drv_softc</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
A pointer to the drive's softc. Can be used to print the drive's name.</dd>
</dl>
<p>
<b class="var">drive_flags</b> handles the following flags:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 4.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
DRIVE_ATA, DRIVE_ATAPI</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Gives the drive type, if any. The shortcut DRIVE can be used to just test the presence/absence of a drive.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
DRIVE_CAP32</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
This drive works with 32-bit data I/O.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
DRIVE_DMA</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
This drive supports DMA.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
DRIVE_UDMA</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
This drive supports Ultra-DMA.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
DRIVE_MODE</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
This drive properly reported its PIO and DMA mode.</dd>
</dl>
<p>
Once the controller has been initialised, it has to reset the <span class="define">DRIVE_DMA</span> and <span class="define">DRIVE_UDMA</span>, as well as the values of <b class="var">PIO_mode</b>, <b class="var">DMA_mode</b> and <b class="var">UDMA_mode</b> if the modes to be used are not highest ones supported by the drive.</div>
<div class="section">
<h1 id="x434f4445205245464552454e434553">CODE REFERENCES</h1> The wdc core functions are implemented in <i class="file">sys/dev/ic/wdc.c</i>. Low-level ATA and ATAPI support is provided by <i class="file">sys/dev/ata_wdc.c</i> and <i class="file">sys/dev/scsipi/atapi_wdc.c</i> respectively.<p>
An example of a simple bus front-end can be found in <i class="file">sys/dev/isapnp/wdc_isapnp.c</i>. A more complex one, with multiple channels and bus-master DMA support is <i class="file">sys/dev/pci/pciide.c</i>. <i class="file">sys/arch/atari/dev/wdc_mb.c</i> makes use of hardware locking, and also provides an example of bus-front end for a big-endian system, which needs byte-swapping bus_space functions.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html4/wdc.html">wdc(4)</a>, <a class="link-man" href="../html9/bus_space.html">bus_space(9)</a></div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
April 18, 2010</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

