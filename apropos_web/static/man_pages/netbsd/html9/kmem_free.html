<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="/static/man_pages/netbsd/style.css" type="text/css" media="all">
<title>
KMEM(9)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
KMEM(9)</td>
<td class="head-vol" align="center">
Kernel Developer's Manual</td>
<td class="head-rtitle" align="right">
KMEM(9)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">kmem</b> &#8212; <span class="desc">kernel wired memory allocator</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/kmem.h</a>&gt;</b><p>
<i class="ftype">void *</i><br>
<b class="fname">kmem_alloc</b>(<i class="farg" style="white-space:nowrap;">size_t size</i>, <i class="farg" style="white-space:nowrap;">km_flag_t kmflags</i>);<p>
<i class="ftype">void *</i><br>
<b class="fname">kmem_zalloc</b>(<i class="farg" style="white-space:nowrap;">size_t size</i>, <i class="farg" style="white-space:nowrap;">km_flag_t kmflags</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">kmem_free</b>(<i class="farg" style="white-space:nowrap;">void *p</i>, <i class="farg" style="white-space:nowrap;">size_t size</i>);<p>
<i class="ftype">void *</i><br>
<b class="fname">kmem_intr_alloc</b>(<i class="farg" style="white-space:nowrap;">size_t size</i>, <i class="farg" style="white-space:nowrap;">km_flag_t kmflags</i>);<p>
<i class="ftype">void *</i><br>
<b class="fname">kmem_intr_zalloc</b>(<i class="farg" style="white-space:nowrap;">size_t size</i>, <i class="farg" style="white-space:nowrap;">km_flag_t kmflags</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">kmem_intr_free</b>(<i class="farg" style="white-space:nowrap;">void *p</i>, <i class="farg" style="white-space:nowrap;">size_t size</i>);<p>
<i class="ftype">char *</i><br>
<b class="fname">kmem_asprintf</b>(<i class="farg" style="white-space:nowrap;">const char *fmt</i>, <i class="farg" style="white-space:nowrap;">...</i>);<p>
<br>
<b class="config">options DEBUG</b></div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> <b class="fname">kmem_alloc</b>() allocates kernel wired memory. It takes the following arguments.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">size</i></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Specify the size of allocation in bytes.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">kmflags</i></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Either of the following:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
KM_SLEEP</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
If the allocation cannot be satisfied immediately, sleep until enough memory is available.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
KM_NOSLEEP</dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Don't sleep. Immediately return <span class="define">NULL</span> if there is not enough memory available. It should only be used when failure to allocate will not have harmful, user-visible effects.<p>
<div class="symb" style="display:inline;margin-left: 1.00ex;">
Use of <span class="define">KM_NOSLEEP</span> is strongly discouraged as it can create transient, hard to debug failures that occur when the system is under memory pressure.</div>
<p>
In situations where it is not possible to sleep, for example because locks are held by the caller, the code path should be restructured to allow the allocation to be made in another place.</dd>
</dl>
</dd>
</dl>
<p>
The contents of allocated memory are uninitialized.<p>
Unlike Solaris, kmem_alloc(0, flags) is illegal.<p>
<b class="fname">kmem_zalloc</b>() is the equivalent of <b class="fname">kmem_alloc</b>(), except that it initializes the memory to zero.<p>
<b class="fname">kmem_asprintf</b>() functions as the well known <b class="fname">asprintf</b>() function, but allocates memory using <b class="fname">kmem_alloc</b>(). This routine can sleep during allocation. The size of the allocated area is the length of the returned character string, plus one (for the NUL terminator). This must be taken into consideration when freeing the returned area with <b class="fname">kmem_free</b>().<p>
<b class="fname">kmem_free</b>() frees kernel wired memory allocated by <b class="fname">kmem_alloc</b>() or <b class="fname">kmem_zalloc</b>() so that it can be used for other purposes. It takes the following arguments.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">p</i></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
The pointer to the memory being freed. It must be the one returned by <b class="fname">kmem_alloc</b>() or <b class="fname">kmem_zalloc</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">size</i></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
The size of the memory being freed, in bytes. It must be the same as the <i class="farg">size</i> argument used for <b class="fname">kmem_alloc</b>() or <b class="fname">kmem_zalloc</b>() when the memory was allocated.</dd>
</dl>
<p>
Freeing <span class="define">NULL</span> is illegal.<p>
<b class="fname">kmem_intr_alloc</b>(), <b class="fname">kmem_intr_zalloc</b>() and <b class="fname">kmem_intr_free</b>() are the equivalents of the above kmem routines which can be called from the interrupt context. These routines are for the special cases. Normally, <a class="link-man" href="../9/pool_cache">pool_cache(9)</a> should be used for memory allocation from interrupt context.</div>
<div class="section">
<h1 id="x4e4f544553">NOTES</h1> Making <span class="define">KM_SLEEP</span> allocations while holding mutexes or reader/writer locks is discouraged, as the caller can sleep for an unbounded amount of time in order to satisfy the allocation. This can in turn block other threads that wish to acquire locks held by the caller. It should be noted that <b class="fname">kmem_free</b>() may also block.<p>
For some locks this is permissible or even unavoidable. For others, particularly locks that may be taken from soft interrupt context, it is a serious problem. As a general rule it is better not to allow this type of situation to develop. One way to circumvent the problem is to make allocations speculative and part of a retryable sequence. For example:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
  retry: 
        /* speculative unlocked check */ 
        if (need to allocate) { 
                new_item = kmem_alloc(sizeof(*new_item), KM_SLEEP); 
        } else { 
                new_item = NULL; 
        } 
        mutex_enter(lock); 
        /* check while holding lock for true status */ 
        if (need to allocate) { 
                if (new_item == NULL) { 
                        mutex_exit(lock); 
                        goto retry; 
                } 
                consume(new_item); 
                new_item = NULL; 
        } 
        mutex_exit(lock); 
        if (new_item != NULL) { 
                /* did not use it after all */ 
                kmem_free(new_item, sizeof(*new_item)); 
        }</pre>
</div>
<div class="section">
<h1 id="x4f5054494f4e53">OPTIONS</h1> Kernels compiled with the <span class="define">DEBUG</span> option perform CPU intensive sanity checks on kmem operations, and include the <span class="define">kmguard</span> facility which can be enabled at runtime.<p>
<span class="define">kmguard</span> adds additional, very high overhead runtime verification to kmem operations. To enable it, boot the system with the <b class="flag">&#45;d</b> option, which causes the debugger to be entered early during the kernel boot process. Issue commands such as the following:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
db&gt; w kmem_guard_depth 0t30000 
db&gt; c</pre>
<p>
This instructs <span class="define">kmguard</span> to queue up to 60000 (30000*2) pages of unmapped KVA to catch use-after-free type errors. When <b class="fname">kmem_free</b>() is called, memory backing a freed item is unmapped and the kernel VA space pushed onto a FIFO. The VA space will not be reused until another 30k items have been freed. Until reused the kernel will catch invalid accesses and panic with a page fault. Limitations:<ul style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-bul">
<li class="list-bul" style="margin-top: 1.00em;">
It has a severe impact on performance.</li>
<li class="list-bul" style="margin-top: 1.00em;">
It is best used on a 64-bit machine with lots of RAM.</li>
<li class="list-bul" style="margin-top: 1.00em;">
Allocations larger than PAGE_SIZE bypass the <span class="define">kmguard</span> facility.</li>
</ul>
<p>
kmguard tries to catch the following types of bugs:<ul style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-bul">
<li class="list-bul" style="margin-top: 1.00em;">
Overflow at time of occurrence, by means of a guard page.</li>
<li class="list-bul" style="margin-top: 1.00em;">
Underflow at <b class="fname">kmem_free</b>(), by using a canary value.</li>
<li class="list-bul" style="margin-top: 1.00em;">
Invalid pointer or size passed, at <b class="fname">kmem_free</b>().</li>
</ul>
</div>
<div class="section">
<h1 id="x52455455524e2056414c554553">RETURN VALUES</h1> On success, <b class="fname">kmem_alloc</b>() and <b class="fname">kmem_zalloc</b>() return a pointer to allocated memory. Otherwise, <span class="define">NULL</span> is returned.</div>
<div class="section">
<h1 id="x434f4445205245464552454e434553">CODE REFERENCES</h1> The <b class="name">kmem</b> subsystem is implemented within the file <i class="file">sys/kern/subr_kmem.c</i>.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../9/intro">intro(9)</a>, <a class="link-man" href="../9/memoryallocators">memoryallocators(9)</a>, <a class="link-man" href="../9/percpu">percpu(9)</a>, <a class="link-man" href="../9/pool_cache">pool_cache(9)</a>, <a class="link-man" href="../9/uvm_km">uvm_km(9)</a></div>
<div class="section">
<h1 id="x43415645415453">CAVEATS</h1> Neither <b class="fname">kmem_alloc</b>() nor <b class="fname">kmem_free</b>() can be used from interrupt context, from a soft interrupt, or from a callout. Use <a class="link-man" href="../9/pool_cache">pool_cache(9)</a> in these situations.</div>
<div class="section">
<h1 id="x534543555249545920434f4e53494445524154494f4e53">SECURITY CONSIDERATIONS</h1> As the memory allocated by <b class="fname">kmem_alloc</b>() is uninitialized, it can contain security-sensitive data left by its previous user. It is the caller's responsibility not to expose it to the world.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
November 26, 2013</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

