<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="/static/man_pages/netbsd/style.css" type="text/css" media="all">
<title>
RWLOCK(9)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
RWLOCK(9)</td>
<td class="head-vol" align="center">
Kernel Developer's Manual</td>
<td class="head-rtitle" align="right">
RWLOCK(9)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">rw</b>, <b class="name">rw_init</b>, <b class="name">rw_destroy</b>, <b class="name">rw_enter</b>, <b class="name">rw_exit</b>, <b class="name">rw_tryenter</b>, <b class="name">rw_tryupgrade</b>, <b class="name">rw_downgrade</b>, <b class="name">rw_read_held</b>, <b class="name">rw_write_held</b>, <b class="name">rw_lock_held</b> &#8212; <span class="desc">reader / writer lock primitives</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/rwlock.h</a>&gt;</b><p>
<i class="ftype">void</i><br>
<b class="fname">rw_init</b>(<i class="farg" style="white-space:nowrap;">krwlock_t *rw</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">rw_destroy</b>(<i class="farg" style="white-space:nowrap;">krwlock_t *rw</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">rw_enter</b>(<i class="farg" style="white-space:nowrap;">krwlock_t *rw</i>, <i class="farg" style="white-space:nowrap;">const krw_t op</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">rw_exit</b>(<i class="farg" style="white-space:nowrap;">krwlock_t *rw</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">rw_tryenter</b>(<i class="farg" style="white-space:nowrap;">krwlock_t *rw</i>, <i class="farg" style="white-space:nowrap;">const krw_t op</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">rw_tryupgrade</b>(<i class="farg" style="white-space:nowrap;">krwlock_t *rw</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">rw_downgrade</b>(<i class="farg" style="white-space:nowrap;">krwlock_t *rw</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">rw_read_held</b>(<i class="farg" style="white-space:nowrap;">krwlock_t *rw</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">rw_write_held</b>(<i class="farg" style="white-space:nowrap;">krwlock_t *rw</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">rw_lock_held</b>(<i class="farg" style="white-space:nowrap;">krwlock_t *rw</i>);<p>
<br>
<b class="config">options DIAGNOSTIC</b><br>
<b class="config">options LOCKDEBUG</b></div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> Reader / writer locks (RW locks) are used in the kernel to synchronize access to an object among LWPs (lightweight processes) and soft interrupt handlers.<p>
In addition to the capabilities provided by mutexes, RW locks distinguish between read (shared) and write (exclusive) access.<p>
RW locks are in one of three distinct states at any given time:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">Unlocked</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
The lock is not held.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">Read locked</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
The lock holders intend to read the protected object. Multiple callers may hold a RW lock with &#8220;read intent&#8221; simultaneously.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">Write locked</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
The lock holder intends to update the protected object. Only one caller may hold a RW lock with &#8220;write intent&#8221;.</dd>
</dl>
<p>
The <span class="type">krwlock_t</span> type provides storage for the RW lock object. This should be treated as an opaque object and not examined directly by consumers.<p>
Note that these interfaces must not be used from a hardware interrupt handler.</div>
<div class="section">
<h1 id="x4f5054494f4e5320414e44204d4143524f53">OPTIONS AND MACROS</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="config">options DIANOSTIC</b></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
<p>
Kernels compiled with the <span class="define">DIAGNOSTIC</span> option perform basic sanity checks on RW lock operations.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="config">options LOCKDEBUG</b></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
<p>
Kernels compiled with the <span class="define">LOCKDEBUG</span> option perform potentially CPU intensive sanity checks on RW lock operations.</dd>
</dl>
</div>
<div class="section">
<h1 id="x46554e4354494f4e53">FUNCTIONS</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">rw_init</b>(<i class="farg">rw</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
<p>
Initialize a lock for use. No other operations can be performed on the lock until it has been initialized.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">rw_destroy</b>(<i class="farg">rw</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
<p>
Release resources used by a lock. The lock may not be used after it has been destroyed.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">rw_enter</b>(<i class="farg">rw</i>, <i class="farg">op</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
<p>
If <span class="define">RW_READER</span> is specified as the argument to <i class="farg">op</i>, acquire a read lock. If the lock is write held, the caller will block and not return until the hold is acquired. Callers must not recursively acquire read locks.<p>
If <span class="define">RW_WRITER</span> is specified, acquire a write lock. If the lock is already held, the caller will block and not return until the hold is acquired.<p>
RW locks and other types of locks must always be acquired in a consistent order with respect to each other. Otherwise, the potential for system deadlock exists.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">rw_exit</b>(<i class="farg">rw</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
<p>
Release a lock. The lock must have been previously acquired by the caller.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">rw_tryenter</b>(<i class="farg">rw</i>, <i class="farg">op</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
<p>
Try to acquire a lock, but do not block if the lock is already held. If the lock is acquired successfully, return non-zero. Otherwise, return zero.<p>
Valid arguments to <i class="farg">op</i> are <span class="define">RW_READER</span> or <span class="define">RW_WRITER</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">rw_tryupgrade</b>(<i class="farg">rw</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
<p>
Try to upgrade a lock from one read hold to a write hold. If the lock is upgraded successfully, returns non-zero. Otherwise, returns zero.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">rw_downgrade</b>(<i class="farg">rw</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
<p>
Downgrade a lock from a write hold to a read hold.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">rw_write_held</b>(<i class="farg">rw</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">rw_read_held</b>(<i class="farg">rw</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">rw_lock_held</b>(<i class="farg">rw</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
<p>
Test the lock's condition and return non-zero if the lock is held (potentially by the current LWP) and matches the specified condition. Otherwise, return zero.<p>
These functions must never be used to make locking decisions at run time: they are provided only for diagnostic purposes.</dd>
</dl>
</div>
<div class="section">
<h1 id="x504552464f524d414e434520434f4e53494445524154494f4e53">PERFORMANCE CONSIDERATIONS</h1> RW locks are subject to high cache contention on multiprocessor systems, and scale poorly when the write:read ratio is not strongly in favour of readers. Ideally, RW locks should only be used in settings when the following three conditions are met:<ul style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-bul">
<li class="list-bul" style="margin-top: 1.00em;">
The data object(s) protected by the RW lock are read much more frequently than written.</li>
<li class="list-bul" style="margin-top: 1.00em;">
The read-side hold time for the RW lock is long (in the order of thousands of processor clock cycles).</li>
<li class="list-bul" style="margin-top: 1.00em;">
Strong synchronization semantics are required: there is no scope for lockless, lazy or optimistic synchronization.</li>
</ul>
<p>
Generally speaking, it is better to organise code paths and/or data flows such that fewer and weaker synchronization points are required to ensure correct operation.</div>
<div class="section">
<h1 id="x434f4445205245464552454e434553">CODE REFERENCES</h1> The core of the RW lock implementation is in <i class="file">sys/kern/kern_rwlock.c</i>.<p>
The header file <i class="file">sys/sys/rwlock.h</i> describes the public interface, and interfaces that machine-dependent code must provide to support RW locks.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../8/lockstat">lockstat(8)</a>, <a class="link-man" href="../9/condvar">condvar(9)</a>, <a class="link-man" href="../9/mb">mb(9)</a>, <a class="link-man" href="../9/mutex">mutex(9)</a><p>
<span class="ref"><span class="ref-auth">Jim Mauro</span> and <span class="ref-auth">Richard McDougall</span>, <span class="ref-title">Solaris Internals: Core Kernel Architecture</span>, <i class="ref-issue">Prentice Hall</i>, <span class="ref-date">2001</span>, <span class="ref-opt">ISBN 0-13-022496-0</span>.</span></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The RW lock primitives first appeared in <span class="unix">NetBSD&#160;5.0</span>.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
November 22, 2009</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

