<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="/static/man_pages/netbsd/style.css" type="text/css" media="all">
<title>
EXTENT(9)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
EXTENT(9)</td>
<td class="head-vol" align="center">
Kernel Developer's Manual</td>
<td class="head-rtitle" align="right">
EXTENT(9)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">extent</b>, <b class="name">extent_create</b>, <b class="name">extent_destroy</b>, <b class="name">extent_alloc</b>, <b class="name">extent_alloc_subregion</b>, <b class="name">extent_alloc_region</b>, <b class="name">extent_free</b>, <b class="name">extent_print</b> &#8212; <span class="desc">general purpose extent manager</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/malloc.h</a>&gt;</b><br>
<b class="includes">#include &lt;<a class="link-includes">sys/extent.h</a>&gt;</b><p>
<i class="ftype">struct extent *</i><br>
<b class="fname">extent_create</b>(<i class="farg" style="white-space:nowrap;">char *name</i>, <i class="farg" style="white-space:nowrap;">u_long start</i>, <i class="farg" style="white-space:nowrap;">u_long end</i>, <i class="farg" style="white-space:nowrap;">void *storage</i>, <i class="farg" style="white-space:nowrap;">size_t storagesize</i>, <i class="farg" style="white-space:nowrap;">int flags</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">extent_destroy</b>(<i class="farg" style="white-space:nowrap;">struct extent *ex</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">extent_alloc</b>(<i class="farg" style="white-space:nowrap;">struct extent *ex</i>, <i class="farg" style="white-space:nowrap;">u_long size</i>, <i class="farg" style="white-space:nowrap;">u_long alignment</i>, <i class="farg" style="white-space:nowrap;">u_long boundary</i>, <i class="farg" style="white-space:nowrap;">int flags</i>, <i class="farg" style="white-space:nowrap;">u_long *result</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">extent_alloc_subregion</b>(<i class="farg" style="white-space:nowrap;">struct extent *ex</i>, <i class="farg" style="white-space:nowrap;">u_long substart</i>, <i class="farg" style="white-space:nowrap;">u_long subend</i>, <i class="farg" style="white-space:nowrap;">u_long size</i>, <i class="farg" style="white-space:nowrap;">u_long alignment</i>, <i class="farg" style="white-space:nowrap;">u_long boundary</i>, <i class="farg" style="white-space:nowrap;">u_long flags</i>, <i class="farg" style="white-space:nowrap;">u_long *result</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">extent_alloc1</b>(<i class="farg" style="white-space:nowrap;">struct extent *ex</i>, <i class="farg" style="white-space:nowrap;">u_long size</i>, <i class="farg" style="white-space:nowrap;">u_long alignment</i>, <i class="farg" style="white-space:nowrap;">u_long skew</i>, <i class="farg" style="white-space:nowrap;">u_long boundary</i>, <i class="farg" style="white-space:nowrap;">int flags</i>, <i class="farg" style="white-space:nowrap;">u_long *result</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">extent_alloc_subregion1</b>(<i class="farg">struct extent *ex</i>, <i class="farg">u_long substart</i>, <i class="farg">u_long subend</i>, <i class="farg">u_long size</i>, <i class="farg">u_long alignment</i>, <i class="farg">u_long skew</i>, <i class="farg">u_long boundary</i>, <i class="farg">u_long flags</i>, <i class="farg">u_long *result</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">extent_alloc_region</b>(<i class="farg" style="white-space:nowrap;">struct extent *ex</i>, <i class="farg" style="white-space:nowrap;">u_long start</i>, <i class="farg" style="white-space:nowrap;">u_long size</i>, <i class="farg" style="white-space:nowrap;">int flags</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">extent_free</b>(<i class="farg" style="white-space:nowrap;">struct extent *ex</i>, <i class="farg" style="white-space:nowrap;">u_long start</i>, <i class="farg" style="white-space:nowrap;">u_long size</i>, <i class="farg" style="white-space:nowrap;">int flags</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">extent_print</b>(<i class="farg" style="white-space:nowrap;">struct extent *ex</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <span class="unix">NetBSD</span> extent manager provides management of areas of memory or other number spaces (such as I/O ports). An opaque structure called an <b class="name">extent map</b> keeps track of allocated regions within the number space.<p>
<b class="fname">extent_create</b>() creates an extent map managing the space from <i class="farg">start</i> to <i class="farg">end</i> inclusive. The extent map will have the name <i class="farg">name</i>, used for identification in case of an error. If the flag <span class="define">EX_NOCOALESCE</span> is specified, only entire regions may be freed within the extent map, but internal coalescing of regions is disabled so that <b class="fname">extent_free</b>() will never have to allocate a region descriptor and therefore will never fail. The caller must specify one of the flags <span class="define">EX_NOWAIT</span> or <span class="define">EX_WAITOK</span>, specifying whether it is okay to wait for memory allocated for extent map overhead.<p>
There are some applications which may want to use an extent map but can't use <b class="fname">malloc</b>() and <b class="fname">free</b>(). These applications may provide pre-allocated storage for all descriptor overhead with the arguments <i class="farg">storage</i> and <i class="farg">storagesize</i>. An extent of this type is called a <b class="name">fixed extent</b>. If the application can safely use <b class="fname">malloc</b>() and <b class="fname">free</b>(), <i class="farg">storage</i> should be <span class="define">NULL</span>. A fixed extent has a fixed number of region descriptors, so care should be taken to provide enough storage for them; alternatively, the flag <span class="define">EX_MALLOCOK</span> may be passed to allocation requests to indicate that a fixed extent map may be extended using a call to <b class="fname">malloc</b>().<p>
<b class="fname">extent_destroy</b>() destroys the extent map <i class="farg">ex</i>, freeing all allocated regions. If the extent is not a fixed extent, the region and internal extent descriptors themselves are freed. This function always succeeds.<p>
<b class="fname">extent_alloc</b>() allocates a region in extent <i class="farg">ex</i> of size <i class="farg">size</i> that fits the provided parameters. There are two distinct allocation policies, which are selected by the <i class="farg">flags</i> argument:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">EX_FAST</span></dt>
<dd class="list-tag" style="margin-left: 9.00ex;">
Allocate the first region that fits the provided parameters, regardless of resulting extent fragmentation.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
default</dt>
<dd class="list-tag" style="margin-left: 9.00ex;">
Allocate the smallest region that is capable of holding the request, thus minimizing fragmentation of the extent.</dd>
</dl>
<p>
The caller must specify if waiting for space in the extent is allowed using the flag <span class="define">EX_WAITSPACE</span>. If <span class="define">EX_WAITSPACE</span> is not specified, the allocation will fail if the request can not be satisfied without sleeping. The caller must also specify, using the <span class="define">EX_NOWAIT</span> or <span class="define">EX_WAITOK</span> flags, if waiting for overhead allocation is allowed. The request will be aligned to <i class="farg">alignment</i> boundaries. Alignment values must be a power of 2. If no alignment is necessary, the value 1 should be specified. If <i class="farg">boundary</i> is nonzero, the allocated region will not cross any of the numbers which are a multiple of <i class="farg">boundary</i>. If the caller specifies the <span class="define">EX_BOUNDZERO</span> flag, the boundary lines begin at zero. Otherwise, the boundary lines begin at the beginning of the extent. The allocated region may begin on a boundary address, but the end of the region will not touch nor cross it. A boundary argument smaller than the size of the request is invalid. Upon successful completion, <i class="farg">*result</i> will contain the start of the allocated region.<p>
<b class="fname">extent_alloc_subregion</b>() is similar to <b class="fname">extent_alloc</b>(), but it allows the caller to specify that the allocated region must fall within the subregion from <i class="farg">substart</i> to <i class="farg">subend</i> inclusive. The other arguments and the return values of <b class="fname">extent_alloc_subregion</b>() are otherwise the same as those of <b class="fname">extent_alloc</b>().<p>
<b class="fname">extent_alloc_region</b>() allocates the specific region in the extent map <i class="farg">ex</i> beginning at <i class="farg">start</i> with the size <i class="farg">size</i>. The caller must specify whether it is okay to wait for the indicated region to be free using the flag <span class="define">EX_WAITSPACE</span>. If <span class="define">EX_WAITSPACE</span> is not specified, the allocation will fail if the request can not be satisfied without sleeping. The caller must also specify, using the <span class="define">EX_NOWAIT</span> or <span class="define">EX_WAITOK</span> flags, if waiting for overhead allocation is allowed.<p>
The <b class="fname">extent_alloc1</b>() and <b class="fname">extent_alloc_subregion1</b>() functions are extensions that take one additional argument, <i class="farg">skew</i>, that modifies the requested alignment result in the following way: the value (<i class="farg">result</i> - <i class="farg">skew</i>) is aligned to <i class="farg">alignment</i> boundaries. <i class="farg">skew</i> must be a smaller number than <i class="farg">alignment</i>. Also, a boundary argument smaller than the sum of the requested skew and the size of the request is invalid.<p>
<b class="fname">extent_free</b>() frees a region of <i class="farg">size</i> bytes in extent <i class="farg">ex</i> starting at <i class="farg">start</i>. If the extent has the <span class="define">EX_NOCOALESCE</span> property, only entire regions may be freed. If the extent has the <span class="define">EX_NOCOALESCE</span> property and the caller attempts to free a partial region, behavior is undefined. The caller must specify one of the flags <span class="define">EX_NOWAIT</span> or <span class="define">EX_WAITOK</span> to specify whether waiting for memory is okay; these flags have meaning in the event that allocation of a region descriptor is required during the freeing process. This situation occurs only when a partial region that begins and ends in the middle of another region is freed. Behavior is undefined if invalid arguments are provided.<p>
<b class="fname">extent_print</b>() Print out information about extent <i class="farg">ex</i>. This function always succeeds. Behavior is undefined if invalid arguments are provided.</div>
<div class="section">
<h1 id="x4c4f434b494e47">LOCKING</h1> The extent manager performs all necessary locking on the extent map itself, and any other data structures internal to the extent manager. The locks used by the extent manager are simplelocks, and will never sleep (see <a class="link-man" href="../9/lock">lock(9)</a>). This should be taken into account when designing the locking protocol for users of the extent manager.</div>
<div class="section">
<h1 id="x52455455524e2056414c554553">RETURN VALUES</h1> The behavior of all extent manager functions is undefined if given invalid arguments. <b class="fname">extent_create</b>() returns the extent map on success, or <span class="define">NULL</span> if it fails to allocate storage for the extent map. It always succeeds when creating a fixed extent or when given the flag <span class="define">EX_WAITOK</span>. <b class="fname">extent_alloc</b>(), <b class="fname">extent_alloc_region</b>(), <b class="fname">extent_alloc_subregion</b>(), and <b class="fname">extent_free</b>() return one of the following values:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">0</span></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
Operation was successful.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">ENOMEM</span></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
If <span class="define">EX_NOWAIT</span> is specified, the extent manager was not able to allocate a region descriptor for the new region or to split a region when freeing a partial region.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">EAGAIN</span></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
Requested region is not available and <span class="define">EX_WAITSPACE</span> was not specified.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">EINTR</span></dt>
<dd class="list-tag" style="margin-left: 8.00ex;">
Process received a signal while waiting for the requested region to become available in the extent. Does not apply to <b class="fname">extent_free</b>().</dd>
</dl>
</div>
<div class="section">
<h1 id="x4558414d504c4553">EXAMPLES</h1> Here is an example of a (useless) function that uses several of the extent manager routines.<p>
<pre style="margin-left: 0.00ex;" class="lit display">
void 
func() 
{ 
	struct extent *foo_ex; 
	u_long region_start; 
	int error; 
 
	/* 
	 * Extent "foo" manages a 256k region starting at 0x0 and 
	 * only allows complete regions to be freed so that 
	 * extent_free() never needs to allocate memory. 
	 */ 
	foo_ex = extent_create("foo", 0x0, 0x3ffff, M_DEVBUF, 
	    NULL, 0, EX_WAITOK | EX_NOCOALESCE); 
 
	/* 
	 * Allocate an 8k region, aligned to a 4k boundary, which 
	 * does not cross any of the 3 64k boundaries (at 64k, 
	 * 128k, and 192k) within the extent. 
	 */ 
	error = extent_alloc(foo_ex, 0x2000, 0x1000, 0x10000, 
	    EX_NOWAIT, &amp;region_start); 
	if (error) 
		panic("you lose"); 
 
	/* 
	 * Give up the extent. 
	 */ 
	extent_destroy(foo_ex); 
}</pre>
</div>
<div class="section">
<h1 id="x434f4445205245464552454e434553">CODE REFERENCES</h1> The extent manager itself is implemented within the file <i class="file">sys/kern/subr_extent.c</i>. Function prototypes for the framework are located in <i class="file">sys/sys/extent.h</i>.<p>
The i386 bus management code uses the extent manager for managing I/O ports and I/O memory. This code is in the file <i class="file">sys/arch/i386/i386/machdep.c</i>.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../9/malloc">malloc(9)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The <span class="unix">NetBSD</span> extent manager appeared in <span class="unix">NetBSD&#160;1.3</span>.</div>
<div class="section">
<h1 id="x415554484f5253">AUTHORS</h1> The <span class="unix">NetBSD</span> extent manager was architected and implemented by <span class="author">Jason R. Thorpe</span> &#60;thorpej@NetBSD.org&#62;. <span class="author">Matthias Drochner</span> &#60;drochner@zelux6.zel.kfa-juelich.de&#62; contributed to the initial testing and optimization of the implementation. <span class="author">Chris Demetriou</span> &#60;cgd@NetBSD.org&#62; contributed many architectural suggestions.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
July 14, 2012</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

