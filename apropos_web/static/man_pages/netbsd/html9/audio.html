<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/../4/strict.dtd">
>
<head>
<meta http-equiv="Content-Type" content="te../; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
AUDIO(9)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
AUDIO(9)</td>
<td class="head-vol" align="center">
Kernel Developer's Manual</td>
<td class="head-rtitle" align="right">
AUDIO(9)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">audio</b> &#8212; <span class="desc">interface between low and high level audio drivers</span></div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The audio device driver is divided into a high level, hardware independent layer, and a low level hardware dependent layer. The interface between these is the <b class="var">audio_hw_if</b> structure.<p>
<pre style="margin-left: 0.00ex;" class="lit display">
struct audio_hw_if { 
	int	(*open)(void *, int); 
	void	(*close)(void *); 
	int	(*drain)(void *); 
 
	int	(*query_encoding)(void *, struct audio_encoding *); 
	int	(*set_params)(void *, int, int, 
		    audio_params_t *, audio_params_t *, 
		    stream_filter_list_t *, stream_filter_list_t *); 
	int	(*round_blocksize)(void *, int, int, const audio_params_t *); 
 
	int	(*commit_settings)(void *); 
 
	int	(*init_output)(void *, void *, int); 
	int	(*init_input)(void *, void *, int); 
	int	(*start_output)(void *, void *, int, void (*)(void *), 
	            void *); 
	int	(*start_input)(void *, void *, int, void (*)(void *), 
		    void *); 
	int	(*halt_output)(void *); 
	int	(*halt_input)(void *); 
 
	int	(*speaker_ctl)(void *, int); 
#define SPKR_ON  1 
#define SPKR_OFF 0 
 
	int	(*getdev)(void *, struct audio_device *); 
	int	(*setfd)(void *, int); 
 
	int	(*set_port)(void *, mixer_ctrl_t *); 
	int	(*get_port)(void *, mixer_ctrl_t *); 
 
	int	(*query_devinfo)(void *, mixer_devinfo_t *); 
 
	void	*(*allocm)(void *, int, size_t, struct malloc_type *, int); 
	void	(*freem)(void *, void *, struct malloc_type *); 
	size_t	(*round_buffersize)(void *, int, size_t); 
	paddr_t	(*mappage)(void *, void *, off_t, int); 
 
	int 	(*get_props)(void *); 
 
	int	(*trigger_output)(void *, void *, void *, int, 
		    void (*)(void *), void *, const audio_params_t *); 
	int	(*trigger_input)(void *, void *, void *, int, 
		    void (*)(void *), void *, const audio_params_t *); 
	int	(*dev_ioctl)(void *, u_long, void *, int, struct lwp *); 
	void	(*get_locks)(void *, kmutex_t **, kmutex_t **); 
}; 
 
typedef struct audio_params { 
	u_int	sample_rate;	/* sample rate */ 
	u_int	encoding;	/* e.g. mu-law, linear, etc */ 
	u_int	precision;	/* bits/subframe */ 
	u_int	validbits;	/* valid bits in a subframe */ 
	u_int	channels;	/* mono(1), stereo(2) */ 
} audio_params_t;</pre>
<p>
The high level audio driver attaches to the low level driver when the latter calls <b class="var">audio_attach_mi</b>. This call should be<p>
<pre style="margin-left: 0.00ex;" class="lit display">
    void 
    audio_attach_mi(ahwp, hdl, dev) 
	struct audio_hw_if *ahwp; 
	void *hdl; 
	struct device *dev;</pre>
<p>
The <b class="var">audio_hw_if</b> struct is as shown above. The <b class="var">hdl</b> argument is a handle to some low level data structure. It is sent as the first argument to all the functions in <b class="var">audio_hw_if</b> when the high level driver calls them. <b class="var">dev</b> is the device struct for the hardware device.<p>
The upper layer of the audio driver allocates one buffer for playing and one for recording. It handles the buffering of data from the user processes in these. The data is presented to the lower level in smaller chunks, called blocks. If, during playback, there is no data available from the user process when the hardware request another block a block of silence will be used instead. Furthermore, if the user process does not read data quickly enough during recording data will be thrown away.<p>
The fields of <b class="var">audio_hw_if</b> are described in some more detail below. Some fields are optional and can be set to 0 if not needed.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">int open(void *hdl, int flags)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
optional, is called when the audio device is opened. It should initialize the hardware for I/O. Every successful call to <b class="var">open</b> is matched by a call to <b class="var">close</b>. Return 0 on success, otherwise an error code.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">void close(void *hdl)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
optional, is called when the audio device is closed.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">int drain(void *hdl)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
optional, is called before the device is closed or when <span class="define">AUDIO_DRAIN</span> is called. It should make sure that no samples remain in to be played that could be lost when <b class="var">close</b> is called. Return 0 on success, otherwise an error code.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">int query_encoding(void *hdl, struct audio_encoding *ae)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
is used when <span class="define">AUDIO_GETENC</span> is called. It should fill the <b class="var">audio_encoding</b> structure and return 0 or, if there is no encoding with the given number, return EINVAL.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">int set_params(void *hdl, int setmode, int usemode,</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<span class="define">audio_params_t *play, audio_params_t *rec,</span><p>
<span class="define">stream_filter_list_t *pfil, stream_filter_list_t *rfil)</span><p>
Called to set the audio encoding mode. <b class="var">setmode</b> is a combination of the <span class="define">AUMODE_RECORD</span> and <span class="define">AUMODE_PLAY</span> flags to indicate which mode(s) are to be set. <b class="var">usemode</b> is also a combination of these flags, but indicates the current mode of the device (i.e., the value of <b class="var">mode</b> in the <b class="var">audio_info</b> struct).<p>
The <b class="var">play</b> and <b class="var">rec</b> structures contain the encoding parameters that should be set. The values of the structures may also be modified if the hardware cannot be set to exactly the requested mode (e.g., if the requested sampling rate is not supported, but one close enough is).<p>
If the hardware requires software assistance with some encoding (e.g., it might be lacking mu-law support) it should fill the <b class="var">pfil</b> for playing or <b class="var">rfil</b> for recording with conversion information. For example, if <b class="var">play</b> requests [8000Hz, mu-law, 8/8bit, 1ch] and the hardware does not support 8bit mu-law, but 16bit slinear_le, the driver should call <span class="define">pfil-&gt;append()</span> with <b class="var">pfil</b>, <b class="var">mulaw_to_linear16</b>, and audio_params_t representing [8000Hz, slinear_le, 16/16bit, 2ch]. If the driver needs multiple conversions, a conversion nearest to the hardware should be set to the head of <b class="var">pfil</b> or <b class="var">rfil</b>. The definition of <span class="define">stream_filter_list_t</span> follows:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
typedef struct stream_filter_list { 
	void (*append)(struct stream_filter_list *, 
		       stream_filter_factory_t, 
		       const audio_params_t *); 
	void (*prepend)(struct stream_filter_list *, 
			stream_filter_factory_t, 
			const audio_params_t *); 
	void (*set)(struct stream_filter_list *, int, 
		    stream_filter_factory_t, 
		    const audio_params_t *); 
	int req_size; 
	struct stream_filter_req { 
		stream_filter_factory_t *factory; 
		audio_params_t param; /* from-param for recording, 
					 to-param for playing */ 
	} filters[AUDIO_MAX_FILTERS]; 
} stream_filter_list_t;</pre>
<p>
For playing, <b class="var">pfil</b> constructs conversions as follows:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
	(play) == write(2) input 
	  |	pfil-&gt;filters[pfil-&gt;req_size-1].factory 
	(pfil-&gt;filters[pfil-&gt;req_size-1].param) 
	  |	pfil-&gt;filters[pfil-&gt;req_size-2].factory 
	  : 
	  |	pfil-&gt;filters[1].factory 
	(pfil-&gt;filters[1].param) 
	  |	pfil-&gt;filters[0].factory 
	(pfil-&gt;filters[0].param)  == hardware input</pre>
<p>
For recording, <b class="var">rfil</b> constructs conversions as follows:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
	(rfil-&gt;filters[0].param) == hardware output 
	  |	rfil-&gt;filters[0].factory 
	(rfil-&gt;filters[1].param) 
	  |	rfil-&gt;filters[1].factory 
	  : 
	  |	rfil-&gt;filters[rfil-&gt;req_size-2].factory 
	(rfil-&gt;filters[rfil-&gt;req_size-1].param) 
	  |	rfil-&gt;filters[rfil-&gt;req_size-1].factory 
	(rec)  == read(2) output</pre>
<p>
If the device does not have the <span class="define">AUDIO_PROP_INDEPENDENT</span> property the same value is passed in both <b class="var">play</b> and <b class="var">rec</b> and the encoding parameters from <b class="var">play</b> is copied into <b class="var">rec</b> after the call to <b class="var">set_params</b>. Return 0 on success, otherwise an error code.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">int round_blocksize(void *hdl, int bs, int mode,</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<span class="define">const audio_params_t *param)</span><p>
optional, is called with the block size, <b class="var">bs</b>, that has been computed by the upper layer, <b class="var">mode</b>, <span class="define">AUMODE_PLAY</span> or <span class="define">AUMODE_RECORD</span>, and <b class="var">param</b>, encoding parameters for the hardware. It should return a block size, possibly changed according to the needs of the hardware driver.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">int commit_settings(void *hdl)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
optional, is called after all calls to <b class="var">set_params</b>, and <b class="var">set_port</b>, are done. A hardware driver that needs to get the hardware in and out of command mode for each change can save all the changes during previous calls and do them all here. Return 0 on success, otherwise an error code.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">int init_output(void *hdl, void *buffer, int size)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
optional, is called before any output starts, but when the total <b class="var">size</b> of the output <b class="var">buffer</b> has been determined. It can be used to initialize looping DMA for hardware that needs that. Return 0 on success, otherwise an error code.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">int init_input(void *hdl, void *buffer, int size)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
optional, is called before any input starts, but when the total <b class="var">size</b> of the input <b class="var">buffer</b> has been determined. It can be used to initialize looping DMA for hardware that needs that. Return 0 on success, otherwise an error code.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">int start_output(void *hdl, void *block, int blksize,</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<span class="define">void (*intr)(void*), void *intrarg)</span><p>
is called to start the transfer of <b class="var">blksize</b> bytes from <b class="var">block</b> to the audio hardware. The call should return when the data transfer has been initiated (normally with DMA). When the hardware is ready to accept more samples the function <b class="var">intr</b> should be called with the argument <b class="var">intrarg</b>. Calling <b class="var">intr</b> will normally initiate another call to <b class="var">start_output</b>. Return 0 on success, otherwise an error code.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">int start_input(void *hdl, void *block, int blksize,</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<span class="define">void (*intr)(void*), void *intrarg)</span><p>
is called to start the transfer of <b class="var">blksize</b> bytes to <b class="var">block</b> from the audio hardware. The call should return when the data transfer has been initiated (normally with DMA). When the hardware is ready to deliver more samples the function <b class="var">intr</b> should be called with the argument <b class="var">intrarg</b>. Calling <b class="var">intr</b> will normally initiate another call to <b class="var">start_input</b>. Return 0 on success, otherwise an error code.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">int halt_output(void *hdl)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
is called to abort the output transfer (started by <b class="var">start_output</b>) in progress. Return 0 on success, otherwise an error code.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">int halt_input(void *hdl)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
is called to abort the input transfer (started by <b class="var">start_input</b>) in progress. Return 0 on success, otherwise an error code.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">int speaker_ctl(void *hdl, int on)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
optional, is called when a half duplex device changes between playing and recording. It can, e.g., be used to turn on and off the speaker. Return 0 on success, otherwise an error code.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">int getdev(void *hdl, struct audio_device *ret)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Should fill the <b class="var">audio_device</b> struct with relevant information about the driver. Return 0 on success, otherwise an error code.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">int setfd(void *hdl, int fd)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
optional, is called when <span class="define">AUDIO_SETFD</span> is used, but only if the device has AUDIO_PROP_FULLDUPLEX set. Return 0 on success, otherwise an error code.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">int set_port(void *hdl, mixer_ctrl_t *mc)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
is called in when <span class="define">AUDIO_MIXER_WRITE</span> is used. It should take data from the <b class="var">mixer_ctrl_t</b> struct at set the corresponding mixer values. Return 0 on success, otherwise an error code.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">int get_port(void *hdl, mixer_ctrl_t *mc)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
is called in when <span class="define">AUDIO_MIXER_READ</span> is used. It should fill the <b class="var">mixer_ctrl_t</b> struct. Return 0 on success, otherwise an error code.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">int query_devinfo(void *hdl, mixer_devinfo_t *di)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
is called in when <span class="define">AUDIO_MIXER_DEVINFO</span> is used. It should fill the <b class="var">mixer_devinfo_t</b> struct. Return 0 on success, otherwise an error code.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">void *allocm(void *hdl, int direction, size_t size, struct malloc_type *type, int flags)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<p>
optional, is called to allocate the device buffers. If not present <a class="link-man" href="../9/malloc">malloc(9)</a> is used instead (with the same arguments but the first two). The reason for using a device dependent routine instead of <a class="link-man" href="../9/malloc">malloc(9)</a> is that some buses need special allocation to do DMA. Returns the address of the buffer, or 0 on failure.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">void freem(void *hdl, void *addr, struct malloc_type *type)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
optional, is called to free memory allocated by <b class="var">alloc</b>. If not supplied <a class="link-man" href="../9/free">free(9)</a> is used.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">size_t round_buffersize(void *hdl, int direction, size_t bufsize)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
optional, is called at startup to determine the audio buffer size. The upper layer supplies the suggested size in <b class="var">bufsize</b>, which the hardware driver can then change if needed. E.g., DMA on the ISA bus cannot exceed 65536 bytes.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">paddr_t mappage(void *hdl, void *addr, off_t offs, int prot)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<p>
optional, is called for <a class="link-man" href="../2/mmap">mmap(2)</a>. Should return the map value for the page at offset <b class="var">offs</b> from address <b class="var">addr</b> mapped with protection <b class="var">prot</b>. Returns -1 on failure, or a machine dependent opaque value on success.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">int get_props(void *hdl)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Should return the device properties; i.e., a combination of AUDIO_PROP_xxx.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">int trigger_output(void *hdl, void *start, void *end,</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<span class="define">int blksize, void (*intr)(void*), void *intrarg,</span><p>
<span class="define">const audio_params_t *param)</span><p>
optional, is called to start the transfer of data from the circular buffer delimited by <b class="var">start</b> and <b class="var">end</b> to the audio hardware, parameterized as in <b class="var">param</b>. The call should return when the data transfer has been initiated (normally with DMA). When the hardware is finished transferring each <b class="var">blksize</b> sized block, the function <b class="var">intr</b> should be called with the argument <b class="var">intrarg</b> (typically from the audio hardware interrupt service routine). Once started the transfer may be stopped using <b class="var">halt_output</b>. Return 0 on success, otherwise an error code.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">int trigger_input(void *hdl, void *start, void *end,</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<span class="define">int blksize, void (*intr)(void*), void *intrarg,</span><p>
<span class="define">const audio_params_t *param)</span><p>
optional, is called to start the transfer of data from the audio hardware, parameterized as in <b class="var">param</b>, to the circular buffer delimited by <b class="var">start</b> and <b class="var">end</b>. The call should return when the data transfer has been initiated (normally with DMA). When the hardware is finished transferring each <b class="var">blksize</b> sized block, the function <b class="var">intr</b> should be called with the argument <b class="var">intrarg</b> (typically from the audio hardware interrupt service routine). Once started the transfer may be stopped using <b class="var">halt_input</b>. Return 0 on success, otherwise an error code.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">int dev_ioctl(void *hdl, u_long cmd, void *addr,</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<p>
<span class="define">int flag, struct lwp *l)</span><p>
optional, is called when an <a class="link-man" href="../2/ioctl">ioctl(2)</a> is not recognized by the generic audio driver. Return 0 on success, otherwise an error code.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">void get_locks(void *hdl, kmutex_t **intr, kmutex_t **thread)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Returns the interrupt and thread locks to the common audio layer.</dd>
</dl>
<p>
The <b class="var">query_devinfo</b> method should define certain mixer controls for <span class="define">AUDIO_SETINFO</span> to be able to change the port and gain, and <span class="define">AUDIO_GETINFO</span> to read them, as follows.<p>
If the record mixer is capable of input from more than one source, it should define <span class="define">AudioNsource</span> in class <span class="define">AudioCrecord</span>. This mixer control should be of type <span class="define">AUDIO_MIXER_ENUM</span> or <span class="define">AUDIO_MIXER_SET</span> and enumerate the possible input sources. Each of the named sources for which the recording level can be set should have a control in the <span class="define">AudioCrecord</span> class of type <span class="define">AUDIO_MIXER_VALUE</span>, except the &#8220;mixerout&#8221; source is special, and will never have its own control. Its selection signifies, rather, that various sources in class <span class="define">AudioCrecord</span> will be combined and presented to the single recording output in the same fashion that the sources of class <span class="define">AudioCinputs</span> are combined and presented to the playback output(s). If the overall recording level can be changed, regardless of the input source, then this control should be named <span class="define">AudioNmaster</span> and be of class <span class="define">AudioCrecord</span>.<p>
Controls for various sources that affect only the playback output, as opposed to recording, should be in the <span class="define">AudioCinputs</span> class, as of course should any controls that affect both playback and recording.<p>
If the play mixer is capable of output to more than one destination, it should define <span class="define">AudioNselect</span> in class <span class="define">AudioCoutputs</span>. This mixer control should be of type <span class="define">AUDIO_MIXER_ENUM</span> or <span class="define">AUDIO_MIXER_SET</span> and enumerate the possible destinations. For each of the named destinations for which the output level can be set, there should be a control in the <span class="define">AudioCoutputs</span> class of type <span class="define">AUDIO_MIXER_VALUE</span>. If the overall output level can be changed, which is invariably the case, then this control should be named <span class="define">AudioNmaster</span> and be of class <span class="define">AudioCoutputs</span>.<p>
There's one additional source recognized specially by <span class="define">AUDIO_SETINFO</span> and <span class="define">AUDIO_GETINFO</span>, to be presented as monitor_gain, and that is a control named <span class="define">AudioNmonitor</span>, of class <span class="define">AudioCmonitor</span>.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../4/audio">audio(4)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> This <b class="name">audio</b> interface first appeared in <span class="unix">NetBSD&#160;1.3</span>.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
July 13, 2014</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
<>

