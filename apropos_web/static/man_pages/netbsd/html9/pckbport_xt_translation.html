<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/../4/strict.dtd">
>
<head>
<meta http-equiv="Content-Type" content="te../; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
PCKBPORT(9)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
PCKBPORT(9)</td>
<td class="head-vol" align="center">
Kernel Developer's Manual</td>
<td class="head-rtitle" align="right">
PCKBPORT(9)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">pckbport</b>, <b class="name">pckbport_attach</b>, <b class="name">pckbport_attach_slot</b>, <b class="name">pckbport_cnattach</b>, <b class="name">pckbportintr</b>, <b class="name">pckbport_set_inputhandler</b>, <b class="name">pckbport_flush</b>, <b class="name">pckbport_poll_cmd</b>, <b class="name">pckbport_enqueue_cmd</b>, <b class="name">pckbport_poll_data</b>, <b class="name">pckbport_set_poll</b>, <b class="name">pckbport_xt_translation</b>, <b class="name">pckbport_slot_enable</b> &#8212; <span class="desc">PC keyboard port interface</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">dev/pckbport/pckbportvar.h</a>&gt;</b><p>
<i class="ftype">pckbport_tag_t</i><br>
<b class="fname">pckbport_attach</b>(<i class="farg" style="white-space:nowrap;">void *</i>, <i class="farg" style="white-space:nowrap;">struct pckbport_accessops const *</i>);<p>
<i class="ftype">struct device *</i><br>
<b class="fname">pckbport_attach_slot</b>(<i class="farg" style="white-space:nowrap;">struct device *</i>, <i class="farg" style="white-space:nowrap;">pckbport_tag_t</i>, <i class="farg" style="white-space:nowrap;">pckbport_slot_t</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">pckbport_cnattach</b>(<i class="farg" style="white-space:nowrap;">void *</i>, <i class="farg" style="white-space:nowrap;">struct pckbport_accessops const *</i>, <i class="farg" style="white-space:nowrap;">pckbport_slot_t</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">pckbportintr</b>(<i class="farg" style="white-space:nowrap;">pckbport_tag_t</i>, <i class="farg" style="white-space:nowrap;">pckbport_slot_t</i>, <i class="farg" style="white-space:nowrap;">int</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">pckbport_set_inputhandler</b>(<i class="farg" style="white-space:nowrap;">pckbport_tag_t</i>, <i class="farg" style="white-space:nowrap;">pckbport_slot_t</i>, <i class="farg" style="white-space:nowrap;">pckbport_inputfcn</i>, <i class="farg" style="white-space:nowrap;">void *</i>, <i class="farg" style="white-space:nowrap;">char *</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">pckbport_flush</b>(<i class="farg" style="white-space:nowrap;">pckbport_tag_t</i>, <i class="farg" style="white-space:nowrap;">pckbport_slot_t</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">pckbport_poll_cmd</b>(<i class="farg" style="white-space:nowrap;">pckbport_tag_t</i>, <i class="farg" style="white-space:nowrap;">pckbport_slot_t</i>, <i class="farg" style="white-space:nowrap;">u_char *</i>, <i class="farg" style="white-space:nowrap;">int</i>, <i class="farg" style="white-space:nowrap;">int</i>, <i class="farg" style="white-space:nowrap;">u_char *</i>, <i class="farg" style="white-space:nowrap;">int</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">pckbport_enqueue_cmd</b>(<i class="farg" style="white-space:nowrap;">pckbport_tag_t</i>, <i class="farg" style="white-space:nowrap;">pckbport_slot_t</i>, <i class="farg" style="white-space:nowrap;">u_char *</i>, <i class="farg" style="white-space:nowrap;">int</i>, <i class="farg" style="white-space:nowrap;">int</i>, <i class="farg" style="white-space:nowrap;">int</i>, <i class="farg" style="white-space:nowrap;">u_char *</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">pckbport_poll_data</b>(<i class="farg" style="white-space:nowrap;">pckbport_tag_t</i>, <i class="farg" style="white-space:nowrap;">pckbport_slot_t</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">pckbport_set_poll</b>(<i class="farg" style="white-space:nowrap;">pckbport_tag_t</i>, <i class="farg" style="white-space:nowrap;">pckbport_slot_t</i>, <i class="farg" style="white-space:nowrap;">int</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">pckbport_xt_translation</b>(<i class="farg" style="white-space:nowrap;">pckbport_tag_t</i>, <i class="farg" style="white-space:nowrap;">pckbport_slot_t</i>, <i class="farg" style="white-space:nowrap;">int</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">pckbport_slot_enable</b>(<i class="farg" style="white-space:nowrap;">pckbport_tag_t</i>, <i class="farg" style="white-space:nowrap;">pckbport_slot_t</i>, <i class="farg" style="white-space:nowrap;">int</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The machine-independent <b class="name">pckbport</b> subsystem provides an interface layer corresponding to the serial keyboard and mouse interface used on the IBM PS/2 and many other machines. It interfaces a controller driver such as <a class="link-man" href="../4/pckbc">pckbc(4)</a> to device drivers such as <a class="link-man" href="../4/pckbd">pckbd(4)</a> and <a class="link-man" href="../4/pms">pms(4)</a>.<p>
A single controller can have up to two ports (known as &#8220;slots&#8221;), and these are identified by values of type <i class="farg">pckbport_slot_t</i>. The values <span class="define">PCKBPORT_KBD_SLOT</span> and <span class="define">PCKBPORT_AUX_SLOT</span> should be used for keyboard and mouse ports respectively. Each controller is identified by an opaque value of type <i class="farg">pckbport_tag_t</i>.<div class="subsection">
<h2 id="x436f6e74726f6c6c657220696e74657266616365">Controller interface</h2> A PC keyboard controller registers itself by calling <b class="fname">pckbport_attach</b>(<i class="farg">cookie</i>, <i class="farg">ops</i>), with <i class="farg">ops</i> being a pointer to a <i class="farg">struct pckbport_accessops</i> containing pointers to functions for driving the controller, which will all be called with <i class="farg">cookie</i> as their first argument. <b class="fname">pckbport_attach</b>() returns the <i class="farg">pckbport_tag_t</i> assigned to the controller. The controller is then expected to call <b class="fname">pckbport_attach_slot</b>() for each slot with which it is equipped, passing the <i class="farg">struct device *</i> corresponding to the controller. This function returns a pointer to the child device attached to the slot, or <span class="define">NULL</span> if no such device was attached.<p>
The elements of <i class="farg">struct pckbport_accessops</i> each take as their first two arguments the <i class="farg">cookie</i> passed to <b class="fname">pckbport_attach</b>() and the slot in question. The elements are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">int</i> <b class="fname">(*t_xt_translation)</b>(<i class="farg">void *cookie</i>, <i class="farg">pckbport_slot_t slot</i>, <i class="farg">int on</i>)</dt>
<dd class="list-tag" style="margin-left: 16.00ex;">
If <i class="farg">on</i> is non-zero, enable, otherwise disable, AT-to-XT keycode translation on the slot specified. Returns 1 on success, 0 on failure (or if the controller does not support such translation).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">int</i> <b class="fname">(*t_send_devcmd)</b>(<i class="farg">void *cookie</i>, <i class="farg">pckbport_slot_t slot</i>, <i class="farg">u_char byte</i>)</dt>
<dd class="list-tag" style="margin-left: 16.00ex;">
Send a single <i class="farg">byte</i> to the device without waiting for completion. Returns 1 on success, 0 on failure.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">int</i> <b class="fname">(*t_poll_data1)</b>(<i class="farg">void *cookie</i>, <i class="farg">pckbport_slot_t slot</i>)</dt>
<dd class="list-tag" style="margin-left: 16.00ex;">
Wait for and return one byte of data from the device, without using interrupts. This function will only be called after <b class="fname">(*t_set_poll)</b>() has been used to put the slot in polling mode. If no data are forthcoming from the device after about 100ms, return &#45;1.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">void</i> <b class="fname">(*t_slot_enable)</b>(<i class="farg">void *cookie</i>, <i class="farg">pckbport_slot_t slot</i>, <i class="farg">int on</i>)</dt>
<dd class="list-tag" style="margin-left: 16.00ex;">
If <i class="farg">on</i> is non-zero, enable, otherwise disable, the slot. If a slot is disabled, it can be powered down, and is not expected to generate any interrupts. When first attached, ports should be disabled.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">void</i> <b class="fname">(*t_intr_establish)</b>(<i class="farg">void *cookie</i>, <i class="farg">pckbport_slot_t slot</i>)</dt>
<dd class="list-tag" style="margin-left: 16.00ex;">
Set up an interrupt handler for the slot. Called when a device gets attached to it.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">void</i> <b class="fname">(*t_set_poll)</b>(<i class="farg">void *cookie</i>, <i class="farg">pckbport_slot_t slot</i>, <i class="farg">int on</i>)</dt>
<dd class="list-tag" style="margin-left: 16.00ex;">
If <i class="farg">on</i> is non-zero, enable, otherwise disable, polling mode on the slot. In polling mode, data received from the device are provided to <b class="fname">(*t_poll_data1)</b>() and not passed to <b class="fname">pckbportintr</b>(), whether or not interrupts are enabled. In non-polling mode, data from the device are expected to cause interrupts. The controller interrupt handler should call <b class="fname">pckbportintr</b>(<i class="farg">tag</i>, <i class="farg">slot</i>, <i class="farg">byte</i>) once for each <b class="var">byte</b> received from the device. When first attached, a port should be in non-polling mode.</dd>
</dl>
</div>
<div class="subsection">
<h2 id="x44657669636520696e74657266616365">Device interface</h2> Devices that attach to <b class="name">pckbport</b> controllers do so using the normal <a class="link-man" href="../9/autoconf">autoconf(9)</a> mechanism. Their <b class="fname">(*ca_match)</b>() and <b class="fname">(*ca_attach)</b>() functions get passed a <i class="farg">struct pckbport_attach_args</i> which contains the controller and slot number where the device was found. Device drivers can use the following functions to communicate with the controller. Each takes <i class="farg">tag</i> and <i class="farg">slot</i> arguments to specify the slot to be acted on.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pckbport_set_inputhandler</b>(<i class="farg">tag</i>, <i class="farg">slot</i>, <i class="farg">fn</i>, <i class="farg">arg</i>, <i class="farg">name</i>)</dt>
<dd class="list-tag" style="margin-left: 16.00ex;">
Arrange for <i class="farg">fn</i> to be called with argument <i class="farg">arg</i> whenever an unsolicited byte is received from the slot. The function will be called at <b class="fname">spltty</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pckbport_flush</b>(<i class="farg">tag</i>, <i class="farg">slot</i>)</dt>
<dd class="list-tag" style="margin-left: 16.00ex;">
Ensure that there is no pending input from the slot.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pckbport_poll_cmd</b>(<i class="farg">tag</i>, <i class="farg">slot</i>, <i class="farg">cmd</i>, <i class="farg">len</i>, <i class="farg">responselen</i>, <i class="farg">respbuf</i>, <i class="farg">slow</i>)</dt>
<dd class="list-tag" style="margin-left: 16.00ex;">
Issue a complete device command, <i class="farg">cmd</i>, <i class="farg">len</i> bytes long, expecting a response <i class="farg">responselen</i> bytes long, which will be placed in <i class="farg">respbuf</i>. If <i class="farg">slow</i> is true, the command is expected to take over a second to execute. <b class="fname">pckbport_poll_cmd</b>() handles getting an acknowledgement from the device and retrying the command if necessary. Returns 0 on success, and an error value on failure. This function should only be called during autoconfiguration or when the slot has been placed into polling mode by <b class="fname">pckbport_set_poll</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pckbport_enqueue_cmd</b>(<i class="farg">tag</i>, <i class="farg">slot</i>, <i class="farg">cmd</i>, <i class="farg">len</i>, <i class="farg">responselen</i>, <i class="farg">sync</i>, <i class="farg">respbuf</i>)</dt>
<dd class="list-tag" style="margin-left: 16.00ex;">
Issue a complete device command, <i class="farg">cmd</i>, <i class="farg">len</i> bytes long, expecting a response <i class="farg">responselen</i> bytes long, which will be places in <i class="farg">respbuf</i>. If <i class="farg">sync</i> is true, <b class="fname">pckbport_enqueue_cmd</b>() waits for the command to complete before returning, otherwise it returns immediately. It is not safe to set <i class="farg">sync</i> when calling from an interrupt context. The <b class="name">pckbport</b> layer handles getting an acknowledgement from the device and retrying the command if necessary. Returns 0 on success, and an error value on failure.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pckbport_poll_data</b>(<i class="farg">tag</i>, <i class="farg">slot</i>)</dt>
<dd class="list-tag" style="margin-left: 16.00ex;">
Low-level command to poll for a single byte of data from the device, but ignoring bytes that are part of the response to a command issued through <b class="fname">pckbport_enqueue_command</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pckbport_set_poll</b>(<i class="farg">tag</i>, <i class="farg">slot</i>, <i class="farg">on</i>)</dt>
<dd class="list-tag" style="margin-left: 16.00ex;">
If <i class="farg">on</i> is true, enable polling on the slot, otherwise disable it. In polling mode, <b class="fname">pckbport_poll_cmd</b>() can be used to issue commands and <b class="fname">pckbport_poll_data</b>() to read unsolicited data, without enabling interrupts. In non-polling mode, commands should be issued using <b class="fname">pckbport_enqueue_cmd</b>(), unsolicited data are handled by the input function, and disabling interrupts will suspend <b class="name">pckbport</b> operation.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pckbport_xt_translation</b>(<i class="farg">tag</i>, <i class="farg">slot</i>, <i class="farg">on</i>)</dt>
<dd class="list-tag" style="margin-left: 16.00ex;">
Passthrough of <b class="fname">(*t_xt_translation)</b>() (see above).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pckbport_slot</b>(<i class="farg">enable</i>, <i class="farg">tag</i>, <i class="farg">slot</i>, <i class="farg">on</i>)</dt>
<dd class="list-tag" style="margin-left: 16.00ex;">
Passthrough of <b class="fname">(*t_slot_enable)</b>() (see above).</dd>
</dl>
</div>
<div class="subsection">
<h2 id="x436f6e736f6c6520696e74657266616365">Console interface</h2> On systems that can attach consoles through <b class="name">pckbport</b>, the controller's console attachment function (called very early in autoconfiguration) calls <b class="fname">pckbport_cnattach</b>(<i class="farg">cookie</i>, <i class="farg">ops</i>, <i class="farg">slot</i>). The first two arguments are the same as for <b class="fname">pckbport_attach</b>(), while the third indicates which slot the console keyboard is attached to. <b class="fname">pckbport_cnattach</b>() either calls <b class="fname">pckbd_cnattach</b>(), if it is available, or <b class="fname">pckbport_machdep_cnattach</b>(). The latter allows machine-dependent keyboard drivers to attach themselves, but it is only called if a device with the &#8216;<code class="lit">pckbport_machdep_cnattach</code>&#8217; attribute is configured into the system. <b class="fname">pckbport_cnattach</b>() returns 0 on success and an error value on failure. <b class="fname">pckbport_machdep_cnattach</b>() is expected to do the same.</div>
</div>
<div class="section">
<h1 id="x434f4445205245464552454e434553">CODE REFERENCES</h1> The <b class="name">pckbport</b> code, and the <a class="link-man" href="../4/pckbd">pckbd(4)</a> and <a class="link-man" href="../4/pms">pms(4)</a> device drivers are in <i class="file">sys/dev/pckbport</i>.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../4/pckbc">pckbc(4)</a>, <a class="link-man" href="../4/pckbd">pckbd(4)</a>, <a class="link-man" href="../4/pms">pms(4)</a>, <a class="link-man" href="../9/autoconf">autoconf(9)</a>, <a class="link-man" href="../9/spl">spl(9)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The <b class="name">pckbport</b> system appeared in <span class="unix">NetBSD&#160;2.0</span>. Before that, <a class="link-man" href="../4/pckbd">pckbd(4)</a> and <a class="link-man" href="../4/pms">pms(4)</a> attached directly to <a class="link-man" href="../4/pckbc">pckbc(4)</a> without any sensible way of using a different controller.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
August 5, 2004</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
<>

