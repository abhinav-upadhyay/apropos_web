<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/../4/strict.dtd">
>
<head>
<meta http-equiv="Content-Type" content="te../; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
UVM_MAP(9)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
UVM_MAP(9)</td>
<td class="head-vol" align="center">
Kernel Developer's Manual</td>
<td class="head-rtitle" align="right">
UVM_MAP(9)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">uvm_map</b> &#8212; <span class="desc">virtual address space management interface</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/param.h</a>&gt;</b><br>
<b class="includes">#include &lt;<a class="link-includes">uvm/uvm.h</a>&gt;</b><p>
<i class="ftype">int</i><br>
<b class="fname">uvm_map</b>(<i class="farg" style="white-space:nowrap;">struct vm_map *map</i>, <i class="farg" style="white-space:nowrap;">vaddr_t *startp</i>, <i class="farg" style="white-space:nowrap;">vsize_t size</i>, <i class="farg" style="white-space:nowrap;">struct uvm_object *uobj</i>, <i class="farg" style="white-space:nowrap;">voff_t uoffset</i>, <i class="farg" style="white-space:nowrap;">vsize_t align</i>, <i class="farg" style="white-space:nowrap;">uvm_flag_t flags</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">uvm_unmap</b>(<i class="farg" style="white-space:nowrap;">struct vm_map *map</i>, <i class="farg" style="white-space:nowrap;">vaddr_t start</i>, <i class="farg" style="white-space:nowrap;">vaddr_t end</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">uvm_map_pageable</b>(<i class="farg" style="white-space:nowrap;">struct vm_map *map</i>, <i class="farg" style="white-space:nowrap;">vaddr_t start</i>, <i class="farg" style="white-space:nowrap;">vaddr_t end</i>, <i class="farg" style="white-space:nowrap;">bool new_pageable</i>, <i class="farg" style="white-space:nowrap;">int lockflags</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">uvm_map_checkprot</b>(<i class="farg" style="white-space:nowrap;">struct vm_map *map</i>, <i class="farg" style="white-space:nowrap;">vaddr_t start</i>, <i class="farg" style="white-space:nowrap;">vaddr_t end</i>, <i class="farg" style="white-space:nowrap;">vm_prot_t protection</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">uvm_map_protect</b>(<i class="farg" style="white-space:nowrap;">struct vm_map *map</i>, <i class="farg" style="white-space:nowrap;">vaddr_t start</i>, <i class="farg" style="white-space:nowrap;">vaddr_t end</i>, <i class="farg" style="white-space:nowrap;">vm_prot_t new_prot</i>, <i class="farg" style="white-space:nowrap;">bool set_max</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">uvm_deallocate</b>(<i class="farg" style="white-space:nowrap;">struct vm_map *map</i>, <i class="farg" style="white-space:nowrap;">vaddr_t start</i>, <i class="farg" style="white-space:nowrap;">vsize_t size</i>);<p>
<i class="ftype">struct vmspace *</i><br>
<b class="fname">uvmspace_alloc</b>(<i class="farg" style="white-space:nowrap;">vaddr_t min</i>, <i class="farg" style="white-space:nowrap;">vaddr_t max</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">uvmspace_exec</b>(<i class="farg" style="white-space:nowrap;">struct lwp *l</i>, <i class="farg" style="white-space:nowrap;">vaddr_t start</i>, <i class="farg" style="white-space:nowrap;">vaddr_t end</i>);<p>
<i class="ftype">struct vmspace *</i><br>
<b class="fname">uvmspace_fork</b>(<i class="farg" style="white-space:nowrap;">struct vmspace *vm</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">uvmspace_free</b>(<i class="farg" style="white-space:nowrap;">struct vmspace *vm</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">uvmspace_share</b>(<i class="farg" style="white-space:nowrap;">struct proc *p1</i>, <i class="farg" style="white-space:nowrap;">struct proc *p2</i>);<p>
<i class="ftype">vaddr_t</i><br>
<b class="fname">uvm_uarea_alloc</b>(<i class="farg" style="white-space:nowrap;">void</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">uvm_uarea_free</b>(<i class="farg" style="white-space:nowrap;">vaddr_t uaddr</i>);<p>
<i class="ftype">vaddr_t</i><br>
<b class="fname">uvm_uarea_system_alloc</b>(<i class="farg" style="white-space:nowrap;">void</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">uvm_uarea_system_free</b>(<i class="farg" style="white-space:nowrap;">vaddr_t uaddr</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The UVM facility for virtual address space management.</div>
<div class="section">
<h1 id="x46554e4354494f4e53">FUNCTIONS</h1> <b class="fname">uvm_map</b>() establishes a valid mapping in map <i class="farg">map</i>, which must be unlocked. The new mapping has size <i class="farg">size</i>, which must be a multiple of <span class="define">PAGE_SIZE</span>.<p>
The <i class="farg">uobj</i> and <i class="farg">uoffset</i> arguments can have four meanings:<ul style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 4.00ex;" class="list list-bul">
<li class="list-bul" style="margin-top: 0.00em;">
When <i class="farg">uobj</i> is <span class="define">NULL</span> and <i class="farg">uoffset</i> is <span class="define">UVM_UNKNOWN_OFFSET</span>, <b class="fname">uvm_map</b>() does not use the machine-dependent <span class="define">PMAP_PREFER</span> function.</li>
<li class="list-bul" style="margin-top: 0.00em;">
When <i class="farg">uobj</i> is <span class="define">NULL</span> and <i class="farg">uoffset</i> is any other value, it is used as the hint to <span class="define">PMAP_PREFER</span>.</li>
<li class="list-bul" style="margin-top: 0.00em;">
When <i class="farg">uobj</i> is not <span class="define">NULL</span> and <i class="farg">uoffset</i> is <span class="define">UVM_UNKNOWN_OFFSET</span>, <b class="fname">uvm_map</b>() finds the offset based upon the virtual address, passed as <i class="farg">startp</i>.</li>
<li class="list-bul" style="margin-top: 0.00em;">
When <i class="farg">uobj</i> is not <span class="define">NULL</span> and <i class="farg">uoffset</i> is any other value, then a regular mapping is performed at this offset. The start address of the map will be returned in <i class="farg">startp</i>.</li>
</ul>
Note that <b class="fname">uvm_map</b>() does not add a reference to <i class="farg">uobj</i>; it is the caller's responsibility to do so.<p>
<i class="farg">align</i> specifies alignment of mapping unless <span class="define">UVM_FLAG_FIXED</span> is specified in <i class="farg">flags</i>. <i class="farg">align</i> must be a power of 2.<p>
<i class="farg">flags</i> passed to <b class="fname">uvm_map</b>() are typically created using the <b class="fname">UVM_MAPFLAG</b>(<i class="farg">vm_prot_t prot</i>, <i class="farg">vm_prot_t maxprot</i>, <i class="farg">vm_inherit_t inh</i>, <i class="farg">int advice</i>, <i class="farg">int flags</i>) macro, which uses the following values.<p>
The values that <i class="farg">prot</i> and <i class="farg">maxprot</i> can take are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 4.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
UVM_PROT_NONE</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
No protection bits.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
UVM_PROT_R</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Read.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
UVM_PROT_W</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Write.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
UVM_PROT_X</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Exec.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
UVM_PROT_MASK</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Mask to extraction the protection bits.</dd>
</dl>
Additionally, the following constants for ORed values are available: <span class="define">UVM_PROT_RW</span>, <span class="define">UVM_PROT_RX</span>, <span class="define">UVM_PROT_WX</span> and <span class="define">UVM_PROT_RWX</span>.<p>
The values that <i class="farg">inh</i> can take are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 4.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
UVM_INH_SHARE</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Share the map.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
UVM_INH_COPY</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Copy the map.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
UVM_INH_NONE</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
No inheritance.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
UVM_INH_MASK</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Mask to extract inherit flags.</dd>
</dl>
<p>
The values that <i class="farg">advice</i> can take are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 4.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
UVM_ADV_NORMAL</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
"Normal" use.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
UVM_ADV_RANDOM</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
"Random" access likelihood.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
UVM_ADV_SEQUENTIAL</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
"Sequential" access likelihood.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
UVM_ADV_MASK</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Mask to extract the advice flags.</dd>
</dl>
<p>
The values that <i class="farg">flags</i> can take are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 4.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
UVM_FLAG_FIXED</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Attempt to map on the address specified by <i class="farg">startp</i>. Otherwise, it is used just as a hint.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
UVM_FLAG_OVERLAY</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Establish overlay.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
UVM_FLAG_NOMERGE</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Do not merge map entries, if such merge is possible.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
UVM_FLAG_COPYONW</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Use copy-on-write i.e. do not fault in the pages immediately.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
UVM_FLAG_AMAPPAD</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Used for BSS: allocate larger amap, if extending is likely.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
UVM_FLAG_TRYLOCK</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Fail if cannot acquire the lock immediately.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
UVM_FLAG_NOWAIT</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Not allowed to sleep. Fail, in such case.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
UVM_FLAG_QUANTUM</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Indicates that map entry cannot be split once mapped.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
UVM_FLAG_WAITVA</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Sleep until VA space is available, if it is not.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
UVM_FLAG_VAONLY</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Unmap only VA space. Used by <b class="fname">uvm_unmap</b>().</dd>
</dl>
<p>
The <span class="define">UVM_MAPFLAG</span> macro arguments can be combined with an or operator. There are several special purpose macros for checking protection combinations, e.g., the <span class="define">UVM_PROT_WX</span>. There are also some additional macros to extract bits from the flags. The <span class="define">UVM_PROTECTION</span>, <span class="define">UVM_INHERIT</span>, <span class="define">UVM_MAXPROTECTION</span> and <span class="define">UVM_ADVICE</span> macros return the protection, inheritance, maximum protection, and advice, respectively. <b class="fname">uvm_map</b>() returns zero on success or error number otherwise.<p>
<b class="fname">uvm_unmap</b>() removes a valid mapping, from <i class="farg">start</i> to <i class="farg">end</i>, in map <i class="farg">map</i>, which must be unlocked.<p>
<b class="fname">uvm_map_pageable</b>() changes the pageability of the pages in the range from <i class="farg">start</i> to <i class="farg">end</i> in map <i class="farg">map</i> to <i class="farg">new_pageable</i>. <b class="fname">uvm_map_pageable</b>() returns zero on success or error number otherwise.<p>
<b class="fname">uvm_map_checkprot</b>() checks the protection of the range from <i class="farg">start</i> to <i class="farg">end</i> in map <i class="farg">map</i> against <i class="farg">protection</i>. This returns either <span class="define">true</span> or <span class="define">false</span>.<p>
<b class="fname">uvm_map_protect</b>() changes the protection <i class="farg">start</i> to <i class="farg">end</i> in map <i class="farg">map</i> to <i class="farg">new_prot</i>, also setting the maximum protection to the region to <i class="farg">new_prot</i> if <i class="farg">set_max</i> is true. This function returns a standard UVM return value.<p>
<b class="fname">uvm_deallocate</b>() deallocates kernel memory in map <i class="farg">map</i> from address <i class="farg">start</i> to <i class="farg">start + size</i>.<p>
<b class="fname">uvmspace_alloc</b>() allocates and returns a new address space, with ranges from <i class="farg">min</i> to <i class="farg">max</i>.<p>
<b class="fname">uvmspace_exec</b>() either reuses the address space of thread <i class="farg">l</i> (its process) if there are no other references to it, or creates a new one with <b class="fname">uvmspace_alloc</b>(). The range of valid addresses in the address space is reset to <i class="farg">start</i> through <i class="farg">end</i>.<p>
<b class="fname">uvmspace_fork</b>() creates and returns a new address space based upon the <i class="farg">vm</i> address space, typically used when allocating an address space for a child process.<p>
<b class="fname">uvmspace_free</b>() lowers the reference count on the address space <i class="farg">vm</i>, freeing the data structures if there are no other references.<p>
<b class="fname">uvmspace_share</b>() causes process <i class="file">p2</i> to share the address space of <i class="farg">p1</i>.<p>
<b class="fname">uvm_uarea_alloc</b>() allocates memory for a u-area (i.e. kernel stack, PCB, etc) and returns the address.<p>
<b class="fname">uvm_uarea_free</b>() frees a u-area allocated with <b class="fname">uvm_uarea_alloc</b>().<p>
<b class="fname">uvm_uarea_system_alloc</b>() and <b class="fname">uvm_uarea_system_free</b>() are optimized routines, which are used for kernel threads.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../9/pmap">pmap(9)</a>, <a class="link-man" href="../9/uvm">uvm(9)</a>, <a class="link-man" href="../9/uvm_km">uvm_km(9)</a>, <a class="link-man" href="../9/vmem">vmem(9)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> UVM and <b class="name">uvm_map</b> first appeared in <span class="unix">NetBSD&#160;1.4</span>.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
May 20, 2014</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
<>

