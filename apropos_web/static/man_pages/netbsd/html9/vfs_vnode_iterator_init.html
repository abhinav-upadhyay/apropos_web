<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
VFSSUBR(9)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
VFSSUBR(9)</td>
<td class="head-vol" align="center">
Kernel Developer's Manual</td>
<td class="head-rtitle" align="right">
VFSSUBR(9)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">vfssubr</b>, <b class="name">vfs_getnewfsid</b>, <b class="name">vfs_getvfs</b>, <b class="name">vfs_export</b>, <b class="name">vfs_showexport</b>, <b class="name">vfs_export_lookup</b>, <b class="name">vfs_setpublicfs</b>, <b class="name">vfs_mountedon</b>, <b class="name">vfs_mountroot</b>, <b class="name">vfs_unmountall</b>, <b class="name">vfs_busy</b>, <b class="name">vfs_unbusy</b>, <b class="name">vfs_mountalloc</b>, <b class="name">vfs_rootmountalloc</b>, <b class="name">vfs_shutdown</b>, <b class="name">vfs_attach</b>, <b class="name">vfs_detach</b>, <b class="name">vfs_reinit</b>, <b class="name">vfs_getopsbyname</b>, <b class="name">vfs_suspend</b>, <b class="name">vfs_resume</b>, <b class="name">vfs_vnode_iterator_init</b>, <b class="name">vfs_vnode_iterator_destroy</b>, <b class="name">vfs_vnode_iterator_next</b> &#8212; <span class="desc">high-level interface to kernel file system interface</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/param.h</a>&gt;</b><br>
<b class="includes">#include &lt;<a class="link-includes">sys/mount.h</a>&gt;</b><br>
<b class="includes">#include &lt;<a class="link-includes">sys/vnode.h</a>&gt;</b><p>
<i class="ftype">void</i><br>
<b class="fname">vfs_getnewfsid</b>(<i class="farg" style="white-space:nowrap;">struct mount *mp</i>);<p>
<i class="ftype">struct mount *</i><br>
<b class="fname">vfs_getvfs</b>(<i class="farg" style="white-space:nowrap;">fsid_t *fsid</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">vfs_export_lookup</b>(<i class="farg" style="white-space:nowrap;">struct mount *mp</i>, <i class="farg" style="white-space:nowrap;">struct netexport *nep</i>, <i class="farg" style="white-space:nowrap;">struct export_args *argp</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">vfs_setpublicfs</b>(<i class="farg" style="white-space:nowrap;">struct mount *mp</i>, <i class="farg" style="white-space:nowrap;">struct netexport *nep</i>, <i class="farg" style="white-space:nowrap;">struct export_args *argp</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">vfs_mountedon</b>(<i class="farg" style="white-space:nowrap;">struct vnode *vp</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">vfs_mountroot</b>(<i class="farg" style="white-space:nowrap;">void</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">vfs_unmountall</b>(<i class="farg" style="white-space:nowrap;">struct lwp *l</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">vfs_busy</b>(<i class="farg" style="white-space:nowrap;">struct mount *mp</i>, <i class="farg" style="white-space:nowrap;">struct mount **nextp</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">vfs_unbusy</b>(<i class="farg" style="white-space:nowrap;">struct mount *mp</i>, <i class="farg" style="white-space:nowrap;">bool keepref</i>, <i class="farg" style="white-space:nowrap;">struct mount **nextp</i>);<p>
<i class="ftype">struct mount *</i><br>
<b class="fname">vfs_mountalloc</b>(<i class="farg" style="white-space:nowrap;">struct vfsops *vfs</i>, <i class="farg" style="white-space:nowrap;">struct vnode *vp</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">vfs_rootmountalloc</b>(<i class="farg" style="white-space:nowrap;">char *fstypename</i>, <i class="farg" style="white-space:nowrap;">char *devname</i>, <i class="farg" style="white-space:nowrap;">struct mount **mpp</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">vfs_shutdown</b>(<i class="farg" style="white-space:nowrap;">void</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">vfs_attach</b>(<i class="farg" style="white-space:nowrap;">struct vfsops *vfs</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">vfs_detach</b>(<i class="farg" style="white-space:nowrap;">struct vfsops *vfs</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">vfs_reinit</b>(<i class="farg" style="white-space:nowrap;">void</i>);<p>
<i class="ftype">struct vfsops *</i><br>
<b class="fname">vfs_getopsbyname</b>(<i class="farg" style="white-space:nowrap;">const char *name</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">vfs_suspend</b>(<i class="farg" style="white-space:nowrap;">struct mount *mp</i>, <i class="farg" style="white-space:nowrap;">int nowait</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">vfs_resume</b>(<i class="farg" style="white-space:nowrap;">struct mount *mp</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">vfs_vnode_iterator_init</b>(<i class="farg" style="white-space:nowrap;">struct mount *mp</i>, <i class="farg" style="white-space:nowrap;">struct vnode_iterator **vip</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">vfs_vnode_iterator_destroy</b>(<i class="farg" style="white-space:nowrap;">struct vnode_iterator *vi</i>);<p>
<i class="ftype">struct vnode *</i><br>
<b class="fname">vfs_vnode_iterator_next</b>(<i class="farg" style="white-space:nowrap;">struct vnode_iterator *vi</i>, <i class="farg" style="white-space:nowrap;">bool (*selector)(void *context, struct vnode *vpp)</i>, <i class="farg" style="white-space:nowrap;">void *context</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The high-level functions described in this page are the interface to the kernel file system interface (VFS).</div>
<div class="section">
<h1 id="x46554e4354494f4e53">FUNCTIONS</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vfs_getnewfsid</b>(<i class="farg">mp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Get a new unique file system id type for the file system specified by the mount structure <i class="farg">mp</i>. The file system id type is stored in <span class="emph">mp-&gt;mnt_stat.f_fsidx</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vfs_getvfs</b>(<i class="farg">fsid</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Lookup a mount point with the file system identifier <i class="farg">fsid</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vfs_export_lookup</b>(<i class="farg">mp</i>, <i class="farg">nep</i>, <i class="farg">argp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Check client permission on the exportable file system specified by the mount structure <i class="farg">mp</i>. The argument <i class="farg">nam</i> is the address of the networked client. This function is used by file system type specific functions to verify that the client can access the file system.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vfs_setpublicfs</b>(<i class="farg">mp</i>, <i class="farg">nep</i>, <i class="farg">argp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Set the publicly exported file system specified by the mount structure <i class="farg">mp</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vfs_mountedon</b>(<i class="farg">vp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Check to see if a file system is mounted on a block device specified by the vnode <i class="farg">vp</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vfs_mountroot</b>(<i class="farg">void</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Mount the root file system.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vfs_unmountall</b>(<i class="farg">l</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Unmount all file systems.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vfs_busy</b>(<i class="farg">mp</i>, <i class="farg">nextp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Mark the mount point specified by <i class="farg">mp</i> as busy and get a reference to it. This function is used to synchronize access and to delay unmounting. The caller must hold a pre-existing reference to the mount. If <i class="farg">nextp</i> is not <span class="define">NULL</span>, the caller must hold the <span class="emph">mountlist_lock</span> and <i class="farg">nextp</i> will receive the next mount from mount list on error. The <span class="emph">mountlist_lock</span> is released on return.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vfs_unbusy</b>(<i class="farg">mp</i>, <i class="farg">keepref</i>, <i class="farg">nextp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Undo a <b class="fname">vfs_busy</b>() on the mount point specified by <i class="farg">mp</i>. If <i class="farg">keepref</i> is true, preserve the reference added by <b class="fname">vfs_busy</b>(). If <i class="farg">nextp</i> is not <span class="define">NULL</span>, the <span class="emph">mountlist_lock</span> will be aquired and <i class="farg">nextp</i> will receive the next mount from mount list.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vfs_mountalloc</b>(<i class="farg">vfsops</i>, <i class="farg">vp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Allocate and initialise a mount structure, setting <span class="emph">mnt_vnodecovered</span> to <i class="farg">vp</i> and <span class="emph">mnt_op</span> to <i class="farg">vfsops</i>. On success, mark the mount structure as busy and return its address. Otherwise, return <span class="define">NULL</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vfs_rootmountalloc</b>(<i class="farg">fstypename</i>, <i class="farg">devname</i>, <i class="farg">mpp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Lookup a file system type specified by the name <i class="farg">fstypename</i> and if found allocate and initialise a mount structure for it. The allocated mount structure is returned in the address specified by <i class="farg">mpp</i>. The device the root file system was mounted from is specified by the argument <i class="farg">devname</i> and is recorded in the new mount structure.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vfs_shutdown</b>()</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Sync and unmount all file systems before shutting down. Invoked by <a class="link-man" href="../9/cpu_reboot">cpu_reboot(9)</a>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vfs_attach</b>(<i class="farg">vfs</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Establish file system <i class="farg">vfs</i> and initialise it.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vfs_detach</b>(<i class="farg">vfs</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Remove file system <i class="farg">vfs</i> from the kernel.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vfs_reinit</b>(<i class="farg">void</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Reinitialises all file systems within the kernel through file system-specific vfs operation (see <a class="link-man" href="../9/vfsops">vfsops(9)</a>).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vfs_getopsbyname</b>(<i class="farg">name</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Given a file system name specified by <i class="farg">name</i>, look up the vfs operations for that file system (see <a class="link-man" href="../9/vfsops">vfsops(9)</a>), or return <span class="define">NULL</span> if file system isn't present in the kernel.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vfs_suspend</b>(<i class="farg">mp</i>, <i class="farg">nowait</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Request a mounted file system to suspend all operations. All new operations to the file system are stopped. After all operations in progress have completed, the file system is synced to disk and the function returns. If a file system suspension is currently in progress and <i class="farg">nowait</i> is set <span class="errno">EWOULDBLOCK</span> is returned. If the operation is successful, zero is returned, otherwise an appropriate error code is returned.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vfs_resume</b>(<i class="farg">mp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Request a mounted file system to resume operations.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vfs_vnode_iterator_init</b>(<i class="farg">mp</i>, <i class="farg">vip</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Allocate and initialize an iterator <i class="farg">vip</i> over all vnodes attached to mount point <i class="farg">mp</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vfs_vnode_iterator_destroy</b>(<i class="farg">vi</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Free all resources associated with an iterator <i class="farg">vi</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vfs_vnode_iterator_next</b>(<i class="farg">vi</i>, <i class="farg">selector</i>, <i class="farg">context</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Return the next vnode from iterator <i class="farg">vi</i>. If the operation is successful the vnode has a reference added to it and it is returned. If the iterator is exhausted the function returns <span class="define">NULL</span>. If an optional <i class="farg">selector</i> function is provided, then this function is called with the <i class="farg">context</i> provided and the candidate vnode to be returned. If the <i class="farg">selector</i> returns <span class="define">false</span>, then the vnode is skipped; if it returns <span class="define">true</span>, the vnode is referenced and then returned.</dd>
</dl>
</div>
<div class="section">
<h1 id="x434f4445205245464552454e434553">CODE REFERENCES</h1> The vfs interface functions are implemented within the files <i class="file">sys/kern/vfs_mount.c</i>, <i class="file">sys/kern/vfs_subr.c</i> and <i class="file">sys/kern/vfs_init.c</i>.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../9/intro">intro(9)</a>, <a class="link-man" href="../9/namei">namei(9)</a>, <a class="link-man" href="../9/vfs">vfs(9)</a>, <a class="link-man" href="../9/vfsops">vfsops(9)</a>, <a class="link-man" href="../9/vnode">vnode(9)</a>, <a class="link-man" href="../9/vnodeops">vnodeops(9)</a></div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
May 24, 2014</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

