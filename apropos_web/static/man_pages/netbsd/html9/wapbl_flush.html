<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="/static/man_pages/netbsd/style.css" type="text/css" media="all">
<title>
WAPBL(9)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
WAPBL(9)</td>
<td class="head-vol" align="center">
Kernel Developer's Manual</td>
<td class="head-rtitle" align="right">
WAPBL(9)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">WAPBL</b>, <b class="name">wapbl_start</b>, <b class="name">wapbl_stop</b>, <b class="name">wapbl_begin</b>, <b class="name">wapbl_end</b>, <b class="name">wapbl_flush</b>, <b class="name">wapbl_discard</b>, <b class="name">wapbl_add_buf</b>, <b class="name">wapbl_remove_buf</b>, <b class="name">wapbl_resize_buf</b>, <b class="name">wapbl_register_inode</b>, <b class="name">wapbl_unregister_inode</b>, <b class="name">wapbl_register_deallocation</b>, <b class="name">wapbl_jlock_assert</b>, <b class="name">wapbl_junlock_assert</b> &#8212; <span class="desc">write-ahead physical block logging for file systems</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/wapbl.h</a>&gt;</b><p>
<span class="type">typedef void (*wapbl_flush_fn_t)(struct mount *, daddr_t *, int *, int)</span>;<p>
<i class="ftype">int</i><br>
<b class="fname">wapbl_start</b>(<i class="farg" style="white-space:nowrap;">struct wapbl **wlp</i>, <i class="farg" style="white-space:nowrap;">struct mount *mp</i>, <i class="farg" style="white-space:nowrap;">struct vnode *devvp</i>, <i class="farg" style="white-space:nowrap;">daddr_t off</i>, <i class="farg" style="white-space:nowrap;">size_t count</i>, <i class="farg" style="white-space:nowrap;">size_t blksize</i>, <i class="farg" style="white-space:nowrap;">struct wapbl_replay *wr</i>, <i class="farg" style="white-space:nowrap;">wapbl_flush_fn_t flushfn</i>, <i class="farg" style="white-space:nowrap;">wapbl_flush_fn_t flushabortfn</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">wapbl_stop</b>(<i class="farg" style="white-space:nowrap;">struct wapbl *wl</i>, <i class="farg" style="white-space:nowrap;">int force</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">wapbl_begin</b>(<i class="farg" style="white-space:nowrap;">struct wapbl *wl</i>, <i class="farg" style="white-space:nowrap;">const char *file</i>, <i class="farg" style="white-space:nowrap;">int line</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">wapbl_end</b>(<i class="farg" style="white-space:nowrap;">struct wapbl *wl</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">wapbl_flush</b>(<i class="farg" style="white-space:nowrap;">struct wapbl *wl</i>, <i class="farg" style="white-space:nowrap;">int wait</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">wapbl_discard</b>(<i class="farg" style="white-space:nowrap;">struct wapbl *wl</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">wapbl_add_buf</b>(<i class="farg" style="white-space:nowrap;">struct wapbl *wl</i>, <i class="farg" style="white-space:nowrap;">struct buf *bp</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">wapbl_remove_buf</b>(<i class="farg" style="white-space:nowrap;">struct wapbl *wl</i>, <i class="farg" style="white-space:nowrap;">struct buf *bp</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">wapbl_resize_buf</b>(<i class="farg" style="white-space:nowrap;">struct wapbl *wl</i>, <i class="farg" style="white-space:nowrap;">struct buf *bp</i>, <i class="farg" style="white-space:nowrap;">long oldsz</i>, <i class="farg" style="white-space:nowrap;">long oldcnt</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">wapbl_register_inode</b>(<i class="farg" style="white-space:nowrap;">struct wapbl *wl</i>, <i class="farg" style="white-space:nowrap;">ino_t ino</i>, <i class="farg" style="white-space:nowrap;">mode_t mode</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">wapbl_unregister_inode</b>(<i class="farg" style="white-space:nowrap;">struct wapbl *wl</i>, <i class="farg" style="white-space:nowrap;">ino_t ino</i>, <i class="farg" style="white-space:nowrap;">mode_t mode</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">wapbl_register_deallocation</b>(<i class="farg" style="white-space:nowrap;">struct wapbl *wl</i>, <i class="farg" style="white-space:nowrap;">daddr_t blk</i>, <i class="farg" style="white-space:nowrap;">int len</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">wapbl_jlock_assert</b>(<i class="farg" style="white-space:nowrap;">struct wapbl *wl</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">wapbl_junlock_assert</b>(<i class="farg" style="white-space:nowrap;">struct wapbl *wl</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> <b class="name">WAPBL</b>, or <span class="emph">write-ahead physical block logging</span>, is an abstraction for file systems to write physical blocks in the <a class="link-man" href="../9/buffercache">buffercache(9)</a> to a bounded-size log first before their real destinations on disk. The name means:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 4.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
logging</dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
batches of writes are issued atomically via a log</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
physical block</dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
only physical blocks, not logical file system operations, are stored in the log</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
write-ahead</dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
blocks are written to the log before being written to the disk</dd>
</dl>
<p>
When a file system using <b class="name">WAPBL</b> issues writes (as in <a class="link-man" href="../9/bwrite">bwrite(9)</a> or <a class="link-man" href="../9/bdwrite">bdwrite(9)</a>), they are grouped in batches called <span class="emph">transactions</span> in memory, which are serialized to be consistent with program order before <b class="name">WAPBL</b> submits them to disk atomically.<p>
Thus, within a transaction, after one write, another write need not wait for disk I/O, and if the system is interrupted, e.g. by a crash or by power failure, either both writes will appear on disk, or neither will.<p>
When a transaction is full, it is written to a circular buffer on disk called the <span class="emph">log</span>. When the transaction has been written to disk, every write in the transaction is submitted to disk asynchronously. Finally, the file system may issue new writes via <b class="name">WAPBL</b> once enough writes submitted to disk have completed.<p>
After interruption, such as a crash or power failure, some writes issued by the file system may not have completed. However, the log is written consistently with program order and before file system writes are submitted to disk. Hence a consistent program-order view of the file system can be attained by resubmitting the writes that were successfully stored in the log using <a class="link-man" href="../9/wapbl_replay">wapbl_replay(9)</a>. This may not be the same state just before interruption -- writes in transactions that did not reach the disk will be excluded.<p>
For a file system to use <b class="name">WAPBL</b>, its <a class="link-man" href="../9/VFS_MOUNT">VFS_MOUNT(9)</a> method should first replay any journal on disk using <a class="link-man" href="../9/wapbl_replay">wapbl_replay(9)</a>, and then, if the mount is read/write, initialize <b class="name">WAPBL</b> for the mount by calling <b class="fname">wapbl_start</b>(). The <a class="link-man" href="../9/VFS_UNMOUNT">VFS_UNMOUNT(9)</a> method should call <b class="fname">wapbl_stop</b>().<p>
Before issuing any <a class="link-man" href="../9/buffercache">buffercache(9)</a> writes, the file system must lock the current <b class="name">WAPBL</b> transaction with <b class="fname">wapbl_begin</b>(), which may sleep until there is room in the transaction for new writes. After issuing the writes, the file system must unlock the transaction with <b class="fname">wapbl_end</b>(). Either all writes issued between <b class="fname">wapbl_begin</b>() and <b class="fname">wapbl_end</b>() will complete, or none of them will. File systems can assert that the transaction is locked with <b class="fname">wapbl_jlock_assert</b>(), or not exclusively locked, with <b class="fname">wapbl_junlock_assert</b>().<p>
If a file system requires multiple transactions to initialize an inode, and needs to destroy partially initialized inodes during replay, it can register them by <span class="type">ino_t</span> inode number before initialization with <b class="fname">wapbl_register_inode</b>() and unregister them with <b class="fname">wapbl_unregister_inode</b>() once initialization is complete. <b class="name">WAPBL</b> does not actually concern itself whether the objects identified by <span class="type">ino_t</span> values are &#8216;inodes&#8217; or &#8216;quaggas&#8217; or anything else -- file systems may use this to list any objects keyed by <span class="type">ino_t</span> value in the log.<p>
When a file system frees resources on disk and issues writes to reflect the fact, it cannot then reuse the resources until the writes have reached the disk. However, as far as the <a class="link-man" href="../9/buffercache">buffercache(9)</a> is concerned, as soon as the file system issues the writes, they will appear to have been written. So the file system must not attempt to reuse the resource until the current <b class="name">WAPBL</b> transaction has been flushed to disk.<p>
The file system can defer freeing a resource by calling <b class="fname">wapbl_register_deallocation</b>() to record the disk address of the resource and length in bytes of the resource. Then, when <b class="name">WAPBL</b> next flushes the transaction to disk, it will pass an array of the disk addresses and lengths in bytes to a file-system-supplied callback. (Again, <b class="name">WAPBL</b> does not care whether the &#8216;disk address&#8217; or &#8216;length in bytes&#8217; is actually that; it will pass along <span class="type">daddr_t</span> and <span class="type">int</span> values.)</div>
<div class="section">
<h1 id="x46554e4354494f4e53">FUNCTIONS</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">wapbl_start</b>(<i class="farg">wlp</i>, <i class="farg">mp</i>, <i class="farg">devvp</i>, <i class="farg">off</i>, <i class="farg">count</i>, <i class="farg">blksize</i>, <i class="farg">wr</i>, <i class="farg">flushfn</i>, <i class="farg">flushabortfn</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Start using <b class="name">WAPBL</b> for the file system mounted at <i class="farg">mp</i>, storing a log of <i class="farg">count</i> disk sectors at disk address <i class="farg">off</i> on the block device <i class="farg">devvp</i> writing blocks in units of <i class="farg">blksize</i> bytes. On success, stores an opaque <span class="type">struct wapbl *</span> cookie in <code class="lit">*</code><i class="farg">wlp</i> for use with the other <b class="name">WAPBL</b> routines and returns zero. On failure, returns an error number.<p>
If the file system had replayed the log with <a class="link-man" href="../9/wapbl_replay">wapbl_replay(9)</a>, then <i class="farg">wr</i> must be the <span class="type">struct wapbl_replay *</span> cookie used to replay it, and <b class="fname">wapbl_start</b>() will register any inodes that were in the log as if with <b class="fname">wapbl_register_inode</b>(); otherwise <i class="farg">wr</i> must be <span class="define">NULL</span>.<p>
<i class="farg">flushfn</i> is a callback that <b class="name">WAPBL</b> will invoke as <i class="farg">flushfn</i>(<i class="farg">mp</i>, <i class="farg">deallocblks</i>, <i class="farg">dealloclens</i>, <i class="farg">dealloccnt</i>) just before it flushes a transaction to disk, with the transaction locked exclusively, where <i class="farg">mp</i> is the mount point passed to <b class="fname">wapbl_start</b>(), <i class="farg">deallocblks</i> is an array of <i class="farg">dealloccnt</i> disk addresses, and <i class="farg">dealloclens</i> is an array of <i class="farg">dealloccnt</i> lengths, corresponding to the addresses and lengths the file system passed to <b class="fname">wapbl_register_deallocation</b>(). If flushing the transaction to disk fails, <b class="name">WAPBL</b> will call <i class="farg">flushabortfn</i> with the same arguments to undo any effects that <i class="farg">flushfn</i> had.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">wapbl_stop</b>(<i class="farg">wl</i>, <i class="farg">force</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Flush the current transaction to disk and stop using <b class="name">WAPBL</b>. If flushing the transaction fails and <i class="farg">force</i> is zero, return error. If flushing the transaction fails and <i class="farg">force</i> is nonzero, discard the transaction, permanently losing any writes in it. If flushing the transaction is successful or if <i class="farg">force</i> is nonzero, free memory associated with <i class="farg">wl</i> and return zero.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">wapbl_begin</b>(<i class="farg">wl</i>, <i class="farg">file</i>, <i class="farg">line</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Wait for space in the current transaction for new writes, flushing it if necessary, and lock it.<p>
The lock is not exclusive: other threads may lock the transaction too. However, if there is not enough space, another thread will obtain an exclusive lock in order to flush the transaction.<p>
The lock is not recursive: a thread may not acquire it again without calling <i class="farg">wapbl_end</i> first.<p>
May sleep.<p>
<i class="farg">file</i> and <i class="farg">line</i> are the file name and line number of the caller for debugging purposes.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">wapbl_end</b>(<i class="farg">wl</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Unlock the transaction.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">wapbl_flush</b>(<i class="farg">wl</i>, <i class="farg">wait</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Flush the current transaction to disk. If <i class="farg">wait</i> is nonzero, wait for all writes in the current transaction to complete.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">wapbl_discard</b>(<i class="farg">wl</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Discard the current transaction, permanently losing any writes in it.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">wapbl_add_buf</b>(<i class="farg">wl</i>, <i class="farg">bp</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Add the buffer <i class="farg">bp</i> to the current transaction, which must be locked, because someone has asked to write it.<p>
This is meant to be called from within <a class="link-man" href="../9/buffercache">buffercache(9)</a>, not by file systems directly.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">wapbl_remove_buf</b>(<i class="farg">wl</i>, <i class="farg">bp</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Remove the buffer <i class="farg">bp</i>, which must have been added using <i class="farg">wapbl_add_buf</i>, from the current transaction, which must be locked, because it has been invalidated (or XXX ???).<p>
This is meant to be called from within <a class="link-man" href="../9/buffercache">buffercache(9)</a>, not by file systems directly.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">wapbl_resize_buf</b>(<i class="farg">wl</i>, <i class="farg">bp</i>, <i class="farg">oldsz</i>, <i class="farg">oldcnt</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Note that the buffer <i class="farg">bp</i>, which must have been added using <i class="farg">wapbl_add_buf</i>, has changed size, where <i class="farg">oldsz</i> is the previous allocated size in bytes and <i class="farg">oldcnt</i> is the previous number of valid bytes in <i class="farg">bp</i>.<p>
This is meant to be called from within <a class="link-man" href="../9/buffercache">buffercache(9)</a>, not by file systems directly.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">wapbl_register_inode</b>(<i class="farg">wl</i>, <i class="farg">ino</i>, <i class="farg">mode</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Register <i class="farg">ino</i> with the mode <i class="farg">mode</i> as commencing initialization.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">wapbl_unregister_inode</b>(<i class="farg">wl</i>, <i class="farg">ino</i>, <i class="farg">mode</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Unregister <i class="farg">ino</i>, which must have previously been registered with <i class="farg">wapbl_register_inode</i> using the same <i class="farg">mode</i>, now that its initialization has completed.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">wapbl_register_deallocation</b>(<i class="farg">wl</i>, <i class="farg">blk</i>, <i class="farg">len</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Register <i class="farg">len</i> bytes at the disk address <i class="farg">blk</i> as ready for deallocation, so that they will be passed to the <i class="farg">flushfn</i> that was given to <b class="fname">wapbl_start</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">wapbl_jlock_assert</b>(<i class="farg">wl</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Assert that the current transaction is locked.<p>
Note that it might not be locked by the current thread: this assertion passes if <span class="emph">any</span> thread has it locked.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">wapbl_junlock_assert</b>(<i class="farg">wl</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Assert that the current transaction is not exclusively locked by the current thread.<p>
Users of <b class="name">WAPBL</b> observe exclusive locks only in the <i class="farg">flushfn</i> and <i class="farg">flushabortfn</i> callbacks to <b class="fname">wapbl_start</b>(). Outside of such contexts, the transaction is never exclusively locked, even between <b class="fname">wapbl_begin</b>() and <b class="fname">wapbl_end</b>().<p>
There is no way to assert that the current transaction is not locked at all -- i.e., that the caller may lock the transaction with <b class="fname">wapbl_begin</b>() without danger of deadlock.</dd>
</dl>
</div>
<div class="section">
<h1 id="x434f4445205245464552454e434553">CODE REFERENCES</h1> The <b class="name">WAPBL</b> subsystem is implemented in <i class="file">sys/kern/vfs_wapbl.c</i>, with hooks in <i class="file">sys/kern/vfs_bio.c</i>.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../9/buffercache">buffercache(9)</a>, <a class="link-man" href="../9/vfsops">vfsops(9)</a>, <a class="link-man" href="../9/wapbl_replay">wapbl_replay(9)</a></div>
<div class="section">
<h1 id="x42554753">BUGS</h1> <b class="name">WAPBL</b> works only for file system metadata managed via the <a class="link-man" href="../9/buffercache">buffercache(9)</a>, and provides no way to log writes via the page cache, as in <a class="link-man" href="../9/VOP_GETPAGES">VOP_GETPAGES(9)</a>, <a class="link-man" href="../9/VOP_PUTPAGES">VOP_PUTPAGES(9)</a>, and <a class="link-man" href="../9/ubc_uiomove">ubc_uiomove(9)</a>, which is normally used for file data.<p>
Not only is <b class="name">WAPBL</b> unable to log writes via the page cache, it is also unable to defer <a class="link-man" href="../9/buffercache">buffercache(9)</a> writes until cached pages have been written. This manifests as the well-known garbage-data-appended-after-crash bug in FFS: when appending to a file, the pages containing new data may not reach the disk before the inode update reporting its new size. After a crash, the inode update will be on disk, but the new data will not be -- instead, whatever garbage data in the free space will appear to have been appended to the file. <b class="name">WAPBL</b> exacerbates the problem by increasing the throughput of metadata writes, because it can issue many metadata writes asynchronously that FFS without <b class="name">WAPBL</b> would need to issue synchronously in order for <a class="link-man" href="../8/fsck">fsck(8)</a> to work.<p>
The criteria for when the transaction must be flushed to disk before <b class="fname">wapbl_begin</b>() returns are heuristic, i.e. wrong. There is no way for a file system to communicate to <b class="fname">wapbl_begin</b>() how many buffers, inodes, and deallocations it will issue via <b class="name">WAPBL</b> in the transaction.<p>
<b class="name">WAPBL</b> mainly supports write-ahead, and has only limited support for rolling back operations, in the form of <b class="fname">wapbl_register_inode</b>() and <b class="fname">wapbl_unregister_inode</b>(). Consequently, for example, large writes appending to a file, which requires multiple disk block allocations and an inode update, must occur in a single transaction -- there is no way to roll back the disk block allocations if the write fails in the middle, e.g. because of a fault in the middle of the user buffer.<p>
<b class="fname">wapbl_jlock_assert</b>() does not guarantee that the current thread has the current transaction locked. <b class="fname">wapbl_junlock_assert</b>() does not guarantee that the current thread does not have the current transaction locked at all.<p>
There is only one <b class="name">WAPBL</b> transaction for each file system at any given time, and only one <b class="name">WAPBL</b> log on disk. Consequently, all writes are serialized. Extending <b class="name">WAPBL</b> to support multiple logs per file system, partitioned according to an appropriate scheme, is left as an exercise for the reader.<p>
There is no reason for <b class="name">WAPBL</b> to require its own hooks in <a class="link-man" href="../9/buffercache">buffercache(9)</a>.<p>
The on-disk format used by <b class="name">WAPBL</b> is undocumented.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
March 26, 2015</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

