<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
AUTOCONF(9)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
AUTOCONF(9)</td>
<td class="head-vol" align="center">
Kernel Developer's Manual</td>
<td class="head-rtitle" align="right">
AUTOCONF(9)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">autoconf</b>, <b class="name">config_search_loc</b>, <b class="name">config_search_ia</b>, <b class="name">config_found_sm_loc</b>, <b class="name">config_found_ia</b>, <b class="name">config_found</b>, <b class="name">config_match</b>, <b class="name">config_attach_loc</b>, <b class="name">config_attach</b>, <b class="name">config_attach_pseudo</b>, <b class="name">config_detach</b>, <b class="name">config_detach_children</b>, <b class="name">config_deactivate</b>, <b class="name">config_defer</b>, <b class="name">config_interrupts</b>, <b class="name">config_mountroot</b>, <b class="name">config_pending_incr</b>, <b class="name">config_pending_decr</b>, <b class="name">config_finalize_register</b> &#8212; <span class="desc">autoconfiguration framework</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/param.h</a>&gt;</b><br>
<b class="includes">#include &lt;<a class="link-includes">sys/device.h</a>&gt;</b><br>
<b class="includes">#include &lt;<a class="link-includes">sys/errno.h</a>&gt;</b><p>
<i class="ftype">cfdata_t</i><br>
<b class="fname">config_search_loc</b>(<i class="farg" style="white-space:nowrap;">cfsubmatch_t func</i>, <i class="farg" style="white-space:nowrap;">device_t parent</i>, <i class="farg" style="white-space:nowrap;">const char *ia</i>, <i class="farg" style="white-space:nowrap;">const int *locs</i>, <i class="farg" style="white-space:nowrap;">void *aux</i>);<p>
<i class="ftype">cfdata_t</i><br>
<b class="fname">config_search_ia</b>(<i class="farg" style="white-space:nowrap;">cfsubmatch_t func</i>, <i class="farg" style="white-space:nowrap;">device_t parent</i>, <i class="farg" style="white-space:nowrap;">const char *ia</i>, <i class="farg" style="white-space:nowrap;">void *aux</i>);<p>
<i class="ftype">device_t</i><br>
<b class="fname">config_found_sm_loc</b>(<i class="farg" style="white-space:nowrap;">device_t parent</i>, <i class="farg" style="white-space:nowrap;">const char *ia</i>, <i class="farg" style="white-space:nowrap;">const int *locs</i>, <i class="farg" style="white-space:nowrap;">void *aux</i>, <i class="farg" style="white-space:nowrap;">cfprint_t print</i>, <i class="farg" style="white-space:nowrap;">cfsubmatch_t submatch</i>);<p>
<i class="ftype">device_t</i><br>
<b class="fname">config_found_ia</b>(<i class="farg" style="white-space:nowrap;">device_t parent</i>, <i class="farg" style="white-space:nowrap;">const char *ia</i>, <i class="farg" style="white-space:nowrap;">void *aux</i>, <i class="farg" style="white-space:nowrap;">cfprint_t print</i>);<p>
<i class="ftype">device_t</i><br>
<b class="fname">config_found</b>(<i class="farg" style="white-space:nowrap;">device_t parent</i>, <i class="farg" style="white-space:nowrap;">void *aux</i>, <i class="farg" style="white-space:nowrap;">cfprint_t print</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">config_match</b>(<i class="farg" style="white-space:nowrap;">device_t parent</i>, <i class="farg" style="white-space:nowrap;">cfdata_t cf</i>, <i class="farg" style="white-space:nowrap;">void *aux</i>);<p>
<i class="ftype">device_t</i><br>
<b class="fname">config_attach_loc</b>(<i class="farg" style="white-space:nowrap;">device_t parent</i>, <i class="farg" style="white-space:nowrap;">cfdata_t cf</i>, <i class="farg" style="white-space:nowrap;">const int *locs</i>, <i class="farg" style="white-space:nowrap;">void *aux</i>, <i class="farg" style="white-space:nowrap;">cfprint_t print</i>);<p>
<i class="ftype">device_t</i><br>
<b class="fname">config_attach</b>(<i class="farg" style="white-space:nowrap;">device_t parent</i>, <i class="farg" style="white-space:nowrap;">cfdata_t cf</i>, <i class="farg" style="white-space:nowrap;">void *aux</i>, <i class="farg" style="white-space:nowrap;">cfprint_t print</i>);<p>
<i class="ftype">device_t</i><br>
<b class="fname">config_attach_pseudo</b>(<i class="farg" style="white-space:nowrap;">cfdata_t cf</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">config_detach</b>(<i class="farg" style="white-space:nowrap;">device_t dev</i>, <i class="farg" style="white-space:nowrap;">int flags</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">config_detach_children</b>(<i class="farg" style="white-space:nowrap;">device_t dev</i>, <i class="farg" style="white-space:nowrap;">int flags</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">config_deactivate</b>(<i class="farg" style="white-space:nowrap;">device_t dev</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">config_defer</b>(<i class="farg" style="white-space:nowrap;">device_t dev</i>, <i class="farg" style="white-space:nowrap;">void (*func)(device_t)</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">config_interrupts</b>(<i class="farg" style="white-space:nowrap;">device_t dev</i>, <i class="farg" style="white-space:nowrap;">void (*func)(device_t)</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">config_mountroot</b>(<i class="farg" style="white-space:nowrap;">device_t dev</i>, <i class="farg" style="white-space:nowrap;">void (*func)(device_t)</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">config_pending_incr</b>();<p>
<i class="ftype">void</i><br>
<b class="fname">config_pending_decr</b>();<p>
<i class="ftype">int</i><br>
<b class="fname">config_finalize_register</b>(<i class="farg" style="white-space:nowrap;">device_t dev</i>, <i class="farg" style="white-space:nowrap;">int (*func)(device_t)</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> Autoconfiguration is the process of matching hardware devices with an appropriate device driver. In its most basic form, autoconfiguration consists of the recursive process of finding and attaching all devices on a bus, including other busses.<p>
The autoconfiguration framework supports <span class="emph">direct configuration</span> where the bus driver can determine the devices present. The autoconfiguration framework also supports <span class="emph">indirect configuration</span> where the drivers must probe the bus looking for the presence of a device. Direct configuration is preferred since it can find hardware regardless of the presence of proper drivers.<p>
The autoconfiguration process occurs at system bootstrap and is driven by a table generated from a &#8220;machine description&#8221; file by <a class="link-man" href="../1/config">config(1)</a>. For a description of the <a class="link-man" href="../1/config">config(1)</a> &#8220;device definition&#8221; language, see <a class="link-man" href="../9/config">config(9)</a>.<p>
Each device must have a name consisting of an alphanumeric string that ends with a unit number. The unit number identifies an instance of the driver. Device data structures are allocated dynamically during autoconfiguration, giving a unique address for each instance.</div>
<div class="section">
<h1 id="x46554e4354494f4e53">FUNCTIONS</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">config_search_loc</b>(<i class="farg">func</i>, <i class="farg">parent</i>, <i class="farg">ia</i>, <i class="farg">locs</i>, <i class="farg">aux</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Performs indirect configuration of physical devices. <b class="fname">config_search_loc</b>() iterates over all potential children, calling the given function <i class="farg">func</i> for each one. If <i class="farg">func</i> is <span class="define">NULL</span>, <b class="fname">config_search_loc</b>() applies each child's match function instead. The argument <i class="farg">parent</i> is the pointer to the parent's device structure. The argument <i class="farg">ia</i> is the interface attribute on which the potential children should attach. It can be <span class="define">NULL</span>, in which case all children attaching to any attribute are considered. The <i class="farg">locs</i> argument lists the locator values for the device and are passed to function <i class="farg">func</i>. The given <i class="farg">aux</i> argument describes the device that has been found and is simply passed on through <i class="farg">func</i> to the child. <b class="fname">config_search_loc</b>() returns a pointer to the best-matched child or <span class="define">NULL</span> otherwise.<p>
The role of <i class="farg">func</i> is to call the match function for each device and call <b class="fname">config_attach_loc</b>() for any positive matches. If <i class="farg">func</i> is <span class="define">NULL</span>, then the parent should record the return value from <b class="fname">config_search_loc</b>() and call <b class="fname">config_attach_loc</b>() itself.<p>
Note that this function is designed so that it can be used to apply an arbitrary function to all potential children. In this case callers may choose to ignore the return value.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">config_search_ia</b>(<i class="farg">func</i>, <i class="farg">parent</i>, <i class="farg">ia</i>, <i class="farg">aux</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
This function is equivalent to calling <b class="fname">config_search_loc</b>(<i class="farg">func</i>, <i class="farg">parent</i>, <i class="farg">ia</i>, <i class="farg">locs</i>, <i class="farg">aux</i>) with <i class="farg">locs</i> set to <span class="define">NULL</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">config_found_sm_loc</b>(<i class="farg">parent</i>, <i class="farg">ia</i>, <i class="farg">locs</i>, <i class="farg">aux</i>, <i class="farg">print</i>, <i class="farg">submatch</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Performs direct configuration on a physical device. <b class="fname">config_found_sm_loc</b>() is called by the parent and in turn calls the <i class="farg">submatch</i> function to call the match function as determined by the configuration table. If <i class="farg">submatch</i> is <span class="define">NULL</span>, the driver match functions are called directly. The argument <i class="farg">parent</i> is the pointer to the parent's device structure. The argument <i class="farg">ia</i> is the name of the interface attribute on which the child will attach, per <a class="link-man" href="../5/config">config(5)</a> syntax. The argument <i class="farg">locs</i> lists the locator values for the device. The given <i class="farg">aux</i> argument describes the device that has been found. <b class="fname">config_found_sm_loc</b>() internally uses <b class="fname">config_search_loc</b>(), passing on <i class="farg">submatch</i>, <i class="farg">ia</i>, <i class="farg">locs</i> and <i class="farg">aux</i>. The <span class="emph">softc</span> structure for the matched device will be allocated, and the appropriate driver attach function will be called. If the device is matched, the system prints the name of the child and parent devices, and then calls the <i class="farg">print</i> function to produce additional information if desired. If no driver takes a match, the same <i class="farg">print</i> function is called to complain. The print function is called with the <i class="farg">aux</i> argument and, if the matches failed, the full name (including unit number) of the parent device, otherwise <span class="define">NULL</span>. The <i class="farg">print</i> function must return an integer value.<p>
Two special strings, &#8220;not configured&#8221; and &#8220;unsupported&#8221; will be appended automatically to non-driver reports if the return value is UNCONF or UNSUPP respectively; otherwise the function should return the value QUIET.<p>
<b class="fname">config_found_sm_loc</b>() returns a pointer to the attached device's <span class="emph">softc</span> structure if the device is attached, <span class="define">NULL</span> otherwise. Most callers can ignore this value, since the system will already have printed a diagnostic.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">config_found_ia</b>(<i class="farg">parent</i>, <i class="farg">ia</i>, <i class="farg">aux</i>, <i class="farg">print</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
This function is equivalent to calling <b class="fname">config_found_sm_loc</b>(<i class="farg">parent</i>, <i class="farg">ia</i>, <i class="farg">locs</i>, <i class="farg">aux</i>, <i class="farg">print</i>, <i class="farg">submatch</i>) with <i class="farg">locs</i> and <i class="farg">submatch</i> set to <span class="define">NULL</span>. It is provided for better source code readability with locator-less device buses.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">config_found</b>(<i class="farg">parent</i>, <i class="farg">aux</i>, <i class="farg">print</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
This function is equivalent to calling <b class="fname">config_found_sm_loc</b>(<i class="farg">parent</i>, <i class="farg">ia</i>, <i class="farg">locs</i>, <i class="farg">aux</i>, <i class="farg">print</i>, <i class="farg">submatch</i>) with <i class="farg">ia</i>, <i class="farg">locs</i> and <i class="farg">submatch</i> set to <span class="define">NULL</span> and is provided for compatibility with older drivers. New code should either make the interface attribute explicit or prefer an indirect method based on <b class="fname">config_search_loc</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">config_match</b>(<i class="farg">parent</i>, <i class="farg">cf</i>, <i class="farg">aux</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Match a device. Invokes the drivers match function according to the configuration table. The <b class="fname">config_match</b>() function returns a nonzero integer indicating the confidence of supporting this device and a value of 0 if the driver doesn't support the device.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">config_attach_loc</b>(<i class="farg">parent</i>, <i class="farg">cf</i>, <i class="farg">locs</i>, <i class="farg">aux</i>, <i class="farg">print</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Attach a found device. Allocates the memory for the <span class="emph">softc</span> structure and calls the drivers attach function according to the configuration table. If successful, <b class="fname">config_attach_loc</b>() returns the <span class="emph">softc</span>. If unsuccessful, it returns <span class="define">NULL</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">config_attach</b>(<i class="farg">parent</i>, <i class="farg">cf</i>, <i class="farg">aux</i>, <i class="farg">print</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
This function is equivalent to calling <b class="fname">config_attach_loc</b>(<i class="farg">parent</i>, <i class="farg">cf</i>, <i class="farg">locs</i>, <i class="farg">aux</i>, <i class="farg">print</i>) with <i class="farg">locs</i> set to <span class="define">NULL</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">config_attach_pseudo</b>(<i class="farg">cf</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Create an instance of a pseudo-device driver. <a class="link-man" href="../5/config">config(5)</a> syntax allows the creation of pseudo-devices from which regular <i class="ftype">device_t</i> instances can be created. Such objects are similar to the devices that attach at the root of the device tree.<p>
The caller is expected to allocate and fill the <i class="ftype">cfdata_t</i> object and pass it to <b class="fname">config_attach_pseudo</b>(). The content of that object is similar to what is returned by <b class="fname">config_search_loc</b>() for regular devices.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">config_detach</b>(<i class="farg">dev</i>, <i class="farg">flags</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Called by the parent to detach the child device. The second argument <span class="emph">flags</span> contains detachment flags. Valid values are DETACH_FORCE (force detachment (e.g., because of hardware removal)) and DETACH_QUIET (do not print a notice). <b class="fname">config_detach</b>() returns zero if successful and an error code otherwise. <b class="fname">config_detach</b>() is always called from a thread context, allowing condition variables to be used while the device detaches itself.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">config_detach_children</b>(<i class="farg">dev</i>, <i class="farg">flags</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Iterate through all attached devices, calling <b class="fname">config_detach</b>() for each child of <i class="farg">dev</i>, passing <i class="farg">flags</i>. If detaching any child results in an error, the iteration will halt and any remaining devices will not be detached. <b class="fname">config_detach_children</b>() returns zero if successful and an error code otherwise.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">config_deactivate</b>(<i class="farg">dev</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Called by the parent to deactivate the child device <i class="farg">dev</i>. <b class="fname">config_deactivate</b>() is called from interrupt context to immediately relinquish resources and notify dependent kernel subsystems that the device is about to be detached. At some later point <b class="fname">config_detach</b>() will be called to finalise the removal of the device.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">config_defer</b>(<i class="farg">dev</i>, <i class="farg">func</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Called by the child to defer the remainder of its configuration until all its parent's devices have been attached. At this point, the function <i class="farg">func</i> is called with the argument <i class="farg">dev</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">config_interrupts</b>(<i class="farg">dev</i>, <i class="farg">func</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Called by the child to defer the remainder of its configuration until interrupts are enabled. At this point, the function <i class="farg">func</i> is called with the argument <i class="farg">dev</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">config_mountroot</b>(<i class="farg">dev</i>, <i class="farg">func</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Called by the child to defer the remainder of its configuration until the root file system is mounted. At this point, the function <i class="farg">func</i> is called with the argument <i class="farg">dev</i>. This is used for devices that need to load firmware image from a mounted file system.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">config_pending_incr</b>()</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Increment the <b class="var">config_pending</b> semaphore. It is used to account for deferred configurations before mounting the root file system.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">config_pending_decr</b>()</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Decrement the <b class="var">config_pending</b> semaphore. It is used to account for deferred configurations before mounting the root file system.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">config_finalize_register</b>(<i class="farg">dev</i>, <i class="farg">func</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Register a function to be called after all real devices have been found.<p>
Registered functions are all executed until all of them return 0. The callbacks should return 0 to indicate they do not require to be called another time, but they should be aware that they still might be in case one of them returns 1.</dd>
</dl>
</div>
<div class="section">
<h1 id="x434f4445205245464552454e434553">CODE REFERENCES</h1> The autoconfiguration framework itself is implemented within the file <i class="file">sys/kern/subr_autoconf.c</i>. Data structures and function prototypes for the framework are located in <i class="file">sys/sys/device.h</i>.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../1/config">config(1)</a>, <a class="link-man" href="../5/config">config(5)</a>, <a class="link-man" href="../9/condvar">condvar(9)</a>, <a class="link-man" href="../9/config">config(9)</a>, <a class="link-man" href="../9/driver">driver(9)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> Autoconfiguration first appeared in <span class="unix">4.1BSD</span>. The autoconfiguration framework was completely revised in <span class="unix">4.4BSD</span>. The detach and deactivate interfaces appeared in <span class="unix">NetBSD&#160;1.5</span>.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
February 17, 2012</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

