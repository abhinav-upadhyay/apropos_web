<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/../4/strict.dtd">
>
<head>
<meta http-equiv="Content-Type" content="te../; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
BUS_SPACE(9)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
BUS_SPACE(9)</td>
<td class="head-vol" align="center">
Kernel Developer's Manual</td>
<td class="head-rtitle" align="right">
BUS_SPACE(9)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">bus_space</b>, <b class="name">bus_space_barrier</b>, <b class="name">bus_space_copy_region_1</b>, <b class="name">bus_space_copy_region_2</b>, <b class="name">bus_space_copy_region_4</b>, <b class="name">bus_space_copy_region_8</b>, <b class="name">bus_space_free</b>, <b class="name">bus_space_handle_is_equal</b>, <b class="name">bus_space_is_equal</b>, <b class="name">bus_space_map</b>, <b class="name">bus_space_mmap</b>, <b class="name">bus_space_peek_1</b>, <b class="name">bus_space_peek_2</b>, <b class="name">bus_space_peek_4</b>, <b class="name">bus_space_peek_8</b>, <b class="name">bus_space_poke_1</b>, <b class="name">bus_space_poke_2</b>, <b class="name">bus_space_poke_4</b>, <b class="name">bus_space_poke_8</b>, <b class="name">bus_space_read_1</b>, <b class="name">bus_space_read_2</b>, <b class="name">bus_space_read_4</b>, <b class="name">bus_space_read_8</b>, <b class="name">bus_space_read_multi_1</b>, <b class="name">bus_space_read_multi_2</b>, <b class="name">bus_space_read_multi_4</b>, <b class="name">bus_space_read_multi_8</b>, <b class="name">bus_space_read_multi_stream_1</b>, <b class="name">bus_space_read_multi_stream_2</b>, <b class="name">bus_space_read_multi_stream_4</b>, <b class="name">bus_space_read_multi_stream_8</b>, <b class="name">bus_space_read_region_1</b>, <b class="name">bus_space_read_region_2</b>, <b class="name">bus_space_read_region_4</b>, <b class="name">bus_space_read_region_8</b>, <b class="name">bus_space_read_region_stream_1</b>, <b class="name">bus_space_read_region_stream_2</b>, <b class="name">bus_space_read_region_stream_4</b>, <b class="name">bus_space_read_region_stream_8</b>, <b class="name">bus_space_read_stream_1</b>, <b class="name">bus_space_read_stream_2</b>, <b class="name">bus_space_read_stream_4</b>, <b class="name">bus_space_read_stream_8</b>, <b class="name">bus_space_release</b>, <b class="name">bus_space_reservation_addr</b>, <b class="name">bus_space_reservation_init</b>, <b class="name">bus_space_reservation_size</b>, <b class="name">bus_space_reservation_map</b>, <b class="name">bus_space_reservation_unmap</b>, <b class="name">bus_space_reserve</b>, <b class="name">bus_space_reserve_subregion</b>, <b class="name">bus_space_set_region_1</b>, <b class="name">bus_space_set_region_2</b>, <b class="name">bus_space_set_region_4</b>, <b class="name">bus_space_set_region_8</b>, <b class="name">bus_space_subregion</b>, <b class="name">bus_space_tag_create</b>, <b class="name">bus_space_tag_destroy</b>, <b class="name">bus_space_unmap</b>, <b class="name">bus_space_vaddr</b>, <b class="name">bus_space_write_1</b>, <b class="name">bus_space_write_2</b>, <b class="name">bus_space_write_4</b>, <b class="name">bus_space_write_8</b>, <b class="name">bus_space_write_multi_1</b>, <b class="name">bus_space_write_multi_2</b>, <b class="name">bus_space_write_multi_4</b>, <b class="name">bus_space_write_multi_8</b>, <b class="name">bus_space_write_multi_stream_1</b>, <b class="name">bus_space_write_multi_stream_2</b>, <b class="name">bus_space_write_multi_stream_4</b>, <b class="name">bus_space_write_multi_stream_8</b>, <b class="name">bus_space_write_region_1</b>, <b class="name">bus_space_write_region_2</b>, <b class="name">bus_space_write_region_4</b>, <b class="name">bus_space_write_region_8</b>, <b class="name">bus_space_write_region_stream_1</b>, <b class="name">bus_space_write_region_stream_2</b>, <b class="name">bus_space_write_region_stream_4</b>, <b class="name">bus_space_write_region_stream_8</b>, <b class="name">bus_space_write_stream_1</b>, <b class="name">bus_space_write_stream_2</b>, <b class="name">bus_space_write_stream_4</b>, <b class="name">bus_space_write_stream_8</b> &#8212; <span class="desc">bus space manipulation functions</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/bus.h</a>&gt;</b><p>
<i class="ftype">bool</i><br>
<b class="fname">bus_space_handle_is_equal</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle1</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle2</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">bus_space_is_equal</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space1</i>, <i class="farg" style="white-space:nowrap;">bus_space_tag_t space2</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_release</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t t</i>, <i class="farg" style="white-space:nowrap;">bus_space_reservation_t *bsr</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">bus_space_reserve</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t t</i>, <i class="farg" style="white-space:nowrap;">bus_addr_t bpa</i>, <i class="farg" style="white-space:nowrap;">bus_size_t size</i>, <i class="farg" style="white-space:nowrap;">int flags</i>, <i class="farg" style="white-space:nowrap;">bus_space_reservation_t *bsrp</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">bus_space_reserve_subregion</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t t</i>, <i class="farg" style="white-space:nowrap;">bus_addr_t reg_start</i>, <i class="farg" style="white-space:nowrap;">bus_addr_t reg_end</i>, <i class="farg" style="white-space:nowrap;">bus_size_t size</i>, <i class="farg" style="white-space:nowrap;">bus_size_t alignment</i>, <i class="farg" style="white-space:nowrap;">bus_size_t boundary</i>, <i class="farg" style="white-space:nowrap;">int flags</i>, <i class="farg" style="white-space:nowrap;">bus_space_reservation_t *bsrp</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_reservation_init</b>(<i class="farg" style="white-space:nowrap;">bus_space_reservation_t *bsr</i>, <i class="farg" style="white-space:nowrap;">bus_addr_t addr</i>, <i class="farg" style="white-space:nowrap;">bus_size_t size</i>);<p>
<i class="ftype">bus_size_t</i><br>
<b class="fname">bus_space_reservation_size</b>(<i class="farg" style="white-space:nowrap;">bus_space_reservation_t *bsr</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">bus_space_reservation_map</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t t</i>, <i class="farg" style="white-space:nowrap;">bus_space_reservation_t *bsr</i>, <i class="farg" style="white-space:nowrap;">int flags</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t *bshp</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_reservation_unmap</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t t</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t bsh</i>, <i class="farg" style="white-space:nowrap;">bus_size_t size</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">bus_space_map</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_addr_t address</i>, <i class="farg" style="white-space:nowrap;">bus_size_t size</i>, <i class="farg" style="white-space:nowrap;">int flags</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t *handlep</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_unmap</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t size</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">bus_space_subregion</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">bus_size_t size</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t *nhandlep</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">bus_space_alloc</b>(<i class="farg">bus_space_tag_t space</i>, <i class="farg">bus_addr_t reg_start</i>, <i class="farg">bus_addr_t reg_end</i>, <i class="farg">bus_size_t size</i>, <i class="farg">bus_size_t alignment</i>, <i class="farg">bus_size_t boundary</i>, <i class="farg">int flags</i>, <i class="farg">bus_addr_t *addrp</i>, <i class="farg">bus_space_handle_t *handlep</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_free</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t size</i>);<p>
<i class="ftype">void *</i><br>
<b class="fname">bus_space_vaddr</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>);<p>
<i class="ftype">paddr_t</i><br>
<b class="fname">bus_space_mmap</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_addr_t addr</i>, <i class="farg" style="white-space:nowrap;">off_t off</i>, <i class="farg" style="white-space:nowrap;">int prot</i>, <i class="farg" style="white-space:nowrap;">int flags</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">bus_space_tag_create</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t obst</i>, <i class="farg" style="white-space:nowrap;">uint64_t present</i>, <i class="farg" style="white-space:nowrap;">uint64_t extpresent</i>, <i class="farg" style="white-space:nowrap;">const struct bus_space_overrides *ov</i>, <i class="farg" style="white-space:nowrap;">void *ctx</i>, <i class="farg" style="white-space:nowrap;">bus_space_tag_t *bstp</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_tag_destroy</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t bst</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">bus_space_peek_1</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">uint8_t *datap</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">bus_space_peek_2</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">uint16_t *datap</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">bus_space_peek_4</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">uint32_t *datap</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">bus_space_peek_8</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">uint64_t *datap</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">bus_space_poke_1</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">uint8_t data</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">bus_space_poke_2</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">uint16_t data</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">bus_space_poke_4</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">uint32_t data</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">bus_space_poke_8</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">uint64_t data</i>);<p>
<i class="ftype">uint8_t</i><br>
<b class="fname">bus_space_read_1</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>);<p>
<i class="ftype">uint16_t</i><br>
<b class="fname">bus_space_read_2</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>);<p>
<i class="ftype">uint32_t</i><br>
<b class="fname">bus_space_read_4</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>);<p>
<i class="ftype">uint64_t</i><br>
<b class="fname">bus_space_read_8</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_write_1</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">uint8_t value</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_write_2</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">uint16_t value</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_write_4</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">uint32_t value</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_write_8</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">uint64_t value</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_barrier</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">bus_size_t length</i>, <i class="farg" style="white-space:nowrap;">int flags</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_read_region_1</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">uint8_t *datap</i>, <i class="farg" style="white-space:nowrap;">bus_size_t count</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_read_region_2</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">uint16_t *datap</i>, <i class="farg" style="white-space:nowrap;">bus_size_t count</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_read_region_4</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">uint32_t *datap</i>, <i class="farg" style="white-space:nowrap;">bus_size_t count</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_read_region_8</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">uint64_t *datap</i>, <i class="farg" style="white-space:nowrap;">bus_size_t count</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_read_region_stream_1</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">uint8_t *datap</i>, <i class="farg" style="white-space:nowrap;">bus_size_t count</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_read_region_stream_2</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">uint16_t *datap</i>, <i class="farg" style="white-space:nowrap;">bus_size_t count</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_read_region_stream_4</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">uint32_t *datap</i>, <i class="farg" style="white-space:nowrap;">bus_size_t count</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_read_region_stream_8</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">uint64_t *datap</i>, <i class="farg" style="white-space:nowrap;">bus_size_t count</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_write_region_1</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">const uint8_t *datap</i>, <i class="farg" style="white-space:nowrap;">bus_size_t count</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_write_region_2</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">const uint16_t *datap</i>, <i class="farg" style="white-space:nowrap;">bus_size_t count</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_write_region_4</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">const uint32_t *datap</i>, <i class="farg" style="white-space:nowrap;">bus_size_t count</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_write_region_8</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">const uint64_t *datap</i>, <i class="farg" style="white-space:nowrap;">bus_size_t count</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_write_region_stream_1</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">const uint8_t *datap</i>, <i class="farg" style="white-space:nowrap;">bus_size_t count</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_write_region_stream_2</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">const uint16_t *datap</i>, <i class="farg" style="white-space:nowrap;">bus_size_t count</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_write_region_stream_4</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">const uint32_t *datap</i>, <i class="farg" style="white-space:nowrap;">bus_size_t count</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_write_region_stream_8</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">const uint64_t *datap</i>, <i class="farg" style="white-space:nowrap;">bus_size_t count</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_copy_region_1</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t srchandle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t srcoffset</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t dsthandle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t dstoffset</i>, <i class="farg" style="white-space:nowrap;">bus_size_t count</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_copy_region_2</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t srchandle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t srcoffset</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t dsthandle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t dstoffset</i>, <i class="farg" style="white-space:nowrap;">bus_size_t count</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_copy_region_4</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t srchandle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t srcoffset</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t dsthandle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t dstoffset</i>, <i class="farg" style="white-space:nowrap;">bus_size_t count</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_copy_region_8</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t srchandle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t srcoffset</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t dsthandle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t dstoffset</i>, <i class="farg" style="white-space:nowrap;">bus_size_t count</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_set_region_1</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">uint8_t value</i>, <i class="farg" style="white-space:nowrap;">bus_size_t count</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_set_region_2</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">uint16_t value</i>, <i class="farg" style="white-space:nowrap;">bus_size_t count</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_set_region_4</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">uint32_t value</i>, <i class="farg" style="white-space:nowrap;">bus_size_t count</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_set_region_8</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">uint64_t value</i>, <i class="farg" style="white-space:nowrap;">bus_size_t count</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_read_multi_1</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">uint8_t *datap</i>, <i class="farg" style="white-space:nowrap;">bus_size_t count</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_read_multi_2</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">uint16_t *datap</i>, <i class="farg" style="white-space:nowrap;">bus_size_t count</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_read_multi_4</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">uint32_t *datap</i>, <i class="farg" style="white-space:nowrap;">bus_size_t count</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_read_multi_8</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">uint64_t *datap</i>, <i class="farg" style="white-space:nowrap;">bus_size_t count</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_read_multi_stream_1</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">uint8_t *datap</i>, <i class="farg" style="white-space:nowrap;">bus_size_t count</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_read_multi_stream_2</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">uint16_t *datap</i>, <i class="farg" style="white-space:nowrap;">bus_size_t count</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_read_multi_stream_4</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">uint32_t *datap</i>, <i class="farg" style="white-space:nowrap;">bus_size_t count</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_read_multi_stream_8</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">uint64_t *datap</i>, <i class="farg" style="white-space:nowrap;">bus_size_t count</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_write_multi_1</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">const uint8_t *datap</i>, <i class="farg" style="white-space:nowrap;">bus_size_t count</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_write_multi_2</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">const uint16_t *datap</i>, <i class="farg" style="white-space:nowrap;">bus_size_t count</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_write_multi_4</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">const uint32_t *datap</i>, <i class="farg" style="white-space:nowrap;">bus_size_t count</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_write_multi_8</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">const uint64_t *datap</i>, <i class="farg" style="white-space:nowrap;">bus_size_t count</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_write_multi_stream_1</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">const uint8_t *datap</i>, <i class="farg" style="white-space:nowrap;">bus_size_t count</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_write_multi_stream_2</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">const uint16_t *datap</i>, <i class="farg" style="white-space:nowrap;">bus_size_t count</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_write_multi_stream_4</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">const uint32_t *datap</i>, <i class="farg" style="white-space:nowrap;">bus_size_t count</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bus_space_write_multi_stream_8</b>(<i class="farg" style="white-space:nowrap;">bus_space_tag_t space</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t handle</i>, <i class="farg" style="white-space:nowrap;">bus_size_t offset</i>, <i class="farg" style="white-space:nowrap;">const uint64_t *datap</i>, <i class="farg" style="white-space:nowrap;">bus_size_t count</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <b class="name">bus_space</b> functions exist to allow device drivers machine-independent access to bus memory and register areas. All of the functions and types described in this document can be used by including the <b class="includes">&lt;<a class="link-includes">sys/bus.h</a>&gt;</b> header file.<p>
Many common devices are used on multiple architectures, but are accessed differently on each because of architectural constraints. For instance, a device which is mapped in one system's I/O space may be mapped in memory space on a second system. On a third system, architectural limitations might change the way registers need to be accessed (e.g., creating a non-linear register space). In some cases, a single driver may need to access the same type of device in multiple ways in a single system or architecture. The goal of the <b class="name">bus_space</b> functions is to allow a single driver source file to manipulate a set of devices on different system architectures, and to allow a single driver object file to manipulate a set of devices on multiple bus types on a single architecture.<p>
Not all busses have to implement all functions described in this document, though that is encouraged if the operations are logically supported by the bus. Unimplemented functions should cause compile-time errors if possible.<p>
All of the interface definitions described in this document are shown as function prototypes and discussed as if they were required to be functions. Implementations are encouraged to implement prototyped (type-checked) versions of these interfaces, but may implement them as macros if appropriate. Machine-dependent types, variables, and functions should be marked clearly in <b class="includes">&lt;<a class="link-includes">machine/bus_defs.h</a>&gt;</b> and in <b class="includes">&lt;<a class="link-includes">machine/bus_funcs.h</a>&gt;</b> to avoid confusion with the machine-independent types and functions, and, if possible, should be given names which make the machine-dependence clear.</div>
<div class="section">
<h1 id="x434f4e434550545320414e442047554944454c494e4553">CONCEPTS AND GUIDELINES</h1> Bus spaces are described by bus space tags, which can be created only by machine-dependent code. A given machine may have several different types of bus space (e.g., memory space and I/O space), and thus may provide multiple different bus space tags. Individual busses or devices on a machine may use more than one bus space tag. For instance, ISA devices are given an ISA memory space tag and an ISA I/O space tag. Architectures may have several different tags which represent the same type of space, for instance because of multiple different host bus interface chipsets.<p>
A range in bus space is described by a bus address and a bus size. The bus address describes the start of the range in bus space. The bus size describes the size of the range in bytes. Busses which are not byte addressable may require use of bus space ranges with appropriately aligned addresses and properly rounded sizes.<p>
Access to regions of bus space is facilitated by use of bus space handles, which are usually created by mapping a specific range of a bus space. Handles may also be created by allocating and mapping a range of bus space, the actual location of which is picked by the implementation within bounds specified by the caller of the allocation function.<p>
All of the bus space access functions require one bus space tag argument, at least one handle argument, and at least one offset argument (a bus size). The bus space tag specifies the space, each handle specifies a region in the space, and each offset specifies the offset into the region of the actual location(s) to be accessed. Offsets are given in bytes, though busses may impose alignment constraints. The offset used to access data relative to a given handle must be such that all of the data being accessed is in the mapped region that the handle describes. Trying to access data outside that region is an error.<p>
Because some architectures' memory systems use buffering to improve memory and device access performance, there is a mechanism which can be used to create &#8220;barriers&#8221; in the bus space read and write stream.<p>
There are two types of barriers: ordering barriers and completion barriers.<p>
Ordering barriers prevent some operations from bypassing other operations. They are relatively light weight and described in terms of the operations they are intended to order. The important thing to note is that they create specific ordering constraint surrounding bus accesses but do not necessarily force any synchronization themselves. So, if there is enough distance between the memory operations being ordered, the preceding ones could complete by themselves resulting in no performance penalty.<p>
For instance, a write before read barrier will force any writes issued before the barrier instruction to complete before any reads after the barrier are issued. This forces processors with write buffers to read data from memory rather than from the pending write in the write buffer.<p>
Ordering barriers are usually sufficient for most circumstances, and can be combined together. For instance a read before write barrier can be combined with a write before write barrier to force all memory operations to complete before the next write is started.<p>
Completion barriers force all memory operations and any pending exceptions to be completed before any instructions after the barrier may be issued. Completion barriers are extremely expensive and almost never required in device driver code. A single completion barrier can force the processor to stall on memory for hundreds of cycles on some machines.<p>
Correctly-written drivers will include all appropriate barriers, and assume only the read/write ordering imposed by the barrier operations.<p>
People trying to write portable drivers with the <b class="name">bus_space</b> functions should try to make minimal assumptions about what the system allows. In particular, they should expect that the system requires bus space addresses being accessed to be naturally aligned (i.e., base address of handle added to offset is a multiple of the access size), and that the system does alignment checking on pointers (i.e., pointer to objects being read and written must point to properly-aligned data).<p>
The descriptions of the <b class="name">bus_space</b> functions given below all assume that they are called with proper arguments. If called with invalid arguments or arguments that are out of range (e.g., trying to access data outside of the region mapped when a given handle was created), undefined behaviour results. In that case, they may cause the system to halt, either intentionally (via panic) or unintentionally (by causing a fatal trap or by some other means) or may cause improper operation which is not immediately fatal. Functions which return void or which return data read from bus space (i.e., functions which don't obviously return an error code) do not fail. They could only fail if given invalid arguments, and in that case their behaviour is undefined. Functions which take a count of bytes have undefined results if the specified <i class="farg">count</i> is zero.</div>
<div class="section">
<h1 id="x5459504553">TYPES</h1> Several types are defined in <b class="includes">&lt;<a class="link-includes">machine/bus_defs.h</a>&gt;</b> to facilitate use of the <b class="name">bus_space</b> functions by drivers.<p>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-ohang">
<dt class="list-ohang" style="margin-top: 0.00em;">
<i class="farg">bus_addr_t</i></dt>
<dd class="list-ohang">
<p>
The <i class="farg">bus_addr_t</i> type is used to describe bus addresses. It must be an unsigned integral type capable of holding the largest bus address usable by the architecture. This type is primarily used when mapping and unmapping bus space.<p>
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<i class="farg">bus_size_t</i></dt>
<dd class="list-ohang">
<p>
The <i class="farg">bus_size_t</i> type is used to describe sizes of ranges in bus space. It must be an unsigned integral type capable of holding the size of the largest bus address range usable on the architecture. This type is used by virtually all of the <b class="name">bus_space</b> functions, describing sizes when mapping regions and offsets into regions when performing space access operations.<p>
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<i class="farg">bus_space_tag_t</i></dt>
<dd class="list-ohang">
<p>
The <i class="farg">bus_space_tag_t</i> type is used to describe a particular bus space on a machine. Its contents are machine-dependent and should be considered opaque by machine-independent code. This type is used by all <b class="name">bus_space</b> functions to name the space on which they're operating.<p>
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<i class="farg">bus_space_handle_t</i></dt>
<dd class="list-ohang">
<p>
The <i class="farg">bus_space_handle_t</i> type is used to describe a mapping of a range of bus space. Its contents are machine-dependent and should be considered opaque by machine-independent code. This type is used when performing bus space access operations.<p>
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<i class="farg">bus_space_reservation_t</i></dt>
<dd class="list-ohang">
<p>
The <i class="farg">bus_space_reservation_t</i> type is used to describe a range of bus space. It logically consists of a <i class="farg">bus_addr_t</i>, the first address in the range, and a <i class="farg">bus_size_t</i>, the length in bytes of the range. Machine-independent code creates and interrogates a <i class="farg">bus_space_reservation_t</i> using a constructor, <b class="fname">bus_space_reservation_init</b>(), and accessor functions, <b class="fname">bus_space_reservation_addr</b>() and <b class="fname">bus_space_reservation_size</b>().</dd>
</dl>
</div>
<div class="section">
<h1 id="x434f4d504152494e47204255532053504143452054414753">COMPARING BUS SPACE TAGS</h1> To check whether or not one <i class="farg">bus_space_tag_t</i> refers to the same space as another in machine-independent code, do not use either <a class="link-man" href="../9/memcmp">memcmp(9)</a> or the C equals (==) operator. Use <b class="fname">bus_space_is_equal</b>(), instead.</div>
<div class="section">
<h1 id="x4d415050494e4720414e4420554e4d415050494e4720425553205350414345">MAPPING AND UNMAPPING BUS SPACE</h1> Bus space must be mapped before it can be used, and should be unmapped when it is no longer needed. The <b class="fname">bus_space_map</b>(), <b class="fname">bus_space_reservation_map</b>(), <b class="fname">bus_space_reservation_unmap</b>(), and <b class="fname">bus_space_unmap</b>() functions provide these capabilities.<p>
Some drivers need to be able to pass a subregion of already-mapped bus space to another driver or module within a driver. The <b class="fname">bus_space_subregion</b>() function allows such subregions to be created.<p>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-ohang">
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_map</b>(<i class="farg">space</i>, <i class="farg">address</i>, <i class="farg">size</i>, <i class="farg">flags</i>, <i class="farg">handlep</i>)</dt>
<dd class="list-ohang">
<p>
The <b class="fname">bus_space_map</b>() function exclusively reserves and maps the region of bus space named by the <i class="farg">space</i>, <i class="farg">address</i>, and <i class="farg">size</i> arguments. If successful, it returns zero and fills in the bus space handle pointed to by <i class="farg">handlep</i> with the handle that can be used to access the mapped region. If unsuccessful, it will return non-zero and leave the bus space handle pointed to by <i class="farg">handlep</i> in an undefined state.<p>
The <i class="farg">flags</i> argument controls how the space is to be mapped. Supported flags include:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">BUS_SPACE_MAP_CACHEABLE</span></dt>
<dd class="list-tag" style="margin-left: 23.00ex;">
Try to map the space so that accesses can be cached by the system cache. If this flag is not specified, the implementation should map the space so that it will not be cached. This mapping method will only be useful in very rare occasions.<p>
This flag must have a value of 1 on all implementations for backward compatibility.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">BUS_SPACE_MAP_PREFETCHABLE</span></dt>
<dd class="list-tag" style="margin-left: 23.00ex;">
Try to map the space so that accesses can be prefetched by the system, and writes can be buffered. This means, accesses should be side effect free (idempotent). The <b class="fname">bus_space_barrier</b>() methods will flush the write buffer or force actual read accesses. If this flag is not specified, the implementation should map the space so that it will not be prefetched or delayed.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">BUS_SPACE_MAP_LINEAR</span></dt>
<dd class="list-tag" style="margin-left: 23.00ex;">
Try to map the space so that its contents can be accessed linearly via normal memory access methods (e.g., pointer dereferencing and structure accesses). The <b class="fname">bus_space_vaddr</b>() method can be used to obtain the kernel virtual address of the mapped range. This is useful when software wants to do direct access to a memory device, e.g., a frame buffer. If this flag is specified and linear mapping is not possible, the <b class="fname">bus_space_map</b>() call should fail. If this flag is not specified, the system may map the space in whatever way is most convenient. Use of this mapping method is not encouraged for normal device access; where linear access is not essential, use of the <b class="fname">bus_space_read/write</b>() methods is strongly recommended.</dd>
</dl>
<p>
Not all combinations of flags make sense or are supported with all spaces. For instance, <span class="define">BUS_SPACE_MAP_CACHEABLE</span> may be meaningless when used on many systems' I/O port spaces, and on some systems <span class="define">BUS_SPACE_MAP_LINEAR</span> without <span class="define">BUS_SPACE_MAP_PREFETCHABLE</span> may never work. When the system hardware or firmware provides hints as to how spaces should be mapped (e.g., the PCI memory mapping registers' "prefetchable" bit), those hints should be followed for maximum compatibility. On some systems, requesting a mapping that cannot be satisfied (e.g., requesting a non-prefetchable mapping when the system can only provide a prefetchable one) will cause the request to fail.<p>
Some implementations may keep track of use of bus space for some or all bus spaces and refuse to allow duplicate allocations. This is encouraged for bus spaces which have no notion of slot-specific space addressing, such as ISA and VME, and for spaces which coexist with those spaces (e.g., EISA and PCI memory and I/O spaces co-existing with ISA memory and I/O spaces).<p>
Mapped regions may contain areas for which there is no device on the bus. If space in those areas is accessed, the results are bus-dependent.<p>
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_reservation_map</b>(<i class="farg">space</i>, <i class="farg">bsr</i>, <i class="farg">flags</i>, <i class="farg">handlep</i>)</dt>
<dd class="list-ohang">
<p>
The <b class="fname">bus_space_reservation_map</b>() function is similar to <b class="fname">bus_space_map</b>() but it maps a region of bus space that was previously reserved by a call to <b class="fname">bus_space_reserve</b>() or <b class="fname">bus_space_reserve_subregion</b>(). The region is given by the <i class="farg">space</i> and <i class="farg">bsr</i> arguments. If successful, it returns zero and fills in the bus space handle pointed to by <i class="farg">handlep</i> with the handle that can be used to access the mapped region. If unsuccessful, it will return non-zero and leave the bus space handle pointed to by <i class="farg">handlep</i> in an undefined state.<p>
A region mapped by <b class="fname">bus_space_reservation_map</b>() may only be unmapped by a call to <b class="fname">bus_space_reservation_unmap</b>().<p>
For more details, see the description of <b class="fname">bus_space_map</b>().<p>
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_unmap</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">size</i>)</dt>
<dd class="list-ohang">
<p>
The <b class="fname">bus_space_unmap</b>() function unmaps and relinquishes a region of bus space reserved and mapped with <b class="fname">bus_space_map</b>(). When unmapping a region, the <i class="farg">size</i> specified should be the same as the size given to <b class="fname">bus_space_map</b>() when mapping that region.<p>
After <b class="fname">bus_space_unmap</b>() is called on a handle, that handle is no longer valid. (If copies were made of the handle they are no longer valid, either.)<p>
This function will never fail. If it would fail (e.g., because of an argument error), that indicates a software bug which should cause a panic. In that case, <b class="fname">bus_space_unmap</b>() will never return.<p>
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_reservation_unmap</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">size</i>)</dt>
<dd class="list-ohang">
<p>
The <b class="fname">bus_space_reservation_unmap</b>() function is similar to <b class="fname">bus_space_unmap</b>() but it should be called on handles mapped by <b class="fname">bus_space_reservation_map</b>() and only on such handles. Unlike <b class="fname">bus_space_unmap</b>(), <b class="fname">bus_space_reservation_unmap</b>() does not relinquish exclusive use of the bus space named by <i class="farg">handle</i> and <i class="farg">size</i>; that is the job of <b class="fname">bus_space_release</b>().<p>
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_subregion</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">size</i>, <i class="farg">nhandlep</i>)</dt>
<dd class="list-ohang">
<p>
The <b class="fname">bus_space_subregion</b>() function is a convenience function which makes a new handle to some subregion of an already-mapped region of bus space. The subregion described by the new handle starts at byte offset <i class="farg">offset</i> into the region described by <i class="farg">handle</i>, with the size given by <i class="farg">size</i>, and must be wholly contained within the original region.<p>
If successful, <b class="fname">bus_space_subregion</b>() returns zero and fills in the bus space handle pointed to by <i class="farg">nhandlep</i>. If unsuccessful, it returns non-zero and leaves the bus space handle pointed to by <i class="farg">nhandlep</i> in an undefined state. In either case, the handle described by <i class="farg">handle</i> remains valid and is unmodified.<p>
When done with a handle created by <b class="fname">bus_space_subregion</b>(), the handle should be thrown away. Under no circumstances should <b class="fname">bus_space_unmap</b>() be used on the handle. Doing so may confuse any resource management being done on the space, and will result in undefined behaviour. When <b class="fname">bus_space_unmap</b>() or <b class="fname">bus_space_free</b>() is called on a handle, all subregions of that handle become invalid.<p>
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_vaddr</b>(<i class="farg">tag</i>, <i class="farg">handle</i>)</dt>
<dd class="list-ohang">
<p>
This method returns the kernel virtual address of a mapped bus space if and only if it was mapped with the <span class="define">BUS_SPACE_MAP_LINEAR</span> flag. The range can be accessed by normal (volatile) pointer dereferences. If mapped with the <span class="define">BUS_SPACE_MAP_PREFETCHABLE</span> flag, the <b class="fname">bus_space_barrier</b>() method must be used to force a particular access order.<p>
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_mmap</b>(<i class="farg">tag</i>, <i class="farg">addr</i>, <i class="farg">off</i>, <i class="farg">prot</i>, <i class="farg">flags</i>)</dt>
<dd class="list-ohang">
<p>
This method is used to provide support for memory mapping bus space into user applications. If an address space is addressable via volatile pointer dereferences, <b class="fname">bus_space_mmap</b>() will return the physical address (possibly encoded as a machine-dependent cookie) of the bus space indicated by <i class="farg">addr</i> and <i class="farg">off</i>. <i class="farg">addr</i> is the base address of the device or device region, and <i class="farg">off</i> is the offset into that region that is being requested. If the request is made with <span class="define">BUS_SPACE_MAP_LINEAR</span> as a flag, then a linear region must be returned to the caller. If the region cannot be mapped (either the address does not exist, or the constraints can not be met), <b class="fname">bus_space_mmap</b>() returns <span class="define">-1</span> to indicate failure.<p>
Note that it is not necessary that the region being requested by a <b class="fname">bus_space_mmap</b>() call be mapped into a <i class="farg">bus_space_handle_t</i>.<p>
<b class="fname">bus_space_mmap</b>() is called once per <span class="define">PAGE_SIZE</span> page in the range. The <i class="farg">prot</i> argument indicates the memory protection requested by the user application for the range.<p>
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_handle_is_equal</b>(<i class="farg">space</i>, <i class="farg">handle1</i>, <i class="farg">handle2</i>)</dt>
<dd class="list-ohang">
Use <b class="fname">bus_space_handle_is_equal</b>() to check whether or not <i class="farg">handle1</i> and <i class="farg">handle2</i> refer to regions starting at the same address in the bus space <i class="farg">space</i>.</dd>
</dl>
</div>
<div class="section">
<h1 id="x414c4c4f434154494e4720414e442046524545494e4720425553205350414345">ALLOCATING AND FREEING BUS SPACE</h1> Some devices require or allow bus space to be allocated by the operating system for device use. When the devices no longer need the space, the operating system should free it for use by other devices. The <b class="fname">bus_space_alloc</b>(), <b class="fname">bus_space_free</b>(), <b class="fname">bus_space_reserve</b>(), <b class="fname">bus_space_reserve_subregion</b>(), and <b class="fname">bus_space_release</b>() functions provide these capabilities. The functions <b class="fname">bus_space_reserve</b>(), <b class="fname">bus_space_reserve_subregion</b>(), and <b class="fname">bus_space_release</b>() are not yet available on all architectures.<p>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-ohang">
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_alloc</b>(<i class="farg">space</i>, <i class="farg">reg_start</i>, <i class="farg">reg_end</i>, <i class="farg">size</i>, <i class="farg">alignment</i>, <i class="farg">boundary</i>, <i class="farg">flags</i>, <i class="farg">addrp</i>, <i class="farg">handlep</i>)</dt>
<dd class="list-ohang">
<p>
The <b class="fname">bus_space_alloc</b>() function allocates and maps a region of bus space with the size given by <i class="farg">size</i>, corresponding to the given constraints. If successful, it returns zero, fills in the bus address pointed to by <i class="farg">addrp</i> with the bus space address of the allocated region, and fills in the bus space handle pointed to by <i class="farg">handlep</i> with the handle that can be used to access that region. If unsuccessful, it returns non-zero and leaves the bus address pointed to by <i class="farg">addrp</i> and the bus space handle pointed to by <i class="farg">handlep</i> in an undefined state.<p>
Constraints on the allocation are given by the <i class="farg">reg_start</i>, <i class="farg">reg_end</i>, <i class="farg">alignment</i>, and <i class="farg">boundary</i> parameters. The allocated region will start at or after <i class="farg">reg_start</i> and end before or at <i class="farg">reg_end</i>. The <i class="farg">alignment</i> constraint must be a power of two, and the allocated region will start at an address that is an even multiple of that power of two. The <i class="farg">boundary</i> constraint, if non-zero, ensures that the region is allocated so that <i class="farg">first address in region</i> / <i class="farg">boundary</i> has the same value as <i class="farg">last address in region</i> / <i class="farg">boundary</i>. If the constraints cannot be met, <b class="fname">bus_space_alloc</b>() will fail. It is an error to specify a set of constraints that can never be met (for example, <i class="farg">size</i> greater than <i class="farg">boundary</i>).<p>
The <i class="farg">flags</i> parameter is the same as the like-named parameter to <i class="farg">bus_space_map</i>, the same flag values should be used, and they have the same meanings.<p>
Handles created by <b class="fname">bus_space_alloc</b>() should only be freed with <b class="fname">bus_space_free</b>(). Trying to use <b class="fname">bus_space_unmap</b>() on them causes undefined behaviour. The <b class="fname">bus_space_subregion</b>() function can be used on handles created by <b class="fname">bus_space_alloc</b>().<p>
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_reserve</b>(<i class="farg">t</i>, <i class="farg">bpa</i>, <i class="farg">size</i>, <i class="farg">flags</i>, <i class="farg">bsrp</i>)</dt>
<dd class="list-ohang">
<p>
The <b class="fname">bus_space_reserve</b>() function reserves, for the caller's exclusive use, <i class="farg">size</i> bytes starting at the address <i class="farg">bpa</i> in the space referenced by <i class="farg">t</i>.<p>
<b class="fname">bus_space_reserve</b>() does <span class="emph">not</span> map the space. The caller should use <b class="fname">bus_space_reservation_map</b>() to map the reservation. <i class="farg">flags</i> contains a hint how the caller may map the reservation, later. Whenever possible, callers should pass the same flags to <b class="fname">bus_space_reserve</b>() as they will pass to <b class="fname">bus_space_reservation_map</b>() to map the reservation.<p>
On success, <b class="fname">bus_space_reserve</b>() records the reservation at <i class="farg">bsrp</i> and returns 0. On failure, <i class="farg">bsrp</i> is undefined, and <b class="fname">bus_space_reserve</b>() returns a non-zero error code. Possible error codes include<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="errno">EOPNOTSUPP</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
<b class="fname">bus_space_reserve</b>() is not supported on this architecture, or <i class="farg">flags</i> was incompatible with the bus space represented by <i class="farg">t</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="errno">ENOMEM</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
There was not sufficient bus space at <i class="farg">bpa</i> to satisfy the request.</dd>
</dl>
<p>
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_reserve_subregion</b>(<i class="farg">t</i>, <i class="farg">reg_start</i>, <i class="farg">reg_end</i>, <i class="farg">size</i>, <i class="farg">alignment</i>, <i class="farg">boundary</i>, <i class="farg">flags</i>, <i class="farg">bsrp</i>)</dt>
<dd class="list-ohang">
<p>
The <b class="fname">bus_space_reserve_subregion</b>() function reserves, for the caller's exclusive use, <i class="farg">size</i> bytes in the space referenced by <i class="farg">t</i>. The parameters <i class="farg">reg_start</i>, <i class="farg">reg_end</i>, <i class="farg">alignment</i>, <i class="farg">boundary</i>, and <i class="farg">flags</i> each work alike to the <b class="fname">bus_space_alloc</b>() parameters of the same names.<p>
On success, <b class="fname">bus_space_reserve_subregion</b>() records the reservation at <i class="farg">bsrp</i> and returns 0. On failure, <i class="farg">bsrp</i> is undefined, and <b class="fname">bus_space_reserve_subregion</b>() returns a non-zero error code. Possible error codes include<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="errno">EOPNOTSUPP</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
<b class="fname">bus_space_reserve</b>() is not supported on this architecture, or <i class="farg">flags</i> was incompatible with the bus space represented by <i class="farg">t</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="errno">ENOMEM</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
There was not sufficient bus space at <i class="farg">bpa</i> to satisfy the request.</dd>
</dl>
<p>
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_release</b>(<i class="farg">t</i>, <i class="farg">bsr</i>)</dt>
<dd class="list-ohang">
<p>
The <b class="fname">bus_space_release</b>() function releases the bus space <i class="farg">bsr</i> in <i class="farg">t</i> that was previously reserved by <b class="fname">bus_space_reserve</b>() or <b class="fname">bus_space_reserve_subregion</b>().<p>
If <b class="fname">bus_space_release</b>() is called on a reservation that has been mapped by <b class="fname">bus_space_reservation_map</b>() without subsequently being unmapped, the behavior of the system is undefined.<p>
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_free</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">size</i>)</dt>
<dd class="list-ohang">
<p>
The <b class="fname">bus_space_free</b>() function unmaps and frees a region of bus space mapped and allocated with <b class="fname">bus_space_alloc</b>(). When unmapping a region, the <i class="farg">size</i> specified should be the same as the size given to <b class="fname">bus_space_alloc</b>() when allocating the region.<p>
After <b class="fname">bus_space_free</b>() is called on a handle, that handle is no longer valid. (If copies were made of the handle, they are no longer valid, either.)<p>
This function will never fail. If it would fail (e.g., because of an argument error), that indicates a software bug which should cause a panic. In that case, <b class="fname">bus_space_free</b>() will never return.</dd>
</dl>
</div>
<div class="section">
<h1 id="x52454144494e4720414e442057524954494e472053494e474c452044415441204954454d53">READING AND WRITING SINGLE DATA ITEMS</h1> The simplest way to access bus space is to read or write a single data item. The <b class="fname">bus_space_read_N</b>() and <b class="fname">bus_space_write_N</b>() families of functions provide the ability to read and write 1, 2, 4, and 8 byte data items on busses which support those access sizes.<p>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-ohang">
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_read_1</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_read_2</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_read_4</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_read_8</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>)</dt>
<dd class="list-ohang">
<p>
The <b class="fname">bus_space_read_N</b>() family of functions reads a 1, 2, 4, or 8 byte data item from the offset specified by <i class="farg">offset</i> into the region specified by <i class="farg">handle</i> of the bus space specified by <i class="farg">space</i>. The location being read must lie within the bus space region specified by <i class="farg">handle</i>.<p>
For portability, the starting address of the region specified by <i class="farg">handle</i> plus the offset should be a multiple of the size of data item being read. On some systems, not obeying this requirement may cause incorrect data to be read, on others it may cause a system crash.<p>
Read operations done by the <b class="fname">bus_space_read_N</b>() functions may be executed out of order with respect to other pending read and write operations unless order is enforced by use of the <b class="fname">bus_space_barrier</b>() function.<p>
These functions will never fail. If they would fail (e.g., because of an argument error), that indicates a software bug which should cause a panic. In that case, they will never return.<p>
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_write_1</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">value</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_write_2</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">value</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_write_4</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">value</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_write_8</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">value</i>)</dt>
<dd class="list-ohang">
<p>
The <b class="fname">bus_space_write_N</b>() family of functions writes a 1, 2, 4, or 8 byte data item to the offset specified by <i class="farg">offset</i> into the region specified by <i class="farg">handle</i> of the bus space specified by <i class="farg">space</i>. The location being written must lie within the bus space region specified by <i class="farg">handle</i>.<p>
For portability, the starting address of the region specified by <i class="farg">handle</i> plus the offset should be a multiple of the size of data item being written. On some systems, not obeying this requirement may cause incorrect data to be written, on others it may cause a system crash.<p>
Write operations done by the <b class="fname">bus_space_write_N</b>() functions may be executed out of order with respect to other pending read and write operations unless order is enforced by use of the <b class="fname">bus_space_barrier</b>() function.<p>
These functions will never fail. If they would fail (e.g., because of an argument error), that indicates a software bug which should cause a panic. In that case, they will never return.</dd>
</dl>
</div>
<div class="section">
<h1 id="x50524f42494e472042555320535041434520464f52204841524457415245205748494348204d4159204e4f5420524553504f4e44">PROBING BUS SPACE FOR HARDWARE WHICH MAY NOT RESPOND</h1> One problem with the <b class="fname">bus_space_read_N</b>() and <b class="fname">bus_space_write_N</b>() family of functions is that they provide no protection against exceptions which can occur when no physical hardware or device responds to the read or write cycles. In such a situation, the system typically would panic due to a kernel-mode bus error. The <b class="fname">bus_space_peek_N</b>() and <b class="fname">bus_space_poke_N</b>() family of functions provide a mechanism to handle these exceptions gracefully without the risk of crashing the system.<p>
As with <b class="fname">bus_space_read_N</b>() and <b class="fname">bus_space_write_N</b>(), the peek and poke functions provide the ability to read and write 1, 2, 4, and 8 byte data items on busses which support those access sizes. All of the constraints specified in the descriptions of the <b class="fname">bus_space_read_N</b>() and <b class="fname">bus_space_write_N</b>() functions also apply to <b class="fname">bus_space_peek_N</b>() and <b class="fname">bus_space_poke_N</b>().<p>
In addition, explicit calls to the <b class="fname">bus_space_barrier</b>() function are not required as the implementation will ensure all pending operations complete before the peek or poke operation starts. The implementation will also ensure that the peek or poke operations complete before returning.<p>
The return value indicates the outcome of the peek or poke operation. A return value of zero implies that a hardware device is responding to the operation at the specified offset in the bus space. A non-zero return value indicates that the kernel intercepted a hardware exception (e.g., bus error) when the peek or poke operation was attempted. Note that some busses are incapable of generating exceptions when non-existent hardware is accessed. In such cases, these functions will always return zero and the value of the data read by <b class="fname">bus_space_peek_N</b>() will be unspecified.<p>
Finally, it should be noted that at this time the <b class="fname">bus_space_peek_N</b>() and <b class="fname">bus_space_poke_N</b>() functions are not re-entrant and should not, therefore, be used from within an interrupt service routine. This constraint may be removed at some point in the future.<p>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-ohang">
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_peek_1</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">datap</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_peek_2</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">datap</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_peek_4</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">datap</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_peek_8</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">datap</i>)</dt>
<dd class="list-ohang">
<p>
The <b class="fname">bus_space_peek_N</b>() family of functions cautiously read a 1, 2, 4, or 8 byte data item from the offset specified by <i class="farg">offset</i> in the region specified by <i class="farg">handle</i> of the bus space specified by <i class="farg">space</i>. The data item read is stored in the location pointed to by <i class="farg">datap</i>. It is permissible for <i class="farg">datap</i> to be NULL, in which case the data item will be discarded after being read.<p>
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_poke_1</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">value</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_poke_2</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">value</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_poke_4</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">value</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_poke_8</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">value</i>)</dt>
<dd class="list-ohang">
<p>
The <b class="fname">bus_space_poke_N</b>() family of functions cautiously write a 1, 2, 4, or 8 byte data item specified by <i class="farg">value</i> to the offset specified by <i class="farg">offset</i> in the region specified by <i class="farg">handle</i> of the bus space specified by <i class="farg">space</i>.</dd>
</dl>
</div>
<div class="section">
<h1 id="x4241525249455253">BARRIERS</h1> In order to allow high-performance buffering implementations to avoid bus activity on every operation, read and write ordering should be specified explicitly by drivers when necessary. The <b class="fname">bus_space_barrier</b>() function provides that ability.<p>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-ohang">
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_barrier</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">length</i>, <i class="farg">flags</i>)</dt>
<dd class="list-ohang">
<p>
The <b class="fname">bus_space_barrier</b>() function enforces ordering of bus space read and write operations for the specified subregion (described by the <i class="farg">offset</i> and <i class="farg">length</i> parameters) of the region named by <i class="farg">handle</i> in the space named by <i class="farg">space</i>.<p>
The <i class="farg">flags</i> argument controls what types of operations are to be ordered. Supported flags are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">BUS_SPACE_BARRIER_READ_BEFORE_READ</span></dt>
<dd class="list-tag" style="margin-left: 36.00ex;">
Force all reads before the barrier to complete before any reads after the barrier may be issued.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">BUS_SPACE_BARRIER_READ_BEFORE_WRITE</span></dt>
<dd class="list-tag" style="margin-left: 36.00ex;">
Force all reads before the barrier to complete before any writes after the barrier may be issued.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">BUS_SPACE_BARRIER_WRITE_BEFORE_READ</span></dt>
<dd class="list-tag" style="margin-left: 36.00ex;">
Force all writes before the barrier to complete before any reads after the barrier may be issued.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">BUS_SPACE_BARRIER_WRITE_BEFORE_WRITE</span></dt>
<dd class="list-tag" style="margin-left: 36.00ex;">
Force all writes before the barrier to complete before any writes after the barrier may be issued.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">BUS_SPACE_BARRIER_SYNC</span></dt>
<dd class="list-tag" style="margin-left: 36.00ex;">
Force all memory operations and any pending exceptions to be completed before any instructions after the barrier may be issued.</dd>
</dl>
<p>
Those flags can be combined (or-ed together) to enforce ordering on different combinations of read and write operations.<p>
All of the specified type(s) of operation which are done to the region before the barrier operation are guaranteed to complete before any of the specified type(s) of operation done after the barrier.<p>
Example: Consider a hypothetical device with two single-byte ports, one write-only input port (at offset 0) and a read-only output port (at offset 1). Operation of the device is as follows: data bytes are written to the input port, and are placed by the device on a stack, the top of which is read by reading from the output port. The sequence to correctly write two data bytes to the device then read those two data bytes back would be:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
/* 
 * t and h are the tag and handle for the mapped device's 
 * space. 
 */ 
bus_space_write_1(t, h, 0, data0); 
bus_space_barrier(t, h, 0, 1, BUS_SPACE_BARRIER_WRITE_BEFORE_WRITE); /* 1 */ 
bus_space_write_1(t, h, 0, data1); 
bus_space_barrier(t, h, 0, 2, BUS_SPACE_BARRIER_WRITE_BEFORE_READ);  /* 2 */ 
ndata1 = bus_space_read_1(t, h, 1); 
bus_space_barrier(t, h, 1, 1, BUS_SPACE_BARRIER_READ_BEFORE_READ);   /* 3 */ 
ndata0 = bus_space_read_1(t, h, 1); 
/* data0 == ndata0, data1 == ndata1 */</pre>
<p>
The first barrier makes sure that the first write finishes before the second write is issued, so that two writes to the input port are done in order and are not collapsed into a single write. This ensures that the data bytes are written to the device correctly and in order.<p>
The second barrier forces the writes to the output port finish before any of the reads to the input port are issued, thereby making sure that all of the writes are finished before data is read. This ensures that the first byte read from the device really is the last one that was written.<p>
The third barrier makes sure that the first read finishes before the second read is issued, ensuring that data is read correctly and in order.<p>
The barriers in the example above are specified to cover the absolute minimum number of bus space locations. It is correct (and often easier) to make barrier operations cover the device's whole range of bus space, that is, to specify an offset of zero and the size of the whole region.<p>
The following barrier operations are obsolete and should be removed from existing code:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">BUS_SPACE_BARRIER_READ</span></dt>
<dd class="list-tag" style="margin-left: 23.00ex;">
Synchronize read operations.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">BUS_SPACE_BARRIER_WRITE</span></dt>
<dd class="list-tag" style="margin-left: 23.00ex;">
Synchronize write operations.</dd>
</dl>
</dd>
</dl>
</div>
<div class="section">
<h1 id="x524547494f4e204f5045524154494f4e53">REGION OPERATIONS</h1> Some devices use buffers which are mapped as regions in bus space. Often, drivers want to copy the contents of those buffers to or from memory, e.g., into mbufs which can be passed to higher levels of the system or from mbufs to be output to a network. In order to allow drivers to do this as efficiently as possible, the <b class="fname">bus_space_read_region_N</b>() and <b class="fname">bus_space_write_region_N</b>() families of functions are provided.<p>
Drivers occasionally need to copy one region of a bus space to another, or to set all locations in a region of bus space to contain a single value. The <b class="fname">bus_space_copy_region_N</b>() family of functions and the <b class="fname">bus_space_set_region_N</b>() family of functions allow drivers to perform these operations.<p>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-ohang">
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_read_region_1</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">datap</i>, <i class="farg">count</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_read_region_2</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">datap</i>, <i class="farg">count</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_read_region_4</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">datap</i>, <i class="farg">count</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_read_region_8</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">datap</i>, <i class="farg">count</i>)</dt>
<dd class="list-ohang">
<p>
The <b class="fname">bus_space_read_region_N</b>() family of functions reads <i class="farg">count</i> 1, 2, 4, or 8 byte data items from bus space starting at byte offset <i class="farg">offset</i> in the region specified by <i class="farg">handle</i> of the bus space specified by <i class="farg">space</i> and writes them into the array specified by <i class="farg">datap</i>. Each successive data item is read from an offset 1, 2, 4, or 8 bytes after the previous data item (depending on which function is used). All locations being read must lie within the bus space region specified by <i class="farg">handle</i>.<p>
For portability, the starting address of the region specified by <i class="farg">handle</i> plus the offset should be a multiple of the size of data items being read and the data array pointer should be properly aligned. On some systems, not obeying these requirements may cause incorrect data to be read, on others it may cause a system crash.<p>
Read operations done by the <b class="fname">bus_space_read_region_N</b>() functions may be executed in any order. They may also be executed out of order with respect to other pending read and write operations unless order is enforced by use of the <b class="fname">bus_space_barrier</b>() function. There is no way to insert barriers between reads of individual bus space locations executed by the <b class="fname">bus_space_read_region_N</b>() functions.<p>
These functions will never fail. If they would fail (e.g., because of an argument error), that indicates a software bug which should cause a panic. In that case, they will never return.<p>
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_write_region_1</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">datap</i>, <i class="farg">count</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_write_region_2</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">datap</i>, <i class="farg">count</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_write_region_4</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">datap</i>, <i class="farg">count</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_write_region_8</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">datap</i>, <i class="farg">count</i>)</dt>
<dd class="list-ohang">
<p>
The <b class="fname">bus_space_write_region_N</b>() family of functions reads <i class="farg">count</i> 1, 2, 4, or 8 byte data items from the array specified by <i class="farg">datap</i> and writes them to bus space starting at byte offset <i class="farg">offset</i> in the region specified by <i class="farg">handle</i> of the bus space specified by <i class="farg">space</i>. Each successive data item is written to an offset 1, 2, 4, or 8 bytes after the previous data item (depending on which function is used). All locations being written must lie within the bus space region specified by <i class="farg">handle</i>.<p>
For portability, the starting address of the region specified by <i class="farg">handle</i> plus the offset should be a multiple of the size of data items being written and the data array pointer should be properly aligned. On some systems, not obeying these requirements may cause incorrect data to be written, on others it may cause a system crash.<p>
Write operations done by the <b class="fname">bus_space_write_region_N</b>() functions may be executed in any order. They may also be executed out of order with respect to other pending read and write operations unless order is enforced by use of the <b class="fname">bus_space_barrier</b>() function. There is no way to insert barriers between writes of individual bus space locations executed by the <b class="fname">bus_space_write_region_N</b>() functions.<p>
These functions will never fail. If they would fail (e.g., because of an argument error), that indicates a software bug which should cause a panic. In that case, they will never return.<p>
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_copy_region_1</b>(<i class="farg">space</i>, <i class="farg">srchandle</i>, <i class="farg">srcoffset</i>, <i class="farg">dsthandle</i>, <i class="farg">dstoffset</i>, <i class="farg">count</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_copy_region_2</b>(<i class="farg">space</i>, <i class="farg">srchandle</i>, <i class="farg">srcoffset</i>, <i class="farg">dsthandle</i>, <i class="farg">dstoffset</i>, <i class="farg">count</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_copy_region_4</b>(<i class="farg">space</i>, <i class="farg">srchandle</i>, <i class="farg">srcoffset</i>, <i class="farg">dsthandle</i>, <i class="farg">dstoffset</i>, <i class="farg">count</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_copy_region_8</b>(<i class="farg">space</i>, <i class="farg">srchandle</i>, <i class="farg">srcoffset</i>, <i class="farg">dsthandle</i>, <i class="farg">dstoffset</i>, <i class="farg">count</i>)</dt>
<dd class="list-ohang">
<p>
The <b class="fname">bus_space_copy_region_N</b>() family of functions copies <i class="farg">count</i> 1, 2, 4, or 8 byte data items in bus space from the area starting at byte offset <i class="farg">srcoffset</i> in the region specified by <i class="farg">srchandle</i> of the bus space specified by <i class="farg">space</i> to the area starting at byte offset <i class="farg">dstoffset</i> in the region specified by <i class="farg">dsthandle</i> in the same bus space. Each successive data item read or written has an offset 1, 2, 4, or 8 bytes after the previous data item (depending on which function is used). All locations being read and written must lie within the bus space region specified by their respective handles.<p>
For portability, the starting addresses of the regions specified by each handle plus its respective offset should be a multiple of the size of data items being copied. On some systems, not obeying this requirement may cause incorrect data to be copied, on others it may cause a system crash.<p>
Read and write operations done by the <b class="fname">bus_space_copy_region_N</b>() functions may be executed in any order. They may also be executed out of order with respect to other pending read and write operations unless order is enforced by use of the <b class="fname">bus_space_barrier</b>(<i class="farg">function</i>). There is no way to insert barriers between reads or writes of individual bus space locations executed by the <b class="fname">bus_space_copy_region_N</b>() functions.<p>
Overlapping copies between different subregions of a single region of bus space are handled correctly by the <b class="fname">bus_space_copy_region_N</b>() functions.<p>
These functions will never fail. If they would fail (e.g., because of an argument error), that indicates a software bug which should cause a panic. In that case, they will never return.<p>
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_set_region_1</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">value</i>, <i class="farg">count</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_set_region_2</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">value</i>, <i class="farg">count</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_set_region_4</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">value</i>, <i class="farg">count</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_set_region_8</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">value</i>, <i class="farg">count</i>)</dt>
<dd class="list-ohang">
<p>
The <b class="fname">bus_space_set_region_N</b>() family of functions writes the given <i class="farg">value</i> to <i class="farg">count</i> 1, 2, 4, or 8 byte data items in bus space starting at byte offset <i class="farg">offset</i> in the region specified by <i class="farg">handle</i> of the bus space specified by <i class="farg">space</i>. Each successive data item has an offset 1, 2, 4, or 8 bytes after the previous data item (depending on which function is used). All locations being written must lie within the bus space region specified by <i class="farg">handle</i>.<p>
For portability, the starting address of the region specified by <i class="farg">handle</i> plus the offset should be a multiple of the size of data items being written. On some systems, not obeying this requirement may cause incorrect data to be written, on others it may cause a system crash.<p>
Write operations done by the <b class="fname">bus_space_set_region_N</b>() functions may be executed in any order. They may also be executed out of order with respect to other pending read and write operations unless order is enforced by use of the <b class="fname">bus_space_barrier</b>() function. There is no way to insert barriers between writes of individual bus space locations executed by the <b class="fname">bus_space_set_region_N</b>() functions.<p>
These functions will never fail. If they would fail (e.g., because of an argument error), that indicates a software bug which should cause a panic. In that case, they will never return.</dd>
</dl>
</div>
<div class="section">
<h1 id="x52454144494e4720414e442057524954494e4720412053494e474c45204c4f434154494f4e204d554c5449504c452054494d4553">READING AND WRITING A SINGLE LOCATION MULTIPLE TIMES</h1> Some devices implement single locations in bus space which are to be read or written multiple times to communicate data, e.g., some ethernet devices' packet buffer FIFOs. In order to allow drivers to manipulate these types of devices as efficiently as possible, the <b class="fname">bus_space_read_multi_N</b>() and <b class="fname">bus_space_write_multi_N</b>() families of functions are provided.<p>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-ohang">
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_read_multi_1</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">datap</i>, <i class="farg">count</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_read_multi_2</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">datap</i>, <i class="farg">count</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_read_multi_4</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">datap</i>, <i class="farg">count</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_read_multi_8</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">datap</i>, <i class="farg">count</i>)</dt>
<dd class="list-ohang">
<p>
The <b class="fname">bus_space_read_multi_N</b>() family of functions reads <i class="farg">count</i> 1, 2, 4, or 8 byte data items from bus space at byte offset <i class="farg">offset</i> in the region specified by <i class="farg">handle</i> of the bus space specified by <i class="farg">space</i> and writes them into the array specified by <i class="farg">datap</i>. Each successive data item is read from the same location in bus space. The location being read must lie within the bus space region specified by <i class="farg">handle</i>.<p>
For portability, the starting address of the region specified by <i class="farg">handle</i> plus the offset should be a multiple of the size of data items being read and the data array pointer should be properly aligned. On some systems, not obeying these requirements may cause incorrect data to be read, on others it may cause a system crash.<p>
Read operations done by the <b class="fname">bus_space_read_multi_N</b>() functions may be executed out of order with respect to other pending read and write operations unless order is enforced by use of the <b class="fname">bus_space_barrier</b>() function. Because the <b class="fname">bus_space_read_multi_N</b>() functions read the same bus space location multiple times, they place an implicit read barrier between each successive read of that bus space location.<p>
These functions will never fail. If they would fail (e.g., because of an argument error), that indicates a software bug which should cause a panic. In that case, they will never return.<p>
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_write_multi_1</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">datap</i>, <i class="farg">count</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_write_multi_2</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">datap</i>, <i class="farg">count</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_write_multi_4</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">datap</i>, <i class="farg">count</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_write_multi_8</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">datap</i>, <i class="farg">count</i>)</dt>
<dd class="list-ohang">
<p>
The <b class="fname">bus_space_write_multi_N</b>() family of functions reads <i class="farg">count</i> 1, 2, 4, or 8 byte data items from the array specified by <i class="farg">datap</i> and writes them into bus space at byte offset <i class="farg">offset</i> in the region specified by <i class="farg">handle</i> of the bus space specified by <i class="farg">space</i>. Each successive data item is written to the same location in bus space. The location being written must lie within the bus space region specified by <i class="farg">handle</i>.<p>
For portability, the starting address of the region specified by <i class="farg">handle</i> plus the offset should be a multiple of the size of data items being written and the data array pointer should be properly aligned. On some systems, not obeying these requirements may cause incorrect data to be written, on others it may cause a system crash.<p>
Write operations done by the <b class="fname">bus_space_write_multi_N</b>() functions may be executed out of order with respect to other pending read and write operations unless order is enforced by use of the <b class="fname">bus_space_barrier</b>() function. Because the <b class="fname">bus_space_write_multi_N</b>() functions write the same bus space location multiple times, they place an implicit write barrier between each successive write of that bus space location.<p>
These functions will never fail. If they would fail (e.g., because of an argument error), that indicates a software bug which should cause a panic. In that case, they will never return.</dd>
</dl>
</div>
<div class="section">
<h1 id="x53545245414d2046554e4354494f4e53">STREAM FUNCTIONS</h1> Most of the <b class="name">bus_space</b> functions imply a host byte-order and a bus byte-order and take care of any translation for the caller. In some cases, however, hardware may map a FIFO or some other memory region for which the caller may want to use multi-word, yet untranslated access. Access to these types of memory regions should be with the <b class="fname">bus_space_*_stream_N</b>() functions.<p>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-ohang">
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_read_stream_1</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_read_stream_2</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_read_stream_4</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_read_stream_8</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_read_multi_stream_1</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">datap</i>, <i class="farg">count</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_read_multi_stream_2</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">datap</i>, <i class="farg">count</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_read_multi_stream_4</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">datap</i>, <i class="farg">count</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_read_multi_stream_8</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">datap</i>, <i class="farg">count</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_read_region_stream_1</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">datap</i>, <i class="farg">count</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_read_region_stream_2</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">datap</i>, <i class="farg">count</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_read_region_stream_4</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">datap</i>, <i class="farg">count</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_read_region_stream_8</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">datap</i>, <i class="farg">count</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_write_stream_1</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">value</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_write_stream_2</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">value</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_write_stream_4</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">value</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_write_stream_8</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">value</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_write_multi_stream_1</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">datap</i>, <i class="farg">count</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_write_multi_stream_2</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">datap</i>, <i class="farg">count</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_write_multi_stream_4</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">datap</i>, <i class="farg">count</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_write_multi_stream_8</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">datap</i>, <i class="farg">count</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_write_region_stream_1</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">datap</i>, <i class="farg">count</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_write_region_stream_2</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">datap</i>, <i class="farg">count</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_write_region_stream_4</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">datap</i>, <i class="farg">count</i>)</dt>
<dd class="list-ohang">
</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_write_region_stream_8</b>(<i class="farg">space</i>, <i class="farg">handle</i>, <i class="farg">offset</i>, <i class="farg">datap</i>, <i class="farg">count</i>)</dt>
<dd class="list-ohang">
</dd>
</dl>
<p>
These functions are defined just as their non-stream counterparts, except that they provide no byte-order translation.</div>
<div class="section">
<h1 id="x494d504c454d454e54494e47204255532053504143455320494e204d414348494e451e494e444550454e44454e5420434f4445">IMPLEMENTING BUS SPACES IN MACHINE-INDEPENDENT CODE</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-ohang">
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_tag_create</b>(<i class="farg">obst</i>, <i class="farg">present</i>, <i class="farg">extpresent</i>, <i class="farg">ov</i>, <i class="farg">ctx</i>, <i class="farg">bstp</i>)</dt>
<dd class="list-ohang">
Create a copy of the tag <i class="farg">obst</i> at <i class="farg">*bstp</i>. Except for the behavior overridden by <i class="farg">ov</i>, <i class="farg">*bstp</i> inherits the behavior of <i class="farg">obst</i> under <b class="name">bus_space</b> calls.<p>
<i class="farg">ov</i> contains function pointers corresponding to <b class="name">bus_space</b> routines. Each function pointer has a corresponding bit in <i class="farg">present</i> or <i class="farg">extpresent</i>, and if that bit is 1, the function pointer overrides the corresponding <b class="name">bus_space</b> call for the new tag. Any combination of these bits may be set in <i class="farg">present</i>:<p>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BUS_SPACE_OVERRIDE_MAP</span></dt>
<dd class="list-tag" style="margin-left: 36.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BUS_SPACE_OVERRIDE_UNMAP</span></dt>
<dd class="list-tag" style="margin-left: 36.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BUS_SPACE_OVERRIDE_ALLOC</span></dt>
<dd class="list-tag" style="margin-left: 36.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BUS_SPACE_OVERRIDE_FREE</span></dt>
<dd class="list-tag" style="margin-left: 36.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BUS_SPACE_OVERRIDE_RESERVE</span></dt>
<dd class="list-tag" style="margin-left: 36.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BUS_SPACE_OVERRIDE_RELEASE</span></dt>
<dd class="list-tag" style="margin-left: 36.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BUS_SPACE_OVERRIDE_RESERVATION_MAP</span></dt>
<dd class="list-tag" style="margin-left: 36.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BUS_SPACE_OVERRIDE_RESERVATION_UNMAP</span></dt>
<dd class="list-tag" style="margin-left: 36.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">BUS_SPACE_OVERRIDE_RESERVE_SUBREGION</span></dt>
<dd class="list-tag" style="margin-left: 36.00ex;">
</dd>
</dl>
<p>
<b class="fname">bus_space_tag_create</b>() does not copy <i class="farg">ov</i>. After a new tag is created by <b class="fname">bus_space_tag_create</b>(), <i class="farg">ov</i> must not be destroyed until after the tag is destroyed by <b class="fname">bus_space_tag_destroy</b>().<p>
The first argument of every override-function is a <span class="type">void *</span>, and <i class="farg">ctx</i> is passed in that argument.<p>
Return 0 if the call succeeds. Return <span class="errno">EOPNOTSUPP</span> if the architecture does not support overrides. Return <span class="errno">EINVAL</span> if <i class="farg">present</i> is 0, if <i class="farg">ov</i> is <span class="define">NULL</span>, or if <i class="farg">present</i> indicates that an override is present, but the corresponding override in <i class="farg">ov</i> is <span class="define">NULL</span>.<p>
If the call does not succeed, <i class="farg">*bstp</i> is undefined.</dd>
<dt class="list-ohang" style="margin-top: 0.00em;">
<b class="fname">bus_space_tag_destroy</b>(<i class="farg">bst</i>)</dt>
<dd class="list-ohang">
Destroy a tag, <i class="farg">bst</i>, created by a prior call to <b class="fname">bus_space_tag_create</b>(). If <i class="farg">bst</i> was not created by <b class="fname">bus_space_tag_create</b>(), results are undefined. If <i class="farg">bst</i> was already destroyed, results are undefined.</dd>
</dl>
</div>
<div class="section">
<h1 id="x4558504543544544204348414e47455320544f20544845204255535f53504143452046554e4354494f4e53">EXPECTED CHANGES TO THE BUS_SPACE FUNCTIONS</h1> The definition of the <b class="name">bus_space</b> functions should not yet be considered finalized. There are several changes and improvements which should be explored, including:<ul style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-bul">
<li class="list-bul" style="margin-top: 1.00em;">
Providing a mechanism by which incorrectly-written drivers will be automatically given barriers and properly-written drivers won't be forced to use more barriers than they need. This should probably be done via a <code class="lit">#define</code> in the incorrectly-written drivers. Unfortunately, at this time, few drivers actually use barriers correctly (or at all). Because of that, <b class="name">bus_space</b> implementations on architectures which do buffering must always do the barriers inside the <b class="name">bus_space</b> calls, to be safe. That has a potentially significant performance impact.</li>
<li class="list-bul" style="margin-top: 1.00em;">
Exporting the <b class="name">bus_space</b> functions to user-land so that applications (such as X servers) have easier, more portable access to device space.</li>
<li class="list-bul" style="margin-top: 1.00em;">
Redefining bus space tags and handles so that machine-independent bus interface drivers (for example PCI to VME bridges) could define and implement bus spaces without requiring machine-dependent code. If this is done, it should be done in such a way that machine-dependent optimizations should remain possible.</li>
<li class="list-bul" style="margin-top: 1.00em;">
Converting bus spaces (such as PCI configuration space) which currently use space-specific access methods to use the <b class="name">bus_space</b> functions where that is appropriate.</li>
<li class="list-bul" style="margin-top: 1.00em;">
Redefining the way bus space is mapped and allocated, so that mapping and allocation are done with bus specific functions which return bus space tags. This would allow further optimization than is currently possible, and would also ease translation of the <b class="name">bus_space</b> functions into user space (since mapping in user space would look like it just used a different bus-specific mapping function).</li>
</ul>
</div>
<div class="section">
<h1 id="x434f4d5041544942494c495459">COMPATIBILITY</h1> The current version of the <b class="name">bus_space</b> interface specification differs slightly from the original specification that came into wide use. A few of the function names and arguments have changed for consistency and increased functionality. Drivers that were written to the old, deprecated specification can be compiled by defining the <span class="define">__BUS_SPACE_COMPAT_OLDDEFS</span> preprocessor symbol before including <b class="includes">&lt;<a class="link-includes">sys/bus.h</a>&gt;</b>.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../9/bus_dma">bus_dma(9)</a>, <a class="link-man" href="../9/mb">mb(9)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The <b class="name">bus_space</b> functions were introduced in a different form (memory and I/O spaces were accessed via different sets of functions) in <span class="unix">NetBSD&#160;1.2</span>. The functions were merged to work on generic &#8220;spaces&#8221; early in the <span class="unix">NetBSD&#160;1.3</span> development cycle, and many drivers were converted to use them. This document was written later during the <span class="unix">NetBSD&#160;1.3</span> development cycle and the specification was updated to fix some consistency problems and to add some missing functionality.</div>
<div class="section">
<h1 id="x415554484f5253">AUTHORS</h1> The <b class="name">bus_space</b> interfaces were designed and implemented by the <span class="unix">NetBSD</span> developer community. Primary contributors and implementors were Chris Demetriou, Jason Thorpe, and Charles Hannum, but the rest of the <span class="unix">NetBSD</span> developers and the user community played a significant role in development.<p>
Chris Demetriou wrote this manual page.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
July 6, 2011</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
<>

