<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="/static/man_pages/netbsd/style.css" type="text/css" media="all">
<title>
BUFFERCACHE(9)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
BUFFERCACHE(9)</td>
<td class="head-vol" align="center">
Kernel Developer's Manual</td>
<td class="head-rtitle" align="right">
BUFFERCACHE(9)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">buffercache</b>, <b class="name">bread</b>, <b class="name">breadn</b>, <b class="name">bwrite</b>, <b class="name">bawrite</b>, <b class="name">bdwrite</b>, <b class="name">getblk</b>, <b class="name">geteblk</b>, <b class="name">incore</b>, <b class="name">allocbuf</b>, <b class="name">brelse</b> &#8212; <span class="desc">buffer cache interfaces</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/buf.h</a>&gt;</b><p>
<i class="ftype">int</i><br>
<b class="fname">bread</b>(<i class="farg" style="white-space:nowrap;">struct vnode *vp</i>, <i class="farg" style="white-space:nowrap;">daddr_t blkno</i>, <i class="farg" style="white-space:nowrap;">int size</i>, <i class="farg" style="white-space:nowrap;">int flags</i>, <i class="farg" style="white-space:nowrap;">buf_t **bpp</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">breadn</b>(<i class="farg" style="white-space:nowrap;">struct vnode *vp</i>, <i class="farg" style="white-space:nowrap;">daddr_t blkno</i>, <i class="farg" style="white-space:nowrap;">int size</i>, <i class="farg" style="white-space:nowrap;">daddr_t rablks[]</i>, <i class="farg" style="white-space:nowrap;">int rasizes[]</i>, <i class="farg" style="white-space:nowrap;">int nrablks</i>, <i class="farg" style="white-space:nowrap;">int flags</i>, <i class="farg" style="white-space:nowrap;">buf_t **bpp</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">bwrite</b>(<i class="farg" style="white-space:nowrap;">buf_t *bp</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bawrite</b>(<i class="farg" style="white-space:nowrap;">buf_t *bp</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">bdwrite</b>(<i class="farg" style="white-space:nowrap;">buf_t *bp</i>);<p>
<i class="ftype">buf_t *</i><br>
<b class="fname">getblk</b>(<i class="farg" style="white-space:nowrap;">struct vnode *vp</i>, <i class="farg" style="white-space:nowrap;">daddr_t blkno</i>, <i class="farg" style="white-space:nowrap;">int size</i>, <i class="farg" style="white-space:nowrap;">int slpflag</i>, <i class="farg" style="white-space:nowrap;">int slptimeo</i>);<p>
<i class="ftype">buf_t *</i><br>
<b class="fname">geteblk</b>(<i class="farg" style="white-space:nowrap;">int size</i>);<p>
<i class="ftype">buf_t *</i><br>
<b class="fname">incore</b>(<i class="farg" style="white-space:nowrap;">struct vnode *vp</i>, <i class="farg" style="white-space:nowrap;">daddr_t blkno</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">allocbuf</b>(<i class="farg" style="white-space:nowrap;">buf_t *bp</i>, <i class="farg" style="white-space:nowrap;">int size</i>, <i class="farg" style="white-space:nowrap;">int preserve</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">brelse</b>(<i class="farg" style="white-space:nowrap;">buf_t *bp</i>, <i class="farg" style="white-space:nowrap;">int set</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <b class="name">buffercache</b> interface is used by each filesystems to improve I/O performance using in-core caches of filesystem blocks.<p>
The kernel memory used to cache a block is called a buffer and described by a <span class="emph">buf</span> structure. In addition to describing a cached block, a <span class="emph">buf</span> structure is also used to describe an I/O request as a part of the disk driver interface.</div>
<div class="section">
<h1 id="x46554e4354494f4e53">FUNCTIONS</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">bread</b>(<i class="farg">vp</i>, <i class="farg">blkno</i>, <i class="farg">size</i>, <i class="farg">flags</i>, <i class="farg">bpp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Read a block corresponding to <i class="farg">vp</i> and <i class="farg">blkno</i>. The buffer is returned via <i class="farg">bpp</i>. The units of <i class="farg">blkno</i> are specifically the units used by the <b class="fname">VOP_STRATEGY</b>() routine for the <i class="farg">vp</i> vnode. For device special files, <i class="farg">blkno</i> is in units of <span class="define">DEV_BSIZE</span> and both <i class="farg">blkno</i> and <i class="farg">size</i> must be multiples of the underlying device's block size. For other files, <i class="farg">blkno</i> is in units chosen by the file system containing <i class="farg">vp</i>.<p>
If the buffer is not found (i.e. the block is not cached in memory), <b class="fname">bread</b>() allocates a buffer with enough pages for <i class="farg">size</i> and reads the specified disk block into it.<p>
The buffer returned by <b class="fname">bread</b>() is marked as busy. (The <span class="define">B_BUSY</span> flag is set.) After manipulation of the buffer returned from <b class="fname">bread</b>(), the caller should unbusy it so that another thread can get it. If the buffer contents are modified and should be written back to disk, it should be unbusied using one of variants of <b class="fname">bwrite</b>(). Otherwise, it should be unbusied using <b class="fname">brelse</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">breadn</b>(<i class="farg">vp</i>, <i class="farg">blkno</i>, <i class="farg">size</i>, <i class="farg">rablks</i>, <i class="farg">rasizes</i>, <i class="farg">nrablks</i>, <i class="farg">flags</i>, <i class="farg">bpp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Get a buffer as <b class="fname">bread</b>(). In addition, <b class="fname">breadn</b>() will start read-ahead of blocks specified by <i class="farg">rablks</i>, <i class="farg">rasizes</i>, <i class="farg">nrablks</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">bwrite</b>(<i class="farg">bp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Write a block. Start I/O for write using <b class="fname">VOP_STRATEGY</b>(). Then, unless the <span class="define">B_ASYNC</span> flag is set in <i class="farg">bp</i>, <b class="fname">bwrite</b>() waits for the I/O to complete.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">bawrite</b>(<i class="farg">bp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Write a block asynchronously. Set the <span class="define">B_ASYNC</span> flag in <i class="farg">bp</i> and simply call <b class="fname">VOP_BWRITE</b>(), which results in <b class="fname">bwrite</b>() for most filesystems.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">bdwrite</b>(<i class="farg">bp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Delayed write. Unlike <b class="fname">bawrite</b>(), <b class="fname">bdwrite</b>() won't start any I/O. It only marks the buffer as dirty (<span class="define">B_DELWRI</span>) and unbusy it.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">getblk</b>(<i class="farg">vp</i>, <i class="farg">blkno</i>, <i class="farg">size</i>, <i class="farg">slpflag</i>, <i class="farg">slptimeo</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Get a block of requested size <i class="farg">size</i> that is associated with a given vnode and block offset, specified by <i class="farg">vp</i> and <i class="farg">blkno</i>. If it is found in the block cache, make it busy and return it. Otherwise, return an empty block of the correct size. It is up to the caller to ensure that the cached blocks are of the correct size.<p>
If <b class="fname">getblk</b>() needs to sleep, <i class="farg">slpflag</i> and <i class="farg">slptimeo</i> are used as arguments for <b class="fname">cv_timedwait</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">geteblk</b>(<i class="farg">size</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Allocate an empty, disassociated block of a given size <i class="farg">size</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">incore</b>(<i class="farg">vp</i>, <i class="farg">blkno</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Determine if a block associated to a given vnode and block offset is in the cache. If it is there, return a pointer to it. Note that <b class="fname">incore</b>() doesn't busy the buffer unlike <b class="fname">getblk</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">allocbuf</b>(<i class="farg">bp</i>, <i class="farg">size</i>, <i class="farg">preserve</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Expand or contract the actual memory allocated to a buffer. If <i class="farg">preserve</i> is zero, the entire data in the buffer will be lost. Otherwise, if the buffer shrinks, the truncated part of the data is lost, so it is up to the caller to have written it out <span class="emph">first</span> if needed; this routine will not start a write. If the buffer grows, it is the callers responsibility to fill out the buffer's additional contents.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">brelse</b>(<i class="farg">bp</i>, <i class="farg">set</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Unbusy a buffer and release it to the free lists.</dd>
</dl>
</div>
<div class="section">
<h1 id="x434f4445205245464552454e434553">CODE REFERENCES</h1> The buffer cache subsystem is implemented within the file <i class="file">sys/kern/vfs_bio.c</i>.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../9/intro">intro(9)</a>, <a class="link-man" href="../9/vnode">vnode(9)</a><p>
<span class="ref"><span class="ref-auth">Maurice J. Bach</span>, <i class="ref-book">The Design of the UNIX Operating System</i>, <i class="ref-issue">Prentice Hall</i>, <span class="ref-date">1986</span>.</span><p>
<span class="ref"><span class="ref-auth">Marshall Kirk McKusick</span>, <span class="ref-auth">Keith Bostic</span>, <span class="ref-auth">Michael J. Karels</span>, and <span class="ref-auth">John S. Quarterman</span>, <i class="ref-book">The Design and Implementation of the 4.4BSD Operating System</i>, <i class="ref-issue">Addison Wesley</i>, <span class="ref-date">1996</span>.</span></div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
March 28, 2015</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

