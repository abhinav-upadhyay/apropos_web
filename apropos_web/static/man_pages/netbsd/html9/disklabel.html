<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
DISKLABEL(9)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
DISKLABEL(9)</td>
<td class="head-vol" align="center">
Kernel Developer's Manual</td>
<td class="head-rtitle" align="right">
DISKLABEL(9)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">disklabel</b>, <b class="name">readdisklabel</b>, <b class="name">writedisklabel</b>, <b class="name">setdisklabel</b>, <b class="name">bounds_check_with_label</b> &#8212; <span class="desc">disk label management routines</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <i class="ftype">char *</i><br>
<b class="fname">readdisklabel</b>(<i class="farg" style="white-space:nowrap;">dev_t dev</i>, <i class="farg" style="white-space:nowrap;">void (*strat)(struct buf *)</i>, <i class="farg" style="white-space:nowrap;">struct disklabel *lp</i>, <i class="farg" style="white-space:nowrap;">struct cpu_disklabel *clp</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">writedisklabel</b>(<i class="farg" style="white-space:nowrap;">dev_t dev</i>, <i class="farg" style="white-space:nowrap;">void (*strat)(struct buf *)</i>, <i class="farg" style="white-space:nowrap;">struct disklabel *lp</i>, <i class="farg" style="white-space:nowrap;">struct cpu_disklabel *clp</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">setdisklabel</b>(<i class="farg" style="white-space:nowrap;">struct disklabel *olp</i>, <i class="farg" style="white-space:nowrap;">struct disklabel *nlp</i>, <i class="farg" style="white-space:nowrap;">u_long openmask</i>, <i class="farg" style="white-space:nowrap;">struct cpu_disklabel *clp</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">bounds_check_with_label</b>(<i class="farg" style="white-space:nowrap;">struct buf *bp</i>, <i class="farg" style="white-space:nowrap;">struct disklabel *lp</i>, <i class="farg" style="white-space:nowrap;">int wlabel</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> This collection of routines provides a disklabel management interface to kernel device drivers. These routines are classified as machine- or architecture-dependent because of restrictions imposed by the machine architecture and boot-strapping code on the location of the label, or because cooperation with other operating systems requires specialized conversion code.<p>
<b class="fname">readdisklabel</b>() attempts to read a disklabel from the device identified by <i class="farg">dev</i>, using the device strategy routine passed in <i class="farg">strat</i>. Note that a buffer structure is required to pass to the strategy routine; it needs to be acquired and parameterized for the intended I/O operation, and disposed of when the operation has completed. Some fields in the disklabel passed in <i class="farg">lp</i> may be pre-initialized by the caller in order to meet device driver requirements for the I/O operation initiated to get to the disklabel data on the medium. In particular, the field &#8220;d_secsize&#8221;, if non-zero, is used by <b class="fname">readdisklabel</b>() to get an appropriately sized buffer to pass to the device strategy routine. Unspecified fields in <i class="farg">lp</i> should be set to zero. If the medium does not contain a native disklabel that can be read in directly, <b class="fname">readdisklabel</b>() may resort to constructing a label from other machine-dependent information using the provided buffer passed in the <i class="farg">clp</i> argument. If a disk label can not be found or constructed, a string containing an approximated description of the failure mode is returned. Otherwise the <span class="define">NULL</span> string is returned.<p>
<b class="fname">writedisklabel</b>() stores disk label information contained in the disk label structure given by <i class="farg">lp</i> on the device identified by <i class="farg">dev</i>. Like <b class="fname">readdisklabel</b>(), it acquires and sets up an I/O buffer to pass to the strategy routine <i class="farg">strat</i>. <b class="fname">writedisklabel</b>() may elect to do a machine-dependent conversion of the native disk label structure (using the buffer pointed at by <i class="farg">clp</i>), to store the disk label onto the medium in a format complying with architectural constraints. <b class="fname">writedisklabel</b>() returns 0 on success and <span class="define">EINVAL</span> if the disk label specifies invalid or inconvertible values. Otherwise, any error condition reported by the device strategy routine in the buffer's &#8220;<b class="var">b_error</b>&#8221; field is returned.<p>
<b class="fname">setdisklabel</b>() checks a proposed new disk label passed in <i class="farg">nlp</i> for some amount of basic sanity. This includes a check on attempts to change the location, or reduce the size, of an existing disk partition that is currently in use by the system. The current disposition of the disk partitions is made available through <i class="farg">olp</i> and <i class="farg">openmask</i>, which provide, respectively, the existing disk label and a bit mask identifying the partitions that are currently in use. Failure to pass on &#8220;basic sanity&#8221;, results in a <span class="define">EINVAL</span> return value, while a vetoed update of the partition layout is signaled by a <span class="define">EBUSY</span> return value. Otherwise, 0 is returned.<p>
<b class="fname">bounds_check_with_label</b>() is used to check whether a device transfer described by <i class="farg">bp</i> to the device identified by <i class="farg">dev</i>, is properly contained within a disk partition of the disk with label <i class="farg">lp</i>. If this check fails, <b class="fname">bounds_check_with_label</b>() sets the buffer's &#8220;<b class="var">b_error</b>&#8221; field to <span class="define">EINVAL</span>, sets the <span class="define">B_ERROR</span> flag in &#8220;<b class="var">b_flags</b>&#8221;, and returns -1. If the argument <i class="farg">wlabel</i> is zero, and the transfer is a write operation, a check is done if the transfer would overwrite (a portion of) the disklabel area on the medium. If that is the case, <span class="define">EROFS</span> is set in &#8220;<b class="var">b_error</b>&#8221;, the <span class="define">B_ERROR</span> flag is set in &#8220;<b class="var">b_flags</b>&#8221;, and -1 is returned. Note that <i class="farg">wlabel</i> should be set to a non-zero value if the intended operation is expected to install or update the disk label. Programs that intend to do so using the raw device interface should notify the driver by using a <span class="define">DIOCWLABEL</span> ioctl function.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html5/disklabel.html">disklabel(5)</a>, <a class="link-man" href="../html8/disklabel.html">disklabel(8)</a></div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
December 26, 1996</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

