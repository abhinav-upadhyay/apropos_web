<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
PCMCIA(9)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
PCMCIA(9)</td>
<td class="head-vol" align="center">
Kernel Developer's Manual</td>
<td class="head-rtitle" align="right">
PCMCIA(9)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">PCMCIA</b> <b class="name">pcmcia_function_init</b>, <b class="name">pcmcia_function_enable</b>, <b class="name">pcmcia_function_disable</b>, <b class="name">pcmcia_io_alloc</b>, <b class="name">pcmcia_io_free</b>, <b class="name">pcmcia_io_map</b>, <b class="name">pcmcia_io_unmap</b>, <b class="name">pcmcia_mem_alloc</b>, <b class="name">pcmcia_mem_free</b>, <b class="name">pcmcia_mem_map</b>, <b class="name">pcmcia_mem_unmap</b>, <b class="name">pcmcia_intr_establish</b>, <b class="name">pcmcia_intr_disestablish</b>, <b class="name">pcmcia_cis_read_1</b>, <b class="name">pcmcia_cis_read_2</b>, <b class="name">pcmcia_cis_read_3</b>, <b class="name">pcmcia_cis_read_4</b>, <b class="name">pcmcia_cis_read_n</b>, <b class="name">pcmcia_scan_cis</b> &#8212; <span class="desc">support for PCMCIA PC-Card devices</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/bus.h</a>&gt;</b><br>
<b class="includes">#include &lt;<a class="link-includes">dev/pcmcia/pcmciareg.h</a>&gt;</b><br>
<b class="includes">#include &lt;<a class="link-includes">dev/pcmcia/pcmciavar.h</a>&gt;</b><br>
<b class="includes">#include &lt;<a class="link-includes">dev/pcmcia/pcmciadevs.h</a>&gt;</b><p>
<i class="ftype">void</i><br>
<b class="fname">pcmcia_function_init</b>(<i class="farg" style="white-space:nowrap;">struct pcmcia_function *pf</i>, <i class="farg" style="white-space:nowrap;">struct pcmcia_config_entry *cfe</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">pcmcia_function_enable</b>(<i class="farg" style="white-space:nowrap;">struct pcmcia_function *pf</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">pcmcia_function_disable</b>(<i class="farg" style="white-space:nowrap;">struct pcmcia_function *pf</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">pcmcia_io_alloc</b>(<i class="farg" style="white-space:nowrap;">struct pcmcia_function *pf</i>, <i class="farg" style="white-space:nowrap;">bus_addr_t start</i>, <i class="farg" style="white-space:nowrap;">bus_size_t size</i>, <i class="farg" style="white-space:nowrap;">bus_size_t align</i>, <i class="farg" style="white-space:nowrap;">struct pcmcia_io_handle *pciop</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">pcmcia_io_free</b>(<i class="farg" style="white-space:nowrap;">struct pcmcia_function *pf</i>, <i class="farg" style="white-space:nowrap;">struct pcmcia_io_handle *pcihp</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">pcmcia_io_map</b>(<i class="farg" style="white-space:nowrap;">struct pcmcia_function *pf</i>, <i class="farg" style="white-space:nowrap;">int width</i>, <i class="farg" style="white-space:nowrap;">struct pcmcia_io_handle *pcihp</i>, <i class="farg" style="white-space:nowrap;">int *windowp</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">pcmcia_io_unmap</b>(<i class="farg" style="white-space:nowrap;">struct pcmcia_function *pf</i>, <i class="farg" style="white-space:nowrap;">int window</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">pcmcia_mem_alloc</b>(<i class="farg" style="white-space:nowrap;">struct pcmcia_function *pf</i>, <i class="farg" style="white-space:nowrap;">bus_size_t size</i>, <i class="farg" style="white-space:nowrap;">struct pcmcia_mem_handle *pcmhp</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">pcmcia_mem_free</b>(<i class="farg" style="white-space:nowrap;">struct pcmcia_function *pf</i>, <i class="farg" style="white-space:nowrap;">struct pcmcia_mem_handle *pcmhp</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">pcmcia_mem_map</b>(<i class="farg" style="white-space:nowrap;">struct pcmcia_function *pf</i>, <i class="farg" style="white-space:nowrap;">int width</i>, <i class="farg" style="white-space:nowrap;">bus_addr_t card_addr</i>, <i class="farg" style="white-space:nowrap;">bus_size_t size</i>, <i class="farg" style="white-space:nowrap;">struct pcmcia_mem_handle *pcmhp</i>, <i class="farg" style="white-space:nowrap;">bus_size_t *offsetp</i>, <i class="farg" style="white-space:nowrap;">int *windowp</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">pcmcia_mem_unmap</b>(<i class="farg" style="white-space:nowrap;">struct pcmcia_function *pf</i>, <i class="farg" style="white-space:nowrap;">int window</i>);<p>
<i class="ftype">void *</i><br>
<b class="fname">pcmcia_intr_establish</b>(<i class="farg" style="white-space:nowrap;">struct pcmcia_function *pf</i>, <i class="farg" style="white-space:nowrap;">int level</i>, <i class="farg" style="white-space:nowrap;">int (*handler)(void *)</i>, <i class="farg" style="white-space:nowrap;">void *arg</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">pcmcia_intr_disestablish</b>(<i class="farg" style="white-space:nowrap;">struct pcmcia_function *pf</i>, <i class="farg" style="white-space:nowrap;">void *ih</i>);<p>
<i class="ftype">uint8_t</i><br>
<b class="fname">pcmcia_cis_read_1</b>(<i class="farg" style="white-space:nowrap;">struct pcmcia_tuple *tuple</i>, <i class="farg" style="white-space:nowrap;">int index</i>);<p>
<i class="ftype">uint16_t</i><br>
<b class="fname">pcmcia_cis_read_2</b>(<i class="farg" style="white-space:nowrap;">struct pcmcia_tuple *tuple</i>, <i class="farg" style="white-space:nowrap;">int index</i>);<p>
<i class="ftype">uint32_t</i><br>
<b class="fname">pcmcia_cis_read_3</b>(<i class="farg" style="white-space:nowrap;">struct pcmcia_tuple *tuple</i>, <i class="farg" style="white-space:nowrap;">int index</i>);<p>
<i class="ftype">uint32_t</i><br>
<b class="fname">pcmcia_cis_read_4</b>(<i class="farg" style="white-space:nowrap;">struct pcmcia_tuple *tuple</i>, <i class="farg" style="white-space:nowrap;">int index</i>);<p>
<i class="ftype">uint32_t</i><br>
<b class="fname">pcmcia_cis_read_n</b>(<i class="farg" style="white-space:nowrap;">struct pcmcia_tuple *tuple</i>, <i class="farg" style="white-space:nowrap;">int number</i>, <i class="farg" style="white-space:nowrap;">int index</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">pcmcia_scan_cis</b>(<i class="farg" style="white-space:nowrap;">struct device *dev</i>, <i class="farg" style="white-space:nowrap;">int (*func)(struct pcmcia_tuple *, void *)</i>, <i class="farg" style="white-space:nowrap;">void *arg</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The machine-independent <b class="name">PCMCIA</b> subsystem provides support for PC-Card devices defined by the Personal Computer Memory Card International Assocation (PCMCIA). The <b class="name">PCMCIA</b> bus supports insertion and removal of cards while a system is powered-on (ie, dynamic reconfiguration). The socket must be powered-off when a card is not present. To the user, this appears as though the socket is "hot" during insertion and removal events.<p>
A PCMCIA controller interfaces the PCMCIA bus with the ISA or PCI busses on the host system. The controller is responsible for detecting and enabling devices and for allocating and mapping resources such as memory and interrupts to devices on the PCMCIA bus.<p>
Each device has a table called the Card Information Structure (CIS) which contains configuration information. The tuples in the CIS are used by the controller to uniquely identify the device. Additional information may be present in the CIS, such as the ethernet MAC address, that can be accessed and used within a device driver.<p>
Devices on the PCMCIA bus are uniquely identified by a 32-bit manufacturer ID and a 32-bit product ID. Additionally, devices can perform multiple functions (such as ethernet and modem) and these functions are identified by a function ID.<p>
PCMCIA devices do not support DMA, however memory on the device can be mapped into the address space of the host.</div>
<div class="section">
<h1 id="x44415441205459504553">DATA TYPES</h1> Drivers attached to the <b class="name">PCMCIA</b> bus will make use of the following data types:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">struct pcmcia_card</i></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Devices (cards) have their identity recorded in this structure. It contains the following members:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
	char		*cis1_info[4]; 
        int32_t         manufacturer; 
        int32_t         product; 
        uint16_t       error; 
        SIMPLEQ_HEAD(, pcmcia_function)	pf_head;</pre>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">struct pcmcia_function</i></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Identifies the function of the devices. A device can have multiple functions. Consider it an opaque type for identifying a particular function of a device.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
struct pcmcia_config_entry</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Contains information about the resources requested by the device. It contains the following members:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
        int             number; 
        uint32_t       flags; 
        int     	iftype; 
        int   		num_iospace; 
        u_long 		iomask; 
        struct { 
                u_long  length; 
                u_long  start; 
        } iospace[4]; 
        uint16_t       irqmask; 
        int             num_memspace; 
        struct { 
                u_long  length; 
                u_long  cardaddr; 
                u_long  hostaddr; 
        } 		memspace[2]; 
        int             maxtwins; 
	SIMPLEQ_ENTRY(pcmcia_config_entry) cfe_list;</pre>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">struct pcmcia_tuple</i></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
A handle for identifying an entry in the CIS.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">struct pcmcia_io_handle</i></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
A handle for mapping and allocating I/O address spaces. It contains the tag and handle for accessing the bus-space.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">struct pcmcia_mem_handle</i></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
A handle for mapping and allocating memory address spaces. It contains the tag and handle for accessing the bus-space.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">struct pcmcia_attach_args</i></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
A structure used to inform the driver of the device properties. It contains the following members:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
	int32_t			manufacturer; 
	int32_t			product; 
	struct pcmcia_card	*card; 
	struct pcmcia_function	*pf;</pre>
</dd>
</dl>
</div>
<div class="section">
<h1 id="x46554e4354494f4e53">FUNCTIONS</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pcmcia_function_init</b>(<i class="farg">pf</i>, <i class="farg">cfe</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Initialise the machine-independent <b class="name">PCMCIA</b> state with the config entry <i class="farg">cfe</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pcmcia_function_enable</b>(<i class="farg">pf</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Provide power to the socket containing the device specified by device function <i class="farg">pf</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pcmcia_function_disable</b>(<i class="farg">pf</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Remove power from the socket containing the device specified by device function <i class="farg">pf</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pcmcia_io_alloc</b>(<i class="farg">pf</i>, <i class="farg">start</i>, <i class="farg">size</i>, <i class="farg">align</i>, <i class="farg">pciop</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Request I/O space for device function <i class="farg">pf</i> at address <i class="farg">start</i> of size <i class="farg">size</i>. Alignment is specified by <i class="farg">align</i>. A handle for the I/O space is returned in <i class="farg">pciop</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pcmcia_io_free</b>(<i class="farg">pf</i>, <i class="farg">pcihp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Release I/O space with handle <i class="farg">pcihp</i> for device function <i class="farg">pf</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pcmcia_io_map</b>(<i class="farg">pf</i>, <i class="farg">width</i>, <i class="farg">pcihp</i>, <i class="farg">windowp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Map device I/O for device function <i class="farg">pf</i> to the I/O space with handle <i class="farg">pcihp</i>. The width of data access is specified by <i class="farg">width</i>. Valid values for the width are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
PCMCIA_WIDTH_AUTO</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
Use the largest I/O width reported by the device.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
PCMCIA_WIDTH_IO8</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
Force 8-bit I/O width.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
PCMCIA_WIDTH_IO16</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
Force 16-bit I/O width.</dd>
</dl>
<p>
A handle for the mapped I/O window is returned in <i class="farg">windowp</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pcmcia_io_unmap</b>(<i class="farg">pf</i>, <i class="farg">window</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Unmap the I/O window <i class="farg">window</i> for device function <i class="farg">pf</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pcmcia_mem_alloc</b>(<i class="farg">pf</i>, <i class="farg">size</i>, <i class="farg">pcmhp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Request memory space for device function <i class="farg">pf</i> of size <i class="farg">size</i>. A handle for the memory space is returned in <i class="farg">pcmhp</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pcmcia_mem_free</b>(<i class="farg">pf</i>, <i class="farg">pcmhp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Release memory space with handle <i class="farg">pcmhp</i> for device function <i class="farg">pf</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pcmcia_mem_map</b>(<i class="farg">pf</i>, <i class="farg">width</i>, <i class="farg">card_addr</i>, <i class="farg">size</i>, <i class="farg">pcmhp</i>, <i class="farg">offsetp</i>, <i class="farg">windowp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Map device memory for device function <i class="farg">pf</i> to the memory space with handle <i class="farg">pcmhp</i>. The address of the device memory starts at <i class="farg">card_addr</i> and is size <i class="farg">size</i>. The width of data access is specified by <i class="farg">width</i>. Valid values for the width are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
PCMCIA_WIDTH_MEM8</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Force 8-bit memory width.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
PCMCIA_WIDTH_MEM16</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Force 16-bit memory width.</dd>
</dl>
<p>
A handle for the mapped memory window is returned in <i class="farg">windowp</i> and a bus-space offset into the memory window is returned in <i class="farg">offsetp</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pcmcia_mem_unmap</b>(<i class="farg">pf</i>, <i class="farg">window</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Unmap the memory window <i class="farg">window</i> for device function <i class="farg">pf</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pcmcia_intr_establish</b>(<i class="farg">pf</i>, <i class="farg">level</i>, <i class="farg">handler</i>, <i class="farg">arg</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Establish an interrupt handler for device function <i class="farg">pf</i>. The priority of the interrupt is specified by <i class="farg">level</i>. When the interrupt occurs the function <i class="farg">handler</i> is called with argument <i class="farg">arg</i>. The return value is a handle for the interrupt handler. <b class="fname">pcmcia_intr_establish</b>() returns an opaque handle to an event descriptor if it succeeds, and returns NULL on failure.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pcmcia_intr_disestablish</b>(<i class="farg">pf</i>, <i class="farg">ih</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Dis-establish the interrupt handler for device function <i class="farg">pf</i> with handle <i class="farg">ih</i>. The handle was returned from <b class="fname">pcmcia_intr_establish</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pcmcia_cis_read_1</b>(<i class="farg">tuple</i>, <i class="farg">index</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Read one byte from tuple <i class="farg">tuple</i> at index <i class="farg">index</i> in the CIS.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pcmcia_cis_read_2</b>(<i class="farg">tuple</i>, <i class="farg">index</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Read two bytes from tuple <i class="farg">tuple</i> at index <i class="farg">index</i> in the CIS.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pcmcia_cis_read_3</b>(<i class="farg">tuple</i>, <i class="farg">index</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Read three bytes from tuple <i class="farg">tuple</i> at index <i class="farg">index</i> in the CIS.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pcmcia_cis_read_4</b>(<i class="farg">tuple</i>, <i class="farg">index</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Read four bytes from tuple <i class="farg">tuple</i> at index <i class="farg">index</i> in the CIS.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pcmcia_cis_read_n</b>(<i class="farg">tuple</i>, <i class="farg">number</i>, <i class="farg">index</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Read <i class="farg">n</i> bytes from tuple <i class="farg">tuple</i> at index <i class="farg">index</i> in the CIS.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pcmcia_scan_cis</b>(<i class="farg">dev</i>, <i class="farg">func</i>, <i class="farg">arg</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Scan the CIS for device <i class="farg">dev</i>. For each tuple in the CIS, function <i class="farg">func</i> is called with the tuple and the argument <i class="farg">arg</i>. <i class="farg">func</i> should return 0 if the tuple it was called with is the one it was looking for, or 1 otherwise.</dd>
</dl>
</div>
<div class="section">
<h1 id="x4155544f434f4e46494755524154494f4e">AUTOCONFIGURATION</h1> During autoconfiguration, a <b class="name">PCMCIA</b> driver will receive a pointer to <i class="farg">struct pcmcia_attach_args</i> describing the device attached to the PCMCIA bus. Drivers match the device using the <span class="emph">manufacturer</span> and <span class="emph">product</span> members.<p>
During the driver attach step, drivers will use the pcmcia function <span class="emph">pf</span>. The driver should traverse the list of config entries searching for a useful configuration. This config entry is passed to <b class="fname">pcmcia_function_init</b>() to initialise the machine-independent interface. I/O and memory resources should be initialised using <b class="fname">pcmcia_io_alloc</b>() and <b class="fname">pcmcia_mem_alloc</b>() using the specified resources in the config entry. These resources can then be mapped into processor bus space using <b class="fname">pcmcia_io_map</b>() and <b class="fname">pcmcia_mem_map</b>() respectively. Upon successful allocation of resources, power can be applied to the device with <b class="fname">pcmcia_function_enable</b>() so that device-specific interrogation can be performed. Finally, power should be removed from the device using <b class="fname">pcmcia_function_disable</b>().<p>
Since PCMCIA devices support dynamic configuration, drivers should make use of <a class="link-man" href="../html9/pmf.html">pmf(9)</a> framework. Power can be applied and the interrupt handler should be established through this interface.</div>
<div class="section">
<h1 id="x444d4120535550504f5254">DMA SUPPORT</h1> PCMCIA devices do not support DMA.</div>
<div class="section">
<h1 id="x434f4445205245464552454e434553">CODE REFERENCES</h1> The PCMCIA subsystem itself is implemented within the file <i class="file">sys/dev/pcmcia/pcmcia.c</i>. The database of known devices exists within the file <i class="file">sys/dev/pcmcia/pcmciadevs_data.h</i> and is generated automatically from the file <i class="file">sys/dev/pcmcia/pcmciadevs</i>. New manufacturer and product identifiers should be added to this file. The database can be regenerated using the Makefile <i class="file">sys/dev/pcmcia/Makefile.pcmciadevs</i>.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html4/pcic.html">pcic(4)</a>, <a class="link-man" href="../html4/pcmcia.html">pcmcia(4)</a>, <a class="link-man" href="../html4/tcic.html">tcic(4)</a>, <a class="link-man" href="../html9/autoconf.html">autoconf(9)</a>, <a class="link-man" href="../html9/bus_dma.html">bus_dma(9)</a>, <a class="link-man" href="../html9/bus_space.html">bus_space(9)</a>, <a class="link-man" href="../html9/driver.html">driver(9)</a><p>
<span class="ref"><span class="ref-auth">Personal Computer Memory Card International Association (PCMCIA)</span>, <span class="ref-title">PC Card 95 Standard</span>, <span class="ref-date">1995</span>.</span></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The machine-independent PCMCIA subsystem appeared in <span class="unix">NetBSD&#160;1.3</span>.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
April 15, 2010</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

