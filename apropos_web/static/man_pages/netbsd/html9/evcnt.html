<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
EVCNT(9)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
EVCNT(9)</td>
<td class="head-vol" align="center">
Kernel Developer's Manual</td>
<td class="head-rtitle" align="right">
EVCNT(9)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">evcnt</b>, <b class="name">evcnt_attach_dynamic</b>, <b class="name">evcnt_attach_static</b>, <b class="name">evcnt_detach</b> &#8212; <span class="desc">generic event counter framework</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/evcnt.h</a>&gt;</b><p>
<i class="ftype">void</i><br>
<b class="fname">evcnt_attach_dynamic</b>(<i class="farg" style="white-space:nowrap;">struct evcnt *ev</i>, <i class="farg" style="white-space:nowrap;">int type</i>, <i class="farg" style="white-space:nowrap;">const struct evcnt *parent</i>, <i class="farg" style="white-space:nowrap;">const char *group</i>, <i class="farg" style="white-space:nowrap;">const char *name</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">evcnt_attach_static</b>(<i class="farg" style="white-space:nowrap;">struct evcnt *ev</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">evcnt_detach</b>(<i class="farg" style="white-space:nowrap;">struct evcnt *ev</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <span class="unix">NetBSD</span> generic event counter framework is designed to provide a flexible and hierarchical event counting facility, which is useful for tracking system events (including device interrupts).<p>
The fundamental component of this framework is the <span class="emph">evcnt</span> structure. Its user-accessible fields are:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
struct evcnt { 
	uint64_t	ev_count;	/* how many have occurred */ 
	TAILQ_ENTRY(evcnt) ev_list;	/* entry on list of all counters */ 
	unsigned char	ev_type;	/* counter type; see below */ 
	unsigned char	ev_grouplen;	/* 'group' len, excluding NUL */ 
	unsigned char	ev_namelen;	/* 'name' len, excluding NUL */ 
	const struct evcnt *ev_parent;	/* parent, for hierarchical ctrs */ 
	const char	*ev_group;	/* name of group */ 
	const char	*ev_name;	/* name of specific event */ 
};</pre>
<p>
The system maintains a global linked list of all active event counters. This list, called <b class="name">allevents</b>, may grow or shrink over time as event counters are dynamically added to and removed from the system.<p>
Each event counter is marked (in the <i class="farg">ev_type</i> field) with the type of event being counted. The following types are currently defined:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="env">EVCNT_TYPE_MISC</span></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
Miscellaneous; doesn't fit into one of the other types.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="env">EVCNT_TYPE_INTR</span></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
Interrupt counter, reported by <b class="cmd">vmstat -i</b>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="env">EVCNT_TYPE_TRAP</span></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
Processor trap style events.</dd>
</dl>
<p>
Each event counter also has a group name (<i class="farg">ev_group</i>) and an event name (<i class="farg">ev_name</i>) which are used to identify the counter. The group name may be shared by a set of counters. For example, device interrupt counters would use the name of the device whose interrupts are being counted as the group name. The counter name is meant to distinguish the counter from others in its group (and need not be unique across groups). Both names should be understandable by users, since they are printed by commands like <a class="link-man" href="../1/vmstat">vmstat(1)</a>. The constant <span class="define">EVCNT_STRING_MAX</span> is defined to be the maximum group or event name length in bytes (including the trailing <span class="define">NUL</span>). In the current implementation it is 256.<p>
To support hierarchical tracking of events, each event counter can name a &#8220;parent&#8221; event counter. For instance, interrupt dispatch code could have an event counter per interrupt line, and devices could each have counters for the number of interrupts that they were responsible for causing. In that case, the counter for a device on a given interrupt line would have the line's counter as its parent. The value <span class="define">NULL</span> is used to indicate that a counter has no parent. A counter's parent must be attached before the counter is attached, and detached after the counter is detached.<p>
The <b class="fname">EVCNT_INITIALIZER</b>() macro can be used to provide a static initializer for an event counter structure. It is invoked as <b class="fname">EVCNT_INITIALIZER</b>(<i class="farg">type</i>, <i class="farg">parent</i>, <i class="farg">group</i>, <i class="farg">name</i>), and its arguments will be placed into the corresponding fields of the event counter structure it is initializing. The <i class="farg">group</i> and <i class="farg">name</i> arguments must be constant strings.</div>
<div class="section">
<h1 id="x46554e4354494f4e53">FUNCTIONS</h1> The following is a brief description of each function in the framework:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">evcnt_attach_dynamic</b>(<i class="farg">ev</i>, <i class="farg">type</i>, <i class="farg">parent</i>, <i class="farg">group</i>, <i class="farg">name</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Attach the event counter structure pointed to by <i class="farg">ev</i> to the system event list. The event counter is cleared and its fields initialized using the arguments to the function call. The contents of the remaining elements in the structure (e.g., the name lengths) are calculated, and the counter is added to the system event list.<p>
The strings specified as the group and counter names must persist (with the same value) throughout the life of the event counter; they are referenced by, not copied into, the counter.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">evcnt_attach_static</b>(<i class="farg">ev</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Attach the statically-initialized event counter structure pointed to by <i class="farg">ev</i> to the system event list. The event counter is assumed to be statically initialized using the <b class="fname">EVCNT_INITIALIZER</b>() macro. This function simply calculates structure elements' values as appropriate (e.g., the string lengths), and adds the counter to the system event list.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">evcnt_detach</b>(<i class="farg">ev</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Detach the event counter structure pointed to by <i class="farg">ev</i> from the system event list.</dd>
</dl>
<p>
Note that no method is provided to increment the value of an event counter. Code incrementing an event counter should do so by directly accessing its <i class="farg">ev_count</i> field in a manner that is known to be safe. For instance, additions to a device's event counters in the interrupt handler for that device will often be safe without additional protection (because interrupt handler entries for a given device have to be serialized). However, for other uses of event counters, additional locking or use of machine-dependent atomic operation may be appropriate. (The overhead of using a mechanism that is guaranteed to be safe to increment every counter, regardless of actual need for such a mechanism where the counter is being incremented, would be too great. On some systems, it might involve a global lock and several function calls.)</div>
<div class="section">
<h1 id="x4558414d504c4553">EXAMPLES</h1> This section includes a description on basic use of the framework and example usage of its functions.<p>
Device drivers can use the <b class="fname">evcnt_attach_dynamic</b>() and <b class="fname">evcnt_detach</b>() functions to manage device-specific event counters. Statically configured system modules can use <b class="fname">evcnt_attach_static</b>() to configure global event counters. Similarly, loadable modules can use <b class="fname">evcnt_attach_static</b>() to configure their global event counters, <b class="fname">evcnt_attach_dynamic</b>() to attach device-specific event counters, and <b class="fname">evcnt_detach</b>() to detach all counters when being unloaded.<p>
Device drivers that wish to use the generic event counter framework should place event counter structures in their &#8220;softc&#8221; structures. For example, to keep track of the number of interrupts for a given device (broken down further into &#8220;device readable&#8221; and &#8220;device writable&#8221; interrupts) a device driver might use:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
struct foo_softc { 
	[ . . . ] 
	struct evcnt sc_ev_intr;	/* interrupt count */ 
	struct evcnt sc_ev_intr_rd;	/* 'readable' interrupt count */ 
	struct evcnt sc_ev_intr_wr;	/* 'writable' interrupt count */ 
	[ . . . ] 
};</pre>
<p>
In the device attach function, those counters would be registered with the system using the <b class="fname">evcnt_attach_dynamic</b>() function, using code like:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
void 
fooattach(device_t parent, device_t self, void *aux) 
{ 
	struct foo_softc *sc = device_private(self); 
 
	[ . . . ] 
 
	/* Initialize and attach event counters. */ 
	evcnt_attach_dynamic(&amp;sc-&gt;sc_ev, EVCNT_TYPE_INTR, 
	    NULL, device_xname(self), "intr"); 
	evcnt_attach_dynamic(&amp;sc-&gt;sc_ev_rd, EVCNT_TYPE_INTR, 
	    &amp;sc-&gt;sc_ev, device_xname(self), "intr rd"); 
	evcnt_attach_dynamic(&amp;sc-&gt;sc_ev_wr, EVCNT_TYPE_INTR, 
	    &amp;sc-&gt;sc_ev, device_xname(self), "intr wr"); 
 
	[ . . . ] 
}</pre>
<p>
If the device can be detached from the system, its detach function should invoke <b class="fname">evcnt_detach</b>() on each attached counter (making sure to detach any &#8220;parent&#8221; counters only after detaching all children).<p>
Code like the following might be used to initialize a static event counter (in this example, one used to track CPU alignment traps):<p>
<pre style="margin-left: 0.00ex;" class="lit display">
	struct evcnt aligntrap_ev = EVCNT_INITIALIZER(EVCNT_TYPE_MISC, 
	    NULL, "cpu", "aligntrap")</pre>
<p>
To attach this event counter, code like the following could be used:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
	evcnt_attach_static(&amp;aligntrap_ev);</pre>
</div>
<div class="section">
<h1 id="x434f4445205245464552454e434553">CODE REFERENCES</h1> The event counter framework itself is implemented within the file <i class="file">sys/kern/subr_evcnt.c</i>. Data structures and function prototypes for the framework are located in <i class="file">sys/sys/device.h</i>.<p>
Event counters are used throughout the system.<p>
The <a class="link-man" href="../1/vmstat">vmstat(1)</a> source file <i class="file">usr.bin/vmstat/vmstat.c</i> shows an example of how to access event counters from user programs.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../1/vmstat">vmstat(1)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> A set of interrupt counter interfaces with similar names to the interfaces in the <span class="unix">NetBSD</span> generic event counter framework appeared as part of the new autoconfiguration system in <span class="unix">4.4BSD</span>. Those interfaces were never widely adopted in <span class="unix">NetBSD</span> because of limitations in their applicability. (Their use was limited to non-hierarchical, dynamically attached device interrupt counters.) The <span class="unix">NetBSD</span> generic event counter framework first appeared in <span class="unix">NetBSD&#160;1.5</span>.</div>
<div class="section">
<h1 id="x415554484f5253">AUTHORS</h1> The <span class="unix">NetBSD</span> generic event counter framework was designed and implemented by <span class="author">Chris Demetriou</span> &#60;cgd@NetBSD.org&#62;.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
January 14, 2011</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

