<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
BLUETOOTH(9)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
BLUETOOTH(9)</td>
<td class="head-vol" align="center">
Kernel Developer's Manual</td>
<td class="head-rtitle" align="right">
BLUETOOTH(9)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">BLUETOOTH</b> &#8212; <span class="desc">Bluetooth Device/Protocol API</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">netbt/bluetooth.h</a>&gt;</b><br>
<b class="includes">#include &lt;<a class="link-includes">netbt/hci.h</a>&gt;</b><br>
<b class="includes">#include &lt;<a class="link-includes">netbt/l2cap.h</a>&gt;</b><br>
<b class="includes">#include &lt;<a class="link-includes">netbt/rfcomm.h</a>&gt;</b><p>
<i class="ftype">struct hci_unit *</i><br>
<b class="fname">hci_attach</b>(<i class="farg" style="white-space:nowrap;">const struct hci_if *hci_if</i>, <i class="farg" style="white-space:nowrap;">device_t dev</i>, <i class="farg" style="white-space:nowrap;">uint16_t flags</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">hci_detach</b>(<i class="farg" style="white-space:nowrap;">struct hci_unit *unit</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">hci_input_event</b>(<i class="farg" style="white-space:nowrap;">struct hci_unit *unit</i>, <i class="farg" style="white-space:nowrap;">struct mbuf *m</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">hci_input_acl</b>(<i class="farg" style="white-space:nowrap;">struct hci_unit *unit</i>, <i class="farg" style="white-space:nowrap;">struct mbuf *m</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">hci_input_sco</b>(<i class="farg" style="white-space:nowrap;">struct hci_unit *unit</i>, <i class="farg" style="white-space:nowrap;">struct mbuf *m</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">btproto_attach</b>(<i class="farg" style="white-space:nowrap;">btproto_handle *</i>, <i class="farg" style="white-space:nowrap;">const struct btproto *proto</i>, <i class="farg" style="white-space:nowrap;">void *ref</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">btproto_bind</b>(<i class="farg" style="white-space:nowrap;">btproto_handle</i>, <i class="farg" style="white-space:nowrap;">struct sockaddr_bt *addr</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">btproto_sockaddr</b>(<i class="farg" style="white-space:nowrap;">btproto_handle</i>, <i class="farg" style="white-space:nowrap;">struct sockaddr_bt *addr</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">btproto_connect</b>(<i class="farg" style="white-space:nowrap;">btproto_handle</i>, <i class="farg" style="white-space:nowrap;">struct sockaddr_bt *addr</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">btproto_peeraddr</b>(<i class="farg" style="white-space:nowrap;">btproto_handle</i>, <i class="farg" style="white-space:nowrap;">struct sockaddr_bt *addr</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">btproto_disconnect</b>(<i class="farg" style="white-space:nowrap;">btproto_handle</i>, <i class="farg" style="white-space:nowrap;">int linger</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">btproto_detach</b>(<i class="farg" style="white-space:nowrap;">btproto_handle *</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">btproto_listen</b>(<i class="farg" style="white-space:nowrap;">btproto_handle</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">btproto_send</b>(<i class="farg" style="white-space:nowrap;">btproto_handle</i>, <i class="farg" style="white-space:nowrap;">struct mbuf *mbuf</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">btproto_rcvd</b>(<i class="farg" style="white-space:nowrap;">btproto_handle</i>, <i class="farg" style="white-space:nowrap;">size_t space</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">btproto_setopt</b>(<i class="farg" style="white-space:nowrap;">btproto_handle</i>, <i class="farg" style="white-space:nowrap;">int optarg</i>, <i class="farg" style="white-space:nowrap;">void *arg</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">btproto_getopt</b>(<i class="farg" style="white-space:nowrap;">btproto_handle</i>, <i class="farg" style="white-space:nowrap;">int optarg</i>, <i class="farg" style="white-space:nowrap;">void *arg</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The Bluetooth Protocol Stack provides socket based access to Bluetooth Devices. This document describes device driver access to the stack from below, and also the general Bluetooth Protocol/Service API for layering above existing Bluetooth Protocols.</div>
<div class="section">
<h1 id="x44415441205459504553">DATA TYPES</h1> Device drivers attaching to the Bluetooth Protocol Stack should pass a pointer to a <i class="farg">struct hci_if</i> defined in <b class="includes">&lt;<a class="link-includes">netbt/hci.h</a>&gt;</b> containing the driver information as follows:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
struct hci_if { 
	int	(*enable)(device_t); 
	void	(*disable)(device_t); 
	void	(*output_cmd)(device_t, struct mbuf *); 
	void	(*output_acl)(device_t, struct mbuf *); 
	void	(*output_sco)(device_t, struct mbuf *); 
	void	(*get_stats)(device_t, struct bt_stats *, int); 
	int	ipl; 
};</pre>
<p>
Statistics counters should be updated by the device after packets have been transmitted or received, or when errors occur.<p>
<pre style="margin-left: 0.00ex;" class="lit display">
struct bt_stats { 
	uint32_t	err_tx; 
	uint32_t	err_rx; 
	uint32_t	cmd_tx; 
	uint32_t	evt_rx; 
	uint32_t	acl_tx; 
	uint32_t	acl_rx; 
	uint32_t	sco_tx; 
	uint32_t	sco_rx; 
	uint32_t	byte_tx; 
	uint32_t	byte_rx; 
};</pre>
<p>
Bluetooth Protocol layers attaching above the Bluetooth Protocol Stack will make use of the <i class="farg">struct btproto</i> data type, which is defined in <b class="includes">&lt;<a class="link-includes">netbt/bluetooth.h</a>&gt;</b> and contains the following function callbacks which should be initialized by the protocol layer before attaching to the protocol which it uses:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
struct btproto { 
	void (*connecting)(void *); 
	void (*connected)(void *); 
	void (*disconnected)(void *, int); 
	void *(*newconn)(void *, struct sockaddr_bt *, struct sockaddr_bt *); 
	void (*complete)(void *, int); 
	void (*linkmode)(void *, int); 
	void (*input)(void *, struct mbuf *); 
};</pre>
</div>
<div class="section">
<h1 id="x46554e4354494f4e53">FUNCTIONS</h1> The following functions are related to the Bluetooth Device API.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">hci_attach</b>(<i class="farg">hci_if</i>, <i class="farg">dev</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Attach Bluetooth HCI device <i class="arg">dev</i> to the protocol stack in the manner described by <i class="arg">hci_if</i>. Driver quirks may be registered by passing the corresponding <span class="define">BTF_xxxx</span> flag in the <i class="arg">flags</i> argument.<p>
<b class="fname">hci_attach</b>() will return a <i class="farg">struct hci_unit</i> handle to be passed to the protocol stack in other calls.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">hci_detach</b>(<i class="farg">unit</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Detach Bluetooth HCI <i class="arg">unit</i> from the device.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">hci_input_event</b>(<i class="farg">unit</i>, <i class="farg">mbuf</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
This function should be called by the device when it has an event packet to present to the protocol stack. It may be called from an interrupt routine at the <i class="farg">ipl</i> value given in the <i class="arg">hci_if</i> descriptor.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">hci_input_acl</b>(<i class="farg">unit</i>, <i class="farg">mbuf</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
This function should be called by the device when it has an ACL data packet to present to the protocol stack. It may be called from an interrupt routine at the <i class="farg">ipl</i> value given in the <i class="arg">hci_if</i> descriptor.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">hci_input_sco</b>(<i class="farg">unit</i>, <i class="farg">mbuf</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
This function should be called by the device when it has an SCO data packet to present to the protocol stack. It may be called from an interrupt routine at the <i class="farg">ipl</i> value given in the <i class="arg">hci_if</i> descriptor.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">(*enable)</b>(<i class="farg">dev</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
This will be called when the protocol stack wishes to enable the device.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">(*disable)</b>(<i class="farg">dev</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
This will be called when the protocol stack wishes to disable the device.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">(*output_cmd)</b>(<i class="farg">dev</i>, <i class="farg">mbuf</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Will be called to output command packets on the device. The device is responsible for arbitrating access to the output queue, and output commands should be sent asynchronously. The device owns the <i class="arg">mbuf</i> and should release it when sent.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">(*output_acl)</b>(<i class="farg">dev</i>, <i class="farg">mbuf</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Will be called to output ACL data packets on the device. The device is responsible for arbitrating access to the output queue, and ACL data packets should be sent asynchronously. The device owns the <i class="arg">mbuf</i> and should release it when sent.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">(*output_sco)</b>(<i class="farg">dev</i>, <i class="farg">mbuf</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Will be called to output SCO data packets on the device. The device is responsible for arbitrating access to the output queue, and SCO data packets should be sent asynchronously. When the SCO data packet has been placed on the device and the <i class="arg">mbuf</i> is no longer required, it should be returned to the Bluetooth protocol stack via the <b class="fname">hci_complete_sco</b>() call.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">(*get_stats)</b>(<i class="farg">dev</i>, <i class="farg">dest</i>, <i class="farg">flush</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Will be called when IO statistics are requested. The <i class="farg">bt_stats</i> structure <i class="arg">dest</i> should be filled in, and if the <i class="arg">flush</i> argument is true, statistics should be reset.</dd>
</dl>
<p>
The following function definitions are related to the Bluetooth Protocol API. Note that the "btproto" prefix is representative only, the protocol being used will have a more specific prefix with prototypes being declared in the appropriate <b class="includes">&lt;<a class="link-includes">netbt/btproto.h</a>&gt;</b> file.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">btproto_attach</b>(<i class="farg">handle_ptr</i>, <i class="farg">proto</i>, <i class="farg">ref</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Allocate and initialize a new protocol object at the <i class="arg">handle_ptr</i> address that should subsequently be passed into the other functions. <i class="arg">proto</i> is a pointer to the <i class="farg">btproto</i> structure as described above containing relevant callbacks, and <i class="arg">ref</i> is the argument that will be supplied to those calls.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">btproto_bind</b>(<i class="farg">handle</i>, <i class="farg">addr</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Set the local address of the protocol object described by <i class="arg">handle</i> to <i class="arg">addr</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">btproto_sockaddr</b>(<i class="farg">handle</i>, <i class="farg">addr</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Copy the local address of the protocol object described by <i class="arg">handle</i> into <i class="arg">addr</i></dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">btproto_connect</b>(<i class="farg">handle</i>, <i class="farg">addr</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Initiate a connection by the protocol object described by <i class="arg">handle</i> to the remote device described by <i class="arg">addr</i>. This will result in a call to either <b class="fname">proto-&gt;connected</b>() or <b class="fname">proto-&gt;disconnected</b>(), and optionally <b class="fname">proto-&gt;connecting</b>() with the appropriate reference as given to <b class="fname">btproto_attach</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">btproto_peeraddr</b>(<i class="farg">handle</i>, <i class="farg">addr</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Copy the remote address of the protocol object described by <i class="arg">handle</i> into <i class="arg">addr</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">btproto_disconnect</b>(<i class="farg">handle</i>, <i class="farg">linger</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Schedule a disconnection by the protocol object described by <i class="arg">handle</i>. This will result in a call to <b class="fname">proto-&gt;disconnected</b>() with the appropriate reference when the connection is torn down. If linger is zero, the disconnection will be initiated immediately and any outstanding data may be lost.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">btproto_detach</b>(<i class="farg">handle_ptr</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Detach the protocol object described by the value in the location of <i class="arg">handle_ptr</i>, and free any related memory. The pointer in the location is cleared.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">btproto_listen</b>(<i class="farg">handle</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Use the protocol object described by <i class="arg">handle</i> as a listening post. This will result in calls to the <b class="fname">proto-&gt;newconn</b>() function when incoming connections are detected.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">btproto_send</b>(<i class="farg">handle</i>, <i class="farg">mbuf</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Send data on the connection described by the protocol object.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">btproto_rcvd</b>(<i class="farg">handle</i>, <i class="farg">space</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Indicate to the protocol that <i class="arg">space</i> is now available in the input buffers so that flow control may be deasserted. This should also be called to indicate initial buffer space. Note that <i class="arg">space</i> is an absolute value.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">btproto_setopt</b>(<i class="farg">handle</i>, <i class="farg">optarg</i>, <i class="farg">arg</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Set options on the protocol object described by <i class="arg">handle</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">btproto_getopt</b>(<i class="farg">handle</i>, <i class="farg">optarg</i>, <i class="farg">arg</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Get options for the protocol object described by <i class="arg">handle</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">(*connecting)</b>(<i class="farg">ref</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
This function will be called when the protocol receives information that the connection described by <i class="arg">ref</i> is pending.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">(*connected)</b>(<i class="farg">ref</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
This function will be called when the connection described by <i class="arg">ref</i> is successful and indicates that data may now be sent.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">(*disconnected)</b>(<i class="farg">ref</i>, <i class="farg">error</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
This function will be called when the connection described by <i class="arg">ref</i> is disconnected.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">*(*newconn)</b>(<i class="farg">ref</i>, <i class="farg">laddr</i>, <i class="farg">raddr</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
This function will be called when the protocol receives a new incoming connection on the local device described by <i class="arg">laddr</i> from the remote device described by <i class="arg">raddr</i>. The protocol should decide if it wishes to accept the connection and should attach and return a new instance of the relevant protocol handle or NULL.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">(*complete)</b>(<i class="farg">ref</i>, <i class="farg">count</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
This function will be called when the protocol has completed sending data. Complete will usually mean that the data has successfully left the device though for guaranteed protocols it can mean that the data has arrived at the other end and been acknowledged, and that <i class="arg">count</i> amount of data can be removed from the socket buffer. The units of the <i class="arg">count</i> value will be dependent on the protocol being used (e.g. RFCOMM is bytes, but L2CAP is packets)</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">(*linkmode)</b>(<i class="farg">ref</i>, <i class="farg">mode</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
This function will be called for established connections, when the link mode of the baseband link has changed. <i class="arg">mode</i> is the new mode.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">(*input)</b>(<i class="farg">ref</i>, <i class="farg">mbuf</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
This function is called to supply new data on the connection described by <i class="arg">ref</i>.</dd>
</dl>
</div>
<div class="section">
<h1 id="x434f4445205245464552454e434553">CODE REFERENCES</h1> The Bluetooth Protocol Stack is contained in the <i class="file">sys/netbt</i> directory.<p>
The Bluetooth Device API as described above is contained in the <i class="file">sys/netbt/hci_unit.c</i> file.<p>
For examples of the Bluetooth Protocol API see the interaction between the L2CAP upper layer in <i class="file">sys/netbt/l2cap_upper.c</i> and either the L2CAP socket layer in <i class="file">sys/netbt/l2cap_socket.c</i> or the <a class="link-man" href="../4/bthidev">bthidev(4)</a> pseudo-device in <i class="file">sys/dev/bluetooth/bthidev.c</i>.<p>
Also, the RFCOMM upper layer in <i class="file">sys/netbt/rfcomm_upper.c</i> and the RFCOMM socket layer in <i class="file">sys/netbt/rfcomm_socket.c</i>.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../4/bluetooth">bluetooth(4)</a>, <a class="link-man" href="../4/bt3c">bt3c(4)</a>, <a class="link-man" href="../4/bthidev">bthidev(4)</a>, <a class="link-man" href="../4/ubt">ubt(4)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> This Bluetooth Protocol Stack was written for <span class="unix">NetBSD&#160;4.0</span> by <span class="author">Iain Hibbert</span>, under the sponsorship of Itronix, Inc.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
November 20, 2007</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

