<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
OPENCRYPTO(9)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
OPENCRYPTO(9)</td>
<td class="head-vol" align="center">
Kernel Developer's Manual</td>
<td class="head-rtitle" align="right">
OPENCRYPTO(9)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">opencrypto</b>, <b class="name">crypto_get_driverid</b>, <b class="name">crypto_register</b>, <b class="name">crypto_kregister</b>, <b class="name">crypto_unregister</b>, <b class="name">crypto_unregister_all</b>, <b class="name">crypto_done</b>, <b class="name">crypto_kdone</b>, <b class="name">crypto_newsession</b>, <b class="name">crypto_freesession</b>, <b class="name">crypto_dispatch</b>, <b class="name">crypto_kdispatch</b>, <b class="name">crypto_getreq</b>, <b class="name">crypto_freereq</b> &#8212; <span class="desc">API for cryptographic services in the kernel</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">opencrypto/cryptodev.h</a>&gt;</b><p>
<i class="ftype">int32_t</i><br>
<b class="fname">crypto_get_driverid</b>(<i class="farg" style="white-space:nowrap;">u_int32_t</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">crypto_register</b>(<i class="farg" style="white-space:nowrap;">u_int32_t</i>, <i class="farg" style="white-space:nowrap;">int</i>, <i class="farg" style="white-space:nowrap;">u_int16_t</i>, <i class="farg" style="white-space:nowrap;">u_int32_t</i>, <i class="farg" style="white-space:nowrap;">int (*)(void *, u_int32_t *, struct cryptoini *)</i>, <i class="farg" style="white-space:nowrap;">int (*)(void *, u_int32_t *)</i>, <i class="farg" style="white-space:nowrap;">int (*)(u_int64_t)</i>, <i class="farg" style="white-space:nowrap;">int (*)(struct cryptop *)</i>, <i class="farg" style="white-space:nowrap;">void *</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">crypto_kregister</b>(<i class="farg" style="white-space:nowrap;">u_int32_t</i>, <i class="farg" style="white-space:nowrap;">int</i>, <i class="farg" style="white-space:nowrap;">u_int32_t</i>, <i class="farg" style="white-space:nowrap;">int (*)(void *, struct cryptkop *, int)</i>, <i class="farg" style="white-space:nowrap;">void *</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">crypto_unregister</b>(<i class="farg" style="white-space:nowrap;">u_int32_t</i>, <i class="farg" style="white-space:nowrap;">int</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">crypto_unregister_all</b>(<i class="farg" style="white-space:nowrap;">u_int32_t</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">crypto_done</b>(<i class="farg" style="white-space:nowrap;">struct cryptop *</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">crypto_kdone</b>(<i class="farg" style="white-space:nowrap;">struct cryptkop *</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">crypto_newsession</b>(<i class="farg" style="white-space:nowrap;">u_int64_t *</i>, <i class="farg" style="white-space:nowrap;">struct cryptoini *</i>, <i class="farg" style="white-space:nowrap;">int</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">crypto_freesession</b>(<i class="farg" style="white-space:nowrap;">u_int64_t</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">crypto_dispatch</b>(<i class="farg" style="white-space:nowrap;">struct cryptop *</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">crypto_kdispatch</b>(<i class="farg" style="white-space:nowrap;">struct cryptkop *</i>);<p>
<i class="ftype">struct cryptop *</i><br>
<b class="fname">crypto_getreq</b>(<i class="farg" style="white-space:nowrap;">int</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">crypto_freereq</b>(<i class="farg" style="white-space:nowrap;">struct cryptop *</i>);<p>
<pre style="margin-left: 0.00ex;" class="lit display">
 
#define EALG_MAX_BLOCK_LEN      16 
 
struct cryptoini { 
	int                cri_alg; 
	int                cri_klen; 
	int                cri_rnd; 
	void            *cri_key; 
	u_int8_t           cri_iv[EALG_MAX_BLOCK_LEN]; 
	struct cryptoini  *cri_next; 
}; 
 
struct cryptodesc { 
	int                crd_skip; 
	int                crd_len; 
	int                crd_inject; 
	int                crd_flags; 
	struct cryptoini   CRD_INI; 
	struct cryptodesc *crd_next; 
}; 
 
struct cryptop { 
	TAILQ_ENTRY(cryptop) crp_next; 
	u_int64_t          crp_sid; 
	int                crp_ilen; 
	int                crp_olen; 
	int                crp_etype; 
	int                crp_flags; 
	void            *crp_buf; 
	void            *crp_opaque; 
	struct cryptodesc *crp_desc; 
	int              (*crp_callback)(struct cryptop *); 
	void            *crp_mac; 
}; 
 
struct crparam { 
        void         *crp_p; 
        u_int           crp_nbits; 
}; 
 
#define CRK_MAXPARAM    8 
 
struct cryptkop { 
	TAILQ_ENTRY(cryptkop) krp_next; 
        u_int              krp_op;         /* i.e. CRK_MOD_EXP or other */ 
        u_int              krp_status;     /* return status */ 
        u_short            krp_iparams;    /* # of input parameters */ 
        u_short            krp_oparams;    /* # of output parameters */ 
	u_int32_t	   krp_hid; 
        struct crparam     krp_param[CRK_MAXPARAM];	  /* kvm */ 
        int               (*krp_callback)(struct cryptkop *); 
};</pre>
</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> <b class="name">opencrypto</b> is a framework for drivers of cryptographic hardware to register with the kernel so &#8220;consumers&#8221; (other kernel subsystems, and eventually users through an appropriate device) are able to make use of it. Drivers register with the framework the algorithms they support, and provide entry points (functions) the framework may call to establish, use, and tear down sessions. Sessions are used to cache cryptographic information in a particular driver (or associated hardware), so initialization is not needed with every request. Consumers of cryptographic services pass a set of descriptors that instruct the framework (and the drivers registered with it) of the operations that should be applied on the data (more than one cryptographic operation can be requested).<p>
Keying operations are supported as well. Unlike the symmetric operators described above, these sessionless commands perform mathematical operations using input and output parameters.<p>
Since the consumers may not be associated with a process, drivers may not use condition variables: <a class="link-man" href="../html9/condvar.html">condvar(9)</a>. The same holds for the framework. Thus, a callback mechanism is used to notify a consumer that a request has been completed (the callback is specified by the consumer on an per-request basis). The callback is invoked by the framework whether the request was successfully completed or not. An error indication is provided in the latter case. A specific error code, <span class="errno">EAGAIN</span>, is used to indicate that a session number has changed and that the request may be re-submitted immediately with the new session number. Errors are only returned to the invoking function if not enough information to call the callback is available (meaning, there was a fatal error in verifying the arguments). No callback mechanism is used for session initialization and teardown.<p>
The <b class="fname">crypto_newsession</b>() routine is called by consumers of cryptographic services (such as the <a class="link-man" href="../html4/ipsec.html">ipsec(4)</a> stack) that wish to establish a new session with the framework. On success, the first argument will contain the Session Identifier (SID). The second argument contains all the necessary information for the driver to establish the session. The third argument indicates whether a hardware driver should be used (1) or not (0). The various fields in the <i class="farg">cryptoini</i> structure are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">cri_alg</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Contains an algorithm identifier. Currently supported algorithms are:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
CRYPTO_DES_CBC 
CRYPTO_3DES_CBC 
CRYPTO_BLF_CBC 
CRYPTO_CAST_CBC 
CRYPTO_CAMELLIA_CBC 
CRYPTO_SKIPJACK_CBC 
CRYPTO_ARC4 
CRYPTO_AES_CBC 
CRYPTO_AES_CTR 
CRYPTO_AES_GCM_16 
CRYPTO_AES_GMAC 
CRYPTO_AES_128_GMAC 
CRYPTO_AES_192_GMAC 
CRYPTO_AES_256_GMAC 
CRYPTO_AES_XCBC_MAC_96 
CRYPTO_MD5 
CRYPTO_MD5_HMAC 
CRYPTO_MD5_HMAC_96 
CRYPTO_MD5_KPDK 
CRYPTO_NULL_CBC 
CRYPTO_NULL_HMAC 
CRYPTO_SHA1 
CRYPTO_SHA1_HMAC 
CRYPTO_SHA1_HMAC_96 
CRYPTO_SHA1_KPDK 
CRYPTO_SHA2_256_HMAC 
CRYPTO_SHA2_384_HMAC 
CRYPTO_SHA2_512_HMAC 
CRYPTO_RIPEMD160_HMAC 
CRYPTO_RIPEMD160_HMAC_96 
CRYPTO_DEFLATE_COMP 
CRYPTO_DEFLATE_COMP_NOGROW 
CRYPTO_GZIP_COMP</pre>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">cri_klen</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Specifies the length of the key in bits, for variable-size key algorithms.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">cri_rnd</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Specifies the number of rounds to be used with the algorithm, for variable-round algorithms.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">cri_key</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Contains the key to be used with the algorithm.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">cri_iv</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Contains an explicit initialization vector (IV), if it does not prefix the data. This field is ignored during initialization. If no IV is explicitly passed (see below on details), a random IV is used by the device driver processing the request.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">cri_next</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Contains a pointer to another <i class="farg">cryptoini</i> structure. Multiple such structures may be linked to establish multi-algorithm sessions (<a class="link-man" href="../html4/ipsec.html">ipsec(4)</a> is an example consumer of such a feature).</dd>
</dl>
<p>
The <i class="farg">cryptoini</i> structure and its contents will not be modified by the framework (or the drivers used). Subsequent requests for processing that use the SID returned will avoid the cost of re-initializing the hardware (in essence, SID acts as an index in the session cache of the driver).<p>
<b class="fname">crypto_freesession</b>() is called with the SID returned by <b class="fname">crypto_newsession</b>() to disestablish the session.<p>
<b class="fname">crypto_dispatch</b>() is called to process a request. The various fields in the <i class="farg">cryptop</i> structure are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">crp_sid</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Contains the SID.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">crp_ilen</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Indicates the total length in bytes of the buffer to be processed.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">crp_olen</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
On return, contains the length of the result, not including <i class="farg">crd_skip</i>. For symmetric crypto operations, this will be the same as the input length.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">crp_alloctype</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Indicates the type of buffer, as used in the kernel <a class="link-man" href="../html9/malloc.html">malloc(9)</a> routine. This will be used if the framework needs to allocate a new buffer for the result (or for re-formatting the input).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">crp_callback</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
This routine is invoked upon completion of the request, whether successful or not. It is invoked through the <b class="fname">crypto_done</b>() routine. If the request was not successful, an error code is set in the <i class="farg">crp_etype</i> field. It is the responsibility of the callback routine to set the appropriate <a class="link-man" href="../html9/spl.html">spl(9)</a> level.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">crp_etype</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Contains the error type, if any errors were encountered, or zero if the request was successfully processed. If the <span class="errno">EAGAIN</span> error code is returned, the SID has changed (and has been recorded in the <i class="farg">crp_sid</i> field). The consumer should record the new SID and use it in all subsequent requests. In this case, the request may be re-submitted immediately. This mechanism is used by the framework to perform session migration (move a session from one driver to another, because of availability, performance, or other considerations).<p>
Note that this field only makes sense when examined by the callback routine specified in <i class="farg">crp_callback</i>. Errors are returned to the invoker of <b class="fname">crypto_process</b>() only when enough information is not present to call the callback routine (i.e., if the pointer passed is <span class="define">NULL</span> or if no callback routine was specified).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">crp_flags</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Is a bitmask of flags associated with this request. Currently defined flags are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">CRYPTO_F_IMBUF</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
The buffer pointed to by <i class="farg">crp_buf</i> is an mbuf chain.</dd>
</dl>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">crp_buf</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Points to the input buffer. On return (when the callback is invoked), it contains the result of the request. The input buffer may be an mbuf chain or a contiguous buffer (of a type identified by <i class="farg">crp_alloctype</i>), depending on <i class="farg">crp_flags</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">crp_opaque</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
This is passed through the crypto framework untouched and is intended for the invoking application's use.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">crp_desc</i></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
This is a linked list of descriptors. Each descriptor provides information about what type of cryptographic operation should be done on the input buffer. The various fields are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">crd_skip</i></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
The offset in the input buffer where processing should start.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">crd_len</i></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
How many bytes, after <i class="farg">crd_skip</i>, should be processed.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">crd_inject</i></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
Offset from the beginning of the buffer to insert any results. For encryption algorithms, this is where the initialization vector (IV) will be inserted when encrypting or where it can be found when decrypting (subject to <i class="farg">crd_flags</i>). For MAC algorithms, this is where the result of the keyed hash will be inserted.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">crd_flags</i></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
For adjusting general operation from userland, the following flags are defined:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">CRD_F_ENCRYPT</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
For encryption algorithms, this bit is set when encryption is required (when not set, decryption is performed).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">CRD_F_IV_PRESENT</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
For encryption algorithms, this bit is set when the IV already precedes the data, so the <i class="farg">crd_inject</i> value will be ignored and no IV will be written in the buffer. Otherwise, the IV used to encrypt the packet will be written at the location pointed to by <i class="farg">crd_inject</i>. Some applications that do special &#8220;IV cooking&#8221;, such as the half-IV mode in <a class="link-man" href="../html4/ipsec.html">ipsec(4)</a>, can use this flag to indicate that the IV should not be written on the packet. This flag is typically used in conjunction with the <span class="define">CRD_F_IV_EXPLICIT</span> flag.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">CRD_F_IV_EXPLICIT</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
For encryption algorithms, this bit is set when the IV is explicitly provided by the consumer in the <i class="farg">crd_iv</i> fields. Otherwise, for encryption operations the IV is provided for by the driver used to perform the operation, whereas for decryption operations it is pointed to by the <i class="farg">crd_inject</i> field. This flag is typically used when the IV is calculated &#8220;on the fly&#8221; by the consumer, and does not precede the data (some <a class="link-man" href="../html4/ipsec.html">ipsec(4)</a> configurations, and the encrypted swap are two such examples).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">CRD_F_COMP</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
For compression algorithms, this bit is set when compression is required (when not set, decompression is performed).</dd>
</dl>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">CRD_INI</i></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
This <i class="farg">cryptoini</i> structure will not be modified by the framework or the device drivers. Since this information accompanies every cryptographic operation request, drivers may re-initialize state on-demand (typically an expensive operation). Furthermore, the cryptographic framework may re-route requests as a result of full queues or hardware failure, as described above.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">crd_next</i></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
Point to the next descriptor. Linked operations are useful in protocols such as <a class="link-man" href="../html4/ipsec.html">ipsec(4)</a>, where multiple cryptographic transforms may be applied on the same block of data.</dd>
</dl>
</dd>
</dl>
<p>
<b class="fname">crypto_getreq</b>() allocates a <i class="farg">cryptop</i> structure with a linked list of as many <i class="farg">cryptodesc</i> structures as were specified in the argument passed to it.<p>
<b class="fname">crypto_freereq</b>() deallocates a structure <i class="farg">cryptop</i> and any <i class="farg">cryptodesc</i> structures linked to it. Note that it is the responsibility of the callback routine to do the necessary cleanups associated with the opaque field in the <i class="farg">cryptop</i> structure.<p>
<b class="fname">crypto_kdispatch</b>() is called to perform a keying operation. The various fields in the <i class="farg">crytokop</i> structure are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">krp_op</i></dt>
<dd class="list-tag" style="margin-left: 13.00ex;">
Operation code, such as CRK_MOD_EXP.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">krp_status</i></dt>
<dd class="list-tag" style="margin-left: 13.00ex;">
Return code. This errno-style variable indicates whether there were lower level reasons for operation failure.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">krp_iparams</i></dt>
<dd class="list-tag" style="margin-left: 13.00ex;">
Number of input parameters to the specified operation. Note that each operation has a (typically hardwired) number of such parameters.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">krp_oparams</i></dt>
<dd class="list-tag" style="margin-left: 13.00ex;">
Number of output parameters from the specified operation. Note that each operation has a (typically hardwired) number of such parameters.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">krp_kvp</i></dt>
<dd class="list-tag" style="margin-left: 13.00ex;">
An array of kernel memory blocks containing the parameters.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">krp_hid</i></dt>
<dd class="list-tag" style="margin-left: 13.00ex;">
Identifier specifying which low-level driver is being used.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">krp_callback</i></dt>
<dd class="list-tag" style="margin-left: 13.00ex;">
Callback called on completion of a keying operation.</dd>
</dl>
<p>
The following sysctl entries exist to adjust the behaviour of the system from userland:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
kern.usercrypto</dt>
<dd class="list-tag" style="margin-left: 23.00ex;">
Allow (1) or forbid (0) userland access to <i class="file">/dev/crypto</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
kern.userasymcrypto</dt>
<dd class="list-tag" style="margin-left: 23.00ex;">
Allow (1) or forbid (0) userland access to do asymmetric crypto requests.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
kern.cryptodevallowsoft</dt>
<dd class="list-tag" style="margin-left: 23.00ex;">
Enable/disable access to hardware versus software operations:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
&lt; 0</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Force userlevel requests to use software operations, always.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
= 0</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Use hardware if present, grant userlevel requests for non-accelerated operations (handling the latter in software).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&gt; 0</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Allow user requests only for operations which are hardware-accelerated.</dd>
</dl>
</dd>
</dl>
</div>
<div class="section">
<h1 id="x4452495645521e5349444520415049">DRIVER-SIDE API</h1> The <b class="fname">crypto_get_driverid</b>(), <b class="fname">crypto_register</b>(), <b class="fname">crypto_kregister</b>(), <b class="fname">crypto_unregister</b>(), <b class="fname">crypto_unregister_all</b>(), and <b class="fname">crypto_done</b>() routines are used by drivers that provide support for cryptographic primitives to register and unregister with the kernel crypto services framework. Drivers must first use the <b class="fname">crypto_get_driverid</b>() function to acquire a driver identifier, specifying the <i class="farg">flags</i> as an argument (normally 0, but software-only drivers should specify <span class="define">CRYPTOCAP_F_SOFTWARE</span>). For each algorithm the driver supports, it must then call <b class="fname">crypto_register</b>(). The first argument is the driver identifier. The second argument is an array of <span class="define">CRYPTO_ALGORITHM_MAX + 1</span> elements, indicating which algorithms are supported. The last three arguments are pointers to three driver-provided functions that the framework may call to establish new cryptographic context with the driver, free already established context, and ask for a request to be processed (encrypt, decrypt, etc.) <b class="fname">crypto_unregister</b>() is called by drivers that wish to withdraw support for an algorithm. The two arguments are the driver and algorithm identifiers, respectively. algorithms supported by the card. If all algorithms associated with a driver are unregistered, the driver will be disabled (no new sessions will be allocated on that driver, and any existing sessions will be migrated to other drivers). <b class="fname">crypto_unregister_all</b>() will unregister all registered algorithms, disable the driver, and migrate existing sessions to other drivers.<p>
The calling convention for the three driver-supplied routines is:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
int (*newsession) (void *, u_int32_t *, struct cryptoini *); 
int (*freesession) (void *, u_int64_t); 
int (*process) (void *, struct cryptop *, int);</pre>
<p>
On invocation, the first argument to <b class="fname">newsession</b>() contains the driver identifier obtained via <b class="fname">crypto_get_driverid</b>(). On successfully returning, it should contain a driver-specific session identifier. The second argument is identical to that of <b class="fname">crypto_newsession</b>().<p>
The <b class="fname">freesession</b>() routine takes as argument the SID (which is the concatenation of the driver identifier and the driver-specific session identifier). It should clear any context associated with the session (clear hardware registers, memory, etc.).<p>
The <b class="fname">process</b>() routine is invoked with a request to perform crypto processing. This routine must not block, but should queue the request and return immediately. Upon processing the request, the callback routine should be invoked. In case of error, the error indication must be placed in the <i class="farg">crp_etype</i> field of the <i class="farg">cryptop</i> structure. The <i class="farg">hint</i> argument can be set to <span class="define">CRYPTO_HINT_MORE</span> when there will be more request right after this request. When the request is completed, or an error is detected, the <b class="fname">process</b>() routine should invoke <b class="fname">crypto_done</b>(). Session migration may be performed, as mentioned previously.<p>
The <b class="fname">kprocess</b>() routine is invoked with a request to perform crypto key processing. This routine must not block, but should queue the request and return immediately. Upon processing the request, the callback routine should be invoked. In case of error, the error indication must be placed in the <i class="farg">krp_status</i> field of the <i class="farg">cryptkop</i> structure. When the request is completed, or an error is detected, the <b class="fname">kprocess</b>() routine should invoke <b class="fname">crypto_kdone</b>().</div>
<div class="section">
<h1 id="x52455455524e2056414c554553">RETURN VALUES</h1> <b class="fname">crypto_register</b>(), <b class="fname">crypto_kregister</b>(), <b class="fname">crypto_unregister</b>(), <b class="fname">crypto_newsession</b>(), and <b class="fname">crypto_freesession</b>() return 0 on success, or an error code on failure. <b class="fname">crypto_get_driverid</b>() returns a non-negative value on error, and &#45;1 on failure. <b class="fname">crypto_getreq</b>() returns a pointer to a <i class="farg">cryptop</i> structure and <span class="define">NULL</span> on failure. <b class="fname">crypto_dispatch</b>() returns <span class="errno">EINVAL</span> if its argument or the callback function was <span class="define">NULL</span>, and 0 otherwise. The callback is provided with an error code in case of failure, in the <i class="farg">crp_etype</i> field.</div>
<div class="section">
<h1 id="x46494c4553">FILES</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="file">sys/opencrypto/crypto.c</i></dt>
<dd class="list-tag" style="margin-left: 23.00ex;">
most of the framework code</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="file">sys/crypto</i></dt>
<dd class="list-tag" style="margin-left: 23.00ex;">
crypto algorithm implementations</dd>
</dl>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html4/ipsec.html">ipsec(4)</a>, <a class="link-man" href="../html4/pcmcia.html">pcmcia(4)</a>, <a class="link-man" href="../html9/condvar.html">condvar(9)</a>, <a class="link-man" href="../html9/malloc.html">malloc(9)</a><p>
<span class="ref"><span class="ref-auth">Angelos D. Keromytis</span>, <span class="ref-auth">Jason L. Wright</span>, and <span class="ref-auth">Theo de Raadt</span>, <span class="ref-title">The Design of the OpenBSD Cryptographic Framework</span>, <i class="ref-issue">Usenix</i>, <span class="ref-num">2003</span>, <span class="ref-date">June 2003</span>.</span></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The cryptographic framework first appeared in <span class="unix">OpenBSD&#160;2.7</span> and was written by <span class="author">Angelos D. Keromytis</span> &#60;<a class="link-mail" href="mailto:angelos@openbsd.org">angelos@openbsd.org</a>&#62;.<p>
<span class="author">Sam Leffler</span> ported the crypto framework to <span class="unix">FreeBSD</span> and made performance improvements.<p>
<span class="author">Jonathan Stone</span> &#60;<a class="link-mail" href="mailto:jonathan@NetBSD.org">jonathan@NetBSD.org</a>&#62; ported the cryptoframe from <span class="unix">FreeBSD</span> to <span class="unix">NetBSD</span>. <b class="name">opencrypto</b> first appeared in <span class="unix">NetBSD&#160;2.0</span>.</div>
<div class="section">
<h1 id="x42554753">BUGS</h1> The framework currently assumes that all the algorithms in a <b class="fname">crypto_newsession</b>() operation must be available by the same driver. If that's not the case, session initialization will fail.<p>
The framework also needs a mechanism for determining which driver is best for a specific set of algorithms associated with a session. Some type of benchmarking is in order here.<p>
Multiple instances of the same algorithm in the same session are not supported. Note that 3DES is considered one algorithm (and not three instances of DES). Thus, 3DES and DES could be mixed in the same request.<p>
A queue for completed operations should be implemented and processed at some software <a class="link-man" href="../html9/spl.html">spl(9)</a> level, to avoid overall system latency issues, and potential kernel stack exhaustion while processing a callback.<p>
When SMP time comes, we will support use of a second processor (or more) as a crypto device (this is actually AMP, but we need the same basic support).</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
December 30, 2013</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

