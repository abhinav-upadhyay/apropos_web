<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="/static/man_pages/netbsd/style.css" type="text/css" media="all">
<title>
MBUF(9)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
MBUF(9)</td>
<td class="head-vol" align="center">
Kernel Developer's Manual</td>
<td class="head-rtitle" align="right">
MBUF(9)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">mbuf</b>, <b class="name">m_get</b>, <b class="name">m_getclr</b>, <b class="name">m_gethdr</b>, <b class="name">m_devget</b>, <b class="name">m_copym</b>, <b class="name">m_copypacket</b>, <b class="name">m_copydata</b>, <b class="name">m_copyback</b>, <b class="name">m_copyback_cow</b>, <b class="name">m_cat</b>, <b class="name">m_dup</b>, <b class="name">m_makewritable</b>, <b class="name">m_prepend</b>, <b class="name">m_pulldown</b>, <b class="name">m_pullup</b>, <b class="name">m_copyup</b>, <b class="name">m_split</b>, <b class="name">m_adj</b>, <b class="name">m_apply</b>, <b class="name">m_free</b>, <b class="name">m_freem</b>, <b class="name">mtod</b>, <b class="name">MGET</b>, <b class="name">MGETHDR</b>, <b class="name">MEXTMALLOC</b>, <b class="name">MEXTADD</b>, <b class="name">MCLGET</b>, <b class="name">M_COPY_PKTHDR</b>, <b class="name">M_MOVE_PKTHDR</b>, <b class="name">M_ALIGN</b>, <b class="name">MH_ALIGN</b>, <b class="name">M_LEADINGSPACE</b>, <b class="name">M_TRAILINGSPACE</b>, <b class="name">M_PREPEND</b>, <b class="name">MCHTYPE</b>, <b class="name">MFREE</b> &#8212; <span class="desc">functions and macros for managing memory used by networking code</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/mbuf.h</a>&gt;</b><p>
<i class="ftype">struct mbuf *</i><br>
<b class="fname">m_get</b>(<i class="farg" style="white-space:nowrap;">int nowait</i>, <i class="farg" style="white-space:nowrap;">int type</i>);<p>
<i class="ftype">struct mbuf *</i><br>
<b class="fname">m_getclr</b>(<i class="farg" style="white-space:nowrap;">int nowait</i>, <i class="farg" style="white-space:nowrap;">int type</i>);<p>
<i class="ftype">struct mbuf *</i><br>
<b class="fname">m_gethdr</b>(<i class="farg" style="white-space:nowrap;">int nowait</i>, <i class="farg" style="white-space:nowrap;">int type</i>);<p>
<i class="ftype">struct mbuf *</i><br>
<b class="fname">m_devget</b>(<i class="farg" style="white-space:nowrap;">char *buf</i>, <i class="farg" style="white-space:nowrap;">int totlen</i>, <i class="farg" style="white-space:nowrap;">int off0</i>, <i class="farg" style="white-space:nowrap;">struct ifnet *ifp</i>, <i class="farg" style="white-space:nowrap;">void (*copy)(const void *, void *, size_t)</i>);<p>
<i class="ftype">struct mbuf *</i><br>
<b class="fname">m_copym</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>, <i class="farg" style="white-space:nowrap;">int off0</i>, <i class="farg" style="white-space:nowrap;">int len</i>, <i class="farg" style="white-space:nowrap;">int wait</i>);<p>
<i class="ftype">struct mbuf *</i><br>
<b class="fname">m_copypacket</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>, <i class="farg" style="white-space:nowrap;">int how</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">m_copydata</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>, <i class="farg" style="white-space:nowrap;">int off</i>, <i class="farg" style="white-space:nowrap;">int len</i>, <i class="farg" style="white-space:nowrap;">void *cp</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">m_copyback</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m0</i>, <i class="farg" style="white-space:nowrap;">int off</i>, <i class="farg" style="white-space:nowrap;">int len</i>, <i class="farg" style="white-space:nowrap;">void *cp</i>);<p>
<i class="ftype">struct mbuf *</i><br>
<b class="fname">m_copyback_cow</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m0</i>, <i class="farg" style="white-space:nowrap;">int off</i>, <i class="farg" style="white-space:nowrap;">int len</i>, <i class="farg" style="white-space:nowrap;">void *cp</i>, <i class="farg" style="white-space:nowrap;">int how</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">m_makewritable</b>(<i class="farg" style="white-space:nowrap;">struct mbuf **mp</i>, <i class="farg" style="white-space:nowrap;">int off</i>, <i class="farg" style="white-space:nowrap;">int len</i>, <i class="farg" style="white-space:nowrap;">int how</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">m_cat</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>, <i class="farg" style="white-space:nowrap;">struct mbuf *n</i>);<p>
<i class="ftype">struct mbuf *</i><br>
<b class="fname">m_dup</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>, <i class="farg" style="white-space:nowrap;">int off0</i>, <i class="farg" style="white-space:nowrap;">int len</i>, <i class="farg" style="white-space:nowrap;">int wait</i>);<p>
<i class="ftype">struct mbuf *</i><br>
<b class="fname">m_prepend</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>, <i class="farg" style="white-space:nowrap;">int len</i>, <i class="farg" style="white-space:nowrap;">int how</i>);<p>
<i class="ftype">struct mbuf *</i><br>
<b class="fname">m_pulldown</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>, <i class="farg" style="white-space:nowrap;">int off</i>, <i class="farg" style="white-space:nowrap;">int len</i>, <i class="farg" style="white-space:nowrap;">int *offp</i>);<p>
<i class="ftype">struct mbuf *</i><br>
<b class="fname">m_pullup</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *n</i>, <i class="farg" style="white-space:nowrap;">int len</i>);<p>
<i class="ftype">struct mbuf *</i><br>
<b class="fname">m_copyup</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>, <i class="farg" style="white-space:nowrap;">int len</i>, <i class="farg" style="white-space:nowrap;">int dstoff</i>);<p>
<i class="ftype">struct mbuf *</i><br>
<b class="fname">m_split</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m0</i>, <i class="farg" style="white-space:nowrap;">int len0</i>, <i class="farg" style="white-space:nowrap;">int wait</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">m_adj</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *mp</i>, <i class="farg" style="white-space:nowrap;">int req_len</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">m_apply</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>, <i class="farg" style="white-space:nowrap;">int off</i>, <i class="farg" style="white-space:nowrap;">int len</i>, <i class="farg" style="white-space:nowrap;">int *f(void *, void *, unsigned int)</i>, <i class="farg" style="white-space:nowrap;">void *arg</i>);<p>
<i class="ftype">struct mbuf *</i><br>
<b class="fname">m_free</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">m_freem</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>);<p>
<i class="ftype">datatype</i><br>
<b class="fname">mtod</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>, <i class="farg" style="white-space:nowrap;">datatype</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">MGET</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>, <i class="farg" style="white-space:nowrap;">int how</i>, <i class="farg" style="white-space:nowrap;">int type</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">MGETHDR</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>, <i class="farg" style="white-space:nowrap;">int how</i>, <i class="farg" style="white-space:nowrap;">int type</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">MEXTMALLOC</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>, <i class="farg" style="white-space:nowrap;">int len</i>, <i class="farg" style="white-space:nowrap;">int how</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">MEXTADD</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>, <i class="farg" style="white-space:nowrap;">void *buf</i>, <i class="farg" style="white-space:nowrap;">int size</i>, <i class="farg" style="white-space:nowrap;">int type</i>, <i class="farg" style="white-space:nowrap;">void (*free)(struct mbuf *, void *, size_t, void *)</i>, <i class="farg" style="white-space:nowrap;">void *arg</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">MCLGET</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>, <i class="farg" style="white-space:nowrap;">int how</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">M_COPY_PKTHDR</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *to</i>, <i class="farg" style="white-space:nowrap;">struct mbuf *from</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">M_MOVE_PKTHDR</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *to</i>, <i class="farg" style="white-space:nowrap;">struct mbuf *from</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">M_ALIGN</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>, <i class="farg" style="white-space:nowrap;">int len</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">MH_ALIGN</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>, <i class="farg" style="white-space:nowrap;">int len</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">M_LEADINGSPACE</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">M_TRAILINGSPACE</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">M_PREPEND</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>, <i class="farg" style="white-space:nowrap;">int plen</i>, <i class="farg" style="white-space:nowrap;">int how</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">MCHTYPE</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>, <i class="farg" style="white-space:nowrap;">int type</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">MFREE</b>(<i class="farg" style="white-space:nowrap;">struct mbuf *m</i>, <i class="farg" style="white-space:nowrap;">struct mbuf *n</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <b class="name">mbuf</b> functions and macros provide an easy and consistent way to handle a networking stack's memory management needs. An <b class="name">mbuf</b> consists of a header and a data area. It is of a fixed size, <span class="define">MSIZE</span> (defined in &#60;<i class="file">machine/param.h</i>&#62;), which includes overhead. The header contains a pointer to the next <b class="name">mbuf</b> in the &#8216;mbuf chain&#8217;, a pointer to the next &#8216;mbuf chain&#8217;, a pointer to the data area, the amount of data in this mbuf, its type and a <span class="define">flags</span> field.<p>
The <span class="define">type</span> variable can signify:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">MT_FREE</span></dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
the mbuf should be on the ``free'' list</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">MT_DATA</span></dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
data was dynamically allocated</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">MT_HEADER</span></dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
data is a packet header</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">MT_SONAME</span></dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
data is a socket name</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">MT_SOOPTS</span></dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
data is socket options</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">MT_FTABLE</span></dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
data is the fragment reassembly header</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">MT_CONTROL</span></dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
mbuf contains ancillary (protocol control) data</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">MT_OOBDATA</span></dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
mbuf contains out-of-band data.</dd>
</dl>
<p>
The <span class="define">flags</span> variable contains information describing the <b class="name">mbuf</b>, notably:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">M_EXT</span></dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
has external storage</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">M_PKTHDR</span></dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
is start of record</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">M_EOR</span></dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
is end of record</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">M_CLUSTER</span></dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
external storage is a cluster.</dd>
</dl>
<p>
If an <b class="name">mbuf</b> designates the start of a record (<span class="define">M_PKTHDR</span>), its <span class="define">flags</span> field may contain additional information describing the content of the record:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">M_BCAST</span></dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
sent/received as link-level broadcast</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">M_MCAST</span></dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
sent/received as link-level multicast</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">M_LINK0</span>,</dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">M_LINK1</span>,</dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">M_LINK2</span></dt>
<dd class="list-tag" style="margin-left: 11.00ex;">
three link-level specific flags.</dd>
</dl>
<p>
An <b class="name">mbuf</b> may add a single &#8216;mbuf cluster&#8217; of <span class="define">MCLBYTES</span> bytes (also defined in &#60;<i class="file">machine/param.h</i>&#62;), which has no additional overhead and is used instead of the internal data area; this is done when at least <span class="define">MINCLSIZE</span> bytes of data must be stored.<p>
When the <span class="define">M_EXT</span> flag is raised for an mbuf, the external storage area could be shared among multiple mbufs. Be careful when you attempt to overwrite the data content of the mbuf.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_get</b>(<i class="farg">int nowait</i>, <i class="farg">int type</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Allocates an mbuf and initializes it to contain internal data. The <i class="farg">nowait</i> parameter is a choice of <span class="define">M_WAIT / M_DONTWAIT</span> from caller. <span class="define">M_WAIT</span> means the call cannot fail, but may take forever. The <i class="farg">type</i> parameter is an mbuf type.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_getclr</b>(<i class="farg">int nowait</i>, <i class="farg">int type</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Allocates an mbuf and initializes it to contain internal data, then zeros the data area. The <i class="farg">nowait</i> parameter is a choice of <span class="define">M_WAIT / M_DONTWAIT</span> from caller. The <i class="farg">type</i> parameter is an mbuf type.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_gethdr</b>(<i class="farg">int nowait</i>, <i class="farg">int type</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Allocates an mbuf and initializes it to contain a packet header and internal data. The <i class="farg">nowait</i> parameter is a choice of <span class="define">M_WAIT / M_DONTWAIT</span> from caller. The <i class="farg">type</i> parameter is an mbuf type.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_devget</b>(<i class="farg">char *buf</i>, <i class="farg">int totlen</i>, <i class="farg">int off0</i>, <i class="farg">struct ifnet *ifp</i>, <i class="farg">void (*copy)(const void *, void *, size_t)</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Copies <i class="farg">len</i> bytes from device local memory into mbufs using copy routine <i class="farg">copy</i>. If parameter <i class="farg">off</i> is non-zero, the packet is supposed to be trailer-encapsulated and <i class="farg">off</i> bytes plus the type and length fields will be skipped before copying. Returns the top of the mbuf chain it created.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_copym</b>(<i class="farg">struct mbuf *m</i>, <i class="farg">int off0</i>, <i class="farg">int len</i>, <i class="farg">int wait</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Creates a copy of an mbuf chain starting <i class="farg">off0</i> bytes from the beginning, continuing for <i class="farg">len</i> bytes. If the <i class="farg">len</i> requested is <span class="define">M_COPYALL</span>, the complete mbuf chain will be copied. The <i class="farg">wait</i> parameter is a choice of <span class="define">M_WAIT / M_DONTWAIT</span> from caller.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_copypacket</b>(<i class="farg">struct mbuf *m</i>, <i class="farg">int how</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Copies an entire packet, including header (which must be present). This function is an optimization of the common case <code class="lit">m_copym(m, 0,</code> <span class="define">M_COPYALL,</span> <i class="farg">how</i>).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_copydata</b>(<i class="farg">struct mbuf *m</i>, <i class="farg">int off</i>, <i class="farg">int len</i>, <i class="farg">void *cp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Copies <i class="farg">len</i> bytes data from mbuf chain <i class="farg">m</i> into the buffer <i class="farg">cp</i>, starting <i class="farg">off</i> bytes from the beginning.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_copyback</b>(<i class="farg">struct mbuf *m0</i>, <i class="farg">int off</i>, <i class="farg">int len</i>, <i class="farg">void *cp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Copies <i class="farg">len</i> bytes data from buffer <i class="farg">cp</i> back into the mbuf chain <i class="farg">m0</i>, starting <i class="farg">off</i> bytes from the beginning of the chain, extending the mbuf chain if necessary. <b class="fname">m_copyback</b>() can only fail when extending the chain. The caller should check for this kind of failure by checking the resulting length of the chain in that case. It is an error to use <b class="fname">m_copyback</b>() on read-only mbufs.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_copyback_cow</b>(<i class="farg">struct mbuf *m0</i>, <i class="farg">int off</i>, <i class="farg">int len</i>, <i class="farg">void *cp</i>, <i class="farg">int how</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Copies <i class="farg">len</i> bytes data from buffer <i class="farg">cp</i> back into the mbuf chain <i class="farg">m0</i> as <b class="fname">m_copyback</b>() does. Unlike <b class="fname">m_copyback</b>(), it is safe to use <b class="fname">m_copyback_cow</b>() on read-only mbufs. If needed, <b class="fname">m_copyback_cow</b>() automatically allocates new mbufs and adjusts the chain. On success, it returns a pointer to the resulting mbuf chain, and frees the original mbuf <i class="farg">m0</i>. Otherwise, it returns <span class="define">NULL</span>. The <i class="farg">how</i> parameter is a choice of <span class="define">M_WAIT / M_DONTWAIT</span> from the caller. Unlike <b class="fname">m_copyback</b>(), extending the mbuf chain isn't supported. It is an error to attempt to extend the mbuf chain using <b class="fname">m_copyback_cow</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_makewritable</b>(<i class="farg">struct mbuf **mp</i>, <i class="farg">int off</i>, <i class="farg">int len</i>, <i class="farg">int how</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Rearranges an mbuf chain so that <i class="farg">len</i> bytes from offset <i class="farg">off</i> are writable. When it meets read-only mbufs, it allocates new mbufs, adjusts the chain as <b class="fname">m_copyback_cow</b>() does, and copies the original content into them. <b class="fname">m_makewritable</b>() does <span class="emph">not</span> guarantee that all <i class="farg">len</i> bytes at <i class="farg">off</i> are consecutive. The <i class="farg">how</i> parameter is a choice of <span class="define">M_WAIT / M_DONTWAIT</span> from the caller. <b class="fname">m_makewritable</b>() preserves the contents of the mbuf chain even in the case of failure. It updates a pointer to the mbuf chain pointed to by <i class="farg">mp</i>. It returns 0 on success. Otherwise, it returns an error code, typically <span class="errno">ENOBUFS</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_cat</b>(<i class="farg">struct mbuf *m</i>, <i class="farg">struct mbuf *n</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Concatenates mbuf chain <i class="farg">n</i> to <i class="farg">m</i>. Both chains must be of the same type; packet headers will <span class="emph">not</span> be updated if present.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_dup</b>(<i class="farg">struct mbuf *m</i>, <i class="farg">int off0</i>, <i class="farg">int len</i>, <i class="farg">int wait</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Similarly to <b class="fname">m_copym</b>(), the function creates a copy of an mbuf chain starting <i class="farg">off0</i> bytes from the beginning, continuing for <i class="farg">len</i> bytes. While <b class="fname">m_copym</b>() tries to share external storage for mbufs with <span class="define">M_EXT</span> flag, <b class="fname">m_dup</b>() will deep-copy the whole data content into new mbuf chain and avoids shared external storage.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_prepend</b>(<i class="farg">struct mbuf *m</i>, <i class="farg">int len</i>, <i class="farg">int how</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Lesser-used path for <b class="fname">M_PREPEND</b>(): allocates new mbuf <i class="farg">m</i> of size <i class="farg">len</i> to prepend to the chain, copying junk along. The <i class="farg">how</i> parameter is a choice of <span class="define">M_WAIT / M_DONTWAIT</span> from caller.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_pulldown</b>(<i class="farg">struct mbuf *m</i>, <i class="farg">int off</i>, <i class="farg">int len</i>, <i class="farg">int *offp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Rearranges an mbuf chain so that <i class="farg">len</i> bytes from offset <i class="farg">off</i> are contiguous and in the data area of an mbuf. The return value points to an mbuf in the middle of the mbuf chain <i class="farg">m</i>. If we call the return value <i class="farg">n</i>, the contiguous data region is available at <code class="lit">mtod(n, void *) + *offp</code>, or <code class="lit">mtod(n, void *)</code> if <i class="farg">offp</i> is <span class="define">NULL</span>. The top of the mbuf chain <i class="farg">m</i>, and mbufs up to <i class="farg">off</i>, will not be modified. On successful return, it is guaranteed that the mbuf pointed to by <i class="farg">n</i> does not have a shared external storage, therefore it is safe to update the contiguous region. Returns <span class="define">NULL</span> and frees the mbuf chain on failure. <i class="farg">len</i> must be smaller or equal than <span class="define">MCLBYTES</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_pullup</b>(<i class="farg">struct mbuf *m</i>, <i class="farg">int len</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Rearranges an mbuf chain so that <i class="farg">len</i> bytes are contiguous and in the data area of an mbuf (so that <b class="fname">mtod</b>() will work for a structure of size <i class="farg">len</i>). Returns the resulting mbuf chain on success, frees it and returns <span class="define">NULL</span> on failure. If there is room, it will add up to <span class="define">max_protohdr</span> - <i class="farg">len</i> extra bytes to the contiguous region to possibly avoid being called again. <i class="farg">len</i> must be smaller or equal than <span class="define">MHLEN</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_copyup</b>(<i class="farg">struct mbuf *m</i>, <i class="farg">int len</i>, <i class="farg">int dstoff</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Similar to <b class="fname">m_pullup</b>() but copies <i class="farg">len</i> bytes of data into a new mbuf at <i class="farg">dstoff</i> bytes into the mbuf. The <i class="farg">dstoff</i> argument aligns the data and leaves room for a link layer header. Returns the new mbuf chain on success, and frees the mbuf chain and returns <span class="define">NULL</span> on failure. Note that the function does not allocate mbuf clusters, so <i class="farg">len + dstoff</i> must be less than <span class="define">MHLEN</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_split</b>(<i class="farg">struct mbuf *m0</i>, <i class="farg">int len0</i>, <i class="farg">int wait</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Partitions an mbuf chain in two pieces, returning the tail, which is all but the first <i class="farg">len0</i> bytes. In case of failure, it returns <span class="define">NULL</span> and attempts to restore the chain to its original state.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_adj</b>(<i class="farg">struct mbuf *mp</i>, <i class="farg">int req_len</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Shaves off <i class="farg">req_len</i> bytes from head or tail of the (valid) data area. If <i class="farg">req_len</i> is greater than zero, front bytes are being shaved off, if it's smaller, from the back (and if it is zero, the mbuf will stay bearded). This function does not move data in any way, but is used to manipulate the data area pointer and data length variable of the mbuf in a non-clobbering way.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_apply</b>(<i class="farg">struct mbuf *m</i>, <i class="farg">int off</i>, <i class="farg">int len</i>, <i class="farg">int (*f)(void *, void *, unsigned int)</i>, <i class="farg">void *arg</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Apply function <i class="farg">f</i> to the data in an mbuf chain starting <i class="farg">off</i> bytes from the beginning, continuing for <i class="farg">len</i> bytes. Neither <i class="farg">off</i> nor <i class="farg">len</i> may be negative. <i class="farg">arg</i> will be supplied as first argument for <i class="farg">f</i>, the second argument will be the pointer to the data buffer of a packet (starting after <i class="farg">off</i> bytes in the stream), and the third argument is the amount of data in bytes in this call. If <i class="farg">f</i> returns something not equal to zero <b class="fname">m_apply</b>() will bail out, returning the return code of <i class="farg">f</i>. Upon successful completion it will return zero.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_free</b>(<i class="farg">struct mbuf *m</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Frees mbuf <i class="farg">m</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">m_freem</b>(<i class="farg">struct mbuf *m</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Frees the mbuf chain beginning with <i class="farg">m</i>. This function contains the elementary sanity check for a <span class="define">NULL</span> pointer.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">mtod</b>(<i class="farg">struct mbuf *m</i>, <i class="farg">datatype</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Returns a pointer to the data contained in the specified mbuf <i class="farg">m</i>, type-casted to the specified data type <i class="farg">datatype</i>. Implemented as a macro.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">MGET</b>(<i class="farg">struct mbuf *m</i>, <i class="farg">int how</i>, <i class="farg">int type</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Allocates mbuf <i class="farg">m</i> and initializes it to contain internal data. See <b class="fname">m_get</b>(). Implemented as a macro.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">MGETHDR</b>(<i class="farg">struct mbuf *m</i>, <i class="farg">int how</i>, <i class="farg">int type</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Allocates mbuf <i class="farg">m</i> and initializes it to contain a packet header. See <b class="fname">m_gethdr</b>(). Implemented as a macro.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">MEXTMALLOC</b>(<i class="farg">struct mbuf *m</i>, <i class="farg">int len</i>, <i class="farg">int how</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Allocates external storage of size <i class="farg">len</i> for mbuf <i class="farg">m</i>. The <i class="farg">how</i> parameter is a choice of <span class="define">M_WAIT / M_DONTWAIT</span> from caller. The flag <span class="define">M_EXT</span> is set upon success. Implemented as a macro.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">MEXTADD</b>(<i class="farg">struct mbuf *m</i>, <i class="farg">void *buf</i>, <i class="farg">int size</i>, <i class="farg">int type</i>, <i class="farg">void (*free)(struct mbuf *, void *, size_t, void *)</i>, <i class="farg">void *arg</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Adds pre-allocated external storage <i class="farg">buf</i> to a normal mbuf <i class="farg">m</i>; the parameters <i class="farg">size</i>, <i class="farg">type</i>, <i class="farg">free</i> and <i class="farg">arg</i> describe the external storage. <i class="farg">size</i> is the size of the storage, <i class="farg">type</i> describes its <a class="link-man" href="../9/malloc">malloc(9)</a> type, <i class="farg">free</i> is a free routine (if not the usual one), and <i class="farg">arg</i> is a possible argument to the free routine. The flag <span class="define">M_EXT</span> is set upon success. Implemented as a macro. If a free routine is specified, it will be called when the mbuf is freed. In the case of former, the first argument for a free routine is the mbuf <i class="farg">m</i> and the routine is expected to free it in addition to the external storage pointed by second argument. In the case of latter, the first argument for the routine is NULL.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">MCLGET</b>(<i class="farg">struct mbuf *m</i>, <i class="farg">int how</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Allocates and adds an mbuf cluster to a normal mbuf <i class="farg">m</i>. The <i class="farg">how</i> parameter is a choice of <span class="define">M_WAIT / M_DONTWAIT</span> from caller. The flag <span class="define">M_EXT</span> is set upon success. Implemented as a macro.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">M_COPY_PKTHDR</b>(<i class="farg">struct mbuf *to</i>, <i class="farg">struct mbuf *from</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Copies the mbuf pkthdr from mbuf <i class="farg">from</i> to mbuf <i class="farg">to</i>. <i class="farg">from</i> must have the type flag <span class="define">M_PKTHDR</span> set, and <i class="farg">to</i> must be empty. Implemented as a macro.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">M_MOVE_PKTHDR</b>(<i class="farg">struct mbuf *to</i>, <i class="farg">struct mbuf *from</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Moves the mbuf pkthdr from mbuf <i class="farg">from</i> to mbuf <i class="farg">to</i>. <i class="farg">from</i> must have the type flag <span class="define">M_PKTHDR</span> set, and <i class="farg">to</i> must be empty. The flag <span class="define">M_PKTHDR</span> in mbuf <i class="farg">from</i> will be cleared.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">M_ALIGN</b>(<i class="farg">struct mbuf *m</i>, <i class="farg">int len</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Sets the data pointer of a newly allocated mbuf <i class="farg">m</i> to <i class="farg">len</i> bytes from the end of the mbuf data area, so that <i class="farg">len</i> bytes of data written to the mbuf <i class="farg">m</i>, starting at the data pointer, will be aligned to the end of the data area. Implemented as a macro.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">MH_ALIGN</b>(<i class="farg">struct mbuf *m</i>, <i class="farg">int len</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Sets the data pointer of a newly allocated packetheader mbuf <i class="farg">m</i> to <i class="farg">len</i> bytes from the end of the mbuf data area, so that <i class="farg">len</i> bytes of data written to the mbuf <i class="farg">m</i>, starting at the data pointer, will be aligned to the end of the data area. Implemented as a macro.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">M_LEADINGSPACE</b>(<i class="farg">struct mbuf *m</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Returns the amount of space available before the current start of valid data in mbuf <i class="farg">m</i>. Returns 0 if the mbuf data part is shared across multiple mbufs (i.e. not writable). Implemented as a macro.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">M_TRAILINGSPACE</b>(<i class="farg">struct mbuf *m</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Returns the amount of space available after the current end of valid data in mbuf <i class="farg">m</i>. Returns 0 if the mbuf data part is shared across multiple mbufs (i.e. not writable). Implemented as a macro.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">M_PREPEND</b>(<i class="farg">struct mbuf *m</i>, <i class="farg">int plen</i>, <i class="farg">int how</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Prepends space of size <i class="farg">plen</i> to mbuf <i class="farg">m</i>. If a new mbuf must be allocated, <i class="farg">how</i> specifies whether to wait. If <i class="farg">how</i> is <span class="define">M_DONTWAIT</span> and allocation fails, the original mbuf chain is freed and <i class="farg">m</i> is set to <span class="define">NULL</span>. Implemented as a macro.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">MCHTYPE</b>(<i class="farg">struct mbuf *m</i>, <i class="farg">int type</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Change mbuf <i class="farg">m</i> to new type <i class="farg">type</i>. Implemented as a macro.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">MFREE</b>(<i class="farg">struct mbuf *m</i>, <i class="farg">struct mbuf *n</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Frees a single mbuf <i class="farg">m</i> and places the successor, if any, in mbuf <i class="farg">n</i>. Implemented as a macro.</dd>
</dl>
</div>
<div class="section">
<h1 id="x434f4445205245464552454e434553">CODE REFERENCES</h1> The <b class="name">mbuf</b> management functions are implemented within the file <i class="file">sys/kern/uipc_mbuf.c</i>. Function prototypes, and the functions implemented as macros are located in <i class="file">sys/sys/mbuf.h</i>.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <i class="file">/usr/share/doc/smm/18.net</i>, <a class="link-man" href="../1/netstat">netstat(1)</a>, <a class="link-man" href="../9/m_tag">m_tag(9)</a>, <a class="link-man" href="../9/malloc">malloc(9)</a><p>
<span class="ref"><span class="ref-auth">Jun-ichiro Hagino</span>, <span class="ref-title">Mbuf issues in 4.4BSD IPv6/IPsec support (experiences from KAME IPv6/IPsec implementation)</span>, <i class="ref-book">Proceedings of the freenix track: 2000 USENIX annual technical conference</i>, <span class="ref-date">June 2000</span>.</span></div>
<div class="section">
<h1 id="x415554484f5253">AUTHORS</h1> <span class="author"></span>The original mbuf data structures were designed by Rob Gurwitz when he did the initial TCP/IP implementation at BBN.<p>
Further extensions and enhancements were made by Bill Joy, Sam Leffler, and Mike Karels at CSRG.<p>
Current implementation of external storage by <span class="author">Matt Thomas</span> &#60;matt@3am-software.com&#62; and <span class="author">Jason R. Thorpe</span> &#60;thorpej@NetBSD.org&#62;.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
June 17, 2013</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

