<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
VNODE(9)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
VNODE(9)</td>
<td class="head-vol" align="center">
Kernel Developer's Manual</td>
<td class="head-rtitle" align="right">
VNODE(9)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">vnode</b>, <b class="name">vref</b>, <b class="name">vrele</b>, <b class="name">vrele_async</b>, <b class="name">vget</b>, <b class="name">vput</b>, <b class="name">vhold</b>, <b class="name">holdrele</b>, <b class="name">vcache_get</b>, <b class="name">vcache_new</b>, <b class="name">vcache_rekey_enter</b>, <b class="name">vcache_rekey_exit</b>, <b class="name">vcache_remove</b>, <b class="name">vrecycle</b>, <b class="name">vgone</b>, <b class="name">vgonel</b>, <b class="name">vdead_check</b>, <b class="name">vflush</b>, <b class="name">vaccess</b>, <b class="name">bdevvp</b>, <b class="name">cdevvp</b>, <b class="name">vfinddev</b>, <b class="name">vdevgone</b>, <b class="name">vwakeup</b>, <b class="name">vflushbuf</b>, <b class="name">vinvalbuf</b>, <b class="name">vtruncbuf</b>, <b class="name">vprint</b> &#8212; <span class="desc">kernel representation of a file or directory</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/param.h</a>&gt;</b><br>
<b class="includes">#include &lt;<a class="link-includes">sys/vnode.h</a>&gt;</b><p>
<i class="ftype">void</i><br>
<b class="fname">vref</b>(<i class="farg" style="white-space:nowrap;">struct vnode *vp</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">vrele</b>(<i class="farg" style="white-space:nowrap;">struct vnode *vp</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">vrele_async</b>(<i class="farg" style="white-space:nowrap;">struct vnode *vp</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">vget</b>(<i class="farg" style="white-space:nowrap;">struct vnode *vp</i>, <i class="farg" style="white-space:nowrap;">int lockflag</i>, <i class="farg" style="white-space:nowrap;">int wait</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">vput</b>(<i class="farg" style="white-space:nowrap;">struct vnode *vp</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">vhold</b>(<i class="farg" style="white-space:nowrap;">struct vnode *vp</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">holdrele</b>(<i class="farg" style="white-space:nowrap;">struct vnode *vp</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">vcache_get</b>(<i class="farg" style="white-space:nowrap;">struct mount *mp</i>, <i class="farg" style="white-space:nowrap;">const void *key</i>, <i class="farg" style="white-space:nowrap;">size_t key_len</i>, <i class="farg" style="white-space:nowrap;">struct vnode **vpp</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">vcache_new</b>(<i class="farg" style="white-space:nowrap;">struct mount *mp</i>, <i class="farg" style="white-space:nowrap;">struct vnode *dvp</i>, <i class="farg" style="white-space:nowrap;">struct vattr *vap</i>, <i class="farg" style="white-space:nowrap;">kauth_cred_t cred</i>, <i class="farg" style="white-space:nowrap;">struct vnode **vpp</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">vcache_rekey_enter</b>(<i class="farg" style="white-space:nowrap;">struct mount *mp</i>, <i class="farg" style="white-space:nowrap;">struct vnode *vp</i>, <i class="farg" style="white-space:nowrap;">const void *old_key</i>, <i class="farg" style="white-space:nowrap;">size_t old_key_len</i>, <i class="farg" style="white-space:nowrap;">const void *new_key</i>, <i class="farg" style="white-space:nowrap;">size_t new_key_len</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">vcache_rekey_exit</b>(<i class="farg" style="white-space:nowrap;">struct mount *mp</i>, <i class="farg" style="white-space:nowrap;">struct vnode *vp</i>, <i class="farg" style="white-space:nowrap;">const void *old_key</i>, <i class="farg" style="white-space:nowrap;">size_t old_key_len</i>, <i class="farg" style="white-space:nowrap;">const void *new_key</i>, <i class="farg" style="white-space:nowrap;">size_t new_key_len</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">vcache_remove</b>(<i class="farg" style="white-space:nowrap;">struct mount *mp</i>, <i class="farg" style="white-space:nowrap;">const void *key</i>, <i class="farg" style="white-space:nowrap;">size_t key_len</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">vrecycle</b>(<i class="farg" style="white-space:nowrap;">struct vnode *vp</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">vgone</b>(<i class="farg" style="white-space:nowrap;">struct vnode *vp</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">vgonel</b>(<i class="farg" style="white-space:nowrap;">struct vnode *vp</i>, <i class="farg" style="white-space:nowrap;">struct lwp *l</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">vdead_check</b>(<i class="farg" style="white-space:nowrap;">struct vnode *vp</i>, <i class="farg" style="white-space:nowrap;">int flags</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">vflush</b>(<i class="farg" style="white-space:nowrap;">struct mount *mp</i>, <i class="farg" style="white-space:nowrap;">struct vnode *skipvp</i>, <i class="farg" style="white-space:nowrap;">int flags</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">vaccess</b>(<i class="farg" style="white-space:nowrap;">enum vtype type</i>, <i class="farg" style="white-space:nowrap;">mode_t file_mode</i>, <i class="farg" style="white-space:nowrap;">uid_t uid</i>, <i class="farg" style="white-space:nowrap;">gid_t gid</i>, <i class="farg" style="white-space:nowrap;">mode_t acc_mode</i>, <i class="farg" style="white-space:nowrap;">kauth_cred_t cred</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">bdevvp</b>(<i class="farg" style="white-space:nowrap;">dev_t dev</i>, <i class="farg" style="white-space:nowrap;">struct vnode **vpp</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">cdevvp</b>(<i class="farg" style="white-space:nowrap;">dev_t dev</i>, <i class="farg" style="white-space:nowrap;">struct vnode **vpp</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">vfinddev</b>(<i class="farg" style="white-space:nowrap;">dev_t dev</i>, <i class="farg" style="white-space:nowrap;">enum vtype</i>, <i class="farg" style="white-space:nowrap;">struct vnode **vpp</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">vdevgone</b>(<i class="farg" style="white-space:nowrap;">int maj</i>, <i class="farg" style="white-space:nowrap;">int minl</i>, <i class="farg" style="white-space:nowrap;">int minh</i>, <i class="farg" style="white-space:nowrap;">enum vtype type</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">vwakeup</b>(<i class="farg" style="white-space:nowrap;">struct buf *bp</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">vflushbuf</b>(<i class="farg" style="white-space:nowrap;">struct vnode *vp</i>, <i class="farg" style="white-space:nowrap;">int sync</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">vinvalbuf</b>(<i class="farg" style="white-space:nowrap;">struct vnode *vp</i>, <i class="farg" style="white-space:nowrap;">int flags</i>, <i class="farg" style="white-space:nowrap;">kauth_cred_t cred</i>, <i class="farg" style="white-space:nowrap;">struct lwp *l</i>, <i class="farg" style="white-space:nowrap;">int slpflag</i>, <i class="farg" style="white-space:nowrap;">int slptimeo</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">vtruncbuf</b>(<i class="farg" style="white-space:nowrap;">struct vnode *vp</i>, <i class="farg" style="white-space:nowrap;">daddr_t lbn</i>, <i class="farg" style="white-space:nowrap;">int slpflag</i>, <i class="farg" style="white-space:nowrap;">int slptimeo</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">vprint</b>(<i class="farg" style="white-space:nowrap;">const char *label</i>, <i class="farg" style="white-space:nowrap;">struct vnode *vp</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> A <span class="emph">vnode</span> represents an on-disk file in use by the system. Each <a class="link-man" href="../9/vfs">vfs(9)</a> file system provides a set of <a class="link-man" href="../9/vnodeops">vnodeops(9)</a> operations on vnodes, invoked by file-system-independent system calls and supported by file-system-independent library routines.<p>
Each mounted file system provides a vnode for the root of the file system, via <a class="link-man" href="../9/VFS_ROOT">VFS_ROOT(9)</a>. Other vnodes are obtained by <a class="link-man" href="../9/VOP_LOOKUP">VOP_LOOKUP(9)</a>. Users of vnodes usually invoke these indirectly via <a class="link-man" href="../9/namei">namei(9)</a> to obtain vnodes from paths.<p>
Each file system usually maintains a cache mapping recently used inode numbers, or the equivalent, to vnodes, and a cache mapping recently used file names to vnodes. If memory is scarce, the system may decide to <span class="emph">reclaim</span> an unused cached vnode, calling <a class="link-man" href="../9/VOP_RECLAIM">VOP_RECLAIM(9)</a> to remove it from the caches and to free file-system-specific memory associated with it. A file system may also choose to immediately reclaim a cached vnode once it is unused, in <a class="link-man" href="../9/VOP_INACTIVE">VOP_INACTIVE(9)</a>, if the vnode has been deleted on disk.<p>
When a file system retrieves a vnode from a cache, the vnode may not have any users, and another thread in the system may be simultaneously deciding to reclaim it. Thus, to retrieve a vnode from a cache, one must use <b class="fname">vget</b>(), not <b class="fname">vref</b>(), to acquire the first reference, and be prepared for <b class="fname">vget</b>() to fail if another thread is reclaiming the vnode.<p>
The vnode has the following structure:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
struct vnode { 
	struct uvm_object v_uobj;		/* the VM object */ 
	kcondvar_t	v_cv;			/* synchronization */ 
	voff_t		v_size;			/* size of file */ 
	voff_t		v_writesize;		/* new size after write */ 
	int		v_iflag;		/* VI_* flags */ 
	int		v_vflag;		/* VV_* flags */ 
	int		v_uflag;		/* VU_* flags */ 
	int		v_numoutput;		/* # of pending writes */ 
	int		v_writecount;		/* ref count of writers */ 
	int		v_holdcnt;		/* page &amp; buffer refs */ 
	int		v_synclist_slot;	/* synclist slot index */ 
	struct mount	*v_mount;		/* ptr to vfs we are in */ 
	int		(**v_op)(void *);	/* vnode operations vector */ 
	TAILQ_ENTRY(vnode) v_freelist;		/* vnode freelist */ 
	struct vnodelst	*v_freelisthd;		/* which freelist? */ 
	TAILQ_ENTRY(vnode) v_mntvnodes;		/* vnodes for mount point */ 
	struct buflists	v_cleanblkhd;		/* clean blocklist head */ 
	struct buflists	v_dirtyblkhd;		/* dirty blocklist head */ 
	TAILQ_ENTRY(vnode) v_synclist;		/* vnodes with dirty bufs */ 
	LIST_HEAD(, namecache) v_dnclist;	/* namecaches (children) */ 
	LIST_HEAD(, namecache) v_nclist;	/* namecaches (parent) */ 
	union { 
		struct mount	*vu_mountedhere;/* ptr to vfs (VDIR) */ 
		struct socket	*vu_socket;	/* unix ipc (VSOCK) */ 
		struct specnode	*vu_specnode;	/* device (VCHR, VBLK) */ 
		struct fifoinfo	*vu_fifoinfo;	/* fifo (VFIFO) */ 
		struct uvm_ractx *vu_ractx;	/* read-ahead ctx (VREG) */ 
	} v_un; 
	enum vtype	v_type;			/* vnode type */ 
	enum vtagtype	v_tag;			/* type of underlying data */ 
	struct vnlock	v_lock;			/* lock for this vnode */ 
	void 		*v_data;		/* private data for fs */ 
	struct klist	v_klist;		/* notes attached to vnode */ 
};</pre>
<p>
Most members of the vnode structure should be treated as opaque and only manipulated using the proper functions. There are some rather common exceptions detailed throughout this page.<p>
Files and file systems are inextricably linked with the virtual memory system and <span class="emph">v_uobj</span> contains the data maintained by the virtual memory system. For compatibility with code written before the integration of <a class="link-man" href="../9/uvm">uvm(9)</a> into <span class="unix">NetBSD</span>, C-preprocessor directives are used to alias the members of <span class="emph">v_uobj</span>.<p>
Vnode flags are recorded by <span class="emph">v_iflag</span>, <span class="emph">v_vflag</span> and <span class="emph">v_uflag</span>. Valid flags are:<p>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VV_ROOT</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
This vnode is the root of its file system.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VV_SYSTEM</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
This vnode is being used by the kernel; only used to skip quota files in <b class="fname">vflush</b>().</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VV_ISTTY</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
This vnode represents a tty; used when reading dead vnodes.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VV_MAPPED</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
This vnode might have user mappings.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VV_MPSAFE</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
This file system is MP safe.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VV_LOCKSWORK</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
This vnode's file system supports locking.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VI_TEXT</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
This vnode is a pure text prototype.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VI_EXECMAP</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
This vnode has executable mappings.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VI_WRMAP</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
This vnode might have PROT_WRITE user mappings.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VI_WRMAPDIRTY</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
This vnode might have dirty pages due to <span class="define">VWRITEMAP</span>.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VI_XLOCK</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
This vnode is currently locked to change underlying type.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VI_ONWORKLST</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
This vnode is on syncer work-list.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VI_MARKER</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
A dummy marker vnode.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VI_CLEAN</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
This vnode has been reclaimed and is no longer attached to a file system.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VU_DIROP</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
This vnode is involved in a directory operation. This flag is used exclusively by LFS.</dd>
</dl>
<p>
The <span class="define">VI_XLOCK</span> flag is used to prevent multiple processes from entering the vnode reclamation code. It is also used as a flag to indicate that reclamation is in progress. Before <span class="emph">v_iflag</span> can be modified, the <span class="emph">v_interlock</span> mutex must be acquired. See <a class="link-man" href="../9/lock">lock(9)</a> for details on the kernel locking API.<p>
Each vnode has three reference counts: <span class="emph">v_usecount</span>, <span class="emph">v_writecount</span> and <span class="emph">v_holdcnt</span>. The first is the number of active references within the kernel to the vnode. This count is maintained by <b class="fname">vref</b>(), <b class="fname">vrele</b>(), <b class="fname">vrele_async</b>(), and <b class="fname">vput</b>(). The second is the number of active references within the kernel to the vnode performing write access to the file. It is maintained by the <a class="link-man" href="../2/open">open(2)</a> and <a class="link-man" href="../2/close">close(2)</a> system calls. The third is the number of references within the kernel requiring the vnode to remain active and not be recycled. This count is maintained by <b class="fname">vhold</b>() and <b class="fname">holdrele</b>(). When both the <span class="emph">v_usecount</span> and <span class="emph">v_holdcnt</span> reach zero, the vnode is recycled to the freelist and may be reused for another file. The transition to and from the freelist is handled by a kernel thread and <b class="fname">vrecycle</b>(). Access to <span class="emph">v_usecount</span>, <span class="emph">v_writecount</span> and <span class="emph">v_holdcnt</span> is also protected by the <span class="emph">v_interlock</span> mutex.<p>
The number of pending synchronous and asynchronous writes on the vnode are recorded in <span class="emph">v_numoutput</span>. It is used by <a class="link-man" href="../2/fsync">fsync(2)</a> to wait for all writes to complete before returning to the user. Its value must only be modified at splbio (see <a class="link-man" href="../9/spl">spl(9)</a>). It does not track the number of dirty buffers attached to the vnode.<p>
<span class="emph">v_dnclist</span> and <span class="emph">v_nclist</span> are used by <a class="link-man" href="../9/namecache">namecache(9)</a> to maintain the list of associated entries so that <a class="link-man" href="../9/cache_purge">cache_purge(9)</a> can purge them.<p>
The link to the file system which owns the vnode is recorded by <span class="emph">v_mount</span>. See <a class="link-man" href="../9/vfsops">vfsops(9)</a> for further information of file system mount status.<p>
The <span class="emph">v_op</span> pointer points to its vnode operations vector. This vector describes what operations can be done to the file associated with the vnode. The system maintains one vnode operations vector for each file system type configured into the kernel. The vnode operations vector contains a pointer to a function for each operation supported by the file system. See <a class="link-man" href="../9/vnodeops">vnodeops(9)</a> for a description of vnode operations.<p>
When not in use, vnodes are kept on the freelist through <span class="emph">v_freelist</span>. The vnodes still reference valid files but may be reused to refer to a new file at any time. When a valid vnode which is on the freelist is used again, the user must call <b class="fname">vget</b>() to increment the reference count and retrieve it from the freelist. When a user wants a new vnode for another file, <b class="fname">vcache_get</b>() or <b class="fname">vcache_new</b>() is invoked to allocate a vnode and initialize it for the new file.<p>
The type of object the vnode represents is recorded by <span class="emph">v_type</span>. It is used by generic code to perform checks to ensure operations are performed on valid file system objects. Valid types are:<p>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VNON</span></dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
The vnode has no type.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VREG</span></dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
The vnode represents a regular file.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VDIR</span></dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
The vnode represents a directory.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VBLK</span></dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
The vnode represents a block special device.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VCHR</span></dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
The vnode represents a character special device.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VLNK</span></dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
The vnode represents a symbolic link.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VSOCK</span></dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
The vnode represents a socket.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VFIFO</span></dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
The vnode represents a pipe.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VBAD</span></dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
The vnode represents a bad file (not currently used).</dd>
</dl>
<p>
Vnode tag types are used by external programs only (e.g., <a class="link-man" href="../8/pstat">pstat(8)</a>), and should never be inspected by the kernel. Its use is deprecated since new <span class="emph">v_tag</span> values cannot be defined for loadable file systems. The <span class="emph">v_tag</span> member is read-only. Valid tag types are:<p>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VT_NON</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
non file system</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VT_UFS</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
universal file system</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VT_NFS</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
network file system</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VT_MFS</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
memory file system</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VT_MSDOSFS</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
FAT file system</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VT_LFS</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
log-structured file system</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VT_LOFS</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
loopback file system</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VT_FDESC</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
file descriptor file system</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VT_NULL</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
null file system layer</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VT_UMAP</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
uid/gid remapping file system layer</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VT_KERNFS</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
kernel interface file system</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VT_PROCFS</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
process interface file system</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VT_AFS</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
AFS file system</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VT_ISOFS</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
ISO 9660 file system(s)</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VT_UNION</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
union file system</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VT_ADOSFS</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Amiga file system</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VT_EXT2FS</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Linux's ext2 file system</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VT_CODA</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Coda file system</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VT_FILECORE</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
filecore file system</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VT_NTFS</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Microsoft NT's file system</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VT_VFS</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
virtual file system</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VT_OVERLAY</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
overlay file system</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VT_SMBFS</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
SMB file system</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VT_PTYFS</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
pseudo-terminal device file system</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VT_TMPFS</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
efficient memory file system</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VT_UDF</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
universal disk format file system</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">VT_SYSVBFS</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
systemV boot file system</dd>
</dl>
<p>
All vnode locking operations use <span class="emph">v_lock</span>. This lock is acquired by calling <a class="link-man" href="../9/vn_lock">vn_lock(9)</a> and released by calling <a class="link-man" href="../9/VOP_UNLOCK">VOP_UNLOCK(9)</a>. The reason for this asymmetry is that <a class="link-man" href="../9/vn_lock">vn_lock(9)</a> is a wrapper for <a class="link-man" href="../9/VOP_LOCK">VOP_LOCK(9)</a> with extra checks, while the unlocking step usually does not need additional checks and thus has no wrapper.<p>
The vnode locking operation is complicated because it is used for many purposes. Sometimes it is used to bundle a series of vnode operations (see <a class="link-man" href="../9/vnodeops">vnodeops(9)</a>) into an atomic group. Many file systems rely on it to prevent race conditions in updating file system type specific data structures rather than using their own private locks. The vnode lock can operate as a multiple-reader (shared-access lock) or single-writer lock (exclusive access lock), however many current file system implementations were written assuming only single-writer locking. Multiple-reader locking functions equivalently only in the presence of big-lock SMP locking or a uni-processor machine. The lock may be held while sleeping. While the <span class="emph">v_lock</span> is acquired, the holder is guaranteed that the vnode will not be reclaimed or invalidated. Most file system functions require that you hold the vnode lock on entry. See <a class="link-man" href="../9/lock">lock(9)</a> for details on the kernel locking API.<p>
Each file system underlying a vnode allocates its own private area and hangs it from <span class="emph">v_data</span>.<p>
Most functions discussed in this page that operate on vnodes cannot be called from interrupt context. The members <span class="emph">v_numoutput</span>, <span class="emph">v_holdcnt</span>, <span class="emph">v_dirtyblkhd</span>, <span class="emph">v_cleanblkhd</span>, <span class="emph">v_freelist</span>, and <span class="emph">v_synclist</span> are modified in interrupt context and must be protected by <a class="link-man" href="../9/splbio">splbio(9)</a> unless it is certain that there is no chance an interrupt handler will modify them. The vnode lock must not be acquired within interrupt context.</div>
<div class="section">
<h1 id="x46554e4354494f4e53">FUNCTIONS</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vref</b>(<i class="farg">vp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Increment <span class="emph">v_usecount</span> of the vnode <span class="emph">vp</span>. Any kernel thread system which uses a vnode (e.g., during the operation of some algorithm or to store in a data structure) should call <b class="fname">vref</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vrele</b>(<i class="farg">vp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Decrement <span class="emph">v_usecount</span> of unlocked vnode <span class="emph">vp</span>. Any code in the system which is using a vnode should call <b class="fname">vrele</b>() when it is finished with the vnode. If <span class="emph">v_usecount</span> of the vnode reaches zero and <span class="emph">v_holdcnt</span> is greater than zero, the vnode is placed on the holdlist. If both <span class="emph">v_usecount</span> and <span class="emph">v_holdcnt</span> are zero, the vnode is placed on the freelist.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vrele_async</b>(<i class="farg">vp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Will asychronously release the vnode in different context than the caller, sometime after the call.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vget</b>(<i class="farg">vp</i>, <i class="farg">lockflags</i>, <i class="farg">wait</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Reclaim vnode <i class="farg">vp</i> from the freelist and increment its reference count.<p>
The vnode <i class="farg">vp</i> may be changing state: another thread may be initializing it from disk, or revoking it with <a class="link-man" href="../2/revoke">revoke(2)</a>, or reclaiming it with <a class="link-man" href="../9/VOP_RECLAIM">VOP_RECLAIM(9)</a>. In that case, <b class="fname">vget</b>() will wait until the state has changed, if <i class="farg">lockflags</i> is <code class="lit">0</code> and <i class="farg">wait</i> is <code class="lit">true</code>; or will return <span class="errno">EBUSY</span> if <i class="farg">lockflags</i> is <span class="define">LK_NOWAIT</span> and <i class="farg">wait</i> is <code class="lit">false</code>.<p>
(The extra argument enables the compiler to detect old code which additionally used <b class="fname">vget</b>() to lock the vnode.)<p>
Returns<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 4.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="errno">EBUSY</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
if <i class="farg">vp</i> was changing state and <i class="farg">wait</i> is false.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="errno">ENOENT</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
if the system was reclaiming <i class="farg">vp</i> with <a class="link-man" href="../9/VOP_RECLAIM">VOP_RECLAIM(9)</a>.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<code class="lit">0</code></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
on success.</dd>
</dl>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vput</b>(<i class="farg">vp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Legacy convenience routine for unlocking and releasing <i class="farg">vp</i>. Equivalent to:<p>
<pre style="margin-left: 4.00ex;" class="lit display">
VOP_UNLOCK(<i class="farg">vp</i><code class="lit">);</code> 
vrele(<i class="farg">vp</i><code class="lit">);</code></pre>
<p>
Note that this is <span class="emph">not</span> an inverse of <b class="fname">vget</b>(). The name appears so for hysterical raisins. New code should prefer using <a class="link-man" href="../9/VOP_UNLOCK">VOP_UNLOCK(9)</a> and <b class="fname">vrele</b>() directly.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vhold</b>(<i class="farg">vp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Mark the vnode <i class="farg">vp</i> as active by incrementing <span class="emph">vp-&gt;v_holdcnt</span> and moving the vnode from the freelist to the holdlist. Once on the holdlist, the vnode will not be recycled until it is released with <b class="fname">holdrele</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">holdrele</b>(<i class="farg">vp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Mark the vnode <i class="farg">vp</i> as inactive by decrementing <span class="emph">vp-&gt;v_holdcnt</span> and moving the vnode from the holdlist to the freelist.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vcache_get</b>(<i class="farg">mp</i>, <i class="farg">key</i>, <i class="farg">key_len</i>, <i class="farg">vpp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Allocate a new vnode. The new vnode is returned referenced in the address specified by <i class="farg">vpp</i>.<p>
The argument <i class="farg">mp</i> is the mount point for the file system to lookup the file in.<p>
The arguments <i class="farg">key</i> and <i class="farg">key_len</i> uniquely identify the file in the file system.<p>
If a vnode is successfully retrieved zero is returned, otherwise an appropriate error code is returned.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vcache_new</b>(<i class="farg">mp</i>, <i class="farg">dvp</i>, <i class="farg">vap</i>, <i class="farg">cred</i>, <i class="farg">vpp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Allocate a new vnode with a new file. The new vnode is returned referenced in the address specified by <i class="farg">vpp</i>.<p>
The argument <i class="farg">mp</i> is the mount point for the file system to create the file in.<p>
The argument <i class="farg">dvp</i> points to the directory to create the file in.<p>
The argument <i class="farg">vap</i> points to the attributes for the file to create.<p>
The argument <i class="farg">cred</i> holds the credentials for the file to create.<p>
If a vnode is successfully created zero is returned, otherwise an appropriate error code is returned.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vcache_rekey_enter</b>(<i class="farg">mp</i>, <i class="farg">vp</i>, <i class="farg">old_key</i>, <i class="farg">old_key_len</i>, <i class="farg">new_key</i>, <i class="farg">new_key_len</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Prepare to change the key of a cached vnode.<p>
The argument <i class="farg">mp</i> is the mount point for the file system the vnode <i class="farg">vp</i> resides in.<p>
The arguments <i class="farg">old_key</i> and <i class="farg">old_key_len</i> identify the cached vnode.<p>
The arguments <i class="farg">new_key</i> and <i class="farg">new_key_len</i> will identify the vnode after rename.<p>
If the new key already exists <span class="errno">EEXIST</span> is returned, otherwise zero is returned.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vcache_rekey_exit</b>(<i class="farg">mp</i>, <i class="farg">vp</i>, <i class="farg">old_key</i>, <i class="farg">old_key_len</i>, <i class="farg">new_key</i>, <i class="farg">new_key_len</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Finish rename after calling <b class="fname">vcache_rekey_enter</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vcache_remove</b>(<i class="farg">mp</i>, <i class="farg">key</i>, <i class="farg">key_len</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Remove a vnode from the cache. Must be called when a file system reclaims a vnode.<p>
The argument <i class="farg">mp</i> is the mount point for the file system this file resides in.<p>
The arguments <i class="farg">key</i> and <i class="farg">key_len</i> uniquely identify the file in the file system.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vrecycle</b>(<i class="farg">vp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Recycle the referenced vnode <i class="farg">vp</i> if this is the last reference. <b class="fname">vrecycle</b>() is a null operation if the reference count is greater than one.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vgone</b>(<i class="farg">vp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Eliminate all activity associated with the unlocked vnode <i class="farg">vp</i> in preparation for recycling.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vgonel</b>(<i class="farg">vp</i>, <i class="farg">p</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Eliminate all activity associated with the locked vnode <i class="farg">vp</i> in preparation for recycling.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vdead_check</b>(<i class="farg">vp</i>, <i class="farg">flags</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Check the vnode <i class="farg">vp</i> for being or becoming dead. Returns <span class="errno">ENOENT</span> for a dead vnode and zero otherwise. If <i class="farg">flags</i> is <span class="define">VDEAD_NOWAIT</span> it will return <span class="errno">EBUSY</span> if the vnode is becoming dead and the function will not sleep.<p>
Whenever this function returns a non-zero value all future calls for this <i class="farg">vp</i> will also return a non-zero value.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vflush</b>(<i class="farg">mp</i>, <i class="farg">skipvp</i>, <i class="farg">flags</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Remove any vnodes in the vnode table belonging to mount point <i class="farg">mp</i>. If <i class="farg">skipvp</i> is not <span class="define">NULL</span> it is exempt from being flushed. The argument <i class="farg">flags</i> is a set of flags modifying the operation of <b class="fname">vflush</b>(). If <span class="define">FORCECLOSE</span> is not specified, there should not be any active vnodes and the error <span class="errno">EBUSY</span> is returned if any are found (this is a user error, not a system error). If <span class="define">FORCECLOSE</span> is specified, active vnodes that are found are detached. If <span class="define">WRITECLOSE</span> is set, only flush out regular file vnodes open for writing. SKIPSYSTEM causes any vnodes marked <span class="define">V_SYSTEM</span> to be skipped.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vaccess</b>(<i class="farg">type</i>, <i class="farg">file_mode</i>, <i class="farg">uid</i>, <i class="farg">gid</i>, <i class="farg">acc_mode</i>, <i class="farg">cred</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Do access checking by comparing the file's permissions to the caller's desired access type <i class="farg">acc_mode</i> and credentials <i class="farg">cred</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">bdevvp</b>(<i class="farg">dev</i>, <i class="farg">vpp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Create a vnode for a block device. <b class="fname">bdevvp</b>() is used for root file systems, swap areas and for memory file system special devices.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">cdevvp</b>(<i class="farg">dev</i>, <i class="farg">vpp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Create a vnode for a character device. <b class="fname">cdevvp</b>() is used for the console and kernfs special devices.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vfinddev</b>(<i class="farg">dev</i>, <i class="farg">vtype</i>, <i class="farg">vpp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Lookup a vnode by device number. The vnode is referenced and returned in the address specified by <i class="farg">vpp</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vdevgone</b>(<i class="farg">int maj</i>, <i class="farg">int min</i>, <i class="farg">int minh</i>, <i class="farg">enum vtype type</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Reclaim all vnodes that correspond to the specified minor number range <i class="farg">minl</i> to <i class="farg">minh</i> (endpoints inclusive) of the specified major <i class="farg">maj</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vwakeup</b>(<i class="farg">bp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Update outstanding I/O count <span class="emph">vp-&gt;v_numoutput</span> for the vnode <span class="emph">bp-&gt;b_vp</span> and do a wakeup if requested and <span class="emph">vp-&gt;vflag</span> has <span class="define">VBWAIT</span> set.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vflushbuf</b>(<i class="farg">vp</i>, <i class="farg">sync</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Flush all dirty buffers to disk for the file with the locked vnode <i class="farg">vp</i>. The argument <i class="farg">sync</i> specifies whether the I/O should be synchronous and <b class="fname">vflushbuf</b>() will sleep until <span class="emph">vp-&gt;v_numoutput</span> is zero and <span class="emph">vp-&gt;v_dirtyblkhd</span> is empty.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vinvalbuf</b>(<i class="farg">vp</i>, <i class="farg">flags</i>, <i class="farg">cred</i>, <i class="farg">l</i>, <i class="farg">slpflag</i>, <i class="farg">slptimeo</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Flush out and invalidate all buffers associated with locked vnode <i class="farg">vp</i>. The argument <i class="farg">l</i> and <i class="farg">cred</i> specified the calling process and its credentials. The <a class="link-man" href="../9/ltsleep">ltsleep(9)</a> flag and timeout are specified by the arguments <i class="farg">slpflag</i> and <i class="farg">slptimeo</i> respectively. If the operation is successful zero is returned, otherwise an appropriate error code is returned.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vtruncbuf</b>(<i class="farg">vp</i>, <i class="farg">lbn</i>, <i class="farg">slpflag</i>, <i class="farg">slptimeo</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Destroy any in-core buffers past the file truncation length for the locked vnode <i class="farg">vp</i>. The truncation length is specified by <i class="farg">lbn</i>. <b class="fname">vtruncbuf</b>() will sleep while the I/O is performed,  The <a class="link-man" href="../9/ltsleep">ltsleep(9)</a> flag and timeout are specified by the arguments <i class="farg">slpflag</i> and <i class="farg">slptimeo</i> respectively. If the operation is successful zero is returned, otherwise an appropriate error code is returned.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">vprint</b>(<i class="farg">label</i>, <i class="farg">vp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
This function is used by the kernel to dump vnode information during a panic. It is only used if the kernel option DIAGNOSTIC is compiled into the kernel. The argument <i class="farg">label</i> is a string to prefix the information dump of vnode <i class="farg">vp</i>.</dd>
</dl>
</div>
<div class="section">
<h1 id="x434f4445205245464552454e434553">CODE REFERENCES</h1> The vnode framework is implemented within the file <i class="file">sys/kern/vfs_subr.c</i>.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../9/intro">intro(9)</a>, <a class="link-man" href="../9/lock">lock(9)</a>, <a class="link-man" href="../9/namecache">namecache(9)</a>, <a class="link-man" href="../9/namei">namei(9)</a>, <a class="link-man" href="../9/uvm">uvm(9)</a>, <a class="link-man" href="../9/vattr">vattr(9)</a>, <a class="link-man" href="../9/vfs">vfs(9)</a>, <a class="link-man" href="../9/vfsops">vfsops(9)</a>, <a class="link-man" href="../9/vnodeops">vnodeops(9)</a>, <a class="link-man" href="../9/vnsubr">vnsubr(9)</a></div>
<div class="section">
<h1 id="x42554753">BUGS</h1> The locking protocol is inconsistent. Many vnode operations are passed locked vnodes on entry but release the lock before they exit. The locking protocol is used in some places to attempt to make a series of operations atomic (e.g., access check then operation). This does not work for non-local file systems that do not support locking (e.g., NFS). The <b class="name">vnode</b> interface would benefit from a simpler locking protocol.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
July 12, 2015</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

