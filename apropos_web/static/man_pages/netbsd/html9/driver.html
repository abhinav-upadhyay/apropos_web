<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="/static/man_pages/netbsd/style.css" type="text/css" media="all">
<title>
DRIVER(9)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
DRIVER(9)</td>
<td class="head-vol" align="center">
Kernel Developer's Manual</td>
<td class="head-rtitle" align="right">
DRIVER(9)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">driver</b> &#8212; <span class="desc">description of a device driver</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/param.h</a>&gt;</b><br>
<b class="includes">#include &lt;<a class="link-includes">sys/device.h</a>&gt;</b><br>
<b class="includes">#include &lt;<a class="link-includes">sys/errno.h</a>&gt;</b><p>
<i class="ftype">static int</i><br>
<b class="fname">foo_match</b>(<i class="farg" style="white-space:nowrap;">device_t parent</i>, <i class="farg" style="white-space:nowrap;">cfdata_t match</i>, <i class="farg" style="white-space:nowrap;">void *aux</i>);<p>
<i class="ftype">static void</i><br>
<b class="fname">foo_attach</b>(<i class="farg" style="white-space:nowrap;">device_t parent</i>, <i class="farg" style="white-space:nowrap;">device_t self</i>, <i class="farg" style="white-space:nowrap;">void *aux</i>);<p>
<i class="ftype">static int</i><br>
<b class="fname">foo_detach</b>(<i class="farg" style="white-space:nowrap;">device_t self</i>, <i class="farg" style="white-space:nowrap;">int flags</i>);<p>
<i class="ftype">static int</i><br>
<b class="fname">foo_activate</b>(<i class="farg" style="white-space:nowrap;">device_t self</i>, <i class="farg" style="white-space:nowrap;">enum devact act</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> This page briefly describes the basic <span class="unix">NetBSD</span> autoconfiguration interface used by device drivers. For a detailed overview of the autoconfiguration framework see <a class="link-man" href="../9/autoconf">autoconf(9)</a>.<p>
Each device driver must present to the system a standard autoconfiguration interface. This interface is provided by the <span class="emph">cfattach</span> structure. The interface to the driver is constant and is defined statically inside the driver. For example, the interface to driver &#8220;foo&#8221; is defined with:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
CFATTACH_DECL(foo, 			/* driver name */ 
	sizeof(struct foo_softc),	/* size of instance data */ 
	foo_match,			/* match/probe function */ 
	foo_attach,			/* attach function */ 
	foo_detach,			/* detach function */ 
	foo_activate);			/* activate function */</pre>
<p>
For each device instance controlled by the driver, the autoconfiguration framework allocates a block of memory to record device-instance-specific driver variables. The size of this memory block is specified by the second argument in the <span class="emph">CFATTACH_DECL</span> macro. The memory block is referred to as the driver's <span class="emph">softc</span> structure. The <span class="emph">softc</span> structure is only accessed within the driver, so its definition is local to the driver. Nevertheless, the <span class="emph">softc</span> structure should adopt the standard <span class="unix">NetBSD</span> configuration and naming conventions. For example, the <span class="emph">softc</span> structure for driver &#8220;foo&#8221; is defined with:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
struct foo_softc { 
	device_t sc_dev;		/* generic device info */ 
	/* device-specific state */ 
};</pre>
<p>
The autoconfiguration framework mandates that the first member of the <span class="emph">softc</span> structure must be the driver-independent <span class="emph">device_t</span>. Probably its most useful aspect to the driver is that it contains the device-instance name <span class="emph">dv_xname</span>.<p>
If a driver has character device interfaces accessed from userland, the driver must define the <span class="emph">cdevsw</span> structure. The structure is constant and is defined inside the driver. For example, the <span class="emph">cdevsw</span> structure for driver &#8220;foo&#8221; is defined with:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
const struct cdevsw foo_cdevsw { 
	int (*d_open)(dev_t, int, int, struct lwp *); 
	int (*d_close)(dev_t, int, int, struct lwp *); 
	int (*d_read)(dev_t, struct uio *, int); 
	int (*d_write)(dev_t, struct uio *, int); 
	int (*d_ioctl)(dev_t, u_long, void *, int, struct lwp *); 
	void (*d_stop)(struct tty *, int); 
	struct tty *(*d_tty)(dev_t); 
	int (*d_poll)(dev_t, int, struct lwp *); 
	paddr_t (*d_mmap)(dev_t, off_t, int); 
	int (*d_kqfilter)(dev_t, struct knote *); 
	int d_flag; 
};</pre>
<p>
The structure variable must be named foo_cdevsw by appending the letters &#8220;_cdevsw&#8221; to the driver's base name. This convention is mandated by the autoconfiguration framework.<p>
If the driver &#8220;foo&#8221; has also block device interfaces, the driver must define the <span class="emph">bdevsw</span> structure. The structure is constant and is defined inside the driver. For example, the <span class="emph">bdevsw</span> structure for driver &#8220;foo&#8221; is defined with:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
const struct bdevsw foo_bdevsw { 
	int (*d_open)(dev_t, int, int, struct lwp *); 
	int (*d_close)(dev_t, int, int, struct lwp *); 
	void (*d_strategy)(struct buf *); 
	int (*d_ioctl)(dev_t, u_long, void *, int, struct lwp *); 
	int (*d_dump)(dev_t, daddr_t, void *, size_t); 
	int (*d_psize)(dev_t); 
	int d_flag; 
};</pre>
<p>
The structure variable must be named foo_bdevsw by appending the letters &#8220;_bdevsw&#8221; to the driver's base name. This convention is mandated by the autoconfiguration framework.<p>
During system bootstrap, the autoconfiguration framework searches the system for devices. For each device driver, its match function is called (via its <span class="emph">cfattach</span> structure) to match the driver with a device instance. The match function is called with three arguments. This first argument <i class="farg">parent</i> is a pointer to the driver's parent device structure. The second argument <i class="farg">match</i> is a pointer to a data structure describing the autoconfiguration framework's understanding of the driver. Both the <i class="farg">parent</i> and <i class="farg">match</i> arguments are ignored by most drivers. The third argument <i class="farg">aux</i> contains a pointer to a structure describing a potential device-instance. It is passed to the driver from the parent. The match function would type-cast the <i class="farg">aux</i> argument to its appropriate attachment structure and use its contents to determine whether it supports the device. Depending on the device hardware, the contents of the attachment structure may contain &#8220;locators&#8221; to locate the device instance so that the driver can probe it for its identity. If the probe process identifies additional device properties, it may modify the members of the attachment structure. For these devices, the <span class="unix">NetBSD</span> convention is to call the match routine <b class="fname">foo_probe</b>() instead of <b class="fname">foo_match</b>() to make this distinction clear. Either way, the match function returns a nonzero integer indicating the confidence of supporting this device and a value of 0 if the driver doesn't support the device. Generally, only a single driver exists for a device, so the match function returns 1 for a positive match.<p>
The autoconfiguration framework will call the attach function (via its <span class="emph">cfattach</span> structure) of the driver which returns the highest value from its match function. The attach function is called with three arguments. The attach function performs the necessary process to initialise the device for operation. The first argument <i class="farg">parent</i> is a pointer to the driver's parent device structure. The second argument <i class="farg">self</i> is a pointer to the driver's device structure. It is also a pointer to our <span class="emph">softc</span> structure since the device structure is its first member. The third argument <i class="farg">aux</i> is a pointer to the attachment structure. The <i class="farg">parent</i> and <i class="farg">aux</i> arguments are the same as passed to the match function.<p>
The driver's attach function is called before system interrupts are enabled. If interrupts are required during initialisation, then the attach function should make use of <b class="fname">config_interrupts</b>() (see <a class="link-man" href="../9/autoconf">autoconf(9)</a>).<p>
Some devices can be removed from the system without requiring a system reboot. The autoconfiguration framework calls the driver's detach function (via its <span class="emph">cfattach</span> structure) during device detachment. If the device does not support detachment, then the driver does not have to provide a detach function. The detach function is used to relinquish resources allocated to the driver which are no longer needed. The first argument <i class="farg">self</i> is a pointer to the driver's device structure. It is the same structure as passed to the attach function. The second argument <i class="farg">flags</i> contains detachment flags. Valid values are <span class="define">DETACH_FORCE</span> (force detachment; hardware gone) and <span class="define">DETACH_QUIET</span> (do not print a notice).<p>
The autoconfiguration framework may call the driver's activate function to notify the driver of a change in the resources that have been allocated to it. For example, an Ethernet driver has to be notified if the network stack is being added or removed from the kernel. The first argument to the activate function <i class="farg">self</i> is a pointer to the driver's device structure. It is the same argument as passed to the attach function. The second argument <i class="farg">act</i> describes the action. Valid actions are <span class="define">DVACT_ACTIVATE</span> (activate the device) and <span class="define">DVACT_DEACTIVATE</span> (deactivate the device). If the action is not supported the activate function should return <span class="errno">EOPNOTSUPP</span>. The <span class="define">DVACT_DEACTIVATE</span> call will only be made if the <span class="define">DVACT_ACTIVATE</span> call was successful. The activate function is called in interrupt context.<p>
Most drivers will want to make use of interrupt facilities. Interrupt locators provided through the attachment structure should be used to establish interrupts within the system. Generally, an interrupt interface is provided by the parent. The interface will require a handler and a driver-specific argument to be specified. This argument is usually a pointer to the device-instance-specific softc structure. When a hardware interrupt for the device occurs the handler is called with the argument. Interrupt handlers should return 0 for &#8220;interrupt not for me&#8221;, 1 for &#8220;I took care of it&#8221;, or -1 for &#8220;I guess it was mine, but I wasn't expecting it&#8221;.<p>
For a driver to be compiled into the kernel, <a class="link-man" href="../1/config">config(1)</a> must be aware of its existence. This is done by including an entry in files.&lt;bus&gt; in the directory containing the driver. For example, the driver &#8220;foo&#8221; attaching to bus &#8220;bar&#8221; with dependency on kernel module &#8220;baz&#8221; has the entry:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
device	foo: baz 
attach	foo at bar 
file	dev/bar/foo.c		foo</pre>
<p>
An entry can now be added to the machine description file:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
foo*	at bar?</pre>
<p>
For device interfaces of a driver to be compiled into the kernel, <a class="link-man" href="../1/config">config(1)</a> must be aware of its existence. This is done by including an entry in majors.&lt;arch&gt;. For example, the driver &#8220;foo&#8221; with character device interfaces, a character major device number &#8220;cmaj&#8221;, block device interfaces, a block device major number &#8220;bmaj&#8221; and dependency on kernel module &#8220;baz&#8221; has the entry:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
device-major	foo	char cmaj block bmaj	baz</pre>
<p>
For a detailed description of the machine description file and the &#8220;device definition&#8221; language see <a class="link-man" href="../9/config">config(9)</a>.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../1/config">config(1)</a>, <a class="link-man" href="../9/autoconf">autoconf(9)</a>, <a class="link-man" href="../9/config">config(9)</a>, <a class="link-man" href="../9/pmf">pmf(9)</a></div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
July 23, 2011</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

