<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/../4/strict.dtd">
>
<head>
<meta http-equiv="Content-Type" content="te../; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
PCI(9)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
PCI(9)</td>
<td class="head-vol" align="center">
Kernel Developer's Manual</td>
<td class="head-rtitle" align="right">
PCI(9)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">PCI</b>, <b class="name">pci_activate</b>, <b class="name">pci_bus_devorder</b>, <b class="name">pci_chipset_tag_create</b>, <b class="name">pci_chipset_tag_destroy</b>, <b class="name">pci_conf_read</b>, <b class="name">pci_conf_write</b>, <b class="name">pci_conf_print</b>, <b class="name">pci_conf_capture</b>, <b class="name">pci_conf_restore</b>, <b class="name">pci_find_device</b>, <b class="name">pci_get_capability</b>, <b class="name">pci_mapreg_type</b>, <b class="name">pci_mapreg_map</b>, <b class="name">pci_mapreg_info</b>, <b class="name">pci_intr_map</b>, <b class="name">pci_intr_string</b>, <b class="name">pci_intr_evcnt</b>, <b class="name">pci_intr_establish</b>, <b class="name">pci_intr_disestablish</b>, <b class="name">pci_get_powerstate</b>, <b class="name">pci_set_powerstate</b>, <b class="name">pci_vpd_read</b>, <b class="name">pci_vpd_write</b>, <b class="name">pci_make_tag</b>, <b class="name">pci_decompose_tag</b>, <b class="name">pci_findvendor</b>, <b class="name">pci_devinfo</b>, <b class="name">PCI_VENDOR</b>, <b class="name">PCI_PRODUCT</b>, <b class="name">PCI_REVISION</b> &#8212; <span class="desc">Peripheral Component Interconnect</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/bus.h</a>&gt;</b><br>
<b class="includes">#include &lt;<a class="link-includes">dev/pci/pcivar.h</a>&gt;</b><br>
<b class="includes">#include &lt;<a class="link-includes">dev/pci/pcireg.h</a>&gt;</b><br>
<b class="includes">#include &lt;<a class="link-includes">dev/pci/pcidevs.h</a>&gt;</b><p>
<i class="ftype">int</i><br>
<b class="fname">pci_bus_devorder</b>(<i class="farg" style="white-space:nowrap;">pci_chipset_tag_t pc</i>, <i class="farg" style="white-space:nowrap;">int bus</i>, <i class="farg" style="white-space:nowrap;">uint8_t *devs</i>, <i class="farg" style="white-space:nowrap;">int maxdevs</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">pci_activate</b>(<i class="farg" style="white-space:nowrap;">pci_chipset_tag_t pc</i>, <i class="farg" style="white-space:nowrap;">pcitag_t tag</i>, <i class="farg" style="white-space:nowrap;">device_t dev</i>, <i class="farg" style="white-space:nowrap;">int (*wakeup)(pci_chipset_tag_t pc, pcitag_t tag, device_t dev, pcireg_t reg)</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">pci_chipset_tag_create</b>(<i class="farg" style="white-space:nowrap;">pci_chipset_tag_t opc</i>, <i class="farg" style="white-space:nowrap;">uint64_t present</i>, <i class="farg" style="white-space:nowrap;">const struct pci_overrides *ov</i>, <i class="farg" style="white-space:nowrap;">void *ctx</i>, <i class="farg" style="white-space:nowrap;">pci_chipset_tag_t *pcp</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">pci_chipset_tag_destroy</b>(<i class="farg" style="white-space:nowrap;">pci_chipset_tag_t pc</i>);<p>
<i class="ftype">pcireg_t</i><br>
<b class="fname">pci_conf_read</b>(<i class="farg" style="white-space:nowrap;">pci_chipset_tag_t pc</i>, <i class="farg" style="white-space:nowrap;">pcitag_t tag</i>, <i class="farg" style="white-space:nowrap;">int reg</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">pci_conf_write</b>(<i class="farg" style="white-space:nowrap;">pci_chipset_tag_t pc</i>, <i class="farg" style="white-space:nowrap;">pcitag_t tag</i>, <i class="farg" style="white-space:nowrap;">int reg</i>, <i class="farg" style="white-space:nowrap;">pcireg_t val</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">pci_conf_print</b>(<i class="farg" style="white-space:nowrap;">pci_chipset_tag_t pc</i>, <i class="farg" style="white-space:nowrap;">pcitag_t tag</i>, <i class="farg" style="white-space:nowrap;">void (*func)(pci_chipset_tag_t, pcitag_t, const pcireg_t *)</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">pci_conf_capture</b>(<i class="farg" style="white-space:nowrap;">pci_chipset_tag_t pc</i>, <i class="farg" style="white-space:nowrap;">pcitag_t tag</i>, <i class="farg" style="white-space:nowrap;">struct pci_conf_state *</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">pci_conf_restore</b>(<i class="farg" style="white-space:nowrap;">pci_chipset_tag_t pc</i>, <i class="farg" style="white-space:nowrap;">pcitag_t tag</i>, <i class="farg" style="white-space:nowrap;">struct pci_conf_state *</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">pci_find_device</b>(<i class="farg" style="white-space:nowrap;">struct pci_attach_args *pa</i>, <i class="farg" style="white-space:nowrap;">int (*func)(const struct pci_attach_args *)</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">pci_get_capability</b>(<i class="farg" style="white-space:nowrap;">pci_chipset_tag_t pc</i>, <i class="farg" style="white-space:nowrap;">pcitag_t tag</i>, <i class="farg" style="white-space:nowrap;">int capid</i>, <i class="farg" style="white-space:nowrap;">int *offsetp</i>, <i class="farg" style="white-space:nowrap;">pcireg_t *valuep</i>);<p>
<i class="ftype">pcireg_t</i><br>
<b class="fname">pci_mapreg_type</b>(<i class="farg" style="white-space:nowrap;">pci_chipset_tag_t pc</i>, <i class="farg" style="white-space:nowrap;">pcitag_t tag</i>, <i class="farg" style="white-space:nowrap;">int reg</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">pci_mapreg_map</b>(<i class="farg" style="white-space:nowrap;">const struct pci_attach_args *pa</i>, <i class="farg" style="white-space:nowrap;">int reg</i>, <i class="farg" style="white-space:nowrap;">pcireg_t type</i>, <i class="farg" style="white-space:nowrap;">int busflags</i>, <i class="farg" style="white-space:nowrap;">bus_space_tag_t *tagp</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t *handlep</i>, <i class="farg" style="white-space:nowrap;">bus_addr_t *basep</i>, <i class="farg" style="white-space:nowrap;">bus_size_t *sizep</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">pci_mapreg_info</b>(<i class="farg" style="white-space:nowrap;">pci_chipset_tag_t pc</i>, <i class="farg" style="white-space:nowrap;">pcitag_t tag</i>, <i class="farg" style="white-space:nowrap;">int reg</i>, <i class="farg" style="white-space:nowrap;">pcireg_t type</i>, <i class="farg" style="white-space:nowrap;">bus_addr_t *basep</i>, <i class="farg" style="white-space:nowrap;">bus_size_t *sizep</i>, <i class="farg" style="white-space:nowrap;">int *flagsp</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">pci_find_rom</b>(<i class="farg" style="white-space:nowrap;">const struct pci_attach_args *pa</i>, <i class="farg" style="white-space:nowrap;">bus_space_tag_t bst</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t bsh</i>, <i class="farg" style="white-space:nowrap;">int code</i>, <i class="farg" style="white-space:nowrap;">bus_space_handle_t *handlep</i>, <i class="farg" style="white-space:nowrap;">bus_space_size_t *sizep</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">pci_intr_map</b>(<i class="farg" style="white-space:nowrap;">const struct pci_attach_args *pa</i>, <i class="farg" style="white-space:nowrap;">pci_intr_handle_t *ih</i>);<p>
<i class="ftype">const char *</i><br>
<b class="fname">pci_intr_string</b>(<i class="farg" style="white-space:nowrap;">pci_chipset_tag_t pc</i>, <i class="farg" style="white-space:nowrap;">pci_intr_handle_t ih</i>);<p>
<i class="ftype">const struct evcnt *</i><br>
<b class="fname">pci_intr_evcnt</b>(<i class="farg" style="white-space:nowrap;">pci_chipset_tag_t pc</i>, <i class="farg" style="white-space:nowrap;">pci_intr_handle_t ih</i>);<p>
<i class="ftype">void *</i><br>
<b class="fname">pci_intr_establish</b>(<i class="farg" style="white-space:nowrap;">pci_chipset_tag_t pc</i>, <i class="farg" style="white-space:nowrap;">pci_intr_handle_t ih</i>, <i class="farg" style="white-space:nowrap;">int level</i>, <i class="farg" style="white-space:nowrap;">int (*handler)(void *)</i>, <i class="farg" style="white-space:nowrap;">void *arg</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">pci_intr_disestablish</b>(<i class="farg" style="white-space:nowrap;">pci_chipset_tag_t pc</i>, <i class="farg" style="white-space:nowrap;">void *ih</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">pci_set_powerstate</b>(<i class="farg" style="white-space:nowrap;">pci_chipset_tag_t pc</i>, <i class="farg" style="white-space:nowrap;">pcitag_t tag</i>, <i class="farg" style="white-space:nowrap;">pcireg_t newstate</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">pci_get_powerstate</b>(<i class="farg" style="white-space:nowrap;">pci_chipset_tag_t pc</i>, <i class="farg" style="white-space:nowrap;">pcitag_t tag</i>, <i class="farg" style="white-space:nowrap;">pcireg_t *state</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">pci_vpd_read</b>(<i class="farg" style="white-space:nowrap;">pci_chipset_tag_t pc</i>, <i class="farg" style="white-space:nowrap;">pcitag_t tag</i>, <i class="farg" style="white-space:nowrap;">int offset</i>, <i class="farg" style="white-space:nowrap;">int count</i>, <i class="farg" style="white-space:nowrap;">pcireg_t *data</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">pci_vpd_write</b>(<i class="farg" style="white-space:nowrap;">pci_chipset_tag_t pc</i>, <i class="farg" style="white-space:nowrap;">pcitag_t tag</i>, <i class="farg" style="white-space:nowrap;">int offset</i>, <i class="farg" style="white-space:nowrap;">int count</i>, <i class="farg" style="white-space:nowrap;">pcireg_t *data</i>);<p>
<i class="ftype">pcitag_t</i><br>
<b class="fname">pci_make_tag</b>(<i class="farg" style="white-space:nowrap;">pci_chipset_tag_t pc</i>, <i class="farg" style="white-space:nowrap;">int bus</i>, <i class="farg" style="white-space:nowrap;">int device</i>, <i class="farg" style="white-space:nowrap;">int function</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">pci_decompose_tag</b>(<i class="farg" style="white-space:nowrap;">pci_chipset_tag_t pc</i>, <i class="farg" style="white-space:nowrap;">pcitag_t tag</i>, <i class="farg" style="white-space:nowrap;">int *busp</i>, <i class="farg" style="white-space:nowrap;">int *devicep</i>, <i class="farg" style="white-space:nowrap;">int *functionp</i>);<p>
<i class="ftype">char *</i><br>
<b class="fname">pci_findvendor</b>(<i class="farg" style="white-space:nowrap;">pcireg_t id</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">pci_devinfo</b>(<i class="farg" style="white-space:nowrap;">pcireg_t id</i>, <i class="farg" style="white-space:nowrap;">pcireg_t class</i>, <i class="farg" style="white-space:nowrap;">int show</i>, <i class="farg" style="white-space:nowrap;">char *cp</i>, <i class="farg" style="white-space:nowrap;">size_t len</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">pci_aprint_devinfo</b>(<i class="farg" style="white-space:nowrap;">struct pci_attach_args *pa</i>, <i class="farg" style="white-space:nowrap;">const char *naive</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">PCI_VENDOR</b>(<i class="farg" style="white-space:nowrap;">pcireg_t id</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">PCI_PRODUCT</b>(<i class="farg" style="white-space:nowrap;">pcireg_t id</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">PCI_REVISION</b>(<i class="farg" style="white-space:nowrap;">pcireg_t id</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The machine-independent <b class="name">PCI</b> subsystem provides support for PCI devices.<p>
The PCI bus was initially developed by Intel in the early 1990's to replace the ISA bus for interfacing with their Pentium processor. The PCI specification is widely regarded as well designed, and the PCI bus has found widespread acceptance in machines ranging from Apple's PowerPC-based systems to Sun's UltraSPARC-based machines.<p>
The PCI bus is a multiplexed bus, allowing addresses and data on the same pins for a reduced number of pins. Data transfers can be 8-bit, 16-bit or 32-bit. A 64-bit extended PCI bus is also defined. Multi-byte transfers are little-endian. The PCI bus operates up to 33MHz and any device on the bus can be the bus master.<p>
AGP is a version of PCI optimised for high-throughput data rates, particularly for accelerated frame buffers.<p>
The PCI bus is a "plug and play" bus, in the sense that devices can be configured dynamically by software. The PCI interface chip on a PCI device bus presents a small window of registers into the PCI configuration space. These registers contain information about the device such as the vendor and a product ID. The configuration registers can also be written to by software to alter how the device interfaces to the PCI bus. An important register in the configuration space is the Base Address Register (BAR). The BAR is written to by software to map the device registers into a window of processor address space. Once this mapping is done, the device registers can be accessed relative to the base address.</div>
<div class="section">
<h1 id="x44415441205459504553">DATA TYPES</h1> Drivers for devices attached to the <b class="name">PCI</b> will make use of the following data types:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">pcireg_t</i></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Configuration space register.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">pci_chipset_tag_t</i></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Chipset tag for the PCI bus.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">pcitag_t</i></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Configuration tag describing the location and function of the PCI device. It contains the tuple &#60;bus, device, function&#62;.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">pci_intr_handle_t</i></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
The opaque handle describing an established interrupt handler.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">struct pci_attach_args</i></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Devices have their identity recorded in this structure. It contains the following members:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
	bus_space_tag_t pa_iot;		/* pci i/o space tag */ 
	bus_space_tag_t pa_memt;	/* pci mem space tag */ 
	bus_dma_tag_t pa_dmat;		/* DMA tag */ 
	pci_chipset_tag_t pa_pc; 
	int pa_flags;			/* flags */ 
	pcitag_t pa_tag; 
	pcireg_t pa_id; 
	pcireg_t pa_class;</pre>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">struct pci_conf_state</i></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Stores the PCI configuration state of a device. It contains the following member:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
	pcireg_t reg[16];			/* pci conf register */</pre>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">struct pci_overrides</i></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Stores pointers to functions that override the architecture's default <a class="link-man" href="../9/pci">pci(9)</a> and <a class="link-man" href="../9/pci_intr">pci_intr(9)</a> implementation. It contains the following members:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
	pcireg_t (*ov_conf_read)(void *, 
	    pci_chipset_tag_t, pcitag_t, int); 
	void (*ov_conf_write)(void *, 
	    pci_chipset_tag_t, pcitag_t, int, pcireg_t); 
	int (*ov_intr_map)(void *, 
	   const struct pci_attach_args *, pci_intr_handle_t *); 
	const char *(*ov_intr_string)(void *, 
	    pci_chipset_tag_t, pci_intr_handle_t); 
	const struct evcnt *(*ov_intr_evcnt)(void *, 
	    pci_chipset_tag_t, pci_intr_handle_t); 
	void *(*ov_intr_establish)(void *, 
	    pci_chipset_tag_t, pci_intr_handle_t, 
	    int, int (*)(void *), void *); 
	void (*ov_intr_disestablish)(void *, 
	    pci_chipset_tag_t, void *); 
	pcitag_t (*ov_make_tag)(void *, 
	    pci_chipset_tag_t, int, int, int); 
	void (*ov_decompose_tag)(void *, 
	    pci_chipset_tag_t, pcitag_t, int *, int *, int *);</pre>
</dd>
</dl>
</div>
<div class="section">
<h1 id="x46554e4354494f4e53">FUNCTIONS</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pci_bus_devorder</b>(<i class="farg">pc</i>, <i class="farg">bus</i>, <i class="farg">devs</i>, <i class="farg">maxdevs</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Tell how many devices a PCI bus driver should probe and in what order. If <i class="farg">maxdevs</i> is less than or equal to zero, return 0 and do not modify <i class="farg">devs</i>. Otherwise, return <i class="farg">maxdevs</i> or the number of devices on <i class="farg">bus</i> to probe, whichever is less, and copy to <i class="farg">devs</i> each of the PCI device numbers to probe in the order that they should be probed. <b class="fname">pci_bus_devorder</b>() will not copy more than <i class="farg">maxdevs</i> device numbers to <i class="farg">devs</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pci_activate</b>(<i class="farg">pc</i>, <i class="farg">tag</i>, <i class="farg">dev</i>, <i class="farg">fun</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Attempt to bring the device to state D0. If the device is not in the D0 state call <i class="farg">fun</i> to restore its state. If <i class="farg">fun</i> is <span class="define">NULL</span> then restoring from state D3 is going to fail.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pci_chipset_tag_create</b>(<i class="farg">opc</i>, <i class="farg">present</i>, <i class="farg">ov</i>, <i class="farg">ctx</i>, <i class="farg">pcp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Create a copy of the tag <i class="farg">opc</i> at <i class="farg">*pcp</i>. Except for the behavior overridden by <i class="farg">ov</i>, <i class="farg">*pcp</i> inherits the behavior of <i class="farg">opc</i> under <b class="name">PCI</b> calls.<p>
<i class="farg">ov</i> contains function pointers corresponding to <b class="name">PCI</b> routines. Each function pointer has a corresponding bit in <i class="farg">present</i>, and if that bit is 1, the function pointer overrides the corresponding <b class="name">PCI</b> call for the new tag. Any combination of these bits may be set in <i class="farg">present</i>:<p>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">PCI_OVERRIDE_CONF_READ</span></dt>
<dd class="list-tag" style="margin-left: 30.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">PCI_OVERRIDE_CONF_WRITE</span></dt>
<dd class="list-tag" style="margin-left: 30.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">PCI_OVERRIDE_INTR_MAP</span></dt>
<dd class="list-tag" style="margin-left: 30.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">PCI_OVERRIDE_INTR_STRING</span></dt>
<dd class="list-tag" style="margin-left: 30.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">PCI_OVERRIDE_INTR_EVCNT</span></dt>
<dd class="list-tag" style="margin-left: 30.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">PCI_OVERRIDE_INTR_ESTABLISH</span></dt>
<dd class="list-tag" style="margin-left: 30.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">PCI_OVERRIDE_INTR_DISESTABLISH</span></dt>
<dd class="list-tag" style="margin-left: 30.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">PCI_OVERRIDE_MAKE_TAG</span></dt>
<dd class="list-tag" style="margin-left: 30.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">PCI_OVERRIDE_DECOMPOSE_TAG</span></dt>
<dd class="list-tag" style="margin-left: 30.00ex;">
</dd>
</dl>
<p>
<b class="fname">pci_chipset_tag_create</b>() does not copy <i class="farg">ov</i>. After a new tag is created by <b class="fname">pci_chipset_tag_create</b>(), <i class="farg">ov</i> must not be destroyed until after the tag is destroyed by <b class="fname">pci_chipset_tag_destroy</b>().<p>
The first argument of every override-function is a <span class="type">void *</span>, and <i class="farg">ctx</i> is passed in that argument.<p>
Return 0 if the call succeeds. Return <span class="define">EOPNOTSUPP</span> if the architecture does not support overrides. Return <span class="define">EINVAL</span> if <i class="farg">present</i> is 0, if <i class="farg">ov</i> is <span class="define">NULL</span>, or if <i class="farg">present</i> indicates that an override is present, but the corresponding override in <i class="farg">ov</i> is <span class="define">NULL</span>.<p>
If the call does not succeed, <i class="farg">*pcp</i> is undefined.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pci_chipset_tag_destroy</b>(<i class="farg">pc</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Destroy a tag, <i class="farg">pc</i>, created by a prior call to <b class="fname">pci_chipset_tag_create</b>(). If <i class="farg">pc</i> was not created by <b class="fname">pci_chipset_tag_create</b>(), results are undefined. If <i class="farg">pc</i> was already destroyed, results are undefined.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pci_conf_read</b>(<i class="farg">pc</i>, <i class="farg">tag</i>, <i class="farg">reg</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Read from register <i class="farg">reg</i> in PCI configuration space. The argument <i class="farg">tag</i> is the PCI tag for the current device attached to PCI chipset <i class="farg">pc</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pci_conf_write</b>(<i class="farg">pc</i>, <i class="farg">tag</i>, <i class="farg">reg</i>, <i class="farg">val</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Write to register <i class="farg">reg</i> in PCI configuration space. The argument <i class="farg">tag</i> is the PCI tag for the current device attached to PCI chipset <i class="farg">pc</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pci_conf_print</b>(<i class="farg">pc</i>, <i class="farg">tag</i>, <i class="farg">func</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Print out most of the registers in the PCI configuration for the device. The argument <i class="farg">tag</i> is the PCI tag for the current device attached to PCI chipset <i class="farg">pc</i>. The argument <i class="farg">func</i> is a function called by <b class="fname">pci_conf_print</b>() to print the device-dependent registers. This function is only useful for driver development and is usually wrapped in pre-processor declarations.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pci_conf_capture</b>(<i class="farg">pc</i>, <i class="farg">tag</i>, <i class="farg">pcs</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Capture PCI configuration space into structure <i class="farg">pcs</i>. The argument <i class="farg">tag</i> is the PCI tag for the current device attached to the PCI chipset <i class="farg">pc</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pci_conf_restore</b>(<i class="farg">pc</i>, <i class="farg">tag</i>, <i class="farg">pcs</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Restores PCI configuration space from structure <i class="farg">pcs</i>. The argument <i class="farg">tag</i> is the PCI tag for the current device attached to the PCI chipset <i class="farg">pc</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pci_find_device</b>(<i class="farg">pa</i>, <i class="farg">func</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Find a device using a match function on all probed busses. The argument <i class="farg">func</i> is called by <b class="fname">pci_find_device</b>() to match a device. The argument <i class="farg">pa</i> is filled in if the device is matched. <b class="fname">pci_find_device</b>() returns 1 if the device is matched, and zero otherwise. This function is specifically for use by kernel modules and its use otherwise is strongly discouraged.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pci_get_capability</b>(<i class="farg">pc</i>, <i class="farg">tag</i>, <i class="farg">capid</i>, <i class="farg">offsetp</i>, <i class="farg">valuep</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Parse the device capability list in configuration space looking for capability <i class="farg">capid</i>. If <i class="farg">offsetp</i> is not NULL, the register offset in configuration space is returned in <i class="farg">offsetp</i>. If <i class="farg">valuep</i> is not NULL, the value of the capability is returned in <i class="farg">valuep</i>. The argument <i class="farg">tag</i> is the PCI tag for the current device attached to PCI chipset <i class="farg">pc</i>. This function returns 1 if the capability was found. If the capability was not found, it returns zero, and <i class="farg">offsetp</i> and <i class="farg">valuep</i> remain unchanged.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pci_mapreg_type</b>(<i class="farg">pc</i>, <i class="farg">tag</i>, <i class="farg">reg</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Interrogates the Base Address Register (BAR) in configuration space specified by <i class="farg">reg</i> and returns the default (or current) mapping type. Valid returns values are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">PCI_MAPREG_TYPE_IO</span></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
The mapping is to I/O address space.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">PCI_MAPREG_TYPE_MEM</span></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
The mapping is to memory address space.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">PCI_MAPREG_TYPE_MEM</span> | <span class="define">PCI_MAPREG_MEM_TYPE_64BIT</span></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
The mapping is to 64-bit memory address space.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">PCI_MAPREG_TYPE_ROM</span></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
The mapping is to ROM. Note that in the current implementation, <span class="define">PCI_MAPREG_TYPE_ROM</span> has the same numeric value as <span class="define">PCI_MAPREG_TYPE_MEM</span>.</dd>
</dl>
<p>
The argument <i class="farg">tag</i> is the PCI tag for the current device attached to PCI chipset <i class="farg">pc</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pci_mapreg_map</b>(<i class="farg">pa</i>, <i class="farg">reg</i>, <i class="farg">type</i>, <i class="farg">busflags</i>, <i class="farg">tagp</i>, <i class="farg">handlep</i>, <i class="farg">basep</i>, <i class="farg">sizep</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Maps the register windows for the device into kernel virtual address space. This function is generally only called during the driver attach step and takes a pointer to the <span class="emph">struct pci_attach_args</span> in <i class="farg">pa</i>. The physical address of the mapping is in the Base Address Register (BAR) in configuration space specified by <i class="farg">reg</i>. Valid values for the type of mapping <i class="farg">type</i> are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">PCI_MAPREG_TYPE_IO</span></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
The mapping should be to I/O address space.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">PCI_MAPREG_TYPE_MEM</span></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
The mapping should be to memory address space.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">PCI_MAPREG_TYPE_ROM</span></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
The mapping is to access ROM. This type of mapping is only permitted when the value for <i class="farg">reg</i> is <span class="define">PCI_MAPREG_ROM</span>.</dd>
</dl>
<p>
The argument <i class="farg">busflags</i> are bus-space flags passed to <b class="fname">bus_space_map</b>() to perform the mapping (see <a class="link-man" href="../9/bus_space">bus_space(9)</a>). The bus-space tag and handle for the mapped register window are returned in <i class="farg">tagp</i> and <i class="farg">handlep</i> respectively. The bus-address and size of the mapping are returned in <i class="farg">basep</i> and <i class="farg">sizep</i> respectively. If any of <i class="farg">tagp</i>, <i class="farg">handlep</i>, <i class="farg">basep</i>, or <i class="farg">sizep</i> are NULL then <b class="fname">pci_mapreg_map</b>() does not define their return value. This function returns zero on success and non-zero on error.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pci_mapreg_info</b>(<i class="farg">pc</i>, <i class="farg">tag</i>, <i class="farg">reg</i>, <i class="farg">type</i>, <i class="farg">basep</i>, <i class="farg">sizep</i>, <i class="farg">flagsp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Performs the same operations as <b class="fname">pci_mapreg_map</b>() but doesn't actually map the register window into kernel virtual address space. Returns the bus-address, size and bus flags in <i class="farg">basep</i>, <i class="farg">sizep</i> and <i class="farg">flagsp</i> respectively. These return values can be used by <b class="fname">bus_space_map</b>() to actually map the register window into kernel virtual address space. This function is useful for setting up the registers in configuration space and deferring the mapping to a later time, such as in a bus-independent attachment routine. <i class="farg">pci_mapreg_info</i> returns zero on success and non-zero on failure.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pci_find_rom</b>(<i class="farg">pa</i>, <i class="farg">bst</i>, <i class="farg">bsh</i>, <i class="farg">code</i>, <i class="farg">handlep</i>, <i class="farg">sizep</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Locates a suitable ROM image within a PCI expansion ROM previously mapped with <b class="fname">pci_mapreg_map</b>() and creates a subregion for it with <b class="fname">bus_space_subregion</b>(). The <i class="farg">bst</i> and <i class="farg">bsh</i> arguments are the bus tag and handle obtained with the prior call to <b class="fname">pci_mapreg_map</b>(). Valid values for the image type <i class="farg">code</i> are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">PCI_ROM_CODE_TYPE_X86</span></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Find a ROM image containing i386 executable code for use by PC BIOS.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">PCI_ROM_CODE_TYPE_OFW</span></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Find a ROM image containing Forth code for use by Open Firmware.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">PCI_ROM_CODE_TYPE_HPPA</span></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Find a ROM image containing HP PA/RISC executable code.</dd>
</dl>
<p>
The created subregion will cover the entire selected ROM image, including header data. The handle to this subregion is returned in <i class="farg">handlep</i>. The size of the image (and the corresponding subregion) is returned in <i class="farg">sizep</i>. This function can only be used with expansion ROMs located at the <span class="define">PCI_MAPREG_ROM</span> base address register (BAR).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pci_intr_map</b>(<i class="farg">pa</i>, <i class="farg">ih</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
See <a class="link-man" href="../9/pci_intr">pci_intr(9)</a>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pci_intr_string</b>(<i class="farg">pc</i>, <i class="farg">ih</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
See <a class="link-man" href="../9/pci_intr">pci_intr(9)</a>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pci_intr_evcnt</b>(<i class="farg">pc</i>, <i class="farg">ih</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
See <a class="link-man" href="../9/pci_intr">pci_intr(9)</a>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pci_intr_establish</b>(<i class="farg">pc</i>, <i class="farg">ih</i>, <i class="farg">level</i>, <i class="farg">handler</i>, <i class="farg">arg</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
See <a class="link-man" href="../9/pci_intr">pci_intr(9)</a>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pci_intr_disestablish</b>(<i class="farg">pc</i>, <i class="farg">ih</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
See <a class="link-man" href="../9/pci_intr">pci_intr(9)</a>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pci_set_powerstate</b>(<i class="farg">pc</i>, <i class="farg">tag</i>, <i class="farg">newstate</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Set power state of the device to newstate. Valid values for <i class="farg">newstate</i> are:<p>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">PCI_PMCSR_STATE_D0</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">PCI_PMCSR_STATE_D1</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">PCI_PMCSR_STATE_D2</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">PCI_PMCSR_STATE_D3</span></dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
</dd>
</dl>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pci_get_powerstate</b>(<i class="farg">pc</i>, <i class="farg">tag</i>, <i class="farg">state</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Get current power state of the device.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pci_vpd_read</b>(<i class="farg">pc</i>, <i class="farg">tag</i>, <i class="farg">offset</i>, <i class="farg">count</i>, <i class="farg">data</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Read <i class="farg">count</i> 32-bit words of Vital Product Data for the device starting at offset <i class="farg">offset</i> into the buffer pointed to by <i class="farg">data</i>. Returns 0 on success or non-zero if the device has no Vital Product Data capability or if reading the Vital Product Data fails.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pci_vpd_write</b>(<i class="farg">pc</i>, <i class="farg">tag</i>, <i class="farg">offset</i>, <i class="farg">count</i>, <i class="farg">data</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Write <i class="farg">count</i> 32-bit words of Vital Product Data for the device starting at offset <i class="farg">offset</i> from the buffer pointed to by <i class="farg">data</i>. Returns 0 on success or non-zero if the device has no Vital Product Data capability of if writing the Vital Product Data fails.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pci_make_tag</b>(<i class="farg">pc</i>, <i class="farg">bus</i>, <i class="farg">device</i>, <i class="farg">function</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Create a new PCI tag for the PCI device specified by the tuple &#60;bus, device, function&#62;. This function is not useful to the usual PCI device driver. It is generally used by drivers of multi-function devices when attaching other PCI device drivers to each function.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pci_decompose_tag</b>(<i class="farg">pc</i>, <i class="farg">tag</i>, <i class="farg">busp</i>, <i class="farg">devicep</i>, <i class="farg">fnp</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Decompose the PCI tag <i class="farg">tag</i> generated by <b class="fname">pci_make_tag</b>() into its &#60;bus, device, function&#62; tuple.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pci_findvendor</b>(<i class="farg">id</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Return the string of the vendor name for the device specified by <i class="farg">id</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pci_devinfo</b>(<i class="farg">id</i>, <i class="farg">class</i>, <i class="farg">show</i>, <i class="farg">cp</i>, <i class="farg">len</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Returns the description string from the in-kernel PCI database for the device described by <i class="farg">id</i> and <i class="farg">class</i>. The description string is returned in <i class="farg">cp</i>; the size of that storage is given in <i class="farg">len</i>. The argument <i class="farg">show</i> specifies whether the PCI subsystem should report the string to the console.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pci_aprint_devinfo</b>(<i class="farg">pa</i>, <i class="farg">naive</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Print device information to the console and system log, using the <a class="link-man" href="../9/aprint_normal">aprint_normal(9)</a> and <a class="link-man" href="../9/aprint_naive">aprint_naive(9)</a> functions. For the device information, the &#8220;pci_devinfo&#8221; function above is used, or the <i class="arg">naive</i> argument in the &#8220;AB_QUIET&#8221; case. This function is intended to be used early in device attach.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">PCI_VENDOR</b>(<i class="farg">id</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Return the PCI vendor id for device <i class="farg">id</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">PCI_PRODUCT</b>(<i class="farg">id</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Return the PCI product id for device <i class="farg">id</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">PCI_REVISION</b>(<i class="farg">id</i>)</dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
Return the PCI product revision for device <i class="farg">id</i>.</dd>
</dl>
</div>
<div class="section">
<h1 id="x4155544f434f4e46494755524154494f4e">AUTOCONFIGURATION</h1> During autoconfiguration, a <b class="name">PCI</b> driver will receive a pointer to <i class="farg">struct pci_attach_args</i> describing the device attaches to the PCI bus. Drivers match the device using the <i class="farg">pa_id</i> member using <b class="fname">PCI_VENDOR</b>(). <b class="fname">PCI_PRODUCT</b>() and <b class="fname">PCI_REVISION</b>().<p>
During the driver attach step, drivers can read the device configuration space using <b class="fname">pci_conf_read</b>(). The meaning attached to registers in the PCI configuration space are device-dependent, but will usually contain physical addresses of the device register windows. Device options can also be stored into the PCI configuration space using <b class="fname">pci_conf_write</b>(). For example, the driver can request support for bus-mastering DMA by writing the option to the PCI configuration space.<p>
Device capabilities can be queried using <b class="fname">pci_get_capability</b>(), and returns device-specific information which can be found in the PCI configuration space to alter device operation.<p>
After reading the physical addresses of the device register windows from configuration space, these windows must be mapped into kernel virtual address space using <b class="fname">pci_mapreg_map</b>(). Device registers can now be accessed using the standard bus-space API (see <a class="link-man" href="../9/bus_space">bus_space(9)</a>).<p>
Details of using PCI interrupts is described in <a class="link-man" href="../9/pci_intr">pci_intr(9)</a>.</div>
<div class="section">
<h1 id="x444d4120535550504f5254">DMA SUPPORT</h1> The PCI bus supports bus-mastering operations from any device on the bus. The DMA facilities are accessed through the standard <a class="link-man" href="../9/bus_dma">bus_dma(9)</a> interface. To support DMA transfers from the device to the host, it is necessary to enable bus-mastering in the PCI configuration space for the device.<p>
During system shutdown, it is necessary to abort any DMA transfers in progress by registering a shutdown hook (see <a class="link-man" href="../9/pmf">pmf(9)</a>).</div>
<div class="section">
<h1 id="x434f4445205245464552454e434553">CODE REFERENCES</h1> The PCI subsystem itself is implemented within the files <i class="file">sys/dev/pci/pci.c</i>, <i class="file">sys/dev/pci/pci_subr.c</i>, <i class="file">sys/dev/pci/pci_map.c</i>, <i class="file">sys/dev/pci/pci_quirks.c</i>, and <i class="file">sys/dev/pci/pciconf.c</i>. Machine-dependent portions are implemented within the file <i class="file">sys/arch/&lt;arch&gt;/pci/pci_machdep.c</i>.<p>
The database of known devices exists within the file <i class="file">sys/dev/pci/pcidevs_data.h</i> and is generated automatically from the file <i class="file">sys/dev/pci/pcidevs</i>. New vendor and product identifiers should be added to this file. The database can be regenerated using the Makefile <i class="file">sys/dev/pci/Makefile.pcidevs</i>.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../4/pci">pci(4)</a>, <a class="link-man" href="../9/autoconf">autoconf(9)</a>, <a class="link-man" href="../9/bus_dma">bus_dma(9)</a>, <a class="link-man" href="../9/bus_space">bus_space(9)</a>, <a class="link-man" href="../9/driver">driver(9)</a>, <a class="link-man" href="../9/pci_configure_bus">pci_configure_bus(9)</a>, <a class="link-man" href="../9/pci_intr">pci_intr(9)</a>, <a class="link-man" href="../9/pmf">pmf(9)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The machine-independent PCI subsystem appeared in <span class="unix">NetBSD&#160;1.2</span>.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
October 27, 2014</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
<>

