<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="/static/man_pages/netbsd/style.css" type="text/css" media="all">
<title>
MODULE(9)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
MODULE(9)</td>
<td class="head-vol" align="center">
Kernel Developer's Manual</td>
<td class="head-rtitle" align="right">
MODULE(9)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">module</b>, <b class="name">module_load</b>, <b class="name">module_autoload</b>, <b class="name">module_unload</b>, <b class="name">module_init_class</b>, <b class="name">module_hold</b>, <b class="name">module_rele</b>, <b class="name">module_find_section</b> &#8212; <span class="desc">kernel module loader</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/module.h</a>&gt;</b><p>
<b class="fname">MODULE</b>(<i class="farg" style="white-space:nowrap;">class</i>, <i class="farg" style="white-space:nowrap;">name</i>, <i class="farg" style="white-space:nowrap;">required</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">module_load</b>(<i class="farg" style="white-space:nowrap;">const char *name</i>, <i class="farg" style="white-space:nowrap;">int flags</i>, <i class="farg" style="white-space:nowrap;">prop_dictionary_t props</i>, <i class="farg" style="white-space:nowrap;">modclass_t class</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">module_autoload</b>(<i class="farg" style="white-space:nowrap;">const char *name</i>, <i class="farg" style="white-space:nowrap;">modclass_t class</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">module_unload</b>(<i class="farg" style="white-space:nowrap;">const char *name</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">module_init_class</b>(<i class="farg" style="white-space:nowrap;">modclass_t class</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">module_hold</b>(<i class="farg" style="white-space:nowrap;">const char *name</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">module_rele</b>(<i class="farg" style="white-space:nowrap;">const char *</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">module_find_section</b>(<i class="farg" style="white-space:nowrap;">const char *</i>, <i class="farg" style="white-space:nowrap;">void **</i>, <i class="farg" style="white-space:nowrap;">size_t *</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">module_init</b>(<i class="farg" style="white-space:nowrap;">void</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">module_start_unload_thread</b>(<i class="farg" style="white-space:nowrap;">void</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">module_builtin_require_force</b>(<i class="farg" style="white-space:nowrap;">void</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">module_load_vfs_init</b>(<i class="farg" style="white-space:nowrap;">void</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> Modules are sections of code that can be independently linked and selectively loaded into or unloaded from a running kernel. This provides a mechanism to update the module without having to relink the kernel and reboot. Modules can be loaded from within the kernel image, provided by the boot loader, or loaded from the file system.<p>
Two data types are relevant for <b class="name">module</b>:<ol style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-enum">
<li class="list-enum" style="margin-top: 1.00em;">
The <span class="type">module_t</span> type provides storage to describe a module.</li>
<li class="list-enum" style="margin-top: 1.00em;">
The <span class="type">modinfo_t</span> type resides within the module itself, and contains module header info.</li>
</ol>
<p>
The module subsystem is protected by the global kernconfig_mutex.</div>
<div class="section">
<h1 id="x46554e4354494f4e53">FUNCTIONS</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">MODULE</b>(<i class="farg">class</i>, <i class="farg">name</i>, <i class="farg">required</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The <b class="fname">MODULE</b>() macro creates and initializes a <span class="type">modinfo_t</span> structure. In addition to the explicit arguments, the <b class="fname">MODULE</b>() macro creates a reference to the module's <b class="fname">modcmd</b>() function. This function is defined as:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="ftype">int</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<b class="fname">modcmd</b>(<i class="farg">modcmd_t cmd</i>, <i class="farg">void *data</i>)</dd>
</dl>
<p>
The <i class="farg">cmd</i> argument requests one of the following operations:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MODULE_CMD_INIT</span></dt>
<dd class="list-tag" style="margin-left: 21.00ex;">
Perform module-specific initialization when the module is loaded.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MODULE_CMD_FINI</span></dt>
<dd class="list-tag" style="margin-left: 21.00ex;">
Perform module-specific clean-up before the module is unloaded.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MODULE_CMD_AUTOUNLOAD</span></dt>
<dd class="list-tag" style="margin-left: 21.00ex;">
Notify the module that it is about to be unloaded.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MODULE_CMD_STAT</span></dt>
<dd class="list-tag" style="margin-left: 21.00ex;">
Request the module to provide status information (not currently implemented).</dd>
</dl>
<p>
All modules' <b class="fname">modcmd</b>() functions must implement the <span class="define">MODULE_CMD_INIT</span> and <span class="define">MODULE_CMD_FINI</span> commands. The other commands are optional, and should return <span class="errno">ENOTTY</span> if not implemented.<p>
For the <span class="define">MODULE_CMD_INIT</span> command, the <i class="farg">data</i> argument is used to pass a pointer to the module's <a class="link-man" href="../3/prop_dictionary">prop_dictionary(3)</a>. For the <span class="define">MODULE_CMD_STAT</span> command, the <i class="farg">data</i> argument points to a buffer where the status information should be placed.<p>
The __link_set mechanism is used to enable the <b class="name">module</b> subsystem to locate the <span class="type">modinfo_t</span> structure.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">module_load</b>(<i class="farg">name</i>, <i class="farg">flags</i>, <i class="farg">props</i>, <i class="farg">class</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Load a module, link it into the running kernel, and call the module's <b class="fname">modcmd</b>() routine with a <i class="farg">cmd</i> argument of <span class="define">MODULE_CMD_INIT</span>. If the specified module requires other modules, they are loaded first; if any required module cannot be loaded or if any of their <b class="fname">modcmd</b>() control routines returns a non-zero status, loading of this module and the specific required module will fail. The required modules are marked for automatic unloading. Thus, if the loading of the module failed, the required modules will be automatically unloaded after a short delay.<p>
The loader will look first for a built-in module with the specified <i class="farg">name</i> that has not been disabled (see <b class="fname">module_unload</b>() below). If a built-in module with that <i class="farg">name</i> is not found, the list of modules prepared by the boot loader is searched. If the named module is still not found, an attempt is made to locate the module within the file system, provided it has been mounted by the initialization code.<p>
The <i class="farg">flags</i> argument can include:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MODCTL_NO_PROP</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
When loading a module from the file system, do not attempt to locate a corresponding prop_dictionary file.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MODCTL_LOAD_FORCE</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
Force loading of disabled built-in modules and modules built for a different version of the operating system.</dd>
</dl>
<p>
The <i class="farg">props</i> argument points to an externalized property list which is passed to the module's <b class="fname">modcmd</b>() routine. If a module is being loaded from the file system, and the <span class="define">MODCTL_NO_PROP</span> flag is not set, the system searches for a file with the same name as the module file, but with the suffix &#8220;<i class="file">.plist</i>&#8221;. If this file is found, the prop_dictionary it contains is loaded and merged with the prop_dictionary from the <i class="farg">props</i> argument.<p>
The <i class="farg">class</i> argument can be any of:<p>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">MODULE_CLASS_ANY</span></dt>
<dd class="list-tag" style="margin-left: 21.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">MODULE_CLASS_DRIVER</span></dt>
<dd class="list-tag" style="margin-left: 21.00ex;">
Device driver</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">MODULE_CLASS_EXEC</span></dt>
<dd class="list-tag" style="margin-left: 21.00ex;">
Executable image handler</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">MODULE_CLASS_MISC</span></dt>
<dd class="list-tag" style="margin-left: 21.00ex;">
Miscellaneous module</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">MODULE_CLASS_SECMODEL</span></dt>
<dd class="list-tag" style="margin-left: 21.00ex;">
Security model (see <a class="link-man" href="../9/secmodel">secmodel(9)</a> for more details)</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">MODULE_CLASS_VFS</span></dt>
<dd class="list-tag" style="margin-left: 21.00ex;">
Virtual file system</dd>
</dl>
<p>
If the class is not <span class="define">MODULE_CLASS_ANY</span>, the class of the module being loaded must match the requested <i class="farg">class</i>. Except when verifying a module's class when it is being loaded, module classes other than <span class="define">MODULE_CLASS_SECMODEL</span> are transparent to the module subsystem. They are provided only for the benefit of the subsystem's clients. Modules with class <span class="define">MODULE_CLASS_SECMODEL</span> are automatically registered with <b class="fname">secmodel_register</b>() after being successfully loaded, and automatically deregistered with <b class="fname">secmodel_deregister</b>() when being unloaded.<p>
The <b class="fname">module_load</b>() routine is primarily intended as the implementation of the <span class="define">MODCTL_LOAD</span> option of the <a class="link-man" href="../2/modctl">modctl(2)</a> system call.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">module_autoload</b>(<i class="farg">name</i>, <i class="farg">class</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Auto-load a module, making it available for automatic unloading. The <i class="farg">name</i> and <i class="farg">class</i> arguments are the same as for the <b class="fname">module_load</b>() routine.<p>
The module subsystem uses a kernel thread to attempt to automatically unload modules a short time (currently, 10 seconds) after being loaded by <b class="fname">module_autoload</b>(). Before the module is unloaded, its <b class="fname">modcmd</b>() is called with the <i class="farg">cmd</i> argument specified as <span class="define">MODULE_CMD_AUTOUNLOAD</span>. A module can prevent itself from being unloaded by returning a non-zero value.<p>
The <b class="fname">module_autoload</b>() function is intended for use by kernel components to locate and load optional system components. The function is also used to load modules that are required by other modules.<p>
The directory from which the module is loaded will be searched for a file with the same name as the module file, but with the suffix &#8220;<i class="file">.plist</i>&#8221;. If this file is found, the prop_dictionary it contains will be loaded and passed to the module's <b class="fname">modcmd</b>() routine. If this prop_dictionary contains a &#8220;<i class="file">noautoload</i>&#8221; property which is set to &#8220;<i class="file">true</i>&#8221; then the system will refuse to load the module.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">module_unload</b>(<i class="farg">name</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Unload a module. If the module's reference count is non-zero, the function returns <span class="errno">EBUSY</span>. Otherwise, the module's <b class="fname">modcmd</b>() routine is called with a <i class="farg">cmd</i> argument of <span class="define">MODULE_CMD_FINI</span>. If the <b class="fname">modcmd</b>() routine returns with an error, then the error is returned to the caller otherwise the module is unloaded.<p>
The reference counts of all modules that were required by this module are decremented, but the required modules are not unloaded by the call to <b class="fname">module_unload</b>(). Instead, the required modules may be unloaded by subsequent calls to <b class="fname">module_unload</b>().<p>
Unloading a built-in module causes the module to be marked as disabled. This prevents the module from being re-loaded, except by the <b class="fname">module_load</b>() function with the <i class="farg">flags</i> argument set to <span class="define">MODULE_FORCE_LOAD</span>.<p>
The <b class="fname">module_unload</b>() function may be called by the <a class="link-man" href="../2/modctl">modctl(2)</a> system call, by the module subsystem's internal auto-unload thread, or by other kernel facilities. Generally, other kernel facilities should not be calling this function.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">module_init_class</b>(<i class="farg">class</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Load and initialize all available modules of the specified <i class="farg">class</i>. Any built-in modules that have not been disabled, and any modules provided by the boot loader are loaded.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">module_hold</b>(<i class="farg">name</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Increment the reference count of a module. A module cannot be unloaded if its reference count is non-zero.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">module_rele</b>(<i class="farg">name</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Decrement the reference count of a module.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">module_find_section</b>(<i class="farg">name</i>, <i class="farg">addr</i>, <i class="farg">size</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Find the start address and size of linker section <i class="arg">name</i> within a module. The miniroot module uses this routine to find the address and size of the embedded file system image. This routine can only examine the linker data for the module that is currently being initialized;  it cannot examine data for any other module.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">module_init</b>(<i class="farg">void</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Initialize the module subsystem. Creates and initializes various data structures, locates all built-in modules, and establishes the sub-system's <a class="link-man" href="../8/sysctl">sysctl(8)</a> tree. <b class="fname">module_init</b>() is called early in system initialization to facilitate use of security model modules.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">module_start_unload_thread</b>(<i class="farg">void</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Create the thread that attempts to automatically unload modules that were loaded via the <b class="fname">module_autoload</b>() routine. The function is called only once, after the scheduler and timer functions are initialized.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">module_builtin_require_force</b>(<i class="farg">void</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Mark as "disabled" any built-in modules that have not been successfully initialized. Modules marked "disabled" can only be loaded if the <span class="define">MODCTL_LOAD_FORCE</span> is specified. <b class="fname">module_builtin_require_force</b>() is called near the end of system initialization, after the <a class="link-man" href="../8/init">init(8)</a> process is created.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">module_load_vfs_init</b>()</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The module subsystem is initialized early, long before any file systems are available. After the root file system is mounted, <b class="fname">module_load_vfs_init</b>() is used to enable loading modules from the file system. Until this routine is called, modules can only be loaded if they were built-in to the kernel image or provided by the boot loader.</dd>
</dl>
</div>
<div class="section">
<h1 id="x50524f4752414d4d494e4720434f4e53494445524154494f4e53">PROGRAMMING CONSIDERATIONS</h1> The module subsystem is designed to be called recursively, but only within a single LWP. This permits one module's <b class="fname">modcmd</b>() routine to load or unload other modules.<p>
Additional considerations:<ul style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-bul">
<li class="list-bul" style="margin-top: 1.00em;">
A module is not permitted to load or unload itself. Attempts to load or unload a module from within its own <b class="fname">modcmd</b>() routine will fail with <span class="errno">EEXIST</span> or <span class="errno">EBUSY</span>, respectively.</li>
<li class="list-bul" style="margin-top: 1.00em;">
Although a module can be loaded by using either <b class="fname">module_load</b>() or <b class="fname">module_autoload</b>(), it is not possible for the module's <b class="fname">modcmd</b>() routine to distinguish between the two methods. Any module which needs to ensure that it does not get auto-unloaded must either handle the <span class="define">MODULE_CMD_AUTOUNLOAD</span> command in its <b class="fname">modcmd</b>() routine, or use <b class="fname">module_hold</b>() to increment its reference count. Note however that modules loaded manually with <a class="link-man" href="../8/modload">modload(8)</a> are never auto-unloaded.</li>
</ul>
</div>
<div class="section">
<h1 id="x4558414d504c4553">EXAMPLES</h1> A set of example modules is available in the <i class="file">src/sys/modules/examples</i> directory hierarchy.</div>
<div class="section">
<h1 id="x434f4445205245464552454e434553">CODE REFERENCES</h1> The core of the kernel module implementation is in <i class="file">sys/kern/kern_module.c</i> and <i class="file">sys/kern/kern_module_vfs.c</i>.<p>
The routines for linking the module are in <i class="file">sys/kern/subr_kobj.c</i>.<p>
The routines for reading a module from the file system are in <i class="file">sys/kern/subr_kobj_vfs.c</i>.<p>
The header file <b class="includes">&lt;<a class="link-includes">sys/sys/module.h</a>&gt;</b> describes the public interface.<p>
In addition, each architecture is expected to provide <b class="fname">kobj_machdep</b>(), <b class="fname">kobj_reloc</b>(), and <b class="fname">module_init_md</b>(). <b class="fname">kobj_machdep</b>() is for any machine dependent actions, such as flushing caches, that are needed when a module is loaded or unloaded. <b class="fname">kobj_reloc</b>() deals with resolution of relocatable symbols. <b class="fname">module_init_md</b>() is for finding modules passed in by the boot loader.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../2/modctl">modctl(2)</a>, <a class="link-man" href="../7/module">module(7)</a>, <a class="link-man" href="../9lua/intro">intro(9lua)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The kernel module subsystem first appeared in <span class="unix">NetBSD&#160;5.0</span>. It replaces the &#8220;LKM&#8221; subsystem from earlier releases.</div>
<div class="section">
<h1 id="x415554484f5253">AUTHORS</h1> <span class="author"></span>The <b class="name">module</b> system was written by <span class="author">Andrew Doran</span> &#60;<a class="link-mail" href="mailto:ad@NetBSD.org">ad@NetBSD.org</a>&#62;. This manual page was written by <span class="author">Paul Goyette</span> &#60;<a class="link-mail" href="mailto:pgoyette@NetBSD.org">pgoyette@NetBSD.org</a>&#62;.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
October 18, 2011</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

