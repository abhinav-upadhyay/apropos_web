<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="/static/man_pages/netbsd/style.css" type="text/css" media="all">
<title>
SELECT(2)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
SELECT(2)</td>
<td class="head-vol" align="center">
System Calls Manual</td>
<td class="head-rtitle" align="right">
SELECT(2)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">select</b>, <b class="name">pselect</b> &#8212; <span class="desc">synchronous I/O multiplexing</span></div>
<div class="section">
<h1 id="x4c494252415259">LIBRARY</h1> <span class="lib">Standard C Library (libc, &#45;lc)</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/select.h</a>&gt;</b><p>
<i class="ftype">int</i><br>
<b class="fname">select</b>(<i class="farg" style="white-space:nowrap;">int nfds</i>, <i class="farg" style="white-space:nowrap;">fd_set * restrict readfds</i>, <i class="farg" style="white-space:nowrap;">fd_set * restrict writefds</i>, <i class="farg" style="white-space:nowrap;">fd_set * restrict exceptfds</i>, <i class="farg" style="white-space:nowrap;">struct timeval * restrict timeout</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">pselect</b>(<i class="farg" style="white-space:nowrap;">int nfds</i>, <i class="farg" style="white-space:nowrap;">fd_set * restrict readfds</i>, <i class="farg" style="white-space:nowrap;">fd_set * restrict writefds</i>, <i class="farg" style="white-space:nowrap;">fd_set * restrict exceptfds</i>, <i class="farg" style="white-space:nowrap;">const struct timespec *restrict timeout</i>, <i class="farg" style="white-space:nowrap;">const sigset_t * restrict sigmask</i>);<p>
<b class="fname">FD_SET</b>(<i class="farg" style="white-space:nowrap;">int fd</i>, <i class="farg" style="white-space:nowrap;">fd_set *fdset</i>);<p>
<b class="fname">FD_CLR</b>(<i class="farg" style="white-space:nowrap;">int fd</i>, <i class="farg" style="white-space:nowrap;">fd_set *fdset</i>);<p>
<b class="fname">FD_ISSET</b>(<i class="farg" style="white-space:nowrap;">int fd</i>, <i class="farg" style="white-space:nowrap;">fd_set *fdset</i>);<p>
<b class="fname">FD_ZERO</b>(<i class="farg" style="white-space:nowrap;">fd_set *fdset</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> <b class="fname">select</b>() and <b class="fname">pselect</b>() examine the I/O descriptor sets whose addresses are passed in <i class="farg">readfds</i>, <i class="farg">writefds</i>, and <i class="farg">exceptfds</i> to see if some of their descriptors are ready for reading, are ready for writing, or have an exceptional condition pending, respectively. The first <i class="farg">nfds</i> descriptors are checked in each set; i.e., the descriptors from 0 through <i class="farg">nfds</i>&#45;1 in the descriptor sets are examined. This means that <i class="farg">nfds</i> must be set to the highest file descriptor of the three sets, plus one. On return, <b class="fname">select</b>() and <b class="fname">pselect</b>() replace the given descriptor sets with subsets consisting of those descriptors that are ready for the requested operation. <b class="fname">select</b>() and <b class="fname">pselect</b>() return the total number of ready descriptors in all the sets.<p>
The descriptor sets are stored as bit fields in arrays of integers. The following macros are provided for manipulating such descriptor sets: <b class="fname">FD_ZERO</b>(<i class="farg">fdset</i>) initializes a descriptor set pointed to by <i class="farg">fdset</i> to the null set. <b class="fname">FD_SET</b>(<i class="farg">fd</i>, <i class="farg">fdset</i>) includes a particular descriptor <i class="farg">fd</i> in <i class="farg">fdset</i>. <b class="fname">FD_CLR</b>(<i class="farg">fd</i>, <i class="farg">fdset</i>) removes <i class="farg">fd</i> from <i class="farg">fdset</i>. <b class="fname">FD_ISSET</b>(<i class="farg">fd</i>, <i class="farg">fdset</i>) is non-zero if <i class="farg">fd</i> is a member of <i class="farg">fdset</i>, zero otherwise. The behavior of these macros is undefined if a descriptor value is less than zero or greater than or equal to <span class="define">FD_SETSIZE</span>, which is normally at least equal to the maximum number of descriptors supported by the system.<p>
If <i class="farg">timeout</i> is a non-null pointer, it specifies a maximum interval to wait for the selection to complete. If <i class="farg">timeout</i> is a null pointer, the select blocks indefinitely. To poll without blocking, the <i class="farg">timeout</i> argument should be non-null, pointing to a zero-valued timeval or timespec structure, as appropriate. <i class="farg">timeout</i> is not changed by <b class="fname">select</b>(), and may be reused on subsequent calls; however, it is good style to re-initialize it before each invocation of <b class="fname">select</b>().<p>
If <i class="farg">sigmask</i> is a non-null pointer, then the <b class="fname">pselect</b>() function shall replace the signal mask of the caller by the set of signals pointed to by <i class="farg">sigmask</i> before examining the descriptors, and shall restore the signal mask of the calling thread before returning.<p>
Any of <i class="farg">readfds</i>, <i class="farg">writefds</i>, and <i class="farg">exceptfds</i> may be given as null pointers if no descriptors are of interest.</div>
<div class="section">
<h1 id="x4e4f544553">NOTES</h1> It is recommended to use the <a class="link-man" href="../2/poll">poll(2)</a> interface instead, which tends to be more portable and efficient.</div>
<div class="section">
<h1 id="x52455455524e2056414c554553">RETURN VALUES</h1> <b class="fname">select</b>() returns the number of ready descriptors that are contained in the descriptor sets, or &#45;1 if an error occurred. If the time limit expires, <b class="fname">select</b>() returns 0. If <b class="fname">select</b>() returns with an error, including one due to an interrupted call, the descriptor sets will be unmodified.</div>
<div class="section">
<h1 id="x4558414d504c4553">EXAMPLES</h1><pre style="margin-left: 0.00ex;" class="lit display">
#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt; 
#include &lt;unistd.h&gt; 
#include &lt;string.h&gt; 
#include &lt;err.h&gt; 
#include &lt;errno.h&gt; 
#include &lt;sys/types.h&gt; 
#include &lt;sys/time.h&gt; 
 
int 
main(int argc, char **argv) 
{ 
	fd_set read_set; 
	struct timeval timeout; 
	int ret, fd, i; 
 
	/* file descriptor 1 is stdout */ 
	fd = 1; 
 
	/* Wait for ten seconds. */ 
	timeout.tv_sec = 10; 
	timeout.tv_usec = 0; 
 
	/* Initialize the read set to null */ 
	FD_ZERO(&amp;read_set); 
 
	/* Add file descriptor 1 to read_set */ 
	FD_SET(fd, &amp;read_set); 
 
	/* 
	 * Check if data is ready to be read on 
	 * file descriptor 1, give up after 10 seconds. 
	 */ 
	ret = select(fd + 1, &amp;read_set, NULL, NULL, &amp;timeout); 
 
	/* 
	 * Returned value is the number of file 
	 * descriptors ready for I/O, or -1 on error. 
	 */ 
	switch (ret) { 
	case &#45;1: 
		err(EXIT_FAILURE, "select() failed"); 
		break; 
 
	case 0: 
		printf("Timeout, no data received.&#92;n"); 
		break; 
 
	default: 
		printf("Data received on %d file descriptor(s)&#92;n", ret); 
 
		/* 
		 * select(2) hands back a file descriptor set where 
		 * only descriptors ready for I/O are set. These can 
		 * be tested using FD_ISSET 
		 */ 
		for (i = 0; i &lt;= fd; i++) { 
			if (FD_ISSET(i, &amp;read_set)) { 
				printf("Data on file descriptor %d&#92;n", i); 
				/* Remove the file descriptor from the set */ 
				FD_CLR(fd, &amp;read_set); 
			} 
		} 
		break; 
	} 
 
	return 0; 
}</pre>
</div>
<div class="section">
<h1 id="x4552524f5253">ERRORS</h1> An error return from <b class="fname">select</b>() indicates:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">EBADF</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
One of the descriptor sets specified an invalid descriptor.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">EFAULT</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
One or more of <i class="farg">readfds</i>, <i class="farg">writefds</i>, or <i class="farg">exceptfds</i> points outside the process's allocated address space.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">EINTR</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
A signal was delivered before the time limit expired and before any of the selected events occurred.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">EINVAL</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
The specified time limit is invalid. One of its components is negative or too large.</dd>
</dl>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../2/accept">accept(2)</a>, <a class="link-man" href="../2/connect">connect(2)</a>, <a class="link-man" href="../2/gettimeofday">gettimeofday(2)</a>, <a class="link-man" href="../2/poll">poll(2)</a>, <a class="link-man" href="../2/read">read(2)</a>, <a class="link-man" href="../2/recv">recv(2)</a>, <a class="link-man" href="../2/send">send(2)</a>, <a class="link-man" href="../2/write">write(2)</a>, <a class="link-man" href="../3/getdtablesize">getdtablesize(3)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The <b class="fname">select</b>() function call appeared in <span class="unix">4.2BSD</span>.</div>
<div class="section">
<h1 id="x42554753">BUGS</h1> Although the provision of <a class="link-man" href="../3/getdtablesize">getdtablesize(3)</a> was intended to allow user programs to be written independent of the kernel limit on the number of open files, the dimension of a sufficiently large bit field for select remains a problem. The default bit size of <i class="ftype">fd_set</i> is based on the symbol <span class="define">FD_SETSIZE</span> (currently 256), but that is somewhat smaller than the current kernel limit to the number of open files. However, in order to accommodate programs which might potentially use a larger number of open files with select, it is possible to increase this size within a program by providing a larger definition of <span class="define">FD_SETSIZE</span> before the inclusion of <b class="includes">&lt;<a class="link-includes">sys/types.h</a>&gt;</b>. The kernel will cope, and the userland libraries provided with the system are also ready for large numbers of file descriptors.<p>
Note: <a class="link-man" href="../3/rpc">rpc(3)</a> library uses <i class="ftype">fd_set</i> with the default <span class="define">FD_SETSIZE</span> as part of its ABI. Therefore, programs that use <a class="link-man" href="../3/rpc">rpc(3)</a> routines cannot change <span class="define">FD_SETSIZE</span>.<p>
Alternatively, to be really safe, it is possible to allocate <i class="ftype">fd_set</i> bit-arrays dynamically. The idea is to permit a program to work properly even if it is <a class="link-man" href="../2/execve">execve(2)</a>'d with 4000 file descriptors pre-allocated. The following illustrates the technique which is used by userland libraries:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
	fd_set *fdsr; 
	int max = fd; 
 
	fdsr = (fd_set *)calloc(howmany(max+1, NFDBITS), 
	    sizeof(fd_mask)); 
	if (fdsr == NULL) { 
		... 
		return (-1); 
	} 
	FD_SET(fd, fdsr); 
	n = select(max+1, fdsr, NULL, NULL, &amp;tv); 
	... 
	free(fdsr);</pre>
<p>
<b class="fname">select</b>() should probably have been designed to return the time remaining from the original timeout, if any, by modifying the time value in place. Even though some systems stupidly act in this different way, it is unlikely this semantic will ever be commonly implemented, as the change causes massive source code compatibility problems. Furthermore, recent new standards have dictated the current behaviour. In general, due to the existence of those non-conforming systems, it is unwise to assume that the timeout value will be unmodified by the <b class="fname">select</b>() call, and the caller should reinitialize it on each invocation. Calculating the delta is easily done by calling <a class="link-man" href="../2/gettimeofday">gettimeofday(2)</a> before and after the call to <b class="fname">select</b>(), and using <b class="fname">timersub</b>() (as described in <a class="link-man" href="../2/getitimer">getitimer(2)</a>).<p>
Internally to the kernel, <b class="fname">select</b>() works poorly if multiple processes wait on the same file descriptor.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
November 28, 2013</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

