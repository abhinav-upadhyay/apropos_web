<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="/static/man_pages/netbsd/style.css" type="text/css" media="all">
<title>
RPC_CLNT_CALLS(3)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
RPC_CLNT_CALLS(3)</td>
<td class="head-vol" align="center">
Library Functions Manual</td>
<td class="head-rtitle" align="right">
RPC_CLNT_CALLS(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">rpc_clnt_calls</b>, <b class="name">clnt_call</b>, <b class="name">clnt_freeres</b>, <b class="name">clnt_geterr</b>, <b class="name">clnt_perrno</b>, <b class="name">clnt_perror</b>, <b class="name">clnt_sperrno</b>, <b class="name">clnt_sperror</b>, <b class="name">rpc_broadcast</b>, <b class="name">rpc_broadcast_exp</b>, <b class="name">rpc_call</b> &#8212; <span class="desc">library routines for client side calls</span></div>
<div class="section">
<h1 id="x4c494252415259">LIBRARY</h1> <span class="lib">Standard C Library (libc, &#45;lc)</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">rpc/rpc.h</a>&gt;</b><p>
<i class="ftype">enum clnt_stat</i><br>
<b class="fname">clnt_call</b>(<i class="farg" style="white-space:nowrap;">CLIENT *clnt</i>, <i class="farg" style="white-space:nowrap;">const rpcproc_t procnum</i>, <i class="farg" style="white-space:nowrap;">const xdrproc_t inproc</i>, <i class="farg" style="white-space:nowrap;">const char *in</i>, <i class="farg" style="white-space:nowrap;">const xdrproc_t outproc</i>, <i class="farg" style="white-space:nowrap;">caddr_t out</i>, <i class="farg" style="white-space:nowrap;">const struct timeval tout</i>);<p>
<i class="ftype">bool_t</i><br>
<b class="fname">clnt_freeres</b>(<i class="farg" style="white-space:nowrap;">CLIENT *clnt</i>, <i class="farg" style="white-space:nowrap;">const xdrproc_t outproc</i>, <i class="farg" style="white-space:nowrap;">caddr_t out</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">clnt_geterr</b>(<i class="farg" style="white-space:nowrap;">const CLIENT * clnt</i>, <i class="farg" style="white-space:nowrap;">struct rpc_err * errp</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">clnt_perrno</b>(<i class="farg" style="white-space:nowrap;">const enum clnt_stat stat</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">clnt_perror</b>(<i class="farg" style="white-space:nowrap;">const CLIENT * clnt</i>, <i class="farg" style="white-space:nowrap;">const char *s</i>);<p>
<i class="ftype">char *</i><br>
<b class="fname">clnt_sperrno</b>(<i class="farg" style="white-space:nowrap;">const enum clnt_stat stat</i>);<p>
<i class="ftype">char *</i><br>
<b class="fname">clnt_sperror</b>(<i class="farg" style="white-space:nowrap;">const CLIENT *clnt</i>, <i class="farg" style="white-space:nowrap;">const char * s</i>);<p>
<i class="ftype">enum clnt_stat</i><br>
<b class="fname">rpc_broadcast</b>(<i class="farg" style="white-space:nowrap;">const rpcprog_t prognum, const rpcvers_t versnum</i>, <i class="farg" style="white-space:nowrap;">const rpcproc_t procnum</i>, <i class="farg" style="white-space:nowrap;">const xdrproc_t inproc</i>, <i class="farg" style="white-space:nowrap;">const char *in</i>, <i class="farg" style="white-space:nowrap;">const xdrproc_t outproc</i>, <i class="farg" style="white-space:nowrap;">caddr_t out</i>, <i class="farg" style="white-space:nowrap;">const resultproc_t eachresult</i>, <i class="farg" style="white-space:nowrap;">const char *nettype</i>);<p>
<i class="ftype">enum clnt_stat</i><br>
<b class="fname">rpc_broadcast_exp</b>(<i class="farg" style="white-space:nowrap;">rpcprog_t prognum, const rpcvers_t versnum</i>, <i class="farg" style="white-space:nowrap;">const rpcproc_t procnum, const xdrproc_t xargs</i>, <i class="farg" style="white-space:nowrap;">caddr_t argsp, const xdrproc_t xresults</i>, <i class="farg" style="white-space:nowrap;">caddr_t resultsp</i>, <i class="farg" style="white-space:nowrap;">const int inittime</i>, <i class="farg" style="white-space:nowrap;">const int waittime</i>, <i class="farg" style="white-space:nowrap;">const resultproc_t eachresult</i>, <i class="farg" style="white-space:nowrap;">const char * nettype</i>);<p>
<i class="ftype">enum clnt_stat</i><br>
<b class="fname">rpc_call</b>(<i class="farg" style="white-space:nowrap;">const char *host, const rpcprog_t prognum</i>, <i class="farg" style="white-space:nowrap;">const rpcvers_t versnum</i>, <i class="farg" style="white-space:nowrap;">const rpcproc_t procnum, const xdrproc_t inproc</i>, <i class="farg" style="white-space:nowrap;">const char *in</i>, <i class="farg" style="white-space:nowrap;">const xdrproc_t outproc</i>, <i class="farg" style="white-space:nowrap;">char *out</i>, <i class="farg" style="white-space:nowrap;">const char *nettype</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> RPC library routines allow C language programs to make procedure calls on other machines across the network. First, the client calls a procedure to send a request to the server. Upon receipt of the request, the server calls a dispatch routine to perform the requested service, and then sends back a reply.<p>
The <b class="fname">clnt_call</b>(), <b class="fname">rpc_call</b>(), and <b class="fname">rpc_broadcast</b>() routines handle the client side of the procedure call. The remaining routines deal with error handling in the case of errors.<p>
Some of the routines take a <span class="define">CLIENT</span> handle as one of the parameters. A <span class="define">CLIENT</span> handle can be created by an RPC creation routine such as <b class="fname">clnt_create</b>() (see <a class="link-man" href="../3/rpc_clnt_create">rpc_clnt_create(3)</a>).<p>
These routines are safe for use in multithreaded applications. <span class="define">CLIENT</span> handles can be shared between threads, however in this implementation requests by different threads are serialized (that is, the first request will receive its results before the second request is sent).</div>
<div class="section">
<h1 id="x524f5554494e4553">ROUTINES</h1> See <a class="link-man" href="../3/rpc">rpc(3)</a> for the definition of the <span class="define">CLIENT</span> data structure.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">clnt_call</b>()</dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
A function macro that calls the remote procedure <i class="farg">procnum</i> associated with the client handle, <i class="farg">clnt</i>, which is obtained with an RPC client creation routine such as <b class="fname">clnt_create</b>() (see <a class="link-man" href="../3/rpc_clnt_create">rpc_clnt_create(3)</a>). The parameter <b class="fname">inproc</b>() is the XDR function used to encode the procedure's parameters, and <b class="fname">outproc</b>() is the XDR function used to decode the procedure's results; <b class="fname">in</b>() is the address of the procedure's argument(s), and <b class="fname">out</b>() is the address of where to place the result(s). <b class="fname">tout</b>() is the time allowed for results to be returned, which is overridden by a time-out set explicitly through <b class="fname">clnt_control</b>(), see <a class="link-man" href="../3/rpc_clnt_create">rpc_clnt_create(3)</a>. If the remote call succeeds, the status returned is <span class="define">RPC_SUCCESS</span>, otherwise an appropriate status is returned.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">clnt_freeres</b>()</dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
A function macro that frees any data allocated by the RPC/XDR system when it decoded the results of an RPC call. The parameter <i class="farg">out</i> is the address of the results, and <i class="farg">outproc</i> is the XDR routine describing the results. This routine returns 1 if the results were successfully freed, and 0 otherwise.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">clnt_geterr</b>()</dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
A function macro that copies the error structure out of the client handle to the structure at address <i class="farg">errp</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">clnt_perrno</b>()</dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
Print a message to standard error corresponding to the condition indicated by <i class="farg">stat</i>. A newline is appended. Normally used after a procedure call fails for a routine for which a client handle is not needed, for instance <b class="fname">rpc_call</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">clnt_perror</b>()</dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
Print a message to the standard error indicating why an RPC call failed; <i class="farg">clnt</i> is the handle used to do the call. The message is prepended with string <i class="farg">s</i> and a colon. A newline is appended. Normally used after a remote procedure call fails for a routine which requires a client handle, for instance <b class="fname">clnt_call</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">clnt_sperrno</b>()</dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
Take the same arguments as <b class="fname">clnt_perrno</b>(), but instead of sending a message to the standard error indicating why an RPC call failed, return a pointer to a string which contains the message. <b class="fname">clnt_sperrno</b>() is normally used instead of <b class="fname">clnt_perrno</b>() when the program does not have a standard error (as a program running as a server quite likely does not), or if the programmer does not want the message to be output with <b class="fname">printf</b>() (see <a class="link-man" href="../3/printf">printf(3)</a>), or if a message format different than that supported by <b class="fname">clnt_perrno</b>() is to be used. Note: unlike <b class="fname">clnt_sperror</b>() and <b class="fname">clnt_spcreaterror</b>() (see <a class="link-man" href="../3/rpc_clnt_create">rpc_clnt_create(3)</a>), <b class="fname">clnt_sperrno</b>() does not return pointer to static data so the result will not get overwritten on each call.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">clnt_sperror</b>()</dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
Like <b class="fname">clnt_perror</b>(), except that (like <b class="fname">clnt_sperrno</b>()) it returns a string instead of printing to standard error. However, <b class="fname">clnt_sperror</b>() does not append a newline at the end of the message. Warning: returns pointer to a buffer that is overwritten on each call.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">rpc_broadcast</b>()</dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
Like <b class="fname">rpc_call</b>(), except the call message is broadcast to all the connectionless transports specified by <i class="farg">nettype</i>. If <i class="farg">nettype</i> is <span class="define">NULL</span>, it defaults to &#8220;netpath&#8221;. Each time it receives a response, this routine calls <b class="fname">eachresult</b>(), whose form is: <i class="ftype">bool_t</i> <b class="fname">eachresult</b>(<i class="farg">caddr_t out</i>, <i class="farg">const struct netbuf * addr</i>, <i class="farg">const struct netconfig * netconf</i>) where <i class="farg">out</i> is the same as <i class="farg">out</i> passed to <b class="fname">rpc_broadcast</b>(), except that the remote procedure's output is decoded there; <i class="farg">addr</i> points to the address of the machine that sent the results, and <i class="farg">netconf</i> is the netconfig structure of the transport on which the remote server responded. If <b class="fname">eachresult</b>() returns 0, <b class="fname">rpc_broadcast</b>() waits for more replies; otherwise it returns with appropriate status. Warning: broadcast file descriptors are limited in size to the maximum transfer size of that transport. For Ethernet, this value is 1500 bytes. <b class="fname">rpc_broadcast</b>() uses <span class="define">AUTH_SYS</span> credentials by default (see <a class="link-man" href="../3/rpc_clnt_auth">rpc_clnt_auth(3)</a>).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">rpc_broadcast_exp</b>()</dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
Like <b class="fname">rpc_broadcast</b>(), except that the initial timeout, <i class="farg">inittime</i> and the maximum timeout, <i class="farg">waittime</i> are specified in milliseconds. <i class="farg">inittime</i> is the initial time that <b class="fname">rpc_broadcast_exp</b>() waits before resending the request. After the first resend, the re-transmission interval increases exponentially until it exceeds <i class="farg">waittime</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">rpc_call</b>()</dt>
<dd class="list-tag" style="margin-left: 5.00ex;">
Call the remote procedure associated with <i class="farg">prognum</i>, <i class="farg">versnum</i>, and <i class="farg">procnum</i> on the machine, <i class="farg">host</i>. The parameter <i class="farg">inproc</i> is used to encode the procedure's parameters, and <i class="farg">outproc</i> is used to decode the procedure's results; <i class="farg">in</i> is the address of the procedure's argument(s), and <i class="farg">out</i> is the address of where to place the result(s). <i class="farg">nettype</i> can be any of the values listed on <a class="link-man" href="../3/rpc">rpc(3)</a>. This routine returns <span class="define">RPC_SUCCESS</span> if it succeeds, or an appropriate status is returned. Use the <b class="fname">clnt_perrno</b>() routine to translate failure status into error messages. Warning: <b class="fname">rpc_call</b>() uses the first available transport belonging to the class <i class="farg">nettype</i>, on which it can create a connection. You do not have control of timeouts or authentication using this routine.</dd>
</dl>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../3/printf">printf(3)</a>, <a class="link-man" href="../3/rpc">rpc(3)</a>, <a class="link-man" href="../3/rpc_clnt_auth">rpc_clnt_auth(3)</a>, <a class="link-man" href="../3/rpc_clnt_create">rpc_clnt_create(3)</a></div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
December 4, 2005</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

