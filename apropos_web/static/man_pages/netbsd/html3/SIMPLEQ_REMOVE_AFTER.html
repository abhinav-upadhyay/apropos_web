<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="/static/man_pages/netbsd/style.css" type="text/css" media="all">
<title>
QUEUE(3)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
QUEUE(3)</td>
<td class="head-vol" align="center">
Library Functions Manual</td>
<td class="head-rtitle" align="right">
QUEUE(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">SLIST_HEAD</b>, <b class="name">SLIST_HEAD_INITIALIZER</b>, <b class="name">SLIST_ENTRY</b>, <b class="name">SLIST_FIRST</b>, <b class="name">SLIST_EMPTY</b>, <b class="name">SLIST_NEXT</b>, <b class="name">SLIST_FOREACH</b>, <b class="name">SLIST_FOREACH_SAFE</b>, <b class="name">SLIST_INIT</b>, <b class="name">SLIST_INSERT_AFTER</b>, <b class="name">SLIST_INSERT_HEAD</b>, <b class="name">SLIST_REMOVE_AFTER</b>, <b class="name">SLIST_REMOVE_HEAD</b>, <b class="name">SLIST_REMOVE</b>, <b class="name">LIST_HEAD</b>, <b class="name">LIST_HEAD_INITIALIZER</b>, <b class="name">LIST_ENTRY</b>, <b class="name">LIST_FIRST</b>, <b class="name">LIST_EMPTY</b>, <b class="name">LIST_NEXT</b>, <b class="name">LIST_FOREACH</b>, <b class="name">LIST_FOREACH_SAFE</b>, <b class="name">LIST_INIT</b>, <b class="name">LIST_INSERT_AFTER</b>, <b class="name">LIST_INSERT_BEFORE</b>, <b class="name">LIST_INSERT_HEAD</b>, <b class="name">LIST_REMOVE</b>, <b class="name">LIST_REPLACE</b>, <b class="name">LIST_MOVE</b>, <b class="name">SIMPLEQ_HEAD</b>, <b class="name">SIMPLEQ_HEAD_INITIALIZER</b>, <b class="name">SIMPLEQ_ENTRY</b>, <b class="name">SIMPLEQ_FIRST</b>, <b class="name">SIMPLEQ_EMPTY</b>, <b class="name">SIMPLEQ_NEXT</b>, <b class="name">SIMPLEQ_LAST</b>, <b class="name">SIMPLEQ_FOREACH</b>, <b class="name">SIMPLEQ_FOREACH_SAFE</b>, <b class="name">SIMPLEQ_INIT</b>, <b class="name">SIMPLEQ_INSERT_AFTER</b>, <b class="name">SIMPLEQ_INSERT_HEAD</b>, <b class="name">SIMPLEQ_INSERT_TAIL</b>, <b class="name">SIMPLEQ_REMOVE_AFTER</b>, <b class="name">SIMPLEQ_REMOVE_HEAD</b>, <b class="name">SIMPLEQ_REMOVE</b>, <b class="name">SIMPLEQ_CONCAT</b>, <b class="name">TAILQ_HEAD</b>, <b class="name">TAILQ_HEAD_INITIALIZER</b>, <b class="name">TAILQ_ENTRY</b>, <b class="name">TAILQ_FIRST</b>, <b class="name">TAILQ_NEXT</b>, <b class="name">TAILQ_LAST</b>, <b class="name">TAILQ_PREV</b>, <b class="name">TAILQ_EMPTY</b>, <b class="name">TAILQ_FOREACH</b>, <b class="name">TAILQ_FOREACH_SAFE</b>, <b class="name">TAILQ_FOREACH_REVERSE</b>, <b class="name">TAILQ_FOREACH_REVERSE_SAFE</b>, <b class="name">TAILQ_INIT</b>, <b class="name">TAILQ_INSERT_AFTER</b>, <b class="name">TAILQ_INSERT_BEFORE</b>, <b class="name">TAILQ_INSERT_HEAD</b>, <b class="name">TAILQ_INSERT_TAIL</b>, <b class="name">TAILQ_REMOVE</b>, <b class="name">TAILQ_REPLACE</b>, <b class="name">TAILQ_CONCAT</b>, <b class="name">STAILQ_HEAD</b>, <b class="name">STAILQ_HEAD_INITIALIZER</b>, <b class="name">STAILQ_ENTRY</b>, <b class="name">STAILQ_FIRST</b>, <b class="name">STAILQ_EMPTY</b>, <b class="name">STAILQ_NEXT</b>, <b class="name">STAILQ_LAST</b>, <b class="name">STAILQ_FOREACH</b>, <b class="name">STAILQ_FOREACH_SAFE</b>, <b class="name">STAILQ_INIT</b>, <b class="name">STAILQ_INSERT_AFTER</b>, <b class="name">STAILQ_INSERT_HEAD</b>, <b class="name">STAILQ_INSERT_TAIL</b>, <b class="name">STAILQ_REMOVE_HEAD</b>, <b class="name">STAILQ_REMOVE</b>, <b class="name">STAILQ_CONCAT</b>, &#8212; <span class="desc">implementations of singly-linked lists, lists, simple queues, tail queues, and singly-linked tail queues</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/queue.h</a>&gt;</b><p>
<br>
<b class="fname">SLIST_HEAD</b>(<i class="farg" style="white-space:nowrap;">HEADNAME</i>, <i class="farg" style="white-space:nowrap;">TYPE</i>);<p>
<b class="fname">SLIST_HEAD_INITIALIZER</b>(<i class="farg" style="white-space:nowrap;">head</i>);<p>
<b class="fname">SLIST_ENTRY</b>(<i class="farg" style="white-space:nowrap;">TYPE</i>);<p>
<i class="ftype">TYPE *</i><br>
<b class="fname">SLIST_FIRST</b>(<i class="farg" style="white-space:nowrap;">SLIST_HEAD *head</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">SLIST_EMPTY</b>(<i class="farg" style="white-space:nowrap;">SLIST_HEAD *head</i>);<p>
<i class="ftype">TYPE *</i><br>
<b class="fname">SLIST_NEXT</b>(<i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">SLIST_ENTRY NAME</i>);<p>
<b class="fname">SLIST_FOREACH</b>(<i class="farg" style="white-space:nowrap;">TYPE *var</i>, <i class="farg" style="white-space:nowrap;">SLIST_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">SLIST_ENTRY NAME</i>);<p>
<b class="fname">SLIST_FOREACH_SAFE</b>(<i class="farg" style="white-space:nowrap;">TYPE *var</i>, <i class="farg" style="white-space:nowrap;">SLIST_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">SLIST_ENTRY NAME</i>, <i class="farg" style="white-space:nowrap;">TYPE *tmp</i>);<p>
<b class="fname">SLIST_INIT</b>(<i class="farg" style="white-space:nowrap;">SLIST_HEAD *head</i>);<p>
<b class="fname">SLIST_INSERT_HEAD</b>(<i class="farg" style="white-space:nowrap;">SLIST_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">SLIST_ENTRY NAME</i>);<p>
<b class="fname">SLIST_INSERT_AFTER</b>(<i class="farg" style="white-space:nowrap;">TYPE *listelm</i>, <i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">SLIST_ENTRY NAME</i>);<p>
<b class="fname">SLIST_REMOVE</b>(<i class="farg" style="white-space:nowrap;">SLIST_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">TYPE</i>, <i class="farg" style="white-space:nowrap;">SLIST_ENTRY NAME</i>);<p>
<b class="fname">SLIST_REMOVE_HEAD</b>(<i class="farg" style="white-space:nowrap;">SLIST_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">SLIST_ENTRY NAME</i>);<p>
<br>
<b class="fname">LIST_HEAD</b>(<i class="farg" style="white-space:nowrap;">HEADNAME</i>, <i class="farg" style="white-space:nowrap;">TYPE</i>);<p>
<b class="fname">LIST_HEAD_INITIALIZER</b>(<i class="farg" style="white-space:nowrap;">head</i>);<p>
<b class="fname">LIST_ENTRY</b>(<i class="farg" style="white-space:nowrap;">TYPE</i>);<p>
<i class="ftype">TYPE *</i><br>
<b class="fname">LIST_FIRST</b>(<i class="farg" style="white-space:nowrap;">LIST_HEAD *head</i>);<p>
<i class="ftype">TYPE *</i><br>
<b class="fname">LIST_NEXT</b>(<i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">LIST_ENTRY NAME</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">LIST_EMPTY</b>(<i class="farg" style="white-space:nowrap;">LIST_HEAD *head</i>);<p>
<b class="fname">LIST_FOREACH</b>(<i class="farg" style="white-space:nowrap;">TYPE *var</i>, <i class="farg" style="white-space:nowrap;">LIST_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">LIST_ENTRY NAME</i>);<p>
<b class="fname">LIST_FOREACH_SAFE</b>(<i class="farg" style="white-space:nowrap;">TYPE *var</i>, <i class="farg" style="white-space:nowrap;">LIST_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">LIST_ENTRY NAME</i>, <i class="farg" style="white-space:nowrap;">TYPE *tmp</i>);<p>
<b class="fname">LIST_INIT</b>(<i class="farg" style="white-space:nowrap;">LIST_HEAD *head</i>);<p>
<b class="fname">LIST_INSERT_AFTER</b>(<i class="farg" style="white-space:nowrap;">TYPE *listelm</i>, <i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">LIST_ENTRY NAME</i>);<p>
<b class="fname">LIST_INSERT_BEFORE</b>(<i class="farg" style="white-space:nowrap;">TYPE *listelm</i>, <i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">LIST_ENTRY NAME</i>);<p>
<b class="fname">LIST_INSERT_HEAD</b>(<i class="farg" style="white-space:nowrap;">LIST_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">LIST_ENTRY NAME</i>);<p>
<b class="fname">LIST_REMOVE</b>(<i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">LIST_ENTRY NAME</i>);<p>
<b class="fname">LIST_REPLACE</b>(<i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">TYPE *new</i>, <i class="farg" style="white-space:nowrap;">LIST_ENTRY NAME</i>);<p>
<b class="fname">LIST_MOVE</b>(<i class="farg" style="white-space:nowrap;">LIST_HEAD *head1</i>, <i class="farg" style="white-space:nowrap;">LIST_HEAD *head2</i>);<p>
<br>
<b class="fname">SIMPLEQ_HEAD</b>(<i class="farg" style="white-space:nowrap;">HEADNAME</i>, <i class="farg" style="white-space:nowrap;">TYPE</i>);<p>
<b class="fname">SIMPLEQ_HEAD_INITIALIZER</b>(<i class="farg" style="white-space:nowrap;">head</i>);<p>
<b class="fname">SIMPLEQ_ENTRY</b>(<i class="farg" style="white-space:nowrap;">TYPE</i>);<p>
<i class="ftype">TYPE *</i><br>
<b class="fname">SIMPLEQ_FIRST</b>(<i class="farg" style="white-space:nowrap;">SIMPLEQ_HEAD *head</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">SIMPLEQ_EMPTY</b>(<i class="farg" style="white-space:nowrap;">SIMPLEQ_HEAD *head</i>);<p>
<i class="ftype">TYPE *</i><br>
<b class="fname">SIMPLEQ_NEXT</b>(<i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">SIMPLEQ_ENTRY NAME</i>);<p>
<i class="ftype">TYPE *</i><br>
<b class="fname">SIMPLEQ_LAST</b>(<i class="farg" style="white-space:nowrap;">SIMPLEQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">SIMPLEQ_ENTRY NAME</i>);<p>
<b class="fname">SIMPLEQ_FOREACH</b>(<i class="farg" style="white-space:nowrap;">TYPE *var</i>, <i class="farg" style="white-space:nowrap;">SIMPLEQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">SIMPLEQ_ENTRY NAME</i>);<p>
<b class="fname">SIMPLEQ_FOREACH_SAFE</b>(<i class="farg" style="white-space:nowrap;">TYPE *var</i>, <i class="farg" style="white-space:nowrap;">SIMPLEQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">SIMPLEQ_ENTRY NAME</i>, <i class="farg" style="white-space:nowrap;">TYPE *tmp</i>);<p>
<b class="fname">SIMPLEQ_INIT</b>(<i class="farg" style="white-space:nowrap;">SIMPLEQ_HEAD *head</i>);<p>
<b class="fname">SIMPLEQ_INSERT_HEAD</b>(<i class="farg" style="white-space:nowrap;">SIMPLEQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">SIMPLEQ_ENTRY NAME</i>);<p>
<b class="fname">SIMPLEQ_INSERT_TAIL</b>(<i class="farg" style="white-space:nowrap;">SIMPLEQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">SIMPLEQ_ENTRY NAME</i>);<p>
<b class="fname">SIMPLEQ_INSERT_AFTER</b>(<i class="farg" style="white-space:nowrap;">SIMPLEQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">TYPE *listelm</i>, <i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">SIMPLEQ_ENTRY NAME</i>);<p>
<b class="fname">SIMPLEQ_REMOVE_HEAD</b>(<i class="farg" style="white-space:nowrap;">SIMPLEQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">SIMPLEQ_ENTRY NAME</i>);<p>
<b class="fname">SIMPLEQ_REMOVE_AFTER</b>(<i class="farg" style="white-space:nowrap;">SIMPLEQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">SIMPLEQ_ENTRY NAME</i>);<p>
<b class="fname">SIMPLEQ_REMOVE</b>(<i class="farg" style="white-space:nowrap;">SIMPLEQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">TYPE</i>, <i class="farg" style="white-space:nowrap;">SIMPLEQ_ENTRY NAME</i>);<p>
<b class="fname">SIMPLEQ_CONCAT</b>(<i class="farg" style="white-space:nowrap;">SIMPLEQ_HEAD *head1</i>, <i class="farg" style="white-space:nowrap;">SIMPLEQ_HEAD *head2</i>);<p>
<br>
<b class="fname">TAILQ_HEAD</b>(<i class="farg" style="white-space:nowrap;">HEADNAME</i>, <i class="farg" style="white-space:nowrap;">TYPE</i>);<p>
<b class="fname">TAILQ_HEAD_INITIALIZER</b>(<i class="farg" style="white-space:nowrap;">head</i>);<p>
<b class="fname">TAILQ_ENTRY</b>(<i class="farg" style="white-space:nowrap;">TYPE</i>);<p>
<i class="ftype">TYPE *</i><br>
<b class="fname">TAILQ_FIRST</b>(<i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head</i>);<p>
<i class="ftype">TYPE *</i><br>
<b class="fname">TAILQ_NEXT</b>(<i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">TAILQ_ENTRY NAME</i>);<p>
<i class="ftype">TYPE *</i><br>
<b class="fname">TAILQ_LAST</b>(<i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">HEADNAME</i>);<p>
<i class="ftype">TYPE *</i><br>
<b class="fname">TAILQ_PREV</b>(<i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">HEADNAME</i>, <i class="farg" style="white-space:nowrap;">TAILQ_ENTRY NAME</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">TAILQ_EMPTY</b>(<i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head</i>);<p>
<b class="fname">TAILQ_FOREACH</b>(<i class="farg" style="white-space:nowrap;">TYPE *var</i>, <i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">TAILQ_ENTRY NAME</i>);<p>
<b class="fname">TAILQ_FOREACH_SAFE</b>(<i class="farg" style="white-space:nowrap;">TYPE *var</i>, <i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">TAILQ_ENTRY NAME</i>, <i class="farg" style="white-space:nowrap;">TYPE *tmp</i>);<p>
<b class="fname">TAILQ_FOREACH_REVERSE</b>(<i class="farg" style="white-space:nowrap;">TYPE *var</i>, <i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">HEADNAME</i>, <i class="farg" style="white-space:nowrap;">TAILQ_ENTRY NAME</i>);<p>
<b class="fname">TAILQ_FOREACH_REVERSE_SAFE</b>(<i class="farg" style="white-space:nowrap;">TYPE *var</i>, <i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">HEADNAME</i>, <i class="farg" style="white-space:nowrap;">TAILQ_ENTRY NAME</i>, <i class="farg" style="white-space:nowrap;">TYPE *tmp</i>);<p>
<b class="fname">TAILQ_INIT</b>(<i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head</i>);<p>
<b class="fname">TAILQ_INSERT_HEAD</b>(<i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">TAILQ_ENTRY NAME</i>);<p>
<b class="fname">TAILQ_INSERT_TAIL</b>(<i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">TAILQ_ENTRY NAME</i>);<p>
<b class="fname">TAILQ_INSERT_AFTER</b>(<i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">TYPE *listelm</i>, <i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">TAILQ_ENTRY NAME</i>);<p>
<b class="fname">TAILQ_INSERT_BEFORE</b>(<i class="farg" style="white-space:nowrap;">TYPE *listelm</i>, <i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">TAILQ_ENTRY NAME</i>);<p>
<b class="fname">TAILQ_REMOVE</b>(<i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">TAILQ_ENTRY NAME</i>);<p>
<b class="fname">TAILQ_REPLACE</b>(<i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">TYPE *new</i>, <i class="farg" style="white-space:nowrap;">TAILQ_ENTRY NAME</i>);<p>
<b class="fname">TAILQ_CONCAT</b>(<i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head1</i>, <i class="farg" style="white-space:nowrap;">TAILQ_HEAD *head2</i>, <i class="farg" style="white-space:nowrap;">TAILQ_ENTRY NAME</i>);<p>
<br>
<b class="fname">STAILQ_HEAD</b>(<i class="farg" style="white-space:nowrap;">HEADNAME</i>, <i class="farg" style="white-space:nowrap;">TYPE</i>);<p>
<b class="fname">STAILQ_HEAD_INITIALIZER</b>(<i class="farg" style="white-space:nowrap;">head</i>);<p>
<b class="fname">STAILQ_ENTRY</b>(<i class="farg" style="white-space:nowrap;">TYPE</i>);<p>
<i class="ftype">TYPE *</i><br>
<b class="fname">STAILQ_FIRST</b>(<i class="farg" style="white-space:nowrap;">STAILQ_HEAD *head</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">STAILQ_EMPTY</b>(<i class="farg" style="white-space:nowrap;">STAILQ_HEAD *head</i>);<p>
<i class="ftype">TYPE *</i><br>
<b class="fname">STAILQ_NEXT</b>(<i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">STAILQ_ENTRY NAME</i>);<p>
<i class="ftype">TYPE *</i><br>
<b class="fname">STAILQ_LAST</b>(<i class="farg" style="white-space:nowrap;">STAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">STAILQ_ENTRY NAME</i>);<p>
<b class="fname">STAILQ_FOREACH</b>(<i class="farg" style="white-space:nowrap;">TYPE *var</i>, <i class="farg" style="white-space:nowrap;">STAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">STAILQ_ENTRY NAME</i>);<p>
<b class="fname">STAILQ_FOREACH_SAFE</b>(<i class="farg" style="white-space:nowrap;">TYPE *var</i>, <i class="farg" style="white-space:nowrap;">STAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">STAILQ_ENTRY NAME</i>, <i class="farg" style="white-space:nowrap;">TYPE *tmp</i>);<p>
<b class="fname">STAILQ_INIT</b>(<i class="farg" style="white-space:nowrap;">STAILQ_HEAD *head</i>);<p>
<b class="fname">STAILQ_INSERT_HEAD</b>(<i class="farg" style="white-space:nowrap;">STAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">STAILQ_ENTRY NAME</i>);<p>
<b class="fname">STAILQ_INSERT_TAIL</b>(<i class="farg" style="white-space:nowrap;">STAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">STAILQ_ENTRY NAME</i>);<p>
<b class="fname">STAILQ_INSERT_AFTER</b>(<i class="farg" style="white-space:nowrap;">STAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">TYPE *listelm</i>, <i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">STAILQ_ENTRY NAME</i>);<p>
<b class="fname">STAILQ_REMOVE_HEAD</b>(<i class="farg" style="white-space:nowrap;">STAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">STAILQ_ENTRY NAME</i>);<p>
<b class="fname">STAILQ_REMOVE</b>(<i class="farg" style="white-space:nowrap;">STAILQ_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">TYPE</i>, <i class="farg" style="white-space:nowrap;">STAILQ_ENTRY NAME</i>);<p>
<b class="fname">STAILQ_CONCAT</b>(<i class="farg" style="white-space:nowrap;">STAILQ_HEAD *head1</i>, <i class="farg" style="white-space:nowrap;">STAILQ_HEAD *head2</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> These macros define and operate on five types of data structures: singly-linked lists, simple queues, lists, tail queues, and singly-linked tail queues. All five structures support the following functionality:<ol style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-enum">
<li class="list-enum" style="margin-top: 0.00em;">
Insertion of a new entry at the head of the list.</li>
<li class="list-enum" style="margin-top: 0.00em;">
Insertion of a new entry before or after any element in the list.</li>
<li class="list-enum" style="margin-top: 0.00em;">
Removal of any entry in the list.</li>
<li class="list-enum" style="margin-top: 0.00em;">
Forward traversal through the list.</li>
</ol>
<p>
Singly-linked lists are the simplest of the four data structures and support only the above functionality. Singly-linked lists are ideal for applications with large datasets and few or no removals, or for implementing a LIFO queue.<p>
Simple queues add the following functionality:<ol style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-enum">
<li class="list-enum" style="margin-top: 0.00em;">
Entries can be added at the end of a list.</li>
<li class="list-enum" style="margin-top: 0.00em;">
They may be concatenated.</li>
</ol>
However:<ol style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-enum">
<li class="list-enum" style="margin-top: 0.00em;">
Entries may not be added before any element in the list.</li>
<li class="list-enum" style="margin-top: 0.00em;">
All list insertions and removals must specify the head of the list.</li>
<li class="list-enum" style="margin-top: 0.00em;">
Each head entry requires two pointers rather than one.</li>
</ol>
<p>
Simple queues are ideal for applications with large datasets and few or no removals, or for implementing a FIFO queue.<p>
All doubly linked types of data structures (lists and tail queues) additionally allow:<ol style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-enum">
<li class="list-enum" style="margin-top: 0.00em;">
Insertion of a new entry before any element in the list.</li>
<li class="list-enum" style="margin-top: 0.00em;">
O(1) removal of any entry in the list.</li>
</ol>
However:<ol style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-enum">
<li class="list-enum" style="margin-top: 0.00em;">
Each element requires two pointers rather than one.</li>
<li class="list-enum" style="margin-top: 0.00em;">
Code size and execution time of operations (except for removal) is about twice that of the singly-linked data-structures.</li>
</ol>
<p>
Linked lists are the simplest of the doubly linked data structures and support only the above functionality over singly-linked lists.<p>
Tail queues add the following functionality:<ol style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-enum">
<li class="list-enum" style="margin-top: 0.00em;">
Entries can be added at the end of a list.</li>
<li class="list-enum" style="margin-top: 0.00em;">
They may be concatenated.</li>
</ol>
However:<ol style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-enum">
<li class="list-enum" style="margin-top: 0.00em;">
All list insertions and removals, except insertion before another element, must specify the head of the list.</li>
<li class="list-enum" style="margin-top: 0.00em;">
Each head entry requires two pointers rather than one.</li>
<li class="list-enum" style="margin-top: 0.00em;">
Code size is about 15% greater and operations run about 20% slower than lists.</li>
</ol>
<p>
Circular queues add the following functionality:<ol style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-enum">
<li class="list-enum" style="margin-top: 0.00em;">
Entries can be added at the end of a list.</li>
<li class="list-enum" style="margin-top: 0.00em;">
They may be traversed backwards, from tail to head.</li>
</ol>
However:<ol style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-enum">
<li class="list-enum" style="margin-top: 0.00em;">
All list insertions and removals must specify the head of the list.</li>
<li class="list-enum" style="margin-top: 0.00em;">
Each head entry requires two pointers rather than one.</li>
<li class="list-enum" style="margin-top: 0.00em;">
The termination condition for traversal is more complex.</li>
<li class="list-enum" style="margin-top: 0.00em;">
Code size is about 40% greater and operations run about 45% slower than lists.</li>
</ol>
<p>
In the macro definitions, <i class="farg">TYPE</i> is the name of a user defined structure, that must contain a field of type <code class="lit">SLIST_ENTRY</code>, <code class="lit">LIST_ENTRY</code>, <code class="lit">SIMPLEQ_ENTRY</code>, <code class="lit">TAILQ_ENTRY</code>, or <code class="lit">STAILQ_ENTRY</code>, named <i class="farg">NAME</i>. The argument <i class="farg">HEADNAME</i> is the name of a user defined structure that must be declared using the macros <code class="lit">LIST_HEAD</code>, <code class="lit">SIMPLEQ_HEAD</code>, <code class="lit">SLIST_HEAD</code>, or <code class="lit">TAILQ_HEAD</code>. See the examples below for further explanation of how these macros are used.<div class="subsection">
<h2 id="x53756d6d617279206f66204f7065726174696f6e73">Summary of Operations</h2> The following table summarizes the supported macros for each type of data structure.<p>
<table class="tbl">
<col style="width: 21.00ex;">
<col style="width: 5.00ex;">
<col style="width: 4.00ex;">
<col style="width: 7.00ex;">
<col style="width: 5.00ex;">
<col style="width: 6.00ex;">
<tbody>
<tr>
<td>
</td>
<td>
SLIST</td>
<td>
LIST</td>
<td>
SIMPLEQ</td>
<td>
TAILQ</td>
<td>
STAILQ</td>
</tr>
<tr>
<td colspan="0">
</td>
</tr>
<tr>
<td>
_FIRST</td>
<td>
+</td>
<td>
+</td>
<td>
+</td>
<td>
+</td>
<td>
+</td>
</tr>
<tr>
<td>
_EMPTY</td>
<td>
+</td>
<td>
+</td>
<td>
+</td>
<td>
+</td>
<td>
+</td>
</tr>
<tr>
<td>
_NEXT</td>
<td>
+</td>
<td>
+</td>
<td>
+</td>
<td>
+</td>
<td>
+</td>
</tr>
<tr>
<td>
_PREV</td>
<td>
-</td>
<td>
-</td>
<td>
-</td>
<td>
+</td>
<td>
-</td>
</tr>
<tr>
<td>
_LAST</td>
<td>
-</td>
<td>
-</td>
<td>
+</td>
<td>
+</td>
<td>
+</td>
</tr>
<tr>
<td>
_FOREACH</td>
<td>
+</td>
<td>
+</td>
<td>
+</td>
<td>
+</td>
<td>
+</td>
</tr>
<tr>
<td>
_FOREACH_SAFE</td>
<td>
+</td>
<td>
+</td>
<td>
+</td>
<td>
+</td>
<td>
+</td>
</tr>
<tr>
<td>
_FOREACH_REVERSE</td>
<td>
-</td>
<td>
-</td>
<td>
-</td>
<td>
+</td>
<td>
-</td>
</tr>
<tr>
<td>
_FOREACH_REVERSE_SAFE</td>
<td>
-</td>
<td>
-</td>
<td>
-</td>
<td>
+</td>
<td>
-</td>
</tr>
<tr>
<td>
_INSERT_HEAD</td>
<td>
+</td>
<td>
+</td>
<td>
+</td>
<td>
+</td>
<td>
+</td>
</tr>
<tr>
<td>
_INSERT_AFTER</td>
<td>
+</td>
<td>
+</td>
<td>
+</td>
<td>
+</td>
<td>
+</td>
</tr>
<tr>
<td>
_INSERT_BEFORE</td>
<td>
-</td>
<td>
+</td>
<td>
-</td>
<td>
+</td>
<td>
-</td>
</tr>
<tr>
<td>
_INSERT_TAIL</td>
<td>
-</td>
<td>
-</td>
<td>
+</td>
<td>
+</td>
<td>
+</td>
</tr>
<tr>
<td>
_REMOVE</td>
<td>
+</td>
<td>
+</td>
<td>
+</td>
<td>
+</td>
<td>
+</td>
</tr>
<tr>
<td>
_REMOVE_HEAD</td>
<td>
+</td>
<td>
-</td>
<td>
+</td>
<td>
-</td>
<td>
+</td>
</tr>
<tr>
<td>
_REMOVE_AFTER</td>
<td>
-</td>
<td>
-</td>
<td>
+</td>
<td>
-</td>
<td>
+</td>
</tr>
<tr>
<td>
_REPLACE</td>
<td>
-</td>
<td>
+</td>
<td>
-</td>
<td>
+</td>
<td>
-</td>
</tr>
<tr>
<td>
_CONCAT</td>
<td>
-</td>
<td>
-</td>
<td>
+</td>
<td>
+</td>
<td>
+</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section">
<h1 id="x53494e474c591e4c494e4b4544204c49535453">SINGLY-LINKED LISTS</h1> A singly-linked list is headed by a structure defined by the <b class="name">SLIST_HEAD</b> macro. This structure contains a single pointer to the first element on the list. The elements are singly linked for minimum space and pointer manipulation overhead at the expense of O(n) removal for arbitrary elements. New elements can be added to the list after an existing element or at the head of the list. An <i class="farg">SLIST_HEAD</i> structure is declared as follows:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
SLIST_HEAD(HEADNAME, TYPE) head;</pre>
<p>
where <i class="farg">HEADNAME</i> is the name of the structure to be defined, and <i class="farg">TYPE</i> is the type of the elements to be linked into the list. A pointer to the head of the list can later be declared as:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
struct HEADNAME *headp;</pre>
<p>
(The names <code class="lit">head</code> and <code class="lit">headp</code> are user selectable.)<p>
The macro <b class="name">SLIST_HEAD_INITIALIZER</b> evaluates to an initializer for the list <i class="farg">head</i>.<p>
The macro <b class="name">SLIST_ENTRY</b> declares a structure that connects the elements in the list.<p>
The macro <b class="name">SLIST_FIRST</b> returns the first element in the list or NULL if the list is empty.<p>
The macro <b class="name">SLIST_EMPTY</b> evaluates to true if there are no elements in the list.<p>
The macro <b class="name">SLIST_NEXT</b> returns the next element in the list.<p>
<b class="name">SLIST_FOREACH</b> traverses the list referenced by <i class="farg">head</i> in the forward direction, assigning each element in turn to <i class="farg">var</i>.<p>
The SAFE version uses <i class="farg">tmp</i> to hold the next element, so <i class="farg">var</i> may be freed or removed from the list.<p>
The macro <b class="name">SLIST_INIT</b> initializes the list referenced by <i class="farg">head</i>.<p>
The macro <b class="name">SLIST_INSERT_HEAD</b> inserts the new element <i class="farg">elm</i> at the head of the list.<p>
The macro <b class="name">SLIST_INSERT_AFTER</b> inserts the new element <i class="farg">elm</i> after the element <i class="farg">listelm</i>.<p>
The macro <b class="name">SLIST_REMOVE</b> removes the element <i class="farg">elm</i> from the list.<p>
The macro <b class="name">SLIST_REMOVE_HEAD</b> removes the first element from the head of the list. For optimum efficiency, elements being removed from the head of the list should explicitly use this macro instead of the generic <b class="name">SLIST_REMOVE</b> macro.<p>
The macro <b class="name">SLIST_REMOVE_AFTER</b> removes the element after the one specified. For optimum efficiency, elements being removed after a specified one should explicitly use this macro instead of the generic <b class="name">SLIST_REMOVE</b></div>
<div class="section">
<h1 id="x53494e474c591e4c494e4b4544204c495354204558414d504c45">SINGLY-LINKED LIST EXAMPLE</h1><pre style="margin-left: 0.00ex;" class="lit display">
SLIST_HEAD(slisthead, entry) head = 
    SLIST_HEAD_INITIALIZER(head); 
struct slisthead *headp;                /* Singly-linked List head. */ 
struct entry { 
        ... 
        SLIST_ENTRY(entry) entries;     /* Singly-linked List. */ 
        ... 
} *n1, *n2, *n3, *np; 
 
SLIST_INIT(&amp;head);                      /* Initialize the list. */ 
 
n1 = malloc(sizeof(struct entry));      /* Insert at the head. */ 
SLIST_INSERT_HEAD(&amp;head, n1, entries); 
 
n2 = malloc(sizeof(struct entry));      /* Insert after. */ 
SLIST_INSERT_AFTER(n1, n2, entries); 
 
SLIST_REMOVE(&amp;head, n2, entry, entries);/* Deletion. */ 
free(n2); 
 
n3 = SLIST_FIRST(&amp;head); 
SLIST_REMOVE_HEAD(&amp;head, entries);      /* Deletion from the head. */ 
free(n3); 
                                        /* Forward traversal. */ 
SLIST_FOREACH(np, &amp;head, entries) 
        np-&gt; ... 
 
while (!SLIST_EMPTY(&amp;head)) {           /* List Deletion. */ 
        n1 = SLIST_FIRST(&amp;head); 
        SLIST_REMOVE_HEAD(&amp;head, entries); 
        free(n1); 
}</pre>
</div>
<div class="section">
<h1 id="x4c49535453">LISTS</h1> A list is headed by a structure defined by the <b class="name">LIST_HEAD</b> macro. This structure contains a single pointer to the first element on the list. The elements are doubly linked so that an arbitrary element can be removed without traversing the list. New elements can be added to the list after an existing element, before an existing element, or at the head of the list. A <i class="farg">LIST_HEAD</i> structure is declared as follows:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
LIST_HEAD(HEADNAME, TYPE) head;</pre>
<p>
where <i class="farg">HEADNAME</i> is the name of the structure to be defined, and <i class="farg">TYPE</i> is the type of the elements to be linked into the list. A pointer to the head of the list can later be declared as:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
struct HEADNAME *headp;</pre>
<p>
(The names <code class="lit">head</code> and <code class="lit">headp</code> are user selectable.)<p>
The macro <b class="name">LIST_ENTRY</b> declares a structure that connects the elements in the list.<p>
The macro <b class="name">LIST_HEAD_INITIALIZER</b> provides a value which can be used to initialize a list head at compile time, and is used at the point that the list head variable is declared, like:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
struct HEADNAME head = LIST_HEAD_INITIALIZER(head);</pre>
<p>
The macro <b class="name">LIST_FIRST</b> returns the first element of the list <i class="farg">head</i>.<p>
The macro <b class="name">LIST_EMPTY</b> returns true if the list <i class="farg">head</i> has no elements.<p>
The macro <b class="name">LIST_NEXT</b> returns the element after the element <i class="farg">elm</i>.<p>
The macro <b class="name">LIST_FOREACH</b> traverses the list referenced by <i class="farg">head</i> in the forward direction, assigning each element in turn to <i class="farg">var</i>.<p>
The SAFE version uses <i class="farg">tmp</i> to hold the next element, so <i class="farg">var</i> may be freed or removed from the list.<p>
The macro <b class="name">LIST_INIT</b> initializes the list referenced by <i class="farg">head</i>.<p>
The macro <b class="name">LIST_INSERT_AFTER</b> inserts the new element <i class="farg">elm</i> after the element <i class="farg">listelm</i>.<p>
The macro <b class="name">LIST_INSERT_BEFORE</b> inserts the new element <i class="farg">elm</i> before the element <i class="farg">listelm</i>.<p>
The macro <b class="name">LIST_INSERT_HEAD</b> inserts the new element <i class="farg">elm</i> at the head of the list.<p>
The macro <b class="name">LIST_REMOVE</b> removes the element <i class="farg">elm</i> from the list.<p>
The macro <b class="name">LIST_REPLACE</b> replaces the element <i class="farg">elm</i> with <i class="farg">new</i> in the list.<p>
The macro <b class="name">LIST_MOVE</b> moves the list headed by <i class="farg">head1</i> onto the list headed by <i class="farg">head2</i>, always making the former empty.</div>
<div class="section">
<h1 id="x4c495354204558414d504c45">LIST EXAMPLE</h1><pre style="margin-left: 0.00ex;" class="lit display">
LIST_HEAD(listhead, entry) head; 
struct listhead *headp;		/* List head. */ 
struct entry { 
	... 
	LIST_ENTRY(entry) entries;	/* List. */ 
	... 
} *n1, *n2, *np; 
 
LIST_INIT(&amp;head);			/* Initialize the list. */ 
 
n1 = malloc(sizeof(struct entry));	/* Insert at the head. */ 
LIST_INSERT_HEAD(&amp;head, n1, entries); 
 
n2 = malloc(sizeof(struct entry));	/* Insert after. */ 
LIST_INSERT_AFTER(n1, n2, entries); 
 
n2 = malloc(sizeof(struct entry));	/* Insert before. */ 
LIST_INSERT_BEFORE(n1, n2, entries); 
					/* Forward traversal. */ 
LIST_FOREACH(np, &amp;head, entries) 
	np-&gt; ... 
					/* Delete. */ 
while (LIST_FIRST(&amp;head) != NULL) 
	LIST_REMOVE(LIST_FIRST(&amp;head), entries); 
if (LIST_EMPTY(&amp;head))			/* Test for emptiness. */ 
	printf("nothing to do\n");</pre>
</div>
<div class="section">
<h1 id="x53494d504c4520515545554553">SIMPLE QUEUES</h1> A simple queue is headed by a structure defined by the <b class="name">SIMPLEQ_HEAD</b> macro. This structure contains a pair of pointers, one to the first element in the simple queue and the other to the last element in the simple queue. The elements are singly linked for minimum space and pointer manipulation overhead at the expense of O(n) removal for arbitrary elements. New elements can be added to the queue after an existing element, at the head of the queue, or at the end of the queue. A <i class="farg">SIMPLEQ_HEAD</i> structure is declared as follows:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
SIMPLEQ_HEAD(HEADNAME, TYPE) head;</pre>
<p>
where <code class="lit">HEADNAME</code> is the name of the structure to be defined, and <code class="lit">TYPE</code> is the type of the elements to be linked into the simple queue. A pointer to the head of the simple queue can later be declared as:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
struct HEADNAME *headp;</pre>
<p>
(The names <code class="lit">head</code> and <code class="lit">headp</code> are user selectable.)<p>
The macro <b class="name">SIMPLEQ_ENTRY</b> declares a structure that connects the elements in the simple queue.<p>
The macro <b class="name">SIMPLEQ_HEAD_INITIALIZER</b> provides a value which can be used to initialize a simple queue head at compile time, and is used at the point that the simple queue head variable is declared, like:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
struct HEADNAME head = SIMPLEQ_HEAD_INITIALIZER(head);</pre>
<p>
The macro <b class="name">SIMPLEQ_FIRST</b> returns the first element of the simple queue <i class="farg">head</i>.<p>
The macro <b class="name">SIMPLEQ_EMPTY</b> returns true if the simple queue <i class="farg">head</i> has no elements.<p>
The macro <b class="name">SIMPLEQ_NEXT</b> returns the element after the element <i class="farg">elm</i>.<p>
The macro <b class="name">SIMPLEQ_LAST</b> returns the last item on the tail queue. If the tail queue is empty the return value is <span class="define">NULL</span>.<p>
The macro <b class="name">SIMPLEQ_FOREACH</b> traverses the tail queue referenced by <i class="farg">head</i> in the forward direction, assigning each element in turn to <i class="farg">var</i>.<p>
The SAFE version uses <i class="farg">tmp</i> to hold the next element, so <i class="farg">var</i> may be freed or removed from the list.<p>
The macro <b class="name">SIMPLEQ_INIT</b> initializes the simple queue referenced by <i class="farg">head</i>.<p>
The macro <b class="name">SIMPLEQ_INSERT_HEAD</b> inserts the new element <i class="farg">elm</i> at the head of the simple queue.<p>
The macro <b class="name">SIMPLEQ_INSERT_TAIL</b> inserts the new element <i class="farg">elm</i> at the end of the simple queue.<p>
The macro <b class="name">SIMPLEQ_INSERT_AFTER</b> inserts the new element <i class="farg">elm</i> after the element <i class="farg">listelm</i>.<p>
The macro <b class="name">SIMPLEQ_REMOVE_HEAD</b> removes the first element from the head of the simple queue. For optimum efficiency, elements being removed from the head of the queue should explicitly use this macro instead of the generic <b class="name">SIMPLQ_REMOVE</b> macro.<p>
The macro <b class="name">SIMPLEQ_REMOVE_AFTER</b> removes the element after the one specified from the simple queue. For optimum efficiency, elements being removed after specified elements should explicitly use this macro instead of the generic <b class="name">SIMPLQ_REMOVE</b> macro.<p>
The macro <b class="name">SIMPLEQ_REMOVE</b> removes <i class="farg">elm</i> from the simple queue.<p>
The macro <b class="name">SIMPLEQ_CONCAT</b> concatenates the tail queue headed by <i class="farg">head2</i> onto the end of the one headed by <i class="farg">head1</i>, removing all entries from the former.</div>
<div class="section">
<h1 id="x53494d504c45205155455545204558414d504c45">SIMPLE QUEUE EXAMPLE</h1><pre style="margin-left: 0.00ex;" class="lit display">
SIMPLEQ_HEAD(simplehead, entry) head; 
struct simplehead *headp;		/* Simple queue head. */ 
struct entry { 
	... 
	SIMPLEQ_ENTRY(entry) entries;	/* Simple queue. */ 
	... 
} *n1, *n2, *np; 
 
SIMPLEQ_INIT(&amp;head);			/* Initialize the queue. */ 
 
n1 = malloc(sizeof(struct entry));	/* Insert at the head. */ 
SIMPLEQ_INSERT_HEAD(&amp;head, n1, entries); 
 
n1 = malloc(sizeof(struct entry));	/* Insert at the tail. */ 
SIMPLEQ_INSERT_TAIL(&amp;head, n1, entries); 
 
n2 = malloc(sizeof(struct entry));	/* Insert after. */ 
SIMPLEQ_INSERT_AFTER(&amp;head, n1, n2, entries); 
					/* Forward traversal. */ 
SIMPLEQ_FOREACH(np, &amp;head, entries) 
	np-&gt; ... 
					/* Delete. */ 
while (SIMPLEQ_FIRST(&amp;head) != NULL) 
	SIMPLEQ_REMOVE_HEAD(&amp;head, entries); 
if (SIMPLEQ_EMPTY(&amp;head))		/* Test for emptiness. */ 
	printf("nothing to do\n");</pre>
</div>
<div class="section">
<h1 id="x5441494c20515545554553">TAIL QUEUES</h1> A tail queue is headed by a structure defined by the <b class="name">TAILQ_HEAD</b> macro. This structure contains a pair of pointers, one to the first element in the tail queue and the other to the last element in the tail queue. The elements are doubly linked so that an arbitrary element can be removed without traversing the tail queue. New elements can be added to the queue after an existing element, before an existing element, at the head of the queue, or at the end the queue. A <i class="farg">TAILQ_HEAD</i> structure is declared as follows:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
TAILQ_HEAD(HEADNAME, TYPE) head;</pre>
<p>
where <code class="lit">HEADNAME</code> is the name of the structure to be defined, and <code class="lit">TYPE</code> is the type of the elements to be linked into the tail queue. A pointer to the head of the tail queue can later be declared as:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
struct HEADNAME *headp;</pre>
<p>
(The names <code class="lit">head</code> and <code class="lit">headp</code> are user selectable.)<p>
The macro <b class="name">TAILQ_ENTRY</b> declares a structure that connects the elements in the tail queue.<p>
The macro <b class="name">TAILQ_HEAD_INITIALIZER</b> provides a value which can be used to initialize a tail queue head at compile time, and is used at the point that the tail queue head variable is declared, like:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
struct HEADNAME head = TAILQ_HEAD_INITIALIZER(head);</pre>
<p>
The macro <b class="name">TAILQ_FIRST</b> returns the first element of the tail queue <i class="farg">head</i>.<p>
The macro <b class="name">TAILQ_NEXT</b> returns the element after the element <i class="farg">elm</i>.<p>
The macro <b class="name">TAILQ_LAST</b> returns the last item on the tail queue. If the tail queue is empty the return value is <span class="define">NULL</span>.<p>
The macro <b class="name">TAILQ_PREV</b> returns the previous item on the tail queue, from the one specified. If the tail queue is empty the return value is <span class="define">NULL</span>.<p>
The macro <b class="name">TAILQ_EMPTY</b> returns true if the tail queue <i class="farg">head</i> has no elements.<p>
The macros <b class="name">TAILQ_FOREACH</b>, <b class="name">TAILQ_FOREACH_REVERSE</b>, <b class="name">TAILQ_FOREACH_SAFE</b>, and <b class="name">TAILQ_FOREACH_REVERSE_SAFE</b> traverse the tail queue referenced by <i class="farg">head</i> in the forward or reverse direction direction, assigning each element in turn to <i class="farg">var</i>.<p>
The SAFE versions use <i class="farg">tmp</i> to hold the next element, so <i class="farg">var</i> may be freed or removed from the list.<p>
The macro <b class="name">TAILQ_INIT</b> initializes the tail queue referenced by <i class="farg">head</i>.<p>
The macro <b class="name">TAILQ_INSERT_HEAD</b> inserts the new element <i class="farg">elm</i> at the head of the tail queue.<p>
The macro <b class="name">TAILQ_INSERT_TAIL</b> inserts the new element <i class="farg">elm</i> at the end of the tail queue.<p>
The macro <b class="name">TAILQ_INSERT_AFTER</b> inserts the new element <i class="farg">elm</i> after the element <i class="farg">listelm</i>.<p>
The macro <b class="name">TAILQ_INSERT_BEFORE</b> inserts the new element <i class="farg">elm</i> before the element <i class="farg">listelm</i>.<p>
The macro <b class="name">TAILQ_REMOVE</b> removes the element <i class="farg">elm</i> from the tail queue.<p>
The macro <b class="name">TAILQ_REPLACE</b> replaces the element <i class="farg">elm</i> with the <i class="farg">new</i> one specified in the tail queue.<p>
The macro <b class="name">TAILQ_CONCAT</b> concatenates the tail queue headed by <i class="farg">head2</i> onto the end of the one headed by <i class="farg">head1</i>, removing all entries from the former.</div>
<div class="section">
<h1 id="x5441494c205155455545204558414d504c45">TAIL QUEUE EXAMPLE</h1><pre style="margin-left: 0.00ex;" class="lit display">
TAILQ_HEAD(tailhead, entry) head; 
struct tailhead *headp;		/* Tail queue head. */ 
struct entry { 
	... 
	TAILQ_ENTRY(entry) entries;	/* Tail queue. */ 
	... 
} *n1, *n2, *np; 
 
TAILQ_INIT(&amp;head);			/* Initialize the queue. */ 
 
n1 = malloc(sizeof(struct entry));	/* Insert at the head. */ 
TAILQ_INSERT_HEAD(&amp;head, n1, entries); 
 
n1 = malloc(sizeof(struct entry));	/* Insert at the tail. */ 
TAILQ_INSERT_TAIL(&amp;head, n1, entries); 
 
n2 = malloc(sizeof(struct entry));	/* Insert after. */ 
TAILQ_INSERT_AFTER(&amp;head, n1, n2, entries); 
 
n2 = malloc(sizeof(struct entry));	/* Insert before. */ 
TAILQ_INSERT_BEFORE(n1, n2, entries); 
					/* Forward traversal. */ 
TAILQ_FOREACH(np, &amp;head, entries) 
	np-&gt; ... 
					/* Reverse traversal. */ 
TAILQ_FOREACH_REVERSE(np, &amp;head, tailhead, entries) 
	np-&gt; ... 
					/* Delete. */ 
while (TAILQ_FIRST(&amp;head) != NULL) 
	TAILQ_REMOVE(&amp;head, TAILQ_FIRST(&amp;head), entries); 
if (TAILQ_EMPTY(&amp;head))			/* Test for emptiness. */ 
	printf("nothing to do\n");</pre>
</div>
<div class="section">
<h1 id="x53494e474c59204c494e4b4544205441494c20515545554553">SINGLY LINKED TAIL QUEUES</h1> The macros prefixed with &#8220;<b class="name">STAILQ_</b>&#8221; (<b class="name">STAILQ_HEAD</b>, <b class="name">STAILQ_HEAD_INITIALIZER</b>, <b class="name">STAILQ_ENTRY</b>, <b class="name">STAILQ_FOREACH</b>, <b class="name">STAILQ_FOREACH_SAFE</b>, <b class="name">STAILQ_FIRST</b>, <b class="name">STAILQ_EMPTY</b>, <b class="name">STAILQ_NEXT</b>, <b class="name">STAILQ_LAST</b>, <b class="name">STAILQ_INIT</b>, <b class="name">STAILQ_INSERT_HEAD</b>, <b class="name">STAILQ_INSERT_TAIL</b>, <b class="name">STAILQ_INSERT_AFTER</b>, <b class="name">STAILQ_REMOVE_HEAD</b>, <b class="name">STAILQ_REMOVE</b>, and <b class="name">STAILQ_CONCAT</b>) are functionally identical to these simple queue functions, and are provided for compatibility with <span class="unix">FreeBSD</span>.</div>
<div class="section">
<h1 id="x4e4f544553">NOTES</h1> Some of these macros or functions perform no error checking, and invalid usage leads to undefined behaviour. In the case of macros or functions that expect their arguments to be elements that are present in the list or queue, passing an element that is not present is invalid.</div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The <b class="name">queue</b> functions first appeared in <span class="unix">4.4BSD</span>. The <b class="name">SIMPLEQ</b> functions first appeared in <span class="unix">NetBSD&#160;1.2</span>. The <b class="name">SLIST</b> and <b class="name">STAILQ</b> functions first appeared in <span class="unix">FreeBSD&#160;2.1.5</span>.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
May 17, 2014</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

