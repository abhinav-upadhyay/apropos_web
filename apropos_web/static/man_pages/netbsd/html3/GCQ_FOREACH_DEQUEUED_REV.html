<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
GCQ(3)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
GCQ(3)</td>
<td class="head-vol" align="center">
Library Functions Manual</td>
<td class="head-rtitle" align="right">
GCQ(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">GCQ_INIT</b>, <b class="name">GCQ_INIT_HEAD</b>, <b class="name">gcq_init</b>, <b class="name">gcq_init_head</b>, <b class="name">gcq_q</b>, <b class="name">gcq_hq</b>, <b class="name">gcq_head</b>, <b class="name">gcq_remove</b>, <b class="name">gcq_onlist</b>, <b class="name">gcq_empty</b>, <b class="name">gcq_linked</b>, <b class="name">gcq_insert_after</b>, <b class="name">gcq_insert_before</b>, <b class="name">gcq_insert_head</b>, <b class="name">gcq_insert_tail</b>, <b class="name">gcq_tie</b>, <b class="name">gcq_tie_after</b>, <b class="name">gcq_tie_before</b>, <b class="name">gcq_merge</b>, <b class="name">gcq_merge_head</b>, <b class="name">gcq_merge_tail</b>, <b class="name">gcq_clear</b>, <b class="name">gcq_remove_all</b>, <b class="name">GCQ_ITEM</b>, <b class="name">GCQ_GOT_FIRST</b>, <b class="name">GCQ_GOT_LAST</b>, <b class="name">GCQ_GOT_NEXT</b>, <b class="name">GCQ_GOT_PREV</b>, <b class="name">GCQ_DEQUEUED_FIRST</b>, <b class="name">GCQ_DEQUEUED_LAST</b>, <b class="name">GCQ_DEQUEUED_NEXT</b>, <b class="name">GCQ_DEQUEUED_PREV</b>, <b class="name">GCQ_GOT_FIRST_TYPED</b>, <b class="name">GCQ_GOT_LAST_TYPED</b>, <b class="name">GCQ_GOT_NEXT_TYPED</b>, <b class="name">GCQ_GOT_PREV_TYPED</b>, <b class="name">GCQ_DEQUEUED_FIRST_TYPED</b>, <b class="name">GCQ_DEQUEUED_LAST_TYPED</b>, <b class="name">GCQ_DEQUEUED_NEXT_TYPED</b>, <b class="name">GCQ_DEQUEUED_PREV_TYPED</b>, <b class="name">GCQ_GOT_FIRST_COND</b>, <b class="name">GCQ_GOT_LAST_COND</b>, <b class="name">GCQ_GOT_NEXT_COND</b>, <b class="name">GCQ_GOT_PREV_COND</b>, <b class="name">GCQ_DEQUEUED_FIRST_COND</b>, <b class="name">GCQ_DEQUEUED_LAST_COND</b>, <b class="name">GCQ_DEQUEUED_NEXT_COND</b>, <b class="name">GCQ_DEQUEUED_PREV_COND</b>, <b class="name">GCQ_GOT_FIRST_COND_TYPED</b>, <b class="name">GCQ_GOT_LAST_COND_TYPED</b>, <b class="name">GCQ_GOT_NEXT_COND_TYPED</b>, <b class="name">GCQ_GOT_PREV_COND_TYPED</b>, <b class="name">GCQ_DEQUEUED_FIRST_COND_TYPED</b>, <b class="name">GCQ_DEQUEUED_LAST_COND_TYPED</b>, <b class="name">GCQ_DEQUEUED_NEXT_COND_TYPED</b>, <b class="name">GCQ_DEQUEUED_PREV_COND_TYPED</b>, <b class="name">GCQ_FOREACH</b>, <b class="name">GCQ_FOREACH_REV</b>, <b class="name">GCQ_FOREACH_NVAR</b>, <b class="name">GCQ_FOREACH_NVAR_REV</b>, <b class="name">GCQ_FOREACH_RO</b>, <b class="name">GCQ_FOREACH_RO_REV</b>, <b class="name">GCQ_FOREACH_DEQUEUED</b>, <b class="name">GCQ_FOREACH_DEQUEUED_REV</b>, <b class="name">GCQ_FOREACH_TYPED</b>, <b class="name">GCQ_FOREACH_REV_TYPED</b>, <b class="name">GCQ_FOREACH_NVAR_TYPED</b>, <b class="name">GCQ_FOREACH_NVAR_REV_TYPED</b>, <b class="name">GCQ_FOREACH_RO_TYPED</b>, <b class="name">GCQ_FOREACH_RO_REV_TYPED</b>, <b class="name">GCQ_FOREACH_DEQUEUED_TYPED</b>, <b class="name">GCQ_FOREACH_DEQUEUED_REV_TYPED</b>, <b class="name">GCQ_FIND</b>, <b class="name">GCQ_FIND_REV</b>, <b class="name">GCQ_FIND_TYPED</b>, <b class="name">GCQ_FIND_REV_TYPED</b> &#8212; <span class="desc">Generic Circular Queues</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/gcq.h</a>&gt;</b><p>
<br>
<span class="type">struct gcq</span>;<br>
<span class="type">struct gcq_head</span>;<p>
<br>
<b class="fname">GCQ_INIT</b>(<i class="farg" style="white-space:nowrap;">name</i>);<p>
<b class="fname">GCQ_INIT_HEAD</b>(<i class="farg" style="white-space:nowrap;">name</i>);<p>
<br>
<i class="ftype">static inline void</i><br>
<b class="fname">gcq_init</b>(<i class="farg" style="white-space:nowrap;">struct gcq *q</i>);<p>
<i class="ftype">static inline void</i><br>
<b class="fname">gcq_init_head</b>(<i class="farg" style="white-space:nowrap;">struct gcq_head *head</i>);<p>
<i class="ftype">static inline struct gcq *</i><br>
<b class="fname">gcq_q</b>(<i class="farg" style="white-space:nowrap;">struct gcq_head *head</i>);<p>
<i class="ftype">static inline struct gcq *</i><br>
<b class="fname">gcq_hq</b>(<i class="farg" style="white-space:nowrap;">struct gcq_head *head</i>);<p>
<i class="ftype">static inline struct gcq_head *</i><br>
<b class="fname">gcq_head</b>(<i class="farg" style="white-space:nowrap;">struct gcq *q</i>);<p>
<i class="ftype">static inline struct gcq *</i><br>
<b class="fname">gcq_remove</b>(<i class="farg" style="white-space:nowrap;">struct gcq *q</i>);<p>
<i class="ftype">static inline bool</i><br>
<b class="fname">gcq_onlist</b>(<i class="farg" style="white-space:nowrap;">struct gcq *q</i>);<p>
<i class="ftype">static inline bool</i><br>
<b class="fname">gcq_empty</b>(<i class="farg" style="white-space:nowrap;">struct gcq_head *head</i>);<p>
<i class="ftype">static inline bool</i><br>
<b class="fname">gcq_linked</b>(<i class="farg" style="white-space:nowrap;">struct gcq *prev</i>, <i class="farg" style="white-space:nowrap;">struct gcq *next</i>);<p>
<i class="ftype">static inline void</i><br>
<b class="fname">gcq_insert_after</b>(<i class="farg" style="white-space:nowrap;">struct gcq *on</i>, <i class="farg" style="white-space:nowrap;">struct gcq *off</i>);<p>
<i class="ftype">static inline void</i><br>
<b class="fname">gcq_insert_before</b>(<i class="farg" style="white-space:nowrap;">struct gcq *on</i>, <i class="farg" style="white-space:nowrap;">struct gcq *off</i>);<p>
<i class="ftype">static inline void</i><br>
<b class="fname">gcq_insert_head</b>(<i class="farg" style="white-space:nowrap;">struct gcq_head *head</i>, <i class="farg" style="white-space:nowrap;">struct gcq *q</i>);<p>
<i class="ftype">static inline void</i><br>
<b class="fname">gcq_insert_tail</b>(<i class="farg" style="white-space:nowrap;">struct gcq_head *head</i>, <i class="farg" style="white-space:nowrap;">struct gcq *q</i>);<p>
<i class="ftype">static inline void</i><br>
<b class="fname">gcq_tie</b>(<i class="farg" style="white-space:nowrap;">struct gcq *dst</i>, <i class="farg" style="white-space:nowrap;">struct gcq *src</i>);<p>
<i class="ftype">static inline void</i><br>
<b class="fname">gcq_tie_after</b>(<i class="farg" style="white-space:nowrap;">struct gcq *dst</i>, <i class="farg" style="white-space:nowrap;">struct gcq *src</i>);<p>
<i class="ftype">static inline void</i><br>
<b class="fname">gcq_tie_before</b>(<i class="farg" style="white-space:nowrap;">struct gcq *dst</i>, <i class="farg" style="white-space:nowrap;">struct gcq *src</i>);<p>
<i class="ftype">static inline void</i><br>
<b class="fname">gcq_merge</b>(<i class="farg" style="white-space:nowrap;">struct gcq *dst</i>, <i class="farg" style="white-space:nowrap;">struct gcq *src</i>);<p>
<i class="ftype">static inline void</i><br>
<b class="fname">gcq_merge_tail</b>(<i class="farg" style="white-space:nowrap;">struct gcq_head *dst</i>, <i class="farg" style="white-space:nowrap;">struct gcq_head *src</i>);<p>
<i class="ftype">static inline void</i><br>
<b class="fname">gcq_merge_head</b>(<i class="farg" style="white-space:nowrap;">struct gcq_head *dst</i>, <i class="farg" style="white-space:nowrap;">struct gcq_head *src</i>);<p>
<i class="ftype">static inline void</i><br>
<b class="fname">gcq_clear</b>(<i class="farg" style="white-space:nowrap;">struct gcq *q</i>);<p>
<i class="ftype">static inline void</i><br>
<b class="fname">gcq_remove_all</b>(<i class="farg" style="white-space:nowrap;">struct gcq_head *head</i>);<p>
<br>
<i class="ftype">type *</i><br>
<b class="fname">GCQ_ITEM</b>(<i class="farg" style="white-space:nowrap;">q</i>, <i class="farg" style="white-space:nowrap;">type</i>, <i class="farg" style="white-space:nowrap;">name</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">GCQ_GOT_FIRST</b>(<i class="farg" style="white-space:nowrap;">var</i>, <i class="farg" style="white-space:nowrap;">head</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">GCQ_GOT_LAST</b>(<i class="farg" style="white-space:nowrap;">var</i>, <i class="farg" style="white-space:nowrap;">head</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">GCQ_GOT_NEXT</b>(<i class="farg" style="white-space:nowrap;">var</i>, <i class="farg" style="white-space:nowrap;">current</i>, <i class="farg" style="white-space:nowrap;">head</i>, <i class="farg" style="white-space:nowrap;">start</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">GCQ_GOT_PREV</b>(<i class="farg" style="white-space:nowrap;">var</i>, <i class="farg" style="white-space:nowrap;">current</i>, <i class="farg" style="white-space:nowrap;">head</i>, <i class="farg" style="white-space:nowrap;">start</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">GCQ_DEQUEUED_FIRST</b>(<i class="farg" style="white-space:nowrap;">var</i>, <i class="farg" style="white-space:nowrap;">head</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">GCQ_DEQUEUED_LAST</b>(<i class="farg" style="white-space:nowrap;">var</i>, <i class="farg" style="white-space:nowrap;">head</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">GCQ_DEQUEUED_NEXT</b>(<i class="farg" style="white-space:nowrap;">var</i>, <i class="farg" style="white-space:nowrap;">current</i>, <i class="farg" style="white-space:nowrap;">head</i>, <i class="farg" style="white-space:nowrap;">start</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">GCQ_DEQUEUED_PREV</b>(<i class="farg" style="white-space:nowrap;">var</i>, <i class="farg" style="white-space:nowrap;">current</i>, <i class="farg" style="white-space:nowrap;">head</i>, <i class="farg" style="white-space:nowrap;">start</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">GCQ_GOT_FIRST_TYPED</b>(<i class="farg" style="white-space:nowrap;">tvar</i>, <i class="farg" style="white-space:nowrap;">head</i>, <i class="farg" style="white-space:nowrap;">type</i>, <i class="farg" style="white-space:nowrap;">name</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">GCQ_GOT_LAST_TYPED</b>(<i class="farg" style="white-space:nowrap;">tvar</i>, <i class="farg" style="white-space:nowrap;">head</i>, <i class="farg" style="white-space:nowrap;">type</i>, <i class="farg" style="white-space:nowrap;">name</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">GCQ_GOT_NEXT_TYPED</b>(<i class="farg" style="white-space:nowrap;">tvar</i>, <i class="farg" style="white-space:nowrap;">current</i>, <i class="farg" style="white-space:nowrap;">head</i>, <i class="farg" style="white-space:nowrap;">start</i>, <i class="farg" style="white-space:nowrap;">type</i>, <i class="farg" style="white-space:nowrap;">name</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">GCQ_GOT_PREV_TYPED</b>(<i class="farg" style="white-space:nowrap;">tvar</i>, <i class="farg" style="white-space:nowrap;">current</i>, <i class="farg" style="white-space:nowrap;">head</i>, <i class="farg" style="white-space:nowrap;">start</i>, <i class="farg" style="white-space:nowrap;">type</i>, <i class="farg" style="white-space:nowrap;">name</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">GCQ_DEQUEUED_FIRST_TYPED</b>(<i class="farg" style="white-space:nowrap;">tvar</i>, <i class="farg" style="white-space:nowrap;">head</i>, <i class="farg" style="white-space:nowrap;">type</i>, <i class="farg" style="white-space:nowrap;">name</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">GCQ_DEQUEUED_LAST_TYPED</b>(<i class="farg" style="white-space:nowrap;">tvar</i>, <i class="farg" style="white-space:nowrap;">head</i>, <i class="farg" style="white-space:nowrap;">type</i>, <i class="farg" style="white-space:nowrap;">name</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">GCQ_DEQUEUED_NEXT_TYPED</b>(<i class="farg" style="white-space:nowrap;">tvar</i>, <i class="farg" style="white-space:nowrap;">current</i>, <i class="farg" style="white-space:nowrap;">head</i>, <i class="farg" style="white-space:nowrap;">start</i>, <i class="farg" style="white-space:nowrap;">type</i>, <i class="farg" style="white-space:nowrap;">name</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">GCQ_DEQUEUED_PREV_TYPED</b>(<i class="farg" style="white-space:nowrap;">tvar</i>, <i class="farg" style="white-space:nowrap;">current</i>, <i class="farg" style="white-space:nowrap;">head</i>, <i class="farg" style="white-space:nowrap;">start</i>, <i class="farg" style="white-space:nowrap;">type</i>, <i class="farg" style="white-space:nowrap;">name</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">GCQ_GOT_FIRST_COND</b>(<i class="farg" style="white-space:nowrap;">var</i>, <i class="farg" style="white-space:nowrap;">head</i>, <i class="farg" style="white-space:nowrap;">cond</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">GCQ_GOT_LAST_COND</b>(<i class="farg" style="white-space:nowrap;">var</i>, <i class="farg" style="white-space:nowrap;">head</i>, <i class="farg" style="white-space:nowrap;">cond</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">GCQ_GOT_NEXT_COND</b>(<i class="farg" style="white-space:nowrap;">var</i>, <i class="farg" style="white-space:nowrap;">current</i>, <i class="farg" style="white-space:nowrap;">head</i>, <i class="farg" style="white-space:nowrap;">start</i>, <i class="farg" style="white-space:nowrap;">cond</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">GCQ_GOT_PREV_COND</b>(<i class="farg" style="white-space:nowrap;">var</i>, <i class="farg" style="white-space:nowrap;">current</i>, <i class="farg" style="white-space:nowrap;">head</i>, <i class="farg" style="white-space:nowrap;">start</i>, <i class="farg" style="white-space:nowrap;">cond</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">GCQ_DEQUEUED_FIRST_COND</b>(<i class="farg" style="white-space:nowrap;">var</i>, <i class="farg" style="white-space:nowrap;">head</i>, <i class="farg" style="white-space:nowrap;">cond</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">GCQ_DEQUEUED_LAST_COND</b>(<i class="farg" style="white-space:nowrap;">var</i>, <i class="farg" style="white-space:nowrap;">head</i>, <i class="farg" style="white-space:nowrap;">cond</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">GCQ_DEQUEUED_NEXT_COND</b>(<i class="farg" style="white-space:nowrap;">var</i>, <i class="farg" style="white-space:nowrap;">current</i>, <i class="farg" style="white-space:nowrap;">head</i>, <i class="farg" style="white-space:nowrap;">start</i>, <i class="farg" style="white-space:nowrap;">cond</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">GCQ_DEQUEUED_PREV_COND</b>(<i class="farg" style="white-space:nowrap;">var</i>, <i class="farg" style="white-space:nowrap;">current</i>, <i class="farg" style="white-space:nowrap;">head</i>, <i class="farg" style="white-space:nowrap;">start</i>, <i class="farg" style="white-space:nowrap;">cond</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">GCQ_GOT_FIRST_COND_TYPED</b>(<i class="farg" style="white-space:nowrap;">tvar</i>, <i class="farg" style="white-space:nowrap;">head</i>, <i class="farg" style="white-space:nowrap;">type</i>, <i class="farg" style="white-space:nowrap;">name</i>, <i class="farg" style="white-space:nowrap;">cond</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">GCQ_GOT_LAST_COND_TYPED</b>(<i class="farg" style="white-space:nowrap;">tvar</i>, <i class="farg" style="white-space:nowrap;">head</i>, <i class="farg" style="white-space:nowrap;">type</i>, <i class="farg" style="white-space:nowrap;">name</i>, <i class="farg" style="white-space:nowrap;">cond</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">GCQ_GOT_NEXT_COND_TYPED</b>(<i class="farg" style="white-space:nowrap;">tvar</i>, <i class="farg" style="white-space:nowrap;">current</i>, <i class="farg" style="white-space:nowrap;">head</i>, <i class="farg" style="white-space:nowrap;">start</i>, <i class="farg" style="white-space:nowrap;">type</i>, <i class="farg" style="white-space:nowrap;">name</i>, <i class="farg" style="white-space:nowrap;">cond</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">GCQ_GOT_PREV_COND_TYPED</b>(<i class="farg" style="white-space:nowrap;">tvar</i>, <i class="farg" style="white-space:nowrap;">current</i>, <i class="farg" style="white-space:nowrap;">head</i>, <i class="farg" style="white-space:nowrap;">start</i>, <i class="farg" style="white-space:nowrap;">type</i>, <i class="farg" style="white-space:nowrap;">name</i>, <i class="farg" style="white-space:nowrap;">cond</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">GCQ_DEQUEUED_FIRST_COND_TYPED</b>(<i class="farg" style="white-space:nowrap;">tvar</i>, <i class="farg" style="white-space:nowrap;">head</i>, <i class="farg" style="white-space:nowrap;">type</i>, <i class="farg" style="white-space:nowrap;">name</i>, <i class="farg" style="white-space:nowrap;">cond</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">GCQ_DEQUEUED_LAST_COND_TYPED</b>(<i class="farg" style="white-space:nowrap;">tvar</i>, <i class="farg" style="white-space:nowrap;">head</i>, <i class="farg" style="white-space:nowrap;">type</i>, <i class="farg" style="white-space:nowrap;">name</i>, <i class="farg" style="white-space:nowrap;">cond</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">GCQ_DEQUEUED_NEXT_COND_TYPED</b>(<i class="farg" style="white-space:nowrap;">tvar</i>, <i class="farg" style="white-space:nowrap;">current</i>, <i class="farg" style="white-space:nowrap;">head</i>, <i class="farg" style="white-space:nowrap;">start</i>, <i class="farg" style="white-space:nowrap;">type</i>, <i class="farg" style="white-space:nowrap;">name</i>, <i class="farg" style="white-space:nowrap;">cond</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">GCQ_DEQUEUED_PREV_COND_TYPED</b>(<i class="farg" style="white-space:nowrap;">tvar</i>, <i class="farg" style="white-space:nowrap;">current</i>, <i class="farg" style="white-space:nowrap;">head</i>, <i class="farg" style="white-space:nowrap;">start</i>, <i class="farg" style="white-space:nowrap;">type</i>, <i class="farg" style="white-space:nowrap;">name</i>, <i class="farg" style="white-space:nowrap;">cond</i>);<p>
<b class="fname">GCQ_FOREACH</b>(<i class="farg" style="white-space:nowrap;">var</i>, <i class="farg" style="white-space:nowrap;">head</i>);<p>
<b class="fname">GCQ_FOREACH_REV</b>(<i class="farg" style="white-space:nowrap;">var</i>, <i class="farg" style="white-space:nowrap;">head</i>);<p>
<b class="fname">GCQ_FOREACH_NVAR</b>(<i class="farg" style="white-space:nowrap;">var</i>, <i class="farg" style="white-space:nowrap;">nvar</i>, <i class="farg" style="white-space:nowrap;">head</i>);<p>
<b class="fname">GCQ_FOREACH_NVAR_REV</b>(<i class="farg" style="white-space:nowrap;">var</i>, <i class="farg" style="white-space:nowrap;">nvar</i>, <i class="farg" style="white-space:nowrap;">head</i>);<p>
<b class="fname">GCQ_FOREACH_RO</b>(<i class="farg" style="white-space:nowrap;">var</i>, <i class="farg" style="white-space:nowrap;">nvar</i>, <i class="farg" style="white-space:nowrap;">head</i>);<p>
<b class="fname">GCQ_FOREACH_RO_REV</b>(<i class="farg" style="white-space:nowrap;">var</i>, <i class="farg" style="white-space:nowrap;">nvar</i>, <i class="farg" style="white-space:nowrap;">head</i>);<p>
<b class="fname">GCQ_FOREACH_DEQUEUED</b>(<i class="farg" style="white-space:nowrap;">var</i>, <i class="farg" style="white-space:nowrap;">nvar</i>, <i class="farg" style="white-space:nowrap;">head</i>);<p>
<b class="fname">GCQ_FOREACH_DEQUEUED_REV</b>(<i class="farg" style="white-space:nowrap;">var</i>, <i class="farg" style="white-space:nowrap;">nvar</i>, <i class="farg" style="white-space:nowrap;">head</i>);<p>
<b class="fname">GCQ_FOREACH_TYPED</b>(<i class="farg" style="white-space:nowrap;">var</i>, <i class="farg" style="white-space:nowrap;">head</i>, <i class="farg" style="white-space:nowrap;">tvar</i>, <i class="farg" style="white-space:nowrap;">type</i>, <i class="farg" style="white-space:nowrap;">name</i>);<p>
<b class="fname">GCQ_FOREACH_REV_TYPED</b>(<i class="farg" style="white-space:nowrap;">var</i>, <i class="farg" style="white-space:nowrap;">head</i>, <i class="farg" style="white-space:nowrap;">tvar</i>, <i class="farg" style="white-space:nowrap;">type</i>, <i class="farg" style="white-space:nowrap;">name</i>);<p>
<b class="fname">GCQ_FOREACH_NVAR_TYPED</b>(<i class="farg" style="white-space:nowrap;">var</i>, <i class="farg" style="white-space:nowrap;">nvar</i>, <i class="farg" style="white-space:nowrap;">head</i>, <i class="farg" style="white-space:nowrap;">tvar</i>, <i class="farg" style="white-space:nowrap;">type</i>, <i class="farg" style="white-space:nowrap;">name</i>);<p>
<b class="fname">GCQ_FOREACH_NVAR_REV_TYPED</b>(<i class="farg" style="white-space:nowrap;">var</i>, <i class="farg" style="white-space:nowrap;">nvar</i>, <i class="farg" style="white-space:nowrap;">head</i>, <i class="farg" style="white-space:nowrap;">tvar</i>, <i class="farg" style="white-space:nowrap;">type</i>, <i class="farg" style="white-space:nowrap;">name</i>);<p>
<b class="fname">GCQ_FOREACH_RO_TYPED</b>(<i class="farg" style="white-space:nowrap;">var</i>, <i class="farg" style="white-space:nowrap;">nvar</i>, <i class="farg" style="white-space:nowrap;">head</i>, <i class="farg" style="white-space:nowrap;">tvar</i>, <i class="farg" style="white-space:nowrap;">type</i>, <i class="farg" style="white-space:nowrap;">name</i>);<p>
<b class="fname">GCQ_FOREACH_RO_REV_TYPED</b>(<i class="farg" style="white-space:nowrap;">var</i>, <i class="farg" style="white-space:nowrap;">nvar</i>, <i class="farg" style="white-space:nowrap;">head</i>, <i class="farg" style="white-space:nowrap;">tvar</i>, <i class="farg" style="white-space:nowrap;">type</i>, <i class="farg" style="white-space:nowrap;">name</i>);<p>
<b class="fname">GCQ_FOREACH_DEQUEUED_TYPED</b>(<i class="farg" style="white-space:nowrap;">var</i>, <i class="farg" style="white-space:nowrap;">nvar</i>, <i class="farg" style="white-space:nowrap;">head</i>, <i class="farg" style="white-space:nowrap;">tvar</i>, <i class="farg" style="white-space:nowrap;">type</i>, <i class="farg" style="white-space:nowrap;">name</i>);<p>
<b class="fname">GCQ_FOREACH_DEQUEUED_REV_TYPED</b>(<i class="farg" style="white-space:nowrap;">var</i>, <i class="farg" style="white-space:nowrap;">nvar</i>, <i class="farg" style="white-space:nowrap;">head</i>, <i class="farg" style="white-space:nowrap;">tvar</i>, <i class="farg" style="white-space:nowrap;">type</i>, <i class="farg" style="white-space:nowrap;">name</i>);<p>
<b class="fname">GCQ_FIND</b>(<i class="farg" style="white-space:nowrap;">var</i>, <i class="farg" style="white-space:nowrap;">head</i>, <i class="farg" style="white-space:nowrap;">cond</i>);<p>
<b class="fname">GCQ_FIND_REV</b>(<i class="farg" style="white-space:nowrap;">var</i>, <i class="farg" style="white-space:nowrap;">head</i>, <i class="farg" style="white-space:nowrap;">cond</i>);<p>
<b class="fname">GCQ_FIND_TYPED</b>(<i class="farg" style="white-space:nowrap;">var</i>, <i class="farg" style="white-space:nowrap;">head</i>, <i class="farg" style="white-space:nowrap;">tvar</i>, <i class="farg" style="white-space:nowrap;">type</i>, <i class="farg" style="white-space:nowrap;">name</i>, <i class="farg" style="white-space:nowrap;">cond</i>);<p>
<b class="fname">GCQ_FIND_REV_TYPED</b>(<i class="farg" style="white-space:nowrap;">var</i>, <i class="farg" style="white-space:nowrap;">head</i>, <i class="farg" style="white-space:nowrap;">tvar</i>, <i class="farg" style="white-space:nowrap;">type</i>, <i class="farg" style="white-space:nowrap;">name</i>, <i class="farg" style="white-space:nowrap;">cond</i>);<p>
<b class="fname">GCQ_ASSERT</b>(<i class="farg" style="white-space:nowrap;">cond</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The generic circular queue is a doubly linked list designed for efficient merge operations and unconditional removal. All basic operations can be performed with or without use of a separate head, allowing easy replacement of any pointers where efficient removal is desired. The meaning of the data type will not change; direct use and defined operations can be mixed when convenient. The basic type is:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
struct gcq { 
	struct gcq *q_next; 
	struct gcq *q_prev; 
};</pre>
<p>
The structure must first be initialized such that the <b class="var">q_next</b> and <b class="var">q_prev</b> members point to the beginning of the <span class="type">struct gcq</span>. This can be done with <b class="fname">gcq_init</b>() and <b class="fname">gcq_init_head</b>() or with constant initializers <b class="fname">GCQ_INIT</b>() and <b class="fname">GCQ_INIT_HEAD</b>(). A <span class="type">struct gcq</span> should <span class="emph">never</span> be given <span class="define">NULL</span> values.<p>
The structure containing the <span class="type">struct gcq</span> can be retrieved by pointer arithmetic in the <b class="fname">GCQ_ITEM</b>() macro. List traversal normally requires knowledge of the list head to safely retrieve list items.<p>
Capitalized operation names are macros and should be assumed to cause multiple evaluation of arguments. <code class="lit">TYPED</code> variants of macros set a typed pointer variable instead of or in addition to <span class="type">struct gcq *</span> arguments. Additional type specific inlines and macros around some GCQ operations can be useful.<p>
A few assertions are provided when <span class="define">DIAGNOSTIC</span> is defined in the kernel or <span class="define">_DIAGNOSTIC</span> is defined in userland. If <span class="define">GCQ_USE_ASSERT</span> is defined prior to header inclusions then <b class="fname">assert</b>() will be used for assertions and <span class="define">NDEBUG</span> can be used to turn them off. <b class="fname">GCQ_ASSERT</b>() is a wrapper around the used assertion function. None of the operations accept <span class="define">NULL</span> arguments, however this is not tested by assertion.<p>
The head is separately named for type checking but contains only a <span class="type">struct gcq</span>, a pointer to which can be retrieved via <b class="fname">gcq_hq</b>(). The reverse operation is performed by <b class="fname">gcq_head</b>(), turning the supplied <span class="type">struct gcq *</span> into <span class="type">struct gcq_head *</span>. <b class="fname">gcq_q</b>() returns its <span class="type">struct gcq *</span> argument and is used for type checking in <b class="fname">GCQ_ITEM</b>(). There are no functions for retrieving the raw <b class="var">q_prev</b> and <b class="var">q_next</b> pointers as these are usually clearer when used directly (if at all).<p>
<b class="fname">gcq_remove</b>() returns the element removed and is always a valid operation after initialization. <b class="fname">gcq_onlist</b>() returns <span class="define">false</span> if the structure links to itself and <span class="define">true</span> otherwise. <b class="fname">gcq_empty</b>() is the negation of this operation performed on a head. <b class="fname">gcq_linked</b>() tests if <code class="lit">prev-&gt;q_next == next &amp;&amp; next-&gt;q_prev == prev</code>.<p>
<b class="fname">gcq_tie</b>() ties <b class="var">src</b> after <b class="var">dst</b> such that that if the old lists are DST, DST2 and SRC, SRC2, the new list is DST, SRC, SRC2, DST2. If <b class="var">dst</b> and <b class="var">src</b> are on the same list then any elements between but not including <b class="var">dst</b> and <b class="var">src</b> are cut from the list. If <code class="lit">dst == src</code> then the result is the same as <b class="fname">gcq_remove</b>(). <b class="fname">gcq_tie</b>() is equivalent to <b class="fname">gcq_tie_after</b>() except that the latter must only be used with arguments on separate lists or not on lists and asserts that <code class="lit">src != dst &amp;&amp; dst-&gt;q_prev != src</code>. <b class="fname">gcq_tie_before</b>() performs the same operation on <code class="lit">dst-&gt;q_prev</code>.<p>
<b class="fname">gcq_merge</b>() moves any elements on list <b class="var">src</b> (but not <b class="var">src</b> itself) to list <b class="var">dst</b>. It is normally used with two heads via <b class="fname">gcq_merge_head</b>() or <b class="fname">gcq_merge_tail</b>(). If <span class="define">GCQ_UNCONDITIONAL_MERGE</span> is defined prior to header inclusion then the merge operations will always perform a tie then remove <b class="var">src</b> from the new list, which may reduce code size slightly.<p>
<b class="fname">gcq_clear</b>() initializes all elements currently linked with <b class="var">q</b> and is normally used with a head as <b class="fname">gcq_remove_all</b>().<p>
<b class="fname">gcq_insert_after</b>() and <b class="fname">gcq_insert_before</b>() are slightly optimized versions of <b class="fname">gcq_tie</b>() for the case where <b class="var">off</b> is not on a list and include assertions to this effect, which are also useful to detect missing initialization. <b class="fname">gcq_insert_head</b>() and <b class="fname">gcq_insert_tail</b>() are the same operations applied to a head.<p>
<b class="fname">GCQ_GOT_FIRST</b>() and <b class="fname">GCQ_GOT_LAST</b>() set <b class="var">var</b> to a pointer to the first or last <span class="type">struct gcq</span> in the list or <span class="define">NULL</span> if the list is empty and return <span class="define">false</span> if empty and <span class="define">true</span> otherwise. The boolean return is to emphasise that it is not normally safe and useful to directly pass the raw first/next/etc. pointer to another function. The macros are written such that the <span class="define">NULL</span> values will be optimized out if not otherwise used. <code class="lit">DEQUEUED</code> variants also remove the member from the list. <code class="lit">COND</code> variants take an additional condition that is evaluated when the macro would otherwise return <span class="define">true</span>. If the condition is false <b class="var">var</b> or <b class="var">tvar</b> is set to <span class="define">NULL</span> and no dequeue is performed.<p>
<b class="fname">GCQ_GOT_NEXT</b>() and variants take pointers to the current position, list head, and starting point as arguments. The list head will be skipped when it is reached unless it is equal to the starting point; upon reaching the starting point <b class="var">var</b> will be set to <span class="define">NULL</span> and the macro will return <span class="define">false</span>. The next and prev macros also assert that <b class="var">current</b> is on the list unless it is equal to <b class="var">start</b>. These macros are the only provided method for iterating through the list from an arbitrary point. Traversal macros are only provided for list heads, however <b class="fname">gcq_head</b>() can be used to treat any item as a head.<p>
Foreach variants contain an embedded <code class="lit">for</code> statement for iterating over a list. Those containing <code class="lit">REV</code> use the <b class="var">q_prev</b> pointer for traversal, others use <b class="var">q_next</b>. The plain <b class="fname">GCQ_FOREACH</b>() uses a single variable. <code class="lit">NVAR</code> variants save the next pointer at the top of the loop so that the current element can be removed without adjusting <b class="var">var</b>. This is useful when <b class="var">var</b> is passed to a function that might remove it but will not otherwise modify the list. When the head is reached both <b class="var">var</b> and <b class="var">nvar</b> elements are left pointing to the list head. <code class="lit">FOREACH</code> asserts that <b class="var">var</b>, and <code class="lit">NVAR</code> asserts that <b class="var">nvar</b> does not point to itself when starting the next loop. This assertion takes place after the variable is tested against the head so it is safe to remove all elements from the list. <code class="lit">RO</code> variants also set <b class="var">nvar</b> but assert that the two variables are linked at the end of each iteration. This is useful when calling a function that is not supposed to remove the element passed. <code class="lit">DEQUEUED</code> variants are like <code class="lit">NVAR</code> but remove each element before the code block is executed. <code class="lit">TYPED</code> variants are equivalent to the untyped versions except that they take three extra arguments: a typed pointer, the type name, and the member name of the <span class="type">struct gcq</span> used in this list. <b class="var">tvar</b> is set to <span class="define">NULL</span> when the head is reached.<p>
<b class="fname">GCQ_FIND</b>() is a foreach loop that does nothing except break when the supplied condition is true. <code class="lit">REV</code> and <code class="lit">TYPED</code> variants are available.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../1/gcc">gcc(1)</a>, <a class="link-man" href="../3/_DIAGASSERT">_DIAGASSERT(3)</a>, <a class="link-man" href="../3/assert">assert(3)</a>, <a class="link-man" href="../3/queue">queue(3)</a>, <a class="link-man" href="../9/KASSERT">KASSERT(9)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> GCQ appeared in <span class="unix">NetBSD&#160;5.0</span>.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
May 1, 2007</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

