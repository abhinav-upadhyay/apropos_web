<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="/static/man_pages/netbsd/style.css" type="text/css" media="all">
<title>
EDITLINE(3)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
EDITLINE(3)</td>
<td class="head-vol" align="center">
Library Functions Manual</td>
<td class="head-rtitle" align="right">
EDITLINE(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">editline</b>, <b class="name">el_init</b>, <b class="name">el_init_fd</b>, <b class="name">el_end</b>, <b class="name">el_reset</b>, <b class="name">el_gets</b>, <b class="name">el_wgets</b>, <b class="name">el_getc</b>, <b class="name">el_wgetc</b>, <b class="name">el_push</b>, <b class="name">el_wpush</b>, <b class="name">el_parse</b>, <b class="name">el_wparse</b>, <b class="name">el_set</b>, <b class="name">el_wset</b>, <b class="name">el_get</b>, <b class="name">el_wget</b>, <b class="name">el_source</b>, <b class="name">el_resize</b>, <b class="name">el_cursor</b>, <b class="name">el_line</b>, <b class="name">el_wline</b>, <b class="name">el_insertstr</b>, <b class="name">el_winsertstr</b>, <b class="name">el_deletestr</b>, <b class="name">el_wdeletestr</b>, <b class="name">history_init</b>, <b class="name">history_winit</b>, <b class="name">history_end</b>, <b class="name">history_wend</b>, <b class="name">history</b>, <b class="name">history_w</b>, <b class="name">tok_init</b>, <b class="name">tok_winit</b>, <b class="name">tok_end</b>, <b class="name">tok_wend</b>, <b class="name">tok_reset</b>, <b class="name">tok_wreset</b>, <b class="name">tok_line</b>, <b class="name">tok_wline</b>, <b class="name">tok_str</b> <b class="name">tok_wstr</b> &#8212; <span class="desc">line editor, history and tokenization functions</span></div>
<div class="section">
<h1 id="x4c494252415259">LIBRARY</h1> <span class="lib">Command Line Editor Library (libedit, &#45;ledit)</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">histedit.h</a>&gt;</b><p>
<i class="ftype">EditLine *</i><br>
<b class="fname">el_init</b>(<i class="farg" style="white-space:nowrap;">const char *prog</i>, <i class="farg" style="white-space:nowrap;">FILE *fin</i>, <i class="farg" style="white-space:nowrap;">FILE *fout</i>, <i class="farg" style="white-space:nowrap;">FILE *ferr</i>);<p>
<i class="ftype">EditLine *</i><br>
<b class="fname">el_init_fd</b>(<i class="farg" style="white-space:nowrap;">const char *prog</i>, <i class="farg" style="white-space:nowrap;">FILE *fin</i>, <i class="farg" style="white-space:nowrap;">FILE *fout</i>, <i class="farg" style="white-space:nowrap;">FILE *ferr</i>, <i class="farg" style="white-space:nowrap;">int fdin</i>, <i class="farg" style="white-space:nowrap;">int fdout</i>, <i class="farg" style="white-space:nowrap;">int fderr</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">el_end</b>(<i class="farg" style="white-space:nowrap;">EditLine *e</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">el_reset</b>(<i class="farg" style="white-space:nowrap;">EditLine *e</i>);<p>
<i class="ftype">const char *</i><br>
<b class="fname">el_gets</b>(<i class="farg" style="white-space:nowrap;">EditLine *e</i>, <i class="farg" style="white-space:nowrap;">int *count</i>);<p>
<i class="ftype">const wchar_t *</i><br>
<b class="fname">el_wgets</b>(<i class="farg" style="white-space:nowrap;">EditLine *e</i>, <i class="farg" style="white-space:nowrap;">int *count</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">el_getc</b>(<i class="farg" style="white-space:nowrap;">EditLine *e</i>, <i class="farg" style="white-space:nowrap;">char *ch</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">el_wgetc</b>(<i class="farg" style="white-space:nowrap;">EditLine *e</i>, <i class="farg" style="white-space:nowrap;">wchar_t *ch</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">el_push</b>(<i class="farg" style="white-space:nowrap;">EditLine *e</i>, <i class="farg" style="white-space:nowrap;">const char *str</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">el_wpush</b>(<i class="farg" style="white-space:nowrap;">EditLine *e</i>, <i class="farg" style="white-space:nowrap;">const wchar_t *str</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">el_parse</b>(<i class="farg" style="white-space:nowrap;">EditLine *e</i>, <i class="farg" style="white-space:nowrap;">int argc</i>, <i class="farg" style="white-space:nowrap;">const char *argv[]</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">el_wparse</b>(<i class="farg" style="white-space:nowrap;">EditLine *e</i>, <i class="farg" style="white-space:nowrap;">int argc</i>, <i class="farg" style="white-space:nowrap;">const wchar_t *argv[]</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">el_set</b>(<i class="farg" style="white-space:nowrap;">EditLine *e</i>, <i class="farg" style="white-space:nowrap;">int op</i>, <i class="farg" style="white-space:nowrap;">...</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">el_wset</b>(<i class="farg" style="white-space:nowrap;">EditLine *e</i>, <i class="farg" style="white-space:nowrap;">int op</i>, <i class="farg" style="white-space:nowrap;">...</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">el_get</b>(<i class="farg" style="white-space:nowrap;">EditLine *e</i>, <i class="farg" style="white-space:nowrap;">int op</i>, <i class="farg" style="white-space:nowrap;">...</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">el_wget</b>(<i class="farg" style="white-space:nowrap;">EditLine *e</i>, <i class="farg" style="white-space:nowrap;">int op</i>, <i class="farg" style="white-space:nowrap;">...</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">el_source</b>(<i class="farg" style="white-space:nowrap;">EditLine *e</i>, <i class="farg" style="white-space:nowrap;">const char *file</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">el_resize</b>(<i class="farg" style="white-space:nowrap;">EditLine *e</i>);<p>
<b class="fname">int</b>();<p>
<b class="fname">el_cursor</b>(<i class="farg" style="white-space:nowrap;">EditLine *e</i>, <i class="farg" style="white-space:nowrap;">int count</i>);<p>
<i class="ftype">const LineInfo *</i><br>
<b class="fname">el_line</b>(<i class="farg" style="white-space:nowrap;">EditLine *e</i>);<p>
<i class="ftype">const LineInfoW *</i><br>
<b class="fname">el_wline</b>(<i class="farg" style="white-space:nowrap;">EditLine *e</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">el_insertstr</b>(<i class="farg" style="white-space:nowrap;">EditLine *e</i>, <i class="farg" style="white-space:nowrap;">const char *str</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">el_winsertstr</b>(<i class="farg" style="white-space:nowrap;">EditLine *e</i>, <i class="farg" style="white-space:nowrap;">const wchar_t *str</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">el_deletestr</b>(<i class="farg" style="white-space:nowrap;">EditLine *e</i>, <i class="farg" style="white-space:nowrap;">int count</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">el_wdeletestr</b>(<i class="farg" style="white-space:nowrap;">EditLine *e</i>, <i class="farg" style="white-space:nowrap;">int count</i>);<p>
<i class="ftype">History *</i><br>
<b class="fname">history_init</b>();<p>
<i class="ftype">HistoryW *</i><br>
<b class="fname">history_winit</b>();<p>
<i class="ftype">void</i><br>
<b class="fname">history_end</b>(<i class="farg" style="white-space:nowrap;">History *h</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">history_wend</b>(<i class="farg" style="white-space:nowrap;">HistoryW *h</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">history</b>(<i class="farg" style="white-space:nowrap;">History *h</i>, <i class="farg" style="white-space:nowrap;">HistEvent *ev</i>, <i class="farg" style="white-space:nowrap;">int op</i>, <i class="farg" style="white-space:nowrap;">...</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">history_w</b>(<i class="farg" style="white-space:nowrap;">HistoryW *h</i>, <i class="farg" style="white-space:nowrap;">HistEventW *ev</i>, <i class="farg" style="white-space:nowrap;">int op</i>, <i class="farg" style="white-space:nowrap;">...</i>);<p>
<i class="ftype">Tokenizer *</i><br>
<b class="fname">tok_init</b>(<i class="farg" style="white-space:nowrap;">const char *IFS</i>);<p>
<i class="ftype">TokenizerW *</i><br>
<b class="fname">tok_winit</b>(<i class="farg" style="white-space:nowrap;">const wchar_t *IFS</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">tok_end</b>(<i class="farg" style="white-space:nowrap;">Tokenizer *t</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">tok_wend</b>(<i class="farg" style="white-space:nowrap;">TokenizerW *t</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">tok_reset</b>(<i class="farg" style="white-space:nowrap;">Tokenizer *t</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">tok_wreset</b>(<i class="farg" style="white-space:nowrap;">TokenizerW *t</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">tok_line</b>(<i class="farg" style="white-space:nowrap;">Tokenizer *t</i>, <i class="farg" style="white-space:nowrap;">const LineInfo *li</i>, <i class="farg" style="white-space:nowrap;">int *argc</i>, <i class="farg" style="white-space:nowrap;">const char **argv[]</i>, <i class="farg" style="white-space:nowrap;">int *cursorc</i>, <i class="farg" style="white-space:nowrap;">int *cursoro</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">tok_wline</b>(<i class="farg" style="white-space:nowrap;">TokenizerW *t</i>, <i class="farg" style="white-space:nowrap;">const LineInfoW *li</i>, <i class="farg" style="white-space:nowrap;">int *argc</i>, <i class="farg" style="white-space:nowrap;">const wchar_t **argv[]</i>, <i class="farg" style="white-space:nowrap;">int *cursorc</i>, <i class="farg" style="white-space:nowrap;">int *cursoro</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">tok_str</b>(<i class="farg" style="white-space:nowrap;">Tokenizer *t</i>, <i class="farg" style="white-space:nowrap;">const char *str</i>, <i class="farg" style="white-space:nowrap;">int *argc</i>, <i class="farg" style="white-space:nowrap;">const char **argv[]</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">tok_wstr</b>(<i class="farg" style="white-space:nowrap;">TokenizerW *t</i>, <i class="farg" style="white-space:nowrap;">const wchar_t *str</i>, <i class="farg" style="white-space:nowrap;">int *argc</i>, <i class="farg" style="white-space:nowrap;">const wchar_t **argv[]</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <b class="name">editline</b> library provides generic line editing, history and tokenization functions, similar to those found in <a class="link-man" href="../1/sh">sh(1)</a>.<p>
These functions are available in the <b class="name">libedit</b> library (which needs the <b class="name">libtermcap</b> library). Programs should be linked with <b class="flag">&#45;ledit</b> <b class="flag">&#45;ltermcap</b>.</div>
<div class="section">
<h1 id="x4c494e452045444954494e472046554e4354494f4e53">LINE EDITING FUNCTIONS</h1> The line editing functions use a common data structure, <i class="farg">EditLine</i>, which is created by <b class="fname">el_init</b>() or <b class="fname">el_init_fd</b>() and freed by <b class="fname">el_end</b>().<p>
The wide-character functions behave the same way as their narrow counterparts.<p>
The following functions are available:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">el_init</b>()</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Initialise the line editor, and return a data structure to be used by all other line editing functions, or <span class="define">NULL</span> on failure. <i class="farg">prog</i> is the name of the invoking program, used when reading the <a class="link-man" href="../5/editrc">editrc(5)</a> file to determine which settings to use. <i class="farg">fin</i>, <i class="farg">fout</i> and <i class="farg">ferr</i> are the input, output, and error streams (respectively) to use. In this documentation, references to &#8220;the tty&#8221; are actually to this input/output stream combination.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">el_init_fd</b>()</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Like <b class="fname">el_init</b>() but allows specifying file descriptors for the <a class="link-man" href="../3/stdio">stdio(3)</a> corresponding streams, in case those were created with <a class="link-man" href="../3/funopen">funopen(3)</a>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">el_end</b>()</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Clean up and finish with <i class="farg">e</i>, assumed to have been created with <b class="fname">el_init</b>() or <b class="fname">el_init_fd</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">el_reset</b>()</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Reset the tty and the parser. This should be called after an error which may have upset the tty's state.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">el_gets</b>()</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Read a line from the tty. <i class="farg">count</i> is modified to contain the number of characters read. Returns the line read if successful, or <span class="define">NULL</span> if no characters were read or if an error occurred. If an error occurred, <i class="farg">count</i> is set to &#45;1 and <span class="define">errno</span> contains the error code that caused it. The return value may not remain valid across calls to <b class="fname">el_gets</b>() and must be copied if the data is to be retained.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">el_getc</b>()</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Read a character from the tty. <i class="farg">ch</i> is modified to contain the character read. Returns the number of characters read if successful, &#45;1 otherwise, in which case <span class="define">errno</span> can be inspected for the cause.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">el_push</b>()</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Pushes <i class="farg">str</i> back onto the input stream. This is used by the macro expansion mechanism. Refer to the description of <b class="cmd">bind</b> <b class="flag">&#45;s</b> in <a class="link-man" href="../5/editrc">editrc(5)</a> for more information.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">el_parse</b>()</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Parses the <i class="farg">argv</i> array (which is <i class="farg">argc</i> elements in size) to execute builtin <b class="name">editline</b> commands. If the command is prefixed with &#8220;prog&#8221;: then <b class="fname">el_parse</b>() will only execute the command if &#8220;prog&#8221; matches the <i class="farg">prog</i> argument supplied to <b class="fname">el_init</b>(). The return value is &#45;1 if the command is unknown, 0 if there was no error or &#8220;prog&#8221; didn't match, or 1 if the command returned an error. Refer to <a class="link-man" href="../5/editrc">editrc(5)</a> for more information.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">el_set</b>()</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Set <b class="name">editline</b> parameters. <i class="farg">op</i> determines which parameter to set, and each operation has its own parameter list. Returns 0 on success, &#45;1 on failure.<p>
The following values for <i class="farg">op</i> are supported, along with the required argument list:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">EL_PROMPT</span>, <i class="farg">char *(*f)(EditLine *)</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Define prompt printing function as <i class="farg">f</i>, which is to return a string that contains the prompt.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">EL_PROMPT_ESC</span>, <i class="farg">char *(*f)(EditLine *)</i>, <i class="farg">char c</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Same as <span class="define">EL_PROMPT</span>, but the <i class="farg">c</i> argument indicates the start/stop literal prompt character.<p>
If a start/stop literal character is found in the prompt, the character itself is not printed, but characters after it are printed directly to the terminal without affecting the state of the current line. A subsequent second start/stop literal character ends this behavior. This is typically used to embed literal escape sequences that change the color/style of the terminal in the prompt. <span class="define">0</span> unsets it.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">EL_REFRESH</span></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Re-display the current line on the next terminal line.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">EL_RPROMPT</span>, <i class="farg">char *(*f)(EditLine *)</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Define right side prompt printing function as <i class="farg">f</i>, which is to return a string that contains the prompt.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">EL_RPROMPT_ESC</span>, <i class="farg">char *(*f)(EditLine *)</i>, <i class="farg">char c</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Define the right prompt printing function but with a literal escape character.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">EL_TERMINAL</span>, <i class="farg">const char *type</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Define terminal type of the tty to be <i class="farg">type</i>, or to <span class="env">TERM</span> if <i class="farg">type</i> is <span class="define">NULL</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">EL_EDITOR</span>, <i class="farg">const char *mode</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Set editing mode to <i class="farg">mode</i>, which must be one of &#8220;emacs&#8221; or &#8220;vi&#8221;.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">EL_SIGNAL</span>, <i class="farg">int flag</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
If <i class="farg">flag</i> is non-zero, <b class="name">editline</b> will install its own signal handler for the following signals when reading command input: <span class="define">SIGCONT</span>, <span class="define">SIGHUP</span>, <span class="define">SIGINT</span>, <span class="define">SIGQUIT</span>, <span class="define">SIGSTOP</span>, <span class="define">SIGTERM</span>, <span class="define">SIGTSTP</span>, and <span class="define">SIGWINCH</span>. Otherwise, the current signal handlers will be used.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">EL_BIND</span>, <i class="farg">const char *</i>, <i class="farg">...</i>, <span class="define">NULL</span></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Perform the <b class="cmd">bind</b> builtin command. Refer to <a class="link-man" href="../5/editrc">editrc(5)</a> for more information.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">EL_ECHOTC</span>, <i class="farg">const char *</i>, <i class="farg">...</i>, <span class="define">NULL</span></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Perform the <b class="cmd">echotc</b> builtin command. Refer to <a class="link-man" href="../5/editrc">editrc(5)</a> for more information.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">EL_SETTC</span>, <i class="farg">const char *</i>, <i class="farg">...</i>, <span class="define">NULL</span></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Perform the <b class="cmd">settc</b> builtin command. Refer to <a class="link-man" href="../5/editrc">editrc(5)</a> for more information.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">EL_SETTY</span>, <i class="farg">const char *</i>, <i class="farg">...</i>, <span class="define">NULL</span></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Perform the <b class="cmd">setty</b> builtin command. Refer to <a class="link-man" href="../5/editrc">editrc(5)</a> for more information.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">EL_TELLTC</span>, <i class="farg">const char *</i>, <i class="farg">...</i>, <span class="define">NULL</span></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Perform the <b class="cmd">telltc</b> builtin command. Refer to <a class="link-man" href="../5/editrc">editrc(5)</a> for more information.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">EL_ADDFN</span>, <i class="farg">const char *name</i>, <i class="farg">const char *help</i>, <i class="farg">unsigned char (*func)(EditLine *e, int ch)</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Add a user defined function, <b class="fname">func</b>(), referred to as <i class="farg">name</i> which is invoked when a key which is bound to <i class="farg">name</i> is entered. <i class="farg">help</i> is a description of <i class="farg">name</i>. At invocation time, <i class="farg">ch</i> is the key which caused the invocation. The return value of <b class="fname">func</b>() should be one of:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">CC_NORM</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Add a normal character.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">CC_NEWLINE</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
End of line was entered.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">CC_EOF</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
EOF was entered.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">CC_ARGHACK</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Expecting further command input as arguments, do nothing visually.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">CC_REFRESH</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Refresh display.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">CC_REFRESH_BEEP</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Refresh display, and beep.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">CC_CURSOR</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Cursor moved, so update and perform <span class="define">CC_REFRESH</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">CC_REDISPLAY</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Redisplay entire input line. This is useful if a key binding outputs extra information.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">CC_ERROR</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
An error occurred. Beep, and flush tty.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">CC_FATAL</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Fatal error, reset tty to known state.</dd>
</dl>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">EL_HIST</span>, <i class="farg">History *(*func)(History *, int op, ...)</i>, <i class="farg">const char *ptr</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Defines which history function to use, which is usually <b class="fname">history</b>(). <i class="farg">ptr</i> should be the value returned by <b class="fname">history_init</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">EL_EDITMODE</span>, <i class="farg">int flag</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
If <i class="farg">flag</i> is non-zero, editing is enabled (the default). Note that this is only an indication, and does not affect the operation of <b class="name">editline</b>. At this time, it is the caller's responsibility to check this (using <b class="fname">el_get</b>()) to determine if editing should be enabled or not.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">EL_UNBUFFERED</span>, <i class="farg">int flag</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
If <i class="farg">flag</i> is zero, unbuffered mode is disabled (the default). In unbuffered mode, <b class="fname">el_gets</b>() will return immediately after processing a single character.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">EL_GETCFN</span>, <i class="farg">int (*f)(EditLine *, char *c)</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Define the character reading function as <i class="farg">f</i>, which is to return the number of characters read and store them in <i class="farg">c</i>. This function is called internally by <b class="fname">el_gets</b>() and <b class="fname">el_getc</b>(). The builtin function can be set or restored with the special function name &#8220;<span class="define">EL_BUILTIN_GETCFN</span>&#8221;.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">EL_CLIENTDATA</span>, <i class="farg">void *data</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Register <i class="farg">data</i> to be associated with this EditLine structure. It can be retrieved with the corresponding <b class="fname">el_get</b>() call.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">EL_SETFP</span>, <i class="farg">int fd</i>, <i class="farg">FILE *fp</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Set the current <b class="name">editline</b> file pointer for &#8220;input&#8221; <i class="farg">fd</i> = <span class="define">0</span>, &#8220;output&#8221; <i class="farg">fd</i> = <span class="define">1</span>, or &#8220;error&#8221; <i class="farg">fd</i> = <span class="define">2</span> from <i class="farg">fp</i>.</dd>
</dl>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">el_get</b>()</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Get <b class="name">editline</b> parameters. <i class="farg">op</i> determines which parameter to retrieve into <i class="farg">result</i>. Returns 0 if successful, &#45;1 otherwise.<p>
The following values for <i class="farg">op</i> are supported, along with actual type of <i class="farg">result</i>:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">EL_PROMPT</span>, <i class="farg">char *(*f)(EditLine *)</i>, <i class="farg">char *c</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Return a pointer to the function that displays the prompt in <i class="farg">f</i>. If <i class="farg">c</i> is not <span class="define">NULL</span>, return the start/stop literal prompt character in it.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">EL_RPROMPT</span>, <i class="farg">char *(*f)(EditLine *)</i>, <i class="farg">char *c</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Return a pointer to the function that displays the prompt in <i class="farg">f</i>. If <i class="farg">c</i> is not <span class="define">NULL</span>, return the start/stop literal prompt character in it.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">EL_EDITOR</span>, <i class="farg">const char **</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Return the name of the editor, which will be one of &#8220;emacs&#8221; or &#8220;vi&#8221;.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">EL_GETTC</span>, <i class="farg">const char *name</i>, <i class="farg">void *value</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Return non-zero if <i class="farg">name</i> is a valid <a class="link-man" href="../5/termcap">termcap(5)</a> capability and set <i class="farg">value</i> to the current value of that capability.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">EL_SIGNAL</span>, <i class="farg">int *</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Return non-zero if <b class="name">editline</b> has installed private signal handlers (see <b class="fname">el_get</b>() above).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">EL_EDITMODE</span>, <i class="farg">int *</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Return non-zero if editing is enabled.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">EL_GETCFN</span>, <i class="farg">int (**f)(EditLine *, char *)</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Return a pointer to the function that read characters, which is equal to &#8220;<span class="define">EL_BUILTIN_GETCFN</span>&#8221; in the case of the default builtin function.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">EL_CLIENTDATA</span>, <i class="farg">void **data</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Retrieve <i class="farg">data</i> previously registered with the corresponding <b class="fname">el_set</b>() call.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">EL_UNBUFFERED</span>, <i class="farg">int</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Return non-zero if unbuffered mode is enabled.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">EL_PREP_TERM</span>, <i class="farg">int</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Sets or clears terminal editing mode.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">EL_GETFP</span>, <i class="farg">int fd</i>, <i class="farg">FILE **fp</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Return in <i class="farg">fp</i> the current <b class="name">editline</b> file pointer for &#8220;input&#8221; <i class="farg">fd</i> = <span class="define">0</span>, &#8220;output&#8221; <i class="farg">fd</i> = <span class="define">1</span>, or &#8220;error&#8221; <i class="farg">fd</i> = <span class="define">2</span>.</dd>
</dl>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">el_source</b>()</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Initialise <b class="name">editline</b> by reading the contents of <i class="farg">file</i>. <b class="fname">el_parse</b>() is called for each line in <i class="farg">file</i>. If <i class="farg">file</i> is <span class="define">NULL</span>, try <i class="file">$HOME/.editrc</i>. Refer to <a class="link-man" href="../5/editrc">editrc(5)</a> for details on the format of <i class="farg">file</i>. <b class="fname">el_source</b>() returns 0 on success and &#45;1 on error.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">el_resize</b>()</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Must be called if the terminal size changes. If <span class="define">EL_SIGNAL</span> has been set with <b class="fname">el_set</b>(), then this is done automatically. Otherwise, it's the responsibility of the application to call <b class="fname">el_resize</b>() on the appropriate occasions.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">el_cursor</b>()</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Move the cursor to the right (if positive) or to the left (if negative) <i class="farg">count</i> characters. Returns the resulting offset of the cursor from the beginning of the line.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">el_line</b>()</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Return the editing information for the current line in a <i class="farg">LineInfo</i> structure, which is defined as follows:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
typedef struct lineinfo { 
    const char *buffer;    /* address of buffer */ 
    const char *cursor;    /* address of cursor */ 
    const char *lastchar;  /* address of last character */ 
} LineInfo;</pre>
<p>
<i class="farg">buffer</i> is not NUL terminated. This function may be called after <b class="fname">el_gets</b>() to obtain the <i class="farg">LineInfo</i> structure pertaining to line returned by that function, and from within user defined functions added with <span class="define">EL_ADDFN</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">el_insertstr</b>()</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Insert <i class="farg">str</i> into the line at the cursor. Returns &#45;1 if <i class="farg">str</i> is empty or won't fit, and 0 otherwise.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">el_deletestr</b>()</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Delete <i class="farg">count</i> characters before the cursor.</dd>
</dl>
</div>
<div class="section">
<h1 id="x484953544f5259204c4953542046554e4354494f4e53">HISTORY LIST FUNCTIONS</h1> The history functions use a common data structure, <i class="farg">History</i>, which is created by <b class="fname">history_init</b>() and freed by <b class="fname">history_end</b>().<p>
The following functions are available:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">history_init</b>()</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Initialise the history list, and return a data structure to be used by all other history list functions, or <span class="define">NULL</span> on failure.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">history_end</b>()</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Clean up and finish with <i class="farg">h</i>, assumed to have been created with <b class="fname">history_init</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">history</b>()</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Perform operation <i class="farg">op</i> on the history list, with optional arguments as needed by the operation. <i class="farg">ev</i> is changed accordingly to operation. The following values for <i class="farg">op</i> are supported, along with the required argument list:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">H_SETSIZE</span>, <i class="farg">int size</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Set size of history to <i class="farg">size</i> elements.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">H_GETSIZE</span></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Get number of events currently in history.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">H_END</span></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Cleans up and finishes with <i class="farg">h</i>, assumed to be created with <b class="fname">history_init</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">H_CLEAR</span></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Clear the history.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">H_FUNC</span>, <i class="farg">void *ptr</i>, <i class="farg">history_gfun_t first</i>, <i class="farg">history_gfun_t next</i>, <i class="farg">history_gfun_t last</i>, <i class="farg">history_gfun_t prev</i>, <i class="farg">history_gfun_t curr</i>, <i class="farg">history_sfun_t set</i>, <i class="farg">history_vfun_t clear</i>, <i class="farg">history_efun_t enter</i>, <i class="farg">history_efun_t add</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Define functions to perform various history operations. <i class="farg">ptr</i> is the argument given to a function when it's invoked.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">H_FIRST</span></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Return the first element in the history.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">H_LAST</span></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Return the last element in the history.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">H_PREV</span></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Return the previous element in the history.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">H_NEXT</span></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Return the next element in the history.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">H_CURR</span></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Return the current element in the history.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">H_SET</span></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Set the cursor to point to the requested element.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">H_ADD</span>, <i class="farg">const char *str</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Append <i class="farg">str</i> to the current element of the history, or perform the <span class="define">H_ENTER</span> operation with argument <i class="farg">str</i> if there is no current element.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">H_APPEND</span>, <i class="farg">const char *str</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Append <i class="farg">str</i> to the last new element of the history.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">H_ENTER</span>, <i class="farg">const char *str</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Add <i class="farg">str</i> as a new element to the history, and, if necessary, removing the oldest entry to keep the list to the created size. If <span class="define">H_SETUNIQUE</span> has been called with a non-zero argument, the element will not be entered into the history if its contents match the ones of the current history element. If the element is entered <b class="fname">history</b>() returns 1; if it is ignored as a duplicate returns 0. Finally <b class="fname">history</b>() returns &#45;1 if an error occurred.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">H_PREV_STR</span>, <i class="farg">const char *str</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Return the closest previous event that starts with <i class="farg">str</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">H_NEXT_STR</span>, <i class="farg">const char *str</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Return the closest next event that starts with <i class="farg">str</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">H_PREV_EVENT</span>, <i class="farg">int e</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Return the previous event numbered <i class="farg">e</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">H_NEXT_EVENT</span>, <i class="farg">int e</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Return the next event numbered <i class="farg">e</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">H_LOAD</span>, <i class="farg">const char *file</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Load the history list stored in <i class="farg">file</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">H_SAVE</span>, <i class="farg">const char *file</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Save the history list to <i class="farg">file</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">H_SAVE_FP</span>, <i class="farg">FILE *fp</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Save the history list to the opened <i class="ftype">FILE</i> pointer <i class="farg">fp</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">H_SETUNIQUE</span>, <i class="farg">int unique</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Set flag that adjacent identical event strings should not be entered into the history.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">H_GETUNIQUE</span></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Retrieve the current setting if adjacent identical elements should be entered into the history.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">H_DEL</span>, <i class="farg">int e</i></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Delete the event numbered <i class="farg">e</i>. This function is only provided for <a class="link-man" href="../3/readline">readline(3)</a> compatibility. The caller is responsible for free'ing the string in the returned <i class="farg">HistEvent</i>.</dd>
</dl>
<p>
<b class="fname">history</b>() returns &gt;= 0 if the operation <i class="farg">op</i> succeeds. Otherwise, &#45;1 is returned and <i class="farg">ev</i> is updated to contain more details about the error.</dd>
</dl>
</div>
<div class="section">
<h1 id="x544f4b454e495a4154494f4e2046554e4354494f4e53">TOKENIZATION FUNCTIONS</h1> The tokenization functions use a common data structure, <i class="farg">Tokenizer</i>, which is created by <b class="fname">tok_init</b>() and freed by <b class="fname">tok_end</b>().<p>
The following functions are available:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">tok_init</b>()</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Initialise the tokenizer, and return a data structure to be used by all other tokenizer functions. <i class="farg">IFS</i> contains the Input Field Separators, which defaults to &#60;space&#62;, &#60;tab&#62;, and &#60;newline&#62; if <span class="define">NULL</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">tok_end</b>()</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Clean up and finish with <i class="farg">t</i>, assumed to have been created with <b class="fname">tok_init</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">tok_reset</b>()</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Reset the tokenizer state. Use after a line has been successfully tokenized by <b class="fname">tok_line</b>() or <b class="fname">tok_str</b>() and before a new line is to be tokenized.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">tok_line</b>()</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Tokenize <i class="farg">li</i>, If successful, modify: <i class="farg">argv</i> to contain the words, <i class="farg">argc</i> to contain the number of words, <i class="farg">cursorc</i> (if not <span class="define">NULL</span>) to contain the index of the word containing the cursor, and <i class="farg">cursoro</i> (if not <span class="define">NULL</span>) to contain the offset within <i class="farg">argv[cursorc]</i> of the cursor.<p>
Returns 0 if successful, &#45;1 for an internal error, 1 for an unmatched single quote, 2 for an unmatched double quote, and 3 for a backslash quoted &#60;newline&#62;. A positive exit code indicates that another line should be read and tokenization attempted again.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">tok_str</b>()</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
A simpler form of <b class="fname">tok_line</b>(); <i class="farg">str</i> is a NUL terminated string to tokenize.</dd>
</dl>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../1/sh">sh(1)</a>, <a class="link-man" href="../3/signal">signal(3)</a>, <a class="link-man" href="../3/termcap">termcap(3)</a>, <a class="link-man" href="../5/editrc">editrc(5)</a>, <a class="link-man" href="../5/termcap">termcap(5)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The <b class="name">editline</b> library first appeared in <span class="unix">4.4BSD</span>. <span class="define">CC_REDISPLAY</span> appeared in <span class="unix">NetBSD&#160;1.3</span>. <span class="define">CC_REFRESH_BEEP</span>, <span class="define">EL_EDITMODE</span> and the readline emulation appeared in <span class="unix">NetBSD&#160;1.4</span>. <span class="define">EL_RPROMPT</span> appeared in <span class="unix">NetBSD&#160;1.5</span>.</div>
<div class="section">
<h1 id="x415554484f5253">AUTHORS</h1> <span class="author"></span>The <b class="name">editline</b> library was written by <span class="author">Christos Zoulas</span>. <span class="author">Luke Mewburn</span> wrote this manual and implemented <span class="define">CC_REDISPLAY</span>, <span class="define">CC_REFRESH_BEEP</span>, <span class="define">EL_EDITMODE</span>, and <span class="define">EL_RPROMPT</span>. <span class="author">Jaromir Dolecek</span> implemented the readline emulation. <span class="author">Johny Mattsson</span> implemented wide-character support.</div>
<div class="section">
<h1 id="x42554753">BUGS</h1> At this time, it is the responsibility of the caller to check the result of the <span class="define">EL_EDITMODE</span> operation of <b class="fname">el_get</b>() (after an <b class="fname">el_source</b>() or <b class="fname">el_parse</b>()) to determine if <b class="name">editline</b> should be used for further input. I.e., <span class="define">EL_EDITMODE</span> is purely an indication of the result of the most recent <a class="link-man" href="../5/editrc">editrc(5)</a> <b class="cmd">edit</b> command.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
December 25, 2014</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

