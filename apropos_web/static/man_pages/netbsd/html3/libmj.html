<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
LIBMJ(3)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
LIBMJ(3)</td>
<td class="head-vol" align="center">
Library Functions Manual</td>
<td class="head-rtitle" align="right">
LIBMJ(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">libmj</b> &#8212; <span class="desc">minimalist JSON lightweight data interchange library</span></div>
<div class="section">
<h1 id="x4c494252415259">LIBRARY</h1> <span class="lib">Minimalist JSON library (libmj, &#45;lmj)</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">mj.h</a>&gt;</b><p>
<i class="ftype">int</i><br>
<b class="fname">mj_create</b>(<i class="farg">mj_t *atom</i>, <i class="farg">const char *text</i>, <i class="farg">...</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">mj_parse</b>(<i class="farg">mj_t *atom</i>, <i class="farg">const char *text</i>, <i class="farg">int *tokfrom</i>, <i class="farg">int *tokto</i>, <i class="farg">int *toktype</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">mj_append</b>(<i class="farg">mj_t *atom</i>, <i class="farg">const char *text</i>, <i class="farg">...</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">mj_append_field</b>(<i class="farg">mj_t *atom</i>, <i class="farg">const char *fieldname</i>, <i class="farg">const char *text</i>, <i class="farg">...</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">mj_deepcopy</b>(<i class="farg">mj_t *dest</i>, <i class="farg">mj_t *src</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">mj_delete</b>(<i class="farg">mj_t *atom</i>);<p>
Access to objects and array entries is made using the following functions:<br>
<i class="ftype">int</i><br>
<b class="fname">mj_arraycount</b>(<i class="farg">mj_t *atom</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">mj_object_find</b>(<i class="farg">mj_t *atom</i>, <i class="farg">const char *name</i>, <i class="farg">const unsigned startpoint</i>, <i class="farg">const unsigned incr</i>);<p>
<i class="ftype">mj_t *</i><br>
<b class="fname">mj_get_atom</b>(<i class="farg">mj_t *atom</i>, <i class="farg">...</i>);<p>
JSON object output functions:<br>
<i class="ftype">int</i><br>
<b class="fname">mj_snprint</b>(<i class="farg">char *buffer</i>, <i class="farg">size_t size</i>, <i class="farg">mj_t *atom</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">mj_asprint</b>(<i class="farg">char **buffer</i>, <i class="farg">mj_t *atom</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">mj_string_size</b>(<i class="farg">mj_t *atom</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">mj_pretty</b>(<i class="farg">mj_t *atom</i>, <i class="farg">void *stream</i>, <i class="farg">unsigned depth</i>, <i class="farg">const char *trailer</i>);<p>
<i class="ftype">const char *</i><br>
<b class="fname">mj_string_rep</b>(<i class="farg">mj_t *atom</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> <b class="name">libmj</b> is a small library interface to allow JSON text to be created and parsed. JSON is the Java Script Object Notation, a lightweight data-interchange format, standardised by the ECMA. The library name <b class="name">libmj</b> is derived from a further acronym of &#8220;minimalist JSON&#8221;.<p>
The <b class="name">libmj</b> library can be used to create a string in memory which contains a textual representation of a number of objects, arbitrarily structured. The library can also be used to reconstruct the structure. Data can thus be serialised easily and efficiently, and data structures rebuilt to produce the original structure of the data.<p>
JSON contains basic units called atoms, the two basic atoms being strings and numbers. Three other useful atomic values are provided: &#8220;null&#8221;, &#8220;false&#8221;, and &#8220;true&#8221;. Atoms can be grouped together as key/value pairs in an &#8220;object&#8221;, and as individual, ordered atoms, in an &#8220;array&#8221;.<p>
To create a new object, the <b class="fname">mj_create</b>() function is used. It can be deleted using the <b class="fname">mj_delete</b>() function.<p>
Atoms, objects and arrays can be appended to arrays and objects using the <b class="fname">mj_append</b>() function.<p>
Objects can be printed out by using the <b class="fname">mj_snprint</b>() function. The size of a string of JSON text can be calculated using the <b class="fname">mj_string_size</b>() function. A utility function <b class="fname">mj_asprint</b>() is provided which will allocate space dynamically, using <a class="link-man" href="../3/calloc">calloc(3)</a>, and the JSON serialised text is copied into it. This memory can later be de-allocated using <a class="link-man" href="../3/free">free(3)</a>. For formatted output to a <span class="type">FILE *</span> stream, the <b class="fname">mj_pretty</b>() function is used. The calling interface gives the ability to indent the output to a given <i class="farg">depth</i> and for the formatted output to be followed by a <i class="farg">trailer</i> string, which is usually <span class="define">NULL</span> for external calls, but can be any valid string. Output is sent to the <i class="farg">stream</i> file stream.<p>
The <i class="farg">type</i> argument given to the <b class="fname">mj_create</b>(), <b class="fname">mj_append</b>(), and <b class="fname">mj_append_field</b>() functions is taken from a list of &#8220;false&#8221; &#8220;true&#8221; &#8220;null&#8221; &#8220;number&#8221; &#8220;integer&#8221; &#8220;string&#8221; &#8220;array&#8221; and &#8220;object&#8221; types. An integer differs from a number in that it cannot take on any floating point values. It is implemented internally using a signed 64-bit integer type. This restriction of values for an integer type may be removed at a later date.<p>
Within a JSON object, the key values can be iterated over using an integer index to access the individual JSON objects. The index can also be found using the <b class="fname">mj_object_find</b>() function.<p>
The way objects arrays are implemented in <b class="name">libmj</b> is by using varying-sized arrays internally. Objects have the field name as the even entry in this internal array, with the value being the odd entry. Arrays are implemented as a simple array. Thus, to find an object in an array using <b class="fname">mj_object_find</b>(), a value of 1 should be used as the increment value. This means that every entry in the internal array will be examined, and the first match after the starting point will be returned. For objects, an incremental value of 2 should be used, and an even start value should be specified.<p>
String values should be created and appended using two parameters in the stdarg fields, that of the string itself, and its length in bytes immediately after the string. A value of <span class="define">&#45;1</span> may be used if the string length is not known.</div>
<div class="section">
<h1 id="x4558414d504c4553">EXAMPLES</h1> The following code fragment will make a JSON object out of the string &#8220;Hello &lt;USERNAME&gt;&#92;n&#8221; in the buffer called <b class="var">buf</b> where &#8220;USERNAME&#8221; is the name of the user taken from the runtime environment. The encoded text will be in an allocated buffer called <b class="var">s</b><p>
<pre style="margin-left: 5.00ex;" class="lit display">
mj_t atom; 
char buf[BUFSIZ]; 
char *s; 
int cc; 
 
(void) memset(&amp;atom, 0x0, sizeof(atom)); 
cc = snprintf(buf, sizeof(buf), "Hello %s&#92;n", getenv("USER")); 
mj_create(&amp;atom, "string", buf, cc); 
cc = mj_asprint(&amp;s, &amp;atom, MJ_JSON_ENCODE);</pre>
<p>
Next, the following example will take the (binary) text which has been encoded into JSON and is in the buffer <b class="var">buf</b>, such as in the previous example, and re-create the original text:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
int from, to, tok, cc; 
char *s; 
mj_t atom; 
 
(void) memset(&amp;atom, 0x0, sizeof(atom)); 
from = to = tok = 0; 
mj_parse(&amp;atom, buf, &amp;from, &amp;to, &amp;tok); 
cc = mj_asprint(&amp;s, &amp;atom, MJ_HUMAN); 
printf("%.*s", cc, s);</pre>
<p>
The <b class="var">s</b> pointer points to allocated storage with the original NUL-terminated string in it.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../3/calloc">calloc(3)</a>, <a class="link-man" href="../3/free">free(3)</a><p>
<span class="ref"><span class="ref-title">ECMA-262: ECMAScript Language Specification</span>, <a class="link-ref" href="http://www.ecma-international.org/publications/files/ecma-st/ECMA-262.pdf">http://www.ecma-international.org/publications/files/ecma-st/ECMA-262.pdf</a>, <span class="ref-corp">Ecma International</span>, <span class="ref-date">December 2009</span>, <span class="ref-opt">5th Edition</span>.</span></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The <b class="name">libmj</b> library first appeared in <span class="unix">NetBSD&#160;6.0</span>.</div>
<div class="section">
<h1 id="x415554484f5253">AUTHORS</h1> <span class="author">Alistair Crooks</span> &#60;<a class="link-mail" href="mailto:agc@NetBSD.org">agc@NetBSD.org</a>&#62; wrote this implementation and manual page.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
February 16, 2014</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

