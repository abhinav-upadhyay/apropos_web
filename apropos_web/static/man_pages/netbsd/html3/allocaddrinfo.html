<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="/static/man_pages/netbsd/style.css" type="text/css" media="all">
<title>
GETADDRINFO(3)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
GETADDRINFO(3)</td>
<td class="head-vol" align="center">
Library Functions Manual</td>
<td class="head-rtitle" align="right">
GETADDRINFO(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">getaddrinfo</b>, <b class="name">freeaddrinfo</b>, <b class="name">allocaddrinfo</b> &#8212; <span class="desc">host and service name to socket address structure</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">netdb.h</a>&gt;</b><p>
<i class="ftype">int</i><br>
<b class="fname">getaddrinfo</b>(<i class="farg" style="white-space:nowrap;">const char * restrict hostname</i>, <i class="farg" style="white-space:nowrap;">const char * restrict servname</i>, <i class="farg" style="white-space:nowrap;">const struct addrinfo * restrict hints</i>, <i class="farg" style="white-space:nowrap;">struct addrinfo ** restrict res</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">freeaddrinfo</b>(<i class="farg" style="white-space:nowrap;">struct addrinfo *ai</i>);<p>
<i class="ftype">struct addrinfo *</i><br>
<b class="fname">allocaddrinfo</b>(<i class="farg" style="white-space:nowrap;">socklen_t len</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <b class="fname">getaddrinfo</b>() function is used to get a list of IP addresses and port numbers for host <i class="farg">hostname</i> and service <i class="farg">servname</i>. It is a replacement for and provides more flexibility than the <a class="link-man" href="../3/gethostbyname">gethostbyname(3)</a> and <a class="link-man" href="../3/getservbyname">getservbyname(3)</a> functions.<p>
The <i class="farg">hostname</i> and <i class="farg">servname</i> arguments are either pointers to NUL-terminated strings or the null pointer. An acceptable value for <i class="farg">hostname</i> is either a valid host name or a numeric host address string consisting of a dotted decimal IPv4 address or an IPv6 address. The <i class="farg">servname</i> is either a decimal port number or a service name listed in <a class="link-man" href="../5/services">services(5)</a>. At least one of <i class="farg">hostname</i> and <i class="farg">servname</i> must be non-null.<p>
<i class="farg">hints</i> is an optional pointer to a <code class="lit">struct addrinfo</code>, as defined by <b class="includes">&lt;<a class="link-includes">netdb.h</a>&gt;</b>:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
struct addrinfo { 
	int ai_flags;		/* input flags */ 
	int ai_family;		/* address family for socket */ 
	int ai_socktype;	/* socket type */ 
	int ai_protocol;	/* protocol for socket */ 
	socklen_t ai_addrlen;	/* length of socket-address */ 
	struct sockaddr *ai_addr; /* socket-address for socket */ 
	char *ai_canonname;	/* canonical name for service location */ 
	struct addrinfo *ai_next; /* pointer to next in list */ 
};</pre>
<p>
This structure can be used to provide hints concerning the type of socket that the caller supports or wishes to use. The caller can supply the following structure elements in <i class="farg">hints</i>:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">ai_family</i></dt>
<dd class="list-tag" style="margin-left: 13.00ex;">
The address (and protocol) family that should be used. When <i class="farg">ai_family</i> is set to <span class="define">AF_UNSPEC</span>, it means the caller will accept any address family supported by the operating system. Note that while address families (<span class="define">AF_*</span>) and protocol families (<span class="define">PF_*</span>) are theoretically distinct, in practice the distinction has been lost. <span class="define">RFC 3493</span> defines <b class="fname">getaddrinfo</b>() in terms of the address family constants <span class="define">AF_*</span> even though <i class="farg">ai_family</i> is to be passed as a protocol family to <a class="link-man" href="../2/socket">socket(2)</a>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">ai_socktype</i></dt>
<dd class="list-tag" style="margin-left: 13.00ex;">
Denotes the type of socket that is wanted: <span class="define">SOCK_STREAM</span>, <span class="define">SOCK_DGRAM</span>, or <span class="define">SOCK_RAW</span>. When <i class="farg">ai_socktype</i> is zero the caller will accept any socket type.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">ai_protocol</i></dt>
<dd class="list-tag" style="margin-left: 13.00ex;">
Indicates which transport protocol is desired, <span class="define">IPPROTO_UDP</span> or <span class="define">IPPROTO_TCP</span>. If <i class="farg">ai_protocol</i> is zero the caller will accept any protocol.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">ai_flags</i></dt>
<dd class="list-tag" style="margin-left: 13.00ex;">
<i class="farg">ai_flags</i> is formed by OR'ing the following values:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">AI_CANONNAME</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
If the <span class="define">AI_CANONNAME</span> bit is set, a successful call to <b class="fname">getaddrinfo</b>() will return a NUL-terminated string containing the canonical name of the specified hostname in the <i class="farg">ai_canonname</i> element of the first <code class="lit">addrinfo</code> structure returned.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">AI_NUMERICHOST</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
If the <span class="define">AI_NUMERICHOST</span> bit is set, it indicates that <i class="farg">hostname</i> should be treated as a numeric string defining an IPv4 or IPv6 address and no name resolution should be attempted.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">AI_NUMERICSERV</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
If the <span class="define">AI_NUMERICSERV</span> bit is set, it indicates that the <i class="farg">servname</i> string contains a numeric port number. This is used to prevent service name resolution.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">AI_PASSIVE</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
If the <span class="define">AI_PASSIVE</span> bit is set it indicates that the returned socket address structure is intended for use in a call to <a class="link-man" href="../2/bind">bind(2)</a>. In this case, if the <i class="farg">hostname</i> argument is the null pointer, then the IP address portion of the socket address structure will be set to <span class="define">INADDR_ANY</span> for an IPv4 address or <span class="define">IN6ADDR_ANY_INIT</span> for an IPv6 address.<p>
If the <span class="define">AI_PASSIVE</span> bit is not set, the returned socket address structure will be ready for use in a call to <a class="link-man" href="../2/connect">connect(2)</a> for a connection-oriented protocol or <a class="link-man" href="../2/connect">connect(2)</a>, <a class="link-man" href="../2/sendto">sendto(2)</a>, or <a class="link-man" href="../2/sendmsg">sendmsg(2)</a> if a connectionless protocol was chosen. The IP address portion of the socket address structure will be set to the loopback address if <i class="farg">hostname</i> is the null pointer and <span class="define">AI_PASSIVE</span> is not set.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">AI_SRV</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
Perform SRV (RFC 2782) record lookups first. This is a non-portable extension.</dd>
</dl>
</dd>
</dl>
<p>
All other elements of the <code class="lit">addrinfo</code> structure passed via <i class="farg">hints</i> must be zero or the null pointer.<p>
If <i class="farg">hints</i> is the null pointer, <b class="fname">getaddrinfo</b>() behaves as if the caller provided a <code class="lit">struct addrinfo</code> with <i class="farg">ai_family</i> set to <span class="define">AF_UNSPEC</span> and all other elements set to zero or <span class="define">NULL</span>.<p>
After a successful call to <b class="fname">getaddrinfo</b>(), <i class="farg">*res</i> is a pointer to a linked list of one or more <code class="lit">addrinfo</code> structures. The list can be traversed by following the <i class="farg">ai_next</i> pointer in each <code class="lit">addrinfo</code> structure until a null pointer is encountered. The three members <i class="farg">ai_family</i>, <i class="farg">ai_socktype</i>, and <i class="farg">ai_protocol</i> in each returned <code class="lit">addrinfo</code> structure are suitable for a call to <a class="link-man" href="../2/socket">socket(2)</a>. For each <code class="lit">addrinfo</code> structure in the list, the <i class="farg">ai_addr</i> member points to a filled-in socket address structure of length <i class="farg">ai_addrlen</i>.<p>
This implementation of <b class="fname">getaddrinfo</b>() allows numeric IPv6 address notation with scope identifier, as documented in chapter 11 of draft-ietf-ipv6-scoping-arch-02.txt. By appending the percent character and scope identifier to addresses, one can fill the <code class="lit">sin6_scope_id</code> field for addresses. This would make management of scoped addresses easier and allows cut-and-paste input of scoped addresses.<p>
At this moment the code supports only link-local addresses with the format. The scope identifier is hardcoded to the name of the hardware interface associated with the link (such as <code class="lit">ne0</code>). An example is &#8220;<code class="lit">fe80::1%ne0</code>&#8221;, which means &#8220;<code class="lit">fe80::1</code> on the link associated with the <code class="lit">ne0</code> interface&#8221;.<p>
The current implementation assumes a one-to-one relationship between the interface and link, which is not necessarily true from the specification.<p>
All of the information returned by <b class="fname">getaddrinfo</b>() is dynamically allocated: the <code class="lit">addrinfo</code> structures themselves as well as the socket address structures and the canonical host name strings included in the <code class="lit">addrinfo</code> structures.<p>
Memory allocated for the dynamically allocated structures created by a successful call to <b class="fname">getaddrinfo</b>() is released by the <b class="fname">freeaddrinfo</b>() function. The <i class="farg">ai</i> pointer should be an <code class="lit">addrinfo</code> structure created by a call to <b class="fname">getaddrinfo</b>() or <b class="fname">allocaddrinfo</b>(). The <b class="fname">allocaddrinfo</b>() function is intended primarily for authors of <a class="link-man" href="../3/nsdispatch">nsdispatch(3)</a> plugins implementing <b class="fname">getaddrinfo</b>() backends. <b class="fname">allocaddrinfo</b>() allocates a <code class="lit">struct addrinfo</code> in a way that is compatible with being returned from <b class="fname">getaddrinfo</b>() and being ultimately freed by <b class="fname">freeaddrinfo</b>(). The returned structure is zeroed, except for the <i class="farg">ai_addr</i> field, which will point to <i class="farg">len</i> bytes of memory for storage of a socket address. It is safe to allocate memory separately for <i class="farg">ai_canonname</i> with <a class="link-man" href="../3/malloc">malloc(3)</a>, or in any other way that is compatible with deallocation by <a class="link-man" href="../3/free">free(3)</a>.</div>
<div class="section">
<h1 id="x52455455524e2056414c554553">RETURN VALUES</h1> <b class="fname">getaddrinfo</b>() returns zero on success or one of the error codes listed in <a class="link-man" href="../3/gai_strerror">gai_strerror(3)</a> if an error occurs.</div>
<div class="section">
<h1 id="x4558414d504c4553">EXAMPLES</h1> The following code tries to connect to &#8220;<code class="lit">www.kame.net</code>&#8221; service &#8220;<code class="lit">http</code>&#8221; via a stream socket. It loops through all the addresses available, regardless of address family. If the destination resolves to an IPv4 address, it will use an <span class="define">AF_INET</span> socket. Similarly, if it resolves to IPv6, an <span class="define">AF_INET6</span> socket is used. Observe that there is no hardcoded reference to a particular address family. The code works even if <b class="fname">getaddrinfo</b>() returns addresses that are not IPv4/v6.<p>
<pre style="margin-left: 5.00ex;" class="lit display">
struct addrinfo hints, *res, *res0; 
int error; 
int s; 
const char *cause = NULL; 
 
memset(&amp;hints, 0, sizeof(hints)); 
hints.ai_family = AF_UNSPEC; 
hints.ai_socktype = SOCK_STREAM; 
error = getaddrinfo("www.kame.net", "http", &amp;hints, &amp;res0); 
if (error) { 
	errx(1, "%s", gai_strerror(error)); 
	/*NOTREACHED*/ 
} 
s = -1; 
for (res = res0; res; res = res-&gt;ai_next) { 
	s = socket(res-&gt;ai_family, res-&gt;ai_socktype, 
	    res-&gt;ai_protocol); 
	if (s &lt; 0) { 
		cause = "socket"; 
		continue; 
	} 
 
	if (connect(s, res-&gt;ai_addr, res-&gt;ai_addrlen) &lt; 0) { 
		cause = "connect"; 
		close(s); 
		s = -1; 
		continue; 
	} 
 
	break;	/* okay we got one */ 
} 
if (s &lt; 0) { 
	err(1, "%s", cause); 
	/*NOTREACHED*/ 
} 
freeaddrinfo(res0);</pre>
<p>
The following example tries to open a wildcard listening socket onto service &#8220;<code class="lit">http</code>&#8221;, for all the address families available.<p>
<pre style="margin-left: 5.00ex;" class="lit display">
struct addrinfo hints, *res, *res0; 
int error; 
int s[MAXSOCK]; 
int nsock; 
const char *cause = NULL; 
 
memset(&amp;hints, 0, sizeof(hints)); 
hints.ai_family = AF_UNSPEC; 
hints.ai_socktype = SOCK_STREAM; 
hints.ai_flags = AI_PASSIVE; 
error = getaddrinfo(NULL, "http", &amp;hints, &amp;res0); 
if (error) { 
	errx(1, "%s", gai_strerror(error)); 
	/*NOTREACHED*/ 
} 
nsock = 0; 
for (res = res0; res &amp;&amp; nsock &lt; MAXSOCK; res = res-&gt;ai_next) { 
	s[nsock] = socket(res-&gt;ai_family, res-&gt;ai_socktype, 
	    res-&gt;ai_protocol); 
	if (s[nsock] &lt; 0) { 
		cause = "socket"; 
		continue; 
	} 
 
	if (bind(s[nsock], res-&gt;ai_addr, res-&gt;ai_addrlen) &lt; 0) { 
		cause = "bind"; 
		close(s[nsock]); 
		continue; 
	} 
	(void) listen(s[nsock], 5); 
 
	nsock++; 
} 
if (nsock == 0) { 
	err(1, "%s", cause); 
	/*NOTREACHED*/ 
} 
freeaddrinfo(res0);</pre>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../2/bind">bind(2)</a>, <a class="link-man" href="../2/connect">connect(2)</a>, <a class="link-man" href="../2/send">send(2)</a>, <a class="link-man" href="../2/socket">socket(2)</a>, <a class="link-man" href="../3/gai_strerror">gai_strerror(3)</a>, <a class="link-man" href="../3/gethostbyname">gethostbyname(3)</a>, <a class="link-man" href="../3/getnameinfo">getnameinfo(3)</a>, <a class="link-man" href="../3/getservbyname">getservbyname(3)</a>, <a class="link-man" href="../3/resolver">resolver(3)</a>, <a class="link-man" href="../5/hosts">hosts(5)</a>, <a class="link-man" href="../5/resolv.conf">resolv.conf(5)</a>, <a class="link-man" href="../5/services">services(5)</a>, <a class="link-man" href="../7/hostname">hostname(7)</a>, <a class="link-man" href="../8/named">named(8)</a><p>
<span class="ref"><span class="ref-auth">R. Gilligan</span>, <span class="ref-auth">S. Thomson</span>, <span class="ref-auth">J. Bound</span>, <span class="ref-auth">J. McCann</span>, and <span class="ref-auth">W. Stevens</span>, <span class="ref-title">Basic Socket Interface Extensions for IPv6</span>, <span class="ref-rep">RFC 3493</span>, <span class="ref-date">February 2003</span>.</span><p>
<span class="ref"><span class="ref-auth">S. Deering</span>, <span class="ref-auth">B. Haberman</span>, <span class="ref-auth">T. Jinmei</span>, <span class="ref-auth">E. Nordmark</span>, and <span class="ref-auth">B. Zill</span>, <span class="ref-title">IPv6 Scoped Address Architecture</span>, <span class="ref-rep">internet draft</span>, <span class="ref-num">draft-ietf-ipv6-scoping-arch-02.txt</span>, <span class="ref-opt">work in progress material</span>.</span><p>
<span class="ref"><span class="ref-auth">Craig Metz</span>, <span class="ref-title">Protocol Independence Using the Sockets API</span>, <i class="ref-book">Proceedings of the FREENIX Track: 2000 USENIX Annual Technical Conference</i>, <i class="ref-issue">USENIX Association</i>, <a class="link-ref" href="http://www.usenix.org/events/usenix2000/freenix/metzprotocol/metzprotocol.pdf">http://www.usenix.org/events/usenix2000/freenix/metzprotocol/metzprotocol.pdf</a>, <span class="ref-page">99-108</span>, <span class="ref-date">June 18-23, 2000</span>.</span></div>
<div class="section">
<h1 id="x5354414e4441524453">STANDARDS</h1> The <b class="fname">getaddrinfo</b>() function is defined by the IEEE Std 1003.1g-2000 (&#8220;POSIX.1g&#8221;) draft specification and documented in <span class="define">RFC 3493</span>, &#8220;Basic Socket Interface Extensions for IPv6&#8221;.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
April 30, 2013</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

