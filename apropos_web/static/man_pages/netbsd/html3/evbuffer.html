<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
evbuffer(3)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
evbuffer(3)</td>
<td class="head-vol" align="center">
Library Functions Manual</td>
<td class="head-rtitle" align="right">
evbuffer(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> evbuffer &#45; Functions for buffering data for network sending or receiving.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>SYNOPSIS</h1> #include &lt;event2/buffer.h&gt;<div style="height: 0.00em;">
&#160;</div>
#include &lt;event2/event-config.h&gt;<div style="height: 0.00em;">
&#160;</div>
#include &lt;stdarg.h&gt;<div style="height: 0.00em;">
&#160;</div>
#include &lt;event2/util.h&gt;<div style="height: 0.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="subsection">
<h2>Data Structures</h2><br>
struct <b>evbuffer</b><div style="height: 0.00em;">
&#160;</div>
<i>An evbuffer is an opaque data type for efficiently buffering data to be sent or received on the network. </i> struct  <b>evbuffer_cb_info</b><div style="height: 0.00em;">
&#160;</div>
<i>Structure passed to an evbuffer_cb_func evbuffer callback. </i> struct  <b>evbuffer_iovec</b><div style="height: 0.00em;">
&#160;</div>
<i>Describes a single extent of memory inside an evbuffer. </i> struct  <b>evbuffer_ptr</b><div style="height: 0.00em;">
&#160;</div>
<i>Pointer to a position within an evbuffer. </i><br>
</div>
<div class="subsection">
<h2>Macros</h2><br>
#define <b>EVBUFFER_CB_ENABLED</b>   1<div style="height: 0.00em;">
&#160;</div>
<i>If this flag is not set, then a callback is temporarily disabled, and should not be invoked. </i> #define  <b>EVBUFFER_FLAG_DRAINS_TO_FD</b>   1<div style="height: 0.00em;">
&#160;</div>
<i>If this flag is set, then we will not use </i><b>evbuffer_peek()</b><i>, </i><b>evbuffer_remove()</b><i>, </i><b>evbuffer_remove_buffer()</b><i>, and so on to read bytes from this buffer: we'll only take bytes out of this buffer by writing them to the network (as with evbuffer_write_atmost), by removing them without observing them (as with evbuffer_drain), or by copying them all out at once (as with evbuffer_add_buffer). </i><b></b><br>
</div>
<div class="subsection">
<h2>Typedefs</h2><br>
typedef void(* <b>evbuffer_cb_func</b> )(struct <b>evbuffer</b> *buffer, const struct <b>evbuffer_cb_info</b> *info, void *arg)<div style="height: 0.00em;">
&#160;</div>
<i>Type definition for a callback that is invoked whenever data is added or removed from an evbuffer. </i> typedef void(*  <b>evbuffer_ref_cleanup_cb</b> )(const void *data, size_t datalen, void *extra)<div style="height: 0.00em;">
&#160;</div>
<i>A cleanup function for a piece of memory added to an evbuffer by reference. </i><br>
</div>
<div class="subsection">
<h2>Enumerations</h2><br>
enum <b>evbuffer_eol_style</b> { <b>EVBUFFER_EOL_ANY</b>, <b>EVBUFFER_EOL_CRLF</b>, <b>EVBUFFER_EOL_CRLF_STRICT</b>, <b>EVBUFFER_EOL_LF</b> }<div style="height: 0.00em;">
&#160;</div>
<i>Used to tell evbuffer_readln what kind of line-ending to look for. </i> enum  <b>evbuffer_ptr_how</b> { <b>EVBUFFER_PTR_SET</b>, <b>EVBUFFER_PTR_ADD</b> }<div style="height: 0.00em;">
&#160;</div>
<i>Defines how to adjust an </i><b>evbuffer_ptr</b><i> by </i><b>evbuffer_ptr_set()</b><i> </i><b></b><br>
</div>
<div class="subsection">
<h2>Functions</h2><br>
int <b>evbuffer_add</b> (struct <b>evbuffer</b> *buf, const void *data, size_t datlen)<div style="height: 0.00em;">
&#160;</div>
<i>Append data to the end of an evbuffer. </i> int  <b>evbuffer_add_buffer</b> (struct <b>evbuffer</b> *outbuf, struct <b>evbuffer</b> *inbuf)<div style="height: 0.00em;">
&#160;</div>
<i>Move all data from one evbuffer into another evbuffer. </i> struct evbuffer_cb_entry *  <b>evbuffer_add_cb</b> (struct <b>evbuffer</b> *buffer, <b>evbuffer_cb_func</b> cb, void *cbarg)<div style="height: 0.00em;">
&#160;</div>
<i>Add a new callback to an evbuffer. </i> int  <b>evbuffer_add_file</b> (struct <b>evbuffer</b> *outbuf, int fd, ev_off_t offset, ev_off_t length)<div style="height: 0.00em;">
&#160;</div>
<i>Copy data from a file into the evbuffer for writing to a socket. </i> int  <b>evbuffer_add_printf</b> (struct <b>evbuffer</b> *buf, const char *fmt,...)<div style="height: 0.00em;">
&#160;</div>
<i>Append a formatted string to the end of an evbuffer. </i> int  <b>evbuffer_add_reference</b> (struct <b>evbuffer</b> *outbuf, const void *data, size_t datlen, <b>evbuffer_ref_cleanup_cb</b> cleanupfn, void *cleanupfn_arg)<div style="height: 0.00em;">
&#160;</div>
<i>Reference memory into an evbuffer without copying. </i> int  <b>evbuffer_add_vprintf</b> (struct <b>evbuffer</b> *buf, const char *fmt, va_list ap)<div style="height: 0.00em;">
&#160;</div>
<i>Append a va_list formatted string to the end of an evbuffer. </i> int  <b>evbuffer_cb_clear_flags</b> (struct <b>evbuffer</b> *buffer, struct evbuffer_cb_entry *cb, ev_uint32_t flags)<div style="height: 0.00em;">
&#160;</div>
<i>Change the flags that are set for a callback on a buffer by removing some. </i> int  <b>evbuffer_cb_set_flags</b> (struct <b>evbuffer</b> *buffer, struct evbuffer_cb_entry *cb, ev_uint32_t flags)<div style="height: 0.00em;">
&#160;</div>
<i>Change the flags that are set for a callback on a buffer by adding more. </i> int  <b>evbuffer_clear_flags</b> (struct <b>evbuffer</b> *buf, ev_uint64_t flags)<div style="height: 0.00em;">
&#160;</div>
<i>Change the flags that are set for an evbuffer by removing some. </i> int  <b>evbuffer_commit_space</b> (struct <b>evbuffer</b> *buf, struct <b>evbuffer_iovec</b> *vec, int n_vecs)<div style="height: 0.00em;">
&#160;</div>
<i>Commits previously reserved space. </i> ev_ssize_t  <b>evbuffer_copyout</b> (struct <b>evbuffer</b> *buf, void *data_out, size_t datlen)<div style="height: 0.00em;">
&#160;</div>
<i>Read data from an evbuffer, and leave the buffer unchanged. </i> int  <b>evbuffer_defer_callbacks</b> (struct <b>evbuffer</b> *buffer, struct <b>event_base</b> *base)<div style="height: 0.00em;">
&#160;</div>
<i>Force all the callbacks on an evbuffer to be run, not immediately after the evbuffer is altered, but instead from inside the event loop. </i> int  <b>evbuffer_drain</b> (struct <b>evbuffer</b> *buf, size_t len)<div style="height: 0.00em;">
&#160;</div>
<i>Remove a specified number of bytes data from the beginning of an evbuffer. </i> int  <b>evbuffer_enable_locking</b> (struct <b>evbuffer</b> *buf, void *lock)<div style="height: 0.00em;">
&#160;</div>
<i>Enable locking on an evbuffer so that it can safely be used by multiple threads at the same time. </i> int  <b>evbuffer_expand</b> (struct <b>evbuffer</b> *buf, size_t datlen)<div style="height: 0.00em;">
&#160;</div>
<i>Expands the available space in an evbuffer. </i> void  <b>evbuffer_free</b> (struct <b>evbuffer</b> *buf)<div style="height: 0.00em;">
&#160;</div>
<i>Deallocate storage for an evbuffer. </i> int  <b>evbuffer_freeze</b> (struct <b>evbuffer</b> *buf, int at_front)<div style="height: 0.00em;">
&#160;</div>
<i>Prevent calls that modify an evbuffer from succeeding. </i> size_t  <b>evbuffer_get_contiguous_space</b> (const struct <b>evbuffer</b> *buf)<div style="height: 0.00em;">
&#160;</div>
<i>Returns the number of contiguous available bytes in the first buffer chain. </i> size_t  <b>evbuffer_get_length</b> (const struct <b>evbuffer</b> *buf)<div style="height: 0.00em;">
&#160;</div>
<i>Returns the total number of bytes stored in the evbuffer. </i> void  <b>evbuffer_lock</b> (struct <b>evbuffer</b> *buf)<div style="height: 0.00em;">
&#160;</div>
<i>Acquire the lock on an evbuffer. </i> struct  <b>evbuffer</b> * <b>evbuffer_new</b> (void)<div style="height: 0.00em;">
&#160;</div>
<i>Allocate storage for a new evbuffer. </i> int  <b>evbuffer_peek</b> (struct <b>evbuffer</b> *buffer, ev_ssize_t len, struct <b>evbuffer_ptr</b> *start_at, struct <b>evbuffer_iovec</b> *vec_out, int n_vec)<div style="height: 0.00em;">
&#160;</div>
<i>Function to peek at data inside an evbuffer without removing it or copying it out. </i> int  <b>evbuffer_prepend</b> (struct <b>evbuffer</b> *buf, const void *data, size_t size)<div style="height: 0.00em;">
&#160;</div>
<i>Prepends data to the beginning of the evbuffer. </i> int  <b>evbuffer_prepend_buffer</b> (struct <b>evbuffer</b> *dst, struct <b>evbuffer</b> *src)<div style="height: 0.00em;">
&#160;</div>
<i>Prepends all data from the src evbuffer to the beginning of the dst evbuffer. </i> int  <b>evbuffer_ptr_set</b> (struct <b>evbuffer</b> *buffer, struct <b>evbuffer_ptr</b> *ptr, size_t position, enum <b>evbuffer_ptr_how</b> how)<div style="height: 0.00em;">
&#160;</div>
<i>Sets the search pointer in the buffer to position. </i> unsigned char *  <b>evbuffer_pullup</b> (struct <b>evbuffer</b> *buf, ev_ssize_t size)<div style="height: 0.00em;">
&#160;</div>
<i>Makes the data at the beginning of an evbuffer contiguous. </i> int  <b>evbuffer_read</b> (struct <b>evbuffer</b> *buffer, <b>evutil_socket_t</b> fd, int howmuch)<div style="height: 0.00em;">
&#160;</div>
<i>Read from a file descriptor and store the result in an evbuffer. </i> char *  <b>evbuffer_readln</b> (struct <b>evbuffer</b> *buffer, size_t *n_read_out, enum <b>evbuffer_eol_style</b> eol_style)<div style="height: 0.00em;">
&#160;</div>
<i>Read a single line from an evbuffer. </i> int  <b>evbuffer_remove</b> (struct <b>evbuffer</b> *buf, void *data, size_t datlen)<div style="height: 0.00em;">
&#160;</div>
<i>Read data from an evbuffer and drain the bytes read. </i> int  <b>evbuffer_remove_buffer</b> (struct <b>evbuffer</b> *src, struct <b>evbuffer</b> *dst, size_t datlen)<div style="height: 0.00em;">
&#160;</div>
<i>Read data from an evbuffer into another evbuffer, draining the bytes from the source buffer. </i> int  <b>evbuffer_remove_cb</b> (struct <b>evbuffer</b> *buffer, <b>evbuffer_cb_func</b> cb, void *cbarg)<div style="height: 0.00em;">
&#160;</div>
<i>Remove a callback from an evbuffer, given the function and argument used to add it. </i> int  <b>evbuffer_remove_cb_entry</b> (struct <b>evbuffer</b> *buffer, struct evbuffer_cb_entry *ent)<div style="height: 0.00em;">
&#160;</div>
<i>Remove a callback from an evbuffer, given a handle returned from evbuffer_add_cb. </i> int  <b>evbuffer_reserve_space</b> (struct <b>evbuffer</b> *buf, ev_ssize_t size, struct <b>evbuffer_iovec</b> *vec, int n_vec)<div style="height: 0.00em;">
&#160;</div>
<i>Reserves space in the last chain or chains of an evbuffer. </i> struct  <b>evbuffer_ptr</b> <b>evbuffer_search</b> (struct <b>evbuffer</b> *buffer, const char *what, size_t len, const struct <b>evbuffer_ptr</b> *start)<div style="height: 0.00em;">
&#160;</div>
<i>Search for a string within an evbuffer. </i> struct  <b>evbuffer_ptr</b> <b>evbuffer_search_eol</b> (struct <b>evbuffer</b> *buffer, struct <b>evbuffer_ptr</b> *start, size_t *eol_len_out, enum <b>evbuffer_eol_style</b> eol_style)<div style="height: 0.00em;">
&#160;</div>
<i>Search for an end-of-line string within an evbuffer. </i> struct  <b>evbuffer_ptr</b> <b>evbuffer_search_range</b> (struct <b>evbuffer</b> *buffer, const char *what, size_t len, const struct <b>evbuffer_ptr</b> *start, const struct <b>evbuffer_ptr</b> *end)<div style="height: 0.00em;">
&#160;</div>
<i>Search for a string within part of an evbuffer. </i> int  <b>evbuffer_set_flags</b> (struct <b>evbuffer</b> *buf, ev_uint64_t flags)<div style="height: 0.00em;">
&#160;</div>
<i>Change the flags that are set for an evbuffer by adding more. </i> int  <b>evbuffer_unfreeze</b> (struct <b>evbuffer</b> *buf, int at_front)<div style="height: 0.00em;">
&#160;</div>
<i>Re-enable calls that modify an evbuffer. </i> void  <b>evbuffer_unlock</b> (struct <b>evbuffer</b> *buf)<div style="height: 0.00em;">
&#160;</div>
<i>Release the lock on an evbuffer. </i> int  <b>evbuffer_write</b> (struct <b>evbuffer</b> *buffer, <b>evutil_socket_t</b> fd)<div style="height: 0.00em;">
&#160;</div>
<i>Write the contents of an evbuffer to a file descriptor. </i> int  <b>evbuffer_write_atmost</b> (struct <b>evbuffer</b> *buffer, <b>evutil_socket_t</b> fd, ev_ssize_t howmuch)<div style="height: 0.00em;">
&#160;</div>
<i>Write some of the contents of an evbuffer to a file descriptor. </i><br>
</div>
</div>
<div class="section">
<h1>Detailed Description</h1> Functions for buffering data for network sending or receiving.<div style="height: 1.00em;">
&#160;</div>
An evbuffer can be used for preparing data before sending it to the network or conversely for reading data from the network. Evbuffers try to avoid memory copies as much as possible. As a result, evbuffers can be used to pass data around without actually incurring the overhead of copying the data.<p>
A new evbuffer can be allocated with <b>evbuffer_new()</b>, and can be freed with <b>evbuffer_free()</b>. Most users will be using evbuffers via the bufferevent interface. To access a bufferevent's evbuffers, use <b>bufferevent_get_input()</b> and <b>bufferevent_get_output()</b>.<p>
There are several guidelines for using evbuffers.<dl>
<dt>
&#8226;</dt>
<dd>
if you already know how much data you are going to add as a result of calling <b>evbuffer_add()</b> multiple times, it makes sense to use <b>evbuffer_expand()</b> first to make sure that enough memory is allocated before hand.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
<b>evbuffer_add_buffer()</b> adds the contents of one buffer to the other without incurring any unnecessary memory copies.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
<b>evbuffer_add()</b> and <b>evbuffer_add_buffer()</b> do not mix very well: if you use them, you will wind up with fragmented memory in your buffer.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
For high-performance code, you may want to avoid copying data into and out of buffers. You can skip the copy step by using <b>evbuffer_reserve_space()</b>/evbuffer_commit_space() when writing into a buffer, and <b>evbuffer_peek()</b> when reading.</dd>
</dl>
<p>
In Libevent 2.0 and later, evbuffers are represented using a linked list of memory chunks, with pointers to the first and last chunk in the chain.<p>
As the contents of an evbuffer can be stored in multiple different memory blocks, it cannot be accessed directly. Instead, <b>evbuffer_pullup()</b> can be used to force a specified number of bytes to be contiguous. This will cause memory reallocation and memory copies if the data is split across multiple blocks. It is more efficient, however, to use <b>evbuffer_peek()</b> if you don't require that the memory to be contiguous.</div>
<div class="section">
<h1>Macro Definition Documentation</h1><div class="subsection">
<h2>#define EVBUFFER_CB_ENABLED   1</h2> If this flag is not set, then a callback is temporarily disabled, and should not be invoked.<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>evbuffer_cb_set_flags()</b>, <b>evbuffer_cb_clear_flags()</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>#define EVBUFFER_FLAG_DRAINS_TO_FD   1</h2> If this flag is set, then we will not use  <b>evbuffer_peek()</b>, <b>evbuffer_remove()</b>, <b>evbuffer_remove_buffer()</b>, and so on to read bytes from this buffer: we'll only take bytes out of this buffer by writing them to the network (as with evbuffer_write_atmost), by removing them without observing them (as with evbuffer_drain), or by copying them all out at once (as with evbuffer_add_buffer). Using this option allows the implementation to use sendfile-based operations for <b>evbuffer_add_file()</b>; see that function for more information.<p>
This flag is on by default for bufferevents that can take advantage of it; you should never actually need to set it on a bufferevent's output buffer.</div>
</div>
<div class="section">
<h1>Typedef Documentation</h1><div class="subsection">
<h2>typedef void(* evbuffer_cb_func)(struct <b>evbuffer</b> *buffer, const struct <b>evbuffer_cb_info</b> *info, void *arg)</h2> Type definition for a callback that is invoked whenever data is added or removed from an evbuffer. An evbuffer may have one or more callbacks set at a time. The order in which they are executed is undefined.<p>
A callback function may add more callbacks, or remove itself from the list of callbacks, or add or remove data from the buffer. It may not remove another callback from the list.<p>
If a callback adds or removes data from the buffer or from another buffer, this can cause a recursive invocation of your callback or other callbacks. If you ask for an infinite loop, you might just get one: watch out!<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>buffer</i> the buffer whose size has changed<div style="height: 0.00em;">
&#160;</div>
<i>info</i> a structure describing how the buffer changed.<div style="height: 0.00em;">
&#160;</div>
<i>arg</i> a pointer to user data</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>typedef void(* evbuffer_ref_cleanup_cb)(const void *data, size_t datalen, void *extra)</h2> A cleanup function for a piece of memory added to an evbuffer by reference.<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>evbuffer_add_reference()</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
</div>
<div class="section">
<h1>Enumeration Type Documentation</h1><div class="subsection">
<h2>enum <b>evbuffer_eol_style</b></h2> Used to tell evbuffer_readln what kind of line-ending to look for.<p>
<b>Enumerator</b><br>
<dl>
<dt>
<b></b><i>EVBUFFER_EOL_ANY </i><b></b><i></i></dt>
<dd>
Any sequence of CR and LF characters is acceptable as an EOL. Note that this style can produce ambiguous results: the sequence 'CRLF' will be treated as a single EOL if it is all in the buffer at once, but if you first read a CR from the network and later read an LF from the network, it will be treated as two EOLs.</dd>
</dl>
<dl>
<dt>
<b></b><i>EVBUFFER_EOL_CRLF </i><b></b><i></i></dt>
<dd>
An EOL is an LF, optionally preceded by a CR. This style is most useful for implementing text-based internet protocols.</dd>
</dl>
<dl>
<dt>
<b></b><i>EVBUFFER_EOL_CRLF_STRICT </i><b></b><i></i></dt>
<dd>
An EOL is a CR followed by an LF.</dd>
</dl>
<dl>
<dt>
<b></b><i>EVBUFFER_EOL_LF </i><b></b><i></i></dt>
<dd>
An EOL is a LF.</dd>
</dl>
</div>
<div class="subsection">
<h2>enum <b>evbuffer_ptr_how</b></h2> Defines how to adjust an  <b>evbuffer_ptr</b> by <b>evbuffer_ptr_set()</b><p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>evbuffer_ptr_set()</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
<p>
<b>Enumerator</b><br>
<dl>
<dt>
<b></b><i>EVBUFFER_PTR_SET </i><b></b><i></i></dt>
<dd>
Sets the pointer to the position; can be called on with an uninitialized <b>evbuffer_ptr</b>.</dd>
</dl>
<dl>
<dt>
<b></b><i>EVBUFFER_PTR_ADD </i><b></b><i></i></dt>
<dd>
Advances the pointer by adding to the current position.</dd>
</dl>
</div>
</div>
<div class="section">
<h1>Function Documentation</h1><div class="subsection">
<h2>int evbuffer_add (struct <b>evbuffer</b> *buf, const void *data, size_tdatlen)</h2> Append data to the end of an evbuffer.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>buf</i> the evbuffer to be appended to<div style="height: 0.00em;">
&#160;</div>
<i>data</i> pointer to the beginning of the data buffer<div style="height: 0.00em;">
&#160;</div>
<i>datlen</i> the number of bytes to be copied from the data buffer</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 on success, -1 on failure.</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int evbuffer_add_buffer (struct <b>evbuffer</b> *outbuf, struct <b>evbuffer</b> *inbuf)</h2> Move all data from one evbuffer into another evbuffer. This is a destructive add. The data from one buffer moves into the other buffer. However, no unnecessary memory copies occur.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>outbuf</i> the output buffer<div style="height: 0.00em;">
&#160;</div>
<i>inbuf</i> the input buffer</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 if successful, or -1 if an error occurred</div>
<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>evbuffer_remove_buffer()</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>struct evbuffer_cb_entry* evbuffer_add_cb (struct <b>evbuffer</b> *buffer, <b>evbuffer_cb_func</b>cb, void *cbarg)</h2> Add a new callback to an evbuffer. Subsequent calls to  <b>evbuffer_add_cb()</b> add new callbacks. To remove this callback, call evbuffer_remove_cb or evbuffer_remove_cb_entry.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>buffer</i> the evbuffer to be monitored<div style="height: 0.00em;">
&#160;</div>
<i>cb</i> the callback function to invoke when the evbuffer is modified, or NULL to remove all callbacks.<div style="height: 0.00em;">
&#160;</div>
<i>cbarg</i> an argument to be provided to the callback function</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
a handle to the callback on success, or NULL on failure.</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int evbuffer_add_file (struct <b>evbuffer</b> *outbuf, intfd, ev_off_toffset, ev_off_tlength)</h2> Copy data from a file into the evbuffer for writing to a socket. This function avoids unnecessary data copies between userland and kernel. If sendfile is available and the EVBUFFER_FLAG_DRAINS_TO_FD flag is set, it uses those functions. Otherwise, it tries to use mmap (or CreateFileMapping on Windows).<p>
The function owns the resulting file descriptor and will close it when finished transferring data.<p>
The results of using <b>evbuffer_remove()</b> or <b>evbuffer_pullup()</b> on evbuffers whose data was added using this function are undefined.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>outbuf</i> the output buffer<div style="height: 0.00em;">
&#160;</div>
<i>fd</i> the file descriptor<div style="height: 0.00em;">
&#160;</div>
<i>offset</i> the offset from which to read data<div style="height: 0.00em;">
&#160;</div>
<i>length</i> how much data to read</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 if successful, or -1 if an error occurred</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int evbuffer_add_printf (struct <b>evbuffer</b> *buf, const char *fmt, ...)</h2> Append a formatted string to the end of an evbuffer. The string is formated as printf.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>buf</i> the evbuffer that will be appended to<div style="height: 0.00em;">
&#160;</div>
<i>fmt</i> a format string<div style="height: 0.00em;">
&#160;</div>
<i>...</i> arguments that will be passed to printf(3)</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
The number of bytes added if successful, or -1 if an error occurred.</div>
<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
evutil_printf(), <b>evbuffer_add_vprintf()</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int evbuffer_add_reference (struct <b>evbuffer</b> *outbuf, const void *data, size_tdatlen, <b>evbuffer_ref_cleanup_cb</b>cleanupfn, void *cleanupfn_arg)</h2> Reference memory into an evbuffer without copying. The memory needs to remain valid until all the added data has been read. This function keeps just a reference to the memory without actually incurring the overhead of a copy.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>outbuf</i> the output buffer<div style="height: 0.00em;">
&#160;</div>
<i>data</i> the memory to reference<div style="height: 0.00em;">
&#160;</div>
<i>datlen</i> how memory to reference<div style="height: 0.00em;">
&#160;</div>
<i>cleanupfn</i> callback to be invoked when the memory is no longer referenced by this evbuffer.<div style="height: 0.00em;">
&#160;</div>
<i>cleanupfn_arg</i> optional argument to the cleanup callback</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 if successful, or -1 if an error occurred</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int evbuffer_add_vprintf (struct <b>evbuffer</b> *buf, const char *fmt, va_listap)</h2> Append a va_list formatted string to the end of an evbuffer.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>buf</i> the evbuffer that will be appended to<div style="height: 0.00em;">
&#160;</div>
<i>fmt</i> a format string<div style="height: 0.00em;">
&#160;</div>
<i>ap</i> a varargs va_list argument array that will be passed to vprintf(3)</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
The number of bytes added if successful, or -1 if an error occurred.</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int evbuffer_cb_clear_flags (struct <b>evbuffer</b> *buffer, struct evbuffer_cb_entry *cb, ev_uint32_tflags)</h2> Change the flags that are set for a callback on a buffer by removing some.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>buffer</i> the evbuffer that the callback is watching.<div style="height: 0.00em;">
&#160;</div>
<i>cb</i> the callback whose status we want to change.<div style="height: 0.00em;">
&#160;</div>
<i>flags</i> EVBUFFER_CB_ENABLED to disable the callback.</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 on success, -1 on failure.</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int evbuffer_cb_set_flags (struct <b>evbuffer</b> *buffer, struct evbuffer_cb_entry *cb, ev_uint32_tflags)</h2> Change the flags that are set for a callback on a buffer by adding more.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>buffer</i> the evbuffer that the callback is watching.<div style="height: 0.00em;">
&#160;</div>
<i>cb</i> the callback whose status we want to change.<div style="height: 0.00em;">
&#160;</div>
<i>flags</i> EVBUFFER_CB_ENABLED to re-enable the callback.</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 on success, -1 on failure.</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int evbuffer_clear_flags (struct <b>evbuffer</b> *buf, ev_uint64_tflags)</h2> Change the flags that are set for an evbuffer by removing some.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>buffer</i> the evbuffer that the callback is watching.<div style="height: 0.00em;">
&#160;</div>
<i>cb</i> the callback whose status we want to change.<div style="height: 0.00em;">
&#160;</div>
<i>flags</i> One or more EVBUFFER_FLAG_* options</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 on success, -1 on failure.</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int evbuffer_commit_space (struct <b>evbuffer</b> *buf, struct <b>evbuffer_iovec</b> *vec, intn_vecs)</h2> Commits previously reserved space. Commits some of the space previously reserved with  <b>evbuffer_reserve_space()</b>. It then becomes available for reading.<p>
This function may return an error if the pointer in the extents do not match those returned from evbuffer_reserve_space, or if data has been added to the buffer since the space was reserved.<p>
If you want to commit less data than you got reserved space for, modify the iov_len pointer of the appropriate extent to a smaller value. Note that you may have received more space than you requested if it was available!<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>buf</i> the evbuffer in which to reserve space.<div style="height: 0.00em;">
&#160;</div>
<i>vec</i> one or two extents returned by evbuffer_reserve_space.<div style="height: 0.00em;">
&#160;</div>
<i>n_vecs</i> the number of extents.</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 on success, -1 on error</div>
<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>evbuffer_reserve_space()</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>ev_ssize_t evbuffer_copyout (struct <b>evbuffer</b> *buf, void *data_out, size_tdatlen)</h2> Read data from an evbuffer, and leave the buffer unchanged. If more bytes are requested than are available in the evbuffer, we only extract as many bytes as were available.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>buf</i> the evbuffer to be read from<div style="height: 0.00em;">
&#160;</div>
<i>data_out</i> the destination buffer to store the result<div style="height: 0.00em;">
&#160;</div>
<i>datlen</i> the maximum size of the destination buffer</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
the number of bytes read, or -1 if we can't drain the buffer.</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int evbuffer_defer_callbacks (struct <b>evbuffer</b> *buffer, struct <b>event_base</b> *base)</h2> Force all the callbacks on an evbuffer to be run, not immediately after the evbuffer is altered, but instead from inside the event loop. This can be used to serialize all the callbacks to a single thread of execution.</div>
<div class="subsection">
<h2>int evbuffer_drain (struct <b>evbuffer</b> *buf, size_tlen)</h2> Remove a specified number of bytes data from the beginning of an evbuffer.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>buf</i> the evbuffer to be drained<div style="height: 0.00em;">
&#160;</div>
<i>len</i> the number of bytes to drain from the beginning of the buffer</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 on success, -1 on failure.</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int evbuffer_enable_locking (struct <b>evbuffer</b> *buf, void *lock)</h2> Enable locking on an evbuffer so that it can safely be used by multiple threads at the same time. NOTE: when locking is enabled, the lock will be held when callbacks are invoked. This could result in deadlock if you aren't careful. Plan accordingly!<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>buf</i> An evbuffer to make lockable.<div style="height: 0.00em;">
&#160;</div>
<i>lock</i> A lock object, or NULL if we should allocate our own.</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 on success, -1 on failure.</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int evbuffer_expand (struct <b>evbuffer</b> *buf, size_tdatlen)</h2> Expands the available space in an evbuffer. Expands the available space in the evbuffer to at least datlen, so that appending datlen additional bytes will not require any new allocations.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>buf</i> the evbuffer to be expanded<div style="height: 0.00em;">
&#160;</div>
<i>datlen</i> the new minimum length requirement</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 if successful, or -1 if an error occurred</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>void evbuffer_free (struct <b>evbuffer</b> *buf)</h2> Deallocate storage for an evbuffer.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>buf</i> pointer to the evbuffer to be freed</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int evbuffer_freeze (struct <b>evbuffer</b> *buf, intat_front)</h2> Prevent calls that modify an evbuffer from succeeding. A buffer may frozen at the front, at the back, or at both the front and the back.<p>
If the front of a buffer is frozen, operations that drain data from the front of the buffer, or that prepend data to the buffer, will fail until it is unfrozen. If the back a buffer is frozen, operations that append data from the buffer will fail until it is unfrozen.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>buf</i> The buffer to freeze<div style="height: 0.00em;">
&#160;</div>
<i>at_front</i> If true, we freeze the front of the buffer. If false, we freeze the back.</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 on success, -1 on failure.</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>size_t evbuffer_get_contiguous_space (const struct <b>evbuffer</b> *buf)</h2> Returns the number of contiguous available bytes in the first buffer chain. This is useful when processing data that might be split into multiple chains, or that might all be in the first chain. Calls to  <b>evbuffer_pullup()</b> that cause reallocation and copying of data can thus be avoided.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>buf</i> pointer to the evbuffer</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 if no data is available, otherwise the number of available bytes in the first buffer chain.</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>size_t evbuffer_get_length (const struct <b>evbuffer</b> *buf)</h2> Returns the total number of bytes stored in the evbuffer.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>buf</i> pointer to the evbuffer</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
the number of bytes stored in the evbuffer</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>void evbuffer_lock (struct <b>evbuffer</b> *buf)</h2> Acquire the lock on an evbuffer. Has no effect if locking was not enabled with evbuffer_enable_locking.</div>
<div class="subsection">
<h2>struct <b>evbuffer</b>* evbuffer_new (void)</h2> Allocate storage for a new evbuffer.<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
a pointer to a newly allocated evbuffer struct, or NULL if an error occurred</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int evbuffer_peek (struct <b>evbuffer</b> *buffer, ev_ssize_tlen, struct <b>evbuffer_ptr</b> *start_at, struct <b>evbuffer_iovec</b> *vec_out, intn_vec)</h2> Function to peek at data inside an evbuffer without removing it or copying it out. Pointers to the data are returned by filling the 'vec_out' array with pointers to one or more extents of data inside the buffer.<p>
The total data in the extents that you get back may be more than you requested (if there is more data last extent than you asked for), or less (if you do not provide enough evbuffer_iovecs, or if the buffer does not have as much data as you asked to see).<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>buffer</i> the evbuffer to peek into,<div style="height: 0.00em;">
&#160;</div>
<i>len</i> the number of bytes to try to peek. If len is negative, we will try to fill as much of vec_out as we can. If len is negative and vec_out is not provided, we return the number of evbuffer_iovecs that would be needed to get all the data in the buffer.<div style="height: 0.00em;">
&#160;</div>
<i>start_at</i> an <b>evbuffer_ptr</b> indicating the point at which we should start looking for data. NULL means, 'At the start of the<br>
   buffer.'<div style="height: 0.00em;">
&#160;</div>
<i>vec_out</i> an array of <b>evbuffer_iovec</b><div style="height: 0.00em;">
&#160;</div>
<i>n_vec</i> the length of vec_out. If 0, we only count how many extents would be necessary to point to the requested amount of data.</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
The number of extents needed. This may be less than n_vec if we didn't need all the evbuffer_iovecs we were given, or more than n_vec if we would need more to return all the data that was requested.</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int evbuffer_prepend (struct <b>evbuffer</b> *buf, const void *data, size_tsize)</h2> Prepends data to the beginning of the evbuffer.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>buf</i> the evbuffer to which to prepend data<div style="height: 0.00em;">
&#160;</div>
<i>data</i> a pointer to the memory to prepend<div style="height: 0.00em;">
&#160;</div>
<i>size</i> the number of bytes to prepend</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 if successful, or -1 otherwise</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int evbuffer_prepend_buffer (struct <b>evbuffer</b> *dst, struct <b>evbuffer</b> *src)</h2> Prepends all data from the src evbuffer to the beginning of the dst evbuffer.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>dst</i> the evbuffer to which to prepend data<div style="height: 0.00em;">
&#160;</div>
<i>src</i> the evbuffer to prepend; it will be emptied as a result</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 if successful, or -1 otherwise</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int evbuffer_ptr_set (struct <b>evbuffer</b> *buffer, struct <b>evbuffer_ptr</b> *ptr, size_tposition, enum <b>evbuffer_ptr_how</b>how)</h2> Sets the search pointer in the buffer to position. If  <b>evbuffer_ptr</b> is not initialized. This function can only be called with EVBUFFER_PTR_SET.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>buffer</i> the evbuffer to be search<div style="height: 0.00em;">
&#160;</div>
<i>ptr</i> a pointer to a struct <b>evbuffer_ptr</b><div style="height: 0.00em;">
&#160;</div>
<i>position</i> the position at which to start the next search<div style="height: 0.00em;">
&#160;</div>
<i>how</i> determines how the pointer should be manipulated.</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 on success or -1 otherwise</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>unsigned char* evbuffer_pullup (struct <b>evbuffer</b> *buf, ev_ssize_tsize)</h2> Makes the data at the beginning of an evbuffer contiguous.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>buf</i> the evbuffer to make contiguous<div style="height: 0.00em;">
&#160;</div>
<i>size</i> the number of bytes to make contiguous, or -1 to make the entire buffer contiguous.</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
a pointer to the contiguous memory array</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int evbuffer_read (struct <b>evbuffer</b> *buffer, <b>evutil_socket_t</b>fd, inthowmuch)</h2> Read from a file descriptor and store the result in an evbuffer.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>buffer</i> the evbuffer to store the result<div style="height: 0.00em;">
&#160;</div>
<i>fd</i> the file descriptor to read from<div style="height: 0.00em;">
&#160;</div>
<i>howmuch</i> the number of bytes to be read</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
the number of bytes read, or -1 if an error occurred</div>
<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>evbuffer_write()</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>char* evbuffer_readln (struct <b>evbuffer</b> *buffer, size_t *n_read_out, enum <b>evbuffer_eol_style</b>eol_style)</h2> Read a single line from an evbuffer. Reads a line terminated by an EOL as determined by the evbuffer_eol_style argument. Returns a newly allocated nul-terminated string; the caller must free the returned value. The EOL is not included in the returned string.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>buffer</i> the evbuffer to read from<div style="height: 0.00em;">
&#160;</div>
<i>n_read_out</i> if non-NULL, points to a size_t that is set to the number of characters in the returned string. This is useful for strings that can contain NUL characters.<div style="height: 0.00em;">
&#160;</div>
<i>eol_style</i> the style of line-ending to use.</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
pointer to a single line, or NULL if an error occurred</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int evbuffer_remove (struct <b>evbuffer</b> *buf, void *data, size_tdatlen)</h2> Read data from an evbuffer and drain the bytes read. If more bytes are requested than are available in the evbuffer, we only extract as many bytes as were available.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>buf</i> the evbuffer to be read from<div style="height: 0.00em;">
&#160;</div>
<i>data</i> the destination buffer to store the result<div style="height: 0.00em;">
&#160;</div>
<i>datlen</i> the maximum size of the destination buffer</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
the number of bytes read, or -1 if we can't drain the buffer.</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int evbuffer_remove_buffer (struct <b>evbuffer</b> *src, struct <b>evbuffer</b> *dst, size_tdatlen)</h2> Read data from an evbuffer into another evbuffer, draining the bytes from the source buffer. This function avoids copy operations to the extent possible.<p>
If more bytes are requested than are available in src, the src buffer is drained completely.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>src</i> the evbuffer to be read from<div style="height: 0.00em;">
&#160;</div>
<i>dst</i> the destination evbuffer to store the result into<div style="height: 0.00em;">
&#160;</div>
<i>datlen</i> the maximum numbers of bytes to transfer</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
the number of bytes read</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int evbuffer_remove_cb (struct <b>evbuffer</b> *buffer, <b>evbuffer_cb_func</b>cb, void *cbarg)</h2> Remove a callback from an evbuffer, given the function and argument used to add it.<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 if a callback was removed, or -1 if no matching callback was found.</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int evbuffer_remove_cb_entry (struct <b>evbuffer</b> *buffer, struct evbuffer_cb_entry *ent)</h2> Remove a callback from an evbuffer, given a handle returned from evbuffer_add_cb. Calling this function invalidates the handle.<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 if a callback was removed, or -1 if no matching callback was found.</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int evbuffer_reserve_space (struct <b>evbuffer</b> *buf, ev_ssize_tsize, struct <b>evbuffer_iovec</b> *vec, intn_vec)</h2> Reserves space in the last chain or chains of an evbuffer. Makes space available in the last chain or chains of an evbuffer that can be arbitrarily written to by a user. The space does not become available for reading until it has been committed with  <b>evbuffer_commit_space()</b>.<p>
The space is made available as one or more extents, represented by an initial pointer and a length. You can force the memory to be available as only one extent. Allowing more extents, however, makes the function more efficient.<p>
Multiple subsequent calls to this function will make the same space available until <b>evbuffer_commit_space()</b> has been called.<p>
It is an error to do anything that moves around the buffer's internal memory structures before committing the space.<p>
NOTE: The code currently does not ever use more than two extents. This may change in future versions.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>buf</i> the evbuffer in which to reserve space.<div style="height: 0.00em;">
&#160;</div>
<i>size</i> how much space to make available, at minimum. The total length of the extents may be greater than the requested length.<div style="height: 0.00em;">
&#160;</div>
<i>vec</i> an array of one or more <b>evbuffer_iovec</b> structures to hold pointers to the reserved extents of memory.<div style="height: 0.00em;">
&#160;</div>
<i>n_vec</i> The length of the vec array. Must be at least 1; 2 is more efficient.</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
the number of provided extents, or -1 on error.</div>
<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>evbuffer_commit_space()</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>struct <b>evbuffer_ptr</b> evbuffer_search (struct <b>evbuffer</b> *buffer, const char *what, size_tlen, const struct <b>evbuffer_ptr</b> *start)</h2> Search for a string within an evbuffer.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>buffer</i> the evbuffer to be searched<div style="height: 0.00em;">
&#160;</div>
<i>what</i> the string to be searched for<div style="height: 0.00em;">
&#160;</div>
<i>len</i> the length of the search string<div style="height: 0.00em;">
&#160;</div>
<i>start</i> NULL or a pointer to a valid struct <b>evbuffer_ptr</b>.</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
a struct <b>evbuffer_ptr</b> whose 'pos' field has the offset of the first occurrence of the string in the buffer after 'start'. The 'pos' field of the result is -1 if the string was not found.</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>struct <b>evbuffer_ptr</b> evbuffer_search_eol (struct <b>evbuffer</b> *buffer, struct <b>evbuffer_ptr</b> *start, size_t *eol_len_out, enum <b>evbuffer_eol_style</b>eol_style)</h2> Search for an end-of-line string within an evbuffer.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>buffer</i> the evbuffer to be searched<div style="height: 0.00em;">
&#160;</div>
<i>start</i> NULL or a pointer to a valid struct <b>evbuffer_ptr</b> to start searching at.<div style="height: 0.00em;">
&#160;</div>
<i>eol_len_out</i> If non-NULL, the pointed-to value will be set to the length of the end-of-line string.<div style="height: 0.00em;">
&#160;</div>
<i>eol_style</i> The kind of EOL to look for; see <b>evbuffer_readln()</b> for more information</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
a struct <b>evbuffer_ptr</b> whose 'pos' field has the offset of the first occurrence EOL in the buffer after 'start'. The 'pos' field of the result is -1 if the string was not found.</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>struct <b>evbuffer_ptr</b> evbuffer_search_range (struct <b>evbuffer</b> *buffer, const char *what, size_tlen, const struct <b>evbuffer_ptr</b> *start, const struct <b>evbuffer_ptr</b> *end)</h2> Search for a string within part of an evbuffer.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>buffer</i> the evbuffer to be searched<div style="height: 0.00em;">
&#160;</div>
<i>what</i> the string to be searched for<div style="height: 0.00em;">
&#160;</div>
<i>len</i> the length of the search string<div style="height: 0.00em;">
&#160;</div>
<i>start</i> NULL or a pointer to a valid struct <b>evbuffer_ptr</b> that indicates where we should start searching.<div style="height: 0.00em;">
&#160;</div>
<i>end</i> NULL or a pointer to a valid struct <b>evbuffer_ptr</b> that indicates where we should stop searching.</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
a struct <b>evbuffer_ptr</b> whose 'pos' field has the offset of the first occurrence of the string in the buffer after 'start'. The 'pos' field of the result is -1 if the string was not found.</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int evbuffer_set_flags (struct <b>evbuffer</b> *buf, ev_uint64_tflags)</h2> Change the flags that are set for an evbuffer by adding more.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>buffer</i> the evbuffer that the callback is watching.<div style="height: 0.00em;">
&#160;</div>
<i>cb</i> the callback whose status we want to change.<div style="height: 0.00em;">
&#160;</div>
<i>flags</i> One or more EVBUFFER_FLAG_* options</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 on success, -1 on failure.</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int evbuffer_unfreeze (struct <b>evbuffer</b> *buf, intat_front)</h2> Re-enable calls that modify an evbuffer.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>buf</i> The buffer to un-freeze<div style="height: 0.00em;">
&#160;</div>
<i>at_front</i> If true, we unfreeze the front of the buffer. If false, we unfreeze the back.</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 on success, -1 on failure.</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>void evbuffer_unlock (struct <b>evbuffer</b> *buf)</h2> Release the lock on an evbuffer. Has no effect if locking was not enabled with evbuffer_enable_locking.</div>
<div class="subsection">
<h2>int evbuffer_write (struct <b>evbuffer</b> *buffer, <b>evutil_socket_t</b>fd)</h2> Write the contents of an evbuffer to a file descriptor. The evbuffer will be drained after the bytes have been successfully written.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>buffer</i> the evbuffer to be written and drained<div style="height: 0.00em;">
&#160;</div>
<i>fd</i> the file descriptor to be written to</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
the number of bytes written, or -1 if an error occurred</div>
<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>evbuffer_read()</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int evbuffer_write_atmost (struct <b>evbuffer</b> *buffer, <b>evutil_socket_t</b>fd, ev_ssize_thowmuch)</h2> Write some of the contents of an evbuffer to a file descriptor. The evbuffer will be drained after the bytes have been successfully written.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>buffer</i> the evbuffer to be written and drained<div style="height: 0.00em;">
&#160;</div>
<i>fd</i> the file descriptor to be written to<div style="height: 0.00em;">
&#160;</div>
<i>howmuch</i> the largest allowable number of bytes to write, or -1 to write as many bytes as we can.</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
the number of bytes written, or -1 if an error occurred</div>
<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>evbuffer_read()</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
</div>
<div class="section">
<h1>Author</h1> Generated automatically by Doxygen for libevent from the source code.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tr>
<td class="foot-date">
Tue Jan 27 2015</td>
<td class="foot-os" align="right">
libevent</td>
</tr>
</table>
</div>
</body>
</html>

