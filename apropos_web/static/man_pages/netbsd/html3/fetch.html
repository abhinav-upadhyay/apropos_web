<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
FETCH(3)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
FETCH(3)</td>
<td class="head-vol" align="center">
Library Functions Manual</td>
<td class="head-rtitle" align="right">
FETCH(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">fetchMakeURL</b>, <b class="name">fetchParseURL</b>, <b class="name">fetchCopyURL</b>, <b class="name">fetchFreeURL</b>, <b class="name">fetchXGetURL</b>, <b class="name">fetchGetURL</b>, <b class="name">fetchPutURL</b>, <b class="name">fetchStatURL</b>, <b class="name">fetchListURL</b>, <b class="name">fetchXGet</b>, <b class="name">fetchGet</b>, <b class="name">fetchPut</b>, <b class="name">fetchStat</b>, <b class="name">fetchList</b>, <b class="name">fetchXGetFile</b>, <b class="name">fetchGetFile</b>, <b class="name">fetchPutFile</b>, <b class="name">fetchStatFile</b>, <b class="name">fetchListFile</b>, <b class="name">fetchXGetHTTP</b>, <b class="name">fetchGetHTTP</b>, <b class="name">fetchPutHTTP</b>, <b class="name">fetchStatHTTP</b>, <b class="name">fetchListHTTP</b>, <b class="name">fetchXGetFTP</b>, <b class="name">fetchGetFTP</b>, <b class="name">fetchPutFTP</b>, <b class="name">fetchStatFTP</b>, <b class="name">fetchListFTP</b> <b class="name">fetchInitURLList</b>, <b class="name">fetchFreeURLList</b>, <b class="name">fetchUnquotePath</b>, <b class="name">fetchUnquoteFilename</b>, <b class="name">fetchStringifyURL</b>, <b class="name">fetchConnectionCacheInit</b>, <b class="name">fetchConnectionCacheClose</b>, <b class="name">fetch</b> &#8212; <span class="desc">file transfer functions</span></div>
<div class="section">
<h1 id="x4c494252415259">LIBRARY</h1> <span class="lib">File Transfer Library (libfetch, &#45;lfetch)</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">stdio.h</a>&gt;</b><br>
<b class="includes">#include &lt;<a class="link-includes">fetch.h</a>&gt;</b><p>
<i class="ftype">struct url *</i><br>
<b class="fname">fetchMakeURL</b>(<i class="farg" style="white-space:nowrap;">const char *scheme</i>, <i class="farg" style="white-space:nowrap;">const char *host</i>, <i class="farg" style="white-space:nowrap;">int port</i>, <i class="farg" style="white-space:nowrap;">const char *doc</i>, <i class="farg" style="white-space:nowrap;">const char *user</i>, <i class="farg" style="white-space:nowrap;">const char *pwd</i>);<p>
<i class="ftype">struct url *</i><br>
<b class="fname">fetchParseURL</b>(<i class="farg" style="white-space:nowrap;">const char *URL</i>);<p>
<i class="ftype">struct url *</i><br>
<b class="fname">fetchCopyURL</b>(<i class="farg" style="white-space:nowrap;">const struct url *u</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">fetchFreeURL</b>(<i class="farg" style="white-space:nowrap;">struct url *u</i>);<p>
<i class="ftype">fetchIO *</i><br>
<b class="fname">fetchXGetURL</b>(<i class="farg" style="white-space:nowrap;">const char *URL</i>, <i class="farg" style="white-space:nowrap;">struct url_stat *us</i>, <i class="farg" style="white-space:nowrap;">const char *flags</i>);<p>
<i class="ftype">fetchIO *</i><br>
<b class="fname">fetchGetURL</b>(<i class="farg" style="white-space:nowrap;">const char *URL</i>, <i class="farg" style="white-space:nowrap;">const char *flags</i>);<p>
<i class="ftype">fetchIO *</i><br>
<b class="fname">fetchPutURL</b>(<i class="farg" style="white-space:nowrap;">const char *URL</i>, <i class="farg" style="white-space:nowrap;">const char *flags</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">fetchStatURL</b>(<i class="farg" style="white-space:nowrap;">const char *URL</i>, <i class="farg" style="white-space:nowrap;">struct url_stat *us</i>, <i class="farg" style="white-space:nowrap;">const char *flags</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">fetchListURL</b>(<i class="farg" style="white-space:nowrap;">struct url_list *list</i>, <i class="farg" style="white-space:nowrap;">const char *URL</i>, <i class="farg" style="white-space:nowrap;">const char *flags</i>);<p>
<i class="ftype">fetchIO *</i><br>
<b class="fname">fetchXGet</b>(<i class="farg" style="white-space:nowrap;">struct url *u</i>, <i class="farg" style="white-space:nowrap;">struct url_stat *us</i>, <i class="farg" style="white-space:nowrap;">const char *flags</i>);<p>
<i class="ftype">fetchIO *</i><br>
<b class="fname">fetchGet</b>(<i class="farg" style="white-space:nowrap;">struct url *u</i>, <i class="farg" style="white-space:nowrap;">const char *flags</i>);<p>
<i class="ftype">fetchIO *</i><br>
<b class="fname">fetchPut</b>(<i class="farg" style="white-space:nowrap;">struct url *u</i>, <i class="farg" style="white-space:nowrap;">const char *flags</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">fetchStat</b>(<i class="farg" style="white-space:nowrap;">struct url *u</i>, <i class="farg" style="white-space:nowrap;">struct url_stat *us</i>, <i class="farg" style="white-space:nowrap;">const char *flags</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">fetchList</b>(<i class="farg" style="white-space:nowrap;">struct url_list *list</i>, <i class="farg" style="white-space:nowrap;">struct url *u</i>, <i class="farg" style="white-space:nowrap;">const char *flags</i>);<p>
<i class="ftype">fetchIO *</i><br>
<b class="fname">fetchXGetFile</b>(<i class="farg" style="white-space:nowrap;">struct url *u</i>, <i class="farg" style="white-space:nowrap;">struct url_stat *us</i>, <i class="farg" style="white-space:nowrap;">const char *flags</i>);<p>
<i class="ftype">fetchIO *</i><br>
<b class="fname">fetchGetFile</b>(<i class="farg" style="white-space:nowrap;">struct url *u</i>, <i class="farg" style="white-space:nowrap;">const char *flags</i>);<p>
<i class="ftype">fetchIO *</i><br>
<b class="fname">fetchPutFile</b>(<i class="farg" style="white-space:nowrap;">struct url *u</i>, <i class="farg" style="white-space:nowrap;">const char *flags</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">fetchStatFile</b>(<i class="farg" style="white-space:nowrap;">struct url *u</i>, <i class="farg" style="white-space:nowrap;">struct url_stat *us</i>, <i class="farg" style="white-space:nowrap;">const char *flags</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">fetchListFile</b>(<i class="farg" style="white-space:nowrap;">struct url_list *list</i>, <i class="farg" style="white-space:nowrap;">struct url *u</i>, <i class="farg" style="white-space:nowrap;">const char *flags</i>);<p>
<i class="ftype">fetchIO *</i><br>
<b class="fname">fetchXGetHTTP</b>(<i class="farg" style="white-space:nowrap;">struct url *u</i>, <i class="farg" style="white-space:nowrap;">struct url_stat *us</i>, <i class="farg" style="white-space:nowrap;">const char *flags</i>);<p>
<i class="ftype">fetchIO *</i><br>
<b class="fname">fetchGetHTTP</b>(<i class="farg" style="white-space:nowrap;">struct url *u</i>, <i class="farg" style="white-space:nowrap;">const char *flags</i>);<p>
<i class="ftype">fetchIO *</i><br>
<b class="fname">fetchPutHTTP</b>(<i class="farg" style="white-space:nowrap;">struct url *u</i>, <i class="farg" style="white-space:nowrap;">const char *flags</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">fetchStatHTTP</b>(<i class="farg" style="white-space:nowrap;">struct url *u</i>, <i class="farg" style="white-space:nowrap;">struct url_stat *us</i>, <i class="farg" style="white-space:nowrap;">const char *flags</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">fetchListHTTP</b>(<i class="farg" style="white-space:nowrap;">struct url_list *list</i>, <i class="farg" style="white-space:nowrap;">struct url *u</i>, <i class="farg" style="white-space:nowrap;">const char *flags</i>);<p>
<i class="ftype">fetchIO *</i><br>
<b class="fname">fetchXGetFTP</b>(<i class="farg" style="white-space:nowrap;">struct url *u</i>, <i class="farg" style="white-space:nowrap;">struct url_stat *us</i>, <i class="farg" style="white-space:nowrap;">const char *flags</i>);<p>
<i class="ftype">fetchIO *</i><br>
<b class="fname">fetchGetFTP</b>(<i class="farg" style="white-space:nowrap;">struct url *u</i>, <i class="farg" style="white-space:nowrap;">const char *flags</i>);<p>
<i class="ftype">fetchIO *</i><br>
<b class="fname">fetchPutFTP</b>(<i class="farg" style="white-space:nowrap;">struct url *u</i>, <i class="farg" style="white-space:nowrap;">const char *flags</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">fetchStatFTP</b>(<i class="farg" style="white-space:nowrap;">struct url *u</i>, <i class="farg" style="white-space:nowrap;">struct url_stat *us</i>, <i class="farg" style="white-space:nowrap;">const char *flags</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">fetchListFTP</b>(<i class="farg" style="white-space:nowrap;">struct url_list *list</i>, <i class="farg" style="white-space:nowrap;">struct url *u</i>, <i class="farg" style="white-space:nowrap;">const char *flags</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">fetchInitURLList</b>(<i class="farg" style="white-space:nowrap;">struct url_list *ul</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">fetchAppendURLList</b>(<i class="farg" style="white-space:nowrap;">struct url_list *dst</i>, <i class="farg" style="white-space:nowrap;">const struct url_list *src</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">fetchFreeURLList</b>(<i class="farg" style="white-space:nowrap;">struct url_list *ul</i>);<p>
<i class="ftype">char *</i><br>
<b class="fname">fetchUnquotePath</b>(<i class="farg" style="white-space:nowrap;">struct url *u</i>);<p>
<i class="ftype">char *</i><br>
<b class="fname">fetchUnquoteFilename</b>(<i class="farg" style="white-space:nowrap;">struct url *u</i>);<p>
<i class="ftype">char *</i><br>
<b class="fname">fetchStringifyURL</b>(<i class="farg" style="white-space:nowrap;">const struct url *u</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">fetchConnectionCacheInit</b>(<i class="farg" style="white-space:nowrap;">int global</i>, <i class="farg" style="white-space:nowrap;">int per_host</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">fetchConnectionCacheClose</b>(<i class="farg" style="white-space:nowrap;">void</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> These functions implement a high-level library for retrieving and uploading files using Uniform Resource Locators (URLs).<p>
<b class="fname">fetchParseURL</b>() takes a URL in the form of a null-terminated string and splits it into its components function according to the Common Internet Scheme Syntax detailed in RFC 1738. A regular expression which produces this syntax is:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
&lt;scheme&gt;:(//(&lt;user&gt;(:&lt;pwd&gt;)?@)?&lt;host&gt;(:&lt;port&gt;)?)?/(&lt;document&gt;)?</pre>
<p>
If the URL does not seem to begin with a scheme name, it is assumed to be a local path. Only absolute path names are accepted.<p>
Note that some components of the URL are not necessarily relevant to all URL schemes. For instance, the file scheme only needs the &#60;scheme&#62; and &#60;document&#62; components. <b class="fname">fetchParseURL</b>() quotes any unsafe character in the URL automatically. This is not done by <b class="fname">fetchMakeURL</b>(). <b class="fname">fetchCopyURL</b>() copies an existing <span class="type">url</span> structure.<p>
<b class="fname">fetchMakeURL</b>(), <b class="fname">fetchParseURL</b>(), and <b class="fname">fetchCopyURL</b>() return a pointer to a <span class="type">url</span> structure, which is defined as follows in <b class="includes">&lt;<a class="link-includes">fetch.h</a>&gt;</b>:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
#define URL_SCHEMELEN 16 
#define URL_USERLEN 256 
#define URL_PWDLEN 256 
#define URL_HOSTLEN 255 
 
struct url { 
    char	 scheme[URL_SCHEMELEN + 1]; 
    char	 user[URL_USERLEN + 1]; 
    char	 pwd[URL_PWDLEN + 1]; 
    char	 host[URL_HOSTLEN + 1]; 
    int		 port; 
    char	*doc; 
    off_t	 offset; 
    size_t	 length; 
    time_t	 last_modified; 
};</pre>
<p>
The pointer returned by <b class="fname">fetchMakeURL</b>(), <b class="fname">fetchCopyURL</b>(), and <b class="fname">fetchParseURL</b>() should be freed using <b class="fname">fetchFreeURL</b>(). The size of <span class="type">struct URL</span> is not part of the ABI.<p>
<b class="fname">fetchXGetURL</b>(), <b class="fname">fetchGetURL</b>(), and <b class="fname">fetchPutURL</b>() constitute the recommended interface to the <b class="name">fetch</b> library. They examine the URL passed to them to determine the transfer method, and call the appropriate lower-level functions to perform the actual transfer. <b class="fname">fetchXGetURL</b>() also returns the remote document's metadata in the <span class="type">url_stat</span> structure pointed to by the <i class="farg">us</i> argument.<p>
The <i class="farg">flags</i> argument is a string of characters which specify transfer options. The meaning of the individual flags is scheme-dependent, and is detailed in the appropriate section below.<p>
<b class="fname">fetchStatURL</b>() attempts to obtain the requested document's metadata and fill in the structure pointed to by its second argument. The <span class="type">url_stat</span> structure is defined as follows in <b class="includes">&lt;<a class="link-includes">fetch.h</a>&gt;</b>:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
struct url_stat { 
    off_t	 size; 
    time_t	 atime; 
    time_t	 mtime; 
};</pre>
<p>
If the size could not be obtained from the server, the <i class="farg">size</i> field is set to &#45;1. If the modification time could not be obtained from the server, the <i class="farg">mtime</i> field is set to the epoch. If the access time could not be obtained from the server, the <i class="farg">atime</i> field is set to the modification time.<p>
<b class="fname">fetchListURL</b>() attempts to list the contents of the directory pointed to by the URL provided. The pattern can be a simple glob-like expression as hint. Callers should not depend on the server to filter names. If successful, it appends the list of entries to the <span class="type">url_list</span> structure. The <span class="type">url_list</span> structure is defined as follows in <b class="includes">&lt;<a class="link-includes">fetch.h</a>&gt;</b>:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
struct url_list { 
    size_t	length; 
    size_t	alloc_size; 
    struct url	*urls; 
};</pre>
<p>
The list should be initialized by calling <b class="fname">fetchInitURLList</b>() and the entries be freed by calling <b class="fname">fetchFreeURLList</b>(). The function <b class="fname">fetchAppendURLList</b>() can be used to append one URL lists to another. If the &#8216;<code class="lit">c</code>&#8217; (cache result) flag is specified, the library is allowed to internally cache the result.<p>
<b class="fname">fetchStringifyURL</b>() returns the URL as string. <b class="fname">fetchUnquotePath</b>() returns the path name part of the URL with any quoting undone. Query arguments and fragment identifiers are not included. <b class="fname">fetchUnquoteFilename</b>() returns the last component of the path name as returned by <b class="fname">fetchUnquotePath</b>(). <b class="fname">fetchStringifyURL</b>(), <b class="fname">fetchUnquotePath</b>(), and <b class="fname">fetchUnquoteFilename</b>() return a string that should be deallocated with <b class="fname">free</b>() after use.<p>
<b class="fname">fetchConnectionCacheInit</b>() enables the connection cache. The first argument specifies the global limit on cached connections. The second argument specifies the host limit. Entries are considered to specify the same host, if the host name from the URL is identical, indepent of the address or address family. <b class="fname">fetchConnectionCacheClose</b>() flushed the connection cache and closes all cached connections.<p>
<b class="fname">fetchXGet</b>(), <b class="fname">fetchGet</b>(), <b class="fname">fetchPut</b>(), and <b class="fname">fetchStat</b>() are similar to <b class="fname">fetchXGetURL</b>(), <b class="fname">fetchGetURL</b>(), <b class="fname">fetchPutURL</b>(), and <b class="fname">fetchStatURL</b>(), except that they expect a pre-parsed URL in the form of a pointer to a <span class="type">struct url</span> rather than a string.<p>
All of the <b class="fname">fetchXGetXXX</b>(), <b class="fname">fetchGetXXX</b>(), and <b class="fname">fetchPutXXX</b>() functions return a pointer to a stream which can be used to read or write data from or to the requested document, respectively. Note that although the implementation details of the individual access methods vary, it can generally be assumed that a stream returned by one of the <b class="fname">fetchXGetXXX</b>() or <b class="fname">fetchGetXXX</b>() functions is read-only, and that a stream returned by one of the <b class="fname">fetchPutXXX</b>() functions is write-only.</div>
<div class="section">
<h1 id="x50524f544f434f4c20494e444550454e44454e5420464c414753">PROTOCOL INDEPENDENT FLAGS</h1> If the &#8216;<code class="lit">i</code>&#8217; (if-modified-since) flag is specified, the library will try to fetch the content only if it is newer than <b class="var">last_modified</b>. For HTTP an <code class="lit">If-Modified-Since</code> HTTP header is sent. For FTP a <code class="lit">MTDM</code> command is sent first and compared locally. For FILE the source file is compared.</div>
<div class="section">
<h1 id="x46494c4520534348454d45">FILE SCHEME</h1> <b class="fname">fetchXGetFile</b>(), <b class="fname">fetchGetFile</b>(), and <b class="fname">fetchPutFile</b>() provide access to documents which are files in a locally mounted file system. Only the &#60;document&#62; component of the URL is used.<p>
<b class="fname">fetchXGetFile</b>() and <b class="fname">fetchGetFile</b>() do not accept any flags.<p>
<b class="fname">fetchPutFile</b>() accepts the &#8216;<code class="lit">a</code>&#8217; (append to file) flag. If that flag is specified, the data written to the stream returned by <b class="fname">fetchPutFile</b>() will be appended to the previous contents of the file, instead of replacing them.</div>
<div class="section">
<h1 id="x46545020534348454d45">FTP SCHEME</h1> <b class="fname">fetchXGetFTP</b>(), <b class="fname">fetchGetFTP</b>(), and <b class="fname">fetchPutFTP</b>() implement the FTP protocol as described in RFC 959.<p>
By default <b class="name">libfetch</b> will attempt to use passive mode first and only fallback to active mode if the server reports a syntax error. If the &#8216;<code class="lit">a</code>&#8217; (active) flag is specified, a passive connection is not tried and active mode is used directly.<p>
If the &#8216;<code class="lit">l</code>&#8217; (low) flag is specified, data sockets will be allocated in the low (or default) port range instead of the high port range (see <a class="link-man" href="../4/ip">ip(4)</a>).<p>
If the &#8216;<code class="lit">d</code>&#8217; (direct) flag is specified, <b class="fname">fetchXGetFTP</b>(), <b class="fname">fetchGetFTP</b>(), and <b class="fname">fetchPutFTP</b>() will use a direct connection even if a proxy server is defined.<p>
If no user name or password is given, the <b class="name">fetch</b> library will attempt an anonymous login, with user name "anonymous" and password "anonymous@&lt;hostname&gt;".</div>
<div class="section">
<h1 id="x4854545020534348454d45">HTTP SCHEME</h1> The <b class="fname">fetchXGetHTTP</b>(), <b class="fname">fetchGetHTTP</b>(), and <b class="fname">fetchPutHTTP</b>() functions implement the HTTP/1.1 protocol. With a little luck, there is even a chance that they comply with RFC 2616 and RFC 2617.<p>
If the &#8216;<code class="lit">d</code>&#8217; (direct) flag is specified, <b class="fname">fetchXGetHTTP</b>(), <b class="fname">fetchGetHTTP</b>(), and <b class="fname">fetchPutHTTP</b>() will use a direct connection even if a proxy server is defined.<p>
Since there seems to be no good way of implementing the HTTP PUT method in a manner consistent with the rest of the <b class="name">fetch</b> library, <b class="fname">fetchPutHTTP</b>() is currently unimplemented.</div>
<div class="section">
<h1 id="x41555448454e5449434154494f4e">AUTHENTICATION</h1> Apart from setting the appropriate environment variables and specifying the user name and password in the URL or the <span class="type">struct url</span>, the calling program has the option of defining an authentication function with the following prototype:<p>
<i class="ftype">int</i> <b class="fname">myAuthMethod</b>(<i class="farg">struct url *u</i>)<p>
The callback function should fill in the <i class="farg">user</i> and <i class="farg">pwd</i> fields in the provided <span class="type">struct url</span> and return 0 on success, or any other value to indicate failure.<p>
To register the authentication callback, simply set <b class="var">fetchAuthMethod</b> to point at it. The callback will be used whenever a site requires authentication and the appropriate environment variables are not set.<p>
This interface is experimental and may be subject to change.</div>
<div class="section">
<h1 id="x52455455524e2056414c554553">RETURN VALUES</h1> <b class="fname">fetchParseURL</b>() returns a pointer to a <span class="type">struct url</span> containing the individual components of the URL. If it is unable to allocate memory, or the URL is syntactically incorrect, <b class="fname">fetchParseURL</b>() returns a <span class="define">NULL</span> pointer.<p>
The <b class="fname">fetchStat</b>() functions return 0 on success and &#45;1 on failure.<p>
All other functions return a stream pointer which may be used to access the requested document, or <span class="define">NULL</span> if an error occurred.<p>
The following error codes are defined in <b class="includes">&lt;<a class="link-includes">fetch.h</a>&gt;</b>:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">FETCH_ABORT</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Operation aborted</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">FETCH_AUTH</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Authentication failed</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">FETCH_DOWN</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Service unavailable</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">FETCH_EXISTS</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
File exists</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">FETCH_FULL</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
File system full</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">FETCH_INFO</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Informational response</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">FETCH_MEMORY</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Insufficient memory</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">FETCH_MOVED</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
File has moved</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">FETCH_NETWORK</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Network error</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">FETCH_OK</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
No error</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">FETCH_PROTO</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Protocol error</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">FETCH_RESOLV</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Resolver error</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">FETCH_SERVER</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Server error</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">FETCH_TEMP</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Temporary error</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">FETCH_TIMEOUT</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Operation timed out</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">FETCH_UNAVAIL</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
File is not available</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">FETCH_UNKNOWN</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Unknown error</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">FETCH_URL</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 18.00ex;">
Invalid URL</dd>
</dl>
<p>
The accompanying error message includes a protocol-specific error code and message, e.g. "File is not available (404 Not Found)"</div>
<div class="section">
<h1 id="x454e5649524f4e4d454e54">ENVIRONMENT</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="env">FETCH_BIND_ADDRESS</span></dt>
<dd class="list-tag" style="margin-left: 22.00ex;">
Specifies a host name or IP address to which sockets used for outgoing connections will be bound.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="env">FTP_LOGIN</span></dt>
<dd class="list-tag" style="margin-left: 22.00ex;">
Default FTP login if none was provided in the URL.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="env">FTP_PASSIVE_MODE</span></dt>
<dd class="list-tag" style="margin-left: 22.00ex;">
If set to anything but &#8216;<code class="lit">no</code>&#8217;, forces the FTP code to use passive mode.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="env">FTP_PASSWORD</span></dt>
<dd class="list-tag" style="margin-left: 22.00ex;">
Default FTP password if the remote server requests one and none was provided in the URL.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="env">FTP_PROXY</span></dt>
<dd class="list-tag" style="margin-left: 22.00ex;">
URL of the proxy to use for FTP requests. The document part is ignored. FTP and HTTP proxies are supported; if no scheme is specified, FTP is assumed. If the proxy is an FTP proxy, <b class="name">libfetch</b> will send &#8216;<code class="lit">user@host</code>&#8217; as user name to the proxy, where &#8216;<code class="lit">user</code>&#8217; is the real user name, and &#8216;<code class="lit">host</code>&#8217; is the name of the FTP server.<p>
If this variable is set to an empty string, no proxy will be used for FTP requests, even if the <span class="env">HTTP_PROXY</span> variable is set.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="env">ftp_proxy</span></dt>
<dd class="list-tag" style="margin-left: 22.00ex;">
Same as <span class="env">FTP_PROXY</span>, for compatibility.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="env">HTTP_AUTH</span></dt>
<dd class="list-tag" style="margin-left: 22.00ex;">
Specifies HTTP authorization parameters as a colon-separated list of items. The first and second item are the authorization scheme and realm respectively; further items are scheme-dependent. Currently, only basic authorization is supported.<p>
Basic authorization requires two parameters: the user name and password, in that order.<p>
This variable is only used if the server requires authorization and no user name or password was specified in the URL.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="env">HTTP_PROXY</span></dt>
<dd class="list-tag" style="margin-left: 22.00ex;">
URL of the proxy to use for HTTP requests. The document part is ignored. Only HTTP proxies are supported for HTTP requests. If no port number is specified, the default is 3128.<p>
Note that this proxy will also be used for FTP documents, unless the <span class="env">FTP_PROXY</span> variable is set.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="env">http_proxy</span></dt>
<dd class="list-tag" style="margin-left: 22.00ex;">
Same as <span class="env">HTTP_PROXY</span>, for compatibility.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="env">HTTP_PROXY_AUTH</span></dt>
<dd class="list-tag" style="margin-left: 22.00ex;">
Specifies authorization parameters for the HTTP proxy in the same format as the <span class="env">HTTP_AUTH</span> variable.<p>
This variable is used if and only if connected to an HTTP proxy, and is ignored if a user and/or a password were specified in the proxy URL.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="env">HTTP_REFERER</span></dt>
<dd class="list-tag" style="margin-left: 22.00ex;">
Specifies the referrer URL to use for HTTP requests. If set to &#8220;auto&#8221;, the document URL will be used as referrer URL.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="env">HTTP_USER_AGENT</span></dt>
<dd class="list-tag" style="margin-left: 22.00ex;">
Specifies the User-Agent string to use for HTTP requests. This can be useful when working with HTTP origin or proxy servers that differentiate between user agents.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="env">NETRC</span></dt>
<dd class="list-tag" style="margin-left: 22.00ex;">
Specifies a file to use instead of <i class="file">~/.netrc</i> to look up login names and passwords for FTP sites. See <a class="link-man" href="../1/ftp">ftp(1)</a> for a description of the file format. This feature is experimental.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="env">NO_PROXY</span></dt>
<dd class="list-tag" style="margin-left: 22.00ex;">
Either a single asterisk, which disables the use of proxies altogether, or a comma- or whitespace-separated list of hosts for which proxies should not be used.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="env">no_proxy</span></dt>
<dd class="list-tag" style="margin-left: 22.00ex;">
Same as <span class="env">NO_PROXY</span>, for compatibility.</dd>
</dl>
</div>
<div class="section">
<h1 id="x4558414d504c4553">EXAMPLES</h1> To access a proxy server on <i class="file">proxy.example.com</i> port 8080, set the <span class="env">HTTP_PROXY</span> environment variable in a manner similar to this:<p>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">HTTP_PROXY=http://proxy.example.com:8080</code></div>
</blockquote>
<p>
If the proxy server requires authentication, there are two options available for passing the authentication data. The first method is by using the proxy URL:<p>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">HTTP_PROXY=http://&lt;user&gt;:&lt;pwd&gt;@proxy.example.com:8080</code></div>
</blockquote>
<p>
The second method is by using the <span class="env">HTTP_PROXY_AUTH</span> environment variable:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
HTTP_PROXY=http://proxy.example.com:8080 
HTTP_PROXY_AUTH=basic:*:&lt;user&gt;:&lt;pwd&gt;</pre>
<p>
To disable the use of a proxy for an HTTP server running on the local host, define <span class="env">NO_PROXY</span> as follows:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
NO_PROXY=localhost,127.0.0.1</pre>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../1/ftp">ftp(1)</a>, <a class="link-man" href="../4/ip">ip(4)</a><p>
<span class="ref"><span class="ref-auth">J. Postel</span> and <span class="ref-auth">J. K. Reynolds</span>, <i class="ref-book">File Transfer Protocol</i>, <span class="ref-date">October 1985</span>, <span class="ref-opt">RFC 959</span>.</span><p>
<span class="ref"><span class="ref-auth">P. Deutsch</span>, <span class="ref-auth">A. Emtage</span>, and <span class="ref-auth">A. Marine</span>, <span class="ref-title">How to Use Anonymous FTP</span>, <span class="ref-date">May 1994</span>, <span class="ref-opt">RFC 1635</span>.</span><p>
<span class="ref"><span class="ref-auth">T. Berners-Lee</span>, <span class="ref-auth">L. Masinter</span>, and <span class="ref-auth">M. McCahill</span>, <span class="ref-title">Uniform Resource Locators (URL)</span>, <span class="ref-date">December 1994</span>, <span class="ref-opt">RFC 1738</span>.</span><p>
<span class="ref"><span class="ref-auth">R. Fielding</span>, <span class="ref-auth">J. Gettys</span>, <span class="ref-auth">J. Mogul</span>, <span class="ref-auth">H. Frystyk</span>, <span class="ref-auth">L. Masinter</span>, <span class="ref-auth">P. Leach</span>, and <span class="ref-auth">T. Berners-Lee</span>, <i class="ref-book">Hypertext Transfer Protocol -- HTTP/1.1</i>, <span class="ref-date">January 1999</span>, <span class="ref-opt">RFC 2616</span>.</span><p>
<span class="ref"><span class="ref-auth">J. Franks</span>, <span class="ref-auth">P. Hallam-Baker</span>, <span class="ref-auth">J. Hostetler</span>, <span class="ref-auth">S. Lawrence</span>, <span class="ref-auth">P. Leach</span>, <span class="ref-auth">A. Luotonen</span>, and <span class="ref-auth">L. Stewart</span>, <i class="ref-book">HTTP Authentication: Basic and Digest Access Authentication</i>, <span class="ref-date">June 1999</span>, <span class="ref-opt">RFC 2617</span>.</span></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The <b class="name">fetch</b> library first appeared in <span class="unix">FreeBSD&#160;3.0</span>.</div>
<div class="section">
<h1 id="x415554484f5253">AUTHORS</h1> <span class="author"></span>The <b class="name">fetch</b> library was mostly written by <span class="author">Dag-Erling Sm&#248;rgrav</span> &#60;<a class="link-mail" href="mailto:des@FreeBSD.org">des@FreeBSD.org</a>&#62; with numerous suggestions from <span class="author">Jordan K. Hubbard</span> &#60;<a class="link-mail" href="mailto:jkh@FreeBSD.org">jkh@FreeBSD.org</a>&#62;, <span class="author">Eugene Skepner</span> &#60;<a class="link-mail" href="mailto:eu@qub.com">eu@qub.com</a>&#62; and other <span class="unix">FreeBSD</span> developers. It replaces the older <b class="name">ftpio</b> library written by <span class="author">Poul-Henning Kamp</span> &#60;<a class="link-mail" href="mailto:phk@FreeBSD.org">phk@FreeBSD.org</a>&#62; and <span class="author">Jordan K. Hubbard</span> &#60;<a class="link-mail" href="mailto:jkh@FreeBSD.org">jkh@FreeBSD.org</a>&#62;.<p>
This manual page was written by <span class="author">Dag-Erling Sm&#248;rgrav</span> &#60;<a class="link-mail" href="mailto:des@FreeBSD.org">des@FreeBSD.org</a>&#62;.</div>
<div class="section">
<h1 id="x42554753">BUGS</h1> Some parts of the library are not yet implemented. The most notable examples of this are <b class="fname">fetchPutHTTP</b>() and FTP proxy support.<p>
There is no way to select a proxy at run-time other than setting the <span class="env">HTTP_PROXY</span> or <span class="env">FTP_PROXY</span> environment variables as appropriate.<p>
<b class="name">libfetch</b> does not understand or obey 305 (Use Proxy) replies.<p>
Error numbers are unique only within a certain context; the error codes used for FTP and HTTP overlap, as do those used for resolver and system errors. For instance, error code 202 means "Command not implemented, superfluous at this site" in an FTP context and "Accepted" in an HTTP context.<p>
<b class="fname">fetchStatFTP</b>() does not check that the result of an MDTM command is a valid date.<p>
The man page is incomplete, poorly written and produces badly formatted text.<p>
The error reporting mechanism is unsatisfactory.<p>
Some parts of the code are not fully reentrant.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
January 22, 2010</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

