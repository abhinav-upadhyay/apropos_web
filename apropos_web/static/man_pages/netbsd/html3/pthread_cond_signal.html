<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/../4/strict.dtd">
>
<head>
<meta http-equiv="Content-Type" content="te../; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
PTHREAD_COND(3)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
PTHREAD_COND(3)</td>
<td class="head-vol" align="center">
Library Functions Manual</td>
<td class="head-rtitle" align="right">
PTHREAD_COND(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">pthread_cond</b> &#8212; <span class="desc">condition variable interface</span></div>
<div class="section">
<h1 id="x4c494252415259">LIBRARY</h1> <span class="lib">POSIX Threads Library (libpthread, &#45;lpthread)</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">pthread.h</a>&gt;</b><p>
<i class="ftype">int</i><br>
<b class="fname">pthread_cond_init</b>(<i class="farg" style="white-space:nowrap;">pthread_cond_t * restrict cond</i>, <i class="farg" style="white-space:nowrap;">const pthread_condattr_t * restrict attr</i>);<p>
<span class="type">pthread_cond_t cond = <span class="define">PTHREAD_COND_INITIALIZER;</span></span><p>
<i class="ftype">int</i><br>
<b class="fname">pthread_cond_destroy</b>(<i class="farg" style="white-space:nowrap;">pthread_cond_t *cond</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">pthread_cond_broadcast</b>(<i class="farg" style="white-space:nowrap;">pthread_cond_t *cond</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">pthread_cond_signal</b>(<i class="farg" style="white-space:nowrap;">pthread_cond_t *cond</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">pthread_cond_wait</b>(<i class="farg" style="white-space:nowrap;">pthread_cond_t * restrict cond</i>, <i class="farg" style="white-space:nowrap;">pthread_mutex_t * restrict mutex</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">pthread_cond_timedwait</b>(<i class="farg" style="white-space:nowrap;">pthread_cond_t * restrict cond</i>, <i class="farg" style="white-space:nowrap;">pthread_mutex_t * restrict mutex</i>, <i class="farg" style="white-space:nowrap;">const struct timespec * restrict abstime</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> Condition variables are intended to be used to communicate changes in the state of data shared between threads. Condition variables are always associated with a mutex to provide synchronized access to the shared data. A single predicate should always be associated with a condition variable. The predicate should identify a state of the shared data that must be true before the thread proceeds.<p>
The <b class="fname">pthread_cond_init</b>() function creates a new condition variable, with attributes specified with <i class="farg">attr</i>. If <i class="farg">attr</i> is <span class="define">NULL</span> the default attributes are used. The <b class="fname">pthread_cond_destroy</b>() function frees the resources allocated by the condition variable <i class="farg">cond</i>.<p>
The macro <span class="define">PTHREAD_COND_INITIALIZER</span> can be used to initialize a condition variable when it can be statically allocated and the default attributes are appropriate. The effect is similar to calling <b class="fname">pthread_cond_init</b>() with <i class="farg">attr</i> specified as <span class="define">NULL</span>, except that no error checking is done.<p>
The difference between <b class="fname">pthread_cond_broadcast</b>() and <b class="fname">pthread_cond_signal</b>() is that the former unblocks all threads waiting for the condition variable, whereas the latter blocks only one waiting thread. If no threads are waiting on <i class="farg">cond</i>, neither function has any effect. If more than one thread is blocked on a condition variable, the used scheduling policy determines the order in which threads are unblocked. The same mutex used for waiting must be held while calling either function. Although neither function strictly enforces this requirement, undefined behavior may follow if the mutex is not held.<p>
The <b class="fname">pthread_cond_wait</b>() function atomically blocks the current thread waiting on the condition variable specified by <i class="farg">cond</i>, and unlocks the mutex specified by <i class="farg">mutex</i>. The <b class="fname">pthread_cond_timedwait</b>() function behaves similarly, but unblocks also if the system time reaches the time specified in <i class="farg">abstime</i>, represented as <span class="emph">struct timespec</span> (see <a class="link-man" href="../3/timespec">timespec(3)</a>). With both functions the waiting thread unblocks after another thread calls <b class="fname">pthread_cond_signal</b>() or <b class="fname">pthread_cond_broadcast</b>() with the same condition variable and by holding the same <i class="farg">mutex</i> that was associated with <i class="farg">cond</i> by either one of the blocking functions. The current thread holds the lock on <i class="farg">mutex</i> upon return from either function.<p>
Note that a call to <b class="fname">pthread_cond_wait</b>() or <b class="fname">pthread_cond_timedwait</b>() may wake up spontaneously, without a call to <b class="fname">pthread_cond_signal</b>() or <b class="fname">pthread_cond_broadcast</b>(). The caller should prepare for this by invoking either function within a predicate loop that tests whether the thread should proceed.<p>
As noted, when calling either function that waits on a condition variable, a temporary binding is established between the condition variable <i class="farg">cond</i> and the mutex <i class="farg">mutex</i>. During this time, the effect of an attempt by any thread to wait on that condition variable using a different mutex is undefined. The same mutex must be held while broadcasting or signaling on <i class="farg">cond</i>. Additionally, the same mutex must be used for concurrent calls to <b class="fname">pthread_cond_wait</b>() and <b class="fname">pthread_cond_timedwait</b>(). Only when a condition variable is known to be quiescent may an application change the mutex associated with it. In this implementation, none of the functions enforce this requirement, but if the mutex is not held or independent mutexes are used the resulting behaviour is undefined.</div>
<div class="section">
<h1 id="x52455455524e2056414c554553">RETURN VALUES</h1> If successful, all functions return zero. Otherwise, an error number will be returned to indicate the error.</div>
<div class="section">
<h1 id="x4552524f5253">ERRORS</h1> The <b class="fname">pthread_cond_init</b>() function may fail if:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">EINVAL</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
The value specified by <i class="farg">attr</i> is invalid.</dd>
</dl>
<p>
The <b class="fname">pthread_cond_destroy</b>() function may fail if:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">EBUSY</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
The variable <i class="farg">cond</i> is locked by another thread.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">EINVAL</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
The value specified by <i class="farg">cond</i> is invalid.</dd>
</dl>
<p>
Both <b class="fname">pthread_cond_broadcast</b>() and <b class="fname">pthread_cond_signal</b>() may fail if:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">EINVAL</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
The value specified by <i class="farg">cond</i> is invalid.</dd>
</dl>
<p>
Both <b class="fname">pthread_cond_wait</b>() and <b class="fname">pthread_cond_timedwait</b>() may fail if:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">EINVAL</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
The value specified by <i class="farg">cond</i> or the value specified by <i class="farg">mutex</i> is invalid.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">EPERM</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
The value specified by <i class="farg">mutex</i> was not locked in the condition wait.</dd>
</dl>
<p>
The <b class="fname">pthread_cond_timedwait</b>() function may additionally fail if:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">ETIMEDOUT</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
The system time has reached or exceeded the time specified in <i class="farg">abstime</i>.</dd>
</dl>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../3/pthread">pthread(3)</a>, <a class="link-man" href="../3/pthread_barrier">pthread_barrier(3)</a>, <a class="link-man" href="../3/pthread_condattr">pthread_condattr(3)</a>, <a class="link-man" href="../3/pthread_mutex">pthread_mutex(3)</a>, <a class="link-man" href="../3/pthread_rwlock">pthread_rwlock(3)</a>, <a class="link-man" href="../3/pthread_spin">pthread_spin(3)</a></div>
<div class="section">
<h1 id="x5354414e4441524453">STANDARDS</h1> These functions conform to IEEE Std 1003.1-2001 (&#8220;POSIX.1&#8221;).</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
July 8, 2010</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
<>

