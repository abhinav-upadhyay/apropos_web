<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
evthread(3)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
evthread(3)</td>
<td class="head-vol" align="center">
Library Functions Manual</td>
<td class="head-rtitle" align="right">
evthread(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> evthread &#45;<p>
Functions for multi-threaded applications using Libevent.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>SYNOPSIS</h1> #include &lt;event2/thread.h&gt;<div style="height: 0.00em;">
&#160;</div>
#include &lt;event2/event-config.h&gt;<div style="height: 0.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="subsection">
<h2>Data Structures</h2><br>
struct <b>evthread_condition_callbacks</b><div style="height: 0.00em;">
&#160;</div>
<i>This structure describes the interface a threading library uses for condition variables. </i> struct  <b>evthread_lock_callbacks</b><div style="height: 0.00em;">
&#160;</div>
<i>This structure describes the interface a threading library uses for locking. </i><br>
</div>
<div class="subsection">
<h2>Macros</h2><br>
#define <b>EVTHREAD_CONDITION_API_VERSION</b>   1<div style="height: 0.00em;">
&#160;</div>
#define <b>EVTHREAD_LOCK_API_VERSION</b>   1<div style="height: 0.00em;">
&#160;</div>
#define <b>EVTHREAD_USE_PTHREADS_IMPLEMENTED</b>   1<div style="height: 0.00em;">
&#160;</div>
<i>Defined if Libevent was built with support for </i><b>evthread_use_pthreads()</b><i> </i><b></b> #define  <b>EVTHREAD_USE_WINDOWS_THREADS_IMPLEMENTED</b>   1<div style="height: 0.00em;">
&#160;</div>
<i>Defined if Libevent was built with support for </i><b>evthread_use_windows_threads()</b><i> </i><b></b><br>
<p>
<b>Flags passed to lock functions</b><div style="height: 0.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<br>
<br>
#define <b>EVTHREAD_WRITE</b>   0x04<div style="height: 0.00em;">
&#160;</div>
<i>A flag passed to a locking callback when the lock was allocated as a read-write lock, and we want to acquire or release the lock for writing. </i> #define  <b>EVTHREAD_READ</b>   0x08<div style="height: 0.00em;">
&#160;</div>
<i>A flag passed to a locking callback when the lock was allocated as a read-write lock, and we want to acquire or release the lock for reading. </i> #define  <b>EVTHREAD_TRY</b>   0x10<div style="height: 0.00em;">
&#160;</div>
<i>A flag passed to a locking callback when we don't want to block waiting for the lock; if we can't get the lock immediately, we will instead return nonzero from the locking callback. </i><br>
<br>
<p>
<b>Types of locks</b><div style="height: 0.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<br>
<br>
#define <b>EVTHREAD_LOCKTYPE_RECURSIVE</b>   1<div style="height: 0.00em;">
&#160;</div>
<i>A recursive lock is one that can be acquired multiple times at once by the same thread. </i> #define  <b>EVTHREAD_LOCKTYPE_READWRITE</b>   2<div style="height: 0.00em;">
&#160;</div>
<br>
<br>
</div>
<div class="subsection">
<h2>Functions</h2><br>
void <b>evthread_enable_lock_debuging</b> (void)<div style="height: 0.00em;">
&#160;</div>
<i>Enable debugging wrappers around the current lock callbacks. </i> int  <b>evthread_make_base_notifiable</b> (struct <b>event_base</b> *base)<div style="height: 0.00em;">
&#160;</div>
<i>Make sure it's safe to tell an event base to wake up from another thread or a signal handler. </i> int  <b>evthread_set_condition_callbacks</b> (const struct <b>evthread_condition_callbacks</b> *)<div style="height: 0.00em;">
&#160;</div>
<i>Sets a group of functions that Libevent should use for condition variables. </i> void  <b>evthread_set_id_callback</b> (unsigned long(*id_fn)(void))<div style="height: 0.00em;">
&#160;</div>
<i>Sets the function for determining the thread id. </i> int  <b>evthread_set_lock_callbacks</b> (const struct <b>evthread_lock_callbacks</b> *)<div style="height: 0.00em;">
&#160;</div>
<i>Sets a group of functions that Libevent should use for locking. </i> int  <b>evthread_use_pthreads</b> (void)<div style="height: 0.00em;">
&#160;</div>
<i>Sets up Libevent for use with Pthreads locking and thread ID functions. </i> int  <b>evthread_use_windows_threads</b> (void)<div style="height: 0.00em;">
&#160;</div>
<i>Sets up Libevent for use with Windows builtin locking and thread ID functions. </i><br>
</div>
</div>
<div class="section">
<h1>Detailed Description</h1> Functions for multi-threaded applications using Libevent.<div style="height: 1.00em;">
&#160;</div>
When using a multi-threaded application in which multiple threads add and delete events from a single event base, Libevent needs to lock its data structures.<p>
Like the memory-management function hooks, all of the threading functions <i>must</i> be set up before an <b>event_base</b> is created if you want the base to use them.<p>
Most programs will either be using Windows threads or Posix threads. You can configure Libevent to use one of these event_use_windows_threads() or event_use_pthreads() respectively. If you're using another threading library, you'll need to configure threading functions manually using <b>evthread_set_lock_callbacks()</b> and <b>evthread_set_condition_callbacks()</b>.</div>
<div class="section">
<h1>Macro Definition Documentation</h1><div class="subsection">
<h2>#define EVTHREAD_LOCKTYPE_RECURSIVE   1</h2> A recursive lock is one that can be acquired multiple times at once by the same thread. No other process can allocate the lock until the thread that has been holding it has unlocked it as many times as it locked it.</div>
<div class="subsection">
<h2>#define EVTHREAD_READ   0x08</h2> A flag passed to a locking callback when the lock was allocated as a read-write lock, and we want to acquire or release the lock for reading.</div>
<div class="subsection">
<h2>#define EVTHREAD_TRY   0x10</h2> A flag passed to a locking callback when we don't want to block waiting for the lock; if we can't get the lock immediately, we will instead return nonzero from the locking callback.</div>
<div class="subsection">
<h2>#define EVTHREAD_WRITE   0x04</h2> A flag passed to a locking callback when the lock was allocated as a read-write lock, and we want to acquire or release the lock for writing.</div>
</div>
<div class="section">
<h1>Function Documentation</h1><div class="subsection">
<h2>void evthread_enable_lock_debuging (void)</h2> Enable debugging wrappers around the current lock callbacks. If Libevent makes one of several common locking errors, exit with an assertion failure.<p>
If you're going to call this function, you must do so before any locks are allocated.</div>
<div class="subsection">
<h2>int evthread_make_base_notifiable (struct <b>event_base</b> *base)</h2> Make sure it's safe to tell an event base to wake up from another thread or a signal handler.<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 on success, -1 on failure.</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int evthread_set_condition_callbacks (const struct <b>evthread_condition_callbacks</b> *)</h2> Sets a group of functions that Libevent should use for condition variables. For full information on the required callback API, see the documentation for the individual members of  <b>evthread_condition_callbacks</b>.<p>
Note that if you're using Windows or the Pthreads threading library, you probably shouldn't call this function; instead, use <b>evthread_use_windows_threads()</b> or <b>evthread_use_pthreads()</b> if you can.</div>
<div class="subsection">
<h2>void evthread_set_id_callback (unsigned long(*)(void)id_fn)</h2> Sets the function for determining the thread id.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>base</i> the event base for which to set the id function<div style="height: 0.00em;">
&#160;</div>
<i>id_fn</i> the identify function Libevent should invoke to determine the identity of a thread.</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int evthread_set_lock_callbacks (const struct <b>evthread_lock_callbacks</b> *)</h2> Sets a group of functions that Libevent should use for locking. For full information on the required callback API, see the documentation for the individual members of  <b>evthread_lock_callbacks</b>.<p>
Note that if you're using Windows or the Pthreads threading library, you probably shouldn't call this function; instead, use <b>evthread_use_windows_threads()</b> or evthread_use_posix_threads() if you can.</div>
<div class="subsection">
<h2>int evthread_use_pthreads (void)</h2> Sets up Libevent for use with Pthreads locking and thread ID functions. Unavailable if Libevent is not build for use with pthreads. Requires libraries to link against Libevent_pthreads as well as Libevent.<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 on success, -1 on failure.</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int evthread_use_windows_threads (void)</h2> Sets up Libevent for use with Windows builtin locking and thread ID functions. Unavailable if Libevent is not built for Windows.<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 on success, -1 on failure.</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
</div>
<div class="section">
<h1>Author</h1> Generated automatically by Doxygen for libevent from the source code.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tr>
<td class="foot-date">
Tue Jan 27 2015</td>
<td class="foot-os" align="right">
libevent</td>
</tr>
</table>
</div>
</body>
</html>

