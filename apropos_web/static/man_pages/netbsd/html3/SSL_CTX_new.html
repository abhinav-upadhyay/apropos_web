<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/../4/strict.dtd">
>
<head>
<meta http-equiv="Content-Type" content="te../; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
SSL_CTX_new(3)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
SSL_CTX_new(3)</td>
<td class="head-vol" align="center">
OpenSSL</td>
<td class="head-rtitle" align="right">
SSL_CTX_new(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> SSL_CTX_new &#45; create a new SSL_CTX object as framework for TLS/SSL enabled functions</div>
<div class="section">
<h1>LIBRARY</h1> libcrypto, -lcrypto</div>
<div class="section">
<h1>SYNOPSIS</h1><br>
 #include &lt;openssl/ssl.h&gt;<br>
<br>
 SSL_CTX *SSL_CTX_new(const SSL_METHOD *method);<br>
</div>
<div class="section">
<h1>DESCRIPTION</h1>  <i>SSL_CTX_new()</i> creates a new <b>SSL_CTX</b> object as framework to establish TLS/SSL enabled connections.</div>
<div class="section">
<h1>NOTES</h1> The SSL_CTX object uses  <b>method</b> as connection method. The methods exist in a generic type (for client and server use), a server only type, and a client only type.  <b>method</b> can be of the following types:<dl>
<dt>
SSLv2_method(void), SSLv2_server_method(void), SSLv2_client_method(void)</dt>
<dd>
A TLS/SSL connection established with these methods will only understand the SSLv2 protocol. A client will send out SSLv2 client hello messages and will also indicate that it only understand SSLv2. A server will only understand SSLv2 client hello messages.</dd>
</dl>
<dl>
<dt>
SSLv3_method(void), SSLv3_server_method(void), SSLv3_client_method(void)</dt>
<dd>
A TLS/SSL connection established with these methods will only understand the SSLv3 protocol. A client will send out SSLv3 client hello messages and will indicate that it only understands SSLv3. A server will only understand SSLv3 client hello messages. This especially means, that it will not understand SSLv2 client hello messages which are widely used for compatibility reasons, see SSLv23_* <i>_method()</i>.</dd>
</dl>
<dl>
<dt>
TLSv1_method(void), TLSv1_server_method(void), TLSv1_client_method(void)</dt>
<dd>
A TLS/SSL connection established with these methods will only understand the TLSv1 protocol. A client will send out TLSv1 client hello messages and will indicate that it only understands TLSv1. A server will only understand TLSv1 client hello messages. This especially means, that it will not understand SSLv2 client hello messages which are widely used for compatibility reasons, see SSLv23_* <i>_method()</i>. It will also not understand SSLv3 client hello messages.</dd>
</dl>
<dl>
<dt>
SSLv23_method(void), SSLv23_server_method(void), SSLv23_client_method(void)</dt>
<dd>
A TLS/SSL connection established with these methods may understand the SSLv2, SSLv3, TLSv1, TLSv1.1 and TLSv1.2 protocols.<div style="height: 1.00em;">
&#160;</div>
If the cipher list does not contain any SSLv2 ciphersuites (the default cipher list does not) or extensions are required (for example server name) a client will send out TLSv1 client hello messages including extensions and will indicate that it also understands TLSv1.1, TLSv1.2 and permits a fallback to SSLv3. A server will support SSLv3, TLSv1, TLSv1.1 and TLSv1.2 protocols. This is the best choice when compatibility is a concern.<div style="height: 1.00em;">
&#160;</div>
If any SSLv2 ciphersuites are included in the cipher list and no extensions are required then SSLv2 compatible client hellos will be used by clients and SSLv2 will be accepted by servers. This is  <b>not</b> recommended due to the insecurity of SSLv2 and the limited nature of the SSLv2 client hello prohibiting the use of extensions.</dd>
</dl>
<p>
The list of protocols available can later be limited using the SSL_OP_NO_SSLv2, SSL_OP_NO_SSLv3, SSL_OP_NO_TLSv1, SSL_OP_NO_TLSv1_1 and SSL_OP_NO_TLSv1_2 options of the  <i>SSL_CTX_set_options()</i> or <i>SSL_set_options()</i> functions. Using these options it is possible to choose e.g.  <i>SSLv23_server_method()</i> and be able to negotiate with all possible clients, but to only allow newer protocols like TLSv1, TLSv1.1 or TLS v1.2.<p>
Applications which never want to support SSLv2 (even is the cipher string is configured to use SSLv2 ciphersuites) can set SSL_OP_NO_SSLv2.<p>
<i>SSL_CTX_new()</i> initializes the list of ciphers, the session cache setting, the callbacks, the keys and certificates and the options to its default values.</div>
<div class="section">
<h1>RETURN VALUES</h1> The following return values can occur:<dl>
<dt>
NULL</dt>
<dd>
The creation of a new SSL_CTX object failed. Check the error stack to find out the reason.</dd>
</dl>
<dl>
<dt>
Pointer to an SSL_CTX object</dt>
<dd>
The return value points to an allocated SSL_CTX object.</dd>
</dl>
</div>
<div class="section">
<h1>SEE ALSO</h1>  <i>SSL_CTX_free</i>(3), <i>SSL_accept</i>(3),  <i>ssl</i>(3),  <i>SSL_set_connect_state</i>(3)</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tr>
<td class="foot-date">
2014-08-10</td>
<td class="foot-os" align="right">
1.0.1n</td>
</tr>
</table>
</div>
</body>
<>

