<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
archive_read_disk(3)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
archive_read_disk(3)</td>
<td class="head-vol" align="center">
Library Functions Manual</td>
<td class="head-rtitle" align="right">
archive_read_disk(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">archive_read_disk_new</b>, <b class="name">archive_read_disk_set_symlink_logical</b>, <b class="name">archive_read_disk_set_symlink_physical</b>, <b class="name">archive_read_disk_set_symlink_hybrid</b>, <b class="name">archive_read_disk_entry_from_file</b>, <b class="name">archive_read_disk_gname</b>, <b class="name">archive_read_disk_uname</b>, <b class="name">archive_read_disk_set_uname_lookup</b>, <b class="name">archive_read_disk_set_gname_lookup</b>, <b class="name">archive_read_disk_set_standard_lookup</b>, <b class="name">archive_read_close</b>, <b class="name">archive_read_finish</b> &#8212; <span class="desc">functions for reading objects from disk</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">archive.h</a>&gt;</b><p>
<i class="ftype">struct archive *</i><br>
<b class="fname">archive_read_disk_new</b>(<i class="farg" style="white-space:nowrap;">void</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">archive_read_disk_set_symlink_logical</b>(<i class="farg" style="white-space:nowrap;">struct archive *</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">archive_read_disk_set_symlink_physical</b>(<i class="farg" style="white-space:nowrap;">struct archive *</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">archive_read_disk_set_symlink_hybrid</b>(<i class="farg" style="white-space:nowrap;">struct archive *</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">archive_read_disk_gname</b>(<i class="farg" style="white-space:nowrap;">struct archive *</i>, <i class="farg" style="white-space:nowrap;">gid_t</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">archive_read_disk_uname</b>(<i class="farg" style="white-space:nowrap;">struct archive *</i>, <i class="farg" style="white-space:nowrap;">uid_t</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">archive_read_disk_set_gname_lookup</b>(<i class="farg">struct archive *</i>, <i class="farg">void *</i>, <i class="farg">const char *(*lookup)(void *, gid_t)</i>, <i class="farg">void (*cleanup)(void *)</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">archive_read_disk_set_uname_lookup</b>(<i class="farg">struct archive *</i>, <i class="farg">void *</i>, <i class="farg">const char *(*lookup)(void *, uid_t)</i>, <i class="farg">void (*cleanup)(void *)</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">archive_read_disk_set_standard_lookup</b>(<i class="farg" style="white-space:nowrap;">struct archive *</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">archive_read_disk_entry_from_file</b>(<i class="farg">struct archive *</i>, <i class="farg">struct archive_entry *</i>, <i class="farg">int fd</i>, <i class="farg">const struct stat *</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">archive_read_close</b>(<i class="farg" style="white-space:nowrap;">struct archive *</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">archive_read_finish</b>(<i class="farg" style="white-space:nowrap;">struct archive *</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> These functions provide an API for reading information about objects on disk. In particular, they provide an interface for populating struct archive_entry objects.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">archive_read_disk_new</b>()</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Allocates and initializes a struct archive object suitable for reading object information from disk.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">archive_read_disk_set_symlink_logical</b>(), <b class="fname">archive_read_disk_set_symlink_physical</b>(), <b class="fname">archive_read_disk_set_symlink_hybrid</b>()</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This sets the mode used for handling symbolic links. The &#8220;logical&#8221; mode follows all symbolic links. The &#8220;physical&#8221; mode does not follow any symbolic links. The &#8220;hybrid&#8221; mode currently behaves identically to the &#8220;logical&#8221; mode.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">archive_read_disk_gname</b>(), <b class="fname">archive_read_disk_uname</b>()</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Returns a user or group name given a gid or uid value. By default, these always return a NULL string.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">archive_read_disk_set_gname_lookup</b>(), <b class="fname">archive_read_disk_set_uname_lookup</b>()</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
These allow you to override the functions used for user and group name lookups. You may also provide a void * pointer to a private data structure and a cleanup function for that data. The cleanup function will be invoked when the struct archive object is destroyed or when new lookup functions are registered.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">archive_read_disk_set_standard_lookup</b>()</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This convenience function installs a standard set of user and group name lookup functions. These functions use <a class="link-man" href="../3/getpwid">getpwid(3)</a> and <a class="link-man" href="../3/getgrid">getgrid(3)</a> to convert ids to names, defaulting to NULL if the names cannot be looked up. These functions also implement a simple memory cache to reduce the number of calls to <a class="link-man" href="../3/getpwid">getpwid(3)</a> and <a class="link-man" href="../3/getgrid">getgrid(3)</a>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">archive_read_disk_entry_from_file</b>()</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Populates a struct archive_entry object with information about a particular file. The archive_entry object must have already been created with <a class="link-man" href="../3/archive_entry_new">archive_entry_new(3)</a> and at least one of the source path or path fields must already be set. (If both are set, the source path will be used.)<p>
Information is read from disk using the path name from the struct archive_entry object. If a file descriptor is provided, some information will be obtained using that file descriptor, on platforms that support the appropriate system calls.<p>
If a pointer to a struct stat is provided, information from that structure will be used instead of reading from the disk where appropriate. This can provide performance benefits in scenarios where struct stat information has already been read from the disk as a side effect of some other operation. (For example, directory traversal libraries often provide this information.)<p>
Where necessary, user and group ids are converted to user and group names using the currently registered lookup functions above. This affects the file ownership fields and ACL values in the struct archive_entry object.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">archive_read_close</b>()</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This currently does nothing.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">archive_write_finish</b>()</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Invokes <b class="fname">archive_write_close</b>() if it was not invoked manually, then releases all resources.</dd>
</dl>
More information about the <b class="var">struct archive</b> object and the overall design of the library can be found in the <a class="link-man" href="../3/libarchive">libarchive(3)</a> overview.</div>
<div class="section">
<h1 id="x4558414d504c45">EXAMPLE</h1> The following illustrates basic usage of the library by showing how to use it to copy an item on disk into an archive.<p>
<pre style="margin-left: 5.00ex;" class="lit display">
void 
file_to_archive(struct archive *a, const char *name) 
{ 
  char buff[8192]; 
  size_t bytes_read; 
  struct archive *ard; 
  struct archive_entry *entry; 
  int fd; 
 
  ard = archive_read_disk_new(); 
  archive_read_disk_set_standard_lookup(ard); 
  entry = archive_entry_new(); 
  fd = open(name, O_RDONLY); 
  if (fd &lt; 0) 
     return; 
  archive_entry_copy_sourcepath(entry, name); 
  archive_read_disk_entry_from_file(ard, entry, fd, NULL); 
  archive_write_header(a, entry); 
  while ((bytes_read = read(fd, buff, sizeof(buff))) &gt; 0) 
    archive_write_data(a, buff, bytes_read); 
  archive_write_finish_entry(a); 
  archive_read_finish(ard); 
  archive_entry_free(entry); 
}</pre>
</div>
<div class="section">
<h1 id="x52455455524e2056414c554553">RETURN VALUES</h1> Most functions return <b class="flag">ARCHIVE_OK</b> (zero) on success, or one of several negative error codes for errors. Specific error codes include: <b class="flag">ARCHIVE_RETRY</b> for operations that might succeed if retried, <b class="flag">ARCHIVE_WARN</b> for unusual conditions that do not prevent further operations, and <b class="flag">ARCHIVE_FATAL</b> for serious errors that make remaining operations impossible. The <a class="link-man" href="../3/archive_errno">archive_errno(3)</a> and <a class="link-man" href="../3/archive_error_string">archive_error_string(3)</a> functions can be used to retrieve an appropriate error code and a textual error message. (See <a class="link-man" href="../3/archive_util">archive_util(3)</a> for details.)<p>
<b class="fname">archive_read_disk_new</b>() returns a pointer to a newly-allocated struct archive object or NULL if the allocation failed for any reason.<p>
<b class="fname">archive_read_disk_gname</b>() and <b class="fname">archive_read_disk_uname</b>() return const char * pointers to the textual name or NULL if the lookup failed for any reason. The returned pointer points to internal storage that may be reused on the next call to either of these functions; callers should copy the string if they need to continue accessing it.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../3/archive_read">archive_read(3)</a>, <a class="link-man" href="../3/archive_write">archive_write(3)</a>, <a class="link-man" href="../3/archive_write_disk">archive_write_disk(3)</a>, <a class="link-man" href="../1/tar">tar(1)</a>, <a class="link-man" href="../3/libarchive">libarchive(3)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The <b class="name">libarchive</b> library first appeared in <span class="unix">FreeBSD&#160;5.3</span>. The <b class="name">archive_read_disk</b> interface was added to <b class="name">libarchive 2.6</b> and first appeared in <span class="unix">FreeBSD&#160;8.0</span>.</div>
<div class="section">
<h1 id="x415554484f5253">AUTHORS</h1> <span class="author"></span>The <b class="name">libarchive</b> library was written by <span class="author">Tim Kientzle</span> &#60;<a class="link-mail" href="mailto:kientzle@freebsd.org">kientzle@freebsd.org</a>&#62;.</div>
<div class="section">
<h1 id="x42554753">BUGS</h1> The &#8220;standard&#8221; user name and group name lookup functions are not the defaults because <a class="link-man" href="../3/getgrid">getgrid(3)</a> and <a class="link-man" href="../3/getpwid">getpwid(3)</a> are sometimes too large for particular applications. The current design allows the application author to use a more compact implementation when appropriate.<p>
The full list of metadata read from disk by <b class="fname">archive_read_disk_entry_from_file</b>() is necessarily system-dependent.<p>
The <b class="fname">archive_read_disk_entry_from_file</b>() function reads as much information as it can from disk. Some method should be provided to limit this so that clients who do not need ACLs, for instance, can avoid the extra work needed to look up such information.<p>
This API should provide a set of methods for walking a directory tree. That would make it a direct parallel of the <a class="link-man" href="../3/archive_read">archive_read(3)</a> API. When such methods are implemented, the &#8220;hybrid&#8221; symbolic link mode will make sense.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
March 10, 2009</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

