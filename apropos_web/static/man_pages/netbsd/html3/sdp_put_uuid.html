<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
SDP_DATA(3)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
SDP_DATA(3)</td>
<td class="head-vol" align="center">
Library Functions Manual</td>
<td class="head-rtitle" align="right">
SDP_DATA(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">sdp_match_uuid16</b> <b class="name">sdp_get_data</b> <b class="name">sdp_get_attr</b> <b class="name">sdp_get_uuid</b> <b class="name">sdp_get_bool</b> <b class="name">sdp_get_seq</b> <b class="name">sdp_get_alt</b> <b class="name">sdp_get_uint</b> <b class="name">sdp_get_int</b> <b class="name">sdp_get_str</b> <b class="name">sdp_get_url</b> <b class="name">sdp_put_data</b> <b class="name">sdp_put_attr</b> <b class="name">sdp_put_uuid</b> <b class="name">sdp_put_uuid16</b> <b class="name">sdp_put_uuid32</b> <b class="name">sdp_put_uuid128</b> <b class="name">sdp_put_bool</b> <b class="name">sdp_put_uint</b> <b class="name">sdp_put_uint8</b> <b class="name">sdp_put_uint16</b> <b class="name">sdp_put_uint32</b> <b class="name">sdp_put_uint64</b> <b class="name">sdp_put_int</b> <b class="name">sdp_put_int8</b> <b class="name">sdp_put_int16</b> <b class="name">sdp_put_int32</b> <b class="name">sdp_put_int64</b> <b class="name">sdp_put_seq</b> <b class="name">sdp_put_alt</b> <b class="name">sdp_put_str</b> <b class="name">sdp_put_url</b> <b class="name">sdp_set_bool</b> <b class="name">sdp_set_uint</b> <b class="name">sdp_set_int</b> <b class="name">sdp_set_seq</b> <b class="name">sdp_set_alt</b> <b class="name">sdp_data_size</b> <b class="name">sdp_data_type</b> <b class="name">sdp_data_valid</b> <b class="name">sdp_data_print</b> &#8212; <span class="desc">Service Discovery Protocol data manipulation routines</span></div>
<div class="section">
<h1 id="x4c494252415259">LIBRARY</h1> <span class="lib">Bluetooth Library (libbluetooth, &#45;lbluetooth)</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sdp.h</a>&gt;</b><p>
<span class="type">extern const uuid_t BLUETOOTH_BASE_UUID</span>;<p>
<i class="ftype">bool</i><br>
<b class="fname">sdp_match_uuid16</b>(<i class="farg" style="white-space:nowrap;">sdp_data_t *data</i>, <i class="farg" style="white-space:nowrap;">uint16_t uuid</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">sdp_get_data</b>(<i class="farg" style="white-space:nowrap;">sdp_data_t *data</i>, <i class="farg" style="white-space:nowrap;">sdp_data_t *value</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">sdp_get_attr</b>(<i class="farg" style="white-space:nowrap;">sdp_data_t *data</i>, <i class="farg" style="white-space:nowrap;">uint16_t *attr</i>, <i class="farg" style="white-space:nowrap;">sdp_data_t *value</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">sdp_get_uuid</b>(<i class="farg" style="white-space:nowrap;">sdp_data_t *data</i>, <i class="farg" style="white-space:nowrap;">uuid_t *uuid</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">sdp_get_bool</b>(<i class="farg" style="white-space:nowrap;">sdp_data_t *data</i>, <i class="farg" style="white-space:nowrap;">bool *value</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">sdp_get_seq</b>(<i class="farg" style="white-space:nowrap;">sdp_data_t *data</i>, <i class="farg" style="white-space:nowrap;">sdp_data_t *seq</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">sdp_get_alt</b>(<i class="farg" style="white-space:nowrap;">sdp_data_t *data</i>, <i class="farg" style="white-space:nowrap;">sdp_data_t *alt</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">sdp_get_uint</b>(<i class="farg" style="white-space:nowrap;">sdp_data_t *data</i>, <i class="farg" style="white-space:nowrap;">uintmax_t *value</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">sdp_get_int</b>(<i class="farg" style="white-space:nowrap;">sdp_data_t *data</i>, <i class="farg" style="white-space:nowrap;">intmax_t *value</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">sdp_get_str</b>(<i class="farg" style="white-space:nowrap;">sdp_data_t *data</i>, <i class="farg" style="white-space:nowrap;">char **str</i>, <i class="farg" style="white-space:nowrap;">size_t *length</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">sdp_get_url</b>(<i class="farg" style="white-space:nowrap;">sdp_data_t *data</i>, <i class="farg" style="white-space:nowrap;">char **url</i>, <i class="farg" style="white-space:nowrap;">size_t *length</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">sdp_put_data</b>(<i class="farg" style="white-space:nowrap;">sdp_data_t *data</i>, <i class="farg" style="white-space:nowrap;">sdp_data_t *value</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">sdp_put_attr</b>(<i class="farg" style="white-space:nowrap;">sdp_data_t *data</i>, <i class="farg" style="white-space:nowrap;">uint16_t attr</i>, <i class="farg" style="white-space:nowrap;">sdp_data_t *value</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">sdp_put_uuid</b>(<i class="farg" style="white-space:nowrap;">sdp_data_t *data</i>, <i class="farg" style="white-space:nowrap;">const uuid_t *value</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">sdp_put_uuid16</b>(<i class="farg" style="white-space:nowrap;">sdp_data_t *data</i>, <i class="farg" style="white-space:nowrap;">uint16_t value</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">sdp_put_uuid32</b>(<i class="farg" style="white-space:nowrap;">sdp_data_t *data</i>, <i class="farg" style="white-space:nowrap;">uint32_t value</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">sdp_put_uuid128</b>(<i class="farg" style="white-space:nowrap;">sdp_data_t *data</i>, <i class="farg" style="white-space:nowrap;">const uuid_t *value</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">sdp_put_bool</b>(<i class="farg" style="white-space:nowrap;">sdp_data_t *data</i>, <i class="farg" style="white-space:nowrap;">bool value</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">sdp_put_uint</b>(<i class="farg" style="white-space:nowrap;">sdp_data_t *data</i>, <i class="farg" style="white-space:nowrap;">uintmax_t value</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">sdp_put_uint8</b>(<i class="farg" style="white-space:nowrap;">sdp_data_t *data</i>, <i class="farg" style="white-space:nowrap;">uint8_t value</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">sdp_put_uint16</b>(<i class="farg" style="white-space:nowrap;">sdp_data_t *data</i>, <i class="farg" style="white-space:nowrap;">uint16_t value</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">sdp_put_uint32</b>(<i class="farg" style="white-space:nowrap;">sdp_data_t *data</i>, <i class="farg" style="white-space:nowrap;">uint32_t value</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">sdp_put_uint64</b>(<i class="farg" style="white-space:nowrap;">sdp_data_t *data</i>, <i class="farg" style="white-space:nowrap;">uint64_t value</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">sdp_put_int</b>(<i class="farg" style="white-space:nowrap;">sdp_data_t *data</i>, <i class="farg" style="white-space:nowrap;">intmax_t value</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">sdp_put_int8</b>(<i class="farg" style="white-space:nowrap;">sdp_data_t *data</i>, <i class="farg" style="white-space:nowrap;">int8_t value</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">sdp_put_int16</b>(<i class="farg" style="white-space:nowrap;">sdp_data_t *data</i>, <i class="farg" style="white-space:nowrap;">int16_t value</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">sdp_put_int32</b>(<i class="farg" style="white-space:nowrap;">sdp_data_t *data</i>, <i class="farg" style="white-space:nowrap;">int32_t value</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">sdp_put_int64</b>(<i class="farg" style="white-space:nowrap;">sdp_data_t *data</i>, <i class="farg" style="white-space:nowrap;">int64_t value</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">sdp_put_seq</b>(<i class="farg" style="white-space:nowrap;">sdp_data_t *data</i>, <i class="farg" style="white-space:nowrap;">ssize_t length</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">sdp_put_alt</b>(<i class="farg" style="white-space:nowrap;">sdp_data_t *data</i>, <i class="farg" style="white-space:nowrap;">ssize_t length</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">sdp_put_str</b>(<i class="farg" style="white-space:nowrap;">sdp_data_t *data</i>, <i class="farg" style="white-space:nowrap;">const char *str</i>, <i class="farg" style="white-space:nowrap;">ssize_t length</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">sdp_put_url</b>(<i class="farg" style="white-space:nowrap;">sdp_data_t *data</i>, <i class="farg" style="white-space:nowrap;">const char *url</i>, <i class="farg" style="white-space:nowrap;">ssize_t length</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">sdp_set_bool</b>(<i class="farg" style="white-space:nowrap;">const sdp_data_t *data</i>, <i class="farg" style="white-space:nowrap;">bool value</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">sdp_set_uint</b>(<i class="farg" style="white-space:nowrap;">const sdp_data_t *data</i>, <i class="farg" style="white-space:nowrap;">uintmax_t value</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">sdp_set_int</b>(<i class="farg" style="white-space:nowrap;">const sdp_data_t *data</i>, <i class="farg" style="white-space:nowrap;">intmax_t value</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">sdp_set_seq</b>(<i class="farg" style="white-space:nowrap;">const sdp_data_t *data</i>, <i class="farg" style="white-space:nowrap;">ssize_t length</i>);<p>
<i class="ftype">ssize_t</i><br>
<b class="fname">sdp_data_size</b>(<i class="farg" style="white-space:nowrap;">const sdp_data_t *data</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">sdp_data_type</b>(<i class="farg" style="white-space:nowrap;">const sdp_data_t *data</i>);<p>
<i class="ftype">bool</i><br>
<b class="fname">sdp_data_valid</b>(<i class="farg" style="white-space:nowrap;">const sdp_data_t *data</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">sdp_data_print</b>(<i class="farg" style="white-space:nowrap;">const sdp_data_t *data</i>, <i class="farg" style="white-space:nowrap;">int indent</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> These routines provide for the manipulation of Service Discovery Protocol data buffers. An SDP data buffer type is defined as:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
typedef struct { 
	uint8_t *next; 
	uint8_t *end; 
} sdp_data_t;</pre>
<p>
Where <i class="farg">next</i> points to the next available byte, and <i class="farg">end</i> points to the first address past end of the data area, such that &#8220;end = next + length&#8221;.<p>
The SDP data consists of byte streams describing data elements, where a data element is a typed data representation consisting of a header field and a data field. The header field consists of type and size descriptors, and the data field is a sequence of bytes whose length is specified in the size descriptor and whose content is specified by the type descriptor. For instance, the byte sequence &#8220;0x09, 0x01, 0x00&#8221; describes an 16-bit unsigned integer element (type 0x09) with value of 0x0100.<p>
Data element types including signed and unsigned integers, boolean, string, sequence and alternative lists are defined in the <b class="includes">&lt;<a class="link-includes">sdp.h</a>&gt;</b> include file. See the &#8220;Service Discovery Protocol&#8221; chapters of the &#8220;Bluetooth Core Specifications&#8221; for more information.<p>
To reduce the burden of storing and transferring 128-bit UUID values, a range of UUID values has been pre-allocated for assignment to often-used, registered purposes. The first UUID in this pre-allocated range is known as the &#8220;Bluetooth Base UUID&#8221;, defined in the &#8220;Bluetooth Assigned Numbers&#8221; document and declared in <b class="includes">&lt;<a class="link-includes">sdp.h</a>&gt;</b> as <span class="type">const uuid_t BLUETOOTH_BASE_UUID</span>;<p>
The data manipulation routines are arranged into major groups by function:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-hang">
<dt class="list-hang" style="margin-top: 1.00em;">
The <b class="fname">sdp_match_uuid16</b>()</dt>
<dd class="list-hang">
routine examines the next data element in the data buffer for an element of type UUID that matches the Bluetooth short alias UUID with 16-bit value given. If the UUID matches, the function will return <span class="define">true</span> and the <i class="farg">next</i> field of the SDP data buffer will be advanced to the next element. Otherwise <span class="define">false</span> will be returned.</dd>
<dt class="list-hang" style="margin-top: 1.00em;">
The <b class="fname">sdp_get_xxxx</b>()</dt>
<dd class="list-hang">
routines examine the next data element in the data buffer for an element of the given type. If the type matches, the function will extract the typed value to the address given and advance the <i class="farg">next</i> field of the SDP data buffer to the next element then return <span class="define">true</span>. Otherwise <span class="define">false</span> will be returned. Note, these functions will not modify the <i class="farg">data</i> argument unless the correct type was found, and will update the <i class="farg">data</i> argument first to allow discarding in the case where a <span class="define">sdp_data_t</span> was being returned.</dd>
<dt class="list-hang" style="margin-top: 1.00em;">
The <b class="fname">sdp_put_xxxx</b>()</dt>
<dd class="list-hang">
routines will attempt to write a data element of the given type and value to the data buffer. If the data buffer is too small to contain the encoded data element, the function will return <span class="define">false</span>, otherwise <span class="define">true</span> will be returned and the <i class="farg">next</i> field of the SDP data pointer will be advanced. In the case of <b class="fname">sdp_put_seq</b>() and <b class="fname">sdp_put_alt</b>(), the <i class="farg">length</i> argument may be -1, in which case the generated sequence header will describe all the remaining buffer space. For <b class="fname">sdp_put_str</b>() and <b class="fname">sdp_put_url</b>() the <i class="farg">length</i> argument may be -1 in which case the string pointer is treated as nul terminated.</dd>
<dt class="list-hang" style="margin-top: 1.00em;">
The <b class="fname">sdp_set_xxxx</b>()</dt>
<dd class="list-hang">
routines examine the SDP data buffer for a data element of the given type, and replace the content with the passed value. If the next data element in the buffer is not of the appropriate type, the function will return <span class="define">false</span>, otherwise <span class="define">true</span> will be returned and the value updated. In the case of <b class="fname">sdp_set_seq</b>() and <b class="fname">sdp_set_alt</b>(), the <i class="farg">length</i> argument may be -1, in which case the sequence header will be adjusted to describe the entire data space where possible.</dd>
<dt class="list-hang" style="margin-top: 1.00em;">
The <b class="fname">sdp_data_xxxx</b>()</dt>
<dd class="list-hang">
routines include various functions to provide information about the data stream such as <b class="fname">sdp_data_size</b>() to return the size of the next data element, and <b class="fname">sdp_data_type</b>() to return the type of the next data element. <b class="fname">sdp_data_valid</b>() can be used to ensure that the entire data buffer contains valid SDP data elements and that all of the elements are contained exactly within the data buffer. Finally, <b class="fname">sdp_data_print</b>() will print the data buffer in human readable format.</dd>
</dl>
</div>
<div class="section">
<h1 id="x4558414d504c4553">EXAMPLES</h1> To parse a ServiceAttribute response obtained from a remote server using <a class="link-man" href="../html3/sdp_service_attribute.html">sdp_service_attribute(3)</a>, examining various attribute values:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
	sdp_data_t rsp, val; 
	uint16_t attr; 
	uintmax_t handle; 
 
	/* rsp contains remote response */ 
 
	while (sdp_get_attr(&amp;rsp, &amp;attr, &amp;val)) { 
		switch(attr) { 
		case SDP_ATTR_SERVICE_RECORD_HANDLE: 
			sdp_get_uint(&amp;val, &amp;handle); 
			printf("ServiceRecordHandle: 0x%08x\n", handle); 
			break; 
 
		case SDP_ATTR_PROFILE_DESCRIPTOR_LIST: 
			printf("ProfileDescriptorList:\n"); 
			sdp_data_print(&amp;val, 0); 
			break; 
 
		default: 
			printf("uninteresting attribute 0x%04x\n", attr); 
			break; 
		} 
	}</pre>
<p>
The following code creates a ProtocolDataList attribute value for a service using the L2CAP and RFCOMM protocols and illustrates how to construct sequences of known and unknown length.<p>
<pre style="margin-left: 0.00ex;" class="lit display">
	uint8_t buf[SIZE]; 
	sdp_data_t seq; 
	uint16_t psm; 
	uint8_t channel; 
 
	seq.next = buf; 
	seq.end = buf + sizeof(buf); 
	sdp_put_seq(&amp;seq, -1); 
 
	sdp_put_seq(&amp;seq, 6); 
	sdp_put_uuid16(&amp;seq, SDP_UUID_PROTOCOL_L2CAP); 
	sdp_put_uint16(&amp;seq, psm); 
 
	sdp_put_seq(&amp;seq, 5); 
	sdp_put_uuid16(&amp;seq, SDP_UUID_PROTOCOL_RFCOMM); 
	sdp_put_uint8(&amp;seq, channel); 
 
	seq.end = seq.next; 
	seq.next = buf; 
	sdp_set_seq(&amp;seq, -1);</pre>
<p>
Note that although <span class="define">SIZE</span> is assumed to be large enough to contain the entire sequence in this case, the <b class="fname">sdp_put_xxxx</b>() routines will not overflow the buffer area or write partial data.<p>
The encoded data stream will be stored in a space efficient manner where possible. In the above example, it is known that the data element sequence containing the L2CAP UUID will be 8 bytes long overall since the container length of 6 can be stored in a single byte. But, because the value of <span class="define">SIZE</span> is unknown, the overall length of the ProtocolDataList may vary depending if 8, 16 or 32 bits were needed to represent the original buffer size. <b class="fname">sdp_set_seq</b>() will only modify the content, not the size of the header.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html1/sdpquery.html">sdpquery(1)</a>, <a class="link-man" href="../html3/bluetooth.html">bluetooth(3)</a>, <a class="link-man" href="../html3/sdp.html">sdp(3)</a>, <a class="link-man" href="../html3/uuid.html">uuid(3)</a>, <a class="link-man" href="../html8/sdpd.html">sdpd(8)</a><p>
The &#8220;Service Discovery Protocol&#8221; section of the Bluetooth Core specifications, available at <a class="link-ext" href="http://www.bluetooth.com/">http://www.bluetooth.com/</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> These SDP data parsing and manipulation functions first appeared in <span class="unix">NetBSD&#160;6.0</span>.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
January 15, 2011</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

