<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
XDR(3)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
XDR(3)</td>
<td class="head-vol" align="center">
Library Functions Manual</td>
<td class="head-rtitle" align="right">
XDR(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">xdr</b>, <b class="name">xdr_array</b>, <b class="name">xdr_bool</b>, <b class="name">xdr_bytes</b>, <b class="name">xdr_char</b>, <b class="name">xdr_destroy</b>, <b class="name">xdr_double</b>, <b class="name">xdr_enum</b>, <b class="name">xdr_float</b>, <b class="name">xdr_free</b>, <b class="name">xdr_getpos</b>, <b class="name">xdr_hyper</b>, <b class="name">xdr_inline</b>, <b class="name">xdr_int</b>, <b class="name">xdr_long</b>, <b class="name">xdr_longlong_t</b>, <b class="name">xdrmem_create</b>, <b class="name">xdr_opaque</b>, <b class="name">xdr_pointer</b>, <b class="name">xdrrec_create</b>, <b class="name">xdrrec_endofrecord</b>, <b class="name">xdrrec_eof</b>, <b class="name">xdrrec_skiprecord</b>, <b class="name">xdr_reference</b>, <b class="name">xdr_setpos</b>, <b class="name">xdr_short</b>, <b class="name">xdr_sizeof</b>, <b class="name">xdrstdio_create</b>, <b class="name">xdr_string</b>, <b class="name">xdr_u_char</b>, <b class="name">xdr_u_hyper</b>, <b class="name">xdr_u_long</b>, <b class="name">xdr_u_longlong_t</b>, <b class="name">xdr_u_short</b>, <b class="name">xdr_union</b>, <b class="name">xdr_vector</b>, <b class="name">xdr_void</b>, <b class="name">xdr_wrapstring</b> &#8212; <span class="desc">library routines for external data representation</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <i class="ftype">int</i><br>
<b class="fname">xdr_array</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">char **arrp</i>, <i class="farg" style="white-space:nowrap;">u_int *sizep</i>, <i class="farg" style="white-space:nowrap;">u_int maxsize</i>, <i class="farg" style="white-space:nowrap;">u_int elsize</i>, <i class="farg" style="white-space:nowrap;">xdrproc_t elproc</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">xdr_bool</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">bool_t *bp</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">xdr_bytes</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">char **sp</i>, <i class="farg" style="white-space:nowrap;">u_int *sizep</i>, <i class="farg" style="white-space:nowrap;">u_int maxsize</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">xdr_char</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">char *cp</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">xdr_destroy</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">xdr_double</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">double *dp</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">xdr_enum</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">enum_t *ep</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">xdr_float</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">float *fp</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">xdr_free</b>(<i class="farg" style="white-space:nowrap;">xdrproc_t proc</i>, <i class="farg" style="white-space:nowrap;">char *objp</i>);<p>
<i class="ftype">u_int</i><br>
<b class="fname">xdr_getpos</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">xdr_hyper</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">longlong_t *llp</i>);<p>
<i class="ftype">long *</i><br>
<b class="fname">xdr_inline</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">int len</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">xdr_int</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">int *ip</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">xdr_long</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">long *lp</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">xdr_longlong_t</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">longlong_t *llp</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">xdrmem_create</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">char *addr</i>, <i class="farg" style="white-space:nowrap;">u_int size</i>, <i class="farg" style="white-space:nowrap;">enum xdr_op op</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">xdr_opaque</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">char *cp</i>, <i class="farg" style="white-space:nowrap;">u_int cnt</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">xdr_pointer</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">char **objpp</i>, <i class="farg" style="white-space:nowrap;">u_int objsize</i>, <i class="farg" style="white-space:nowrap;">xdrproc_t xdrobj</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">xdrrec_create</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">u_int sendsize</i>, <i class="farg" style="white-space:nowrap;">u_int recvsize</i>, <i class="farg" style="white-space:nowrap;">char *handle</i>, <i class="farg" style="white-space:nowrap;">int (*readit)()</i>, <i class="farg" style="white-space:nowrap;">int (*writeit)()</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">xdrrec_endofrecord</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">int sendnow</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">xdrrec_eof</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">xdrrec_skiprecord</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">xdr_reference</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">char **pp</i>, <i class="farg" style="white-space:nowrap;">u_int size</i>, <i class="farg" style="white-space:nowrap;">xdrproc_t proc</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">xdr_setpos</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">u_int pos</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">xdr_short</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">short *sp</i>);<p>
<i class="ftype">nsigned long</i><br>
<b class="fname">xdr_sizeof</b>(<i class="farg" style="white-space:nowrap;">xdrproc_t func</i>, <i class="farg" style="white-space:nowrap;">void *data</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">xdrstdio_create</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">FILE *file</i>, <i class="farg" style="white-space:nowrap;">enum xdr_op op</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">xdr_string</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">char **sp</i>, <i class="farg" style="white-space:nowrap;">u_int maxsize</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">xdr_u_char</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">unsigned char *ucp</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">xdr_u_hyper</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">u_longlong_t *ullp</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">xdr_u_int</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">unsigned *up</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">xdr_u_long</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">unsigned long *ulp</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">xdr_u_longlong_t</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">u_longlong_t *ullp</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">xdr_u_short</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">unsigned short *usp</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">xdr_union</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">int *dscmp</i>, <i class="farg" style="white-space:nowrap;">char *unp</i>, <i class="farg" style="white-space:nowrap;">struct xdr_discrim *choices</i>, <i class="farg" style="white-space:nowrap;">bool_t (*defaultarm)()</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">xdr_vector</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">char *arrp</i>, <i class="farg" style="white-space:nowrap;">u_int size</i>, <i class="farg" style="white-space:nowrap;">u_int elsize</i>, <i class="farg" style="white-space:nowrap;">xdrproc_t elproc</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">xdr_void</b>(<i class="farg" style="white-space:nowrap;">void</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">xdr_wrapstring</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">char **sp</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> These routines allow C programmers to describe arbitrary data structures in a machine-independent fashion. Data for remote procedure calls are transmitted using these routines.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdr_array</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A filter primitive that translates between variable-length arrays and their corresponding external representations. The parameter <i class="farg">arrp</i> is the address of the pointer to the array, while <i class="farg">sizep</i> is the address of the element count of the array; this element count cannot exceed <i class="farg">maxsize</i>. The parameter <i class="farg">elsize</i> is the <span class="emph">sizeof</span> each of the array's elements, and <i class="farg">elproc</i> is an XDR filter that translates between the array elements' C form, and their external representation. This routine returns one if it succeeds, zero otherwise.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdr_bool</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A filter primitive that translates between booleans (C integers) and their external representations. When encoding data, this filter produces values of either one or zero. This routine returns one if it succeeds, zero otherwise.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdr_bytes</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A filter primitive that translates between counted byte strings and their external representations. The parameter <i class="farg">sp</i> is the address of the string pointer. The length of the string is located at address <i class="farg">sizep</i>; strings cannot be longer than <i class="farg">maxsize</i>. This routine returns one if it succeeds, zero otherwise.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdr_char</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A filter primitive that translates between C characters and their external representations. This routine returns one if it succeeds, zero otherwise. Note: encoded characters are not packed, and occupy 4 bytes each. For arrays of characters, it is worthwhile to consider <b class="fname">xdr_bytes</b>(), <b class="fname">xdr_opaque</b>() or <b class="fname">xdr_string</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdr_destroy</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A macro that invokes the destroy routine associated with the XDR stream, <i class="farg">xdrs</i>. Destruction usually involves freeing private data structures associated with the stream. Using <i class="farg">xdrs</i> after invoking <b class="fname">xdr_destroy</b>() is undefined.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdr_double</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A filter primitive that translates between C double precision numbers and their external representations. This routine returns one if it succeeds, zero otherwise.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdr_enum</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A filter primitive that translates between C enums (actually integers) and their external representations. This routine returns one if it succeeds, zero otherwise.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdr_float</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A filter primitive that translates between C floats and their external representations. This routine returns one if it succeeds, zero otherwise.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdr_free</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Generic freeing routine. The first argument is the XDR routine for the object being freed. The second argument is a pointer to the object itself. Note: the pointer passed to this routine is <span class="emph">not</span> freed, but what it points to <span class="emph">is</span> freed (recursively).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdr_getpos</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A macro that invokes the get-position routine associated with the XDR stream, <i class="farg">xdrs</i>. The routine returns an unsigned integer, which indicates the position of the XDR byte stream. A desirable feature of XDR streams is that simple arithmetic works with this number, although the XDR stream instances need not guarantee this.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdr_hyper</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A filter primitive that translates between ANSI C long long integers and their external representations. This routine returns one if it succeeds, zero otherwise.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdr_inline</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A macro that invokes the in-line routine associated with the XDR stream, <i class="farg">xdrs</i>. The routine returns a pointer to a contiguous piece of the stream's buffer; <i class="farg">len</i> is the byte length of the desired buffer. Note: pointer is cast to <span class="type">long *</span>.<p>
Warning: <b class="fname">xdr_inline</b>() may return <span class="define">NULL</span> if it cannot allocate a contiguous piece of a buffer. Therefore the behavior may vary among stream instances; it exists for the sake of efficiency.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdr_int</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A filter primitive that translates between C integers and their external representations. This routine returns one if it succeeds, zero otherwise.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdr_long</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A filter primitive that translates between C long integers and their external representations. This routine returns one if it succeeds, zero otherwise.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdr_longlong_t</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A filter primitive that translates between ANSI C long long integers and their external representations. This routine returns one if it succeeds, zero otherwise.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdrmem_create</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
This routine initializes the XDR stream object pointed to by <i class="farg">xdrs</i>. The stream's data is written to, or read from, a chunk of memory at location <i class="farg">addr</i> whose length is no more than <i class="farg">size</i> bytes long. The <i class="farg">op</i> determines the direction of the XDR stream (either <span class="define">XDR_ENCODE</span>, <span class="define">XDR_DECODE</span>, or <span class="define">XDR_FREE</span>).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdr_opaque</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A filter primitive that translates between fixed size opaque data and its external representation. The parameter <i class="farg">cp</i> is the address of the opaque object, and <i class="farg">cnt</i> is its size in bytes. This routine returns one if it succeeds, zero otherwise.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdr_pointer</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Like <b class="fname">xdr_reference</b>() except that it serializes <span class="define">NULL</span> pointers, whereas <b class="fname">xdr_reference</b>() does not. Thus, <b class="fname">xdr_pointer</b>() can represent recursive data structures, such as binary trees or linked lists.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdrrec_create</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
This routine initializes the XDR stream object pointed to by <i class="farg">xdrs</i>. The stream's data is written to a buffer of size <i class="farg">sendsize</i>; a value of zero indicates the system should use a suitable default. The stream's data is read from a buffer of size <i class="farg">recvsize</i>; it too can be set to a suitable default by passing a zero value. When a stream's output buffer is full, <i class="farg">writeit</i> is called. Similarly, when a stream's input buffer is empty, <i class="farg">readit</i> is called. The behavior of these two routines is similar to the system calls <a class="link-man" href="../2/read">read(2)</a> and <a class="link-man" href="../2/write">write(2)</a>, except that <i class="farg">handle</i> is passed to the former routines as the first parameter. Note: the XDR stream's <i class="farg">op</i> field must be set by the caller.<p>
Warning: this XDR stream implements an intermediate record stream. Therefore there are additional bytes in the stream to provide record boundary information.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdrrec_endofrecord</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
This routine can be invoked only on streams created by <b class="fname">xdrrec_create</b>(). The data in the output buffer is marked as a completed record, and the output buffer is optionally written out if <i class="farg">sendnow</i> is non-zero. This routine returns one if it succeeds, zero otherwise.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdrrec_eof</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
This routine can be invoked only on streams created by <b class="fname">xdrrec_create</b>(). After consuming the rest of the current record in the stream, this routine returns one if the stream has no more input, zero otherwise.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdrrec_skiprecord</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
This routine can be invoked only on streams created by <b class="fname">xdrrec_create</b>(). It tells the XDR implementation that the rest of the current record in the stream's input buffer should be discarded. This routine returns one if it succeeds, zero otherwise.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdr_reference</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A primitive that provides pointer chasing within structures. The parameter <i class="farg">pp</i> is the address of the pointer; <i class="farg">size</i> is the <span class="emph">sizeof</span> the structure that <i class="farg">*pp</i> points to; and <i class="farg">proc</i> is an XDR procedure that filters the structure between its C form and its external representation. This routine returns one if it succeeds, zero otherwise.<p>
Warning: this routine does not understand <span class="define">NULL</span> pointers. Use <b class="fname">xdr_pointer</b>() instead.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdr_setpos</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A macro that invokes the set position routine associated with the XDR stream <i class="farg">xdrs</i>. The parameter <i class="farg">pos</i> is a position value obtained from <b class="fname">xdr_getpos</b>(). This routine returns one if the XDR stream could be repositioned, and zero otherwise.<p>
Warning: it is difficult to reposition some types of XDR streams, so this routine may fail with one type of stream and succeed with another.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdr_short</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A filter primitive that translates between C short integers and their external representations. This routine returns one if it succeeds, zero otherwise.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdr_sizeof</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
This routine returns the amount of memory required to encode <i class="farg">data</i> using filter <i class="farg">func</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdrstdio_create</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
This routine initializes the XDR stream object pointed to by <i class="farg">xdrs</i>. The XDR stream data is written to, or read from, the Standard I/O stream <i class="farg">file</i>. The parameter <i class="farg">op</i> determines the direction of the XDR stream (either <span class="define">XDR_ENCODE</span>, <span class="define">XDR_DECODE</span>, or <span class="define">XDR_FREE</span>).<p>
Warning: the destroy routine associated with such XDR streams calls <a class="link-man" href="../3/fflush">fflush(3)</a> on the file stream, but never <a class="link-man" href="../3/fclose">fclose(3)</a>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdr_string</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A filter primitive that translates between C strings and their corresponding external representations. Strings cannot be longer than <i class="farg">maxsize</i>. Note: <i class="farg">sp</i> is the address of the string's pointer. This routine returns one if it succeeds, zero otherwise.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdr_u_char</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A filter primitive that translates between unsigned C characters and their external representations. This routine returns one if it succeeds, zero otherwise.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdr_u_hyper</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A filter primitive that translates between unsigned ANSI C long long integers and their external representations. This routine returns one if it succeeds, zero otherwise.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdr_u_int</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A filter primitive that translates between C unsigned integers<br>
 and their external representations. This routine returns one if it succeeds, zero otherwise.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdr_u_long</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A filter primitive that translates between C unsigned long integers and their external representations. This routine returns one if it succeeds, zero otherwise.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdr_u_longlong_t</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A filter primitive that translates between unsigned ANSI C long long integers and their external representations. This routine returns one if it succeeds, zero otherwise.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdr_u_short</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A filter primitive that translates between C unsigned short integers and their external representations. This routine returns one if it succeeds, zero otherwise.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdr_union</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A filter primitive that translates between a discriminated C union and its corresponding external representation. It first translates the discriminant of the union located at <i class="farg">dscmp</i>. This discriminant is always an enum_t. Next the union located at <i class="farg">unp</i> is translated. The parameter <i class="farg">choices</i> is a pointer to an array of <b class="fname">xdr_discrim</b>() structures. Each structure contains an ordered pair of [<i class="farg">value</i>, <i class="farg">proc</i>]. If the union's discriminant is equal to the associated <i class="farg">value</i>, then the <i class="farg">proc</i> is called to translate the union. The end of the <b class="fname">xdr_discrim</b>() structure array is denoted by a routine of value <span class="define">NULL</span>. If the discriminant is not found in the <i class="farg">choices</i> array, then the <i class="farg">defaultarm</i> procedure is called (if it is not <span class="define">NULL</span>). Returns one if it succeeds, zero otherwise.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdr_vector</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A filter primitive that translates between fixed-length arrays and their corresponding external representations. The parameter <i class="farg">arrp</i> is the address of the pointer to the array, while <i class="farg">size</i> is the element count of the array. The parameter <i class="farg">elsize</i> is the <span class="emph">sizeof</span> each of the array's elements, and <i class="farg">elproc</i> is an XDR filter that translates between the array elements' C form, and their external representation. This routine returns one if it succeeds, zero otherwise.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdr_void</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
This routine always returns one. It may be passed to RPC routines that require a function parameter, where nothing is to be done.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdr_wrapstring</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A primitive that calls <b class="fname">xdr_string</b>(<i class="farg">xdrs</i>, <i class="farg">sp</i>, <i class="farg">MAXUN.UNSIGNED</i>); where <span class="define">MAXUN.UNSIGNED</span> is the maximum value of an unsigned integer. <b class="fname">xdr_wrapstring</b>() is handy because the RPC package passes a maximum of two XDR routines as parameters, and <b class="fname">xdr_string</b>(), one of the most frequently used primitives, requires three. Returns one if it succeeds, zero otherwise.</dd>
</dl>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../3/rpc">rpc(3)</a><p>
The following manuals:<p>
<span class="ref"><i class="ref-book">eXternal Data Representation Standard: Protocol Specification</i>.</span><p>
<span class="ref"><i class="ref-book">eXternal Data Representation: Sun Technical Notes</i>.</span><p>
<span class="ref"><span class="ref-auth">Sun Microsystems, Inc., USC-ISI</span>, <span class="ref-title">XDR: External Data Representation Standard</span>, <span class="ref-rep">RFC 1014, USC-ISI</span>, <span class="ref-vol">1014</span>.</span></div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
July 4, 2011</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

