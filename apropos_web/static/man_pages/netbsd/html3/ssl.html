<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
ssl(3)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
ssl(3)</td>
<td class="head-vol" align="center">
OpenSSL</td>
<td class="head-rtitle" align="right">
ssl(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> SSL &#45; OpenSSL SSL/TLS library</div>
<div class="section">
<h1>LIBRARY</h1> libcrypto, -lcrypto</div>
<div class="section">
<h1>SYNOPSIS</h1></div>
<div class="section">
<h1>DESCRIPTION</h1> The OpenSSL  <b>ssl</b> library implements the Secure Sockets Layer (SSL v2/v3) and Transport Layer Security (TLS v1) protocols. It provides a rich API which is documented here.<p>
At first the library must be initialized; see  <i>SSL_library_init</i>(3).<p>
Then an <b>SSL_CTX</b> object is created as a framework to establish TLS/SSL enabled connections (see  <i>SSL_CTX_new</i>(3)). Various options regarding certificates, algorithms etc. can be set in this object.<p>
When a network connection has been created, it can be assigned to an  <b>SSL</b> object. After the <b>SSL</b> object has been created using  <i>SSL_new</i>(3), <i>SSL_set_fd</i>(3) or  <i>SSL_set_bio</i>(3) can be used to associate the network connection with the object.<p>
Then the TLS/SSL handshake is performed using  <i>SSL_accept</i>(3) or <i>SSL_connect</i>(3) respectively.  <i>SSL_read</i>(3) and <i>SSL_write</i>(3) are used to read and write data on the TLS/SSL connection.  <i>SSL_shutdown</i>(3) can be used to shut down the TLS/SSL connection.</div>
<div class="section">
<h1>DATA STRUCTURES</h1> Currently the OpenSSL  <b>ssl</b> library functions deals with the following data structures:<dl>
<dt>
<b>SSL_METHOD</b> (SSL Method)</dt>
<dd>
That's a dispatch structure describing the internal <b>ssl</b> library methods/functions which implement the various protocol versions (SSLv1, SSLv2 and TLSv1). It's needed to create an  <b>SSL_CTX</b>.</dd>
</dl>
<dl>
<dt>
<b>SSL_CIPHER</b> (SSL Cipher)</dt>
<dd>
This structure holds the algorithm information for a particular cipher which are a core part of the SSL/TLS protocol. The available ciphers are configured on a  <b>SSL_CTX</b> basis and the actually used ones are then part of the  <b>SSL_SESSION</b>.</dd>
</dl>
<dl>
<dt>
<b>SSL_CTX</b> (SSL Context)</dt>
<dd>
That's the global context structure which is created by a server or client once per program life-time and which holds mainly default values for the  <b>SSL</b> structures which are later created for the connections.</dd>
</dl>
<dl>
<dt>
<b>SSL_SESSION</b> (SSL Session)</dt>
<dd>
This is a structure containing the current TLS/SSL session details for a connection:  <b>SSL_CIPHER</b>s, client and server certificates, keys, etc.</dd>
</dl>
<dl>
<dt>
<b>SSL</b> (SSL Connection)</dt>
<dd>
That's the main SSL/TLS structure which is created by a server or client per established connection. This actually is the core structure in the SSL API. Under run-time the application usually deals with this structure which has links to mostly all other structures.</dd>
</dl>
</div>
<div class="section">
<h1>HEADER FILES</h1> Currently the OpenSSL  <b>ssl</b> library provides the following C header files containing the prototypes for the data structures and and functions:<dl>
<dt>
<b>ssl.h</b></dt>
<dd>
That's the common header file for the SSL/TLS API.  Include it into your program to make the API of the  <b>ssl</b> library available. It internally includes both more private SSL headers and headers from the  <b>crypto</b> library. Whenever you need hard-core details on the internals of the SSL API, look inside this header file.</dd>
</dl>
<dl>
<dt>
<b>ssl2.h</b></dt>
<dd>
That's the sub header file dealing with the SSLv2 protocol only.  <i>Usually you don't have to include it explicitly because</i>  <i>it's already included by ssl.h</i>.</dd>
</dl>
<dl>
<dt>
<b>ssl3.h</b></dt>
<dd>
That's the sub header file dealing with the SSLv3 protocol only.  <i>Usually you don't have to include it explicitly because</i>  <i>it's already included by ssl.h</i>.</dd>
</dl>
<dl>
<dt>
<b>ssl23.h</b></dt>
<dd>
That's the sub header file dealing with the combined use of the SSLv2 and SSLv3 protocols.  <i>Usually you don't have to include it explicitly because</i>  <i>it's already included by ssl.h</i>.</dd>
</dl>
<dl>
<dt>
<b>tls1.h</b></dt>
<dd>
That's the sub header file dealing with the TLSv1 protocol only.  <i>Usually you don't have to include it explicitly because</i>  <i>it's already included by ssl.h</i>.</dd>
</dl>
</div>
<div class="section">
<h1>API FUNCTIONS</h1> Currently the OpenSSL  <b>ssl</b> library exports 214 API functions. They are documented in the following:<div class="subsection">
<h2>DEALING WITH PROTOCOL METHODS</h2> Here we document the various API functions which deal with the SSL/TLS protocol methods defined in  <b>SSL_METHOD</b> structures.<dl>
<dt>
const SSL_METHOD *<b>SSLv2_client_method</b>(void);</dt>
<dd>
Constructor for the SSLv2 SSL_METHOD structure for a dedicated client.</dd>
</dl>
<dl>
<dt>
const SSL_METHOD *<b>SSLv2_server_method</b>(void);</dt>
<dd>
Constructor for the SSLv2 SSL_METHOD structure for a dedicated server.</dd>
</dl>
<dl>
<dt>
const SSL_METHOD *<b>SSLv2_method</b>(void);</dt>
<dd>
Constructor for the SSLv2 SSL_METHOD structure for combined client and server.</dd>
</dl>
<dl>
<dt>
const SSL_METHOD *<b>SSLv3_client_method</b>(void);</dt>
<dd>
Constructor for the SSLv3 SSL_METHOD structure for a dedicated client.</dd>
</dl>
<dl>
<dt>
const SSL_METHOD *<b>SSLv3_server_method</b>(void);</dt>
<dd>
Constructor for the SSLv3 SSL_METHOD structure for a dedicated server.</dd>
</dl>
<dl>
<dt>
const SSL_METHOD *<b>SSLv3_method</b>(void);</dt>
<dd>
Constructor for the SSLv3 SSL_METHOD structure for combined client and server.</dd>
</dl>
<dl>
<dt>
const SSL_METHOD *<b>TLSv1_client_method</b>(void);</dt>
<dd>
Constructor for the TLSv1 SSL_METHOD structure for a dedicated client.</dd>
</dl>
<dl>
<dt>
const SSL_METHOD *<b>TLSv1_server_method</b>(void);</dt>
<dd>
Constructor for the TLSv1 SSL_METHOD structure for a dedicated server.</dd>
</dl>
<dl>
<dt>
const SSL_METHOD *<b>TLSv1_method</b>(void);</dt>
<dd>
Constructor for the TLSv1 SSL_METHOD structure for combined client and server.</dd>
</dl>
</div>
<div class="subsection">
<h2>DEALING WITH CIPHERS</h2> Here we document the various API functions which deal with the SSL/TLS ciphers defined in  <b>SSL_CIPHER</b> structures.<dl>
<dt>
char *<b>SSL_CIPHER_description</b>(SSL_CIPHER *cipher, char *buf, int len);</dt>
<dd>
Write a string to <i>buf</i> (with a maximum size of <i>len</i>) containing a human readable description of  <i>cipher</i>. Returns <i>buf</i>.</dd>
</dl>
<dl>
<dt>
int <b>SSL_CIPHER_get_bits</b>(SSL_CIPHER *cipher, int *alg_bits);</dt>
<dd>
Determine the number of bits in <i>cipher</i>. Because of export crippled ciphers there are two bits: The bits the algorithm supports in general (stored to  <i>alg_bits</i>) and the bits which are actually used (the return value).</dd>
</dl>
<dl>
<dt>
const char *<b>SSL_CIPHER_get_name</b>(SSL_CIPHER *cipher);</dt>
<dd>
Return the internal name of <i>cipher</i> as a string. These are the various strings defined by the  <i>SSL2_TXT_xxx</i>, <i>SSL3_TXT_xxx</i> and <i>TLS1_TXT_xxx</i> definitions in the header files.</dd>
</dl>
<dl>
<dt>
char *<b>SSL_CIPHER_get_version</b>(SSL_CIPHER *cipher);</dt>
<dd>
Returns a string like ""TLSv1/SSLv3"" or ""SSLv2"" which indicates the SSL/TLS protocol version to which  <i>cipher</i> belongs (i.e. where it was defined in the specification the first time).</dd>
</dl>
</div>
<div class="subsection">
<h2>DEALING WITH PROTOCOL CONTEXTS</h2> Here we document the various API functions which deal with the SSL/TLS protocol context defined in the  <b>SSL_CTX</b> structure.<dl>
<dt>
int <b>SSL_CTX_add_client_CA</b>(SSL_CTX *ctx, X509 *x);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
long <b>SSL_CTX_add_extra_chain_cert</b>(SSL_CTX *ctx, X509 *x509);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_CTX_add_session</b>(SSL_CTX *ctx, SSL_SESSION *c);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_CTX_check_private_key</b>(const SSL_CTX *ctx);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
long <b>SSL_CTX_ctrl</b>(SSL_CTX *ctx, int cmd, long larg, char *parg);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_CTX_flush_sessions</b>(SSL_CTX *s, long t);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_CTX_free</b>(SSL_CTX *a);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
char *<b>SSL_CTX_get_app_data</b>(SSL_CTX *ctx);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
X509_STORE *<b>SSL_CTX_get_cert_store</b>(SSL_CTX *ctx);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
STACK *<b>SSL_CTX_get_client_CA_list</b>(const SSL_CTX *ctx);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int (*<b>SSL_CTX_get_client_cert_cb</b>(SSL_CTX *ctx))(SSL *ssl, X509 **x509, EVP_PKEY **pkey);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_CTX_get_default_read_ahead</b>(SSL_CTX *ctx);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
char *<b>SSL_CTX_get_ex_data</b>(const SSL_CTX *s, int idx);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_CTX_get_ex_new_index</b>(long argl, char *argp, int (*new_func);(void), int (*dup_func)(void), void (*free_func)(void))</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void (*<b>SSL_CTX_get_info_callback</b>(SSL_CTX *ctx))(SSL *ssl, int cb, int ret);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_CTX_get_quiet_shutdown</b>(const SSL_CTX *ctx);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_CTX_get_read_ahead</b>(SSL_CTX *ctx);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_CTX_get_session_cache_mode</b>(SSL_CTX *ctx);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
long <b>SSL_CTX_get_timeout</b>(const SSL_CTX *ctx);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int (*<b>SSL_CTX_get_verify_callback</b>(const SSL_CTX *ctx))(int ok, X509_STORE_CTX *ctx);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_CTX_get_verify_mode</b>(SSL_CTX *ctx);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_CTX_load_verify_locations</b>(SSL_CTX *ctx, char *CAfile, char *CApath);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
long <b>SSL_CTX_need_tmp_RSA</b>(SSL_CTX *ctx);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
SSL_CTX *<b>SSL_CTX_new</b>(const SSL_METHOD *meth);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_CTX_remove_session</b>(SSL_CTX *ctx, SSL_SESSION *c);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_CTX_sess_accept</b>(SSL_CTX *ctx);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_CTX_sess_accept_good</b>(SSL_CTX *ctx);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_CTX_sess_accept_renegotiate</b>(SSL_CTX *ctx);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_CTX_sess_cache_full</b>(SSL_CTX *ctx);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_CTX_sess_cb_hits</b>(SSL_CTX *ctx);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_CTX_sess_connect</b>(SSL_CTX *ctx);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_CTX_sess_connect_good</b>(SSL_CTX *ctx);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_CTX_sess_connect_renegotiate</b>(SSL_CTX *ctx);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_CTX_sess_get_cache_size</b>(SSL_CTX *ctx);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
SSL_SESSION *(*<b>SSL_CTX_sess_get_get_cb</b>(SSL_CTX *ctx))(SSL *ssl, unsigned char *data, int len, int *copy);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int (*<b>SSL_CTX_sess_get_new_cb</b>(SSL_CTX *ctx)(SSL *ssl, SSL_SESSION *sess);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void (*<b>SSL_CTX_sess_get_remove_cb</b>(SSL_CTX *ctx)(SSL_CTX *ctx, SSL_SESSION *sess);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_CTX_sess_hits</b>(SSL_CTX *ctx);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_CTX_sess_misses</b>(SSL_CTX *ctx);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_CTX_sess_number</b>(SSL_CTX *ctx);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_CTX_sess_set_cache_size</b>(SSL_CTX *ctx,t);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_CTX_sess_set_get_cb</b>(SSL_CTX *ctx, SSL_SESSION *(*cb)(SSL *ssl, unsigned char *data, int len, int *copy));</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_CTX_sess_set_new_cb</b>(SSL_CTX *ctx, int (*cb)(SSL *ssl, SSL_SESSION *sess));</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_CTX_sess_set_remove_cb</b>(SSL_CTX *ctx, void (*cb)(SSL_CTX *ctx, SSL_SESSION *sess));</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_CTX_sess_timeouts</b>(SSL_CTX *ctx);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
LHASH *<b>SSL_CTX_sessions</b>(SSL_CTX *ctx);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_CTX_set_app_data</b>(SSL_CTX *ctx, void *arg);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_CTX_set_cert_store</b>(SSL_CTX *ctx, X509_STORE *cs);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_CTX_set_cert_verify_cb</b>(SSL_CTX *ctx, int (*cb)(), char *arg)</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_CTX_set_cipher_list</b>(SSL_CTX *ctx, char *str);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_CTX_set_client_CA_list</b>(SSL_CTX *ctx, STACK *list);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_CTX_set_client_cert_cb</b>(SSL_CTX *ctx, int (*cb)(SSL *ssl, X509 **x509, EVP_PKEY **pkey));</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_CTX_set_default_passwd_cb</b>(SSL_CTX *ctx, int (*cb);(void))</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_CTX_set_default_read_ahead</b>(SSL_CTX *ctx, int m);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_CTX_set_default_verify_paths</b>(SSL_CTX *ctx);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_CTX_set_ex_data</b>(SSL_CTX *s, int idx, char *arg);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_CTX_set_info_callback</b>(SSL_CTX *ctx, void (*cb)(SSL *ssl, int cb, int ret));</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_CTX_set_msg_callback</b>(SSL_CTX *ctx, void (*cb)(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg));</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_CTX_set_msg_callback_arg</b>(SSL_CTX *ctx, void *arg);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_CTX_set_options</b>(SSL_CTX *ctx, unsigned long op);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_CTX_set_quiet_shutdown</b>(SSL_CTX *ctx, int mode);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_CTX_set_read_ahead</b>(SSL_CTX *ctx, int m);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_CTX_set_session_cache_mode</b>(SSL_CTX *ctx, int mode);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_CTX_set_ssl_version</b>(SSL_CTX *ctx, const SSL_METHOD *meth);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_CTX_set_timeout</b>(SSL_CTX *ctx, long t);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
long <b>SSL_CTX_set_tmp_dh</b>(SSL_CTX* ctx, DH *dh);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
long <b>SSL_CTX_set_tmp_dh_callback</b>(SSL_CTX *ctx, DH *(*cb)(void));</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
long <b>SSL_CTX_set_tmp_rsa</b>(SSL_CTX *ctx, RSA *rsa);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
SSL_CTX_set_tmp_rsa_callback</dt>
<dd>
"long <b>SSL_CTX_set_tmp_rsa_callback</b>(SSL_CTX *<b>ctx</b>, RSA *(*<b>cb</b>)(SSL *<b>ssl</b>, int <b>export</b>, int <b>keylength</b>));"<div style="height: 1.00em;">
&#160;</div>
Sets the callback which will be called when a temporary private key is required. The  <b></b><b>"export"</b><b></b> flag will be set if the reason for needing a temp key is that an export ciphersuite is in use, in which case,  <b></b><b>"keylength"</b><b></b> will contain the required keylength in bits. Generate a key of appropriate size (using ???) and return it.</dd>
</dl>
<dl>
<dt>
SSL_set_tmp_rsa_callback</dt>
<dd>
long <b>SSL_set_tmp_rsa_callback</b>(SSL *ssl, RSA *(*cb)(SSL *ssl, int export, int keylength));<div style="height: 1.00em;">
&#160;</div>
The same as <b>SSL_CTX_set_tmp_rsa_callback</b>, except it operates on an SSL session instead of a context.</dd>
</dl>
<dl>
<dt>
void <b>SSL_CTX_set_verify</b>(SSL_CTX *ctx, int mode, int (*cb);(void))</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_CTX_use_PrivateKey</b>(SSL_CTX *ctx, EVP_PKEY *pkey);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_CTX_use_PrivateKey_ASN1</b>(int type, SSL_CTX *ctx, unsigned char *d, long len);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_CTX_use_PrivateKey_file</b>(SSL_CTX *ctx, char *file, int type);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_CTX_use_RSAPrivateKey</b>(SSL_CTX *ctx, RSA *rsa);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_CTX_use_RSAPrivateKey_ASN1</b>(SSL_CTX *ctx, unsigned char *d, long len);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_CTX_use_RSAPrivateKey_file</b>(SSL_CTX *ctx, char *file, int type);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_CTX_use_certificate</b>(SSL_CTX *ctx, X509 *x);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_CTX_use_certificate_ASN1</b>(SSL_CTX *ctx, int len, unsigned char *d);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_CTX_use_certificate_file</b>(SSL_CTX *ctx, char *file, int type);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_CTX_set_psk_client_callback</b>(SSL_CTX *ctx, unsigned int (*callback)(SSL *ssl, const char *hint, char *identity, unsigned int max_identity_len, unsigned char *psk, unsigned int max_psk_len));</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_CTX_use_psk_identity_hint</b>(SSL_CTX *ctx, const char *hint);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_CTX_set_psk_server_callback</b>(SSL_CTX *ctx, unsigned int (*callback)(SSL *ssl, const char *identity, unsigned char *psk, int max_psk_len));</dt>
<dd>
</dd>
</dl>
</div>
<div class="subsection">
<h2>DEALING WITH SESSIONS</h2> Here we document the various API functions which deal with the SSL/TLS sessions defined in the  <b>SSL_SESSION</b> structures.<dl>
<dt>
int <b>SSL_SESSION_cmp</b>(const SSL_SESSION *a, const SSL_SESSION *b);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_SESSION_free</b>(SSL_SESSION *ss);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
char *<b>SSL_SESSION_get_app_data</b>(SSL_SESSION *s);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
char *<b>SSL_SESSION_get_ex_data</b>(const SSL_SESSION *s, int idx);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_SESSION_get_ex_new_index</b>(long argl, char *argp, int (*new_func);(void), int (*dup_func)(void), void (*free_func)(void))</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
long <b>SSL_SESSION_get_time</b>(const SSL_SESSION *s);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
long <b>SSL_SESSION_get_timeout</b>(const SSL_SESSION *s);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
unsigned long <b>SSL_SESSION_hash</b>(const SSL_SESSION *a);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
SSL_SESSION *<b>SSL_SESSION_new</b>(void);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_SESSION_print</b>(BIO *bp, const SSL_SESSION *x);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_SESSION_print_fp</b>(FILE *fp, const SSL_SESSION *x);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_SESSION_set_app_data</b>(SSL_SESSION *s, char *a);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_SESSION_set_ex_data</b>(SSL_SESSION *s, int idx, char *arg);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
long <b>SSL_SESSION_set_time</b>(SSL_SESSION *s, long t);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
long <b>SSL_SESSION_set_timeout</b>(SSL_SESSION *s, long t);</dt>
<dd>
</dd>
</dl>
</div>
<div class="subsection">
<h2>DEALING WITH CONNECTIONS</h2> Here we document the various API functions which deal with the SSL/TLS connection defined in the  <b>SSL</b> structure.<dl>
<dt>
int <b>SSL_accept</b>(SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_add_dir_cert_subjects_to_stack</b>(STACK *stack, const char *dir);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_add_file_cert_subjects_to_stack</b>(STACK *stack, const char *file);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_add_client_CA</b>(SSL *ssl, X509 *x);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
char *<b>SSL_alert_desc_string</b>(int value);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
char *<b>SSL_alert_desc_string_long</b>(int value);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
char *<b>SSL_alert_type_string</b>(int value);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
char *<b>SSL_alert_type_string_long</b>(int value);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_check_private_key</b>(const SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_clear</b>(SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
long <b>SSL_clear_num_renegotiations</b>(SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_connect</b>(SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_copy_session_id</b>(SSL *t, const SSL *f);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
long <b>SSL_ctrl</b>(SSL *ssl, int cmd, long larg, char *parg);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_do_handshake</b>(SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
SSL *<b>SSL_dup</b>(SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
STACK *<b>SSL_dup_CA_list</b>(STACK *sk);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_free</b>(SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
SSL_CTX *<b>SSL_get_SSL_CTX</b>(const SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
char *<b>SSL_get_app_data</b>(SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
X509 *<b>SSL_get_certificate</b>(const SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
const char *<b>SSL_get_cipher</b>(const SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_get_cipher_bits</b>(const SSL *ssl, int *alg_bits);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
char *<b>SSL_get_cipher_list</b>(const SSL *ssl, int n);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
char *<b>SSL_get_cipher_name</b>(const SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
char *<b>SSL_get_cipher_version</b>(const SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
STACK *<b>SSL_get_ciphers</b>(const SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
STACK *<b>SSL_get_client_CA_list</b>(const SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
SSL_CIPHER *<b>SSL_get_current_cipher</b>(SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
long <b>SSL_get_default_timeout</b>(const SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_get_error</b>(const SSL *ssl, int i);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
char *<b>SSL_get_ex_data</b>(const SSL *ssl, int idx);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_get_ex_data_X509_STORE_CTX_idx</b>(void);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_get_ex_new_index</b>(long argl, char *argp, int (*new_func);(void), int (*dup_func)(void), void (*free_func)(void))</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_get_fd</b>(const SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void (*<b>SSL_get_info_callback</b>(const SSL *ssl);)()</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
STACK *<b>SSL_get_peer_cert_chain</b>(const SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
X509 *<b>SSL_get_peer_certificate</b>(const SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
EVP_PKEY *<b>SSL_get_privatekey</b>(SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_get_quiet_shutdown</b>(const SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
BIO *<b>SSL_get_rbio</b>(const SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_get_read_ahead</b>(const SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
SSL_SESSION *<b>SSL_get_session</b>(const SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
char *<b>SSL_get_shared_ciphers</b>(const SSL *ssl, char *buf, int len);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_get_shutdown</b>(const SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
const SSL_METHOD *<b>SSL_get_ssl_method</b>(SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_get_state</b>(const SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
long <b>SSL_get_time</b>(const SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
long <b>SSL_get_timeout</b>(const SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int (*<b>SSL_get_verify_callback</b>(const SSL *ssl))(int,X509_STORE_CTX *)</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_get_verify_mode</b>(const SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
long <b>SSL_get_verify_result</b>(const SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
char *<b>SSL_get_version</b>(const SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
BIO *<b>SSL_get_wbio</b>(const SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_in_accept_init</b>(SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_in_before</b>(SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_in_connect_init</b>(SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_in_init</b>(SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_is_init_finished</b>(SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
STACK *<b>SSL_load_client_CA_file</b>(char *file);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_load_error_strings</b>(void);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
SSL *<b>SSL_new</b>(SSL_CTX *ctx);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
long <b>SSL_num_renegotiations</b>(SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_peek</b>(SSL *ssl, void *buf, int num);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_pending</b>(const SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_read</b>(SSL *ssl, void *buf, int num);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_renegotiate</b>(SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
char *<b>SSL_rstate_string</b>(SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
char *<b>SSL_rstate_string_long</b>(SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
long <b>SSL_session_reused</b>(SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_set_accept_state</b>(SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_set_app_data</b>(SSL *ssl, char *arg);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_set_bio</b>(SSL *ssl, BIO *rbio, BIO *wbio);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_set_cipher_list</b>(SSL *ssl, char *str);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_set_client_CA_list</b>(SSL *ssl, STACK *list);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_set_connect_state</b>(SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_set_ex_data</b>(SSL *ssl, int idx, char *arg);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_set_fd</b>(SSL *ssl, int fd);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_set_info_callback</b>(SSL *ssl, void (*cb);(void))</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_set_msg_callback</b>(SSL *ctx, void (*cb)(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg));</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_set_msg_callback_arg</b>(SSL *ctx, void *arg);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_set_options</b>(SSL *ssl, unsigned long op);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_set_quiet_shutdown</b>(SSL *ssl, int mode);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_set_read_ahead</b>(SSL *ssl, int yes);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_set_rfd</b>(SSL *ssl, int fd);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_set_session</b>(SSL *ssl, SSL_SESSION *session);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_set_shutdown</b>(SSL *ssl, int mode);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_set_ssl_method</b>(SSL *ssl, const SSL_METHOD *meth);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_set_time</b>(SSL *ssl, long t);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_set_timeout</b>(SSL *ssl, long t);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_set_verify</b>(SSL *ssl, int mode, int (*callback);(void))</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_set_verify_result</b>(SSL *ssl, long arg);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_set_wfd</b>(SSL *ssl, int fd);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_shutdown</b>(SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_state</b>(const SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
char *<b>SSL_state_string</b>(const SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
char *<b>SSL_state_string_long</b>(const SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
long <b>SSL_total_renegotiations</b>(SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_use_PrivateKey</b>(SSL *ssl, EVP_PKEY *pkey);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_use_PrivateKey_ASN1</b>(int type, SSL *ssl, unsigned char *d, long len);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_use_PrivateKey_file</b>(SSL *ssl, char *file, int type);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_use_RSAPrivateKey</b>(SSL *ssl, RSA *rsa);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_use_RSAPrivateKey_ASN1</b>(SSL *ssl, unsigned char *d, long len);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_use_RSAPrivateKey_file</b>(SSL *ssl, char *file, int type);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_use_certificate</b>(SSL *ssl, X509 *x);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_use_certificate_ASN1</b>(SSL *ssl, int len, unsigned char *d);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_use_certificate_file</b>(SSL *ssl, char *file, int type);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_version</b>(const SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_want</b>(const SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_want_nothing</b>(const SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_want_read</b>(const SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_want_write</b>(const SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_want_x509_lookup</b>(const SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_write</b>(SSL *ssl, const void *buf, int num);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_set_psk_client_callback</b>(SSL *ssl, unsigned int (*callback)(SSL *ssl, const char *hint, char *identity, unsigned int max_identity_len, unsigned char *psk, unsigned int max_psk_len));</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
int <b>SSL_use_psk_identity_hint</b>(SSL *ssl, const char *hint);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
void <b>SSL_set_psk_server_callback</b>(SSL *ssl, unsigned int (*callback)(SSL *ssl, const char *identity, unsigned char *psk, int max_psk_len));</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
const char *<b>SSL_get_psk_identity_hint</b>(SSL *ssl);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
const char *<b>SSL_get_psk_identity</b>(SSL *ssl);</dt>
<dd>
</dd>
</dl>
</div>
</div>
<div class="section">
<h1>SEE ALSO</h1>  <i>openssl</i>(1), <i>crypto</i>(3),  <i>SSL_accept</i>(3), <i>SSL_clear</i>(3),  <i>SSL_connect</i>(3),  <i>SSL_CIPHER_get_name</i>(3),  <i>SSL_COMP_add_compression_method</i>(3),  <i>SSL_CTX_add_extra_chain_cert</i>(3),  <i>SSL_CTX_add_session</i>(3),  <i>SSL_CTX_ctrl</i>(3),  <i>SSL_CTX_flush_sessions</i>(3),  <i>SSL_CTX_get_ex_new_index</i>(3),  <i>SSL_CTX_get_verify_mode</i>(3),  <i>SSL_CTX_load_verify_locations</i>(3)  <i>SSL_CTX_new</i>(3),  <i>SSL_CTX_sess_number</i>(3),  <i>SSL_CTX_sess_set_cache_size</i>(3),  <i>SSL_CTX_sess_set_get_cb</i>(3),  <i>SSL_CTX_sessions</i>(3),  <i>SSL_CTX_set_cert_store</i>(3),  <i>SSL_CTX_set_cert_verify_callback</i>(3),  <i>SSL_CTX_set_cipher_list</i>(3),  <i>SSL_CTX_set_client_CA_list</i>(3),  <i>SSL_CTX_set_client_cert_cb</i>(3),  <i>SSL_CTX_set_default_passwd_cb</i>(3),  <i>SSL_CTX_set_generate_session_id</i>(3),  <i>SSL_CTX_set_info_callback</i>(3),  <i>SSL_CTX_set_max_cert_list</i>(3),  <i>SSL_CTX_set_mode</i>(3),  <i>SSL_CTX_set_msg_callback</i>(3),  <i>SSL_CTX_set_options</i>(3),  <i>SSL_CTX_set_quiet_shutdown</i>(3),  <i>SSL_CTX_set_read_ahead</i>(3),  <i>SSL_CTX_set_session_cache_mode</i>(3),  <i>SSL_CTX_set_session_id_context</i>(3),  <i>SSL_CTX_set_ssl_version</i>(3),  <i>SSL_CTX_set_timeout</i>(3),  <i>SSL_CTX_set_tmp_rsa_callback</i>(3),  <i>SSL_CTX_set_tmp_dh_callback</i>(3),  <i>SSL_CTX_set_verify</i>(3),  <i>SSL_CTX_use_certificate</i>(3),  <i>SSL_alert_type_string</i>(3),  <i>SSL_do_handshake</i>(3),  <i>SSL_get_SSL_CTX</i>(3),  <i>SSL_get_ciphers</i>(3),  <i>SSL_get_client_CA_list</i>(3),  <i>SSL_get_default_timeout</i>(3),  <i>SSL_get_error</i>(3),  <i>SSL_get_ex_data_X509_STORE_CTX_idx</i>(3),  <i>SSL_get_ex_new_index</i>(3),  <i>SSL_get_fd</i>(3),  <i>SSL_get_peer_cert_chain</i>(3),  <i>SSL_get_rbio</i>(3),  <i>SSL_get_session</i>(3),  <i>SSL_get_verify_result</i>(3),  <i>SSL_get_version</i>(3),  <i>SSL_library_init</i>(3),  <i>SSL_load_client_CA_file</i>(3),  <i>SSL_new</i>(3),  <i>SSL_pending</i>(3),  <i>SSL_read</i>(3),  <i>SSL_rstate_string</i>(3),  <i>SSL_session_reused</i>(3),  <i>SSL_set_bio</i>(3),  <i>SSL_set_connect_state</i>(3),  <i>SSL_set_fd</i>(3),  <i>SSL_set_session</i>(3),  <i>SSL_set_shutdown</i>(3),  <i>SSL_shutdown</i>(3),  <i>SSL_state_string</i>(3),  <i>SSL_want</i>(3),  <i>SSL_write</i>(3),  <i>SSL_SESSION_free</i>(3),  <i>SSL_SESSION_get_ex_new_index</i>(3),  <i>SSL_SESSION_get_time</i>(3),  <i>d2i_SSL_SESSION</i>(3),  <i>SSL_CTX_set_psk_client_callback</i>(3),  <i>SSL_CTX_use_psk_identity_hint</i>(3),  <i>SSL_get_psk_identity</i>(3)</div>
<div class="section">
<h1>HISTORY</h1> The  <i>ssl</i>(3) document appeared in OpenSSL 0.9.2</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tr>
<td class="foot-date">
2015-03-23</td>
<td class="foot-os" align="right">
1.0.1n</td>
</tr>
</table>
</div>
</body>
</html>

