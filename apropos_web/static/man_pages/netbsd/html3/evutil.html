<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="/static/man_pages/netbsd/style.css" type="text/css" media="all">
<title>
evutil(3)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
evutil(3)</td>
<td class="head-vol" align="center">
Library Functions Manual</td>
<td class="head-rtitle" align="right">
evutil(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> evutil &#45;<p>
Common convenience functions for cross-platform portability and related socket manipulations.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>SYNOPSIS</h1> #include &lt;event2/util.h&gt;<div style="height: 0.00em;">
&#160;</div>
#include &lt;event2/event-config.h&gt;<div style="height: 0.00em;">
&#160;</div>
#include &lt;stdarg.h&gt;<div style="height: 0.00em;">
&#160;</div>
#include &lt;sys/socket.h&gt;<div style="height: 0.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="subsection">
<h2>Data Structures</h2><br>
struct <b>evutil_addrinfo</b><div style="height: 0.00em;">
&#160;</div>
<i>A definition of struct addrinfo for systems that lack it. </i><br>
</div>
<div class="subsection">
<h2>Macros</h2><br>
#define <b>ev_socklen_t</b>   socklen_t<div style="height: 0.00em;">
&#160;</div>
#define <b>EVUTIL_CLOSESOCKET</b>(s)   <b>evutil_closesocket</b>(s)<div style="height: 0.00em;">
&#160;</div>
#define <b>evutil_offsetof</b>(type, field)   ((off_t)(&amp;((type *)0)-&gt;field))<div style="height: 0.00em;">
&#160;</div>
<i>Replacement for offsetof on platforms that don't define it. </i> #define  <b>evutil_socket_t</b>   int<div style="height: 0.00em;">
&#160;</div>
<i>A type wide enough to hold the output of 'socket()' or 'accept()'. </i> #define  <b>evutil_timercmp</b>(tvp, uvp, cmp)<div style="height: 0.00em;">
&#160;</div>
<i>Return true iff the tvp is related to uvp according to the relational operator cmp. </i> #define  <b>evutil_timerisset</b>(tvp)   ((tvp)-&gt;tv_sec || (tvp)-&gt;tv_usec)<div style="height: 0.00em;">
&#160;</div>
<br>
<p>
<b>Standard integer types.</b><div style="height: 0.00em;">
&#160;</div>
Integer type definitions for types that are supposed to be defined in the C99-specified stdint.h.<p>
Shamefully, some platforms do not include stdint.h, so we need to replace it. (If you are on a platform like this, your C headers are now over 10 years out of date. You should bug them to do something about this.)<p>
We define:<dl>
<dt>
<b>ev_uint64_t, ev_uint32_t, ev_uint16_t, ev_uint8_t </b></dt>
<dd>
unsigned integer types of exactly 64, 32, 16, and 8 bits respectively.</dd>
</dl>
<dl>
<dt>
<b>ev_int64_t, ev_int32_t, ev_int16_t, ev_int8_t </b></dt>
<dd>
signed integer types of exactly 64, 32, 16, and 8 bits respectively.</dd>
</dl>
<dl>
<dt>
<b>ev_uintptr_t, ev_intptr_t </b></dt>
<dd>
unsigned/signed integers large enough to hold a pointer without loss of bits.</dd>
</dl>
<dl>
<dt>
<b>ev_ssize_t </b></dt>
<dd>
A signed type of the same size as size_t</dd>
</dl>
<dl>
<dt>
<b>ev_off_t </b></dt>
<dd>
A signed type typically used to represent offsets within a (potentially large) file</dd>
</dl>
<p>
<div style="height: 1.00em;">
&#160;</div>
<p>
<br>
<br>
#define <b>ev_uint64_t</b>   ...<div style="height: 0.00em;">
&#160;</div>
#define <b>ev_int64_t</b>   ...<div style="height: 0.00em;">
&#160;</div>
#define <b>ev_uint32_t</b>   ...<div style="height: 0.00em;">
&#160;</div>
#define <b>ev_int32_t</b>   ...<div style="height: 0.00em;">
&#160;</div>
#define <b>ev_uint16_t</b>   ...<div style="height: 0.00em;">
&#160;</div>
#define <b>ev_int16_t</b>   ...<div style="height: 0.00em;">
&#160;</div>
#define <b>ev_uint8_t</b>   ...<div style="height: 0.00em;">
&#160;</div>
#define <b>ev_int8_t</b>   ...<div style="height: 0.00em;">
&#160;</div>
#define <b>ev_uintptr_t</b>   ev_uint32_t<div style="height: 0.00em;">
&#160;</div>
#define <b>ev_intptr_t</b>   ev_int32_t<div style="height: 0.00em;">
&#160;</div>
#define <b>ev_ssize_t</b>   ssize_t<div style="height: 0.00em;">
&#160;</div>
#define <b>ev_off_t</b>   off_t<div style="height: 0.00em;">
&#160;</div>
<br>
<br>
<p>
<b>Limits for integer types</b><div style="height: 0.00em;">
&#160;</div>
These macros hold the largest or smallest values possible for the ev_[u]int*_t types.<p>
<br>
<br>
#define <b>EV_UINT64_MAX</b>   ((((ev_uint64_t)0xffffffffUL) &lt;&lt; 32) | 0xffffffffUL)<div style="height: 0.00em;">
&#160;</div>
#define <b>EV_INT64_MAX</b>   ((((ev_int64_t) 0x7fffffffL) &lt;&lt; 32) | 0xffffffffL)<div style="height: 0.00em;">
&#160;</div>
#define <b>EV_INT64_MIN</b>   ((-EV_INT64_MAX) - 1)<div style="height: 0.00em;">
&#160;</div>
#define <b>EV_UINT32_MAX</b>   ((ev_uint32_t)0xffffffffUL)<div style="height: 0.00em;">
&#160;</div>
#define <b>EV_INT32_MAX</b>   ((ev_int32_t) 0x7fffffffL)<div style="height: 0.00em;">
&#160;</div>
#define <b>EV_INT32_MIN</b>   ((-EV_INT32_MAX) - 1)<div style="height: 0.00em;">
&#160;</div>
#define <b>EV_UINT16_MAX</b>   ((ev_uint16_t)0xffffUL)<div style="height: 0.00em;">
&#160;</div>
#define <b>EV_INT16_MAX</b>   ((ev_int16_t) 0x7fffL)<div style="height: 0.00em;">
&#160;</div>
#define <b>EV_INT16_MIN</b>   ((-EV_INT16_MAX) - 1)<div style="height: 0.00em;">
&#160;</div>
#define <b>EV_UINT8_MAX</b>   255<div style="height: 0.00em;">
&#160;</div>
#define <b>EV_INT8_MAX</b>   127<div style="height: 0.00em;">
&#160;</div>
#define <b>EV_INT8_MIN</b>   ((-EV_INT8_MAX) - 1)<div style="height: 0.00em;">
&#160;</div>
<br>
<br>
<p>
<b>Limits for SIZE_T and SSIZE_T</b><div style="height: 0.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<br>
<br>
#define <b>EV_SIZE_MAX</b>   ...<div style="height: 0.00em;">
&#160;</div>
#define <b>EV_SSIZE_MAX</b>   ...<div style="height: 0.00em;">
&#160;</div>
#define <b>EV_SSIZE_MIN</b>   ((-EV_SSIZE_MAX) - 1)<div style="height: 0.00em;">
&#160;</div>
<br>
<br>
<p>
<b>Socket error functions</b><div style="height: 0.00em;">
&#160;</div>
These functions are needed for making programs compatible between Windows and Unix-like platforms.<p>
You see, Winsock handles socket errors differently from the rest of the world. Elsewhere, a socket error is like any other error and is stored in errno. But winsock functions require you to retrieve the error with a special function, and don't let you use strerror for the error codes. And handling EWOULDBLOCK is ... different.<p>
<br>
<br>
#define <b>EVUTIL_SOCKET_ERROR</b>()   ...<div style="height: 0.00em;">
&#160;</div>
<i>Return the most recent socket error. </i> #define  <b>EVUTIL_SET_SOCKET_ERROR</b>(errcode)   ...<div style="height: 0.00em;">
&#160;</div>
<i>Replace the most recent socket error with errcode. </i> #define  <b>evutil_socket_geterror</b>(sock)   ...<div style="height: 0.00em;">
&#160;</div>
<i>Return the most recent socket error to occur on sock. </i> #define  <b>evutil_socket_error_to_string</b>(errcode)   ...<div style="height: 0.00em;">
&#160;</div>
<i>Convert a socket error to a string. </i><br>
<br>
<p>
<b>Manipulation macros for struct timeval.</b><div style="height: 0.00em;">
&#160;</div>
We define replacements for timeradd, timersub, timerclear, timercmp, and timerisset.<p>
<br>
<br>
#define <b>evutil_timeradd</b>(tvp, uvp, vvp)<div style="height: 0.00em;">
&#160;</div>
#define <b>evutil_timersub</b>(tvp, uvp, vvp)<div style="height: 0.00em;">
&#160;</div>
#define <b>evutil_timerclear</b>(tvp)   (tvp)-&gt;tv_sec = (tvp)-&gt;tv_usec = 0<div style="height: 0.00em;">
&#160;</div>
<br>
<br>
<p>
<b>evutil_getaddrinfo() error codes</b><div style="height: 0.00em;">
&#160;</div>
These values are possible error codes for <b>evutil_getaddrinfo()</b> and related functions.<p>
<br>
<br>
#define <b>EVUTIL_EAI_ADDRFAMILY</b>   -901<div style="height: 0.00em;">
&#160;</div>
#define <b>EVUTIL_EAI_AGAIN</b>   -902<div style="height: 0.00em;">
&#160;</div>
#define <b>EVUTIL_EAI_BADFLAGS</b>   -903<div style="height: 0.00em;">
&#160;</div>
#define <b>EVUTIL_EAI_FAIL</b>   -904<div style="height: 0.00em;">
&#160;</div>
#define <b>EVUTIL_EAI_FAMILY</b>   -905<div style="height: 0.00em;">
&#160;</div>
#define <b>EVUTIL_EAI_MEMORY</b>   -906<div style="height: 0.00em;">
&#160;</div>
#define <b>EVUTIL_EAI_NODATA</b>   -907<div style="height: 0.00em;">
&#160;</div>
#define <b>EVUTIL_EAI_NONAME</b>   -908<div style="height: 0.00em;">
&#160;</div>
#define <b>EVUTIL_EAI_SERVICE</b>   -909<div style="height: 0.00em;">
&#160;</div>
#define <b>EVUTIL_EAI_SOCKTYPE</b>   -910<div style="height: 0.00em;">
&#160;</div>
#define <b>EVUTIL_EAI_SYSTEM</b>   -911<div style="height: 0.00em;">
&#160;</div>
#define <b>EVUTIL_EAI_CANCEL</b>   -90001<div style="height: 0.00em;">
&#160;</div>
#define <b>EVUTIL_AI_PASSIVE</b>   0x1000<div style="height: 0.00em;">
&#160;</div>
#define <b>EVUTIL_AI_CANONNAME</b>   0x2000<div style="height: 0.00em;">
&#160;</div>
#define <b>EVUTIL_AI_NUMERICHOST</b>   0x4000<div style="height: 0.00em;">
&#160;</div>
#define <b>EVUTIL_AI_NUMERICSERV</b>   0x8000<div style="height: 0.00em;">
&#160;</div>
#define <b>EVUTIL_AI_V4MAPPED</b>   0x10000<div style="height: 0.00em;">
&#160;</div>
#define <b>EVUTIL_AI_ALL</b>   0x20000<div style="height: 0.00em;">
&#160;</div>
#define <b>EVUTIL_AI_ADDRCONFIG</b>   0x40000<div style="height: 0.00em;">
&#160;</div>
<br>
<br>
</div>
<div class="subsection">
<h2>Functions</h2><br>
int <b>evutil_ascii_strcasecmp</b> (const char *str1, const char *str2)<div style="height: 0.00em;">
&#160;</div>
<i>As strcasecmp, but always compares the characters in locale-independent ASCII. </i> int  <b>evutil_ascii_strncasecmp</b> (const char *str1, const char *str2, size_t n)<div style="height: 0.00em;">
&#160;</div>
<i>As strncasecmp, but always compares the characters in locale-independent ASCII. </i> int  <b>evutil_closesocket</b> (<b>evutil_socket_t</b> sock)<div style="height: 0.00em;">
&#160;</div>
<i>Do the platform-specific call needed to close a socket returned from socket() or accept(). </i> void  <b>evutil_freeaddrinfo</b> (struct <b>evutil_addrinfo</b> *ai)<div style="height: 0.00em;">
&#160;</div>
<i>Release storage allocated by evutil_getaddrinfo or evdns_getaddrinfo. </i> const char *  <b>evutil_gai_strerror</b> (int err)<div style="height: 0.00em;">
&#160;</div>
int <b>evutil_getaddrinfo</b> (const char *nodename, const char *servname, const struct <b>evutil_addrinfo</b> *hints_in, struct <b>evutil_addrinfo</b> **res)<div style="height: 0.00em;">
&#160;</div>
<i>This function clones getaddrinfo for systems that don't have it. </i> int  <b>evutil_gettimeofday</b> (struct timeval *tv, struct timezone *tz)<div style="height: 0.00em;">
&#160;</div>
const char * <b>evutil_inet_ntop</b> (int af, const void *src, char *dst, size_t len)<div style="height: 0.00em;">
&#160;</div>
<i>Replacement for inet_ntop for platforms which lack it. </i> int  <b>evutil_inet_pton</b> (int af, const char *src, void *dst)<div style="height: 0.00em;">
&#160;</div>
<i>Replacement for inet_pton for platforms which lack it. </i> int  <b>evutil_make_listen_socket_reuseable</b> (<b>evutil_socket_t</b> sock)<div style="height: 0.00em;">
&#160;</div>
<i>Do platform-specific operations to make a listener socket reusable. </i> int  <b>evutil_make_socket_closeonexec</b> (<b>evutil_socket_t</b> sock)<div style="height: 0.00em;">
&#160;</div>
<i>Do platform-specific operations as needed to close a socket upon a successful execution of one of the exec*() functions. </i> int  <b>evutil_make_socket_nonblocking</b> (<b>evutil_socket_t</b> sock)<div style="height: 0.00em;">
&#160;</div>
<i>Do platform-specific operations as needed to make a socket nonblocking. </i> int  <b>evutil_parse_sockaddr_port</b> (const char *str, struct sockaddr *out, int *outlen)<div style="height: 0.00em;">
&#160;</div>
<i>Parse an IPv4 or IPv6 address, with optional port, from a string. </i> void  <b>evutil_secure_rng_add_bytes</b> (const char *dat, size_t datlen)<div style="height: 0.00em;">
&#160;</div>
<i>Seed the random number generator with extra random bytes. </i> void  <b>evutil_secure_rng_get_bytes</b> (void *buf, size_t n)<div style="height: 0.00em;">
&#160;</div>
<i>Generate n bytes of secure pseudorandom data, and store them in buf. </i> int  <b>evutil_secure_rng_init</b> (void)<div style="height: 0.00em;">
&#160;</div>
<i>Seed the secure random number generator if needed, and return 0 on success or -1 on failure. </i> int  <b>evutil_secure_rng_set_urandom_device_file</b> (char *fname)<div style="height: 0.00em;">
&#160;</div>
<i>Set a filename to use in place of /dev/urandom for seeding the secure PRNG. </i> int  <b>evutil_snprintf</b> (char *buf, size_t buflen, const char *format,...)<div style="height: 0.00em;">
&#160;</div>
<i>Replacement for snprintf to get consistent behavior on platforms for which the return value of snprintf does not conform to C99. </i> int  <b>evutil_sockaddr_cmp</b> (const struct sockaddr *sa1, const struct sockaddr *sa2, int include_port)<div style="height: 0.00em;">
&#160;</div>
<i>Compare two sockaddrs; return 0 if they are equal, or less than 0 if sa1 preceeds sa2, or greater than 0 if sa1 follows sa2. </i> int  <b>evutil_socketpair</b> (int d, int type, int protocol, <b>evutil_socket_t</b> sv[2])<div style="height: 0.00em;">
&#160;</div>
<i>Create two new sockets that are connected to each other. </i> ev_int64_t  <b>evutil_strtoll</b> (const char *s, char **endptr, int base)<div style="height: 0.00em;">
&#160;</div>
<i>Parse a 64-bit value from a string. </i> int  <b>evutil_vsnprintf</b> (char *buf, size_t buflen, const char *format, va_list ap)<div style="height: 0.00em;">
&#160;</div>
<i>Replacement for vsnprintf to get consistent behavior on platforms for which the return value of snprintf does not conform to C99. </i><br>
</div>
</div>
<div class="section">
<h1>Detailed Description</h1> Common convenience functions for cross-platform portability and related socket manipulations.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>Macro Definition Documentation</h1><div class="subsection">
<h2>#define evutil_offsetof(type, field)   ((off_t)(&amp;((type *)0)-&gt;field))</h2> Replacement for offsetof on platforms that don't define it.</div>
<div class="subsection">
<h2>#define EVUTIL_SOCKET_ERROR()   ...</h2> Return the most recent socket error. Not idempotent on all platforms.</div>
<div class="subsection">
<h2>#define evutil_socket_error_to_string(errcode)   ...</h2> Convert a socket error to a string.</div>
<div class="subsection">
<h2>#define evutil_socket_geterror(sock)   ...</h2> Return the most recent socket error to occur on sock.</div>
<div class="subsection">
<h2>#define evutil_socket_t   int</h2> A type wide enough to hold the output of 'socket()' or 'accept()'. On Windows, this is an intptr_t; elsewhere, it is an int.</div>
<div class="subsection">
<h2>#define evutil_timeradd(tvp, uvp, vvp)</h2>  <b>Value:</b><p>
<br>
do {                                       (vvp)-&gt;tv_sec = (tvp)-&gt;tv_sec + (uvp)-&gt;tv_sec;              (vvp)-&gt;tv_usec = (tvp)-&gt;tv_usec + (uvp)-&gt;tv_usec;               if ((vvp)-&gt;tv_usec &gt;= 1000000) {                        (vvp)-&gt;tv_sec++;                            (vvp)-&gt;tv_usec -= 1000000;                  }                               } while (0)<br>
</div>
<div class="subsection">
<h2>#define evutil_timercmp(tvp, uvp, cmp)</h2>  <b>Value:</b><p>
<br>
(((tvp)-&gt;tv_sec == (uvp)-&gt;tv_sec) ?                    ((tvp)-&gt;tv_usec cmp (uvp)-&gt;tv_usec) :                   ((tvp)-&gt;tv_sec cmp (uvp)-&gt;tv_sec))<br>
<p>
Return true iff the tvp is related to uvp according to the relational operator cmp. Recognized values for cmp are ==, &lt;=, &lt;, &gt;=, and &gt;.</div>
<div class="subsection">
<h2>#define evutil_timersub(tvp, uvp, vvp)</h2>  <b>Value:</b><p>
<br>
do {                                      (vvp)-&gt;tv_sec = (tvp)-&gt;tv_sec - (uvp)-&gt;tv_sec;              (vvp)-&gt;tv_usec = (tvp)-&gt;tv_usec - (uvp)-&gt;tv_usec;           if ((vvp)-&gt;tv_usec &lt; 0) {                           (vvp)-&gt;tv_sec--;                            (vvp)-&gt;tv_usec += 1000000;                  }                               } while (0)<br>
</div>
</div>
<div class="section">
<h1>Function Documentation</h1><div class="subsection">
<h2>int evutil_ascii_strcasecmp (const char *str1, const char *str2)</h2> As strcasecmp, but always compares the characters in locale-independent ASCII. That's useful if you're handling data in ASCII-based protocols.</div>
<div class="subsection">
<h2>int evutil_ascii_strncasecmp (const char *str1, const char *str2, size_tn)</h2> As strncasecmp, but always compares the characters in locale-independent ASCII. That's useful if you're handling data in ASCII-based protocols.</div>
<div class="subsection">
<h2>int evutil_closesocket (<b>evutil_socket_t</b>sock)</h2> Do the platform-specific call needed to close a socket returned from socket() or accept().<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>sock</i> The socket to be closed</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 on success, -1 on failure</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>void evutil_freeaddrinfo (struct <b>evutil_addrinfo</b> *ai)</h2> Release storage allocated by evutil_getaddrinfo or evdns_getaddrinfo.</div>
<div class="subsection">
<h2>int evutil_getaddrinfo (const char *nodename, const char *servname, const struct <b>evutil_addrinfo</b> *hints_in, struct <b>evutil_addrinfo</b> **res)</h2> This function clones getaddrinfo for systems that don't have it. For full details, see RFC 3493, section 6.1.<p>
Limitations:<dl>
<dt>
&#8226;</dt>
<dd>
When the system has no getaddrinfo, we fall back to gethostbyname_r or gethostbyname, with their attendant issues.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
The AI_V4MAPPED and AI_ALL flags are not currently implemented.</dd>
</dl>
<p>
For a nonblocking variant, see evdns_getaddrinfo.</div>
<div class="subsection">
<h2>const char* evutil_inet_ntop (intaf, const void *src, char *dst, size_tlen)</h2> Replacement for inet_ntop for platforms which lack it.</div>
<div class="subsection">
<h2>int evutil_inet_pton (intaf, const char *src, void *dst)</h2> Replacement for inet_pton for platforms which lack it.</div>
<div class="subsection">
<h2>int evutil_make_listen_socket_reuseable (<b>evutil_socket_t</b>sock)</h2> Do platform-specific operations to make a listener socket reusable. Specifically, we want to make sure that another program will be able to bind this address right after we've closed the listener.<p>
This differs from Windows's interpretation of 'reusable', which allows multiple listeners to bind the same address at the same time.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>sock</i> The socket to make reusable</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 on success, -1 on failure</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int evutil_make_socket_closeonexec (<b>evutil_socket_t</b>sock)</h2> Do platform-specific operations as needed to close a socket upon a successful execution of one of the exec*() functions.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>sock</i> The socket to be closed</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 on success, -1 on failure</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int evutil_make_socket_nonblocking (<b>evutil_socket_t</b>sock)</h2> Do platform-specific operations as needed to make a socket nonblocking.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>sock</i> The socket to make nonblocking</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 on success, -1 on failure</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int evutil_parse_sockaddr_port (const char *str, struct sockaddr *out, int *outlen)</h2> Parse an IPv4 or IPv6 address, with optional port, from a string. Recognized formats are:<dl>
<dt>
&#8226;</dt>
<dd>
[IPv6Address]:port</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
[IPv6Address]</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
IPv6Address</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
IPv4Address:port</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
IPv4Address</dd>
</dl>
<p>
If no port is specified, the port in the output is set to 0.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>str</i> The string to parse.<div style="height: 0.00em;">
&#160;</div>
<i>out</i> A struct sockaddr to hold the result. This should probably be a struct sockaddr_storage.<div style="height: 0.00em;">
&#160;</div>
<i>outlen</i> A pointer to the number of bytes that that 'out' can safely hold. Set to the number of bytes used in 'out' on success.</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
-1 if the address is not well-formed, if the port is out of range, or if out is not large enough to hold the result. Otherwise returns 0 on success.</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>void evutil_secure_rng_add_bytes (const char *dat, size_tdatlen)</h2> Seed the random number generator with extra random bytes. You should almost never need to call this function; it should be sufficient to invoke  <b>evutil_secure_rng_init()</b>, or let Libevent take care of calling <b>evutil_secure_rng_init()</b> on its own.<p>
If you call this function as a <i>replacement</i> for the regular entropy sources, then you need to be sure that your input contains a fairly large amount of strong entropy. Doing so is notoriously hard: most people who try get it wrong. Watch out!<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>dat</i> a buffer full of a strong source of random numbers<div style="height: 0.00em;">
&#160;</div>
<i>datlen</i> the number of bytes to read from datlen</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>void evutil_secure_rng_get_bytes (void *buf, size_tn)</h2> Generate n bytes of secure pseudorandom data, and store them in buf. Current versions of Libevent use an ARC4-based random number generator, seeded using the platform's entropy source (/dev/urandom on Unix-like systems; CryptGenRandom on Windows). This is not actually as secure as it should be: ARC4 is a pretty lousy cipher, and the current implementation provides only rudimentary prediction- and backtracking-resistance. Don't use this for serious cryptographic applications.</div>
<div class="subsection">
<h2>int evutil_secure_rng_init (void)</h2> Seed the secure random number generator if needed, and return 0 on success or -1 on failure. It is okay to call this function more than once; it will still return 0 if the RNG has been successfully seeded and -1 if it can't be seeded.<p>
Ordinarily you don't need to call this function from your own code; Libevent will seed the RNG itself the first time it needs good random numbers. You only need to call it if (a) you want to double-check that one of the seeding methods did succeed, or (b) you plan to drop the capability to seed (by chrooting, or dropping capabilities, or whatever), and you want to make sure that seeding happens before your program loses the ability to do it.</div>
<div class="subsection">
<h2>int evutil_secure_rng_set_urandom_device_file (char *fname)</h2> Set a filename to use in place of /dev/urandom for seeding the secure PRNG. Return 0 on success, -1 on failure.<p>
Call this function BEFORE calling any other initialization or RNG functions.<p>
(This string will <i>NOT</i> be copied internally. Do not free it while any user of the secure RNG might be running. Don't pass anything other than a real /dev/...random device file here, or you might lose security.)<p>
This API is unstable, and might change in a future libevent version.</div>
<div class="subsection">
<h2>int evutil_sockaddr_cmp (const struct sockaddr *sa1, const struct sockaddr *sa2, intinclude_port)</h2> Compare two sockaddrs; return 0 if they are equal, or less than 0 if sa1 preceeds sa2, or greater than 0 if sa1 follows sa2. If include_port is true, consider the port as well as the address. Only implemented for AF_INET and AF_INET6 addresses. The ordering is not guaranteed to remain the same between Libevent versions.</div>
<div class="subsection">
<h2>int evutil_socketpair (intd, inttype, intprotocol, <b>evutil_socket_t</b>sv[2])</h2> Create two new sockets that are connected to each other. On Unix, this simply calls socketpair(). On Windows, it uses the loopback network interface on 127.0.0.1, and only AF_INET,SOCK_STREAM are supported.<p>
(This may fail on some Windows hosts where firewall software has cleverly decided to keep 127.0.0.1 from talking to itself.)<p>
Parameters and return values are as for socketpair()</div>
<div class="subsection">
<h2>ev_int64_t evutil_strtoll (const char *s, char **endptr, intbase)</h2> Parse a 64-bit value from a string. Arguments are as for strtol.</div>
</div>
<div class="section">
<h1>Author</h1> Generated automatically by Doxygen for libevent from the source code.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tr>
<td class="foot-date">
Tue Jan 27 2015</td>
<td class="foot-os" align="right">
libevent</td>
</tr>
</table>
</div>
</body>
</html>

