<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="/static/man_pages/netbsd/style.css" type="text/css" media="all">
<title>
TREE(3)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
TREE(3)</td>
<td class="head-vol" align="center">
Library Functions Manual</td>
<td class="head-rtitle" align="right">
TREE(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">SPLAY_PROTOTYPE</b>, <b class="name">SPLAY_GENERATE</b>, <b class="name">SPLAY_ENTRY</b>, <b class="name">SPLAY_HEAD</b>, <b class="name">SPLAY_INITIALIZER</b>, <b class="name">SPLAY_ROOT</b>, <b class="name">SPLAY_EMPTY</b>, <b class="name">SPLAY_NEXT</b>, <b class="name">SPLAY_MIN</b>, <b class="name">SPLAY_MAX</b>, <b class="name">SPLAY_FIND</b>, <b class="name">SPLAY_LEFT</b>, <b class="name">SPLAY_RIGHT</b>, <b class="name">SPLAY_FOREACH</b>, <b class="name">SPLAY_INIT</b>, <b class="name">SPLAY_INSERT</b>, <b class="name">SPLAY_REMOVE</b>, <b class="name">RB_PROTOTYPE</b>, <b class="name">RB_PROTOTYPE_STATIC</b>, <b class="name">RB_GENERATE</b>, <b class="name">RB_GENERATE_STATIC</b>, <b class="name">RB_ENTRY</b>, <b class="name">RB_HEAD</b>, <b class="name">RB_INITIALIZER</b>, <b class="name">RB_ROOT</b>, <b class="name">RB_EMPTY</b>, <b class="name">RB_NEXT</b>, <b class="name">RB_PREV</b>, <b class="name">RB_MIN</b>, <b class="name">RB_MAX</b>, <b class="name">RB_FIND</b>, <b class="name">RB_NFIND</b>, <b class="name">RB_LEFT</b>, <b class="name">RB_RIGHT</b>, <b class="name">RB_PARENT</b>, <b class="name">RB_FOREACH</b>, <b class="name">RB_FOREACH_SAFE</b>, <b class="name">RB_FOREACH_REVERSE</b>, <b class="name">RB_FOREACH_REVERSE_SAFE</b>, <b class="name">RB_INIT</b>, <b class="name">RB_INSERT</b>, <b class="name">RB_REMOVE</b> &#8212; <span class="desc">implementations of splay and red-black trees</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/tree.h</a>&gt;</b><p>
<b class="fname">SPLAY_PROTOTYPE</b>(<i class="farg" style="white-space:nowrap;">NAME</i>, <i class="farg" style="white-space:nowrap;">TYPE</i>, <i class="farg" style="white-space:nowrap;">FIELD</i>, <i class="farg" style="white-space:nowrap;">CMP</i>);<p>
<b class="fname">SPLAY_GENERATE</b>(<i class="farg" style="white-space:nowrap;">NAME</i>, <i class="farg" style="white-space:nowrap;">TYPE</i>, <i class="farg" style="white-space:nowrap;">FIELD</i>, <i class="farg" style="white-space:nowrap;">CMP</i>);<p>
<b class="fname">SPLAY_ENTRY</b>(<i class="farg" style="white-space:nowrap;">TYPE</i>);<p>
<b class="fname">SPLAY_HEAD</b>(<i class="farg" style="white-space:nowrap;">HEADNAME</i>, <i class="farg" style="white-space:nowrap;">TYPE</i>);<p>
<i class="ftype">struct TYPE *</i><br>
<b class="fname">SPLAY_INITIALIZER</b>(<i class="farg" style="white-space:nowrap;">SPLAY_HEAD *head</i>);<p>
<b class="fname">SPLAY_ROOT</b>(<i class="farg" style="white-space:nowrap;">SPLAY_HEAD *head</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">SPLAY_EMPTY</b>(<i class="farg" style="white-space:nowrap;">SPLAY_HEAD *head</i>);<p>
<i class="ftype">struct TYPE *</i><br>
<b class="fname">SPLAY_NEXT</b>(<i class="farg" style="white-space:nowrap;">NAME</i>, <i class="farg" style="white-space:nowrap;">SPLAY_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">struct TYPE *elm</i>);<p>
<i class="ftype">struct TYPE *</i><br>
<b class="fname">SPLAY_MIN</b>(<i class="farg" style="white-space:nowrap;">NAME</i>, <i class="farg" style="white-space:nowrap;">SPLAY_HEAD *head</i>);<p>
<i class="ftype">struct TYPE *</i><br>
<b class="fname">SPLAY_MAX</b>(<i class="farg" style="white-space:nowrap;">NAME</i>, <i class="farg" style="white-space:nowrap;">SPLAY_HEAD *head</i>);<p>
<i class="ftype">struct TYPE *</i><br>
<b class="fname">SPLAY_FIND</b>(<i class="farg" style="white-space:nowrap;">NAME</i>, <i class="farg" style="white-space:nowrap;">SPLAY_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">struct TYPE *elm</i>);<p>
<i class="ftype">struct TYPE *</i><br>
<b class="fname">SPLAY_LEFT</b>(<i class="farg" style="white-space:nowrap;">struct TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">SPLAY_ENTRY NAME</i>);<p>
<i class="ftype">struct TYPE *</i><br>
<b class="fname">SPLAY_RIGHT</b>(<i class="farg" style="white-space:nowrap;">struct TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">SPLAY_ENTRY NAME</i>);<p>
<b class="fname">SPLAY_FOREACH</b>(<i class="farg" style="white-space:nowrap;">VARNAME</i>, <i class="farg" style="white-space:nowrap;">NAME</i>, <i class="farg" style="white-space:nowrap;">SPLAY_HEAD *head</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">SPLAY_INIT</b>(<i class="farg" style="white-space:nowrap;">SPLAY_HEAD *head</i>);<p>
<i class="ftype">struct TYPE *</i><br>
<b class="fname">SPLAY_INSERT</b>(<i class="farg" style="white-space:nowrap;">NAME</i>, <i class="farg" style="white-space:nowrap;">SPLAY_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">struct TYPE *elm</i>);<p>
<i class="ftype">struct TYPE *</i><br>
<b class="fname">SPLAY_REMOVE</b>(<i class="farg" style="white-space:nowrap;">NAME</i>, <i class="farg" style="white-space:nowrap;">SPLAY_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">struct TYPE *elm</i>);<p>
<br>
<b class="fname">RB_PROTOTYPE</b>(<i class="farg" style="white-space:nowrap;">NAME</i>, <i class="farg" style="white-space:nowrap;">TYPE</i>, <i class="farg" style="white-space:nowrap;">FIELD</i>, <i class="farg" style="white-space:nowrap;">CMP</i>);<p>
<b class="fname">RB_PROTOTYPE_STATIC</b>(<i class="farg" style="white-space:nowrap;">NAME</i>, <i class="farg" style="white-space:nowrap;">TYPE</i>, <i class="farg" style="white-space:nowrap;">FIELD</i>, <i class="farg" style="white-space:nowrap;">CMP</i>);<p>
<b class="fname">RB_GENERATE</b>(<i class="farg" style="white-space:nowrap;">NAME</i>, <i class="farg" style="white-space:nowrap;">TYPE</i>, <i class="farg" style="white-space:nowrap;">FIELD</i>, <i class="farg" style="white-space:nowrap;">CMP</i>);<p>
<b class="fname">RB_GENERATE_STATIC</b>(<i class="farg" style="white-space:nowrap;">NAME</i>, <i class="farg" style="white-space:nowrap;">TYPE</i>, <i class="farg" style="white-space:nowrap;">FIELD</i>, <i class="farg" style="white-space:nowrap;">CMP</i>);<p>
<b class="fname">RB_ENTRY</b>(<i class="farg" style="white-space:nowrap;">TYPE</i>);<p>
<b class="fname">RB_HEAD</b>(<i class="farg" style="white-space:nowrap;">HEADNAME</i>, <i class="farg" style="white-space:nowrap;">TYPE</i>);<p>
<b class="fname">RB_INITIALIZER</b>(<i class="farg" style="white-space:nowrap;">RB_HEAD *head</i>);<p>
<i class="ftype">struct TYPE *</i><br>
<b class="fname">RB_ROOT</b>(<i class="farg" style="white-space:nowrap;">RB_HEAD *head</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">RB_EMPTY</b>(<i class="farg" style="white-space:nowrap;">RB_HEAD *head</i>);<p>
<i class="ftype">struct TYPE *</i><br>
<b class="fname">RB_NEXT</b>(<i class="farg" style="white-space:nowrap;">NAME</i>, <i class="farg" style="white-space:nowrap;">RB_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">struct TYPE *elm</i>);<p>
<i class="ftype">struct TYPE *</i><br>
<b class="fname">RB_PREV</b>(<i class="farg" style="white-space:nowrap;">NAME</i>, <i class="farg" style="white-space:nowrap;">RB_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">struct TYPE *elm</i>);<p>
<i class="ftype">struct TYPE *</i><br>
<b class="fname">RB_MIN</b>(<i class="farg" style="white-space:nowrap;">NAME</i>, <i class="farg" style="white-space:nowrap;">RB_HEAD *head</i>);<p>
<i class="ftype">struct TYPE *</i><br>
<b class="fname">RB_MAX</b>(<i class="farg" style="white-space:nowrap;">NAME</i>, <i class="farg" style="white-space:nowrap;">RB_HEAD *head</i>);<p>
<i class="ftype">struct TYPE *</i><br>
<b class="fname">RB_FIND</b>(<i class="farg" style="white-space:nowrap;">NAME</i>, <i class="farg" style="white-space:nowrap;">RB_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">struct TYPE *elm</i>);<p>
<i class="ftype">struct TYPE *</i><br>
<b class="fname">RB_NFIND</b>(<i class="farg" style="white-space:nowrap;">NAME</i>, <i class="farg" style="white-space:nowrap;">RB_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">struct TYPE *elm</i>);<p>
<i class="ftype">struct TYPE *</i><br>
<b class="fname">RB_LEFT</b>(<i class="farg" style="white-space:nowrap;">struct TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">RB_ENTRY NAME</i>);<p>
<i class="ftype">struct TYPE *</i><br>
<b class="fname">RB_RIGHT</b>(<i class="farg" style="white-space:nowrap;">struct TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">RB_ENTRY NAME</i>);<p>
<i class="ftype">struct TYPE *</i><br>
<b class="fname">RB_PARENT</b>(<i class="farg" style="white-space:nowrap;">struct TYPE *elm</i>, <i class="farg" style="white-space:nowrap;">RB_ENTRY NAME</i>);<p>
<b class="fname">RB_FOREACH</b>(<i class="farg" style="white-space:nowrap;">VARNAME</i>, <i class="farg" style="white-space:nowrap;">NAME</i>, <i class="farg" style="white-space:nowrap;">RB_HEAD *head</i>);<p>
<b class="fname">RB_FOREACH_SAFE</b>(<i class="farg" style="white-space:nowrap;">VARNAME</i>, <i class="farg" style="white-space:nowrap;">NAME</i>, <i class="farg" style="white-space:nowrap;">RB_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">TEMP_VARNAME</i>);<p>
<b class="fname">RB_FOREACH_REVERSE</b>(<i class="farg" style="white-space:nowrap;">VARNAME</i>, <i class="farg" style="white-space:nowrap;">NAME</i>, <i class="farg" style="white-space:nowrap;">RB_HEAD *head</i>);<p>
<b class="fname">RB_FOREACH_REVERSE_SAFE</b>(<i class="farg" style="white-space:nowrap;">VARNAME</i>, <i class="farg" style="white-space:nowrap;">NAME</i>, <i class="farg" style="white-space:nowrap;">RB_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">TEMP_VARNAME</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">RB_INIT</b>(<i class="farg" style="white-space:nowrap;">RB_HEAD *head</i>);<p>
<i class="ftype">struct TYPE *</i><br>
<b class="fname">RB_INSERT</b>(<i class="farg" style="white-space:nowrap;">NAME</i>, <i class="farg" style="white-space:nowrap;">RB_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">struct TYPE *elm</i>);<p>
<i class="ftype">struct TYPE *</i><br>
<b class="fname">RB_REMOVE</b>(<i class="farg" style="white-space:nowrap;">NAME</i>, <i class="farg" style="white-space:nowrap;">RB_HEAD *head</i>, <i class="farg" style="white-space:nowrap;">struct TYPE *elm</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1><div class="symb" style="display:inline;margin-left: 1.00ex;">
This is a legacy interface; for new code, <a class="link-man" href="../3/rbtree">rbtree(3)</a> is preferred.</div>
<p>
These macros define data structures for different types of trees: splay trees and red-black trees.<p>
In the macro definitions, <i class="farg">TYPE</i> is the name tag of a user defined structure that must contain a field named <i class="farg">FIELD</i>, of type <code class="lit">SPLAY_ENTRY</code> or <code class="lit">RB_ENTRY</code>. The argument <i class="farg">HEADNAME</i> is the name tag of a user defined structure that must be declared using the macros <b class="fname">SPLAY_HEAD</b>() or <b class="fname">RB_HEAD</b>(). The argument <i class="farg">NAME</i> has to be a unique name prefix for every tree that is defined.<p>
The function prototypes are declared with <code class="lit">SPLAY_PROTOTYPE</code>, <code class="lit">RB_PROTOTYPE</code>, or <code class="lit">RB_PROTOTYPE_STATIC</code>. The function bodies are generated with <code class="lit">SPLAY_GENERATE</code>, <code class="lit">RB_GENERATE</code>, or <code class="lit">RB_GENERATE_STATIC</code>. See the examples below for further explanation of how these macros are used.</div>
<div class="section">
<h1 id="x53504c4159205452454553">SPLAY TREES</h1> A splay tree is a self-organizing data structure. Every operation on the tree causes a splay to happen. The splay moves the requested node to the root of the tree and partly rebalances it.<p>
This has the benefit that request locality causes faster lookups as the requested nodes move to the top of the tree. On the other hand, every lookup causes memory writes.<p>
The Balance Theorem bounds the total access time for m operations and n inserts on an initially empty tree as O((m + n)lg n). The amortized cost for a sequence of m accesses to a splay tree is O(lg n).<p>
A splay tree is headed by a structure defined by the <b class="fname">SPLAY_HEAD</b>() macro. A <i class="farg">SPLAY_HEAD</i> structure is declared as follows:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
SPLAY_HEAD(HEADNAME, TYPE) head;</pre>
<p>
where <i class="farg">HEADNAME</i> is the name of the structure to be defined, and struct <i class="farg">TYPE</i> is the type of the elements to be inserted into the tree.<p>
The <b class="fname">SPLAY_ENTRY</b>() macro declares a structure that allows elements to be connected in the tree.<p>
In order to use the functions that manipulate the tree structure, their prototypes need to be declared with the <b class="fname">SPLAY_PROTOTYPE</b>() macro, where <i class="farg">NAME</i> is a unique identifier for this particular tree. The <i class="farg">TYPE</i> argument is the type of the structure that is being managed by the tree. The <i class="farg">FIELD</i> argument is the name of the element defined by <b class="fname">SPLAY_ENTRY</b>().<p>
The function bodies are generated with the <b class="fname">SPLAY_GENERATE</b>() macro. It takes the same arguments as the <b class="fname">SPLAY_PROTOTYPE</b>() macro, but should be used only once.<p>
Finally, the <i class="farg">CMP</i> argument is the name of a function used to compare tree nodes with each other. The function takes two arguments of type <i class="farg">struct TYPE *</i>. If the first argument is smaller than the second, the function returns a value smaller than zero. If they are equal, the function returns zero. Otherwise, it should return a value greater than zero. The compare function defines the order of the tree elements.<p>
The <b class="fname">SPLAY_INIT</b>() macro initializes the tree referenced by <i class="farg">head</i>.<p>
The splay tree can also be initialized statically by using the <b class="fname">SPLAY_INITIALIZER</b>() macro like this:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
SPLAY_HEAD(HEADNAME, TYPE) head = SPLAY_INITIALIZER(&amp;head);</pre>
<p>
The <b class="fname">SPLAY_INSERT</b>() macro inserts the new element <i class="farg">elm</i> into the tree. Upon success, <span class="define">NULL</span> is returned. If a matching element already exists in the tree, the insertion is aborted, and a pointer to the existing element is returned.<p>
The <b class="fname">SPLAY_REMOVE</b>() macro removes the element <i class="farg">elm</i> from the tree pointed by <i class="farg">head</i>. Upon success, a pointer to the removed element is returned. <span class="define">NULL</span> is returned if <i class="farg">elm</i> is not present in the tree.<p>
The <b class="fname">SPLAY_FIND</b>() macro can be used to find a particular element in the tree.<p>
<pre style="margin-left: 5.00ex;" class="lit display">
struct TYPE find, *res; 
find.key = 30; 
res = SPLAY_FIND(NAME, &amp;head, &amp;find);</pre>
<p>
The <b class="fname">SPLAY_ROOT</b>(), <b class="fname">SPLAY_MIN</b>(), <b class="fname">SPLAY_MAX</b>(), and <b class="fname">SPLAY_NEXT</b>() macros can be used to traverse the tree:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
for (np = SPLAY_MIN(NAME, &amp;head); np != NULL; np = SPLAY_NEXT(NAME, &amp;head, np))</pre>
<p>
Or, for simplicity, one can use the <b class="fname">SPLAY_FOREACH</b>() macro:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
SPLAY_FOREACH(np, NAME, &amp;head)</pre>
<p>
The <b class="fname">SPLAY_EMPTY</b>() macro should be used to check whether a splay tree is empty.</div>
<div class="section">
<h1 id="x5245441e424c41434b205452454553">RED-BLACK TREES</h1> A red-black tree is a binary search tree with the node color as an extra attribute. It fulfills a set of conditions:<p>
<ol style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-enum">
<li class="list-enum" style="margin-top: 0.00em;">
every search path from the root to a leaf consists of the same number of black nodes,</li>
<li class="list-enum" style="margin-top: 0.00em;">
each red node (except for the root) has a black parent,</li>
<li class="list-enum" style="margin-top: 0.00em;">
each leaf node is black.</li>
</ol>
<p>
Every operation on a red-black tree is bounded as O(lg n). The maximum height of a red-black tree is 2lg (n+1).<p>
A red-black tree is headed by a structure defined by the <b class="fname">RB_HEAD</b>() macro. A <i class="farg">RB_HEAD</i> structure is declared as follows:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
RB_HEAD(HEADNAME, TYPE) head;</pre>
<p>
where <i class="farg">HEADNAME</i> is the name of the structure to be defined, and struct <i class="farg">TYPE</i> is the type of the elements to be inserted into the tree.<p>
The <b class="fname">RB_ENTRY</b>() macro declares a structure that allows elements to be connected in the tree.<p>
In order to use the functions that manipulate the tree structure, their prototypes need to be declared with the <b class="fname">RB_PROTOTYPE</b>() or <b class="fname">RB_PROTOTYPE_STATIC</b>() macros, where <i class="farg">NAME</i> is a unique identifier for this particular tree. The <i class="farg">TYPE</i> argument is the type of the structure that is being managed by the tree. The <i class="farg">FIELD</i> argument is the name of the element defined by <b class="fname">RB_ENTRY</b>().<p>
The function bodies are generated with the <b class="fname">RB_GENERATE</b>() or <b class="fname">RB_GENERATE_STATIC</b>() macros. These macros take the same arguments as the <b class="fname">RB_PROTOTYPE</b>() and <b class="fname">RB_PROTOTYPE_STATIC</b>() macros, but should be used only once.<p>
Finally, the <i class="farg">CMP</i> argument is the name of a function used to compare trees' nodes with each other. The function takes two arguments of type <i class="farg">struct TYPE *</i>. If the first argument is smaller than the second, the function returns a value smaller than zero. If they are equal, the function returns zero. Otherwise, it should return a value greater than zero. The compare function defines the order of the tree elements.<p>
The <b class="fname">RB_INIT</b>() macro initializes the tree referenced by <i class="farg">head</i>.<p>
The red-black tree can also be initialized statically by using the <b class="fname">RB_INITIALIZER</b>() macro like this:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
RB_HEAD(HEADNAME, TYPE) head = RB_INITIALIZER(&amp;head);</pre>
<p>
The <b class="fname">RB_INSERT</b>() macro inserts the new element <i class="farg">elm</i> into the tree. Upon success, <span class="define">NULL</span> is returned. If a matching element already exists in the tree, the insertion is aborted, and a pointer to the existing element is returned.<p>
The <b class="fname">RB_REMOVE</b>() macro removes the element <i class="farg">elm</i> from the tree pointed to by <i class="farg">head</i>. The element must be present in that tree. <b class="fname">RB_REMOVE</b>() returns <i class="farg">elm</i>.<p>
The <b class="fname">RB_FIND</b>() macro can be used to find a particular element in the tree. and <b class="fname">RB_NFIND</b>() macros can be used to find a particular element in the tree. <b class="fname">RB_FIND</b>() finds the node with the same key as <i class="farg">elm</i>. <b class="fname">RB_NFIND</b>() finds the first node greater than or equal to the search key.<p>
<pre style="margin-left: 5.00ex;" class="lit display">
struct TYPE find, *res; 
find.key = 30; 
res = RB_FIND(NAME, &amp;head, &amp;find);</pre>
<p>
The <b class="fname">RB_ROOT</b>(), <b class="fname">RB_MIN</b>(), <b class="fname">RB_MAX</b>(), <b class="fname">RB_NEXT</b>(), and <b class="fname">RB_PREV</b>() macros can be used to traverse the tree:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
for (np = RB_MIN(NAME, &amp;head); np != NULL; np = RB_NEXT(NAME, &amp;head, np))</pre>
<p>
Or, for simplicity, one can use the <b class="fname">RB_FOREACH</b>() or <b class="fname">RB_FOREACH_REVERSE</b>() macros:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
RB_FOREACH(np, NAME, &amp;head)</pre>
<p>
The macros <b class="fname">RB_FOREACH_SAFE</b>() and <b class="fname">RB_FOREACH_REVERSE_SAFE</b>() traverse the tree referenced by head in a forward or reverse direction respectively, assigning each element in turn to np. However, unlike their unsafe counterparts, they permit both the removal of np as well as freeing it from within the loop safely without interfering with the traversal.<p>
The <b class="fname">RB_EMPTY</b>() macro should be used to check whether a red-black tree is empty.</div>
<div class="section">
<h1 id="x4558414d504c4553">EXAMPLES</h1> The following example demonstrates how to declare a red-black tree holding integers. Values are inserted into it and the contents of the tree are printed in order. Lastly, the internal structure of the tree is printed.<p>
<pre style="margin-left: 3.00ex;" class="lit display">
#include &lt;sys/tree.h&gt; 
#include &lt;err.h&gt; 
#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt; 
 
struct node { 
	RB_ENTRY(node) entry; 
	int i; 
}; 
 
int 
intcmp(struct node *e1, struct node *e2) 
{ 
	return (e1-&gt;i &lt; e2-&gt;i ? -1 : e1-&gt;i &gt; e2-&gt;i); 
} 
 
RB_HEAD(inttree, node) head = RB_INITIALIZER(&amp;head); 
RB_GENERATE(inttree, node, entry, intcmp) 
 
int testdata[] = { 
	20, 16, 17, 13, 3, 6, 1, 8, 2, 4, 10, 19, 5, 9, 12, 15, 18, 
	7, 11, 14 
}; 
 
void 
print_tree(struct node *n) 
{ 
	struct node *left, *right; 
 
	if (n == NULL) { 
		printf("nil"); 
		return; 
	} 
	left = RB_LEFT(n, entry); 
	right = RB_RIGHT(n, entry); 
	if (left == NULL &amp;&amp; right == NULL) 
		printf("%d", n-&gt;i); 
	else { 
		printf("%d(", n-&gt;i); 
		print_tree(left); 
		printf(","); 
		print_tree(right); 
		printf(")"); 
	} 
} 
 
int 
main() 
{ 
	int i; 
	struct node *n; 
 
	for (i = 0; i &lt; sizeof(testdata) / sizeof(testdata[0]); i++) { 
		if ((n = malloc(sizeof(struct node))) == NULL) 
			err(1, NULL); 
		n-&gt;i = testdata[i]; 
		RB_INSERT(inttree, &amp;head, n); 
	} 
 
	RB_FOREACH(n, inttree, &amp;head) { 
		printf("%d&#92;n", n-&gt;i); 
	} 
	print_tree(RB_ROOT(&amp;head)); 
	printf("&#92;n"); 
	return (0); 
}</pre>
</div>
<div class="section">
<h1 id="x4e4f544553">NOTES</h1> Some of these macros or functions perform no error checking, and invalid usage leads to undefined behaviour. In the case of macros or functions that expect their arguments to be elements that are present in the tree, passing an element that is not present in the tree is invalid.<p>
Trying to free a tree in the following way is a common error:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
SPLAY_FOREACH(var, NAME, &amp;head) { 
	SPLAY_REMOVE(NAME, &amp;head, var); 
	free(var); 
} 
free(head);</pre>
<p>
Since <b class="var">var</b> is free'd, the <b class="fname">FOREACH</b>() macro refers to a pointer that may have been reallocated already. Proper code needs a second variable.<p>
<pre style="margin-left: 5.00ex;" class="lit display">
for (var = SPLAY_MIN(NAME, &amp;head); var != NULL; var = nxt) { 
	nxt = SPLAY_NEXT(NAME, &amp;head, var); 
	SPLAY_REMOVE(NAME, &amp;head, var); 
	free(var); 
}</pre>
</div>
<div class="section">
<h1 id="x415554484f5253">AUTHORS</h1> The author of the tree macros is <span class="author">Niels Provos</span>.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
July 9, 2011</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

