<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="/static/man_pages/netbsd/style.css" type="text/css" media="all">
<title>
PCAP_FINDALLDEVS(3)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
PCAP_FINDALLDEVS(3)</td>
<td class="head-vol" align="center">
Library Functions Manual</td>
<td class="head-rtitle" align="right">
PCAP_FINDALLDEVS(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> pcap_findalldevs, pcap_freealldevs &#45; get a list of capture devices, and free that list</div>
<div class="section">
<h1>SYNOPSIS</h1><br>
#include &lt;pcap/pcap.h&gt;<p>
<br>
char errbuf[PCAP_ERRBUF_SIZE];<p>
<br>
int pcap_findalldevs(pcap_if_t **alldevsp, char *errbuf);<br>
void pcap_freealldevs(pcap_if_t *alldevs);<br>
</div>
<div class="section">
<h1>DESCRIPTION</h1> <b>pcap_findalldevs()</b> constructs a list of network devices that can be opened with <b>pcap_create()</b> and <b>pcap_activate()</b> or with <b>pcap_open_live()</b>. (Note that there may be network devices that cannot be opened by the process calling <b>pcap_findalldevs()</b>, because, for example, that process does not have sufficient privileges to open them for capturing; if so, those devices will not appear on the list.) If <b>pcap_findalldevs()</b> succeeds, the pointer pointed to by <i>alldevsp</i> is set to point to the first element of the list, or to <b>NULL</b> if no devices were found (this is considered success). Each element of the list is of type <b>pcap_if_t</b>, and has the following members:<div style="margin-left: 5.00ex;">
<dl>
<dt>
<b>next</b></dt>
<dd>
if not <b>NULL</b>, a pointer to the next element in the list; <b>NULL</b> for the last element of the list</dd>
</dl>
<dl>
<dt>
<b>name</b></dt>
<dd>
a pointer to a string giving a name for the device to pass to <b>pcap_open_live()</b></dd>
</dl>
<dl>
<dt>
<b>description</b></dt>
<dd>
if not <b>NULL</b>, a pointer to a string giving a human-readable description of the device</dd>
</dl>
<dl>
<dt>
<b>addresses</b></dt>
<dd>
a pointer to the first element of a list of network addresses for the device, or <b>NULL</b> if the device has no addresses</dd>
</dl>
<dl>
<dt>
<b>flags</b></dt>
<dd>
device flags:<div style="margin-left: 5.00ex;">
<dl>
<dt>
<b>PCAP_IF_LOOPBACK</b></dt>
<dd>
set if the device is a loopback interface</dd>
</dl>
<dl>
<dt>
<b>PCAP_IF_UP</b></dt>
<dd>
set if the device is up</dd>
</dl>
<dl>
<dt>
<b>PCAP_IF_RUNNING</b></dt>
<dd>
set if the device is running</dd>
</dl>
</div>
</dd>
</dl>
</div>
<p>
Each element of the list of addresses is of type <b>pcap_addr_t</b>, and has the following members:<div style="margin-left: 5.00ex;">
<dl>
<dt>
<b>next</b></dt>
<dd>
if not <b>NULL</b>, a pointer to the next element in the list; <b>NULL</b> for the last element of the list</dd>
</dl>
<dl>
<dt>
<b>addr</b></dt>
<dd>
a pointer to a <b>struct sockaddr</b> containing an address</dd>
</dl>
<dl>
<dt>
<b>netmask</b></dt>
<dd>
if not <b>NULL</b>, a pointer to a <b>struct sockaddr</b> that contains the netmask corresponding to the address pointed to by <b>addr</b></dd>
</dl>
<dl>
<dt>
<b>broadaddr</b></dt>
<dd>
if not <b>NULL</b>, a pointer to a <b>struct sockaddr</b> that contains the broadcast address corresponding to the address pointed to by <b>addr</b>; may be null if the device doesn't support broadcasts</dd>
</dl>
<dl>
<dt>
<b>dstaddr</b></dt>
<dd>
if not <b>NULL</b>, a pointer to a <b>struct sockaddr</b> that contains the destination address corresponding to the address pointed to by <b>addr</b>; may be null if the device isn't a point-to-point interface</dd>
</dl>
</div>
<p>
Note that the addresses in the list of addresses might be IPv4 addresses, IPv6 addresses, or some other type of addresses, so you must check the <b>sa_family</b> member of the <b>struct sockaddr</b> before interpreting the contents of the address; do not assume that the addresses are all IPv4 addresses, or even all IPv4 or IPv6 addresses. IPv4 addresses have the value <b>AF_INET</b>, IPv6 addresses have the value <b>AF_INET6</b> (which older operating systems that don't support IPv6 might not define), and other addresses have other values.  Whether other addresses are returned, and what types they might have is platform-dependent. For IPv4 addresses, the <b>struct sockaddr</b> pointer can be interpreted as if it pointed to a <b>struct sockaddr_in</b>; for IPv6 addresses, it can be interpreted as if it pointed to a <b>struct sockaddr_in6</b>.<p>
The list of devices must be freed with <b>pcap_freealldevs()</b>, which frees the list pointed to by <i>alldevs</i>.</div>
<div class="section">
<h1>RETURN VALUE</h1> <b>pcap_findalldevs()</b> returns 0 on success and &#45;1 on failure; as indicated, finding no devices is considered success, rather than failure, so 0 will be returned in that case. If &#45;1 is returned, <i>errbuf</i> is filled in with an appropriate error message. <i>errbuf</i> is assumed to be able to hold at least <b>PCAP_ERRBUF_SIZE</b> chars.</div>
<div class="section">
<h1>SEE ALSO</h1> pcap(3), pcap_create(3), pcap_activate(3), pcap_open_live(3)</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tr>
<td class="foot-date">
10 January 2014</td>
<td class="foot-os" align="right">
</td>
</tr>
</table>
</div>
</body>
</html>

