<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/../4/strict.dtd">
>
<head>
<meta http-equiv="Content-Type" content="te../; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
SSL_CTX_set_tlsext_ticket_key_cb(3)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
SSL_CTX_set_tlsext_ticket_key_cb(3)</td>
<td class="head-vol" align="center">
OpenSSL</td>
<td class="head-rtitle" align="right">
SSL_CTX_set_tlsext_ticket_key_cb(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> SSL_CTX_set_tlsext_ticket_key_cb &#45; set a callback for session ticket processing</div>
<div class="section">
<h1>LIBRARY</h1> libcrypto, -lcrypto</div>
<div class="section">
<h1>SYNOPSIS</h1><br>
 #include &lt;openssl/tls1.h&gt;<br>
<br>
 long SSL_CTX_set_tlsext_ticket_key_cb(SSL_CTX sslctx,<br>
        int (*cb)(SSL *s, unsigned char key_name[16],<br>
                  unsigned char iv[EVP_MAX_IV_LENGTH],<br>
                  EVP_CIPHER_CTX *ctx, HMAC_CTX *hctx, int enc));<br>
</div>
<div class="section">
<h1>DESCRIPTION</h1>  <i>SSL_CTX_set_tlsext_ticket_key_cb()</i> sets a callback fuction <i>cb</i> for handling session tickets for the ssl context  <i>sslctx</i>. Session tickets, defined in RFC5077 provide an enhanced session resumption capability where the server implementation is not required to maintain per session state. It only applies to TLS and there is no SSLv3 implementation.<p>
The callback is available when the OpenSSL library was built without  <i>OPENSSL_NO_TLSEXT</i> being defined.<p>
The callback function <i>cb</i> will be called for every client instigated TLS session when session ticket extension is presented in the TLS hello message. It is the responsibility of this function to create or retrieve the cryptographic parameters and to maintain their state.<p>
The OpenSSL library uses your callback function to help implement a common TLS  ticket construction state according to RFC5077 Section 4 such that per session state is unnecessary and a small set of cryptographic variables needs to be maintained by the callback function implementation.<p>
In order to reuse a session, a TLS client must send the a session ticket extension to the server. The client can only send exactly one session ticket. The server, through the callback function, either agrees to reuse the session ticket information or it starts a full TLS handshake to create a new session ticket.<p>
Before the callback function is started <i>ctx</i> and <i>hctx</i> have been initialised with EVP_CIPHER_CTX_init and HMAC_CTX_init respectively.<p>
For new sessions tickets, when the client doesn't present a session ticket, or an attempted retreival of the ticket failed, or a renew option was indicated, the callback function will be called with  <i>enc</i> equal to 1. The OpenSSL library expects that the function will set an arbitary  <i>name</i>, initialize  <i>iv</i>, and set the cipher context <i>ctx</i> and the hash context <i>hctx</i>.<p>
The <i>name</i> is 16 characters long and is used as a key identifier.<p>
The <i>iv</i> length is the length of the IV of the corresponding cipher. The maximum IV length is EVP_MAX_IV_LENGTH bytes defined in  <b>evp.h</b>.<p>
The initialization vector <i>iv</i> should be a random value. The cipher context  <i>ctx</i> should use the initialisation vector <i>iv</i>. The cipher context can be set using EVP_EncryptInit_ex. The hmac context can be set using HMAC_Init_ex.<p>
When the client presents a session ticket, the callback function with be called with  <i>enc</i> set to 0 indicating that the <i>cb</i> function should retreive a set of parameters. In this case  <i>name</i> and <i>iv</i> have already been parsed out of the session ticket. The OpenSSL library expects that the  <i>name</i> will be used to retrieve a cryptographic parameters and that the cryptographic context  <i>ctx</i> will be set with the retreived parameters and the initialization vector  <i>iv</i>. using a function like EVP_DecryptInit_ex. The <i>hctx</i> needs to be set using HMAC_Init_ex.<p>
If the <i>name</i> is still valid but a renewal of the ticket is required the callback function should return 2. The library will call the callback again with an arguement of enc equal to 1 to set the new ticket.<p>
The return value of the <i>cb</i> function is used by OpenSSL to determine what further processing will occur. The following return values have meaning:<dl>
<dt>
2</dt>
<dd>
This indicates that the <i>ctx</i> and <i>hctx</i> have been set and the session can continue on those parameters. Additionally it indicates that the session ticket is in a renewal period and should be replaced. The OpenSSL library will call  <i>cb</i> again with an enc argument of 1 to set the new ticket (see RFC5077 3.3 paragraph 2).</dd>
</dl>
<dl>
<dt>
1</dt>
<dd>
This indicates that the <i>ctx</i> and <i>hctx</i> have been set and the session can continue on those parameters.</dd>
</dl>
<dl>
<dt>
0</dt>
<dd>
This indicates that it was not possible to set/retrieve a session ticket and the SSL/TLS session will continue by by negiotationing a set of cryptographic parameters or using the alternate SSL/TLS resumption mechanism, session ids.<div style="height: 1.00em;">
&#160;</div>
If called with enc equal to 0 the library will call the <i>cb</i> again to get a new set of parameters.</dd>
</dl>
<dl>
<dt>
less than 0</dt>
<dd>
This indicates an error.</dd>
</dl>
</div>
<div class="section">
<h1>NOTES</h1> Session resumption shortcuts the TLS so that the client certificate negiotation don't occur. It makes up for this by storing client certificate an all other negotiated state information encrypted within the ticket. In a resumed session the applications will have all this state information available exactly as if a full negiotation had occured.<p>
If an attacker can obtain the key used to encrypt a session ticket, they can obtain the master secret for any ticket using that key and decrypt any traffic using that session: even if the ciphersuite supports forward secrecy. As a result applications may wish to use multiple keys and avoid using long term keys stored in files.<p>
Applications can use longer keys to maintain a consistent level of security. For example if a ciphersuite uses 256 bit ciphers but only a 128 bit ticket key the overall security is only 128 bits because breaking the ticket key will enable an attacker to obtain the session keys.</div>
<div class="section">
<h1>EXAMPLES</h1> Reference Implemention:<br>
  SSL_CTX_set_tlsext_ticket_key_cb(SSL,ssl_tlsext_ticket_key_cb);<br>
  ....<p>
<br>
  static int ssl_tlsext_ticket_key_cb(SSL *s, unsigned char key_name[16], unsigned char *iv, EVP_CIPHER_CTX *ctx, HMAC_CTX *hctx, int enc)<br>
  {<br>
      if (enc) { /* create new session */<br>
          if (RAND_bytes(iv, EVP_MAX_IV_LENGTH) ) {<br>
              return &#45;1; /* insufficient random */<br>
          }<br>
<br>
          key = currentkey(); /* something that you need to implement */<br>
          if ( !key ) {<br>
              /* current key doesn't exist or isn't valid */<br>
              key = createkey(); /* something that you need to implement.<br>
                                   * createkey needs to initialise, a name,<br>
                                   * an aes_key, a hmac_key and optionally<br>
                                   * an expire time. */<br>
              if ( !key ) { /* key couldn't be created */<br>
                  return 0;<br>
              }<br>
          }<br>
          memcpy(key_name, key&#45;&gt;name, 16);<br>
<br>
          EVP_EncryptInit_ex(&amp;ctx, EVP_aes_128_cbc(), NULL, key&#45;&gt;aes_key, iv);<br>
          HMAC_Init_ex(&amp;hctx, key&#45;&gt;hmac_key, 16, EVP_sha256(), NULL);<br>
<br>
          return 1;<br>
<br>
      } else { /* retrieve session */<br>
          key = findkey(name);<br>
<br>
          if  (!key || key&#45;&gt;expire &lt; now() ) {<br>
              return 0;<br>
          }<br>
<br>
          HMAC_Init_ex(&amp;hctx, key&#45;&gt;hmac_key, 16, EVP_sha256(), NULL);<br>
          EVP_DecryptInit_ex(&amp;ctx, EVP_aes_128_cbc(), NULL, key&#45;&gt;aes_key, iv );<br>
<br>
          if (key&#45;&gt;expire &lt; ( now() &#45; RENEW_TIME ) ) {<br>
              /* return 2 &#45; this session will get a new ticket even though the current is still valid */<br>
              return 2;<br>
          }<br>
          return 1;<br>
<br>
      }<br>
  }<br>
</div>
<div class="section">
<h1>RETURN VALUES</h1> returns 0 to indicate the callback function was set.</div>
<div class="section">
<h1>SEE ALSO</h1>  <i>ssl</i>(3), <i>SSL_set_session</i>(3),  <i>SSL_session_reused</i>(3),  <i>SSL_CTX_add_session</i>(3),  <i>SSL_CTX_sess_number</i>(3),  <i>SSL_CTX_sess_set_get_cb</i>(3),  <i>SSL_CTX_set_session_id_context</i>(3),</div>
<div class="section">
<h1>HISTORY</h1> This function was introduced in OpenSSL 0.9.8h</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tr>
<td class="foot-date">
2014-08-10</td>
<td class="foot-os" align="right">
1.0.1n</td>
</tr>
</table>
</div>
</body>
<>

