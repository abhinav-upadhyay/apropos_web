<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="/static/man_pages/netbsd/style.css" type="text/css" media="all">
<title>
GETOPT_LONG(3)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
GETOPT_LONG(3)</td>
<td class="head-vol" align="center">
Library Functions Manual</td>
<td class="head-rtitle" align="right">
GETOPT_LONG(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">getopt_long</b> &#8212; <span class="desc">get long options from command line argument list</span></div>
<div class="section">
<h1 id="x4c494252415259">LIBRARY</h1> <span class="lib">Standard C Library (libc, &#45;lc)</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">getopt.h</a>&gt;</b><p>
<i class="ftype">int</i><br>
<b class="fname">getopt_long</b>(<i class="farg" style="white-space:nowrap;">int argc</i>, <i class="farg" style="white-space:nowrap;">char * const *argv</i>, <i class="farg" style="white-space:nowrap;">const char *optstring</i>, <i class="farg" style="white-space:nowrap;">struct option *long_options</i>, <i class="farg" style="white-space:nowrap;">int *index</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <b class="fname">getopt_long</b>() function is similar to <a class="link-man" href="../3/getopt">getopt(3)</a> but it accepts options in two forms: words and characters. The <b class="fname">getopt_long</b>() function provides a superset of the functionality of <a class="link-man" href="../3/getopt">getopt(3)</a>. <b class="fname">getopt_long</b>() can be used in two ways. In the first way, every long option understood by the program has a corresponding short option, and the option structure is only used to translate from long options to short options. When used in this fashion, <b class="fname">getopt_long</b>() behaves identically to <a class="link-man" href="../3/getopt">getopt(3)</a>. This is a good way to add long option processing to an existing program with the minimum of rewriting.<p>
In the second mechanism, a long option sets a flag in the <i class="farg">option</i> structure passed, or will store a pointer to the command line argument in the <i class="farg">option</i> structure passed to it for options that take arguments. Additionally, the long option's argument may be specified as a single argument with an equal sign, e.g.<p>
<pre style="margin-left: 0.00ex;" class="lit display">
myprogram --myoption=somevalue</pre>
<p>
When a long option is processed the call to <b class="fname">getopt_long</b>() will return 0. For this reason, long option processing without shortcuts is not backwards compatible with <a class="link-man" href="../3/getopt">getopt(3)</a>.<p>
It is possible to combine these methods, providing for long options processing with short option equivalents for some options. Less frequently used options would be processed as long options only.<p>
Abbreviated long option names are accepted when <b class="fname">getopt_long</b>() processes long options if the abbreviation is unique. An exact match is always preferred for a defined long option.<p>
The <b class="fname">getopt_long</b>() call requires a structure to be initialized describing the long options. The structure is:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
struct option { 
	char *name; 
	int has_arg; 
	int *flag; 
	int val; 
};</pre>
<p>
The <i class="farg">name</i> field should contain the option name without the leading double dash.<p>
The <i class="farg">has_arg</i> field should be one of:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">no_argument</code></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
no argument to the option is expect.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">required_argument</code></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
an argument to the option is required.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">optional_argument</code></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
an argument to the option may be presented.</dd>
</dl>
<p>
If <i class="farg">flag</i> is not <span class="define">NULL</span>, then the integer pointed to by it will be set to the value in the <i class="farg">val</i> field. If the <i class="farg">flag</i> field is <span class="define">NULL</span>, then the <i class="farg">val</i> field will be returned. Setting <i class="farg">flag</i> to <span class="define">NULL</span> and setting <i class="farg">val</i> to the corresponding short option will make this function act just like <a class="link-man" href="../3/getopt">getopt(3)</a>.<p>
If the <i class="farg">index</i> field is not <span class="define">NULL</span>, the integer it points to will be set to the index of the long option in the <i class="farg">long_options</i> array.<p>
The last element of the <i class="farg">long_options</i> array has to be filled with zeroes (see <i class="link-sec"><a class="link-sec" href="#x4558414d504c4553">EXAMPLES</a></i> section).</div>
<div class="section">
<h1 id="x4558414d504c4553">EXAMPLES</h1><pre style="margin-left: 0.00ex;" class="lit display">
extern char *optarg; 
extern int optind; 
int bflag, ch, fd; 
int daggerset; 
 
/* options descriptor */ 
static struct option longopts[] = { 
	{ "buffy",	no_argument,		0, 		'b' }, 
	{ "fluoride",	required_argument,	0, 	       	'f' }, 
	{ "daggerset",	no_argument,		&amp;daggerset,	1 }, 
	{ NULL,		0,			NULL, 		0 } 
}; 
 
bflag = 0; 
while ((ch = getopt_long(argc, argv, "bf:", longopts, NULL)) != -1) 
	switch (ch) { 
	case 'b': 
		bflag = 1; 
		break; 
	case 'f': 
		if ((fd = open(optarg, O_RDONLY, 0)) &lt; 0) { 
			(void)fprintf(stderr, 
			    "myname: %s: %s&#92;n", optarg, strerror(errno)); 
			exit(1); 
		} 
		break; 
	case 0: 
		if(daggerset) { 
			fprintf(stderr,"Buffy will use her dagger to " 
				       "apply fluoride to dracula's teeth&#92;n"); 
		} 
		break; 
	case '?': 
	default: 
		usage(); 
} 
argc -= optind; 
argv += optind;</pre>
</div>
<div class="section">
<h1 id="x494d504c454d454e544154494f4e20444946464552454e434553">IMPLEMENTATION DIFFERENCES</h1> This section describes differences to the GNU implementation found in glibc-2.1.3:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">o</code></dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
handling of - as first char of option string in presence of environment variable POSIXLY_CORRECT:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">GNU</code></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
ignores POSIXLY_CORRECT and returns non-options as arguments to option '&#92;1'.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">NetBSD</code></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
honors POSIXLY_CORRECT and stops at the first non-option.</dd>
</dl>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">o</code></dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
handling of :: in options string in presence of POSIXLY_CORRECT:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">Both</code></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
GNU and NetBSD ignore POSIXLY_CORRECT here and take :: to mean the preceding option takes an optional argument.</dd>
</dl>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">o</code></dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
return value in case of missing argument if first character (after + or -) in option string is not ':':<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">GNU</code></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
returns '?'</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
NetBSD</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
returns ':' (since NetBSD's getopt does).</dd>
</dl>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">o</code></dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
handling of --a in getopt:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">GNU</code></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
parses this as option '-', option 'a'.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">NetBSD</code></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
parses this as '--', and returns &#45;1 (ignoring the a). (Because the original getopt does.)</dd>
</dl>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">o</code></dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
setting of optopt for long options with flag != <span class="define">NULL</span>:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">GNU</code></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
sets optopt to val.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">NetBSD</code></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
sets optopt to 0 (since val would never be returned).</dd>
</dl>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">o</code></dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
handling of -W with W; in option string in getopt (not getopt_long):<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">GNU</code></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
causes a segfault.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">NetBSD</code></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
returns &#45;1, with optind pointing past the argument of -W (as if `-W arg' were `--arg', and thus '--' had been found).</dd>
</dl>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">o</code></dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
setting of optarg for long options without an argument that are invoked via -W (W; in option string):<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">GNU</code></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
sets optarg to the option name (the argument of -W).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">NetBSD</code></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
sets optarg to <span class="define">NULL</span> (the argument of the long option).</dd>
</dl>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">o</code></dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
handling of -W with an argument that is not (a prefix to) a known long option (W; in option string):<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">GNU</code></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
returns -W with optarg set to the unknown option.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">NetBSD</code></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
treats this as an error (unknown option) and returns '?' with optopt set to 0 and optarg set to <span class="define">NULL</span> (as GNU's man page documents).</dd>
</dl>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">o</code></dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
The error messages are different.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">o</code></dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
NetBSD does not permute the argument vector at the same points in the calling sequence as GNU does. The aspects normally used by the caller (ordering after &#45;1 is returned, value of optind relative to current positions) are the same, though. (We do fewer variable swaps.)</dd>
</dl>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../3/getopt">getopt(3)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The <b class="fname">getopt_long</b>() function first appeared in GNU libiberty. The first <span class="unix">NetBSD</span> implementation appeared in 1.5.</div>
<div class="section">
<h1 id="x42554753">BUGS</h1> The implementation can completely replace <a class="link-man" href="../3/getopt">getopt(3)</a>, but right now we are using separate code.<p>
The <i class="farg">argv</i> argument is not really const.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
July 2, 2007</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

