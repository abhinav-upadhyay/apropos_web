<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
PUFFS(3)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
PUFFS(3)</td>
<td class="head-vol" align="center">
Library Functions Manual</td>
<td class="head-rtitle" align="right">
PUFFS(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">puffs</b> &#8212; <span class="desc">Pass-to-Userspace Framework File System development interface</span></div>
<div class="section">
<h1 id="x4c494252415259">LIBRARY</h1> <span class="lib">puffs Convenience Library (libpuffs, &#45;lpuffs)</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">puffs.h</a>&gt;</b><p>
<i class="ftype">struct puffs_usermount *</i><br>
<b class="fname">puffs_init</b>(<i class="farg">struct puffs_ops *pops</i>, <i class="farg">const char *mntfromname</i>, <i class="farg">const char *puffsname</i>, <i class="farg">void *private</i>, <i class="farg">uint32_t flags</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_mount</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">const char *dir</i>, <i class="farg">int mntflags</i>, <i class="farg">puffs_cookie_t root_cookie</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_getselectable</b>(<i class="farg" style="white-space:nowrap;">struct puffs_usermount *pu</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_setblockingmode</b>(<i class="farg" style="white-space:nowrap;">struct puffs_usermount *pu</i>, <i class="farg" style="white-space:nowrap;">int mode</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_getstate</b>(<i class="farg" style="white-space:nowrap;">struct puffs_usermount *pu</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_setstacksize</b>(<i class="farg" style="white-space:nowrap;">struct puffs_usermount *pu</i>, <i class="farg" style="white-space:nowrap;">size_t stacksize</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">puffs_setroot</b>(<i class="farg" style="white-space:nowrap;">struct puffs_usermount *pu</i>, <i class="farg" style="white-space:nowrap;">struct puffs_node *node</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">puffs_setrootinfo</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">enum vtype vt</i>, <i class="farg">vsize_t vsize</i>, <i class="farg">dev_t rdev</i>);<p>
<i class="ftype">struct puffs_node *</i><br>
<b class="fname">puffs_getroot</b>(<i class="farg" style="white-space:nowrap;">struct puffs_usermount *pu</i>);<p>
<i class="ftype">void *</i><br>
<b class="fname">puffs_getspecific</b>(<i class="farg" style="white-space:nowrap;">struct puffs_usermount *pu</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">puffs_setspecific</b>(<i class="farg" style="white-space:nowrap;">struct puffs_usermount *pu</i>, <i class="farg" style="white-space:nowrap;">void *private</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">puffs_setmaxreqlen</b>(<i class="farg" style="white-space:nowrap;">struct puffs_usermount *pu</i>, <i class="farg" style="white-space:nowrap;">size_t maxreqlen</i>);<p>
<i class="ftype">size_t</i><br>
<b class="fname">puffs_getmaxreqlen</b>(<i class="farg" style="white-space:nowrap;">struct puffs_usermount *pu</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">puffs_setfhsize</b>(<i class="farg" style="white-space:nowrap;">struct puffs_usermount *pu</i>, <i class="farg" style="white-space:nowrap;">size_t fhsize</i>, <i class="farg" style="white-space:nowrap;">int flags</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">puffs_setncookiehash</b>(<i class="farg" style="white-space:nowrap;">struct puffs_usermount *pu</i>, <i class="farg" style="white-space:nowrap;">int nhashes</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">puffs_ml_loop_fn</b>(<i class="farg" style="white-space:nowrap;">struct puffs_usermount *pu</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">puffs_ml_setloopfn</b>(<i class="farg" style="white-space:nowrap;">struct puffs_usermount *pu</i>, <i class="farg" style="white-space:nowrap;">puffs_ml_loop_fn lfn</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">puffs_ml_settimeout</b>(<i class="farg" style="white-space:nowrap;">struct puffs_usermount *pu</i>, <i class="farg" style="white-space:nowrap;">struct timespec *ts</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_daemon</b>(<i class="farg" style="white-space:nowrap;">struct puffs_usermount *pu</i>, <i class="farg" style="white-space:nowrap;">int nochdir</i>, <i class="farg" style="white-space:nowrap;">int noclose</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_mainloop</b>(<i class="farg" style="white-space:nowrap;">struct puffs_usermount *pu</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_unmountonsignal</b>(<i class="farg" style="white-space:nowrap;">int sig</i>, <i class="farg" style="white-space:nowrap;">bool ignoresig</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_dispatch_create</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">struct puffs_framebuf *pb</i>, <i class="farg">struct puffs_cc **pccp</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_dispatch_exec</b>(<i class="farg" style="white-space:nowrap;">struct puffs_cc *pcc</i>, <i class="farg" style="white-space:nowrap;">struct puffs_framebuf **pbp</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> <b class="name">puffs</b> provides a framework for creating file systems as userspace servers. Operations are transported from the kernel virtual file system layer to the concrete implementation behind <b class="name">puffs</b>, where they are processed and results are sent back to the kernel.<p>
It is possible to use <b class="name">puffs</b> in two different ways. Calling <b class="fname">puffs_mainloop</b>() takes execution context away from the caller and automatically handles all requests by using the callbacks. By using <a class="link-man" href="../html3/puffs_framebuf.html">puffs_framebuf(3)</a> in conjuction with <b class="fname">puffs_mainloop</b>(), it is possible to handle I/O to and from file descriptors. This is suited e.g. for distributed file servers.<div class="subsection">
<h2 id="x4c696272617279206f7065726174696f6e">Library operation</h2> Operations on the library always require a pointer to the opaque context identifier, <b class="var">struct puffs_usermount</b>. It is obtained by calling <b class="fname">puffs_init</b>().<p>
<b class="name">puffs</b> operates using operation callbacks. They can be initialized using the macro <b class="fname">PUFFSOP_SET</b>(<i class="farg">pops</i>, <i class="farg">fsname</i>, <i class="farg">type</i>, <i class="farg">opname</i>), which will initialize the operation <b class="fname">puffs_type_opname</b>() in <i class="farg">pops</i> to <b class="fname">fsname_type_opname</b>(). All operations are initialized to a default state with the call <b class="fname">PUFFSOP_INIT</b>(<i class="farg">pops</i>). All of the VFS routines are mandatory, but all of the node operations with the exception of <b class="fname">puffs_node_lookup</b>() are optional. However, leaving operations blank will naturally have an effect on the features available from the file system implementation.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_init</b>(<i class="farg">pops</i>, <i class="farg">mntfromname</i>, <i class="farg">puffsname</i>, <i class="farg">private</i>, <i class="farg">flags</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Initializes the library context. <i class="arg">pops</i> specifies the callback operations vector. <i class="arg">mntfromname</i> is device the file system is mounted from. This can be for example a block device such as <i class="file">/dev/wd0a</i> or, if the file system is pseudo file system, the <b class="name">puffs</b> device name can be given by <span class="define">_PATH_PUFFS</span>. This value is used for example in the first column of the output of <a class="link-man" href="../html8/mount.html">mount(8)</a> and <a class="link-man" href="../html1/df.html">df(1)</a>. <i class="arg">puffsname</i> is the file system type. It will always be prepended with the string "puffs|". If possible, file server binaries should be named using the format "mount_myfsnamehere" and this value should equal "myfsnamehere". A file system specific context pointer can optionally be given in <i class="arg">private</i>. This can be retrieved by <b class="fname">puffs_getspecific</b>(). Flags for <b class="name">puffs</b> can be given via <i class="farg">pflags</i>. Currently the following flags are supported:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">PUFFS_KFLAG_NOCACHE_NAME</span></dt>
<dd class="list-tag" style="margin-left: 29.00ex;">
Do not enter pathname components into the name cache. This means that every time the kernel does a lookup for a componentname, the file server will be consulted.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">PUFFS_KFLAG_NOCACHE_PAGE</span></dt>
<dd class="list-tag" style="margin-left: 29.00ex;">
Do not use the page cache. This means that all reads and writes to regular file are propagated to the file server for handling. This option makes a difference only for regular files.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">PUFFS_KFLAG_NOCACHE</span></dt>
<dd class="list-tag" style="margin-left: 29.00ex;">
An alias for both <span class="define">PUFFS_KFLAG_NOCACHE_NAME</span> and <span class="define">PUFFS_KFLAG_NOCACHE_PAGE</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">PUFFS_KFLAG_ALLOPS</span></dt>
<dd class="list-tag" style="margin-left: 29.00ex;">
This flag requests that all operations are sent to userspace. Normally the kernel shortcircuits unimplemented operations. This flag is mostly useful for debugging purposes.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">PUFFS_KFLAG_WTCACHE</span></dt>
<dd class="list-tag" style="margin-left: 29.00ex;">
Set the file system cache behavior as write-through. This means that all writes are immediately issued to the file server instead of being flushed in file system sync. This is useful especially for distributed file systems.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">PUFFS_KFLAG_IAONDEMAND</span></dt>
<dd class="list-tag" style="margin-left: 29.00ex;">
Issue inactive only on demand. If a file server defines the inactive method, call it only if the file server has explicitly requested that inactive be called for the node in question. Once inactive has been called for a node, it will not be called again unless the request to call inactive is reissued by the file server. See <b class="fname">puffs_setback</b>() in <a class="link-man" href="../html3/puffs_ops.html">puffs_ops(3)</a> for more information.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">PUFFS_KFLAG_LOOKUP_FULLPNBUF</span></dt>
<dd class="list-tag" style="margin-left: 29.00ex;">
This flag affects only the parameter <i class="arg">pcn to</i> <b class="fname">puffs_node_lookup</b>(). If this flag is not given, only the next pathname component under lookup is found from <i class="arg">pcn-&gt;pcn_name</i>. If this flag is given, the full path the kernel was asked to resolve can be found from there.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">PUFFS_FLAG_BUILDPATH</span></dt>
<dd class="list-tag" style="margin-left: 29.00ex;">
The framework will build a complete path name, which is supplied with each operation and can be found from the <b class="var">pcn_po_full.po_path</b> field in a <span class="type">struct puffs_cn</span>. The option assumes that the framework can map a cookie to a <span class="type">struct puffs_node</span>. See <i class="link-sec"><a class="link-sec" href="#x436f6f6b696573">Cookies</a></i> for more information on cookie mapping. See <a class="link-man" href="../html3/puffs_path.html">puffs_path(3)</a> for more information on library calls involving paths.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">PUFFS_FLAG_HASHPATH</span></dt>
<dd class="list-tag" style="margin-left: 29.00ex;">
Calculate a hash of the path into the path object field <b class="var">po_hash</b>. This hash value is used by <b class="fname">puffs_path_walkcmp</b>() to avoid doing a full comparison for every path equal in length to the one searched for. Especially if the file system uses the abovementioned function, it is a good idea to define this flag.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">PUFFS_FLAG_PNCOOKIE</span></dt>
<dd class="list-tag" style="margin-left: 29.00ex;">
Tell puffs that cookies map to <span class="type">struct pnode</span>. This is automagically set if <b class="fname">puffs_pn_new</b>() is called.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">PUFFS_KFLAG_CACHE_FS_TTL</span></dt>
<dd class="list-tag" style="margin-left: 29.00ex;">
Enforce name and attribute caches based on file system-supplied TTL. In lookup, create, mknod, mkdir, and symlink, the file system must update the node attributes, their TTL, and the node name TTL through <b class="fname">puffs_newinfo_setva</b>(), <b class="fname">puffs_newinfo_setvattl</b>(), and <b class="fname">puffs_newinfo_setcnttl</b>().<p>
Additionally, <b class="fname">puffs_node_getattr_ttl</b>() and <b class="fname">puffs_node_setattr_ttl</b>() will be called instead of <b class="fname">puffs_node_getattr</b>() and <b class="fname">puffs_node_setattr</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">PUFFS_KFLAG_CACHE_DOTDOT</span></dt>
<dd class="list-tag" style="margin-left: 29.00ex;">
Never send lookups for &#8220;..&#8221; to the file system. Parent vnodes are all kept active until their children are reclaimed.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">PUFFS_KFLAG_NOFLUSH_META</span></dt>
<dd class="list-tag" style="margin-left: 29.00ex;">
Do not send metadata cache flushes for time and size to the file system, which should take care of updating the values on its own.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">PUFFS_FLAG_OPDUMP</span></dt>
<dd class="list-tag" style="margin-left: 29.00ex;">
This option makes the framework dump a textual representation of each operation before executing it. It is useful for debugging purposes.</dd>
</dl>
</dd>
</dl>
<p>
The following functions can be used to query or modify the global state of the file system. Note, that all calls are not available at all times.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_getselectable</b>(<i class="farg">pu</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Returns a handle to do I/O multiplexing with: <a class="link-man" href="../html2/select.html">select(2)</a>, <a class="link-man" href="../html2/poll.html">poll(2)</a>, and <a class="link-man" href="../html2/kqueue.html">kqueue(2)</a> are all examples of acceptable operations.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_setblockingmode</b>(<i class="farg">pu</i>, <i class="farg">mode</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Sets the file system upstream access to blocking or non-blocking mode. Acceptable values for the argument are <span class="define">PUFFSDEV_BLOCK</span> and <span class="define">PUFFSDEV_NONBLOCK</span>.<p>
This routine can be called only after calling <b class="fname">puffs_mount</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_getstate</b>(<i class="farg">pu</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Returns the state of the file system. It is maintained by the framework and is mostly useful for the framework itself. Possible values are <span class="define">PUFFS_STATE_BEFOREMOUNT</span>, <span class="define">PUFFS_STATE_RUNNING</span>, <span class="define">PUFFS_STATE_UNMOUNTING</span> and <span class="define">PUFFS_STATE_UNMOUNTED</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_setstacksize</b>(<i class="farg">pu</i>, <i class="farg">stacksize</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Sets the stack size used when running callbacks. The default is <span class="define">PUFFS_STACKSIZE_DEFAULT</span> bytes of stack space per request. The minimum stacksize is architecture-dependent and can be specified by using the opaque constant <span class="define">PUFFS_STACKSIZE_MIN</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_setroot</b>(<i class="farg">pu</i>, <i class="farg">node</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Sets the root node of mount <i class="farg">pu</i> to <i class="farg">node</i>. Setting the root node is currently required only if the path framework is used, see <a class="link-man" href="../html3/puffs_path.html">puffs_path(3)</a>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_setrootinfo</b>(<i class="farg">pu</i>, <i class="farg">vt</i>, <i class="farg">vsize</i>, <i class="farg">rdev</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The default root node is a directory. In case the file system wants something different, it can call this function and set the type, size and possible device type to whatever it wants. This routine is independent of <b class="fname">puffs_setroot</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_getroot</b>(<i class="farg">pu</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Returns the root node set earlier.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_getspecific</b>(<i class="farg">pu</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Returns the <i class="farg">private</i> argument of <b class="fname">puffs_init</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_setspecific</b>(<i class="farg">pu</i>, <i class="farg">private</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Can be used to set the specific data after the call to <b class="fname">puffs_init</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_setmaxreqlen</b>(<i class="farg">pu</i>, <i class="farg">maxreqlen</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
In case the file system desires a maximum buffer length different from the default, the amount <i class="farg">maxreqlen</i> will be requested from the kernel when the file system is mounted.<p>
It is legal to call this function only between <b class="fname">puffs_init</b>() and <b class="fname">puffs_mount</b>().<p>
<span class="emph">NOTE</span> This does not currently work.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_getmaxreqlen</b>(<i class="farg">pu</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Returns the maximum request length the kernel will need for a single request.<p>
<span class="emph">NOTE</span> This does not currently work.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_setfhsize</b>(<i class="farg">pu</i>, <i class="farg">fhsize</i>, <i class="farg">flags</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Sets the desired file handle size. This must be called if the file system wishes to support NFS exporting file systems of the <b class="fname">fh*</b>() family of function calls.<p>
In case all nodes in the file system produce the same length file handle, it must be supplied as <i class="farg">fhsize</i>. In this case, the file system may ignore the length parameters in the file handle callback routines, as the kernel will always pass the correct length buffer. However, if the file handle size varies according to file, the argument <i class="farg">fhsize</i> defines the maximum size of a file handle for the file system. In this case the file system must take care of the handle lengths by itself in the file handle callbacks, see <a class="link-man" href="../html3/puffs_ops.html">puffs_ops(3)</a> for more information. Also, the flag <span class="define">PUFFS_FHFLAG_DYNAMIC</span> must be provided in the argument <i class="farg">flags</i>.<p>
In case the file system wants to sanity check its file handle lengths for the limits of NFS, it can supply <span class="define">PUFFS_FHFLAG_NFSV2</span> and <span class="define">PUFFS_FHFLAG_NFSV3</span> in the <i class="farg">flags</i> parameter. It is especially important to note that these are not directly the limits specified by the protocols, as the kernel uses some bytes from the buffer space. In case the file handles are too large, mount will return an error.<p>
It is legal to call this function only between <b class="fname">puffs_init</b>() and <b class="fname">puffs_mount</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_setncookiehash</b>(<i class="farg">pu</i>, <i class="farg">ncookiehash</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The parameter <i class="farg">ncookiehash</i> controls the amount of hash buckets the kernel has for reverse lookups from cookie to vnode. Technically the default is enough, but a memory/time tradeoff can be made by increasing this for file systems which know they will have very many active files.<p>
It is legal to call this function only between <b class="fname">puffs_init</b>() and <b class="fname">puffs_mount</b>().</dd>
</dl>
<p>
After the correct setup for the library has been established and the backend has been initialized the file system is made operational by calling <b class="fname">puffs_mount</b>(). After this function returns the file system should start processing requests.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_mount</b>(<i class="farg">pu</i>, <i class="farg">dir</i>, <i class="farg">mntflags</i>, <i class="farg">root_cookie</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
<i class="arg">pu</i> is the library context pointer from <b class="fname">puffs_init</b>(). The argument <i class="farg">dir</i> signifies the mount point and <i class="farg">mntflags</i> is the flagset given to <a class="link-man" href="../html2/mount.html">mount(2)</a>. The value <i class="arg">root_cookie</i> will be used as the cookie for the file system root node.</dd>
</dl>
</div>
<div class="subsection">
<h2 id="x5573696e6720746865206275696c741e696e206576656e746c6f6f70">Using the built-in eventloop</h2><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_ml_loop_fn</b>(<i class="farg">pu</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Loop function signature.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_ml_setloopfn</b>(<i class="farg">pu</i>, <i class="farg">lfn</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Set loop function to <i class="arg">lfn</i>. This function is called once each time the event loop loops. It is not a well-defined interval, but it can be made fairly regular by setting the loop timeout by <b class="fname">puffs_ml_settimeout</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_ml_settimeout</b>(<i class="farg">pu</i>, <i class="farg">ts</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Sets the loop timeout to <i class="arg">ts</i> or disables it if <i class="arg">ts</i> is <span class="define">NULL</span>. This can be used to roughly control how often the loop callback <b class="fname">lfn</b>() is called</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_daemon</b>(<i class="farg">pu</i>, <i class="farg">nochdir</i>, <i class="farg">noclose</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Detach from the console like <b class="fname">daemon</b>(<i class="farg">3</i>). This call synchronizes with <b class="fname">puffs_mount</b>() and the foreground process does not exit before the file system mount call has returned from the kernel. Since this routine internally calls fork, it has to be called <span class="emph">before</span> <b class="fname">puffs_mount</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_mainloop</b>(<i class="farg">pu</i>, <i class="farg">flags</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Handle all requests automatically until the file system is unmounted. It returns 0 if the file system was successfully unmounted or &#45;1 if it was killed in action.<p>
In case <a class="link-man" href="../html3/puffs_framebuf.html">puffs_framebuf(3)</a> has been initialized, I/O from the relevant descriptors is processed automatically by the eventloop.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_unmountonsignal</b>(<i class="farg">signum</i>, <i class="farg">ignoresig</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Cause all file servers within the process to initiate unmount upon receipt of signal <i class="arg">signum</i>. This works only for servers which call <b class="fname">puffs_mainloop</b>() and must be called before any server within the process enters the mainloop. The process signal handler is still called before starting the unmount procedure. The parameter <i class="arg">ignoresig</i> is provided as a convenience and tells if to install a signal handler to ignore <i class="arg">sig</i> so that the process will not e.g. terminate based on the default action before the file system unmount can be initiated.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_dispatch_create</b>(<i class="farg">pu</i>, <i class="farg">pb</i>, <i class="farg">pccp</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_dispatch_exec</b>(<i class="farg">pcc</i>, <i class="farg">pbp</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
In case the use of <b class="fname">puffs_mainloop</b>() is not possible, requests may be dispatched manually. However, as this is less efficient than using the mainloop, it should never be the first preference.<p>
Calling <b class="fname">puffs_dispatch_create</b>() creates a dispatch request. The argument <i class="arg">pb</i> should contains a valid request and upon success <i class="arg">pccp</i> will contain a valid request context. This context is passed to <b class="fname">puffs_dispatch_exec</b>() to execute the request. If the request yielded before completing, the routine returns 0, otherwise 1. When the routine completes, <i class="arg">pcc</i> is made invalid and a pointer to the processed buffer is placed in <i class="arg">pbp</i>. It is the responsibility of the caller to send the response (if necessary) and destroy the buffer.<p>
See <a class="link-man" href="../html3/puffs_cc.html">puffs_cc(3)</a> and <a class="link-man" href="../html3/puffs_framebuf.html">puffs_framebuf(3)</a> for further information.</dd>
</dl>
</div>
<div class="subsection">
<h2 id="x436f6f6b696573">Cookies</h2> Every file (regular file, directory, device node, ...) instance is attached to the kernel using a cookie. A cookie should uniquely map to a file during its lifetime. If file instances are kept in memory, a simple strategy is to use the virtual address of the structure describing the file. The cookie can be recycled when <b class="fname">puffs_node_reclaim</b>() is called for a node.<p>
For some operations (such as building paths) the framework needs to map the cookie to the framework-level structure describing a file, <span class="type">struct puffs_node</span>. It is advisable to simply use the <span class="type">struct puffs_node</span> address as a cookie and store file system specific data in the private portion of <span class="type">struct puffs_node</span>. The library assumes this by default. If it is not desirable, the file system implementation can call <b class="fname">puffs_set_cookiemap</b>() to provide an alternative cookie-to-node mapping function.</div>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html2/mount.html">mount(2)</a>, <a class="link-man" href="../html3/puffs_cc.html">puffs_cc(3)</a>, <a class="link-man" href="../html3/puffs_cred.html">puffs_cred(3)</a>, <a class="link-man" href="../html3/puffs_flush.html">puffs_flush(3)</a>, <a class="link-man" href="../html3/puffs_framebuf.html">puffs_framebuf(3)</a>, <a class="link-man" href="../html3/puffs_node.html">puffs_node(3)</a>, <a class="link-man" href="../html3/puffs_ops.html">puffs_ops(3)</a>, <a class="link-man" href="../html3/puffs_path.html">puffs_path(3)</a>, <a class="link-man" href="../html3/refuse.html">refuse(3)</a>, <a class="link-man" href="../html4/puffs.html">puffs(4)</a><p>
<span class="ref"><span class="ref-auth">Antti Kantee</span>, <span class="ref-title">puffs - Pass-to-Userspace Framework File System</span>, <i class="ref-jrnl">Proceedings of AsiaBSDCon 2007</i>, <span class="ref-page">pp. 29-42</span>, <span class="ref-date">March 2007</span>.</span><p>
<span class="ref"><span class="ref-auth">Antti Kantee</span>, <span class="ref-title">Using puffs for Implementing Client-Server Distributed File Systems</span>, <i class="ref-issue">Helsinki University of Technology</i>, <span class="ref-rep">Tech Report TKK-TKO-B157</span>, <span class="ref-date">September 2007</span>.</span><p>
<span class="ref"><span class="ref-auth">Antti Kantee</span> and <span class="ref-auth">Alistair Crooks</span>, <span class="ref-title">ReFUSE: Userspace FUSE Reimplementation Using puffs</span>, <i class="ref-jrnl">EuroBSDCon 2007</i>, <span class="ref-date">September 2007</span>.</span><p>
<span class="ref"><span class="ref-auth">Antti Kantee</span>, <span class="ref-title">Send and Receive of File System Protocols: Userspace Approach With puffs</span>, <i class="ref-jrnl">Proceedings of AsiaBSDCon 2008</i>, <span class="ref-page">pp. 55-70</span>, <span class="ref-date">March 2008</span>.</span></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> An unsupported experimental version of <b class="name">puffs</b> first appeared in <span class="unix">NetBSD&#160;4.0</span>. A stable version appeared in <span class="unix">NetBSD&#160;5.0</span>.</div>
<div class="section">
<h1 id="x415554484f5253">AUTHORS</h1> <span class="author">Antti Kantee</span> &#60;<a class="link-mail" href="mailto:pooka@iki.fi">pooka@iki.fi</a>&#62;</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
February 15, 2015</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

