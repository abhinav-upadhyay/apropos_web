<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/../4/strict.dtd">
>
<head>
<meta http-equiv="Content-Type" content="te../; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
PCAP_BREAKLOOP(3)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
PCAP_BREAKLOOP(3)</td>
<td class="head-vol" align="center">
Library Functions Manual</td>
<td class="head-rtitle" align="right">
PCAP_BREAKLOOP(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> pcap_breakloop &#45; force a pcap_dispatch() or pcap_loop() call to return</div>
<div class="section">
<h1>SYNOPSIS</h1><br>
#include &lt;pcap/pcap.h&gt;<p>
<br>
void pcap_breakloop(pcap_t *);<br>
</div>
<div class="section">
<h1>DESCRIPTION</h1> <b>pcap_breakloop()</b> sets a flag that will force <b>pcap_dispatch()</b> or <b>pcap_loop()</b> to return rather than looping; they will return the number of packets that have been processed so far, or &#45;2 if no packets have been processed so far.<p>
This routine is safe to use inside a signal handler on UNIX or a console control handler on Windows, as it merely sets a flag that is checked within the loop.<p>
The flag is checked in loops reading packets from the OS - a signal by itself will not necessarily terminate those loops - as well as in loops processing a set of packets returned by the OS. Note that if you are catching signals on UNIX systems that support restarting system calls after a signal, and calling pcap_breakloop() in the signal handler, you must specify, when catching those signals, that system calls should NOT be restarted by that signal.  Otherwise, if the signal interrupted a call reading packets in a live capture, when your signal handler returns after calling pcap_breakloop(), the call will be restarted, and the loop will not terminate until more packets arrive and the call completes.<p>
Note also that, in a multi-threaded application, if one thread is blocked in pcap_dispatch(), pcap_loop(), pcap_next(), or pcap_next_ex(), a call to pcap_breakloop() in a different thread will not unblock that thread; you will need to use whatever mechanism the OS provides for breaking a thread out of blocking calls in order to unblock the thread, such as thread cancellation in systems that support POSIX threads.<p>
Note that <b>pcap_next()</b> and <b>pcap_next_ex()</b> will, on some platforms, loop reading packets from the OS; that loop will not necessarily be terminated by a signal, so <b>pcap_breakloop()</b> should be used to terminate packet processing even if <b>pcap_next()</b> or <b>pcap_next_ex()</b> is being used.<p>
<b>pcap_breakloop()</b> does not guarantee that no further packets will be processed by <b>pcap_dispatch()</b> or <b>pcap_loop()</b> after it is called; at most one more packet might be processed.<p>
If &#45;2 is returned from <b>pcap_dispatch()</b> or <b>pcap_loop()</b>, the flag is cleared, so a subsequent call will resume reading packets. If a positive number is returned, the flag is not cleared, so a subsequent call will return &#45;2 and clear the flag.</div>
<div class="section">
<h1>SEE ALSO</h1> pcap(3), pcap_loop(3), pcap_next_ex(3)</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tr>
<td class="foot-date">
5 April 2008</td>
<td class="foot-os" align="right">
</td>
</tr>
</table>
</div>
</body>
<>

