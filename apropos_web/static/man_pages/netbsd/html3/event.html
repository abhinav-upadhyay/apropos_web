<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/../4/strict.dtd">
>
<head>
<meta http-equiv="Content-Type" content="te../; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
event(3)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
event(3)</td>
<td class="head-vol" align="center">
Library Functions Manual</td>
<td class="head-rtitle" align="right">
event(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> event &#45;<p>
Core functions for waiting for and receiving events, and using event bases.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>SYNOPSIS</h1> #include &lt;event2/event.h&gt;<div style="height: 0.00em;">
&#160;</div>
#include &lt;event2/event-config.h&gt;<div style="height: 0.00em;">
&#160;</div>
#include &lt;stdio.h&gt;<div style="height: 0.00em;">
&#160;</div>
#include &lt;event2/util.h&gt;<div style="height: 0.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="subsection">
<h2>Data Structures</h2><br>
struct <b>event</b><div style="height: 0.00em;">
&#160;</div>
<i>Structure to represent a single event. </i> struct  <b>event_base</b><div style="height: 0.00em;">
&#160;</div>
<i>Structure to hold information and state for a Libevent dispatch loop. </i> struct  <b>event_config</b><div style="height: 0.00em;">
&#160;</div>
<i>Configuration for an </i><b>event_base</b><i>. </i><b></b><br>
</div>
<div class="subsection">
<h2>Macros</h2><br>
#define <b>_EVENT_LOG_DEBUG</b>   EVENT_LOG_DEBUG<div style="height: 0.00em;">
&#160;</div>
#define <b>_EVENT_LOG_ERR</b>   EVENT_LOG_ERR<div style="height: 0.00em;">
&#160;</div>
#define <b>_EVENT_LOG_MSG</b>   EVENT_LOG_MSG<div style="height: 0.00em;">
&#160;</div>
#define <b>_EVENT_LOG_WARN</b>   EVENT_LOG_WARN<div style="height: 0.00em;">
&#160;</div>
#define <b>event_get_signal</b>(ev)   ((int)<b>event_get_fd</b>(ev))<div style="height: 0.00em;">
&#160;</div>
<i>Get the signal number assigned to a signal event. </i> #define  <b>EVENT_MAX_PRIORITIES</b>   256<div style="height: 0.00em;">
&#160;</div>
<i>Largest number of priorities that Libevent can support. </i> #define  <b>EVENT_SET_MEM_FUNCTIONS_IMPLEMENTED</b><div style="height: 0.00em;">
&#160;</div>
<i>This definition is present if Libevent was built with support for </i><b>event_set_mem_functions()</b><i> </i><b></b> #define  <b>LIBEVENT_VERSION</b>   _EVENT_VERSION<div style="height: 0.00em;">
&#160;</div>
<i>As event_get_version, but gives the version of Libevent's headers. </i> #define  <b>LIBEVENT_VERSION_NUMBER</b>   _EVENT_NUMERIC_VERSION<div style="height: 0.00em;">
&#160;</div>
<i>As event_get_version_number, but gives the version number of Libevent's headers. </i><br>
<p>
<b>Log severities</b><div style="height: 0.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<br>
<br>
#define <b>EVENT_LOG_DEBUG</b>   0<div style="height: 0.00em;">
&#160;</div>
#define <b>EVENT_LOG_MSG</b>   1<div style="height: 0.00em;">
&#160;</div>
#define <b>EVENT_LOG_WARN</b>   2<div style="height: 0.00em;">
&#160;</div>
#define <b>EVENT_LOG_ERR</b>   3<div style="height: 0.00em;">
&#160;</div>
<br>
<br>
<p>
<b>Loop flags</b><div style="height: 0.00em;">
&#160;</div>
These flags control the behavior of <b>event_base_loop()</b>.<p>
<br>
<br>
#define <b>EVLOOP_ONCE</b>   0x01<div style="height: 0.00em;">
&#160;</div>
<i>Block until we have an active event, then exit once all active events have had their callbacks run. </i> #define  <b>EVLOOP_NONBLOCK</b>   0x02<div style="height: 0.00em;">
&#160;</div>
<i>Do not block: see which events are ready now, run the callbacks of the highest-priority ones, then exit. </i><br>
<br>
<p>
<b>event flags</b><div style="height: 0.00em;">
&#160;</div>
Flags to pass to <b>event_new()</b>, <b>event_assign()</b>, <b>event_pending()</b>, and anything else with an argument of the form 'short events'<p>
<br>
<br>
#define <b>EV_TIMEOUT</b>   0x01<div style="height: 0.00em;">
&#160;</div>
<i>Indicates that a timeout has occurred. </i> #define  <b>EV_READ</b>   0x02<div style="height: 0.00em;">
&#160;</div>
<i>Wait for a socket or FD to become readable. </i> #define  <b>EV_WRITE</b>   0x04<div style="height: 0.00em;">
&#160;</div>
<i>Wait for a socket or FD to become writeable. </i> #define  <b>EV_SIGNAL</b>   0x08<div style="height: 0.00em;">
&#160;</div>
<i>Wait for a POSIX signal to be raised. </i> #define  <b>EV_PERSIST</b>   0x10<div style="height: 0.00em;">
&#160;</div>
<i>Persistent event: won't get removed automatically when activated. </i> #define  <b>EV_ET</b>   0x20<div style="height: 0.00em;">
&#160;</div>
<i>Select edge-triggered behavior, if supported by the backend. </i><br>
<br>
<p>
<b>evtimer_* macros</b><div style="height: 0.00em;">
&#160;</div>
Aliases for working with one-shot timer events<p>
<br>
<br>
#define <b>evtimer_assign</b>(ev, b, cb, arg)   <b>event_assign</b>((ev), (b), -1, 0, (cb), (arg))<div style="height: 0.00em;">
&#160;</div>
#define <b>evtimer_new</b>(b, cb, arg)   <b>event_new</b>((b), -1, 0, (cb), (arg))<div style="height: 0.00em;">
&#160;</div>
#define <b>evtimer_add</b>(ev, tv)   <b>event_add</b>((ev), (tv))<div style="height: 0.00em;">
&#160;</div>
#define <b>evtimer_del</b>(ev)   <b>event_del</b>(ev)<div style="height: 0.00em;">
&#160;</div>
#define <b>evtimer_pending</b>(ev, tv)   <b>event_pending</b>((ev), <b>EV_TIMEOUT</b>, (tv))<div style="height: 0.00em;">
&#160;</div>
#define <b>evtimer_initialized</b>(ev)   <b>event_initialized</b>(ev)<div style="height: 0.00em;">
&#160;</div>
<br>
<br>
<p>
<b>evsignal_* macros</b><div style="height: 0.00em;">
&#160;</div>
Aliases for working with signal events<p>
<br>
<br>
#define <b>evsignal_add</b>(ev, tv)   <b>event_add</b>((ev), (tv))<div style="height: 0.00em;">
&#160;</div>
#define <b>evsignal_assign</b>(ev, b, x, cb, arg)   <b>event_assign</b>((ev), (b), (x), <b>EV_SIGNAL</b>|<b>EV_PERSIST</b>, cb, (arg))<div style="height: 0.00em;">
&#160;</div>
#define <b>evsignal_new</b>(b, x, cb, arg)   <b>event_new</b>((b), (x), <b>EV_SIGNAL</b>|<b>EV_PERSIST</b>, (cb), (arg))<div style="height: 0.00em;">
&#160;</div>
#define <b>evsignal_del</b>(ev)   <b>event_del</b>(ev)<div style="height: 0.00em;">
&#160;</div>
#define <b>evsignal_pending</b>(ev, tv)   <b>event_pending</b>((ev), <b>EV_SIGNAL</b>, (tv))<div style="height: 0.00em;">
&#160;</div>
#define <b>evsignal_initialized</b>(ev)   <b>event_initialized</b>(ev)<div style="height: 0.00em;">
&#160;</div>
<br>
<br>
</div>
<div class="subsection">
<h2>Typedefs</h2><br>
typedef void(* <b>event_callback_fn</b> )(<b>evutil_socket_t</b>, short, void *)<div style="height: 0.00em;">
&#160;</div>
<i>A callback function for an event. </i> typedef void(*  <b>event_fatal_cb</b> )(int err)<div style="height: 0.00em;">
&#160;</div>
<i>A function to be called if Libevent encounters a fatal internal error. </i> typedef void(*  <b>event_log_cb</b> )(int severity, const char *msg)<div style="height: 0.00em;">
&#160;</div>
<i>A callback function used to intercept Libevent's log messages. </i><br>
</div>
<div class="subsection">
<h2>Enumerations</h2><br>
enum <b>event_base_config_flag</b> { <b>EVENT_BASE_FLAG_NOLOCK</b> = 0x01, <b>EVENT_BASE_FLAG_IGNORE_ENV</b> = 0x02, <b>EVENT_BASE_FLAG_STARTUP_IOCP</b> = 0x04, <b>EVENT_BASE_FLAG_NO_CACHE_TIME</b> = 0x08, <b>EVENT_BASE_FLAG_EPOLL_USE_CHANGELIST</b> = 0x10 }<div style="height: 0.00em;">
&#160;</div>
<i>A flag passed to </i><b>event_config_set_flag()</b><i>. </i><b></b> enum  <b>event_method_feature</b> { <b>EV_FEATURE_ET</b> = 0x01, <b>EV_FEATURE_O1</b> = 0x02, <b>EV_FEATURE_FDS</b> = 0x04 }<div style="height: 0.00em;">
&#160;</div>
<i>A flag used to describe which features an </i><b>event_base</b><i> (must) provide. </i><b></b><br>
</div>
<div class="subsection">
<h2>Functions</h2><br>
void <b>event_active</b> (struct <b>event</b> *ev, int res, short ncalls)<div style="height: 0.00em;">
&#160;</div>
<i>Make an event active. </i> int  <b>event_add</b> (struct <b>event</b> *ev, const struct timeval *timeout)<div style="height: 0.00em;">
&#160;</div>
<i>Add an event to the set of pending events. </i> int  <b>event_assign</b> (struct <b>event</b> *, struct <b>event_base</b> *, <b>evutil_socket_t</b>, short, <b>event_callback_fn</b>, void *)<div style="height: 0.00em;">
&#160;</div>
<i>Prepare a new, already-allocated event structure to be added. </i> int  <b>event_base_dispatch</b> (struct <b>event_base</b> *)<div style="height: 0.00em;">
&#160;</div>
<i>Event dispatching loop. </i> void  <b>event_base_dump_events</b> (struct <b>event_base</b> *, FILE *)<div style="height: 0.00em;">
&#160;</div>
void <b>event_base_free</b> (struct <b>event_base</b> *)<div style="height: 0.00em;">
&#160;</div>
<i>Deallocate all memory associated with an </i><b>event_base</b><i>, and free the base. </i><b></b> int  <b>event_base_get_features</b> (const struct <b>event_base</b> *base)<div style="height: 0.00em;">
&#160;</div>
<i>Return a bitmask of the features implemented by an event base. </i> const char *  <b>event_base_get_method</b> (const struct <b>event_base</b> *)<div style="height: 0.00em;">
&#160;</div>
<i>Get the kernel event notification mechanism used by Libevent. </i> int  <b>event_base_gettimeofday_cached</b> (struct <b>event_base</b> *base, struct timeval *tv)<div style="height: 0.00em;">
&#160;</div>
<i>Sets 'tv' to the current time (as returned by gettimeofday()), looking at the cached value in 'base' if possible, and calling gettimeofday() or clock_gettime() as appropriate if there is no cached time. </i> int  <b>event_base_got_break</b> (struct <b>event_base</b> *)<div style="height: 0.00em;">
&#160;</div>
<i>Checks if the event loop was told to abort immediately by </i><b>event_loopbreak()</b><i>. </i><b></b> int  <b>event_base_got_exit</b> (struct <b>event_base</b> *)<div style="height: 0.00em;">
&#160;</div>
<i>Checks if the event loop was told to exit by </i><b>event_loopexit()</b><i>. </i><b></b> const struct timeval *  <b>event_base_init_common_timeout</b> (struct <b>event_base</b> *base, const struct timeval *duration)<div style="height: 0.00em;">
&#160;</div>
<i>Prepare an </i><b>event_base</b><i> to use a large number of timeouts with the same duration. </i><b></b> int  <b>event_base_loop</b> (struct <b>event_base</b> *, int)<div style="height: 0.00em;">
&#160;</div>
<i>Wait for events to become active, and run their callbacks. </i> int  <b>event_base_loopbreak</b> (struct <b>event_base</b> *)<div style="height: 0.00em;">
&#160;</div>
<i>Abort the active </i><b>event_base_loop()</b><i> immediately. </i><b></b> int  <b>event_base_loopexit</b> (struct <b>event_base</b> *, const struct timeval *)<div style="height: 0.00em;">
&#160;</div>
<i>Exit the event loop after the specified time. </i> struct  <b>event_base</b> * <b>event_base_new</b> (void)<div style="height: 0.00em;">
&#160;</div>
<i>Create and return a new </i><b>event_base</b><i> to use with the rest of Libevent. </i><b></b> struct  <b>event_base</b> * <b>event_base_new_with_config</b> (const struct <b>event_config</b> *)<div style="height: 0.00em;">
&#160;</div>
<i>Initialize the event API. </i> int  <b>event_base_once</b> (struct <b>event_base</b> *, <b>evutil_socket_t</b>, short, <b>event_callback_fn</b>, void *, const struct timeval *)<div style="height: 0.00em;">
&#160;</div>
<i>Schedule a one-time event. </i> int  <b>event_base_priority_init</b> (struct <b>event_base</b> *, int)<div style="height: 0.00em;">
&#160;</div>
<i>Set the number of different event priorities. </i> int  <b>event_base_set</b> (struct <b>event_base</b> *, struct <b>event</b> *)<div style="height: 0.00em;">
&#160;</div>
<i>Associate a different event base with an event. </i> int  <b>event_config_avoid_method</b> (struct <b>event_config</b> *cfg, const char *method)<div style="height: 0.00em;">
&#160;</div>
<i>Enters an event method that should be avoided into the configuration. </i> void  <b>event_config_free</b> (struct <b>event_config</b> *cfg)<div style="height: 0.00em;">
&#160;</div>
<i>Deallocates all memory associated with an event configuration object. </i> struct  <b>event_config</b> * <b>event_config_new</b> (void)<div style="height: 0.00em;">
&#160;</div>
<i>Allocates a new event configuration object. </i> int  <b>event_config_require_features</b> (struct <b>event_config</b> *cfg, int feature)<div style="height: 0.00em;">
&#160;</div>
<i>Enters a required event method feature that the application demands. </i> int  <b>event_config_set_flag</b> (struct <b>event_config</b> *cfg, int flag)<div style="height: 0.00em;">
&#160;</div>
<i>Sets one or more flags to configure what parts of the eventual </i><b>event_base</b><i> will be initialized, and how they'll work. </i><b></b> int  <b>event_config_set_num_cpus_hint</b> (struct <b>event_config</b> *cfg, int cpus)<div style="height: 0.00em;">
&#160;</div>
<i>Records a hint for the number of CPUs in the system. </i> void  <b>event_debug_unassign</b> (struct <b>event</b> *)<div style="height: 0.00em;">
&#160;</div>
<i>When debugging mode is enabled, informs Libevent that an event should no longer be considered as assigned. </i> int  <b>event_del</b> (struct <b>event</b> *)<div style="height: 0.00em;">
&#160;</div>
<i>Remove an event from the set of monitored events. </i> void  <b>event_enable_debug_mode</b> (void)<div style="height: 0.00em;">
&#160;</div>
<i>Enable some relatively expensive debugging checks in Libevent that would normally be turned off. </i> void  <b>event_free</b> (struct <b>event</b> *)<div style="height: 0.00em;">
&#160;</div>
<i>Deallocate a struct event * returned by </i><b>event_new()</b><i>. </i><b></b> void  <b>event_get_assignment</b> (const struct <b>event</b> *<b>event</b>, struct <b>event_base</b> **base_out, <b>evutil_socket_t</b> *fd_out, short *events_out, <b>event_callback_fn</b> *callback_out, void **arg_out)<div style="height: 0.00em;">
&#160;</div>
<i>Extract </i><i>all</i><i> of arguments given to construct a given event. </i><i></i> struct  <b>event_base</b> * <b>event_get_base</b> (const struct <b>event</b> *ev)<div style="height: 0.00em;">
&#160;</div>
<i>Get the </i><b>event_base</b><i> associated with an event. </i><b></b>  <b>event_callback_fn</b> <b>event_get_callback</b> (const struct <b>event</b> *ev)<div style="height: 0.00em;">
&#160;</div>
<i>Return the callback assigned to an event. </i> void *  <b>event_get_callback_arg</b> (const struct <b>event</b> *ev)<div style="height: 0.00em;">
&#160;</div>
<i>Return the callback argument assigned to an event. </i> short  <b>event_get_events</b> (const struct <b>event</b> *ev)<div style="height: 0.00em;">
&#160;</div>
<i>Return the events (EV_READ, EV_WRITE, etc) assigned to an event. </i>  <b>evutil_socket_t</b> <b>event_get_fd</b> (const struct <b>event</b> *ev)<div style="height: 0.00em;">
&#160;</div>
<i>Get the socket or signal assigned to an event, or -1 if the event has no socket. </i> size_t  <b>event_get_struct_event_size</b> (void)<div style="height: 0.00em;">
&#160;</div>
<i>Return the size of struct event that the Libevent library was compiled with. </i> const char **  <b>event_get_supported_methods</b> (void)<div style="height: 0.00em;">
&#160;</div>
<i>Gets all event notification mechanisms supported by Libevent. </i> const char *  <b>event_get_version</b> (void)<div style="height: 0.00em;">
&#160;</div>
<i>Get the Libevent version. </i> ev_uint32_t  <b>event_get_version_number</b> (void)<div style="height: 0.00em;">
&#160;</div>
<i>Return a numeric representation of Libevent's version. </i> int  <b>event_initialized</b> (const struct <b>event</b> *ev)<div style="height: 0.00em;">
&#160;</div>
<i>Test if an event structure might be initialized. </i> struct  <b>event</b> * <b>event_new</b> (struct <b>event_base</b> *, <b>evutil_socket_t</b>, short, <b>event_callback_fn</b>, void *)<div style="height: 0.00em;">
&#160;</div>
<i>Allocate and asssign a new event structure, ready to be added. </i> int  <b>event_pending</b> (const struct <b>event</b> *ev, short events, struct timeval *tv)<div style="height: 0.00em;">
&#160;</div>
<i>Checks if a specific event is pending or scheduled. </i> int  <b>event_priority_set</b> (struct <b>event</b> *, int)<div style="height: 0.00em;">
&#160;</div>
<i>Assign a priority to an event. </i> int  <b>event_reinit</b> (struct <b>event_base</b> *base)<div style="height: 0.00em;">
&#160;</div>
<i>Reinitialize the event base after a fork. </i> void  <b>event_set_fatal_callback</b> (<b>event_fatal_cb</b> cb)<div style="height: 0.00em;">
&#160;</div>
<i>Override Libevent's behavior in the event of a fatal internal error. </i> void  <b>event_set_log_callback</b> (<b>event_log_cb</b> cb)<div style="height: 0.00em;">
&#160;</div>
<i>Redirect Libevent's log messages. </i> void  <b>event_set_mem_functions</b> (void *(*malloc_fn)(size_t sz), void *(*realloc_fn)(void *ptr, size_t sz), void(*free_fn)(void *ptr))<div style="height: 0.00em;">
&#160;</div>
<i>Override the functions that Libevent uses for memory management. </i><br>
</div>
</div>
<div class="section">
<h1>Detailed Description</h1> Core functions for waiting for and receiving events, and using event bases.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>Macro Definition Documentation</h1><div class="subsection">
<h2>#define EV_ET   0x20</h2> Select edge-triggered behavior, if supported by the backend.</div>
<div class="subsection">
<h2>#define EV_PERSIST   0x10</h2> Persistent event: won't get removed automatically when activated. When a persistent event with a timeout becomes activated, its timeout is reset to 0.</div>
<div class="subsection">
<h2>#define EV_TIMEOUT   0x01</h2> Indicates that a timeout has occurred. It's not necessary to pass this flag to event_for new()/event_assign() to get a timeout.</div>
<div class="subsection">
<h2>#define EVENT_MAX_PRIORITIES   256</h2> Largest number of priorities that Libevent can support.</div>
<div class="subsection">
<h2>#define EVLOOP_NONBLOCK   0x02</h2> Do not block: see which events are ready now, run the callbacks of the highest-priority ones, then exit.</div>
<div class="subsection">
<h2>#define EVLOOP_ONCE   0x01</h2> Block until we have an active event, then exit once all active events have had their callbacks run.</div>
<div class="subsection">
<h2>#define LIBEVENT_VERSION   _EVENT_VERSION</h2> As event_get_version, but gives the version of Libevent's headers.</div>
<div class="subsection">
<h2>#define LIBEVENT_VERSION_NUMBER   _EVENT_NUMERIC_VERSION</h2> As event_get_version_number, but gives the version number of Libevent's headers.</div>
</div>
<div class="section">
<h1>Typedef Documentation</h1><div class="subsection">
<h2>typedef void(* event_callback_fn)(<b>evutil_socket_t</b>, short, void *)</h2> A callback function for an event. It receives three arguments:<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>fd</i> An fd or signal<div style="height: 0.00em;">
&#160;</div>
<i>events</i> One or more EV_* flags<div style="height: 0.00em;">
&#160;</div>
<i>arg</i> A user-supplied argument.</div>
<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>event_new()</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>typedef void(* event_fatal_cb)(int err)</h2> A function to be called if Libevent encounters a fatal internal error.<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>event_set_fatal_callback</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>typedef void(* event_log_cb)(int severity, const char *msg)</h2> A callback function used to intercept Libevent's log messages.<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>event_set_log_callback</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
</div>
<div class="section">
<h1>Enumeration Type Documentation</h1><div class="subsection">
<h2>enum <b>event_base_config_flag</b></h2> A flag passed to  <b>event_config_set_flag()</b>. These flags change the behavior of an allocated <b>event_base</b>.<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>event_config_set_flag()</b>, <b>event_base_new_with_config()</b>, <b>event_method_feature</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
<p>
<b>Enumerator</b><br>
<dl>
<dt>
<b></b><i>EVENT_BASE_FLAG_NOLOCK </i><b></b><i></i></dt>
<dd>
Do not allocate a lock for the event base, even if we have locking set up.</dd>
</dl>
<dl>
<dt>
<b></b><i>EVENT_BASE_FLAG_IGNORE_ENV </i><b></b><i></i></dt>
<dd>
Do not check the EVENT_* environment variables when configuring an <b>event_base</b>.</dd>
</dl>
<dl>
<dt>
<b></b><i>EVENT_BASE_FLAG_STARTUP_IOCP </i><b></b><i></i></dt>
<dd>
Windows only: enable the IOCP dispatcher at startup. If this flag is set then <b>bufferevent_socket_new()</b> and evconn_listener_new() will use IOCP-backed implementations instead of the usual select-based one on Windows.</dd>
</dl>
<dl>
<dt>
<b></b><i>EVENT_BASE_FLAG_NO_CACHE_TIME </i><b></b><i></i></dt>
<dd>
Instead of checking the current time every time the event loop is ready to run timeout callbacks, check after each timeout callback.</dd>
</dl>
<dl>
<dt>
<b></b><i>EVENT_BASE_FLAG_EPOLL_USE_CHANGELIST </i><b></b><i></i></dt>
<dd>
If we are using the epoll backend, this flag says that it is safe to use Libevent's internal change-list code to batch up adds and deletes in order to try to do as few syscalls as possible. Setting this flag can make your code run faster, but it may trigger a Linux bug: it is not safe to use this flag if you have any fds cloned by dup() or its variants. Doing so will produce strange and hard-to-diagnose bugs.</dd>
</dl>
<p>
This flag can also be activated by settnig the EVENT_EPOLL_USE_CHANGELIST environment variable.<p>
This flag has no effect if you wind up using a backend other than epoll.</div>
<div class="subsection">
<h2>enum <b>event_method_feature</b></h2> A flag used to describe which features an  <b>event_base</b> (must) provide. Because of OS limitations, not every Libevent backend supports every possible feature. You can use this type with <b>event_config_require_features()</b> to tell Libevent to only proceed if your <b>event_base</b> implements a given feature, and you can receive this type from <b>event_base_get_features()</b> to see which features are available.<p>
<b>Enumerator</b><br>
<dl>
<dt>
<b></b><i>EV_FEATURE_ET </i><b></b><i></i></dt>
<dd>
Require an event method that allows edge-triggered events with EV_ET.</dd>
</dl>
<dl>
<dt>
<b></b><i>EV_FEATURE_O1 </i><b></b><i></i></dt>
<dd>
Require an event method where having one event triggered among many is [approximately] an O(1) operation. This excludes (for example) select and poll, which are approximately O(N) for N equal to the total number of possible events.</dd>
</dl>
<dl>
<dt>
<b></b><i>EV_FEATURE_FDS </i><b></b><i></i></dt>
<dd>
Require an event method that allows file descriptors as well as sockets.</dd>
</dl>
</div>
</div>
<div class="section">
<h1>Function Documentation</h1><div class="subsection">
<h2>void event_active (struct <b>event</b> *ev, intres, shortncalls)</h2> Make an event active. You can use this function on a pending or a non-pending event to make it active, so that its callback will be run by  <b>event_base_dispatch()</b> or <b>event_base_loop()</b>.<p>
One common use in multithreaded programs is to wake the thread running <b>event_base_loop()</b> from another thread.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>ev</i> an event to make active.<div style="height: 0.00em;">
&#160;</div>
<i>res</i> a set of flags to pass to the event's callback.<div style="height: 0.00em;">
&#160;</div>
<i>ncalls</i> an obsolete argument: this is ignored.</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int event_add (struct <b>event</b> *ev, const struct timeval *timeout)</h2> Add an event to the set of pending events. The function  <b>event_add()</b> schedules the execution of the ev event when the event specified in <b>event_assign()</b>/event_new() occurs, or when the time specified in timeout has elapesed. If atimeout is NULL, no timeout occurs and the function will only be called if a matching event occurs. The event in the ev argument must be already initialized by <b>event_assign()</b> or <b>event_new()</b> and may not be used in calls to <b>event_assign()</b> until it is no longer pending.<p>
If the event in the ev argument already has a scheduled timeout, calling <b>event_add()</b> replaces the old timeout with the new one, or clears the old timeout if the timeout argument is NULL.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>ev</i> an event struct initialized via <b>event_set()</b><div style="height: 0.00em;">
&#160;</div>
<i>timeout</i> the maximum amount of time to wait for the event, or NULL to wait forever</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 if successful, or -1 if an error occurred</div>
<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>event_del()</b>, <b>event_assign()</b>, <b>event_new()</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int event_assign (struct <b>event</b> *, struct <b>event_base</b> *, <b>evutil_socket_t</b>, short, <b>event_callback_fn</b>, void *)</h2> Prepare a new, already-allocated event structure to be added. The function  <b>event_assign()</b> prepares the event structure ev to be used in future calls to <b>event_add()</b> and <b>event_del()</b>. Unlike <b>event_new()</b>, it doesn't allocate memory itself: it requires that you have already allocated a struct event, probably on the heap. Doing this will typically make your code depend on the size of the event structure, and thereby create incompatibility with future versions of Libevent.<p>
The easiest way to avoid this problem is just to use <b>event_new()</b> and <b>event_free()</b> instead.<p>
A slightly harder way to future-proof your code is to use <b>event_get_struct_event_size()</b> to determine the required size of an event at runtime.<p>
Note that it is NOT safe to call this function on an event that is active or pending. Doing so WILL corrupt internal data structures in Libevent, and lead to strange, hard-to-diagnose bugs. You <i>can</i> use event_assign to change an existing event, but only if it is not active or pending!<p>
The arguments for this function, and the behavior of the events that it makes, are as for <b>event_new()</b>.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>ev</i> an event struct to be modified<div style="height: 0.00em;">
&#160;</div>
<i>base</i> the event base to which ev should be attached.<div style="height: 0.00em;">
&#160;</div>
<i>fd</i> the file descriptor to be monitored<div style="height: 0.00em;">
&#160;</div>
<i>events</i> desired events to monitor; can be EV_READ and/or EV_WRITE<div style="height: 0.00em;">
&#160;</div>
<i>callback</i> callback function to be invoked when the event occurs<div style="height: 0.00em;">
&#160;</div>
<i>callback_arg</i> an argument to be passed to the callback function</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 if success, or -1 on invalid arguments.</div>
<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>event_new()</b>, <b>event_add()</b>, <b>event_del()</b>, <b>event_base_once()</b>, <b>event_get_struct_event_size()</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int event_base_dispatch (struct <b>event_base</b> *)</h2> Event dispatching loop. This loop will run the event base until either there are no more pending or active, or until something calls  <b>event_base_loopbreak()</b> or <b>event_base_loopexit()</b>.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>base</i> the <b>event_base</b> structure returned by <b>event_base_new()</b> or <b>event_base_new_with_config()</b></div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 if successful, -1 if an error occurred, or 1 if we exited because no events were pending or active.</div>
<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>event_base_loop()</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>void event_base_free (struct <b>event_base</b> *)</h2> Deallocate all memory associated with an  <b>event_base</b>, and free the base. Note that this function will not close any fds or free any memory passed to event_new as the argument to callback.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>eb</i> an <b>event_base</b> to be freed</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int event_base_get_features (const struct <b>event_base</b> *base)</h2> Return a bitmask of the features implemented by an event base. This will be a bitwise OR of one or more of the values of event_method_feature<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>event_method_feature</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>const char* event_base_get_method (const struct <b>event_base</b> *)</h2> Get the kernel event notification mechanism used by Libevent.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>eb</i> the <b>event_base</b> structure returned by <b>event_base_new()</b></div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
a string identifying the kernel event mechanism (kqueue, epoll, etc.)</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int event_base_gettimeofday_cached (struct <b>event_base</b> *base, struct timeval *tv)</h2> Sets 'tv' to the current time (as returned by gettimeofday()), looking at the cached value in 'base' if possible, and calling gettimeofday() or clock_gettime() as appropriate if there is no cached time. Generally, this value will only be cached while actually processing event callbacks, and may be very inaccuate if your callbacks take a long time to execute.<p>
Returns 0 on success, negative on failure.</div>
<div class="subsection">
<h2>int event_base_got_break (struct <b>event_base</b> *)</h2> Checks if the event loop was told to abort immediately by  <b>event_loopbreak()</b>. This function will return true for an <b>event_base</b> at every point after <b>event_loopbreak()</b> is called, until the event loop is next entered.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>eb</i> the <b>event_base</b> structure returned by <b>event_init()</b></div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
true if <b>event_base_loopbreak()</b> was called on this event base, or 0 otherwise</div>
<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>event_base_loopbreak()</b><p>
<b>event_base_got_exit()</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int event_base_got_exit (struct <b>event_base</b> *)</h2> Checks if the event loop was told to exit by  <b>event_loopexit()</b>. This function will return true for an <b>event_base</b> at every point after <b>event_loopexit()</b> is called, until the event loop is next entered.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>eb</i> the <b>event_base</b> structure returned by <b>event_init()</b></div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
true if <b>event_base_loopexit()</b> was called on this event base, or 0 otherwise</div>
<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>event_base_loopexit()</b><p>
<b>event_base_got_break()</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>const struct timeval* event_base_init_common_timeout (struct <b>event_base</b> *base, const struct timeval *duration)</h2> Prepare an  <b>event_base</b> to use a large number of timeouts with the same duration. Libevent's default scheduling algorithm is optimized for having a large number of timeouts with their durations more or less randomly distributed. But if you have a large number of timeouts that all have the same duration (for example, if you have a large number of connections that all have a 10-second timeout), then you can improve Libevent's performance by telling Libevent about it.<p>
To do this, call this function with the common duration. It will return a pointer to a different, opaque timeout value. (Don't depend on its actual contents!) When you use this timeout value in <b>event_add()</b>, Libevent will schedule the event more efficiently.<p>
(This optimization probably will not be worthwhile until you have thousands or tens of thousands of events with the same timeout.)</div>
<div class="subsection">
<h2>int event_base_loop (struct <b>event_base</b> *, int)</h2> Wait for events to become active, and run their callbacks. This is a more flexible version of  <b>event_base_dispatch()</b>.<p>
By default, this loop will run the event base until either there are no more pending or active events, or until something calls <b>event_base_loopbreak()</b> or <b>event_base_loopexit()</b>. You can override this behavior with the 'flags' argument.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>eb</i> the <b>event_base</b> structure returned by <b>event_base_new()</b> or <b>event_base_new_with_config()</b><div style="height: 0.00em;">
&#160;</div>
<i>flags</i> any combination of EVLOOP_ONCE | EVLOOP_NONBLOCK</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 if successful, -1 if an error occurred, or 1 if we exited because no events were pending or active.</div>
<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>event_base_loopexit()</b>, <b>event_base_dispatch()</b>, <b>EVLOOP_ONCE</b>, <b>EVLOOP_NONBLOCK</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int event_base_loopbreak (struct <b>event_base</b> *)</h2> Abort the active  <b>event_base_loop()</b> immediately. <b>event_base_loop()</b> will abort the loop after the next event is completed; <b>event_base_loopbreak()</b> is typically invoked from this event's callback. This behavior is analogous to the 'break;' statement.<p>
Subsequent invocations of <b>event_loop()</b> will proceed normally.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>eb</i> the <b>event_base</b> structure returned by <b>event_init()</b></div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 if successful, or -1 if an error occurred</div>
<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>event_base_loopexit()</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int event_base_loopexit (struct <b>event_base</b> *, const struct timeval *)</h2> Exit the event loop after the specified time. The next  <b>event_base_loop()</b> iteration after the given timer expires will complete normally (handling all queued events) then exit without blocking for events again.<p>
Subsequent invocations of <b>event_base_loop()</b> will proceed normally.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>eb</i> the <b>event_base</b> structure returned by <b>event_init()</b><div style="height: 0.00em;">
&#160;</div>
<i>tv</i> the amount of time after which the loop should terminate, or NULL to exit after running all currently active events.</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 if successful, or -1 if an error occurred</div>
<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>event_base_loopbreak()</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>struct <b>event_base</b>* event_base_new (void)</h2> Create and return a new  <b>event_base</b> to use with the rest of Libevent.<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
a new <b>event_base</b> on success, or NULL on failure.</div>
<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>event_base_free()</b>, <b>event_base_new_with_config()</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>struct <b>event_base</b>* event_base_new_with_config (const struct <b>event_config</b> *)</h2> Initialize the event API. Use  <b>event_base_new_with_config()</b> to initialize a new event base, taking the specified configuration under consideration. The configuration object can currently be used to avoid certain event notification mechanisms.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>cfg</i> the event configuration object</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
an initialized <b>event_base</b> that can be used to registering events, or NULL if no event base can be created with the requested <b>event_config</b>.</div>
<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>event_base_new()</b>, <b>event_base_free()</b>, <b>event_init()</b>, <b>event_assign()</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int event_base_once (struct <b>event_base</b> *, <b>evutil_socket_t</b>, short, <b>event_callback_fn</b>, void *, const struct timeval *)</h2> Schedule a one-time event. The function  <b>event_base_once()</b> is similar to <b>event_set()</b>. However, it schedules a callback to be called exactly once, and does not require the caller to prepare an event structure.<p>
Note that in Libevent 2.0 and earlier, if the event is never triggered, the internal memory used to hold it will never be freed. This may be fixed in a later version of Libevent.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>base</i> an <b>event_base</b><div style="height: 0.00em;">
&#160;</div>
<i>fd</i> a file descriptor to monitor, or -1 for no fd.<div style="height: 0.00em;">
&#160;</div>
<i>events</i> <b>event(s)</b> to monitor; can be any of EV_READ | EV_WRITE, or EV_TIMEOUT<div style="height: 0.00em;">
&#160;</div>
<i>callback</i> callback function to be invoked when the event occurs<div style="height: 0.00em;">
&#160;</div>
<i>arg</i> an argument to be passed to the callback function<div style="height: 0.00em;">
&#160;</div>
<i>timeout</i> the maximum amount of time to wait for the event. NULL makes an EV_READ/EV_WRITE event make forever; NULL makes an EV_TIMEOUT event succees immediately.</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 if successful, or -1 if an error occurred</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int event_base_priority_init (struct <b>event_base</b> *, int)</h2> Set the number of different event priorities. By default Libevent schedules all active events with the same priority. However, some time it is desirable to process some events with a higher priority than others. For that reason, Libevent supports strict priority queues. Active events with a lower priority are always processed before events with a higher priority.<p>
The number of different priorities can be set initially with the <b>event_base_priority_init()</b> function. This function should be called before the first call to <b>event_base_dispatch()</b>. The <b>event_priority_set()</b> function can be used to assign a priority to an event. By default, Libevent assigns the middle priority to all events unless their priority is explicitly set.<p>
Note that urgent-priority events can starve less-urgent events: after running all urgent-priority callbacks, Libevent checks for more urgent events again, before running less-urgent events. Less-urgent events will not have their callbacks run until there are no events more urgent than them that want to be active.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>eb</i> the <b>event_base</b> structure returned by <b>event_base_new()</b><div style="height: 0.00em;">
&#160;</div>
<i>npriorities</i> the maximum number of priorities</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 if successful, or -1 if an error occurred</div>
<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>event_priority_set()</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int event_base_set (struct <b>event_base</b> *, struct <b>event</b> *)</h2> Associate a different event base with an event. The event to be associated must not be currently active or pending.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>eb</i> the event base<div style="height: 0.00em;">
&#160;</div>
<i>ev</i> the event</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 on success, -1 on failure.</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int event_config_avoid_method (struct <b>event_config</b> *cfg, const char *method)</h2> Enters an event method that should be avoided into the configuration. This can be used to avoid event mechanisms that do not support certain file descriptor types, or for debugging to avoid certain event mechanisms. An application can make use of multiple event bases to accommodate incompatible file descriptor types.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>cfg</i> the event configuration object<div style="height: 0.00em;">
&#160;</div>
<i>method</i> the name of the event method to avoid</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 on success, -1 on failure.</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>void event_config_free (struct <b>event_config</b> *cfg)</h2> Deallocates all memory associated with an event configuration object.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>cfg</i> the event configuration object to be freed.</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>struct <b>event_config</b>* event_config_new (void)</h2> Allocates a new event configuration object. The event configuration object can be used to change the behavior of an event base.<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
an <b>event_config</b> object that can be used to store configuration, or NULL if an error is encountered.</div>
<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>event_base_new_with_config()</b>, <b>event_config_free()</b>, <b>event_config</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int event_config_require_features (struct <b>event_config</b> *cfg, intfeature)</h2> Enters a required event method feature that the application demands. Note that not every feature or combination of features is supported on every platform. Code that requests features should be prepared to handle the case where  <b>event_base_new_with_config()</b> returns NULL, as in:<p>
<p>
<br>
  event_config_require_features(cfg, EV_FEATURE_ET);<br>
  base = event_base_new_with_config(cfg);<br>
  if (base == NULL) {<br>
    // We can't get edge-triggered behavior here.<br>
    event_config_require_features(cfg, 0);<br>
    base = event_base_new_with_config(cfg);<br>
  }<br>
<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>cfg</i> the event configuration object<div style="height: 0.00em;">
&#160;</div>
<i>feature</i> a bitfield of one or more event_method_feature values. Replaces values from previous calls to this function.</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 on success, -1 on failure.</div>
<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>event_method_feature</b>, <b>event_base_new_with_config()</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int event_config_set_flag (struct <b>event_config</b> *cfg, intflag)</h2> Sets one or more flags to configure what parts of the eventual  <b>event_base</b> will be initialized, and how they'll work.<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
event_base_config_flags, <b>event_base_new_with_config()</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int event_config_set_num_cpus_hint (struct <b>event_config</b> *cfg, intcpus)</h2> Records a hint for the number of CPUs in the system. This is used for tuning thread pools, etc, for optimal performance. In Libevent 2.0, it is only on Windows, and only when IOCP is in use.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>cfg</i> the event configuration object<div style="height: 0.00em;">
&#160;</div>
<i>cpus</i> the number of cpus</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 on success, -1 on failure.</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>void event_debug_unassign (struct <b>event</b> *)</h2> When debugging mode is enabled, informs Libevent that an event should no longer be considered as assigned. When debugging mode is not enabled, does nothing.<p>
This function must only be called on a non-added event.<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>event_enable_debug_mode()</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int event_del (struct <b>event</b> *)</h2> Remove an event from the set of monitored events. The function  <b>event_del()</b> will cancel the event in the argument ev. If the event has already executed or has never been added the call will have no effect.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>ev</i> an event struct to be removed from the working set</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 if successful, or -1 if an error occurred</div>
<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>event_add()</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>void event_enable_debug_mode (void)</h2> Enable some relatively expensive debugging checks in Libevent that would normally be turned off. Generally, these checks cause code that would otherwise crash mysteriously to fail earlier with an assertion failure. Note that this method MUST be called before any events or event_bases have been created.<p>
Debug mode can currently catch the following errors: An event is re-assigned while it is added Any function is called on a non-assigned event<p>
Note that debugging mode uses memory to track every event that has been initialized (via event_assign, event_set, or event_new) but not yet released (via event_free or event_debug_unassign). If you want to use debug mode, and you find yourself running out of memory, you will need to use event_debug_unassign to explicitly stop tracking events that are no longer considered set-up.<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>event_debug_unassign()</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>void event_free (struct <b>event</b> *)</h2> Deallocate a struct event * returned by  <b>event_new()</b>. If the event is pending or active, first make it non-pending and non-active.</div>
<div class="subsection">
<h2>void event_get_assignment (const struct <b>event</b> *event, struct <b>event_base</b> **base_out, <b>evutil_socket_t</b> *fd_out, short *events_out, <b>event_callback_fn</b> *callback_out, void **arg_out)</h2> Extract  <i>all</i> of arguments given to construct a given event. The <b>event_base</b> is copied into *base_out, the fd is copied into *fd_out, and so on.<p>
If any of the '_out' arguments is NULL, it will be ignored.</div>
<div class="subsection">
<h2>size_t event_get_struct_event_size (void)</h2> Return the size of struct event that the Libevent library was compiled with. This will be NO GREATER than sizeof(struct event) if you're running with the same version of Libevent that your application was built with, but otherwise might not.<p>
Note that it might be SMALLER than sizeof(struct event) if some future version of Libevent adds extra padding to the end of struct event. We might do this to help ensure ABI-compatibility between different versions of Libevent.</div>
<div class="subsection">
<h2>const char** event_get_supported_methods (void)</h2> Gets all event notification mechanisms supported by Libevent. This functions returns the event mechanism in order preferred by Libevent. Note that this list will include all backends that Libevent has compiled-in support for, and will not necessarily check your OS to see whether it has the required resources.<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
an array with pointers to the names of support methods. The end of the array is indicated by a NULL pointer. If an error is encountered NULL is returned.</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>const char* event_get_version (void)</h2> Get the Libevent version. Note that this will give you the version of the library that you're currently linked against, not the version of the headers that you've compiled against.<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
a string containing the version number of Libevent</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>ev_uint32_t event_get_version_number (void)</h2> Return a numeric representation of Libevent's version. Note that this will give you the version of the library that you're currently linked against, not the version of the headers you've used to compile.<p>
The format uses one byte each for the major, minor, and patchlevel parts of the version number. The low-order byte is unused. For example, version 2.0.1-alpha has a numeric representation of 0x02000100</div>
<div class="subsection">
<h2>int event_initialized (const struct <b>event</b> *ev)</h2> Test if an event structure might be initialized. The  <b>event_initialized()</b> function can be used to check if an event has been initialized.<p>
Warning: This function is only useful for distinguishing a a zeroed-out piece of memory from an initialized event, it can easily be confused by uninitialized memory. Thus, it should ONLY be used to distinguish an initialized event from zero.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>ev</i> an event structure to be tested</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
1 if the structure might be initialized, or 0 if it has not been initialized</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>struct <b>event</b>* event_new (struct <b>event_base</b> *, <b>evutil_socket_t</b>, short, <b>event_callback_fn</b>, void *)</h2> Allocate and asssign a new event structure, ready to be added. The function  <b>event_new()</b> returns a new event that can be used in future calls to <b>event_add()</b> and <b>event_del()</b>. The fd and events arguments determine which conditions will trigger the event; the callback and callback_arg arguments tell Libevent what to do when the event becomes active.<p>
If events contains one of EV_READ, EV_WRITE, or EV_READ|EV_WRITE, then fd is a file descriptor or socket that should get monitored for readiness to read, readiness to write, or readiness for either operation (respectively). If events contains EV_SIGNAL, then fd is a signal number to wait for. If events contains none of those flags, then the event can be triggered only by a timeout or by manual activation with <b>event_active()</b>: In this case, fd must be -1.<p>
The EV_PERSIST flag can also be passed in the events argument: it makes <b>event_add()</b> persistent until <b>event_del()</b> is called.<p>
The EV_ET flag is compatible with EV_READ and EV_WRITE, and supported only by certain backends. It tells Libevent to use edge-triggered events.<p>
The EV_TIMEOUT flag has no effect here.<p>
It is okay to have multiple events all listening on the same fds; but they must either all be edge-triggered, or all not be edge triggerd.<p>
When the event becomes active, the event loop will run the provided callbuck function, with three arguments. The first will be the provided fd value. The second will be a bitfield of the events that triggered: EV_READ, EV_WRITE, or EV_SIGNAL. Here the EV_TIMEOUT flag indicates that a timeout occurred, and EV_ET indicates that an edge-triggered event occurred. The third event will be the callback_arg pointer that you provide.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>base</i> the event base to which the event should be attached.<div style="height: 0.00em;">
&#160;</div>
<i>fd</i> the file descriptor or signal to be monitored, or -1.<div style="height: 0.00em;">
&#160;</div>
<i>events</i> desired events to monitor: bitfield of EV_READ, EV_WRITE, EV_SIGNAL, EV_PERSIST, EV_ET.<div style="height: 0.00em;">
&#160;</div>
<i>callback</i> callback function to be invoked when the event occurs<div style="height: 0.00em;">
&#160;</div>
<i>callback_arg</i> an argument to be passed to the callback function</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
a newly allocated struct event that must later be freed with <b>event_free()</b>.</div>
<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>event_free()</b>, <b>event_add()</b>, <b>event_del()</b>, <b>event_assign()</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int event_pending (const struct <b>event</b> *ev, shortevents, struct timeval *tv)</h2> Checks if a specific event is pending or scheduled.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>ev</i> an event struct previously passed to <b>event_add()</b><div style="height: 0.00em;">
&#160;</div>
<i>events</i> the requested event type; any of EV_TIMEOUT|EV_READ| EV_WRITE|EV_SIGNAL<div style="height: 0.00em;">
&#160;</div>
<i>tv</i> if this field is not NULL, and the event has a timeout, this field is set to hold the time at which the timeout will expire.</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
true if the event is pending on any of the events in 'what', (that is to say, it has been added), or 0 if the event is not added.</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int event_priority_set (struct <b>event</b> *, int)</h2> Assign a priority to an event.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>ev</i> an event struct<div style="height: 0.00em;">
&#160;</div>
<i>priority</i> the new priority to be assigned</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 if successful, or -1 if an error occurred</div>
<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>event_priority_init()</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int event_reinit (struct <b>event_base</b> *base)</h2> Reinitialize the event base after a fork. Some event mechanisms do not survive across fork. The event base needs to be reinitialized with the  <b>event_reinit()</b> function.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>base</i> the event base that needs to be re-initialized</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 if successful, or -1 if some events could not be re-added.</div>
<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>event_base_new()</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>void event_set_fatal_callback (<b>event_fatal_cb</b>cb)</h2> Override Libevent's behavior in the event of a fatal internal error. By default, Libevent will call exit(1) if a programming error makes it impossible to continue correct operation. This function allows you to supply another callback instead. Note that if the function is ever invoked, something is wrong with your program, or with Libevent: any subsequent calls to Libevent may result in undefined behavior.<p>
Libevent will (almost) always log an _EVENT_LOG_ERR message before calling this function; look at the last log message to see why Libevent has died.</div>
<div class="subsection">
<h2>void event_set_log_callback (<b>event_log_cb</b>cb)</h2> Redirect Libevent's log messages.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>cb</i> a function taking two arguments: an integer severity between _EVENT_LOG_DEBUG and _EVENT_LOG_ERR, and a string. If cb is NULL, then the default log is used.</div>
<p>
NOTE: The function you provide <i>must not</i> call any other libevent functionality. Doing so can produce undefined behavior.</div>
<div class="subsection">
<h2>void event_set_mem_functions (void *(*)(size_t sz)malloc_fn, void *(*)(void *ptr, size_t sz)realloc_fn, void(*)(void *ptr)free_fn)</h2> Override the functions that Libevent uses for memory management. Usually, Libevent uses the standard libc functions malloc, realloc, and free to allocate memory. Passing replacements for those functions to  <b>event_set_mem_functions()</b> overrides this behavior.<p>
Note that all memory returned from Libevent will be allocated by the replacement functions rather than by malloc() and realloc(). Thus, if you have replaced those functions, it will not be appropriate to free() memory that you get from Libevent. Instead, you must use the free_fn replacement that you provided.<p>
Note also that if you are going to call this function, you should do so before any call to any Libevent function that does allocation. Otherwise, those funtions will allocate their memory using malloc(), but then later free it using your provided free_fn.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>malloc_fn</i> A replacement for malloc.<div style="height: 0.00em;">
&#160;</div>
<i>realloc_fn</i> A replacement for realloc<div style="height: 0.00em;">
&#160;</div>
<i>free_fn</i> A replacement for free.</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
</div>
<div class="section">
<h1>Author</h1> Generated automatically by Doxygen for libevent from the source code.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tr>
<td class="foot-date">
Tue Jan 27 2015</td>
<td class="foot-os" align="right">
libevent</td>
</tr>
</table>
</div>
</body>
<>

