<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
PUFFS_FRAMEBUF(3)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
PUFFS_FRAMEBUF(3)</td>
<td class="head-vol" align="center">
Library Functions Manual</td>
<td class="head-rtitle" align="right">
PUFFS_FRAMEBUF(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">puffs_framebuf</b> &#8212; <span class="desc">buffering and event handling for networked file systems</span></div>
<div class="section">
<h1 id="x4c494252415259">LIBRARY</h1> <span class="lib">puffs Convenience Library (libpuffs, &#45;lpuffs)</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">puffs.h</a>&gt;</b><p>
<i class="ftype">struct puffs_framebuf *</i><br>
<b class="fname">puffs_framebuf_make</b>();<p>
<i class="ftype">void</i><br>
<b class="fname">puffs_framebuf_destroy</b>(<i class="farg" style="white-space:nowrap;">struct puffs_framebuf *pufbuf</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">puffs_framebuf_recycle</b>(<i class="farg" style="white-space:nowrap;">struct puffs_framebuf *pufbuf</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_framebuf_reserve_space</b>(<i class="farg" style="white-space:nowrap;">struct puffs_framebuf *pufbuf</i>, <i class="farg" style="white-space:nowrap;">size_t space</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_framebuf_putdata</b>(<i class="farg">struct puffs_framebuf *pufbuf</i>, <i class="farg">const void *data</i>, <i class="farg">size_t dlen</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_framebuf_putdata_atoff</b>(<i class="farg">struct puffs_framebuf *pufbuf</i>, <i class="farg">size_t offset</i>, <i class="farg">const void *data</i>, <i class="farg">size_t dlen</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_framebuf_getdata</b>(<i class="farg">struct puffs_framebuf *pufbuf</i>, <i class="farg">void *data</i>, <i class="farg">size_t dlen</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_framebuf_getdata_atoff</b>(<i class="farg">struct puffs_framebuf *pufbuf</i>, <i class="farg">size_t offset</i>, <i class="farg">void *data</i>, <i class="farg">size_t dlen</i>);<p>
<i class="ftype">size_t</i><br>
<b class="fname">puffs_framebuf_telloff</b>(<i class="farg" style="white-space:nowrap;">struct puffs_framebuf *pufbuf</i>);<p>
<i class="ftype">size_t</i><br>
<b class="fname">puffs_framebuf_tellsize</b>(<i class="farg" style="white-space:nowrap;">struct puffs_framebuf *pufbuf</i>);<p>
<i class="ftype">size_t</i><br>
<b class="fname">puffs_framebuf_remaining</b>(<i class="farg" style="white-space:nowrap;">struct puffs_framebuf *pufbuf</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_framebuf_seekset</b>(<i class="farg" style="white-space:nowrap;">struct puffs_framebuf *pufbuf</i>, <i class="farg" style="white-space:nowrap;">size_t offset</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_framebuf_getwindow</b>(<i class="farg">struct puffs_framebuf *pufbuf</i>, <i class="farg">size_t offset</i>, <i class="farg">void **winp</i>, <i class="farg">size_t *winlen</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_framev_enqueue_cc</b>(<i class="farg">struct puffs_cc *pcc</i>, <i class="farg">int fd</i>, <i class="farg">struct puffs_framebuf *pufbuf</i>, <i class="farg">int flags</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">puffs_framev_cb</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">int fd</i>, <i class="farg">struct puffs_framebuf *pufbuf</i>, <i class="farg">void *arg</i>, <i class="farg">int flags</i>, <i class="farg">int error</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">puffs_framev_enqueue_cb</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">int fd</i>, <i class="farg">struct puffs_framebuf *pufbuf</i>, <i class="farg">puffs_framebuf_cb fcb</i>, <i class="farg">void *fcb_arg</i>, <i class="farg">int flags</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">puffs_framev_enqueue_justsend</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">int fd</i>, <i class="farg">struct puffs_framebuf *pufbuf</i>, <i class="farg">int waitreply</i>, <i class="farg">int flags</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">puffs_framev_enqueue_directsend</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">int fd</i>, <i class="farg">struct puffs_framebuf *pufbuf</i>, <i class="farg">int flags</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">puffs_framev_enqueue_directreceive</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">int fd</i>, <i class="farg">struct puffs_framebuf *pufbuf</i>, <i class="farg">int flags</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_framev_framebuf_ccpromote</b>(<i class="farg">struct puffs_framebuf *pufbuf</i>, <i class="farg">struct puffs_cc *pcc</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_framev_enqueue_waitevent</b>(<i class="farg" style="white-space:nowrap;">struct puffs_cc *pcc</i>, <i class="farg" style="white-space:nowrap;">int fd</i>, <i class="farg" style="white-space:nowrap;">int *what</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_framev_readframe_fn</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">struct puffs_framebuf *pufbuf</i>, <i class="farg">int fd</i>, <i class="farg">int *done</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_framev_writeframe_fn</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">struct puffs_framebuf *pufbuf</i>, <i class="farg">int fd</i>, <i class="farg">int *done</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_framev_cmpframe_fn</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">struct puffs_framebuf *cmp1</i>, <i class="farg">struct puffs_framebuf *cmp2</i>, <i class="farg">int *notresp</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">puffs_framev_gotframe_fn</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">struct puffs_framebuf *pufbuf</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">puffs_framev_fdnotify_fn</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">int fd</i>, <i class="farg">int what</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">puffs_framev_init</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">puffs_framev_readframe_fn rfb</i>, <i class="farg">puffs_framev_writeframe_fn wfb</i>, <i class="farg">puffs_framev_cmpframe_fn cmpfb</i>, <i class="farg">puffs_framev_gotframe_fn gotfb</i>, <i class="farg">puffs_framev_fdnotify_fn fdnotfn</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_framev_addfd</b>(<i class="farg" style="white-space:nowrap;">struct puffs_usermount *pu</i>, <i class="farg" style="white-space:nowrap;">int fd</i>, <i class="farg" style="white-space:nowrap;">int what</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_framev_enablefd</b>(<i class="farg" style="white-space:nowrap;">struct puffs_usermount *pu</i>, <i class="farg" style="white-space:nowrap;">int fd</i>, <i class="farg" style="white-space:nowrap;">int what</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_framev_disablefd</b>(<i class="farg" style="white-space:nowrap;">struct puffs_usermount *pu</i>, <i class="farg" style="white-space:nowrap;">int fd</i>, <i class="farg" style="white-space:nowrap;">int what</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_framev_removefd</b>(<i class="farg" style="white-space:nowrap;">struct puffs_usermount *pu</i>, <i class="farg" style="white-space:nowrap;">int fd</i>, <i class="farg" style="white-space:nowrap;">int error</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">puffs_framev_unmountonclose</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">int fd</i>, <i class="farg">int what</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <b class="name">puffs_framebuf</b> routines provide buffering and an event loop structured around the buffers. It operates on top of the puffs continuation framework, <a class="link-man" href="../html3/puffs_cc.html">puffs_cc(3)</a>, and multiplexes execution automatically to an instance whenever one is runnable.<p>
The file system is entered in three different ways:<ul style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-bul">
<li class="list-bul" style="margin-top: 1.00em;">
An event arrives from the kernel and the <a class="link-man" href="../html3/puffs_ops.html">puffs_ops(3)</a> callbacks are called to start processing the event.</li>
<li class="list-bul" style="margin-top: 1.00em;">
A file system which has sent out a request receives a response. Execution is resumed from the place where the file system yielded.</li>
<li class="list-bul" style="margin-top: 1.00em;">
A request from a peer arrives. A request is an incoming PDU which is not a response to any outstanding request.</li>
</ul>
<p>
<b class="name">puffs_framebuf</b> is used by defining various callbacks and providing I/O descriptors, which are then monitored for activity by the library. A descriptor, when present, can be either enabled or disabled for input and output. If a descriptor is not enabled for a certain direction, the callbacks will not be called even if there were activity on the descriptor. For example, even if a network socket has been added and there is input data in the socket buffer, the read callback will be called only if the socket has been enabled for reading.<p>
File descriptors are treated like sockets: they have two sides, a read side and a write side. The framework determines that one side of the descriptor has been closed if the supplied I/O callbacks return an error or if the I/O multiplexing call says a side has been closed. It is still possible, from the framework perspective, to write to a file descriptor whose read side is closed. However, it is not possible to wait for a response on such a file descriptor. Conversely, it is possible to read responses from a descriptor whose write side is closed. It should be stressed that the implementation underlying the file descriptor might not support this.<p>
The following callbacks can be defined, cf. <b class="fname">puffs_framev_init</b>(), and all are optional. None of them should block, because this would cause the entire file server to block. One option is to make the descriptors non-blocking before adding them.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
rfb</dt>
<dd class="list-tag" style="margin-left: 9.00ex;">
Read a frame from the file descriptor onto the specified buffer.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
wfb</dt>
<dd class="list-tag" style="margin-left: 9.00ex;">
Write a frame from the specified buffer into the file descriptor.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
cmpfb</dt>
<dd class="list-tag" style="margin-left: 9.00ex;">
Identify if a buffer is the response to the specified buffer.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
gotfb</dt>
<dd class="list-tag" style="margin-left: 9.00ex;">
Called iff no outstanding request matches the incoming frame. In other words, this is called when we receive a request from a peer.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
fdnotfn</dt>
<dd class="list-tag" style="margin-left: 9.00ex;">
Receive notifications about a change-of-state in a file descriptor's status.</dd>
</dl>
<p>
Better descriptions for each callback are given below.<p>
The buffers of <b class="name">puffs_framebuf</b> provide automatic memory management of buffers for the file servers. They provide a cursor to the current buffer offset. Reading or writing data through the normal routines will advance that cursor. Additionally, the buffer size is provided to the user. It represents the maximum offset where data was written.<p>
Generally the write functions will fail if the cannot allocate enough memory to satisfy the buffer length requirements. Read functions will fail if the amount of data written to the buffer is not large enough to satisfy the read.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_framebuf_make</b>()</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Create a buffer. Return the address of the buffer or <span class="define">NULL</span> in case no memory was available.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_framebuf_destroy</b>(<i class="farg">pufbuf</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Free memory used by buffer.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_framebuf_recycle</b>(<i class="farg">pufbuf</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Reset offsets so that buffer can be reused. Does not free memory or reallocate memory.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_framebuf_reserve_space</b>(<i class="farg">pufbuf</i>, <i class="farg">space</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Make sure that the buffer has <i class="arg">space</i> bytes of available memory starting from the current offset. This is not strictly necessary, but can be used for optimizations where it is known in advance how much memory will be required.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_framebuf_putdata</b>(<i class="farg">pufbuf</i>, <i class="farg">data</i>, <i class="farg">dlen</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Write <i class="arg">dlen</i> amount of data from the address <i class="arg">data</i> into the buffer. Moves the offset cursor forward <i class="arg">dlen</i> bytes.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_framebuf_putdata_atoff</b>(<i class="farg">pufbuf</i>, <i class="farg">offset</i>, <i class="farg">data</i>, <i class="farg">dlen</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Like <b class="fname">puffs_framebuf_putdata</b>(), except writes data at buffer offset <i class="arg">offset</i>. It is legal to write past the current end of the buffer. Does NOT modify the current offset cursor.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_framebuf_getdata</b>(<i class="farg">pufbuf</i>, <i class="farg">data</i>, <i class="farg">dlen</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Read <i class="arg">dlen</i> bytes of data from the buffer into <i class="arg">data</i>. Advances the offset cursor.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_framebuf_getdata_atoff</b>(<i class="farg">pufbuf</i>, <i class="farg">offset</i>, <i class="farg">data</i>, <i class="farg">dlen</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Read data from buffer position <i class="arg">offset</i>. Does NOT modify the offset cursor.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_framebuf_telloff</b>(<i class="farg">pufbuf</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Return the offset into the buffer.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_framebuf_tellsize</b>(<i class="farg">pufbuf</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Return the maximum offset where data has been written, i.e. buffer size.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_framebuf_remaining</b>(<i class="farg">pufbuf</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Distance from current offset to the end of the buffer, i.e. size-offset.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_framebuf_seekset</b>(<i class="farg">pufbuf</i>, <i class="farg">offset</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Set the offset cursor to the position <i class="arg">offset</i>. This does NOT modify the buffer size, but reserves at least enough memory memory for a write to <i class="arg">offset</i> and will fail if memory cannot be allocated.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_framebuf_getwindow</b>(<i class="farg">pufbuf</i>, <i class="farg">offset</i>, <i class="farg">winp</i>, <i class="farg">winlen</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Get a direct memory window into the buffer starting from <i class="arg">offset</i>. The maximum mapped window size will be <i class="arg">winlen</i> bytes, but this routine might return a smaller window and the caller should always check the actual mapped size after the call. The window is returned in <i class="arg">winp</i>. This function not modify the buffer offset, but it DOES set the buffer size to <i class="arg">offset +</i> <i class="arg">winlen</i> in case that value is greater than the current size. The window is valid until the next until the next <b class="fname">puffs_framebuf</b>() call operating on the buffer in question.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_framev_enqueue_cc</b>(<i class="farg">pcc</i>, <i class="farg">fd</i>, <i class="farg">pufbuf</i>, <i class="farg">flags</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Add the buffer <i class="arg">pufbuf</i> to outgoing queue of descriptor <i class="arg">fd</i> and yield with the continuation <i class="arg">pcc</i>. Execution is resumed once a response is received. Returns 0 if the buffer was successfully enqueued (not necessarily delivered) and non-zero to signal a non-recoverable error.<p>
Usually the buffer is placed at the end of the output queue. However, if <i class="arg">flags</i> contains <span class="define">PUFFS_FBQUEUE_URGENT</span>, <i class="arg">pufbuf</i> is placed in the front of the queue to be sent immediately after the current PDU (if any) has been sent.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_framev_enqueue_cb</b>(<i class="farg">pu</i>, <i class="farg">fd</i>, <i class="farg">pufbuf</i>, <i class="farg">fcb</i>, <i class="farg">fcb_arg</i>, <i class="farg">flags</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Enqueue the buffer <i class="arg">pufbuf</i> for outgoing data and immediately return. Once a response arrives, the callback <b class="fname">fcb</b>() will be called with the argument <i class="arg">fcb_arg</i>. The callback function <b class="fname">fcb</b>() is responsible for freeing the buffer. Returns 0 if the buffer was successfully enqueued (not necessarily delivered) and non-zero to signal a non-recoverable error.<p>
See <b class="fname">puffs_framev_enqueue_cc</b>() for <i class="arg">flags</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_framev_cb</b>(<i class="farg">pu</i>, <i class="farg">pufbuf</i>, <i class="farg">arg</i>, <i class="farg">error</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Callback function. Called when a response to a specific request arrives from the server. If <i class="arg">error</i> is non-zero, the framework was unable to obtain a response and the function should not examine the contents of <i class="arg">pufbuf</i>, only do resource cleanup. May not block.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_framev_enqueue_justsend</b>(<i class="farg">pu</i>, <i class="farg">fd</i>, <i class="farg">pufbuf</i>, <i class="farg">waitreply</i>, <i class="farg">flags</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Enqueue the buffer <i class="arg">pufbuf</i> for outgoing traffic and immediately return. The parameter <i class="arg">waitreply</i> can be used to control if the buffer is to be freed immediately after sending of if a response is expected and the buffer should be freed only after the response arrives (receiving an unexpected message from the server is treated as an error). Returns 0 if the buffer was successfully enqueued (not necessarily delivered) and non-zero to signal a non-recoverable error.<p>
See <b class="fname">puffs_framev_enqueue_cc</b>() for <i class="arg">flags</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_framev_enqueue_directsend</b>(<i class="farg">pcc</i>, <i class="farg">fd</i>, <i class="farg">pufbuf</i>, <i class="farg">flags</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Acts like <b class="fname">puffs_framev_enqueue_justsend</b>() with the exception that the call yields until the frame has been sent. As opposed to <b class="fname">puffs_framev_enqueue_cc</b>(), the routine does not wait for input, but returns immediately after sending the frame.<p>
See <b class="fname">puffs_framev_enqueue_cc</b>() for <i class="arg">flags</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_framev_enqueue_directreceive</b>(<i class="farg">pcc</i>, <i class="farg">fd</i>, <i class="farg">pufbuf</i>, <i class="farg">flags</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Receive data into <i class="arg">pufbuf</i>. This routine yields until a complete frame has been read into the buffer by the readframe routine.<p>
See <b class="fname">puffs_framev_enqueue_cc</b>() for <i class="arg">flags</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_framev_framebuf_ccpromote</b>(<i class="farg">pufbuf</i>, <i class="farg">pcc</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Promote the framebuffer <i class="arg">pufbuf</i> sent with <b class="fname">puffs_framev_enqueue_cb</b>() or <b class="fname">puffs_framev_enqueue_justsend</b>() to a wait using <i class="arg">pcc</i> and yield until the result arrives. The response from the file server for <i class="arg">pufbuf</i> must not yet have arrived. If sent with <b class="fname">puffs_framev_enqueue_justsend</b>(), the call must be expecting a response.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_framev_enqueue_waitevent</b>(<i class="farg">pcc</i>, <i class="farg">fd</i>, <i class="farg">what</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Waits for an event in <i class="arg">what</i> to happen on file descriptor <i class="arg">fd</i>. The events which happened are returned back in <i class="arg">what</i>. The possible events are <span class="define">PUFFS_FBIO_READ</span>, <span class="define">PUFFS_FBIO_WRITE</span>, and <span class="define">PUFFS_FBIO_ERROR</span>, specifying read, write and error conditions, respectively. Error is always checked.<p>
This call does not depend on if the events were previously enabled on the file descriptor - the specified events are always checked regardless.<p>
There is currently no other way to cancel or timeout a call except by removing the file descriptor in question. This may change in the future.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_framev_readframe_fn</b>(<i class="farg">pu</i>, <i class="farg">pufbuf</i>, <i class="farg">fd</i>, <i class="farg">done</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Callback function. Read at most one frame from file descriptor <i class="arg">fd</i> into the buffer <i class="arg">pufbuf</i>. If a complete frame is read, the value pointed to by <i class="arg">done</i> must be set to 1. This function should return 0 on success (even if a complete frame was not yet read) and a non-zero <span class="errno">errno</span> to signal a fatal error. In case a fatal error is returned, the read side of the file descriptor is marked closed. This routine will be called with the same buffer argument until a complete frame has been read. May not block.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_framev_writeframe_fn</b>(<i class="farg">pu</i>, <i class="farg">pufbuf</i>, <i class="farg">fd</i>, <i class="farg">done</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Write the frame contained in <i class="arg">pufbuf</i> to the file descriptor <i class="arg">fd</i>. In case the entire frame is successfully written, <i class="arg">*done</i> should be set to 1. This function should return 0 on success (even if a complete frame was not yet written) and a non-zero <span class="errno">errno</span> to signal a fatal error. In case a fatal error is returned, the write side of the file descriptor is marked closed. This routine will be called with the same buffer argument until the complete frame has been written. May not block.<p>
It is a good idea to make sure that this function can handle a possible <span class="define">SIGPIPE</span> caused by a closed connection. For example, the file server can opt to trap <span class="define">SIGPIPE</span> or, if writing to a socket, call <b class="fname">send</b>() with the flag <span class="define">MSG_NOSIGNAL</span> instead of using <b class="fname">write</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_framev_cmpframe_fn</b>(<i class="farg">pu</i>, <i class="farg">pufbuf_cmp1</i>, <i class="farg">pufbuf_cmp2</i>, <i class="farg">notresp</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Compare the file system internal request tags in <i class="arg">pufbuf_cmp1</i> and <i class="arg">pufbuf_cmp2</i>. Should return 0 if the tags are equal, 1 if first buffer's tag is greater than the second and &#45;1 if it is smaller. The definitions "greater" and "smaller" are used transparently by the library, e.g. like <a class="link-man" href="../html3/qsort.html">qsort(3)</a>. If it can be determined from <i class="arg">pufbuf_cmp1</i> that it is not a response to any outstanding request, <i class="arg">notresp</i> should be set to non-zero. This will cause <b class="name">puffs_framebuf</b> to skip the test of the buffer against the rest of the outstanding request. May not block.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_framev_gotframe_fn</b>(<i class="farg">pu</i>, <i class="farg">pufbuf</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Called when no outstanding request matches an incoming frame. The ownership of <i class="arg">pufbuf</i> is transferred to the called function and must be destroyed once processing is over. May not block.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_framev_fdnotify_fn</b>(<i class="farg">pu</i>, <i class="farg">fd</i>, <i class="farg">what</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Is called when the read or write side of the file descriptor <i class="arg">fd</i> is closed. It is called once for each side, the bitmask parameter <i class="arg">what</i> specified what is currently closed: <span class="define">PUFFS_FBIO_READ</span> and <span class="define">PUFFS_FBIO_WRITE</span> for read and write, respectively.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_framev_init</b>(<i class="farg">pu</i>, <i class="farg">rfb</i>, <i class="farg">wfb</i>, <i class="farg">cmpfb</i>, <i class="farg">gotfb</i>, <i class="farg">fdnotfn</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Initializes the given callbacks to the system. They will be used when <b class="fname">puffs_mainloop</b>() is called. The framework provides the routines <b class="fname">puffs_framev_removeonclose</b>() and <b class="fname">puffs_framev_unmountonclose</b>(), which can be given as <i class="arg">fdnotfn</i>. The first one removes the file descriptor once both sides are closed while the second one unmounts the file system and exits the mainloop.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_framev_addfd</b>(<i class="farg">pu</i>, <i class="farg">fd</i>, <i class="farg">what</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Add file descriptor <i class="arg">fd</i> to be handled by the framework. It is legal to add a file descriptor either before calling <b class="fname">puffs_mainloop</b>() or at time when running. The parameter <i class="arg">what</i> controls enabling of input and output events and can be a bitwise combination of <span class="define">PUFFS_FBIO_READ</span> and <span class="define">PUFFS_FBIO_WRITE</span>. If not specified, the descriptor will be in a disabled state.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_framev_enablefd</b>(<i class="farg">pu</i>, <i class="farg">fd</i>, <i class="farg">what</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Enable events of type <i class="arg">what</i> for file descriptor <i class="arg">fd</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_framev_disablefd</b>(<i class="farg">pu</i>, <i class="farg">fd</i>, <i class="farg">what</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Disable events of type <i class="arg">what</i> for file descriptor <i class="arg">fd</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_framev_removefd</b>(<i class="farg">pu</i>, <i class="farg">fd</i>, <i class="farg">error</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Remove file descriptor <i class="arg">fd</i> from the list of descriptors handled by the framework. Removing a file descriptor causes all operations blocked either on output or input to be released with the error value <i class="arg">error</i>. In case 0 is supplied as this parameter, <span class="errno">ECONNRESET</span> is used.<p>
The file system <span class="emph">must</span> explicitly remove each fd it has added. A good place to do this is <b class="fname">puffs_framev_fdnotify_fn</b>() or <b class="fname">puffs_node_reclaim</b>(), depending a little on the structure of the file system.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_framev_unmountonclose</b>(<i class="farg">pu</i>, <i class="farg">fd</i>, <i class="farg">what</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
This is library provided convenience routine for <b class="fname">puffs_framev_fdnotify_fn</b>(). It unmounts the file system when both the read and write side are closed. It is useful for file systems such as <a class="link-man" href="../html8/mount_psshfs.html">mount_psshfs(8)</a> which depend on a single connection.</dd>
</dl>
</div>
<div class="section">
<h1 id="x52455455524e2056414c554553">RETURN VALUES</h1> These functions generally return &#45;1 to signal error and set <span class="errno">errno</span> to indicate the type of error.</div>
<div class="section">
<h1 id="x434f4445205245464552454e434553">CODE REFERENCES</h1> The current users of <b class="name">puffs_framebuf</b> in the tree are <a class="link-man" href="../html8/mount_psshfs.html">mount_psshfs(8)</a> and <a class="link-man" href="../html8/mount_9p.html">mount_9p(8)</a>. See <i class="file">src/usr.sbin/puffs/mount_psshfs</i> and <i class="file">src/usr.sbin/puffs/mount_9p</i> for the respective usage examples.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html3/puffs.html">puffs(3)</a>, <a class="link-man" href="../html3/puffs_cc.html">puffs_cc(3)</a>, <a class="link-man" href="../html3/puffs_ops.html">puffs_ops(3)</a><p>
<span class="ref"><span class="ref-auth">Antti Kantee</span>, <span class="ref-title">Using puffs for Implementing Client-Server Distributed File Systems</span>, <i class="ref-issue">Helsinki University of Technology</i>, <span class="ref-rep">Tech Report TKK-TKO-B157</span>, <span class="ref-date">September 2007</span>.</span><p>
<span class="ref"><span class="ref-auth">Antti Kantee</span>, <span class="ref-title">Send and Receive of File System Protocols: Userspace Approach With puffs</span>, <i class="ref-jrnl">Proceedings of AsiaBSDCon 2008</i>, <span class="ref-page">pp. 55-70</span>, <span class="ref-date">March 2008</span>.</span></div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
September 6, 2008</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

