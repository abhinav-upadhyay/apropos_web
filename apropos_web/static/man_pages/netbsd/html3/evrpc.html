<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/../4/strict.dtd">
>
<head>
<meta http-equiv="Content-Type" content="te../; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
evrpc(3)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
evrpc(3)</td>
<td class="head-vol" align="center">
Library Functions Manual</td>
<td class="head-rtitle" align="right">
evrpc(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> evrpc &#45;<p>
This header files provides basic support for an RPC server and client.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>SYNOPSIS</h1> #include &lt;event2/rpc.h&gt;<div style="height: 0.00em;">
&#160;</div>
<div class="subsection">
<h2>Macros</h2><br>
#define <b>EVRPC_GENERATE</b>(rpcname, reqstruct, rplystruct)<div style="height: 0.00em;">
&#160;</div>
<i>Generates the code for receiving and sending an RPC message. </i> #define  <b>EVRPC_HEADER</b>(rpcname, reqstruct, rplystruct)<div style="height: 0.00em;">
&#160;</div>
<i>Creates the definitions and prototypes for an RPC. </i> #define  <b>EVRPC_MAKE_CTX</b>(rpcname, reqstruct, rplystruct, pool, request, reply, cb, cbarg)<div style="height: 0.00em;">
&#160;</div>
<i>Creates a context structure that contains rpc specific information. </i> #define  <b>EVRPC_MAKE_REQUEST</b>(name, pool, request, reply, cb, cbarg)   evrpc_send_request_##name((pool), (request), (reply), (cb), (cbarg))<div style="height: 0.00em;">
&#160;</div>
<i>launches an RPC and sends it to the server </i> #define  <b>EVRPC_REGISTER</b>(base, name, request, reply, callback, cbarg)<div style="height: 0.00em;">
&#160;</div>
<i>register RPCs with the HTTP Server </i> #define  <b>EVRPC_REQUEST_DONE</b>(rpc_req)<div style="height: 0.00em;">
&#160;</div>
<i>Creates the reply to an RPC request. </i> #define  <b>EVRPC_REQUEST_HTTP</b>(rpc_req)   (rpc_req)-&gt;http_req<div style="height: 0.00em;">
&#160;</div>
<i>Provides access to the HTTP request object underlying an RPC. </i> #define  <b>EVRPC_STRUCT</b>(rpcname)   struct evrpc_req__##rpcname<div style="height: 0.00em;">
&#160;</div>
<i>The type of a specific RPC Message. </i> #define  <b>EVRPC_UNREGISTER</b>(base, name)   evrpc_unregister_rpc((base), #name)<div style="height: 0.00em;">
&#160;</div>
<i>Unregisters an already registered RPC. </i> #define  <b>EVTAG_ARRAY_ADD</b>(msg, member)   (*(msg)-&gt;base-&gt;member##_add)(msg)<div style="height: 0.00em;">
&#160;</div>
<i>Allocates a new entry in the array and returns it. </i> #define  <b>EVTAG_ARRAY_ADD_VALUE</b>(msg, member, value)   (*(msg)-&gt;base-&gt;member##_add)((msg), (value))<div style="height: 0.00em;">
&#160;</div>
<i>Adds a value to an array. </i> #define  <b>EVTAG_ARRAY_GET</b>(msg, member, offset, pvalue)   (*(msg)-&gt;base-&gt;member##_get)((msg), (offset), (pvalue))<div style="height: 0.00em;">
&#160;</div>
<i>Gets a variable at the specified offset from the array. </i> #define  <b>EVTAG_ARRAY_LEN</b>(msg, member)   ((msg)-&gt;member##_length)<div style="height: 0.00em;">
&#160;</div>
<i>Returns the number of entries in the array. </i> #define  <b>EVTAG_ASSIGN</b>(msg, member, value)   (*(msg)-&gt;base-&gt;member##_assign)((msg), (value))<div style="height: 0.00em;">
&#160;</div>
<i>Assigns a value to the member in the message. </i> #define  <b>EVTAG_ASSIGN_WITH_LEN</b>(msg, member, value, len)   (*(msg)-&gt;base-&gt;member##_assign)((msg), (value), (len))<div style="height: 0.00em;">
&#160;</div>
<i>Assigns a value to the member in the message. </i> #define  <b>EVTAG_GET</b>(msg, member, pvalue)   (*(msg)-&gt;base-&gt;member##_get)((msg), (pvalue))<div style="height: 0.00em;">
&#160;</div>
<i>Returns the value for a member. </i> #define  <b>EVTAG_GET_WITH_LEN</b>(msg, member, pvalue, plen)   (*(msg)-&gt;base-&gt;member##_get)((msg), (pvalue), (plen))<div style="height: 0.00em;">
&#160;</div>
<i>Returns the value for a member. </i> #define  <b>EVTAG_HAS</b>(msg, member)   ((msg)-&gt;member##_set == 1)<div style="height: 0.00em;">
&#160;</div>
<i>Determines if the member has been set in the message. </i> #define  <b>INPUT</b>   <b>EVRPC_INPUT</b><div style="height: 0.00em;">
&#160;</div>
<i>Deprecated alias for EVRPC_INPUT. </i> #define  <b>OUTPUT</b>   <b>EVRPC_OUTPUT</b><div style="height: 0.00em;">
&#160;</div>
<i>Deprecated alias for EVRPC_OUTPUT. </i><br>
</div>
<div class="subsection">
<h2>Enumerations</h2><br>
enum <b>EVRPC_HOOK_RESULT</b> { <b>EVRPC_TERMINATE</b> = -1, <b>EVRPC_CONTINUE</b> = 0, <b>EVRPC_PAUSE</b> = 1 }<div style="height: 0.00em;">
&#160;</div>
<i>Return value from hook processing functions. </i> enum  <b>EVRPC_HOOK_TYPE</b> { <b>EVRPC_INPUT</b>, <b>EVRPC_OUTPUT</b> }<div style="height: 0.00em;">
&#160;</div>
<i>Hooks for changing the input and output of RPCs; this can be used to implement compression, authentication, encryption, ... </i><br>
</div>
<div class="subsection">
<h2>Functions</h2><br>
void * <b>evrpc_add_hook</b> (void *vbase, enum <b>EVRPC_HOOK_TYPE</b> hook_type, int(*cb)(void *, struct evhttp_request *, struct <b>evbuffer</b> *, void *), void *cb_arg)<div style="height: 0.00em;">
&#160;</div>
<i>adds a processing hook to either an rpc base or rpc pool </i> void  <b>evrpc_free</b> (struct evrpc_base *base)<div style="height: 0.00em;">
&#160;</div>
<i>Frees the evrpc base. </i> void *  <b>evrpc_get_reply</b> (struct evrpc_req_generic *req)<div style="height: 0.00em;">
&#160;</div>
void * <b>evrpc_get_request</b> (struct evrpc_req_generic *req)<div style="height: 0.00em;">
&#160;</div>
<i>accessors for request and reply </i> void  <b>evrpc_hook_add_meta</b> (void *ctx, const char *key, const void *data, size_t data_size)<div style="height: 0.00em;">
&#160;</div>
<i>adds meta data to request </i> int  <b>evrpc_hook_find_meta</b> (void *ctx, const char *key, void **data, size_t *data_size)<div style="height: 0.00em;">
&#160;</div>
<i>retrieves meta data previously associated </i> struct evhttp_connection *  <b>evrpc_hook_get_connection</b> (void *ctx)<div style="height: 0.00em;">
&#160;</div>
<i>returns the connection object associated with the request </i> struct evrpc_base *  <b>evrpc_init</b> (struct evhttp *server)<div style="height: 0.00em;">
&#160;</div>
<i>Creates a new rpc base from which RPC requests can be received. </i> int  <b>evrpc_make_request</b> (struct evrpc_request_wrapper *ctx)<div style="height: 0.00em;">
&#160;</div>
<i>Makes an RPC request based on the provided context. </i> struct evrpc_request_wrapper *  <b>evrpc_make_request_ctx</b> (struct evrpc_pool *pool, void *request, void *reply, const char *rpcname, void(*req_marshal)(struct <b>evbuffer</b> *, void *), void(*rpl_clear)(void *), int(*rpl_unmarshal)(void *, struct <b>evbuffer</b> *), void(*cb)(struct evrpc_status *, void *, void *, void *), void *cbarg)<div style="height: 0.00em;">
&#160;</div>
<i>use EVRPC_GENERATE instead </i> void  <b>evrpc_pool_add_connection</b> (struct evrpc_pool *pool, struct evhttp_connection *evcon)<div style="height: 0.00em;">
&#160;</div>
<i>Adds a connection over which rpc can be dispatched to the pool. </i> void  <b>evrpc_pool_free</b> (struct evrpc_pool *pool)<div style="height: 0.00em;">
&#160;</div>
<i>frees an rpc connection pool </i> struct evrpc_pool *  <b>evrpc_pool_new</b> (struct <b>event_base</b> *base)<div style="height: 0.00em;">
&#160;</div>
<i>creates an rpc connection pool </i> void  <b>evrpc_pool_remove_connection</b> (struct evrpc_pool *pool, struct evhttp_connection *evcon)<div style="height: 0.00em;">
&#160;</div>
<i>Removes a connection from the pool. </i> void  <b>evrpc_pool_set_timeout</b> (struct evrpc_pool *pool, int timeout_in_secs)<div style="height: 0.00em;">
&#160;</div>
<i>Sets the timeout in secs after which a request has to complete. </i> int  <b>evrpc_register_generic</b> (struct evrpc_base *base, const char *name, void(*callback)(struct evrpc_req_generic *, void *), void *cbarg, void *(*req_new)(void *), void *req_new_arg, void(*req_free)(void *), int(*req_unmarshal)(void *, struct <b>evbuffer</b> *), void *(*rpl_new)(void *), void *rpl_new_arg, void(*rpl_free)(void *), int(*rpl_complete)(void *), void(*rpl_marshal)(struct <b>evbuffer</b> *, void *))<div style="height: 0.00em;">
&#160;</div>
<i>Function for registering a generic RPC with the RPC base. </i> int  <b>evrpc_register_rpc</b> (struct evrpc_base *, struct evrpc *, void(*)(struct evrpc_req_generic *, void *), void *)<div style="height: 0.00em;">
&#160;</div>
<i>Low level function for registering an RPC with a server. </i> int  <b>evrpc_remove_hook</b> (void *vbase, enum <b>EVRPC_HOOK_TYPE</b> hook_type, void *handle)<div style="height: 0.00em;">
&#160;</div>
<i>removes a previously added hook </i> void  <b>evrpc_request_done</b> (struct evrpc_req_generic *req)<div style="height: 0.00em;">
&#160;</div>
<i>completes the server response to an rpc request </i> struct evrpc_pool *  <b>evrpc_request_get_pool</b> (struct evrpc_request_wrapper *ctx)<div style="height: 0.00em;">
&#160;</div>
<i>accessors for obscure and undocumented functionality </i> void  <b>evrpc_request_set_cb</b> (struct evrpc_request_wrapper *ctx, void(*cb)(struct evrpc_status *, void *request, void *reply, void *arg), void *cb_arg)<div style="height: 0.00em;">
&#160;</div>
void <b>evrpc_request_set_pool</b> (struct evrpc_request_wrapper *ctx, struct evrpc_pool *pool)<div style="height: 0.00em;">
&#160;</div>
int <b>evrpc_resume_request</b> (void *vbase, void *ctx, enum <b>EVRPC_HOOK_RESULT</b> res)<div style="height: 0.00em;">
&#160;</div>
<i>resume a paused request </i> int  <b>evrpc_send_request_generic</b> (struct evrpc_pool *pool, void *request, void *reply, void(*cb)(struct evrpc_status *, void *, void *, void *), void *cb_arg, const char *rpcname, void(*req_marshal)(struct <b>evbuffer</b> *, void *), void(*rpl_clear)(void *), int(*rpl_unmarshal)(void *, struct <b>evbuffer</b> *))<div style="height: 0.00em;">
&#160;</div>
<i>Function for sending a generic RPC request. </i> int  <b>evrpc_unregister_rpc</b> (struct evrpc_base *base, const char *name)<div style="height: 0.00em;">
&#160;</div>
<br>
</div>
</div>
<div class="section">
<h1>Detailed Description</h1> This header files provides basic support for an RPC server and client.<div style="height: 1.00em;">
&#160;</div>
To support RPCs in a server, every supported RPC command needs to be defined and registered.<p>
<b>EVRPC_HEADER(SendCommand, Request, Reply)</b>;<p>
SendCommand is the name of the RPC command. Request is the name of a structure generated by event_rpcgen.py. It contains all parameters relating to the SendCommand RPC. The server needs to fill in the Reply structure. Reply is the name of a structure generated by event_rpcgen.py. It contains the answer to the RPC.<p>
To register an RPC with an HTTP server, you need to first create an RPC base with:<p>
struct evrpc_base *base = evrpc_init(http);<p>
A specific RPC can then be registered with<p>
<b>EVRPC_REGISTER(base, SendCommand, Request, Reply,  FunctionCB, arg)</b>;<p>
when the server receives an appropriately formatted RPC, the user callback is invoked. The callback needs to fill in the reply structure.<p>
void FunctionCB(EVRPC_STRUCT(SendCommand)* rpc, void *arg);<p>
To send the reply, call <b>EVRPC_REQUEST_DONE(rpc)</b>;<p>
See the regression test for an example.</div>
<div class="section">
<h1>Macro Definition Documentation</h1><div class="subsection">
<h2>#define EVRPC_GENERATE(rpcname, reqstruct, rplystruct)</h2>  <b>Value:</b><p>
<br>
int evrpc_send_request_##rpcname(struct evrpc_pool *pool,         struct reqstruct *request, struct rplystruct *reply,            void (*cb)(struct evrpc_status *,                       struct reqstruct *, struct rplystruct *, void *cbarg),          void *cbarg) {                          return evrpc_send_request_generic(pool, request, reply,         (void (*)(struct evrpc_status *, void *, void *, void *))cb,         cbarg,                                  #rpcname,                                   (void (*)(struct evbuffer *, void *))reqstruct##_marshal,           (void (*)(void *))rplystruct##_clear,                   (int (*)(void *, struct evbuffer *))rplystruct##_unmarshal); }<br>
<p>
Generates the code for receiving and sending an RPC message. EVRPC_GENERATE is used to create the code corresponding to sending and receiving a particular RPC message<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>rpcname</i> the name of the RPC<div style="height: 0.00em;">
&#160;</div>
<i>reqstruct</i> the name of the RPC request structure<div style="height: 0.00em;">
&#160;</div>
<i>replystruct</i> the name of the RPC reply structure</div>
<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>EVRPC_HEADER()</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>#define EVRPC_HEADER(rpcname, reqstruct, rplystruct)</h2>  <b>Value:</b><p>
<br>
EVRPC_STRUCT(rpcname) {     struct evrpc_hook_meta *hook_meta;     struct reqstruct* request;     struct rplystruct* reply;     struct evrpc* rpc;     struct evhttp_request* http_req;     struct evbuffer* rpc_data; };                                   int evrpc_send_request_##rpcname(struct evrpc_pool *,     struct reqstruct *, struct rplystruct *,     void (*)(struct evrpc_status *,     struct reqstruct *, struct rplystruct *, void *cbarg),      void *);<br>
<p>
Creates the definitions and prototypes for an RPC. You need to use EVRPC_HEADER to create structures and function prototypes needed by the server and client implementation. The structures have to be defined in an .rpc file and converted to source code via event_rpcgen.py<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>rpcname</i> the name of the RPC<div style="height: 0.00em;">
&#160;</div>
<i>reqstruct</i> the name of the RPC request structure<div style="height: 0.00em;">
&#160;</div>
<i>replystruct</i> the name of the RPC reply structure</div>
<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>EVRPC_GENERATE()</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>#define EVRPC_MAKE_CTX(rpcname, reqstruct, rplystruct, pool, request, reply, cb, cbarg)</h2>  <b>Value:</b><p>
<br>
evrpc_make_request_ctx(pool, request, reply,                 #rpcname,                                   (void (*)(struct evbuffer *, void *))reqstruct##_marshal,           (void (*)(void *))rplystruct##_clear,                   (int (*)(void *, struct evbuffer *))rplystruct##_unmarshal,         (void (*)(struct evrpc_status *, void *, void *, void *))cb,         cbarg)<br>
<p>
Creates a context structure that contains rpc specific information. EVRPC_MAKE_CTX is used to populate a RPC specific context that contains information about marshaling the RPC data types.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>rpcname</i> the name of the RPC<div style="height: 0.00em;">
&#160;</div>
<i>reqstruct</i> the name of the RPC request structure<div style="height: 0.00em;">
&#160;</div>
<i>replystruct</i> the name of the RPC reply structure<div style="height: 0.00em;">
&#160;</div>
<i>pool</i> the evrpc_pool over which to make the request<div style="height: 0.00em;">
&#160;</div>
<i>request</i> a pointer to the RPC request structure object<div style="height: 0.00em;">
&#160;</div>
<i>reply</i> a pointer to the RPC reply structure object<div style="height: 0.00em;">
&#160;</div>
<i>cb</i> the callback function to call when the RPC has completed<div style="height: 0.00em;">
&#160;</div>
<i>cbarg</i> the argument to supply to the callback</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>#define EVRPC_MAKE_REQUEST(name, pool, request, reply, cb, cbarg)   evrpc_send_request_##name((pool), (request), (reply), (cb), (cbarg))</h2> launches an RPC and sends it to the server  <b>EVRPC_MAKE_REQUEST()</b> is used by the client to send an RPC to the server.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>name</i> the name of the RPC<div style="height: 0.00em;">
&#160;</div>
<i>pool</i> the evrpc_pool that contains the connection objects over which the request should be sent.<div style="height: 0.00em;">
&#160;</div>
<i>request</i> a pointer to the RPC request structure - it contains the data to be sent to the server.<div style="height: 0.00em;">
&#160;</div>
<i>reply</i> a pointer to the RPC reply structure. It is going to be filled if the request was answered successfully<div style="height: 0.00em;">
&#160;</div>
<i>cb</i> the callback to invoke when the RPC request has been answered<div style="height: 0.00em;">
&#160;</div>
<i>cbarg</i> an additional argument to be passed to the client</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 on success, -1 on failure</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>#define EVRPC_REGISTER(base, name, request, reply, callback, cbarg)</h2>  <b>Value:</b><p>
<br>
evrpc_register_generic(base, #name,                     (void (*)(struct evrpc_req_generic *, void *))callback, cbarg,         (void *(*)(void *))request##_new, NULL,                 (void (*)(void *))request##_free,                       (int (*)(void *, struct evbuffer *))request##_unmarshal,            (void *(*)(void *))reply##_new, NULL,                   (void (*)(void *))reply##_free,         (int (*)(void *))reply##_complete,         (void (*)(struct evbuffer *, void *))reply##_marshal)<br>
<p>
register RPCs with the HTTP Server registers a new RPC with the HTTP server, each RPC needs to have a unique name under which it can be identified.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>base</i> the evrpc_base structure in which the RPC should be registered.<div style="height: 0.00em;">
&#160;</div>
<i>name</i> the name of the RPC<div style="height: 0.00em;">
&#160;</div>
<i>request</i> the name of the RPC request structure<div style="height: 0.00em;">
&#160;</div>
<i>reply</i> the name of the RPC reply structure<div style="height: 0.00em;">
&#160;</div>
<i>callback</i> the callback that should be invoked when the RPC is received. The callback has the following prototype void (<i>callback)(</i><b>EVRPC_STRUCT(Message)</b><i></i><b> rpc, void *arg)</b><div style="height: 0.00em;">
&#160;</div>
<i>cbarg</i> an additional parameter that can be passed to the callback. The parameter can be used to carry around state.</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>#define EVRPC_REQUEST_DONE(rpc_req)</h2>  <b>Value:</b><p>
<br>
do {   struct evrpc_req_generic *_req = (struct evrpc_req_generic *)(rpc_req); \<br>
  evrpc_request_done(_req);                 } while (0)<br>
<p>
Creates the reply to an RPC request. EVRPC_REQUEST_DONE is used to answer a request; the reply is expected to have been filled in. The request and reply pointers become invalid after this call has finished.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>rpc_req</i> the rpc request structure provided to the server callback</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>#define EVRPC_REQUEST_HTTP(rpc_req)   (rpc_req)-&gt;http_req</h2> Provides access to the HTTP request object underlying an RPC. Access to the underlying http object; can be used to look at headers or for getting the remote ip address<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>rpc_req</i> the rpc request structure provided to the server callback</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
an struct evhttp_request object that can be inspected for HTTP headers or sender information.</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>#define EVRPC_STRUCT(rpcname)   struct evrpc_req__##rpcname</h2> The type of a specific RPC Message.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>rpcname</i> the name of the RPC message</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>#define EVRPC_UNREGISTER(base, name)   evrpc_unregister_rpc((base), #name)</h2> Unregisters an already registered RPC.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>base</i> the evrpc_base object from which to unregister an RPC<div style="height: 0.00em;">
&#160;</div>
<i>name</i> the name of the rpc to unregister</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
-1 on error or 0 when successful.</div>
<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>EVRPC_REGISTER()</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>#define EVTAG_ASSIGN(msg, member, value)   (*(msg)-&gt;base-&gt;member##_assign)((msg), (value))</h2> Assigns a value to the member in the message.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>msg</i> the message to which to assign a value<div style="height: 0.00em;">
&#160;</div>
<i>member</i> the name of the member variable<div style="height: 0.00em;">
&#160;</div>
<i>value</i> the value to assign</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>#define EVTAG_ASSIGN_WITH_LEN(msg, member, value, len)   (*(msg)-&gt;base-&gt;member##_assign)((msg), (value), (len))</h2> Assigns a value to the member in the message.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>msg</i> the message to which to assign a value<div style="height: 0.00em;">
&#160;</div>
<i>member</i> the name of the member variable<div style="height: 0.00em;">
&#160;</div>
<i>value</i> the value to assign<div style="height: 0.00em;">
&#160;</div>
<i>len</i> the length of the value</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>#define EVTAG_GET(msg, member, pvalue)   (*(msg)-&gt;base-&gt;member##_get)((msg), (pvalue))</h2> Returns the value for a member.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>msg</i> the message from which to get the value<div style="height: 0.00em;">
&#160;</div>
<i>member</i> the name of the member variable<div style="height: 0.00em;">
&#160;</div>
<i>pvalue</i> a pointer to the variable to hold the value</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 on success, -1 otherwise.</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>#define EVTAG_GET_WITH_LEN(msg, member, pvalue, plen)   (*(msg)-&gt;base-&gt;member##_get)((msg), (pvalue), (plen))</h2> Returns the value for a member.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>msg</i> the message from which to get the value<div style="height: 0.00em;">
&#160;</div>
<i>member</i> the name of the member variable<div style="height: 0.00em;">
&#160;</div>
<i>pvalue</i> a pointer to the variable to hold the value<div style="height: 0.00em;">
&#160;</div>
<i>plen</i> a pointer to the length of the value</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 on success, -1 otherwise.</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>#define EVTAG_HAS(msg, member)   ((msg)-&gt;member##_set == 1)</h2> Determines if the member has been set in the message.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>msg</i> the message to inspect<div style="height: 0.00em;">
&#160;</div>
<i>member</i> the member variable to test for presences</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
1 if it's present or 0 otherwise.</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>#define INPUT   <b>EVRPC_INPUT</b></h2> Deprecated alias for EVRPC_INPUT. Not available on windows, where it conflicts with platform headers.</div>
<div class="subsection">
<h2>#define OUTPUT   <b>EVRPC_OUTPUT</b></h2> Deprecated alias for EVRPC_OUTPUT. Not available on windows, where it conflicts with platform headers.</div>
</div>
<div class="section">
<h1>Enumeration Type Documentation</h1><div class="subsection">
<h2>enum <b>EVRPC_HOOK_RESULT</b></h2> Return value from hook processing functions.<p>
<b>Enumerator</b><br>
<dl>
<dt>
<b></b><i>EVRPC_TERMINATE </i><b></b><i></i></dt>
<dd>
indicates the rpc should be terminated</dd>
</dl>
<dl>
<dt>
<b></b><i>EVRPC_CONTINUE </i><b></b><i></i></dt>
<dd>
continue processing the rpc</dd>
</dl>
<dl>
<dt>
<b></b><i>EVRPC_PAUSE </i><b></b><i></i></dt>
<dd>
pause processing request until resumed</dd>
</dl>
</div>
<div class="subsection">
<h2>enum <b>EVRPC_HOOK_TYPE</b></h2> Hooks for changing the input and output of RPCs; this can be used to implement compression, authentication, encryption, ...<p>
<b>Enumerator</b><br>
<dl>
<dt>
<b></b><i>EVRPC_INPUT </i><b></b><i></i></dt>
<dd>
apply the function to an input hook</dd>
</dl>
<dl>
<dt>
<b></b><i>EVRPC_OUTPUT </i><b></b><i></i></dt>
<dd>
apply the function to an output hook</dd>
</dl>
</div>
</div>
<div class="section">
<h1>Function Documentation</h1><div class="subsection">
<h2>void* evrpc_add_hook (void *vbase, enum <b>EVRPC_HOOK_TYPE</b>hook_type, int(*)(void *, struct evhttp_request *, struct <b>evbuffer</b> *, void *)cb, void *cb_arg)</h2> adds a processing hook to either an rpc base or rpc pool If a hook returns TERMINATE, the processing is aborted. On CONTINUE, the request is immediately processed after the hook returns. If the hook returns PAUSE, request processing stops until  <b>evrpc_resume_request()</b> has been called.<p>
The add functions return handles that can be used for removing hooks.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>vbase</i> a pointer to either struct evrpc_base or struct evrpc_pool<div style="height: 0.00em;">
&#160;</div>
<i>hook_type</i> either INPUT or OUTPUT<div style="height: 0.00em;">
&#160;</div>
<i>cb</i> the callback to call when the hook is activated<div style="height: 0.00em;">
&#160;</div>
<i>cb_arg</i> an additional argument for the callback</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
a handle to the hook so it can be removed later</div>
<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>evrpc_remove_hook()</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>void evrpc_free (struct evrpc_base *base)</h2> Frees the evrpc base. For now, you are responsible for making sure that no rpcs are ongoing.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>base</i> the evrpc_base object to be freed</div>
<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>evrpc_init</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>void evrpc_hook_add_meta (void *ctx, const char *key, const void *data, size_tdata_size)</h2> adds meta data to request  <b>evrpc_hook_add_meta()</b> allows hooks to add meta data to a request. for a client request, the meta data can be inserted by an outgoing request hook and retrieved by the incoming request hook.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>ctx</i> the context provided to the hook call<div style="height: 0.00em;">
&#160;</div>
<i>key</i> a NUL-terminated c-string<div style="height: 0.00em;">
&#160;</div>
<i>data</i> the data to be associated with the key<div style="height: 0.00em;">
&#160;</div>
<i>data_size</i> the size of the data</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int evrpc_hook_find_meta (void *ctx, const char *key, void **data, size_t *data_size)</h2> retrieves meta data previously associated  <b>evrpc_hook_find_meta()</b> can be used to retrieve meta data associated to a request by a previous hook.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>ctx</i> the context provided to the hook call<div style="height: 0.00em;">
&#160;</div>
<i>key</i> a NUL-terminated c-string<div style="height: 0.00em;">
&#160;</div>
<i>data</i> pointer to a data pointer that will contain the retrieved data<div style="height: 0.00em;">
&#160;</div>
<i>data_size</i> pointer to the size of the data</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 on success or -1 on failure</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>struct evhttp_connection* evrpc_hook_get_connection (void *ctx)</h2> returns the connection object associated with the request<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>ctx</i> the context provided to the hook call</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
a pointer to the evhttp_connection object</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>struct evrpc_base* evrpc_init (struct evhttp *server)</h2> Creates a new rpc base from which RPC requests can be received.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>server</i> a pointer to an existing HTTP server</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
a newly allocated evrpc_base struct</div>
<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>evrpc_free()</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int evrpc_make_request (struct evrpc_request_wrapper *ctx)</h2> Makes an RPC request based on the provided context. This is a low-level function and should not be used directly unless a custom context object is provided. Use  <b>EVRPC_MAKE_REQUEST()</b> instead.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>ctx</i> a context from <b>EVRPC_MAKE_CTX()</b></div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
0 on success, -1 otherwise.</div>
<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>EVRPC_MAKE_REQUEST()</b>, <b>EVRPC_MAKE_CTX()</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>void evrpc_pool_add_connection (struct evrpc_pool *pool, struct evhttp_connection *evcon)</h2> Adds a connection over which rpc can be dispatched to the pool. The connection object must have been newly created.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>pool</i> the pool to which to add the connection<div style="height: 0.00em;">
&#160;</div>
<i>evcon</i> the connection to add to the pool.</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>void evrpc_pool_free (struct evrpc_pool *pool)</h2> frees an rpc connection pool<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>pool</i> a pointer to an evrpc_pool allocated via <b>evrpc_pool_new()</b></div>
<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>evrpc_pool_new()</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>struct evrpc_pool* evrpc_pool_new (struct <b>event_base</b> *base)</h2> creates an rpc connection pool a pool has a number of connections associated with it. rpc requests are always made via a pool.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>base</i> a pointer to an struct event_based object; can be left NULL in singled-threaded applications</div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
a newly allocated struct evrpc_pool object</div>
<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>evrpc_pool_free()</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>void evrpc_pool_remove_connection (struct evrpc_pool *pool, struct evhttp_connection *evcon)</h2> Removes a connection from the pool. The connection object must have been newly created.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>pool</i> the pool from which to remove the connection<div style="height: 0.00em;">
&#160;</div>
<i>evcon</i> the connection to remove from the pool.</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>void evrpc_pool_set_timeout (struct evrpc_pool *pool, inttimeout_in_secs)</h2> Sets the timeout in secs after which a request has to complete. The RPC is completely aborted if it does not complete by then. Setting the timeout to 0 means that it never timeouts and can be used to implement callback type RPCs.<p>
Any connection already in the pool will be updated with the new timeout. Connections added to the pool after set_timeout has be called receive the pool timeout only if no timeout has been set for the connection itself.<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>pool</i> a pointer to a struct evrpc_pool object<div style="height: 0.00em;">
&#160;</div>
<i>timeout_in_secs</i> the number of seconds after which a request should timeout and a failure be returned to the callback.</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int evrpc_register_generic (struct evrpc_base *base, const char *name, void(*)(struct evrpc_req_generic *, void *)callback, void *cbarg, void *(*)(void *)req_new, void *req_new_arg, void(*)(void *)req_free, int(*)(void *, struct <b>evbuffer</b> *)req_unmarshal, void *(*)(void *)rpl_new, void *rpl_new_arg, void(*)(void *)rpl_free, int(*)(void *)rpl_complete, void(*)(struct <b>evbuffer</b> *, void *)rpl_marshal)</h2> Function for registering a generic RPC with the RPC base. Do not call this function directly, use  <b>EVRPC_REGISTER()</b> instead.<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>EVRPC_REGISTER()</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int evrpc_register_rpc (struct evrpc_base *, struct evrpc *, void(*)(struct evrpc_req_generic *, void *), void *)</h2> Low level function for registering an RPC with a server. Use  <b>EVRPC_REGISTER()</b> instead.<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>EVRPC_REGISTER()</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int evrpc_remove_hook (void *vbase, enum <b>EVRPC_HOOK_TYPE</b>hook_type, void *handle)</h2> removes a previously added hook<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>vbase</i> a pointer to either struct evrpc_base or struct evrpc_pool<div style="height: 0.00em;">
&#160;</div>
<i>hook_type</i> either INPUT or OUTPUT<div style="height: 0.00em;">
&#160;</div>
<i>handle</i> a handle returned by <b>evrpc_add_hook()</b></div>
<p>
<b>Returns:</b><div style="margin-left: 4.00ex;">
1 on success or 0 on failure</div>
<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>evrpc_add_hook()</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int evrpc_resume_request (void *vbase, void *ctx, enum <b>EVRPC_HOOK_RESULT</b>res)</h2> resume a paused request<p>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>vbase</i> a pointer to either struct evrpc_base or struct evrpc_pool<div style="height: 0.00em;">
&#160;</div>
<i>ctx</i> the context pointer provided to the original hook call</div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int evrpc_send_request_generic (struct evrpc_pool *pool, void *request, void *reply, void(*)(struct evrpc_status *, void *, void *, void *)cb, void *cb_arg, const char *rpcname, void(*)(struct <b>evbuffer</b> *, void *)req_marshal, void(*)(void *)rpl_clear, int(*)(void *, struct <b>evbuffer</b> *)rpl_unmarshal)</h2> Function for sending a generic RPC request. Do not call this function directly, use  <b>EVRPC_MAKE_REQUEST()</b> instead.<p>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>EVRPC_MAKE_REQUEST()</b></div>
<p>
<div style="height: 1.00em;">
&#160;</div>
</div>
</div>
<div class="section">
<h1>Author</h1> Generated automatically by Doxygen for libevent from the source code.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tr>
<td class="foot-date">
Tue Jan 27 2015</td>
<td class="foot-os" align="right">
libevent</td>
</tr>
</table>
</div>
</body>
<>

