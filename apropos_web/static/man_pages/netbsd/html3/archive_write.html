<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
archive_write(3)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
archive_write(3)</td>
<td class="head-vol" align="center">
Library Functions Manual</td>
<td class="head-rtitle" align="right">
archive_write(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">archive_write_new</b>, <b class="name">archive_write_set_format_cpio</b>, <b class="name">archive_write_set_format_pax</b>, <b class="name">archive_write_set_format_pax_restricted</b>, <b class="name">archive_write_set_format_shar</b>, <b class="name">archive_write_set_format_shar_binary</b>, <b class="name">archive_write_set_format_ustar</b>, <b class="name">archive_write_get_bytes_per_block</b>, <b class="name">archive_write_set_bytes_per_block</b>, <b class="name">archive_write_set_bytes_in_last_block</b>, <b class="name">archive_write_set_compression_bzip2</b>, <b class="name">archive_write_set_compression_compress</b>, <b class="name">archive_write_set_compression_gzip</b>, <b class="name">archive_write_set_compression_none</b>, <b class="name">archive_write_set_compression_program</b>, <b class="name">archive_write_set_compressor_options</b>, <b class="name">archive_write_set_format_options</b>, <b class="name">archive_write_set_options</b>, <b class="name">archive_write_open</b>, <b class="name">archive_write_open_fd</b>, <b class="name">archive_write_open_FILE</b>, <b class="name">archive_write_open_filename</b>, <b class="name">archive_write_open_memory</b>, <b class="name">archive_write_header</b>, <b class="name">archive_write_data</b>, <b class="name">archive_write_finish_entry</b>, <b class="name">archive_write_close</b>, <b class="name">archive_write_finish</b> &#8212; <span class="desc">functions for creating archives</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">archive.h</a>&gt;</b><p>
<i class="ftype">struct archive *</i><br>
<b class="fname">archive_write_new</b>(<i class="farg" style="white-space:nowrap;">void</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">archive_write_get_bytes_per_block</b>(<i class="farg" style="white-space:nowrap;">struct archive *</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">archive_write_set_bytes_per_block</b>(<i class="farg" style="white-space:nowrap;">struct archive *</i>, <i class="farg" style="white-space:nowrap;">int bytes_per_block</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">archive_write_set_bytes_in_last_block</b>(<i class="farg" style="white-space:nowrap;">struct archive *</i>, <i class="farg" style="white-space:nowrap;">int</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">archive_write_set_compression_bzip2</b>(<i class="farg" style="white-space:nowrap;">struct archive *</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">archive_write_set_compression_compress</b>(<i class="farg" style="white-space:nowrap;">struct archive *</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">archive_write_set_compression_gzip</b>(<i class="farg" style="white-space:nowrap;">struct archive *</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">archive_write_set_compression_none</b>(<i class="farg" style="white-space:nowrap;">struct archive *</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">archive_write_set_compression_program</b>(<i class="farg" style="white-space:nowrap;">struct archive *</i>, <i class="farg" style="white-space:nowrap;">const char * cmd</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">archive_write_set_format_cpio</b>(<i class="farg" style="white-space:nowrap;">struct archive *</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">archive_write_set_format_pax</b>(<i class="farg" style="white-space:nowrap;">struct archive *</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">archive_write_set_format_pax_restricted</b>(<i class="farg" style="white-space:nowrap;">struct archive *</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">archive_write_set_format_shar</b>(<i class="farg" style="white-space:nowrap;">struct archive *</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">archive_write_set_format_shar_binary</b>(<i class="farg" style="white-space:nowrap;">struct archive *</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">archive_write_set_format_ustar</b>(<i class="farg" style="white-space:nowrap;">struct archive *</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">archive_write_set_format_options</b>(<i class="farg" style="white-space:nowrap;">struct archive *</i>, <i class="farg" style="white-space:nowrap;">const char *</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">archive_write_set_compressor_options</b>(<i class="farg" style="white-space:nowrap;">struct archive *</i>, <i class="farg" style="white-space:nowrap;">const char *</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">archive_write_set_options</b>(<i class="farg" style="white-space:nowrap;">struct archive *</i>, <i class="farg" style="white-space:nowrap;">const char *</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">archive_write_open</b>(<i class="farg">struct archive *</i>, <i class="farg">void *client_data</i>, <i class="farg">archive_open_callback *</i>, <i class="farg">archive_write_callback *</i>, <i class="farg">archive_close_callback *</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">archive_write_open_fd</b>(<i class="farg" style="white-space:nowrap;">struct archive *</i>, <i class="farg" style="white-space:nowrap;">int fd</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">archive_write_open_FILE</b>(<i class="farg" style="white-space:nowrap;">struct archive *</i>, <i class="farg" style="white-space:nowrap;">FILE *file</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">archive_write_open_filename</b>(<i class="farg" style="white-space:nowrap;">struct archive *</i>, <i class="farg" style="white-space:nowrap;">const char *filename</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">archive_write_open_memory</b>(<i class="farg">struct archive *</i>, <i class="farg">void *buffer</i>, <i class="farg">size_t bufferSize</i>, <i class="farg">size_t *outUsed</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">archive_write_header</b>(<i class="farg" style="white-space:nowrap;">struct archive *</i>, <i class="farg" style="white-space:nowrap;">struct archive_entry *</i>);<p>
<i class="ftype">ssize_t</i><br>
<b class="fname">archive_write_data</b>(<i class="farg" style="white-space:nowrap;">struct archive *</i>, <i class="farg" style="white-space:nowrap;">const void *</i>, <i class="farg" style="white-space:nowrap;">size_t</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">archive_write_finish_entry</b>(<i class="farg" style="white-space:nowrap;">struct archive *</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">archive_write_close</b>(<i class="farg" style="white-space:nowrap;">struct archive *</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">archive_write_finish</b>(<i class="farg" style="white-space:nowrap;">struct archive *</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> These functions provide a complete API for creating streaming archive files. The general process is to first create the struct archive object, set any desired options, initialize the archive, append entries, then close the archive and release all resources. The following summary describes the functions in approximately the order they are ordinarily used:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">archive_write_new</b>()</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Allocates and initializes a struct archive object suitable for writing a tar archive.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">archive_write_set_bytes_per_block</b>()</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Sets the block size used for writing the archive data. Every call to the write callback function, except possibly the last one, will use this value for the length. The third parameter is a boolean that specifies whether or not the final block written will be padded to the full block size. If it is zero, the last block will not be padded. If it is non-zero, padding will be added both before and after compression. The default is to use a block size of 10240 bytes and to pad the last block. Note that a block size of zero will suppress internal blocking and cause writes to be sent directly to the write callback as they occur.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">archive_write_get_bytes_per_block</b>()</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Retrieve the block size to be used for writing. A value of -1 here indicates that the library should use default values. A value of zero indicates that internal blocking is suppressed.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">archive_write_set_bytes_in_last_block</b>()</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Sets the block size used for writing the last block. If this value is zero, the last block will be padded to the same size as the other blocks. Otherwise, the final block will be padded to a multiple of this size. In particular, setting it to 1 will cause the final block to not be padded. For compressed output, any padding generated by this option is applied only after the compression. The uncompressed data is always unpadded. The default is to pad the last block to the full block size (note that <b class="fname">archive_write_open_filename</b>() will set this based on the file type). Unlike the other &#8220;set&#8221; functions, this function can be called after the archive is opened.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">archive_write_get_bytes_in_last_block</b>()</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Retrieve the currently-set value for last block size. A value of -1 here indicates that the library should use default values.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">archive_write_set_format_cpio</b>(), <b class="fname">archive_write_set_format_pax</b>(), <b class="fname">archive_write_set_format_pax_restricted</b>(), <b class="fname">archive_write_set_format_shar</b>(), <b class="fname">archive_write_set_format_shar_binary</b>(), <b class="fname">archive_write_set_format_ustar</b>()</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Sets the format that will be used for the archive. The library can write POSIX octet-oriented cpio format archives, POSIX-standard &#8220;pax interchange&#8221; format archives, traditional &#8220;shar&#8221; archives, enhanced &#8220;binary&#8221; shar archives that store a variety of file attributes and handle binary files, and POSIX-standard &#8220;ustar&#8221; archives. The pax interchange format is a backwards-compatible tar format that adds key/value attributes to each entry and supports arbitrary filenames, linknames, uids, sizes, etc. &#8220;Restricted pax interchange format&#8221; is the library default; this is the same as pax format, but suppresses the pax extended header for most normal files. In most cases, this will result in ordinary ustar archives.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">archive_write_set_compression_bzip2</b>(), <b class="fname">archive_write_set_compression_compress</b>(), <b class="fname">archive_write_set_compression_gzip</b>(), <b class="fname">archive_write_set_compression_none</b>()</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The resulting archive will be compressed as specified. Note that the compressed output is always properly blocked.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">archive_write_set_compression_program</b>()</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The archive will be fed into the specified compression program. The output of that program is blocked and written to the client write callbacks.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">archive_write_set_compressor_options</b>(), <b class="fname">archive_write_set_format_options</b>(), <b class="fname">archive_write_set_options</b>()</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Specifies options that will be passed to the currently-enabled compressor and/or format writer. The argument is a comma-separated list of individual options. Individual options have one of the following forms:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">option=value</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The option/value pair will be provided to every module. Modules that do not accept an option with this name will ignore it.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">option</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The option will be provided to every module with a value of &#8220;1&#8221;.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">!option</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The option will be provided to every module with a NULL value.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="arg">module:option=value</i>, <i class="arg">module:option</i>, <i class="arg">module:!option</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
As above, but the corresponding option and value will be provided only to modules whose name matches <i class="arg">module</i>.</dd>
</dl>
The return value will be <b class="flag">ARCHIVE_OK</b> if any module accepts the option, or <b class="flag">ARCHIVE_WARN</b> if no module accepted the option, or <b class="flag">ARCHIVE_FATAL</b> if there was a fatal error while attempting to process the option.<p>
The currently supported options are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
Compressor gzip</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">compression-level</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The value is interpreted as a decimal integer specifying the gzip compression level.</dd>
</dl>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
Compressor xz</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">compression-level</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The value is interpreted as a decimal integer specifying the compression level.</dd>
</dl>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
Format mtree</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">cksum</b>, <b class="flag">device</b>, <b class="flag">flags</b>, <b class="flag">gid</b>, <b class="flag">gname</b>, <b class="flag">indent</b>, <b class="flag">link</b>, <b class="flag">md5</b>, <b class="flag">mode</b>, <b class="flag">nlink</b>, <b class="flag">rmd160</b>, <b class="flag">sha1</b>, <b class="flag">sha256</b>, <b class="flag">sha384</b>, <b class="flag">sha512</b>, <b class="flag">size</b>, <b class="flag">time</b>, <b class="flag">uid</b>, <b class="flag">uname</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Enable a particular keyword in the mtree output. Prefix with an exclamation mark to disable the corresponding keyword. The default is equivalent to &#8220;device, flags, gid, gname, link, mode, nlink, size, time, type, uid, uname&#8221;.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">all</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Enables all of the above keywords.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">use-set</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Enables generation of <b class="flag">/set</b> lines that specify default values for the following files and/or directories.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<b class="flag">indent</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
XXX needs explanation XXX</dd>
</dl>
</dd>
</dl>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">archive_write_open</b>()</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Freeze the settings, open the archive, and prepare for writing entries. This is the most generic form of this function, which accepts pointers to three callback functions which will be invoked by the compression layer to write the constructed archive.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">archive_write_open_fd</b>()</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
A convenience form of <b class="fname">archive_write_open</b>() that accepts a file descriptor. The <b class="fname">archive_write_open_fd</b>() function is safe for use with tape drives or other block-oriented devices.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">archive_write_open_FILE</b>()</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
A convenience form of <b class="fname">archive_write_open</b>() that accepts a <i class="ftype">FILE *</i> pointer. Note that <b class="fname">archive_write_open_FILE</b>() is not safe for writing to tape drives or other devices that require correct blocking.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">archive_write_open_file</b>()</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
A deprecated synonym for <b class="fname">archive_write_open_filename</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">archive_write_open_filename</b>()</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
A convenience form of <b class="fname">archive_write_open</b>() that accepts a filename. A NULL argument indicates that the output should be written to standard output; an argument of &#8220;-&#8221; will open a file with that name. If you have not invoked <b class="fname">archive_write_set_bytes_in_last_block</b>(), then <b class="fname">archive_write_open_filename</b>() will adjust the last-block padding depending on the file: it will enable padding when writing to standard output or to a character or block device node, it will disable padding otherwise. You can override this by manually invoking <b class="fname">archive_write_set_bytes_in_last_block</b>() before calling <b class="fname">archive_write_open</b>(). The <b class="fname">archive_write_open_filename</b>() function is safe for use with tape drives or other block-oriented devices.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">archive_write_open_memory</b>()</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
A convenience form of <b class="fname">archive_write_open</b>() that accepts a pointer to a block of memory that will receive the archive. The final <i class="ftype">size_t *</i> argument points to a variable that will be updated after each write to reflect how much of the buffer is currently in use. You should be careful to ensure that this variable remains allocated until after the archive is closed.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">archive_write_header</b>()</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Build and write a header using the data in the provided struct archive_entry structure. See <a class="link-man" href="../html3/archive_entry.html">archive_entry(3)</a> for information on creating and populating struct archive_entry objects.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">archive_write_data</b>()</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Write data corresponding to the header just written. Returns number of bytes written or -1 on error.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">archive_write_finish_entry</b>()</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Close out the entry just written. In particular, this writes out the final padding required by some formats. Ordinarily, clients never need to call this, as it is called automatically by <b class="fname">archive_write_next_header</b>() and <b class="fname">archive_write_close</b>() as needed.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">archive_write_close</b>()</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Complete the archive and invoke the close callback.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">archive_write_finish</b>()</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Invokes <b class="fname">archive_write_close</b>() if it was not invoked manually, then releases all resources. Note that this function was declared to return <i class="ftype">void</i> in libarchive 1.x, which made it impossible to detect errors when <b class="fname">archive_write_close</b>() was invoked implicitly from this function. This is corrected beginning with libarchive 2.0.</dd>
</dl>
More information about the <b class="var">struct archive</b> object and the overall design of the library can be found in the <a class="link-man" href="../html3/libarchive.html">libarchive(3)</a> overview.</div>
<div class="section">
<h1 id="x494d504c454d454e544154494f4e">IMPLEMENTATION</h1> Compression support is built-in to libarchive, which uses zlib and bzlib to handle gzip and bzip2 compression, respectively.</div>
<div class="section">
<h1 id="x434c49454e542043414c4c4241434b53">CLIENT CALLBACKS</h1> To use this library, you will need to define and register callback functions that will be invoked to write data to the resulting archive. These functions are registered by calling <b class="fname">archive_write_open</b>():<ul style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-item">
<li class="list-item" style="margin-top: 1.00em;">
<i class="ftype">typedef int</i> <b class="fname">archive_open_callback</b>(<i class="farg">struct archive *</i>, <i class="farg">void *client_data</i>)</li>
</ul>
<p>
The open callback is invoked by <b class="fname">archive_write_open</b>(). It should return <b class="flag">ARCHIVE_OK</b> if the underlying file or data source is successfully opened. If the open fails, it should call <b class="fname">archive_set_error</b>() to register an error code and message and return <b class="flag">ARCHIVE_FATAL</b>.<ul style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-item">
<li class="list-item" style="margin-top: 1.00em;">
<i class="ftype">typedef ssize_t</i> <b class="fname">archive_write_callback</b>(<i class="farg">struct archive *</i>, <i class="farg">void *client_data</i>, <i class="farg">const void *buffer</i>, <i class="farg">size_t length</i>);</li>
</ul>
<p>
The write callback is invoked whenever the library needs to write raw bytes to the archive. For correct blocking, each call to the write callback function should translate into a single <a class="link-man" href="../html2/write.html">write(2)</a> system call. This is especially critical when writing archives to tape drives. On success, the write callback should return the number of bytes actually written. On error, the callback should invoke <b class="fname">archive_set_error</b>() to register an error code and message and return -1.<ul style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-item">
<li class="list-item" style="margin-top: 1.00em;">
<i class="ftype">typedef int</i> <b class="fname">archive_close_callback</b>(<i class="farg">struct archive *</i>, <i class="farg">void *client_data</i>)</li>
</ul>
<p>
The close callback is invoked by archive_close when the archive processing is complete. The callback should return <b class="flag">ARCHIVE_OK</b> on success. On failure, the callback should invoke <b class="fname">archive_set_error</b>() to register an error code and message and return <b class="flag">ARCHIVE_FATAL.</b></div>
<div class="section">
<h1 id="x4558414d504c45">EXAMPLE</h1> The following sketch illustrates basic usage of the library. In this example, the callback functions are simply wrappers around the standard <a class="link-man" href="../html2/open.html">open(2)</a>, <a class="link-man" href="../html2/write.html">write(2)</a>, and <a class="link-man" href="../html2/close.html">close(2)</a> system calls.<p>
<pre style="margin-left: 5.00ex;" class="lit display">
#ifdef __linux__ 
#define	_FILE_OFFSET_BITS 64 
#endif 
#include &lt;sys/stat.h&gt; 
#include &lt;archive.h&gt; 
#include &lt;archive_entry.h&gt; 
#include &lt;fcntl.h&gt; 
#include &lt;stdlib.h&gt; 
#include &lt;unistd.h&gt; 
 
struct mydata { 
	const char *name; 
	int fd; 
}; 
 
int 
myopen(struct archive *a, void *client_data) 
{ 
  struct mydata *mydata = client_data; 
 
  mydata-&gt;fd = open(mydata-&gt;name, O_WRONLY | O_CREAT, 0644); 
  if (mydata-&gt;fd &gt;= 0) 
    return (ARCHIVE_OK); 
  else 
    return (ARCHIVE_FATAL); 
} 
 
ssize_t 
mywrite(struct archive *a, void *client_data, const void *buff, size_t n) 
{ 
  struct mydata *mydata = client_data; 
 
  return (write(mydata-&gt;fd, buff, n)); 
} 
 
int 
myclose(struct archive *a, void *client_data) 
{ 
  struct mydata *mydata = client_data; 
 
  if (mydata-&gt;fd &gt; 0) 
    close(mydata-&gt;fd); 
  return (0); 
} 
 
void 
write_archive(const char *outname, const char **filename) 
{ 
  struct mydata *mydata = malloc(sizeof(struct mydata)); 
  struct archive *a; 
  struct archive_entry *entry; 
  struct stat st; 
  char buff[8192]; 
  int len; 
  int fd; 
 
  a = archive_write_new(); 
  mydata-&gt;name = outname; 
  archive_write_set_compression_gzip(a); 
  archive_write_set_format_ustar(a); 
  archive_write_open(a, mydata, myopen, mywrite, myclose); 
  while (*filename) { 
    stat(*filename, &amp;st); 
    entry = archive_entry_new(); 
    archive_entry_copy_stat(entry, &amp;st); 
    archive_entry_set_pathname(entry, *filename); 
    archive_write_header(a, entry); 
    fd = open(*filename, O_RDONLY); 
    len = read(fd, buff, sizeof(buff)); 
    while ( len &gt; 0 ) { 
	archive_write_data(a, buff, len); 
	len = read(fd, buff, sizeof(buff)); 
    } 
    archive_entry_free(entry); 
    filename++; 
  } 
  archive_write_finish(a); 
} 
 
int main(int argc, const char **argv) 
{ 
	const char *outname; 
	argv++; 
	outname = argv++; 
	write_archive(outname, argv); 
	return 0; 
}</pre>
</div>
<div class="section">
<h1 id="x52455455524e2056414c554553">RETURN VALUES</h1> Most functions return <b class="flag">ARCHIVE_OK</b> (zero) on success, or one of several non-zero error codes for errors. Specific error codes include: <b class="flag">ARCHIVE_RETRY</b> for operations that might succeed if retried, <b class="flag">ARCHIVE_WARN</b> for unusual conditions that do not prevent further operations, and <b class="flag">ARCHIVE_FATAL</b> for serious errors that make remaining operations impossible. The <b class="fname">archive_errno</b>() and <b class="fname">archive_error_string</b>() functions can be used to retrieve an appropriate error code and a textual error message.<p>
<b class="fname">archive_write_new</b>() returns a pointer to a newly-allocated struct archive object.<p>
<b class="fname">archive_write_data</b>() returns a count of the number of bytes actually written. On error, -1 is returned and the <b class="fname">archive_errno</b>() and <b class="fname">archive_error_string</b>() functions will return appropriate values. Note that if the client-provided write callback function returns a non-zero value, that error will be propagated back to the caller through whatever API function resulted in that call, which may include <b class="fname">archive_write_header</b>(), <b class="fname">archive_write_data</b>(), <b class="fname">archive_write_close</b>(), or <b class="fname">archive_write_finish</b>(). The client callback can call <b class="fname">archive_set_error</b>() to provide values that can then be retrieved by <b class="fname">archive_errno</b>() and <b class="fname">archive_error_string</b>().</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html1/tar.html">tar(1)</a>, <a class="link-man" href="../html3/libarchive.html">libarchive(3)</a>, <a class="link-man" href="../html5/tar.html">tar(5)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The <b class="name">libarchive</b> library first appeared in <span class="unix">FreeBSD&#160;5.3</span>.</div>
<div class="section">
<h1 id="x415554484f5253">AUTHORS</h1> <span class="author"></span>The <b class="name">libarchive</b> library was written by <span class="author">Tim Kientzle</span> &#60;<a class="link-mail" href="mailto:kientzle@acm.org">kientzle@acm.org</a>&#62;.</div>
<div class="section">
<h1 id="x42554753">BUGS</h1> There are many peculiar bugs in historic tar implementations that may cause certain programs to reject archives written by this library. For example, several historic implementations calculated header checksums incorrectly and will thus reject valid archives; GNU tar does not fully support pax interchange format; some old tar implementations required specific field terminations.<p>
The default pax interchange format eliminates most of the historic tar limitations and provides a generic key/value attribute facility for vendor-defined extensions. One oversight in POSIX is the failure to provide a standard attribute for large device numbers. This library uses &#8220;SCHILY.devminor&#8221; and &#8220;SCHILY.devmajor&#8221; for device numbers that exceed the range supported by the backwards-compatible ustar header. These keys are compatible with Joerg Schilling's <b class="name">star</b> archiver. Other implementations may not recognize these keys and will thus be unable to correctly restore device nodes with large device numbers from archives created by this library.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
May 11, 2008</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

