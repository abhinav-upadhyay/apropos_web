<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="/static/man_pages/netbsd/style.css" type="text/css" media="all">
<title>
ATF-SH-API(3)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
ATF-SH-API(3)</td>
<td class="head-vol" align="center">
Library Functions Manual</td>
<td class="head-rtitle" align="right">
ATF-SH-API(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">atf_add_test_case</b>, <b class="name">atf_check</b>, <b class="name">atf_check_equal</b>, <b class="name">atf_config_get</b>, <b class="name">atf_config_has</b>, <b class="name">atf_expect_death</b>, <b class="name">atf_expect_exit</b>, <b class="name">atf_expect_fail</b>, <b class="name">atf_expect_pass</b>, <b class="name">atf_expect_signal</b>, <b class="name">atf_expect_timeout</b>, <b class="name">atf_fail</b>, <b class="name">atf_get</b>, <b class="name">atf_get_srcdir</b>, <b class="name">atf_pass</b>, <b class="name">atf_require_prog</b>, <b class="name">atf_set</b>, <b class="name">atf_skip</b>, <b class="name">atf_test_case</b> &#8212; <span class="desc">POSIX shell API to write ATF-based test programs</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="fname">atf_add_test_case</b>(<i class="farg" style="white-space:nowrap;">name</i>);<p>
<b class="fname">atf_check</b>(<i class="farg" style="white-space:nowrap;">command</i>);<p>
<b class="fname">atf_check_equal</b>(<i class="farg" style="white-space:nowrap;">expr1</i>, <i class="farg" style="white-space:nowrap;">expr2</i>);<p>
<b class="fname">atf_config_get</b>(<i class="farg" style="white-space:nowrap;">var_name</i>);<p>
<b class="fname">atf_config_has</b>(<i class="farg" style="white-space:nowrap;">var_name</i>);<p>
<b class="fname">atf_expect_death</b>(<i class="farg" style="white-space:nowrap;">reason</i>, <i class="farg" style="white-space:nowrap;">...</i>);<p>
<b class="fname">atf_expect_exit</b>(<i class="farg" style="white-space:nowrap;">exitcode</i>, <i class="farg" style="white-space:nowrap;">reason</i>, <i class="farg" style="white-space:nowrap;">...</i>);<p>
<b class="fname">atf_expect_fail</b>(<i class="farg" style="white-space:nowrap;">reason</i>, <i class="farg" style="white-space:nowrap;">...</i>);<p>
<b class="fname">atf_expect_pass</b>();<p>
<b class="fname">atf_expect_signal</b>(<i class="farg" style="white-space:nowrap;">signo</i>, <i class="farg" style="white-space:nowrap;">reason</i>, <i class="farg" style="white-space:nowrap;">...</i>);<p>
<b class="fname">atf_expect_timeout</b>(<i class="farg" style="white-space:nowrap;">reason</i>, <i class="farg" style="white-space:nowrap;">...</i>);<p>
<b class="fname">atf_fail</b>(<i class="farg" style="white-space:nowrap;">reason</i>);<p>
<b class="fname">atf_get</b>(<i class="farg" style="white-space:nowrap;">var_name</i>);<p>
<b class="fname">atf_get_srcdir</b>();<p>
<b class="fname">atf_pass</b>();<p>
<b class="fname">atf_require_prog</b>(<i class="farg" style="white-space:nowrap;">prog_name</i>);<p>
<b class="fname">atf_set</b>(<i class="farg" style="white-space:nowrap;">var_name</i>, <i class="farg" style="white-space:nowrap;">value</i>);<p>
<b class="fname">atf_skip</b>(<i class="farg" style="white-space:nowrap;">reason</i>);<p>
<b class="fname">atf_test_case</b>(<i class="farg" style="white-space:nowrap;">name</i>, <i class="farg" style="white-space:nowrap;">cleanup</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> ATF provides a simple but powerful interface to easily write test programs in the POSIX shell language. These are extremely helpful given that they are trivial to write due to the language simplicity and the great deal of available external tools, so they are often ideal to test other applications at the user level.<p>
Test programs written using this library must be run using the <a class="link-man" href="../1/atf-sh">atf-sh(1)</a> interpreter by putting the following on their very first line:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
#! /usr/bin/env atf-sh</pre>
<p>
Shell-based test programs always follow this template:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
atf_test_case tc1 
tc1_head() { 
    ... first test case's header ... 
} 
tc1_body() { 
    ... first test case's body ... 
} 
 
atf_test_case tc2 cleanup 
tc2_head() { 
    ... second test case's header ... 
} 
tc2_body() { 
    ... second test case's body ... 
} 
tc2_cleanup() { 
    ... second test case's cleanup ... 
} 
 
... additional test cases ... 
 
atf_init_test_cases() { 
    atf_add_test_case tc1 
    atf_add_test_case tc2 
    ... add additional test cases ... 
}</pre>
<div class="subsection">
<h2 id="x446566696e6974696f6e206f662074657374206361736573">Definition of test cases</h2> Test cases have an identifier and are composed of three different parts: the header, the body and an optional cleanup routine, all of which are described in <a class="link-man" href="../4/atf-test-case">atf-test-case(4)</a>. To define test cases, one can use the <b class="fname">atf_test_case</b>() function, which takes a first parameter specifiying the test case's name and instructs the library to set things up to accept it as a valid test case. The second parameter is optional and, if provided, must be &#8216;cleanup&#8217;; providing this parameter allows defining a cleanup routine for the test case. It is important to note that this function <span class="emph">does not</span> set the test case up for execution when the program is run. In order to do so, a later registration is needed through the <b class="fname">atf_add_test_case</b>() function detailed in <i class="link-sec"><a class="link-sec" href="#x50726f6772616d20696e697469616c697a6174696f6e">Program initialization</a></i>.<p>
Later on, one must define the three parts of the body by providing two or three functions (remember that the cleanup routine is optional). These functions are named after the test case's identifier, and are <b class="fname">&lt;id&gt;_head</b>(), <b class="fname">&lt;id&gt;_body</b>() and <b class="fname">&lt;id&gt;_cleanup.</b>() None of these take parameters when executed.</div>
<div class="subsection">
<h2 id="x50726f6772616d20696e697469616c697a6174696f6e">Program initialization</h2> The test program must define an <b class="fname">atf_init_test_cases</b>() function, which is in charge of registering the test cases that will be executed at run time by using the <b class="fname">atf_add_test_case</b>() function, which takes the name of a test case as its single parameter. This main function should not do anything else, except maybe sourcing auxiliary source files that define extra variables and functions.</div>
<div class="subsection">
<h2 id="x436f6e66696775726174696f6e207661726961626c6573">Configuration variables</h2> The test case has read-only access to the current configuration variables through the <b class="fname">atf_config_has</b>() and <b class="fname">atf_config_get</b>() methods. The former takes a single parameter specifying a variable name and returns a boolean indicating whether the variable is defined or not. The latter can take one or two parameters. If it takes only one, it specifies the variable from which to get the value, and this variable must be defined. If it takes two, the second one specifies a default value to be returned if the variable is not available.</div>
<div class="subsection">
<h2 id="x41636365737320746f2074686520736f75726365206469726563746f7279">Access to the source directory</h2> It is possible to get the path to the test case's source directory from anywhere in the test program by using the <b class="fname">atf_get_srcdir</b>() function. It is interesting to note that this can be used inside <b class="fname">atf_init_test_cases</b>() to silently include additional helper files from the source directory.</div>
<div class="subsection">
<h2 id="x526571756972696e672070726f6772616d73">Requiring programs</h2> Aside from the <b class="var">require.progs</b> meta-data variable available in the header only, one can also check for additional programs in the test case's body by using the <b class="fname">atf_require_prog</b>() function, which takes the base name or full path of a single binary. Relative paths are forbidden. If it is not found, the test case will be automatically skipped.</div>
<div class="subsection">
<h2 id="x5465737420636173652066696e616c697a6174696f6e">Test case finalization</h2> The test case finalizes either when the body reaches its end, at which point the test is assumed to have <span class="emph">passed</span>, or at any explicit call to <b class="fname">atf_pass</b>(), <b class="fname">atf_fail</b>() or <b class="fname">atf_skip</b>(). These three functions terminate the execution of the test case immediately. The cleanup routine will be processed afterwards in a completely automated way, regardless of the test case's termination reason.<p>
<b class="fname">atf_pass</b>() does not take any parameters. <b class="fname">atf_fail</b>() and <b class="fname">atf_skip</b>() take a single string parameter that describes why the test case failed or was skipped, respectively. It is very important to provide a clear error message in both cases so that the user can quickly know why the test did not pass.</div>
<div class="subsection">
<h2 id="x4578706563746174696f6e73">Expectations</h2> Everything explained in the previous section changes when the test case expectations are redefined by the programmer.<p>
Each test case has an internal state called &#8216;expect&#8217; that describes what the test case expectations are at any point in time. The value of this property can change during execution by any of:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">atf_expect_death</b>(<i class="farg">reason</i>, <i class="farg">...</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Expects the test case to exit prematurely regardless of the nature of the exit.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">atf_expect_exit</b>(<i class="farg">exitcode</i>, <i class="farg">reason</i>, <i class="farg">...</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Expects the test case to exit cleanly. If <b class="var">exitcode</b> is not &#8216;-1&#8217;, <a class="link-man" href="../1/atf-run">atf-run(1)</a> will validate that the exit code of the test case matches the one provided in this call. Otherwise, the exact value will be ignored.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">atf_expect_fail</b>(<i class="farg">reason</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Any failure raised in this mode is recorded, but such failures do not report the test case as failed; instead, the test case finalizes cleanly and is reported as &#8216;expected failure&#8217;; this report includes the provided <i class="farg">reason</i> as part of it. If no error is raised while running in this mode, then the test case is reported as &#8216;failed&#8217;.<p>
This mode is useful to reproduce actual known bugs in tests. Whenever the developer fixes the bug later on, the test case will start reporting a failure, signaling the developer that the test case must be adjusted to the new conditions. In this situation, it is useful, for example, to set <i class="farg">reason</i> as the bug number for tracking purposes.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">atf_expect_pass</b>()</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This is the normal mode of execution. In this mode, any failure is reported as such to the user and the test case is marked as &#8216;failed&#8217;.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">atf_expect_signal</b>(<i class="farg">signo</i>, <i class="farg">reason</i>, <i class="farg">...</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Expects the test case to terminate due to the reception of a signal. If <b class="var">signo</b> is not &#8216;-1&#8217;, <a class="link-man" href="../1/atf-run">atf-run(1)</a> will validate that the signal that terminated the test case matches the one provided in this call. Otherwise, the exact value will be ignored.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">atf_expect_timeout</b>(<i class="farg">reason</i>, <i class="farg">...</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Expects the test case to execute for longer than its timeout.</dd>
</dl>
</div>
<div class="subsection">
<h2 id="x48656c7065722066756e6374696f6e7320666f7220636f6d6d6f6e20636865636b73">Helper functions for common checks</h2> <b class="fname">atf_check</b>(<i class="farg">[options]</i>, <i class="farg">command</i>, <i class="farg">[args]</i>)<p>
This function wraps the execution of the <b class="name">atf-check</b> tool and makes the test case fail if the tool reports failure. You should always use this function instead of the tool in your scripts. For more details on the parameters of this function, refer to <a class="link-man" href="../1/atf-check">atf-check(1)</a>.<p>
<b class="fname">atf_check_equal</b>(<i class="farg">expr1</i>, <i class="farg">expr2</i>)<p>
This function takes two expressions, evaluates them and, if their results differ, aborts the test case with an appropriate failure message.</div>
</div>
<div class="section">
<h1 id="x4558414d504c4553">EXAMPLES</h1> The following shows a complete test program with a single test case that validates the addition operator:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
atf_test_case addition 
addition_head() { 
    atf_set "descr" "Sample tests for the addition operator" 
} 
addition_body() { 
    atf_check_equal $((0 + 0)) 0 
    atf_check_equal $((0 + 1)) 1 
    atf_check_equal $((1 + 0)) 0 
 
    atf_check_equal $((1 + 1)) 2 
 
    atf_check_equal $((100 + 200)) 300 
} 
 
atf_init_test_cases() { 
    atf_add_test_case addition 
}</pre>
<p>
This other example shows how to include a file with extra helper functions in the test program:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
... definition of test cases ... 
 
atf_init_test_cases() { 
    . $(atf_get_srcdir)/helper_functions.sh 
 
    atf_add_test_case foo1 
    atf_add_test_case foo2 
}</pre>
<p>
This example demonstrates the use of the very useful <b class="fname">atf_check</b>() function:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
# Check for silent output 
atf_check -s exit:0 -o empty -e empty 'true' 
 
# Check for silent output and failure 
atf_check -s exit:1 -o empty -e empty 'false' 
 
# Check for known stdout and silent stderr 
echo foo &gt;expout 
atf_check -s exit:0 -o file:expout -e empty 'echo foo' 
 
# Generate a file for later inspection 
atf_check -s exit:0 -o save:stdout -e empty 'ls' 
grep foo ls || atf_fail "foo file not found in listing" 
 
# Or just do the match along the way 
atf_check -s exit:0 -o match:"^foo$" -e empty 'ls'</pre>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../1/atf-sh">atf-sh(1)</a>, <a class="link-man" href="../1/atf-test-program">atf-test-program(1)</a>, <a class="link-man" href="../4/atf-test-case">atf-test-case(4)</a>, <a class="link-man" href="../7/atf">atf(7)</a></div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
October 13, 2013</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

