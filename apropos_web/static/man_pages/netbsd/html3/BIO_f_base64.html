<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
BIO_f_base64(3)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
BIO_f_base64(3)</td>
<td class="head-vol" align="center">
OpenSSL</td>
<td class="head-rtitle" align="right">
BIO_f_base64(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> BIO_f_base64 &#45; base64 BIO filter</div>
<div class="section">
<h1>LIBRARY</h1> libcrypto, -lcrypto</div>
<div class="section">
<h1>SYNOPSIS</h1><br>
 #include &lt;openssl/bio.h&gt;<br>
 #include &lt;openssl/evp.h&gt;<br>
<br>
 BIO_METHOD *   BIO_f_base64(void);<br>
</div>
<div class="section">
<h1>DESCRIPTION</h1>  <i>BIO_f_base64()</i> returns the base64 BIO method. This is a filter BIO that base64 encodes any data written through it and decodes any data read through it.<p>
Base64 BIOs do not support <i>BIO_gets()</i> or <i>BIO_puts()</i>.<p>
<i>BIO_flush()</i> on a base64 BIO that is being written through is used to signal that no more data is to be encoded: this is used to flush the final block through the BIO.<p>
The flag BIO_FLAGS_BASE64_NO_NL can be set with <i>BIO_set_flags()</i> to encode the data all on one line or expect the data to be all on one line.</div>
<div class="section">
<h1>NOTES</h1> Because of the format of base64 encoding the end of the encoded block cannot always be reliably determined.</div>
<div class="section">
<h1>RETURN VALUES</h1>  <i>BIO_f_base64()</i> returns the base64 BIO method.</div>
<div class="section">
<h1>EXAMPLES</h1> Base64 encode the string "Hello World&#92;n" and write the result to standard output:<p>
<br>
 BIO *bio, *b64;<br>
 char message[] = "Hello World &#92;n";<br>
<br>
 b64 = BIO_new(BIO_f_base64());<br>
 bio = BIO_new_fp(stdout, BIO_NOCLOSE);<br>
 BIO_push(b64, bio);<br>
 BIO_write(b64, message, strlen(message));<br>
 BIO_flush(b64);<br>
<br>
 BIO_free_all(b64);<br>
<p>
Read Base64 encoded data from standard input and write the decoded data to standard output:<p>
<br>
 BIO *bio, *b64, *bio_out;<br>
 char inbuf[512];<br>
 int inlen;<br>
<br>
 b64 = BIO_new(BIO_f_base64());<br>
 bio = BIO_new_fp(stdin, BIO_NOCLOSE);<br>
 bio_out = BIO_new_fp(stdout, BIO_NOCLOSE);<br>
 BIO_push(b64, bio);<br>
 while((inlen = BIO_read(b64, inbuf, 512)) &gt; 0)<br>
        BIO_write(bio_out, inbuf, inlen);<br>
<br>
 BIO_flush(bio_out);<br>
 BIO_free_all(b64);<br>
</div>
<div class="section">
<h1>BUGS</h1> The ambiguity of EOF in base64 encoded data can cause additional data following the base64 encoded block to be misinterpreted.<p>
There should be some way of specifying a test that the BIO can perform to reliably determine EOF (for example a MIME boundary).</div>
<div class="section">
<h1>SEE ALSO</h1> TBA</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tr>
<td class="foot-date">
2014-08-10</td>
<td class="foot-os" align="right">
1.0.1n</td>
</tr>
</table>
</div>
</body>
</html>

