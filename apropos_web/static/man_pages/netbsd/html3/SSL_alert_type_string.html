<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="/static/man_pages/netbsd/style.css" type="text/css" media="all">
<title>
SSL_alert_type_string(3)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
SSL_alert_type_string(3)</td>
<td class="head-vol" align="center">
OpenSSL</td>
<td class="head-rtitle" align="right">
SSL_alert_type_string(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> SSL_alert_type_string, SSL_alert_type_string_long, SSL_alert_desc_string, SSL_alert_desc_string_long &#45; get textual description of alert information</div>
<div class="section">
<h1>LIBRARY</h1> libcrypto, -lcrypto</div>
<div class="section">
<h1>SYNOPSIS</h1><br>
 #include &lt;openssl/ssl.h&gt;<br>
<br>
 const char *SSL_alert_type_string(int value);<br>
 const char *SSL_alert_type_string_long(int value);<br>
<br>
 const char *SSL_alert_desc_string(int value);<br>
 const char *SSL_alert_desc_string_long(int value);<br>
</div>
<div class="section">
<h1>DESCRIPTION</h1>  <i>SSL_alert_type_string()</i> returns a one letter string indicating the type of the alert specified by  <b>value</b>.<p>
<i>SSL_alert_type_string_long()</i> returns a string indicating the type of the alert specified by  <b>value</b>.<p>
<i>SSL_alert_desc_string()</i> returns a two letter string as a short form describing the reason of the alert specified by  <b>value</b>.<p>
<i>SSL_alert_desc_string_long()</i> returns a string describing the reason of the alert specified by  <b>value</b>.</div>
<div class="section">
<h1>NOTES</h1> When one side of an SSL/TLS communication wants to inform the peer about a special situation, it sends an alert. The alert is sent as a special message and does not influence the normal data stream (unless its contents results in the communication being canceled).<p>
A warning alert is sent, when a non-fatal error condition occurs. The "close notify" alert is sent as a warning alert. Other examples for non-fatal errors are certificate errors ("certificate expired", "unsupported certificate"), for which a warning alert may be sent. (The sending party may however decide to send a fatal error.) The receiving side may cancel the connection on reception of a warning alert on it discretion.<p>
Several alert messages must be sent as fatal alert messages as specified by the TLS RFC. A fatal alert always leads to a connection abort.</div>
<div class="section">
<h1>RETURN VALUES</h1> The following strings can occur for  <i>SSL_alert_type_string()</i> or  <i>SSL_alert_type_string_long()</i>:<dl>
<dt>
"W"/"warning"</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
"F"/"fatal"</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
"U"/"unknown"</dt>
<dd>
This indicates that no support is available for this alert type. Probably  <b>value</b> does not contain a correct alert message.</dd>
</dl>
<p>
The following strings can occur for <i>SSL_alert_desc_string()</i> or  <i>SSL_alert_desc_string_long()</i>:<dl>
<dt>
"CN"/"close notify"</dt>
<dd>
The connection shall be closed. This is a warning alert.</dd>
</dl>
<dl>
<dt>
"UM"/"unexpected message"</dt>
<dd>
An inappropriate message was received. This alert is always fatal and should never be observed in communication between proper implementations.</dd>
</dl>
<dl>
<dt>
"BM"/"bad record mac"</dt>
<dd>
This alert is returned if a record is received with an incorrect MAC. This message is always fatal.</dd>
</dl>
<dl>
<dt>
"DF"/"decompression failure"</dt>
<dd>
The decompression function received improper input (e.g. data that would expand to excessive length). This message is always fatal.</dd>
</dl>
<dl>
<dt>
"HF"/"handshake failure"</dt>
<dd>
Reception of a handshake_failure alert message indicates that the sender was unable to negotiate an acceptable set of security parameters given the options available. This is a fatal error.</dd>
</dl>
<dl>
<dt>
"NC"/"no certificate"</dt>
<dd>
A client, that was asked to send a certificate, does not send a certificate (SSLv3 only).</dd>
</dl>
<dl>
<dt>
"BC"/"bad certificate"</dt>
<dd>
A certificate was corrupt, contained signatures that did not verify correctly, etc</dd>
</dl>
<dl>
<dt>
"UC"/"unsupported certificate"</dt>
<dd>
A certificate was of an unsupported type.</dd>
</dl>
<dl>
<dt>
"CR"/"certificate revoked"</dt>
<dd>
A certificate was revoked by its signer.</dd>
</dl>
<dl>
<dt>
"CE"/"certificate expired"</dt>
<dd>
A certificate has expired or is not currently valid.</dd>
</dl>
<dl>
<dt>
"CU"/"certificate unknown"</dt>
<dd>
Some other (unspecified) issue arose in processing the certificate, rendering it unacceptable.</dd>
</dl>
<dl>
<dt>
"IP"/"illegal parameter"</dt>
<dd>
A field in the handshake was out of range or inconsistent with other fields. This is always fatal.</dd>
</dl>
<dl>
<dt>
"DC"/"decryption failed"</dt>
<dd>
A TLSCiphertext decrypted in an invalid way: either it wasn't an even multiple of the block length or its padding values, when checked, weren't correct. This message is always fatal.</dd>
</dl>
<dl>
<dt>
"RO"/"record overflow"</dt>
<dd>
A TLSCiphertext record was received which had a length more than 2^14+2048 bytes, or a record decrypted to a TLSCompressed record with more than 2^14+1024 bytes. This message is always fatal.</dd>
</dl>
<dl>
<dt>
"CA"/"unknown CA"</dt>
<dd>
A valid certificate chain or partial chain was received, but the certificate was not accepted because the CA certificate could not be located or couldn't be matched with a known, trusted CA.  This message is always fatal.</dd>
</dl>
<dl>
<dt>
"AD"/"access denied"</dt>
<dd>
A valid certificate was received, but when access control was applied, the sender decided not to proceed with negotiation. This message is always fatal.</dd>
</dl>
<dl>
<dt>
"DE"/"decode error"</dt>
<dd>
A message could not be decoded because some field was out of the specified range or the length of the message was incorrect. This message is always fatal.</dd>
</dl>
<dl>
<dt>
"CY"/"decrypt error"</dt>
<dd>
A handshake cryptographic operation failed, including being unable to correctly verify a signature, decrypt a key exchange, or validate a finished message.</dd>
</dl>
<dl>
<dt>
"ER"/"export restriction"</dt>
<dd>
A negotiation not in compliance with export restrictions was detected; for example, attempting to transfer a 1024 bit ephemeral RSA key for the RSA_EXPORT handshake method. This message is always fatal.</dd>
</dl>
<dl>
<dt>
"PV"/"protocol version"</dt>
<dd>
The protocol version the client has attempted to negotiate is recognized, but not supported. (For example, old protocol versions might be avoided for security reasons). This message is always fatal.</dd>
</dl>
<dl>
<dt>
"IS"/"insufficient security"</dt>
<dd>
Returned instead of handshake_failure when a negotiation has failed specifically because the server requires ciphers more secure than those supported by the client. This message is always fatal.</dd>
</dl>
<dl>
<dt>
"IE"/"internal error"</dt>
<dd>
An internal error unrelated to the peer or the correctness of the protocol makes it impossible to continue (such as a memory allocation failure). This message is always fatal.</dd>
</dl>
<dl>
<dt>
"US"/"user canceled"</dt>
<dd>
This handshake is being canceled for some reason unrelated to a protocol failure. If the user cancels an operation after the handshake is complete, just closing the connection by sending a close_notify is more appropriate. This alert should be followed by a close_notify. This message is generally a warning.</dd>
</dl>
<dl>
<dt>
"NR"/"no renegotiation"</dt>
<dd>
Sent by the client in response to a hello request or by the server in response to a client hello after initial handshaking. Either of these would normally lead to renegotiation; when that is not appropriate, the recipient should respond with this alert; at that point, the original requester can decide whether to proceed with the connection. One case where this would be appropriate would be where a server has spawned a process to satisfy a request; the process might receive security parameters (key length, authentication, etc.) at startup and it might be difficult to communicate changes to these parameters after that point. This message is always a warning.</dd>
</dl>
<dl>
<dt>
"UP"/"unknown PSK identity"</dt>
<dd>
Sent by the server to indicate that it does not recognize a PSK identity or an SRP identity.</dd>
</dl>
<dl>
<dt>
"UK"/"unknown"</dt>
<dd>
This indicates that no description is available for this alert type. Probably  <b>value</b> does not contain a correct alert message.</dd>
</dl>
</div>
<div class="section">
<h1>SEE ALSO</h1>  <i>ssl</i>(3), <i>SSL_CTX_set_info_callback</i>(3)</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tr>
<td class="foot-date">
2012-07-26</td>
<td class="foot-os" align="right">
1.0.1n</td>
</tr>
</table>
</div>
</body>
</html>

