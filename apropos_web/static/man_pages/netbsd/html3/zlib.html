<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
ZLIB(3)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
ZLIB(3)</td>
<td class="head-vol" align="center">
Library Functions Manual</td>
<td class="head-rtitle" align="right">
ZLIB(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">zlib</b> &#8212; <span class="desc">general purpose compression library</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">zlib.h</a>&gt;</b><div class="subsection">
<h2 id="x42617369632066756e6374696f6e73">Basic functions</h2> <i class="ftype">const char *</i><br>
<b class="fname">zlibVersion</b>(<i class="farg" style="white-space:nowrap;">void</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">deflateInit</b>(<i class="farg" style="white-space:nowrap;">z_streamp strm</i>, <i class="farg" style="white-space:nowrap;">int level</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">deflate</b>(<i class="farg" style="white-space:nowrap;">z_streamp strm</i>, <i class="farg" style="white-space:nowrap;">int flush</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">deflateEnd</b>(<i class="farg" style="white-space:nowrap;">z_streamp strm</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">inflateInit</b>(<i class="farg" style="white-space:nowrap;">z_streamp strm</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">inflate</b>(<i class="farg" style="white-space:nowrap;">z_streamp strm</i>, <i class="farg" style="white-space:nowrap;">int flush</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">inflateEnd</b>(<i class="farg" style="white-space:nowrap;">z_streamp strm</i>);</div>
<div class="subsection">
<h2 id="x416476616e6365642066756e6374696f6e73">Advanced functions</h2> <i class="ftype">int</i><br>
<b class="fname">deflateInit2</b>(<i class="farg" style="white-space:nowrap;">z_streamp strm</i>, <i class="farg" style="white-space:nowrap;">int level</i>, <i class="farg" style="white-space:nowrap;">int method</i>, <i class="farg" style="white-space:nowrap;">int windowBits</i>, <i class="farg" style="white-space:nowrap;">int memLevel</i>, <i class="farg" style="white-space:nowrap;">int strategy</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">deflateSetDictionary</b>(<i class="farg" style="white-space:nowrap;">z_streamp strm</i>, <i class="farg" style="white-space:nowrap;">const Bytef *dictionary</i>, <i class="farg" style="white-space:nowrap;">uInt dictLength</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">deflateCopy</b>(<i class="farg" style="white-space:nowrap;">z_streamp dest</i>, <i class="farg" style="white-space:nowrap;">z_streamp source</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">deflateReset</b>(<i class="farg" style="white-space:nowrap;">z_streamp strm</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">deflateParams</b>(<i class="farg" style="white-space:nowrap;">z_streamp strm</i>, <i class="farg" style="white-space:nowrap;">int level</i>, <i class="farg" style="white-space:nowrap;">int strategy</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">inflateInit2</b>(<i class="farg" style="white-space:nowrap;">z_streamp strm</i>, <i class="farg" style="white-space:nowrap;">int windowBits</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">inflateSetDictionary</b>(<i class="farg" style="white-space:nowrap;">z_streamp strm</i>, <i class="farg" style="white-space:nowrap;">const Bytef *dictionary</i>, <i class="farg" style="white-space:nowrap;">uInt dictLength</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">inflateSync</b>(<i class="farg" style="white-space:nowrap;">z_streamp strm</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">inflateReset</b>(<i class="farg" style="white-space:nowrap;">z_streamp strm</i>);</div>
<div class="subsection">
<h2 id="x5574696c6974792066756e6374696f6e73">Utility functions</h2> <b class="macro">typedef voidp gzFile ;</b><p>
<br>
<i class="ftype">int</i><br>
<b class="fname">compress</b>(<i class="farg" style="white-space:nowrap;">Bytef *dest</i>, <i class="farg" style="white-space:nowrap;">uLongf *destLen</i>, <i class="farg" style="white-space:nowrap;">const Bytef *source</i>, <i class="farg" style="white-space:nowrap;">uLong sourceLen</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">compress2</b>(<i class="farg" style="white-space:nowrap;">Bytef *dest</i>, <i class="farg" style="white-space:nowrap;">uLongf *destLen</i>, <i class="farg" style="white-space:nowrap;">const Bytef *source</i>, <i class="farg" style="white-space:nowrap;">uLong sourceLen</i>, <i class="farg" style="white-space:nowrap;">int level</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">uncompress</b>(<i class="farg" style="white-space:nowrap;">Bytef *dest</i>, <i class="farg" style="white-space:nowrap;">uLongf *destLen</i>, <i class="farg" style="white-space:nowrap;">const Bytef *source</i>, <i class="farg" style="white-space:nowrap;">uLong sourceLen</i>);<p>
<i class="ftype">gzFile</i><br>
<b class="fname">gzopen</b>(<i class="farg" style="white-space:nowrap;">const char *path</i>, <i class="farg" style="white-space:nowrap;">const char *mode</i>);<p>
<i class="ftype">gzFile</i><br>
<b class="fname">gzdopen</b>(<i class="farg" style="white-space:nowrap;">int fd</i>, <i class="farg" style="white-space:nowrap;">const char *mode</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">gzsetparams</b>(<i class="farg" style="white-space:nowrap;">gzFile file</i>, <i class="farg" style="white-space:nowrap;">int level</i>, <i class="farg" style="white-space:nowrap;">int strategy</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">gzread</b>(<i class="farg" style="white-space:nowrap;">gzFile file</i>, <i class="farg" style="white-space:nowrap;">voidp buf</i>, <i class="farg" style="white-space:nowrap;">unsigned len</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">gzwrite</b>(<i class="farg" style="white-space:nowrap;">gzFile file</i>, <i class="farg" style="white-space:nowrap;">const voidp buf</i>, <i class="farg" style="white-space:nowrap;">unsigned len</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">gzprintf</b>(<i class="farg" style="white-space:nowrap;">gzFile file</i>, <i class="farg" style="white-space:nowrap;">const char *format</i>, <i class="farg" style="white-space:nowrap;">...</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">gzputs</b>(<i class="farg" style="white-space:nowrap;">gzFile file</i>, <i class="farg" style="white-space:nowrap;">const char *s</i>);<p>
<i class="ftype">char *</i><br>
<b class="fname">gzgets</b>(<i class="farg" style="white-space:nowrap;">gzFile file</i>, <i class="farg" style="white-space:nowrap;">char *buf</i>, <i class="farg" style="white-space:nowrap;">int len</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">gzputc</b>(<i class="farg" style="white-space:nowrap;">gzFile file</i>, <i class="farg" style="white-space:nowrap;">int c</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">gzgetc</b>(<i class="farg" style="white-space:nowrap;">gzFile file</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">gzflush</b>(<i class="farg" style="white-space:nowrap;">gzFile file</i>, <i class="farg" style="white-space:nowrap;">int flush</i>);<p>
<i class="ftype">z_off_t</i><br>
<b class="fname">gzseek</b>(<i class="farg" style="white-space:nowrap;">gzFile file</i>, <i class="farg" style="white-space:nowrap;">z_off_t offset</i>, <i class="farg" style="white-space:nowrap;">int whence</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">gzrewind</b>(<i class="farg" style="white-space:nowrap;">gzFile file</i>);<p>
<i class="ftype">z_off_t</i><br>
<b class="fname">gztell</b>(<i class="farg" style="white-space:nowrap;">gzFile file</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">gzeof</b>(<i class="farg" style="white-space:nowrap;">gzFile file</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">gzclose</b>(<i class="farg" style="white-space:nowrap;">gzFile file</i>);<p>
<i class="ftype">const char *</i><br>
<b class="fname">gzerror</b>(<i class="farg" style="white-space:nowrap;">gzFile file</i>, <i class="farg" style="white-space:nowrap;">int *errnum</i>);</div>
<div class="subsection">
<h2 id="x436865636b73756d2066756e6374696f6e73">Checksum functions</h2> <i class="ftype">uLong</i><br>
<b class="fname">adler32</b>(<i class="farg" style="white-space:nowrap;">uLong adler</i>, <i class="farg" style="white-space:nowrap;">const Bytef *buf</i>, <i class="farg" style="white-space:nowrap;">uInt len</i>);<p>
<i class="ftype">uLong</i><br>
<b class="fname">crc32</b>(<i class="farg" style="white-space:nowrap;">uLong crc</i>, <i class="farg" style="white-space:nowrap;">const Bytef *buf</i>, <i class="farg" style="white-space:nowrap;">uInt len</i>);</div>
</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> This manual page describes the <b class="name">zlib</b> general purpose compression library, version 1.1.4.<p>
The <b class="name">zlib</b> compression library provides in-memory compression and decompression functions, including integrity checks of the uncompressed data. This version of the library supports only one compression method (deflation) but other algorithms will be added later and will have the same stream interface.<p>
Compression can be done in a single step if the buffers are large enough (for example if an input file is mmap'ed), or can be done by repeated calls of the compression function. In the latter case, the application must provide more input and/or consume the output (providing more output space) before each call.<p>
The library also supports reading and writing files in <a class="link-man" href="../html1/gzip.html">gzip(1)</a> (.gz) format with an interface similar to that of <a class="link-man" href="../html3/stdio.html">stdio(3)</a>.<p>
The library does not install any signal handler. The decoder checks the consistency of the compressed data, so the library should never crash even in case of corrupted input.<p>
The functions within the library are divided into the following sections:<p>
<ul style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-dash">
<li class="list-dash" style="margin-top: 0.00em;">
Basic functions</li>
<li class="list-dash" style="margin-top: 0.00em;">
Advanced functions</li>
<li class="list-dash" style="margin-top: 0.00em;">
Utility functions</li>
<li class="list-dash" style="margin-top: 0.00em;">
Checksum functions</li>
</ul>
</div>
<div class="section">
<h1 id="x42415349432046554e4354494f4e53">BASIC FUNCTIONS</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">const char *</i> <b class="fname">zlibVersion</b>(<i class="farg">void</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<p>
The application can compare <b class="fname">zlibVersion</b>() and <span class="define">ZLIB_VERSION</span> for consistency. If the first character differs, the library code actually used is not compatible with the <b class="includes">&lt;<a class="link-includes">zlib.h</a>&gt;</b> header file used by the application. This check is automatically made by <b class="fname">deflateInit</b>() and <b class="fname">inflateInit</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">int</i> <b class="fname">deflateInit</b>(<i class="farg">z_streamp strm</i>, <i class="farg">int level</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<p>
The <b class="fname">deflateInit</b>() function initializes the internal stream state for compression. The fields <i class="farg">zalloc</i>, <i class="farg">zfree</i>, and <i class="farg">opaque</i> must be initialized before by the caller. If <i class="farg">zalloc</i> and <i class="farg">zfree</i> are set to <span class="define">Z_NULL</span>, <b class="fname">deflateInit</b>() updates them to use default allocation functions.<p>
The compression level must be <span class="define">Z_DEFAULT_COMPRESSION</span>, or between 0 and 9: 1 gives best speed, 9 gives best compression, 0 gives no compression at all (the input data is simply copied a block at a time).<p>
<span class="define">Z_DEFAULT_COMPRESSION</span> requests a default compromise between speed and compression (currently equivalent to level 6).<p>
<b class="fname">deflateInit</b>() returns <span class="define">Z_OK</span> if successful, <span class="define">Z_MEM_ERROR</span> if there was not enough memory, <span class="define">Z_STREAM_ERROR</span> if level is not a valid compression level, <span class="define">Z_VERSION_ERROR</span> if the <b class="name">zlib</b> library version (zlib_version) is incompatible with the version assumed by the caller (ZLIB_VERSION). <i class="farg">msg</i> is set to null if there is no error message. <b class="fname">deflateInit</b>() does not perform any compression: this will be done by <b class="fname">deflate</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">int</i> <b class="fname">deflate</b>(<i class="farg">z_streamp strm</i>, <i class="farg">int flush</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<p>
<b class="fname">deflate</b>() compresses as much data as possible, and stops when the input buffer becomes empty or the output buffer becomes full. It may introduce some output latency (reading input without producing any output) except when forced to flush.<p>
The detailed semantics are as follows. <b class="fname">deflate</b>() performs one or both of the following actions:<p>
Compress more input starting at <i class="farg">next_in</i> and update <i class="farg">next_in</i> and <i class="farg">avail_in</i> accordingly. If not all input can be processed (because there is not enough room in the output buffer), <i class="farg">next_in</i> and <i class="farg">avail_in</i> are updated and processing will resume at this point for the next call to <b class="fname">deflate</b>().<p>
Provide more output starting at <i class="farg">next_out</i> and update <i class="farg">next_out</i> and <i class="farg">avail_out</i> accordingly. This action is forced if the parameter <i class="farg">flush</i> is non-zero. Forcing <i class="farg">flush</i> frequently degrades the compression ratio, so this parameter should be set only when necessary (in interactive applications). Some output may be provided even if <i class="farg">flush</i> is not set.<p>
Before the call to <b class="fname">deflate</b>(), the application should ensure that at least one of the actions is possible, by providing more input and/or consuming more output, and updating <i class="farg">avail_in</i> or <i class="farg">avail_out</i> accordingly; <i class="farg">avail_out</i> should never be zero before the call. The application can consume the compressed output when it wants, for example when the output buffer is full (avail_out == 0), or after each call to <b class="fname">deflate</b>(). If <b class="fname">deflate</b>() returns <span class="define">Z_OK</span> and with zero <i class="farg">avail_out</i>, it must be called again after making room in the output buffer because there might be more output pending.<p>
If the parameter <i class="farg">flush</i> is set to <span class="define">Z_SYNC_FLUSH</span>, all pending output is flushed to the output buffer and the output is aligned on a byte boundary, so that the decompressor can get all input data available so far. (In particular, <i class="farg">avail_in</i> is zero after the call if enough output space has been provided before the call.) Flushing may degrade compression for some compression algorithms and so it should be used only when necessary.<p>
If <i class="farg">flush</i> is set to <span class="define">Z_FULL_FLUSH</span>, all output is flushed as with <span class="define">Z_SYNC_FLUSH</span>, and the compression state is reset so that decompression can restart from this point if previous compressed data has been damaged or if random access is desired. Using <span class="define">Z_FULL_FLUSH</span> too often can seriously degrade the compression.<p>
If <b class="fname">deflate</b>() returns with avail_out == 0, this function must be called again with the same value of the flush parameter and more output space (updated <i class="farg">avail_out</i>), until the flush is complete (<b class="fname">deflate</b>() returns with non-zero <i class="farg">avail_out</i>).<p>
If the parameter <i class="farg">flush</i> is set to <span class="define">Z_FINISH</span>, pending input is processed, pending output is flushed and <b class="fname">deflate</b>() returns with <span class="define">Z_STREAM_END</span> if there was enough output space; if <b class="fname">deflate</b>() returns with <span class="define">Z_OK</span>, this function must be called again with <span class="define">Z_FINISH</span> and more output space (updated <i class="farg">avail_out</i> but no more input data, until it returns with <span class="define">Z_STREAM_END</span> or an error. After <b class="fname">deflate</b>() has returned <span class="define">Z_STREAM_END</span>, the only possible operations on the stream are <b class="fname">deflateReset</b>() or <b class="fname">deflateEnd</b>().<p>
<span class="define">Z_FINISH</span> can be used immediately after <b class="fname">deflateInit</b>() if all the compression is to be done in a single step. In this case, <i class="farg">avail_out</i> must be at least 0.1% larger than <i class="farg">avail_in</i> plus 12 bytes. If <b class="fname">deflate</b>() does not return <span class="define">Z_STREAM_END</span>, then it must be called again as described above.<p>
<b class="fname">deflate</b>() sets strm-&gt;adler to the Adler-32 checksum of all input read so far (that is, <i class="farg">total_in</i> bytes).<p>
<b class="fname">deflate</b>() may update <i class="farg">data_type</i> if it can make a good guess about the input data type (Z_ASCII or Z_BINARY). If in doubt, the data is considered binary. This field is only for information purposes and does not affect the compression algorithm in any manner.<p>
<b class="fname">deflate</b>() returns <span class="define">Z_OK</span> if some progress has been made (more input processed or more output produced), <span class="define">Z_STREAM_END</span> if all input has been consumed and all output has been produced (only when <i class="farg">flush</i> is set to <span class="define">Z_FINISH</span>), <span class="define">Z_STREAM_ERROR</span> if the stream state was inconsistent (for example, if <i class="farg">next_in</i> or <i class="farg">next_out</i> was <span class="define">NULL</span>), <span class="define">Z_BUF_ERROR</span> if no progress is possible (for example, <i class="farg">avail_in</i> or <i class="farg">avail_out</i> was zero).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">int</i> <b class="fname">deflateEnd</b>(<i class="farg">z_streamp strm</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<p>
All dynamically allocated data structures for this stream are freed. This function discards any unprocessed input and does not flush any pending output.<p>
<b class="fname">deflateEnd</b>() returns <span class="define">Z_OK</span> if successful, <span class="define">Z_STREAM_ERROR</span> if the stream state was inconsistent, <span class="define">Z_DATA_ERROR</span> if the stream was freed prematurely (some input or output was discarded). In the error case, <i class="farg">msg</i> may be set but then points to a static string (which must not be deallocated).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">int</i> <b class="fname">inflateInit</b>(<i class="farg">z_streamp strm</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The <b class="fname">inflateInit</b>() function initializes the internal stream state for decompression. The fields <i class="farg">next_in</i>, <i class="farg">avail_in</i>, <i class="farg">zalloc</i>, <i class="farg">zfree</i>, and <i class="farg">opaque</i> must be initialized before by the caller. If <i class="farg">next_in</i> is not <span class="define">Z_NULL</span> and <i class="farg">avail_in</i> is large enough (the exact value depends on the compression method), <b class="fname">inflateInit</b>() determines the compression method from the <b class="name">zlib</b> header and allocates all data structures accordingly; otherwise the allocation will be deferred to the first call to <b class="fname">inflate</b>(). If <i class="farg">zalloc</i> and <i class="farg">zfree</i> are set to <span class="define">Z_NULL</span>, <b class="fname">inflateInit</b>() updates them to use default allocation functions.<p>
<b class="fname">inflateInit</b>() returns <span class="define">Z_OK</span> if successful, <span class="define">Z_MEM_ERROR</span> if there was not enough memory, <span class="define">Z_VERSION_ERROR</span> if the <b class="name">zlib</b> library version is incompatible with the version assumed by the caller. <i class="farg">msg</i> is set to null if there is no error message. <b class="fname">inflateInit</b>() does not perform any decompression apart from reading the <b class="name">zlib</b> header if present: this will be done by <b class="fname">inflate</b>(). (So <i class="farg">next_in</i> and <i class="farg">avail_in</i> may be modified, but <i class="farg">next_out</i> and <i class="farg">avail_out</i> are unchanged.)</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">int</i> <b class="fname">inflate</b>(<i class="farg">z_streamp strm</i>, <i class="farg">int flush</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<b class="fname">inflate</b>() decompresses as much data as possible, and stops when the input buffer becomes empty or the output buffer becomes full. It may introduce some output latency (reading input without producing any output) except when forced to flush.<p>
The detailed semantics are as follows. <b class="fname">inflate</b>() performs one or both of the following actions:<p>
Decompress more input starting at <i class="farg">next_in</i> and update <i class="farg">next_in</i> and <i class="farg">avail_in</i> accordingly. If not all input can be processed (because there is not enough room in the output buffer), <i class="farg">next_in</i> is updated and processing will resume at this point for the next call to <b class="fname">inflate</b>().<p>
Provide more output starting at <i class="farg">next_out</i> and update <i class="farg">next_out</i> and <i class="farg">avail_out</i> accordingly. <b class="fname">inflate</b>() provides as much output as possible, until there is no more input data or no more space in the output buffer (see below about the flush parameter).<p>
Before the call to <b class="fname">inflate</b>(), the application should ensure that at least one of the actions is possible, by providing more input and/or consuming more output, and updating the next_* and avail_* values accordingly. The application can consume the uncompressed output when it wants, for example when the output buffer is full (avail_out == 0), or after each call to <b class="fname">inflate</b>(). If <b class="fname">inflate</b>() returns <span class="define">Z_OK</span> and with zero <i class="farg">avail_out</i>, it must be called again after making room in the output buffer because there might be more output pending.<p>
If the parameter <i class="farg">flush</i> is set to <span class="define">Z_SYNC_FLUSH</span>, <b class="fname">inflate</b>() flushes as much output as possible to the output buffer. The flushing behavior of <b class="fname">inflate</b>() is not specified for values of the flush parameter other than <span class="define">Z_SYNC_FLUSH</span> and <span class="define">Z_FINISH</span>, but the current implementation actually flushes as much output as possible anyway.<p>
<b class="fname">inflate</b>() should normally be called until it returns <span class="define">Z_STREAM_END</span> or an error. However if all decompression is to be performed in a single step (a single call to inflate), the parameter <i class="farg">flush</i> should be set to <span class="define">Z_FINISH</span>. In this case all pending input is processed and all pending output is flushed; <i class="farg">avail_out</i> must be large enough to hold all the uncompressed data. (The size of the uncompressed data may have been saved by the compressor for this purpose.) The next operation on this stream must be <b class="fname">inflateEnd</b>() to deallocate the decompression state. The use of <span class="define">Z_FINISH</span> is never required, but can be used to inform <b class="fname">inflate</b>() that a faster routine may be used for the single <b class="fname">inflate</b>() call.<p>
If a preset dictionary is needed at this point (see <b class="fname">inflateSetDictionary</b>() below), <b class="fname">inflate</b>() sets strm-&gt;adler to the Adler-32 checksum of the dictionary chosen by the compressor and returns <span class="define">Z_NEED_DICT</span>; otherwise it sets strm-&gt;adler to the Adler-32 checksum of all output produced so far (that is, <i class="farg">total_out</i> bytes) and returns <span class="define">Z_OK</span>, <span class="define">Z_STREAM_END</span>, or an error code as described below. At the end of the stream, <b class="fname">inflate</b>() checks that its computed Adler-32 checksum is equal to that saved by the compressor and returns <span class="define">Z_STREAM_END</span> only if the checksum is correct.<p>
<b class="fname">inflate</b>() returns <span class="define">Z_OK</span> if some progress has been made (more input processed or more output produced), <span class="define">Z_STREAM_END</span> if the end of the compressed data has been reached and all uncompressed output has been produced, <span class="define">Z_NEED_DICT</span> if a preset dictionary is needed at this point, <span class="define">Z_DATA_ERROR</span> if the input data was corrupted (input stream not conforming to the <b class="name">zlib</b> format or incorrect Adler-32 checksum), <span class="define">Z_STREAM_ERROR</span> if the stream structure was inconsistent (for example, if <i class="farg">next_in</i> or <i class="farg">next_out</i> was <span class="define">NULL</span>), <span class="define">Z_MEM_ERROR</span> if there was not enough memory, <span class="define">Z_BUF_ERROR</span> if no progress is possible or if there was not enough room in the output buffer when <span class="define">Z_FINISH</span> is used. In the <span class="define">Z_DATA_ERROR</span> case, the application may then call <b class="fname">inflateSync</b>() to look for a good compression block.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">int</i> <b class="fname">inflateEnd</b>(<i class="farg">z_streamp strm</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
All dynamically allocated data structures for this stream are freed. This function discards any unprocessed input and does not flush any pending output.<p>
<b class="fname">inflateEnd</b>() returns <span class="define">Z_OK</span> if successful, or <span class="define">Z_STREAM_ERROR</span> if the stream state was inconsistent. In the error case, <i class="farg">msg</i> may be set but then points to a static string (which must not be deallocated).</dd>
</dl>
</div>
<div class="section">
<h1 id="x414456414e4345442046554e4354494f4e53">ADVANCED FUNCTIONS</h1> The following functions are needed only in some special applications.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">int</i> <b class="fname">deflateInit2</b>(<i class="farg">z_streamp strm</i>, <i class="farg">int level</i>, <i class="farg">int method</i>, <i class="farg">int windowBits</i>, <i class="farg">int memLevel</i>, <i class="farg">int strategy</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<p>
This is another version of <b class="fname">deflateInit</b>() with more compression options. The fields <i class="farg">next_in</i>, <i class="farg">zalloc</i>, <i class="farg">zfree</i>, and <i class="farg">opaque</i> must be initialized before by the caller.<p>
The <i class="farg">method</i> parameter is the compression method. It must be <span class="define">Z_DEFLATED</span> in this version of the library.<p>
The <i class="farg">windowBits</i> parameter is the base two logarithm of the window size (the size of the history buffer). It should be in the range 8..15 for this version of the library. Larger values of this parameter result in better compression at the expense of memory usage. The default value is 15 if <b class="fname">deflateInit</b>() is used instead.<p>
The <i class="farg">memLevel</i> parameter specifies how much memory should be allocated for the internal compression state. memLevel=1 uses minimum memory but is slow and reduces compression ratio; memLevel=9 uses maximum memory for optimal speed. The default value is 8. See <b class="includes">&lt;<a class="link-includes">zconf.h</a>&gt;</b> for total memory usage as a function of <i class="farg">windowBits</i> and <i class="farg">memLevel</i>.<p>
The <i class="farg">strategy</i> parameter is used to tune the compression algorithm. Use the value <span class="define">Z_DEFAULT_STRATEGY</span> for normal data; <span class="define">Z_FILTERED</span> for data produced by a filter (or predictor); or <span class="define">Z_HUFFMAN_ONLY</span> to force Huffman encoding only (no string match). Filtered data consists mostly of small values with a somewhat random distribution. In this case, the compression algorithm is tuned to compress them better. The effect of <span class="define">Z_FILTERED</span> is to force more Huffman coding and less string matching; it is somewhat intermediate between <span class="define">Z_DEFAULT</span> and <span class="define">Z_HUFFMAN_ONLY</span>. The <i class="farg">strategy</i> parameter only affects the compression ratio but not the correctness of the compressed output, even if it is not set appropriately.<p>
<b class="fname">deflateInit2</b>() returns <span class="define">Z_OK</span> if successful, <span class="define">Z_MEM_ERROR</span> if there was not enough memory, <span class="define">Z_STREAM_ERROR</span> if a parameter is invalid (such as an invalid method). <i class="farg">msg</i> is set to null if there is no error message. <b class="fname">deflateInit2</b>() does not perform any compression: this will be done by <b class="fname">deflate</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">int</i> <b class="fname">deflateSetDictionary</b>(<i class="farg">z_streamp strm</i>, <i class="farg">const Bytef *dictionary</i>, <i class="farg">uInt dictLength</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<p>
Initializes the compression dictionary from the given byte sequence without producing any compressed output. This function must be called immediately after <b class="fname">deflateInit</b>(), <b class="fname">deflateInit2</b>(), or <b class="fname">deflateReset</b>(), before any call to <b class="fname">deflate</b>(). The compressor and decompressor must use exactly the same dictionary (see <b class="fname">inflateSetDictionary</b>()).<p>
The dictionary should consist of strings (byte sequences) that are likely to be encountered later in the data to be compressed, with the most commonly used strings preferably put towards the end of the dictionary. Using a dictionary is most useful when the data to be compressed is short and can be predicted with good accuracy; the data can then be compressed better than with the default empty dictionary.<p>
Depending on the size of the compression data structures selected by <b class="fname">deflateInit</b>() or <b class="fname">deflateInit2</b>(), a part of the dictionary may in effect be discarded, for example if the dictionary is larger than the window size in <b class="fname">deflate</b>() or <b class="fname">deflate2</b>(). Thus the strings most likely to be useful should be put at the end of the dictionary, not at the front.<p>
Upon return of this function, strm-&gt;adler is set to the Adler-32 value of the dictionary; the decompressor may later use this value to determine which dictionary has been used by the compressor. (The Adler-32 value applies to the whole dictionary even if only a subset of the dictionary is actually used by the compressor.)<p>
<b class="fname">deflateSetDictionary</b>() returns <span class="define">Z_OK</span> if successful, or <span class="define">Z_STREAM_ERROR</span> if a parameter is invalid (such as NULL dictionary) or the stream state is inconsistent (for example if <b class="fname">deflate</b>() has already been called for this stream or if the compression method is bsort). <b class="fname">deflateSetDictionary</b>() does not perform any compression: this will be done by <b class="fname">deflate</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">int</i> <b class="fname">deflateCopy</b>(<i class="farg">z_streamp dest</i>, <i class="farg">z_streamp source</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<p>
The <b class="fname">deflateCopy</b>() function sets the destination stream as a complete copy of the source stream.<p>
This function can be useful when several compression strategies will be tried, for example when there are several ways of pre-processing the input data with a filter. The streams that will be discarded should then be freed by calling <b class="fname">deflateEnd</b>(). Note that <b class="fname">deflateCopy</b>() duplicates the internal compression state which can be quite large, so this strategy is slow and can consume lots of memory.<p>
<b class="fname">deflateCopy</b>() returns <span class="define">Z_OK</span> if successful, <span class="define">Z_MEM_ERROR</span> if there was not enough memory, <span class="define">Z_STREAM_ERROR</span> if the source stream state was inconsistent (such as <i class="farg">zalloc</i> being NULL). <i class="farg">msg</i> is left unchanged in both source and destination.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">int</i> <b class="fname">deflateReset</b>(<i class="farg">z_streamp strm</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<p>
This function is equivalent to <b class="fname">deflateEnd</b>() followed by <b class="fname">deflateInit</b>(), but does not free and reallocate all the internal compression state. The stream will keep the same compression level and any other attributes that may have been set by <b class="fname">deflateInit2</b>().<p>
<b class="fname">deflateReset</b>() returns <span class="define">Z_OK</span> if successful, or <span class="define">Z_STREAM_ERROR</span> if the source stream state was inconsistent (such as <i class="farg">zalloc</i> or <i class="farg">state</i> being NULL).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">int</i> <b class="fname">deflateParams</b>(<i class="farg">z_streamp strm</i>, <i class="farg">int level</i>, <i class="farg">int strategy</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<p>
The <b class="fname">deflateParams</b>() function dynamically updates the compression level and compression strategy. The interpretation of level and strategy is as in <b class="fname">deflateInit2</b>(). This can be used to switch between compression and straight copy of the input data, or to switch to a different kind of input data requiring a different strategy. If the compression level is changed, the input available so far is compressed with the old level (and may be flushed); the new level will take effect only at the next call to <b class="fname">deflate</b>().<p>
Before the call to <b class="fname">deflateParams</b>(), the stream state must be set as for a call to <b class="fname">deflate</b>(), since the currently available input may have to be compressed and flushed. In particular, strm-&gt;avail_out must be non-zero.<p>
<b class="fname">deflateParams</b>() returns <span class="define">Z_OK</span> if successful, <span class="define">Z_STREAM_ERROR</span> if the source stream state was inconsistent or if a parameter was invalid, or <span class="define">Z_BUF_ERROR</span> if strm-&gt;avail_out was zero.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">int</i> <b class="fname">inflateInit2</b>(<i class="farg">z_streamp strm</i>, <i class="farg">int windowBits</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<p>
This is another version of <b class="fname">inflateInit</b>() with an extra parameter. The fields <i class="farg">next_in</i>, <i class="farg">avail_in</i>, <i class="farg">zalloc</i>, <i class="farg">zfree</i>, and <i class="farg">opaque</i> must be initialized before by the caller.<p>
The <i class="farg">windowBits</i> parameter is the base two logarithm of the maximum window size (the size of the history buffer). It should be in the range 8..15 for this version of the library. The default value is 15 if <b class="fname">inflateInit</b>() is used instead. If a compressed stream with a larger window size is given as input, <b class="fname">inflate</b>() will return with the error code <span class="define">Z_DATA_ERROR</span> instead of trying to allocate a larger window.<p>
<b class="fname">inflateInit2</b>() returns <span class="define">Z_OK</span> if successful, <span class="define">Z_MEM_ERROR</span> if there was not enough memory, <span class="define">Z_STREAM_ERROR</span> if a parameter is invalid (such as a negative <i class="farg">memLevel</i>). <i class="farg">msg</i> is set to null if there is no error message. <b class="fname">inflateInit2</b>() does not perform any decompression apart from reading the <b class="name">zlib</b> header if present: this will be done by <b class="fname">inflate</b>(). (So <i class="farg">next_in</i> and <i class="farg">avail_in</i> may be modified, but <i class="farg">next_out</i> and <i class="farg">avail_out</i> are unchanged.)</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">int</i> <b class="fname">inflateSetDictionary</b>(<i class="farg">z_streamp strm</i>, <i class="farg">const Bytef *dictionary</i>, <i class="farg">uInt dictLength</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<p>
Initializes the decompression dictionary from the given uncompressed byte sequence. This function must be called immediately after a call to <b class="fname">inflate</b>() if this call returned <span class="define">Z_NEED_DICT</span>. The dictionary chosen by the compressor can be determined from the Adler-32 value returned by this call to <b class="fname">inflate</b>(). The compressor and decompressor must use exactly the same dictionary (see <b class="fname">deflateSetDictionary</b>()).<p>
<b class="fname">inflateSetDictionary</b>() returns <span class="define">Z_OK</span> if successful, <span class="define">Z_STREAM_ERROR</span> if a parameter is invalid (such as NULL dictionary) or the stream state is inconsistent, <span class="define">Z_DATA_ERROR</span> if the given dictionary doesn't match the expected one (incorrect Adler-32 value). <b class="fname">inflateSetDictionary</b>() does not perform any decompression: this will be done by subsequent calls of <b class="fname">inflate</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">int</i> <b class="fname">inflateSync</b>(<i class="farg">z_streamp strm</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<p>
Skips invalid compressed data until a full flush point (see above the description of <b class="fname">deflate</b>() with <span class="define">Z_FULL_FLUSH</span>) can be found, or until all available input is skipped. No output is provided.<p>
<b class="fname">inflateSync</b>() returns <span class="define">Z_OK</span> if a full flush point has been found, <span class="define">Z_BUF_ERROR</span> if no more input was provided, <span class="define">Z_DATA_ERROR</span> if no flush point has been found, or <span class="define">Z_STREAM_ERROR</span> if the stream structure was inconsistent. In the success case, the application may save the current value of <i class="farg">total_in</i> which indicates where valid compressed data was found. In the error case, the application may repeatedly call <b class="fname">inflateSync</b>(), providing more input each time, until success or end of the input data.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">int</i> <b class="fname">inflateReset</b>(<i class="farg">z_streamp strm</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<p>
This function is equivalent to <b class="fname">inflateEnd</b>() followed by <b class="fname">inflateInit</b>(), but does not free and reallocate all the internal decompression state. The stream will keep attributes that may have been set by <b class="fname">inflateInit2</b>().<p>
<b class="fname">inflateReset</b>() returns <span class="define">Z_OK</span> if successful, or <span class="define">Z_STREAM_ERROR</span> if the source stream state was inconsistent (such as <i class="farg">zalloc</i> or <i class="farg">state</i> being NULL).</dd>
</dl>
</div>
<div class="section">
<h1 id="x5554494c4954592046554e4354494f4e53">UTILITY FUNCTIONS</h1> The following utility functions are implemented on top of the basic stream-oriented functions. To simplify the interface, some default options are assumed (compression level and memory usage, standard memory allocation functions). The source code of these utility functions can easily be modified if you need special options.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">int</i> <b class="fname">compress</b>(<i class="farg">Bytef *dest</i>, <i class="farg">uLongf *destLen</i>, <i class="farg">const Bytef *source</i>, <i class="farg">uLong sourceLen</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<p>
The <b class="fname">compress</b>() function compresses the source buffer into the destination buffer. <i class="farg">sourceLen</i> is the byte length of the source buffer. Upon entry, <i class="farg">destLen</i> is the total size of the destination buffer, which must be at least 0.1% larger than <i class="farg">sourceLen</i> plus 12 bytes. Upon exit, <i class="farg">destLen</i> is the actual size of the compressed buffer. This function can be used to compress a whole file at once if the input file is mmap'ed.<p>
<b class="fname">compress</b>() returns <span class="define">Z_OK</span> if successful, <span class="define">Z_MEM_ERROR</span> if there was not enough memory, or <span class="define">Z_BUF_ERROR</span> if there was not enough room in the output buffer.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">int</i> <b class="fname">compress2</b>(<i class="farg">Bytef *dest</i>, <i class="farg">uLongf *destLen</i>, <i class="farg">const Bytef *source</i>, <i class="farg">uLong sourceLen</i>, <i class="farg">int level</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<p>
The <b class="fname">compress2</b>() function compresses the source buffer into the destination buffer. The <i class="farg">level</i> parameter has the same meaning as in <b class="fname">deflateInit</b>(). <i class="farg">sourceLen</i> is the byte length of the source buffer. Upon entry, <i class="farg">destLen</i> is the total size of the destination buffer, which must be at least 0.1% larger than <i class="farg">sourceLen</i> plus 12 bytes. Upon exit, <i class="farg">destLen</i> is the actual size of the compressed buffer.<p>
<b class="fname">compress2</b>() returns <span class="define">Z_OK</span> if successful, <span class="define">Z_MEM_ERROR</span> if there was not enough memory, <span class="define">Z_BUF_ERROR</span> if there was not enough room in the output buffer, or <span class="define">Z_STREAM_ERROR</span> if the level parameter is invalid.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">int</i> <b class="fname">uncompress</b>(<i class="farg">Bytef *dest</i>, <i class="farg">uLongf *destLen</i>, <i class="farg">const Bytef *source</i>, <i class="farg">uLong sourceLen</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<p>
The <b class="fname">uncompress</b>() function decompresses the source buffer into the destination buffer. <i class="farg">sourceLen</i> is the byte length of the source buffer. Upon entry, <i class="farg">destLen</i> is the total size of the destination buffer, which must be large enough to hold the entire uncompressed data. (The size of the uncompressed data must have been saved previously by the compressor and transmitted to the decompressor by some mechanism outside the scope of this compression library.) Upon exit, <i class="farg">destLen</i> is the actual size of the compressed buffer. This function can be used to decompress a whole file at once if the input file is mmap'ed.<p>
<b class="fname">uncompress</b>() returns <span class="define">Z_OK</span> if successful, <span class="define">Z_MEM_ERROR</span> if there was not enough memory, <span class="define">Z_BUF_ERROR</span> if there was not enough room in the output buffer, or <span class="define">Z_DATA_ERROR</span> if the input data was corrupted.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">gzFile</i> <b class="fname">gzopen</b>(<i class="farg">const char *path</i>, <i class="farg">const char *mode</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<p>
The <b class="fname">gzopen</b>() function opens a gzip (.gz) file for reading or writing. The mode parameter is as in <a class="link-man" href="../html3/fopen.html">fopen(3)</a> (&#8220;rb&#8221; or &#8220;wb&#8221;) but can also include a compression level (&#8220;wb9&#8221;) or a strategy: &#8216;f&#8217; for filtered data, as in &#8220;wb6f&#8221;; &#8216;h&#8217; for Huffman only compression, as in &#8220;wb1h&#8221;. (See the description of <b class="fname">deflateInit2</b>() for more information about the strategy parameter.)<p>
<b class="fname">gzopen</b>() can be used to read a file which is not in gzip format; in this case <b class="fname">gzread</b>() will directly read from the file without decompression.<p>
<b class="fname">gzopen</b>() returns <span class="define">NULL</span> if the file could not be opened or if there was insufficient memory to allocate the (de)compression state; errno can be checked to distinguish the two cases (if errno is zero, the <b class="name">zlib</b> error is <span class="define">Z_MEM_ERROR</span>).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">gzFile</i> <b class="fname">gzdopen</b>(<i class="farg">int fd</i>, <i class="farg">const char *mode</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<p>
The <b class="fname">gzdopen</b>() function associates a gzFile with the file descriptor <i class="farg">fd</i>. File descriptors are obtained from calls like <a class="link-man" href="../html2/open.html">open(2)</a>, <a class="link-man" href="../html2/dup.html">dup(2)</a>, <a class="link-man" href="../html3/creat.html">creat(3)</a>, <a class="link-man" href="../html2/pipe.html">pipe(2)</a>, or <a class="link-man" href="../html3/fileno.html">fileno(3)</a> (if the file has been previously opened with <a class="link-man" href="../html3/fopen.html">fopen(3)</a>). The <i class="farg">mode</i> parameter is as in <b class="fname">gzopen</b>().<p>
The next call to <b class="fname">gzclose</b>() on the returned gzFile will also close the file descriptor fd, just like fclose(fdopen(fd), mode) closes the file descriptor fd. If you want to keep fd open, use gzdopen(dup(fd), mode).<p>
<b class="fname">gzdopen</b>() returns <span class="define">NULL</span> if there was insufficient memory to allocate the (de)compression state.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">int</i> <b class="fname">gzsetparams</b>(<i class="farg">gzFile file</i>, <i class="farg">int level</i>, <i class="farg">int strategy</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<p>
The <b class="fname">gzsetparams</b>() function dynamically updates the compression level or strategy. See the description of <b class="fname">deflateInit2</b>() for the meaning of these parameters.<p>
<b class="fname">gzsetparams</b>() returns <span class="define">Z_OK</span> if successful, or <span class="define">Z_STREAM_ERROR</span> if the file was not opened for writing.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">int</i> <b class="fname">gzread</b>(<i class="farg">gzFile file</i>, <i class="farg">voidp buf</i>, <i class="farg">unsigned len</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<p>
The <b class="fname">gzread</b>() function reads the given number of uncompressed bytes from the compressed file. If the input file was not in gzip format, <b class="fname">gzread</b>() copies the given number of bytes into the buffer.<p>
<b class="fname">gzread</b>() returns the number of uncompressed bytes actually read (0 for end of file, &#45;1 for error).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">int</i> <b class="fname">gzwrite</b>(<i class="farg">gzFile file</i>, <i class="farg">const voidp buf</i>, <i class="farg">unsigned len</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<p>
The <b class="fname">gzwrite</b>() function writes the given number of uncompressed bytes into the compressed file. <b class="fname">gzwrite</b>() returns the number of uncompressed bytes actually written (0 in case of error).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">int</i> <b class="fname">gzprintf</b>(<i class="farg">gzFile file</i>, <i class="farg">const char *format</i>, <i class="farg">...</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<p>
The <b class="fname">gzprintf</b>() function converts, formats, and writes the args to the compressed file under control of the format string, as in <a class="link-man" href="../html3/fprintf.html">fprintf(3)</a>. <b class="fname">gzprintf</b>() returns the number of uncompressed bytes actually written (0 in case of error).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">int</i> <b class="fname">gzputs</b>(<i class="farg">gzFile file</i>, <i class="farg">const char *s</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<p>
The <b class="fname">gzputs</b>() function writes the given null-terminated string to the compressed file, excluding the terminating null character.<p>
<b class="fname">gzputs</b>() returns the number of characters written, or &#45;1 in case of error.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">char *</i> <b class="fname">gzgets</b>(<i class="farg">gzFile file</i>, <i class="farg">char *buf</i>, <i class="farg">int len</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<p>
The <b class="fname">gzgets</b>() function reads bytes from the compressed file until len&#45;1 characters are read, or a newline character is read and transferred to <i class="farg">buf</i>, or an end-of-file condition is encountered. The string is then terminated with a null character.<p>
<b class="fname">gzgets</b>() returns <i class="farg">buf</i>, or <span class="define">Z_NULL</span> in case of error.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">int</i> <b class="fname">gzputc</b>(<i class="farg">gzFile file</i>, <i class="farg">int c</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<p>
The <b class="fname">gzputc</b>() function writes <i class="farg">c</i>, converted to an unsigned char, into the compressed file. <b class="fname">gzputc</b>() returns the value that was written, or &#45;1 in case of error.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">int</i> <b class="fname">gzgetc</b>(<i class="farg">gzFile file</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<p>
The <b class="fname">gzgetc</b>() function reads one byte from the compressed file. <b class="fname">gzgetc</b>() returns this byte or &#45;1 in case of end of file or error.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">int</i> <b class="fname">gzflush</b>(<i class="farg">gzFile file</i>, <i class="farg">int flush</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<p>
The <b class="fname">gzflush</b>() function flushes all pending output into the compressed file. The parameter <i class="farg">flush</i> is as in the <b class="fname">deflate</b>() function. The return value is the <b class="name">zlib</b> error number (see function <b class="fname">gzerror</b>() below). <b class="fname">gzflush</b>() returns <span class="define">Z_OK</span> if the flush parameter is <span class="define">Z_FINISH</span> and all output could be flushed.<p>
<b class="fname">gzflush</b>() should be called only when strictly necessary because it can degrade compression.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">z_off_t</i> <b class="fname">gzseek</b>(<i class="farg">gzFile file</i>, <i class="farg">z_off_t offset</i>, <i class="farg">int whence</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<p>
Sets the starting position for the next <b class="fname">gzread</b>() or <b class="fname">gzwrite</b>() on the given compressed file. The offset represents a number of bytes in the uncompressed data stream. The whence parameter is defined as in <a class="link-man" href="../html2/lseek.html">lseek(2)</a>; the value <span class="define">SEEK_END</span> is not supported.<p>
If the file is opened for reading, this function is emulated but can be extremely slow. If the file is opened for writing, only forward seeks are supported; <b class="fname">gzseek</b>() then compresses a sequence of zeroes up to the new starting position.<p>
<b class="fname">gzseek</b>() returns the resulting offset location as measured in bytes from the beginning of the uncompressed stream, or &#45;1 in case of error, in particular if the file is opened for writing and the new starting position would be before the current position.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">int</i> <b class="fname">gzrewind</b>(<i class="farg">gzFile file</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<p>
The <b class="fname">gzrewind</b>() function rewinds the given <i class="farg">file</i>. This function is supported only for reading.<p>
gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">z_off_t</i> <b class="fname">gztell</b>(<i class="farg">gzFile file</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<p>
The <b class="fname">gztell</b>() function returns the starting position for the next <b class="fname">gzread</b>() or <b class="fname">gzwrite</b>() on the given compressed file. This position represents a number of bytes in the uncompressed data stream.<p>
gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">int</i> <b class="fname">gzeof</b>(<i class="farg">gzFile file</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<p>
The <b class="fname">gzeof</b>() function returns 1 when <span class="define">EOF</span> has previously been detected reading the given input stream, otherwise zero.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">int</i> <b class="fname">gzclose</b>(<i class="farg">gzFile file</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<p>
The <b class="fname">gzclose</b>() function flushes all pending output if necessary, closes the compressed file and deallocates all the (de)compression state. The return value is the <b class="name">zlib</b> error number (see function <b class="fname">gzerror</b>() below).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">const char *</i> <b class="fname">gzerror</b>(<i class="farg">gzFile file</i>, <i class="farg">int *errnum</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
<p>
The <b class="fname">gzerror</b>() function returns the error message for the last error which occurred on the given compressed <i class="farg">file</i>. <i class="farg">errnum</i> is set to the <b class="name">zlib</b> error number. If an error occurred in the file system and not in the compression library, <i class="farg">errnum</i> is set to <span class="define">Z_ERRNO</span> and the application may consult errno to get the exact error code.</dd>
</dl>
</div>
<div class="section">
<h1 id="x434845434b53554d2046554e4354494f4e53">CHECKSUM FUNCTIONS</h1> These functions are not related to compression but are exported anyway because they might be useful in applications using the compression library.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">uLong</i> <b class="fname">adler32</b>(<i class="farg">uLong adler</i>, <i class="farg">const Bytef *buf</i>, <i class="farg">uInt len</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The <b class="fname">adler32</b>() function updates a running Adler-32 checksum with the bytes buf[0..len-1] and returns the updated checksum. If <i class="farg">buf</i> is <span class="define">NULL</span>, this function returns the required initial value for the checksum.<p>
An Adler-32 checksum is almost as reliable as a CRC32 but can be computed much faster. Usage example:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
uLong adler = adler32(0L, Z_NULL, 0); 
 
while (read_buffer(buffer, length) != EOF) { 
adler = adler32(adler, buffer, length); 
} 
if (adler != original_adler) error();</pre>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">uLong</i> <b class="fname">crc32</b>(<i class="farg">uLong crc</i>, <i class="farg">const Bytef *buf</i>, <i class="farg">uInt len</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The <b class="fname">crc32</b>() function updates a running CRC with the bytes buf[0..len-1] and returns the updated CRC. If <i class="farg">buf</i> is <span class="define">NULL</span>, this function returns the required initial value for the CRC. Pre- and post-conditioning (one's complement) is performed within this function so it shouldn't be done by the application. Usage example:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
uLong crc = crc32(0L, Z_NULL, 0); 
 
while (read_buffer(buffer, length) != EOF) { 
crc = crc32(crc, buffer, length); 
} 
if (crc != original_crc) error();</pre>
</dd>
</dl>
</div>
<div class="section">
<h1 id="x53545255435455524553">STRUCTURES</h1><pre style="margin-left: 0.00ex;" class="lit display">
struct internal_state; 
 
typedef struct z_stream_s { 
    Bytef    *next_in;  /* next input byte */ 
    uInt     avail_in;  /* number of bytes available at next_in */ 
    uLong    total_in;  /* total nb of input bytes read so far */ 
 
    Bytef    *next_out; /* next output byte should be put there */ 
    uInt     avail_out; /* remaining free space at next_out */ 
    uLong    total_out; /* total nb of bytes output so far */ 
 
    char     *msg;      /* last error message, NULL if no error */ 
    struct internal_state FAR *state; /* not visible by applications */ 
 
    alloc_func zalloc;  /* used to allocate the internal state */ 
    free_func  zfree;   /* used to free the internal state */ 
    voidpf     opaque;  /* private data object passed to zalloc and zfree*/ 
 
    int     data_type;  /*best guess about the data type: ascii or binary*/ 
    uLong   adler;      /* Adler-32 value of the uncompressed data */ 
    uLong   reserved;   /* reserved for future use */ 
} z_stream; 
 
typedef z_stream FAR * z_streamp;</pre>
<p>
The application must update <i class="farg">next_in</i> and <i class="farg">avail_in</i> when <i class="farg">avail_in</i> has dropped to zero. It must update <i class="farg">next_out</i> and <i class="farg">avail_out</i> when <i class="farg">avail_out</i> has dropped to zero. The application must initialize <i class="farg">zalloc</i>, <i class="farg">zfree</i>, and <i class="farg">opaque</i> before calling the init function. All other fields are set by the compression library and must not be updated by the application.<p>
The <i class="farg">opaque</i> value provided by the application will be passed as the first parameter for calls to <b class="fname">zalloc</b>() and <b class="fname">zfree</b>(). This can be useful for custom memory management. The compression library attaches no meaning to the <i class="farg">opaque</i> value.<p>
<i class="farg">zalloc</i> must return <span class="define">Z_NULL</span> if there is not enough memory for the object. If <b class="name">zlib</b> is used in a multi-threaded application, <i class="farg">zalloc</i> and <i class="farg">zfree</i> must be thread safe.<p>
On 16-bit systems, the functions <i class="farg">zalloc</i> and <i class="farg">zfree</i> must be able to allocate exactly 65536 bytes, but will not be required to allocate more than this if the symbol MAXSEG_64K is defined (see <b class="includes">&lt;<a class="link-includes">zconf.h</a>&gt;</b>).<p>
WARNING: On MSDOS, pointers returned by <i class="farg">zalloc</i> for objects of exactly 65536 bytes *must* have their offset normalized to zero. The default allocation function provided by this library ensures this (see <i class="file">zutil.c</i>). To reduce memory requirements and avoid any allocation of 64K objects, at the expense of compression ratio, compile the library with -DMAX_WBITS=14 (see <b class="includes">&lt;<a class="link-includes">zconf.h</a>&gt;</b>).<p>
The fields <i class="farg">total_in</i> and <i class="farg">total_out</i> can be used for statistics or progress reports. After compression, <i class="farg">total_in</i> holds the total size of the uncompressed data and may be saved for use in the decompressor (particularly if the decompressor wants to decompress everything in a single step).</div>
<div class="section">
<h1 id="x434f4e5354414e5453">CONSTANTS</h1><pre style="margin-left: 0.00ex;" class="lit display">
#define Z_NO_FLUSH      0 
#define Z_PARTIAL_FLUSH 1 /* will be removed, use Z_SYNC_FLUSH instead */ 
#define Z_SYNC_FLUSH    2 
#define Z_FULL_FLUSH    3 
#define Z_FINISH        4 
/* Allowed flush values; see deflate() below for details */ 
 
#define Z_OK            0 
#define Z_STREAM_END    1 
#define Z_NEED_DICT     2 
#define Z_ERRNO        (-1) 
#define Z_STREAM_ERROR (-2) 
#define Z_DATA_ERROR   (-3) 
#define Z_MEM_ERROR    (-4) 
#define Z_BUF_ERROR    (-5) 
#define Z_VERSION_ERROR (-6) 
/* Return codes for the compression/decompression functions. 
 * Negative values are errors, 
 * positive values are used for special but normal events. 
 */ 
 
#define Z_NO_COMPRESSION         0 
#define Z_BEST_SPEED             1 
#define Z_BEST_COMPRESSION       9 
#define Z_DEFAULT_COMPRESSION  (-1) 
/* compression levels */ 
 
#define Z_FILTERED            1 
#define Z_HUFFMAN_ONLY        2 
#define Z_DEFAULT_STRATEGY    0 
/* compression strategy; see deflateInit2() below for details */ 
 
#define Z_BINARY   0 
#define Z_ASCII    1 
#define Z_UNKNOWN  2 
/* Possible values of the data_type field */ 
 
#define Z_DEFLATED   8 
/* The deflate compression method 
 * (the only one supported in this version) 
*/ 
 
#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */ 
 
#define zlib_version zlibVersion() 
/* for compatibility with versions &lt; 1.0.2 */</pre>
</div>
<div class="section">
<h1 id="x564152494f5553204841434b53">VARIOUS HACKS</h1> deflateInit and inflateInit are macros to allow checking the <b class="name">zlib</b> version and the compiler's view of <i class="farg">z_stream</i>.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">int</i> <b class="fname">deflateInit_</b>(<i class="farg">z_stream strm</i>, <i class="farg">int level</i>, <i class="farg">const char *version</i>, <i class="farg">int stream_size</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">int</i> <b class="fname">inflateInit_</b>(<i class="farg">z_stream strm</i>, <i class="farg">const char *version</i>, <i class="farg">int stream_size</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">int</i> <b class="fname">deflateInit2_</b>(<i class="farg">z_stream strm</i>, <i class="farg">int level</i>, <i class="farg">int method</i>, <i class="farg">int windowBits</i>, <i class="farg">int memLevel</i>, <i class="farg">int strategy</i>, <i class="farg">const char *version</i>, <i class="farg">int stream_size</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">int</i> <b class="fname">inflateInit2_</b>(<i class="farg">z_stream strm</i>, <i class="farg">int windowBits</i>, <i class="farg">const char *version</i>, <i class="farg">int stream_size</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">const char *</i> <b class="fname">zError</b>(<i class="farg">int err</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">int</i> <b class="fname">inflateSyncPoint</b>(<i class="farg">z_streamp z</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">const uLongf *</i> <b class="fname">get_crc_table</b>(<i class="farg">void</i>);</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
</dd>
</dl>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
RFC 1950</dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
ZLIB Compressed Data Format Specification.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
RFC 1951</dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
DEFLATE Compressed Data Format Specification.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
RFC 1952</dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
GZIP File Format Specification.</dd>
</dl>
<p>
<a class="link-ext" href="http://www.gzip.org/zlib/">zlib</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> This manual page is based on an HTML version of <b class="includes">&lt;<a class="link-includes">zlib.h</a>&gt;</b> converted by <span class="author">piaip</span> &#60;<a class="link-mail" href="mailto:piaip@csie.ntu.edu.tw">piaip@csie.ntu.edu.tw</a>&#62; and was converted to mdoc format by the <span class="unix">OpenBSD</span> project.</div>
<div class="section">
<h1 id="x415554484f5253">AUTHORS</h1> <span class="author">Jean-loup Gailly</span> &#60;<a class="link-mail" href="mailto:jloup@gzip.org">jloup@gzip.org</a>&#62; <span class="author">Mark Adler</span> &#60;<a class="link-mail" href="mailto:madler@alumni.caltech.edu">madler@alumni.caltech.edu</a>&#62;</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
May 1, 2004</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

