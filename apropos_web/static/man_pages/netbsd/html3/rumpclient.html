<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="/static/man_pages/netbsd/style.css" type="text/css" media="all">
<title>
RUMPCLIENT(3)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
RUMPCLIENT(3)</td>
<td class="head-vol" align="center">
Library Functions Manual</td>
<td class="head-rtitle" align="right">
RUMPCLIENT(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">rumpclient</b> &#8212; <span class="desc">rump client library</span></div>
<div class="section">
<h1 id="x4c494252415259">LIBRARY</h1> <span class="lib">library &#8220;rumpclient&#8221;</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">rump/rumpclient.h</a>&gt;</b><br>
<b class="includes">#include &lt;<a class="link-includes">rump/rump_syscalls.h</a>&gt;</b><p>
<i class="ftype">int</i><br>
<b class="fname">rumpclient_init</b>();<p>
<i class="ftype">pid_t</i><br>
<b class="fname">rumpclient_fork</b>();<p>
<i class="ftype">pid_t</i><br>
<b class="fname">rumpclient_vfork</b>();<p>
<i class="ftype">struct rumpclient_fork *</i><br>
<b class="fname">rumpclient_prefork</b>();<p>
<i class="ftype">int</i><br>
<b class="fname">rumpclient_fork_init</b>(<i class="farg" style="white-space:nowrap;">struct rumpclient_fork *rfp</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">rumpclient_fork_cancel</b>(<i class="farg" style="white-space:nowrap;">struct rumpclient_fork *rfp</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">rumpclient_exec</b>(<i class="farg" style="white-space:nowrap;">const char *path</i>, <i class="farg" style="white-space:nowrap;">char *const argv[]</i>, <i class="farg" style="white-space:nowrap;">char *const envp[]</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">rumpclient_daemon</b>(<i class="farg" style="white-space:nowrap;">int nochdir</i>, <i class="farg" style="white-space:nowrap;">int noclose</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">rumpclient_setconnretry</b>(<i class="farg" style="white-space:nowrap;">time_t retrytime</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">rumpclient_syscall</b>(<i class="farg">int num</i>, <i class="farg">const void *sysarg</i>, <i class="farg">size_t argsize</i>, <i class="farg">register_t *retval</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> <b class="name">rumpclient</b> is the clientside implementation of the <a class="link-man" href="../7/rump_sp">rump_sp(7)</a> facility. It can be used to connect to a rump kernel server and make system call style requests.<p>
Every connection to a rump kernel server creates a new process context in the rump kernel. By default a process is inherited from init, but through existing connections and the forking facility offered by <b class="name">rumpclient</b> it is possible to form process trees.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">rumpclient_init</b>()</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Initialize <b class="name">rumpclient</b>. The server address is determined from the environment variable <span class="env">RUMP_SERVER</span> according to syntax described in <a class="link-man" href="../7/rump_sp">rump_sp(7)</a>. The new process is registered to the rump kernel with the command name from <a class="link-man" href="../3/getprogname">getprogname(3)</a>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">rumpclient_fork</b>()</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Fork a rump client process. This also causes a host process fork via <a class="link-man" href="../2/fork">fork(2)</a>. The child will have a copy of the parent's rump kernel file descriptors.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">rumpclient_vfork</b>()</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Like above, but the host uses <a class="link-man" href="../2/vfork">vfork(2)</a>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">rumpclient_prefork</b>()</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Low-level routine which instructs the rump kernel that the current process is planning to fork. The routine returns a non-<span class="define">NULL</span> cookie if successful.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">rumpclient_fork_init</b>(<i class="farg">rfp</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Low-level routine which works like <b class="fname">rumpclient_init</b>(), with the exception that it uses the <i class="arg">rfp</i> context created by a call to <b class="fname">rumpclient_prefork</b>(). This is typically called from the child of a <a class="link-man" href="../2/fork">fork(2)</a> call.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">rumpclient_fork_cancel</b>(<i class="farg">rfp</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Cancel previously initiated prefork context. This is useful for error handling in case a full fork could not be carried through.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">rumpclient_exec</b>(<i class="farg">path</i>, <i class="farg">argv</i>, <i class="farg">envp</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
This call is a <b class="name">rumpclient</b> wrapper around <a class="link-man" href="../2/execve">execve(2)</a>. The wrapper makes sure that the rump kernel process context stays the same in the newly executed program. This means that the rump kernel PID remains the same and the same rump file descriptors are available (apart from ones which were marked with <span class="define">FD_CLOEXEC</span>).<p>
It should be noted that the newly executed program must call <b class="fname">rumpclient_init</b>() before any other rump kernel communication can take place. The wrapper cannot do it because it no longer has program control. However, since all rump clients call the init routine, this should not be a problem.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">rumpclient_daemon</b>(<i class="farg">noclose</i>, <i class="farg">nochdir</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
This function performs the equivalent of <a class="link-man" href="../3/daemon">daemon(3)</a>, but also ensures that the internal call to <a class="link-man" href="../2/fork">fork(2)</a> is handled properly. This routine is provided for convenience.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">rumpclient_setconnretry</b>(<i class="farg">retrytime</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Set the timeout for how long the client attempts to reconnect to the server in case of a broken connection. After the timeout expires the client will return a failure for that particular request. It is critical to note that after a restablished connection the rump kernel context will be that of a newly connected client. This means all previous kernel state such as file descriptors will be lost. It is largely up to a particular application if this has impact or not. For example, web browsers tend to recover fairly smoothly from a kernel server reconnect, while <a class="link-man" href="../8/sshd">sshd(8)</a> gets confused if its sockets go missing.<p>
If <i class="arg">retrytime</i> is a positive integer, it means the number of seconds for which reconnection will be attempted. The value 0 means that reconnection will not be attempted, and all subsequent operations will return the errno <span class="errno">ENOTCONN</span>.<p>
Additionally, the following special values are accepted:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">RUMPCLIENT_RETRYCONN_INFTIME</span></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Attempt reconnection indefinitely.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">RUMPCLIENT_RETRYCONN_ONCE</span></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Attempt reconnect exactly once. What this precisely means depends on the situation: e.g. getting <span class="errno">EHOSTUNREACH</span> immediately or the TCP connection request timeouting are considered to be one retry.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">RUMPCLIENT_RETRYCONN_DIE</span></dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
In case of a broken connection is detected at runtime, call <a class="link-man" href="../3/exit">exit(3)</a>. This is useful for example in testing. It ensures that clients are killed immediately when they attempt to communicate with a halted server.</dd>
</dl>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">rumpclient_syscall</b>(<i class="farg">num</i>, <i class="farg">sysarg</i>, <i class="farg">argsize</i>, <i class="farg">retval</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Execute an "indirect" system call. In the normal case system calls are executed through the interfaces in <b class="includes">&lt;<a class="link-includes">rump/rump_syscalls.h</a>&gt;</b> (for example <b class="fname">rump_sys_read</b>(<i class="farg">fd</i>, <i class="farg">buf</i>, <i class="farg">nbytes</i>)). This interface allows calling the server with pre-marshalled arguments.</dd>
</dl>
<p>
Additionally, all of the supported rump system calls are available through this library. See <b class="includes">&lt;<a class="link-includes">rump/rump_syscalls.h</a>&gt;</b> for a list.</div>
<div class="section">
<h1 id="x52455455524e2056414c554553">RETURN VALUES</h1> <b class="name">rumpclient</b> routines return &#45;1 in case of error and set errno. In case of success a non-negative integer is returned, where applicable.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../1/rump_server">rump_server(1)</a>, <a class="link-man" href="../3/rump">rump(3)</a>, <a class="link-man" href="../7/rump_sp">rump_sp(7)</a></div>
<div class="section">
<h1 id="x43415645415453">CAVEATS</h1> Interfaces for a cryptographically authenticated client-server handshake do not currently exist. This can be worked around with e.g. host access control and an ssh tunnel.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
February 16, 2011</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

