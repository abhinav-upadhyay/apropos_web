<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
CMSG_DATA(3)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
CMSG_DATA(3)</td>
<td class="head-vol" align="center">
Library Functions Manual</td>
<td class="head-rtitle" align="right">
CMSG_DATA(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">CMSG_DATA</b>, <b class="name">CMSG_FIRSTHDR</b>, <b class="name">CMSG_LEN</b>, <b class="name">CMSG_NXTHDR</b>, <b class="name">CMSG_SPACE</b> &#8212; <span class="desc">socket control message routines</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/socket.h</a>&gt;</b><p>
<i class="ftype">unsigned char *</i><br>
<b class="fname">CMSG_DATA</b>(<i class="farg" style="white-space:nowrap;">struct cmsghdr *</i>);<p>
<i class="ftype">const unsigned char *</i><br>
<b class="fname">CCMSG_DATA</b>(<i class="farg" style="white-space:nowrap;">struct cmsghdr *</i>);<p>
<i class="ftype">struct cmsghdr *</i><br>
<b class="fname">CMSG_FIRSTHDR</b>(<i class="farg" style="white-space:nowrap;">struct msghdr *</i>);<p>
<i class="ftype">size_t</i><br>
<b class="fname">CMSG_LEN</b>(<i class="farg" style="white-space:nowrap;">size_t</i>);<p>
<i class="ftype">struct cmsghdr *</i><br>
<b class="fname">CMSG_NXTHDR</b>(<i class="farg" style="white-space:nowrap;">struct msghdr *</i>, <i class="farg" style="white-space:nowrap;">struct cmsghdr *</i>);<p>
<i class="ftype">size_t</i><br>
<b class="fname">CMSG_SPACE</b>(<i class="farg" style="white-space:nowrap;">size_t</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The control message API is used to construct ancillary data objects for use in control messages sent and received across sockets.<p>
Control messages are passed around by the <a class="link-man" href="../html2/recvmsg.html">recvmsg(2)</a> and <a class="link-man" href="../html2/sendmsg.html">sendmsg(2)</a> system calls. The <span class="type">cmsghdr</span> structure, described in <a class="link-man" href="../html2/recvmsg.html">recvmsg(2)</a>, is used to specify a chain of control messages.<p>
These routines should be used instead of directly accessing the control message header members and data buffers as they ensure that necessary alignment constraints are met.<p>
The following routines are provided:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">CMSG_DATA</b>(<i class="farg">cmsg</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This routine accesses the data portion of the control message header <i class="farg">cmsg</i>. It ensures proper alignment constraints on the beginning of ancillary data are met.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">CMSG_FIRSTHDR</b>(<i class="farg">mhdr</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This routine accesses the first control message attached to the message <i class="farg">msg</i>. If no control messages are attached to the message, this routine returns <span class="define">NULL</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">CMSG_LEN</b>(<i class="farg">len</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This routine determines the size in bytes of a control message, which includes the control message header. <i class="farg">len</i> specifies the length of the data held by the control message. This value is what is normally stored in the <i class="farg">cmsg_len</i> of each control message. This routine accounts for any alignment constraints on the beginning of ancillary data. This macro might not evaluate to a compile-time constant.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">CMSG_NXTHDR</b>(<i class="farg">mhdr</i>, <i class="farg">cmsg</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This routine returns the location of the control message following <i class="farg">cmsg</i> in the message <i class="farg">mhdr</i>. If <i class="farg">cmsg</i> is the last control message in the chain, this routine returns <span class="define">NULL</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">CMSG_SPACE</b>(<i class="farg">len</i>)</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This routine determines the size in bytes needed to hold a control message and its contents of length <i class="farg">len</i>, which includes the control message header. This value is what is normally stored in <i class="farg">msg_msgcontrollen</i>. This routine accounts for any alignment constraints on the beginning of ancillary data as well as any needed to pad the next control message. This macro might not evaluate to a compile-time constant.</dd>
</dl>
</div>
<div class="section">
<h1 id="x4558414d504c4553">EXAMPLES</h1> The following example constructs a control message containing a file descriptor and passes it over a socket:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
struct msghdr	 msg; 
struct cmsghdr	*cmsg; 
/* We use a union to make sure hdr is aligned */ 
union { 
	struct cmsghdr hdr; 
	unsigned char	 buf[CMSG_SPACE(sizeof(int))]; 
} *cmsgbuf; 
 
/* 
 * We allocate in the heap instead of the stack to avoid C99 
 * variable stack allocation, which breaks gcc -fstack-protector. 
 */ 
if ((cmsgbuf = malloc(sizeof(*cmsgbuf))) == NULL) 
	err(1, "malloc"); 
(void)memset(&amp;msg, 0, sizeof(msg)); 
msg.msg_control = cmsgbuf-&gt;buf; 
msg.msg_controllen = sizeof(cmsgbuf-&gt;buf); 
 
cmsg = CMSG_FIRSTHDR(&amp;msg); 
cmsg-&gt;cmsg_len = CMSG_LEN(sizeof(int)); 
cmsg-&gt;cmsg_level = SOL_SOCKET; 
cmsg-&gt;cmsg_type = SCM_RIGHTS; 
*(int *)CMSG_DATA(cmsg) = fd; 
 
if (sendmsg(s, &amp;msg, 0) == -1) 
	err(1, "sendmsg"); 
free(cmsgbuf);</pre>
<p>
And an example that receives and decomposes the control message:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
struct msghdr	 msg; 
struct cmsghdr	*cmsg; 
union { 
	struct cmsghdr hdr; 
	unsigned char	 buf[CMSG_SPACE(sizeof(int))]; 
} *cmsgbuf; 
 
if ((cmsgbuf = malloc(sizeof(*cmsgbuf))) == NULL) 
	err(1, "malloc"); 
(void)memset(&amp;msg, 0, sizeof(msg)); 
msg.msg_control = cmsgbuf-&gt;buf; 
msg.msg_controllen = sizeof(cmsgbuf-&gt;buf); 
 
if (recvmsg(s, &amp;msg, 0) == -1) 
	err(1, "recvmsg"); 
if ((msg.msg_flags &amp; (MSG_TRUNC|MSG_CTRUNC)) 
	errx(1, "control message truncated"); 
for (cmsg = CMSG_FIRSTHDR(&amp;msg); cmsg != NULL; 
    cmsg = CMSG_NXTHDR(&amp;msg, cmsg)) { 
	if (cmsg-&gt;cmsg_len == CMSG_LEN(sizeof(int)) &amp;&amp; 
	    cmsg-&gt;cmsg_level == SOL_SOCKET &amp;&amp; 
	    cmsg-&gt;cmsg_type == SCM_RIGHTS) { 
		fd = *(int *)CMSG_DATA(cmsg); 
		/* Do something with the descriptor. */ 
	} 
} 
free(cmsgbuf);</pre>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html2/recvmsg.html">recvmsg(2)</a>, <a class="link-man" href="../html2/sendmsg.html">sendmsg(2)</a>, <a class="link-man" href="../html2/socket.html">socket(2)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The control message API first appeared in <span class="unix">4.2BSD</span>.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
January 24, 2015</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

