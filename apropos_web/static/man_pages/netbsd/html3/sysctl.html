<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="/static/man_pages/netbsd/style.css" type="text/css" media="all">
<title>
SYSCTL(3)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
SYSCTL(3)</td>
<td class="head-vol" align="center">
Library Functions Manual</td>
<td class="head-rtitle" align="right">
SYSCTL(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">sysctl</b>, <b class="name">sysctlbyname</b>, <b class="name">sysctlgetmibinfo</b>, <b class="name">sysctlnametomib</b>, <b class="name">asysctl</b>, <b class="name">asysctlbyname</b> &#8212; <span class="desc">get or set system information</span></div>
<div class="section">
<h1 id="x4c494252415259">LIBRARY</h1> <span class="lib">Standard C Library (libc, &#45;lc)</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/param.h</a>&gt;</b><br>
<b class="includes">#include &lt;<a class="link-includes">sys/sysctl.h</a>&gt;</b><p>
<i class="ftype">int</i><br>
<b class="fname">sysctl</b>(<i class="farg" style="white-space:nowrap;">const int *name</i>, <i class="farg" style="white-space:nowrap;">u_int namelen</i>, <i class="farg" style="white-space:nowrap;">void *oldp</i>, <i class="farg" style="white-space:nowrap;">size_t *oldlenp</i>, <i class="farg" style="white-space:nowrap;">const void *newp</i>, <i class="farg" style="white-space:nowrap;">size_t newlen</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">sysctlbyname</b>(<i class="farg" style="white-space:nowrap;">const char *sname</i>, <i class="farg" style="white-space:nowrap;">void *oldp</i>, <i class="farg" style="white-space:nowrap;">size_t *oldlenp</i>, <i class="farg" style="white-space:nowrap;">const void *newp</i>, <i class="farg" style="white-space:nowrap;">size_t newlen</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">sysctlgetmibinfo</b>(<i class="farg" style="white-space:nowrap;">const char *sname</i>, <i class="farg" style="white-space:nowrap;">int *name</i>, <i class="farg" style="white-space:nowrap;">u_int *namelenp</i>, <i class="farg" style="white-space:nowrap;">char *cname</i>, <i class="farg" style="white-space:nowrap;">size_t *csz</i>, <i class="farg" style="white-space:nowrap;">struct sysctlnode **rnode</i>, <i class="farg" style="white-space:nowrap;">int v</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">sysctlnametomib</b>(<i class="farg" style="white-space:nowrap;">const char *sname</i>, <i class="farg" style="white-space:nowrap;">int *name</i>, <i class="farg" style="white-space:nowrap;">size_t *namelenp</i>);<p>
<i class="ftype">void *</i><br>
<b class="fname">asysctl</b>(<i class="farg" style="white-space:nowrap;">const int *name</i>, <i class="farg" style="white-space:nowrap;">size_t namelen</i>, <i class="farg" style="white-space:nowrap;">size_t *len</i>);<p>
<i class="ftype">void *</i><br>
<b class="fname">asysctlbyname</b>(<i class="farg" style="white-space:nowrap;">const char *sname</i>, <i class="farg" style="white-space:nowrap;">size_t *len</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <b class="name">sysctl</b> function retrieves system information and allows processes with appropriate privileges to set system information. The information available from <b class="name">sysctl</b> consists of integers, strings, and tables. Information may be retrieved and set from the command interface using the <a class="link-man" href="../8/sysctl">sysctl(8)</a> utility.<p>
Unless explicitly noted below, <b class="name">sysctl</b> returns a consistent snapshot of the data requested. Consistency is obtained by locking the destination buffer into memory so that the data may be copied out without blocking. Calls to <b class="name">sysctl</b> are serialized to avoid deadlock.<p>
The state is described using a ``Management Information Base'' (MIB) style name, listed in <i class="farg">name</i>, which is a <i class="farg">namelen</i> length array of integers.<p>
The <b class="fname">sysctlbyname</b>() function accepts a string representation of a MIB entry and internally maps it to the appropriate numeric MIB representation. Its semantics are otherwise no different from <b class="fname">sysctl</b>().<p>
The information is copied into the buffer specified by <i class="farg">oldp</i>. The size of the buffer is given by the location specified by <i class="farg">oldlenp</i> before the call, and that location gives the amount of data copied after a successful call. If the amount of data available is greater than the size of the buffer supplied, the call supplies as much data as fits in the buffer provided and returns with the error code ENOMEM. If the old value is not desired, <i class="farg">oldp</i> and <i class="farg">oldlenp</i> should be set to <span class="define">NULL</span>.<p>
The size of the available data can be determined by calling <b class="name">sysctl</b> with a <span class="define">NULL</span> parameter for <i class="farg">oldp</i>. The size of the available data will be returned in the location pointed to by <i class="farg">oldlenp</i>. For some operations, the amount of space may change often. For these operations, the system attempts to round up so that the returned size is large enough for a call to return the data shortly thereafter.<p>
To set a new value, <i class="farg">newp</i> is set to point to a buffer of length <i class="farg">newlen</i> from which the requested value is to be taken. If a new value is not to be set, <i class="farg">newp</i> should be set to <span class="define">NULL</span> and <i class="farg">newlen</i> set to 0.<p>
The <b class="fname">sysctlnametomib</b>() function can be used to map the string representation of a MIB entry to the numeric version. The <i class="farg">name</i> argument should point to an array of integers large enough to hold the MIB, and <i class="farg">namelenp</i> should indicate the number of integer slots available. Following a successful translation, the size_t indicated by <i class="farg">namelenp</i> will be changed to show the number of slots consumed.<p>
The <b class="fname">sysctlgetmibinfo</b>() function performs name translation similar to <b class="fname">sysctlnametomib</b>(), but also canonicalizes the name (or returns the first erroneous token from the string being parsed) into the space indicated by <i class="farg">cname</i> and <i class="farg">csz</i>. <i class="farg">csz</i> should indicate the size of the buffer pointed to by <i class="farg">cname</i> and on return, will indicate the size of the returned string including the trailing &#8216;nul&#8217; character.<p>
The <i class="farg">rnode</i> and <i class="farg">v</i> arguments to <b class="fname">sysctlgetmibinfo</b>() are used to provide a tree for it to parse into, and to get back either a pointer to, or a copy of, the terminal node. If <i class="farg">rnode</i> is <span class="define">NULL</span>, <b class="fname">sysctlgetmibinfo</b>() uses its own internal tree for parsing, and checks it against the kernel at each call, to make sure that the name-to-number mapping is kept up to date. The <i class="farg">v</i> argument is ignored in this case. If <i class="farg">rnode</i> is not <span class="define">NULL</span> but the pointer it references is, on a successful return, <i class="farg">rnode</i> will be adjusted to point to a copy of the terminal node. The <i class="farg">v</i> argument indicates which version of the <b class="name">sysctl</b> node structure the caller wants. The application must later <b class="fname">free</b>() this copy. If neither <i class="farg">rnode</i> nor the pointer it references are <span class="define">NULL</span>, the pointer is used as the address of a tree over which the parsing is done. In this last case, the tree is not checked against the kernel, no refreshing of the mappings is performed, and the value given by <i class="farg">v</i> must agree with the version indicated by the tree. It is recommended that applications always use <span class="define">SYSCTL_VERSION</span> as the value for <i class="farg">v</i>, as defined in the include file <i class="file">sys/sysctl.h</i>.<p>
The numeric and text names of sysctl variables are described in <a class="link-man" href="../7/sysctl">sysctl(7)</a>. The numeric names are defined as preprocessor macros. The top level names are defined with a CTL_ prefix in <b class="includes">&lt;<a class="link-includes">sys/sysctl.h</a>&gt;</b>. The next and subsequent levels down have different prefixes for each subtree.<p>
For example, the following retrieves the maximum number of processes allowed in the system - the <code class="lit">kern.maxproc</code> variable:<pre style="margin-left: 5.00ex;" class="lit display">
int mib[2], maxproc; 
size_t len; 
<div style="height: 1.00em;">
&#160;</div>
mib[0] = CTL_KERN; 
mib[1] = KERN_MAXPROC; 
len = sizeof(maxproc); 
sysctl(mib, 2, &amp;maxproc, &amp;len, NULL, 0);</pre>
<div style="height: 1.00em;">
&#160;</div>
To retrieve the standard search path for the system utilities - <code class="lit">user.cs_path</code>:<pre style="margin-left: 5.00ex;" class="lit display">
int mib[2]; 
size_t len; 
char *p; 
<div style="height: 1.00em;">
&#160;</div>
mib[0] = CTL_USER; 
mib[1] = USER_CS_PATH; 
sysctl(mib, 2, NULL, &amp;len, NULL, 0); 
p = malloc(len); 
sysctl(mib, 2, p, &amp;len, NULL, 0);</pre>
<p>
The <b class="fname">asysctl</b>() and <b class="fname">asysctlbyname</b>() functions are wrappers for <b class="fname">sysctl</b>() and <b class="fname">sysctlbyname</b>(). They return memory allocated with <a class="link-man" href="../3/malloc">malloc(3)</a> and resize the buffer in a loop until all data fits.</div>
<div class="section">
<h1 id="x44594e414d4943204f5045524154494f4e53">DYNAMIC OPERATIONS</h1> Several meta-identifiers are provided to perform operations on the <b class="name">sysctl</b> tree itself, or support alternate means of accessing the data instrumented by the <b class="name">sysctl</b> tree.<table style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-col">
<col style="min-width: 16.00ex;">
<tbody>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">Name</span></td>
<td class="list-col" style="margin-top: 1.00em;">
Description</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
CTL_QUERY</td>
<td class="list-col" style="margin-top: 1.00em;">
Retrieve a mapping of names to numbers below a given node</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
CTL_CREATE</td>
<td class="list-col" style="margin-top: 1.00em;">
Create a new node</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
CTL_CREATESYM</td>
<td class="list-col" style="margin-top: 1.00em;">
Create a new node by its kernel symbol</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
CTL_DESTROY</td>
<td class="list-col" style="margin-top: 1.00em;">
Destroy a node</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
CTL_DESCRIBE</td>
<td class="list-col" style="margin-top: 1.00em;">
Retrieve node descriptions</td>
</tr>
</tbody>
</table>
<p>
The core interface to all of these meta-functions is the structure that the kernel uses to describe the tree internally, as defined in <b class="includes">&lt;<a class="link-includes">sys/sysctl.h</a>&gt;</b> as:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
struct sysctlnode { 
        uint32_t sysctl_flags;          /* flags and type */ 
        int32_t sysctl_num;             /* mib number */ 
        char sysctl_name[SYSCTL_NAMELEN]; /* node name */ 
        uint32_t sysctl_ver;        /* node's version vs. rest of tree */ 
        uint32_t __rsvd; 
        union { 
                struct { 
                        uint32_t suc_csize; /* size of child node array */ 
                        uint32_t suc_clen; /* number of valid children */ 
                        struct sysctlnode* suc_child; /* array of child nodes */ 
                } scu_child; 
                struct { 
                        void *sud_data; /* pointer to external data */ 
                        size_t sud_offset; /* offset to data */ 
                } scu_data; 
                int32_t scu_alias;      /* node this node refers to */ 
                int32_t scu_idata;      /* immediate "int" data */ 
                u_quad_t scu_qdata;     /* immediate "u_quad_t" data */ 
        } sysctl_un; 
        size_t _sysctl_size;            /* size of instrumented data */ 
        sysctlfn _sysctl_func;          /* access helper function */ 
        struct sysctlnode *sysctl_parent; /* parent of this node */ 
        const char *sysctl_desc;        /* description of node */ 
}; 
 
#define sysctl_csize    sysctl_un.scu_child.suc_csize 
#define sysctl_clen     sysctl_un.scu_child.suc_clen 
#define sysctl_child    sysctl_un.scu_child.suc_child 
#define sysctl_data     sysctl_un.scu_data.sud_data 
#define sysctl_offset   sysctl_un.scu_data.sud_offset 
#define sysctl_alias    sysctl_un.scu_alias 
#define sysctl_idata    sysctl_un.scu_idata 
#define sysctl_qdata    sysctl_un.scu_qdata</pre>
<p>
Querying the tree to discover the name to number mapping permits dynamic discovery of all the data that the tree currently has instrumented. For example, to discover all the nodes below the CTL_VFS node:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
struct sysctlnode query, vfs[128]; 
int mib[2]; 
size_t len; 
<div style="height: 1.00em;">
&#160;</div>
mib[0] = CTL_VFS; 
mib[1] = CTL_QUERY; 
memset(&amp;query, 0, sizeof(query)); 
query.sysctl_flags = SYSCTL_VERSION; 
len = sizeof(vfs); 
sysctl(mib, 2, &amp;vfs[0], &amp;len, &amp;query, sizeof(query));</pre>
<p>
Note that a reference to an empty node with <i class="farg">sysctl_flags</i> set to <span class="define">SYSCTL_VERSION</span> is passed to sysctl in order to indicate the version that the program is using. All dynamic operations passing nodes into sysctl require that the version be explicitly specified.<p>
Creation and destruction of nodes works by constructing part of a new node description (or a description of the existing node) and invoking CTL_CREATE (or CTL_CREATESYM) or CTL_DESTROY at the parent of the new node, with a pointer to the new node passed via the <i class="farg">new</i> and <i class="farg">newlen</i> arguments. If valid values for <i class="farg">old</i> and <i class="farg">oldlenp</i> are passed, a copy of the new node once in the tree will be returned. If the create operation fails because a node with the same name or MIB number exists, a copy of the conflicting node will be returned.<p>
The minimum requirements for creating a node are setting the <i class="farg">sysctl_flags</i> to indicate the new node's type, <i class="farg">sysctl_num</i> to either the new node's number (or CTL_CREATE or CTL_CREATESYM if a dynamically allocated MIB number is acceptable), <i class="farg">sysctl_size</i> to the size of the data to be instrumented (which must agree with the given type), and <i class="farg">sysctl_name</i> must be set to the new node's name. Nodes that are not of type &#8220;node&#8221; must also have some description of the data to be instrumented, which will vary depending on what is to be instrumented.<p>
If existing kernel data is to be covered by this new node, its address should be given in <i class="farg">sysctl_data</i> or, if CTL_CREATESYM is used, <i class="farg">sysctl_data</i> should be set to a string containing its name from the kernel's symbol table. If new data is to be instrumented and an initial value is available, the new integer or quad type data should be placed into either <i class="farg">sysctl_idata</i> or <i class="farg">sysctl_qdata</i>, respectively, along with the SYSCTL_IMMEDIATE flag being set, or <i class="farg">sysctl_data</i> should be set to point to a copy of the new data, and the SYSCTL_OWNDATA flag must be set. This latter method is the only way that new string and struct type nodes can be initialized. Invalid kernel addresses are accepted, but any attempt to access those nodes will return an error.<p>
The <i class="farg">sysctl_csize</i>, <i class="farg">sysctl_clen</i>, <i class="farg">sysctl_child</i>, <i class="farg">sysctl_parent</i>, and <i class="farg">sysctl_alias</i> members are used by the kernel to link the tree together and must be <span class="define">NULL</span> or 0. Nodes created in this manner cannot have helper functions, so <i class="farg">sysctl_func</i> must also be <span class="define">NULL</span>. If the <i class="farg">sysctl_ver</i> member is non-zero, it must match either the version of the parent or the version at the root of the MIB or an error is returned. This can be used to ensure that nodes are only added or removed from a known state of the tree. Note: It may not be possible to determine the version at the root of the tree.<p>
This example creates a new subtree and adds a node to it that controls the <i class="farg">audiodebug</i> kernel variable, thereby making it tunable at at any time, without needing to use <a class="link-man" href="../4/ddb">ddb(4)</a> or <a class="link-man" href="../3/kvm">kvm(3)</a> to alter the kernel's memory directly.<p>
<pre style="margin-left: 5.00ex;" class="lit display">
struct sysctlnode node; 
int mib[2]; 
size_t len; 
<div style="height: 1.00em;">
&#160;</div>
mib[0] = CTL_CREATE;		/* create at top-level */ 
len = sizeof(node); 
memset(&amp;node, 0, len); 
node.sysctl_flags = SYSCTL_VERSION|CTLFLAG_READWRITE|CTLTYPE_NODE; 
snprintf(node.sysctl_name, sizeof(node.sysctl_name), "local"); 
node.sysctl_num = CTL_CREATE;	/* request dynamic MIB number */ 
sysctl(&amp;mib[0], 1, &amp;node, &amp;len, &amp;node, len); 
<div style="height: 1.00em;">
&#160;</div>
mib[0] = node.sysctl_num;	/* use new MIB number */ 
mib[1] = CTL_CREATESYM;		/* create at second level */ 
len = sizeof(node); 
memset(&amp;node, 0, len); 
node.sysctl_flags = SYSCTL_VERSION|CTLFLAG_READWRITE|CTLTYPE_INT; 
snprintf(node.sysctl_name, sizeof(node.sysctl_name), "audiodebug"); 
node.sysctl_num = CTL_CREATE; 
node.sysctl_data = "audiodebug"; /* kernel symbol to be used */ 
sysctl(&amp;mib[0], 2, NULL, NULL, &amp;node, len);</pre>
<p>
The process for deleting nodes is similar, but less data needs to be supplied. Only the <i class="farg">sysctl_num</i> field needs to be filled in; almost all other fields must be left blank. The <i class="farg">sysctl_name</i> and/or <i class="farg">sysctl_ver</i> fields can be filled in with the name and version of the existing node as additional checks on what will be deleted. If all the given data fail to match any node, nothing will be deleted. If valid values for <i class="farg">old</i> and <i class="farg">oldlenp</i> are supplied and a node is deleted, a copy of what was in the MIB tree will be returned.<p>
This sample code shows the deletion of the two nodes created in the above example:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
int mib[2]; 
<div style="height: 1.00em;">
&#160;</div>
len = sizeof(node); 
memset(&amp;node, 0, len); 
node.sysctl_flags = SYSCTL_VERSION; 
<div style="height: 1.00em;">
&#160;</div>
mib[0] = 3214;			/* assumed number for "local" */ 
mib[1] = CTL_DESTROY; 
node.sysctl_num = 3215;		/* assumed number for "audiodebug" */ 
sysctl(&amp;mib[0], 2, NULL, NULL, &amp;node, len); 
<div style="height: 1.00em;">
&#160;</div>
mib[0] = CTL_DESTROY; 
node.sysctl_num = 3214;		/* now deleting "local" */ 
sysctl(&amp;mib[0], 1, NULL, NULL, &amp;node, len);</pre>
<p>
Descriptions of each of the nodes can also be retrieved, if they are available. Descriptions can be retrieved in bulk at each level or on a per-node basis. The layout of the buffer into which the descriptions are returned is a series of variable length structures, each of which describes its own size. The length indicated includes the terminating &#8216;nul&#8217; character. Nodes that have no description or where the description is not available are indicated by an empty string. The <i class="farg">descr_ver</i> will match the <i class="farg">sysctl_ver</i> value for a given node, so that descriptions for nodes whose number have been recycled can be detected and ignored or discarded.<p>
<pre style="margin-left: 0.00ex;" class="lit display">
struct sysctldesc { 
        int32_t         descr_num;      /* mib number of node */ 
        uint32_t        descr_ver;      /* version of node */ 
        uint32_t        descr_len;      /* length of description string */ 
        char            descr_str[1];   /* not really 1...see above */ 
};</pre>
<p>
The <b class="fname">NEXT_DESCR</b>() macro can be used to skip to the next description in the retrieved list.<p>
<pre style="margin-left: 5.00ex;" class="lit display">
struct sysctlnode desc; 
struct sysctldesc *d; 
char buf[1024]; 
int mib[2]; 
size_t len; 
<div style="height: 1.00em;">
&#160;</div>
/* retrieve kern-level descriptions */ 
mib[0] = CTL_KERN; 
mib[1] = CTL_DESCRIBE; 
d = (struct sysctldesc *)&amp;buf[0]; 
len = sizeof(buf); 
sysctl(mib, 2, d, &amp;len, NULL, 0); 
while ((caddr_t)d &lt; (caddr_t)&amp;buf[len]) { 
	printf("node %d: %.*s\n", d-&gt;descr_num, d-&gt;descr_len, 
	    d-&gt;descr_str); 
	d = NEXT_DESCR(d); 
} 
<div style="height: 1.00em;">
&#160;</div>
/* retrieve description for kern.securelevel */ 
memset(&amp;desc, 0, sizeof(desc)); 
desc.sysctl_flags = SYSCTL_VERSION; 
desc.sysctl_num = KERN_SECURELEVEL; 
d = (struct sysctldesc *)&amp;buf[0]; 
len = sizeof(buf); 
sysctl(mib, 2, d, &amp;len, &amp;desc, sizeof(desc)); 
printf("kern.securelevel: %.*s\n", d-&gt;descr_len, d-&gt;descr_str);</pre>
<p>
Descriptions can also be set as follows, subject to the following rules:<p>
<ul style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-bul">
<li class="list-bul" style="margin-top: 0.00em;">
The kernel securelevel is at zero or lower</li>
<li class="list-bul" style="margin-top: 0.00em;">
The caller has super-user privileges</li>
<li class="list-bul" style="margin-top: 0.00em;">
The node does not currently have a description</li>
<li class="list-bul" style="margin-top: 0.00em;">
The node is not marked as &#8220;permanent&#8221;</li>
</ul>
<p>
<pre style="margin-left: 5.00ex;" class="lit display">
struct sysctlnode desc; 
int mib[2]; 
<div style="height: 1.00em;">
&#160;</div>
/* presuming the given top-level node was just added... */ 
mib[0] = 3214; /* mib numbers taken from previous examples */ 
mib[1] = CTL_DESCRIBE; 
memset(&amp;desc, 0, sizeof(desc)); 
desc.sysctl_flags = SYSCTL_VERSION; 
desc.sysctl_num = 3215; 
desc.sysctl_desc = "audio debug control knob"; 
sysctl(mib, 2, NULL, NULL, &amp;desc, sizeof(desc));</pre>
<p>
Upon successfully setting a description, the new description will be returned in the space indicated by the <i class="farg">oldp</i> and <i class="farg">oldlenp</i> arguments.<p>
The <i class="farg">sysctl_flags</i> field in the struct sysctlnode contains the sysctl version, node type information, and a number of flags. The macros <b class="fname">SYSCTL_VERS</b>(), <b class="fname">SYSCTL_TYPE</b>(), and <b class="fname">SYSCTL_FLAGS</b>() can be used to access the different fields. Valid flags are:<table style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-col">
<col style="min-width: 20.00ex;">
<tbody>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">Name</span></td>
<td class="list-col" style="margin-top: 1.00em;">
Description</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
CTLFLAG_READONLY</td>
<td class="list-col" style="margin-top: 1.00em;">
Node is read-only</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
CTLFLAG_READWRITE</td>
<td class="list-col" style="margin-top: 1.00em;">
Node is writable by the superuser</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
CTLFLAG_ANYWRITE</td>
<td class="list-col" style="margin-top: 1.00em;">
Node is writable by anyone</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
CTLFLAG_PRIVATE</td>
<td class="list-col" style="margin-top: 1.00em;">
Node is readable only by the superuser</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
CTLFLAG_PERMANENT</td>
<td class="list-col" style="margin-top: 1.00em;">
Node cannot be removed (cannot be set by processes)</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
CTLFLAG_OWNDATA</td>
<td class="list-col" style="margin-top: 1.00em;">
Node owns data and does not instrument existing data</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
CTLFLAG_IMMEDIATE</td>
<td class="list-col" style="margin-top: 1.00em;">
Node contains instrumented data and does not instrument existing data</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
CTLFLAG_HEX</td>
<td class="list-col" style="margin-top: 1.00em;">
Node's contents should be displayed in a hexadecimal form</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
CTLFLAG_ROOT</td>
<td class="list-col" style="margin-top: 1.00em;">
Node is the root of a tree (cannot be set at any time)</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
CTLFLAG_ANYNUMBER</td>
<td class="list-col" style="margin-top: 1.00em;">
Node matches any MIB number (cannot be set by processes)</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
CTLFLAG_HIDDEN</td>
<td class="list-col" style="margin-top: 1.00em;">
Node not displayed by default</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
CTLFLAG_ALIAS</td>
<td class="list-col" style="margin-top: 1.00em;">
Node refers to a sibling node (cannot be set by processes)</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
CTLFLAG_OWNDESC</td>
<td class="list-col" style="margin-top: 1.00em;">
Node owns its own description string space</td>
</tr>
</tbody>
</table>
</div>
<div class="section">
<h1 id="x52455455524e2056414c554553">RETURN VALUES</h1> If the call to <b class="name">sysctl</b> is successful, 0 is returned. Otherwise &#45;1 is returned and <b class="var">errno</b> is set appropriately.</div>
<div class="section">
<h1 id="x46494c4553">FILES</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
&#60;<i class="file">sys/sysctl.h</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 21.00ex;">
definitions for top level identifiers, second level kernel and hardware identifiers, and user level identifiers</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
&#60;<i class="file">sys/socket.h</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 21.00ex;">
definitions for second level network identifiers</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
&#60;<i class="file">sys/gmon.h</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 21.00ex;">
definitions for third level profiling identifiers</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
&#60;<i class="file">uvm/uvm_param.h</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 21.00ex;">
definitions for second level virtual memory identifiers</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
&#60;<i class="file">netinet/in.h</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 21.00ex;">
definitions for third level IPv4/v6 identifiers and fourth level IPv4/v6 identifiers</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
&#60;<i class="file">netinet/icmp_var.h</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 21.00ex;">
definitions for fourth level ICMP identifiers</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
&#60;<i class="file">netinet/icmp6.h</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 21.00ex;">
definitions for fourth level ICMPv6 identifiers</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
&#60;<i class="file">netinet/tcp_var.h</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 21.00ex;">
definitions for fourth level TCP identifiers</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
&#60;<i class="file">netinet/udp_var.h</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 21.00ex;">
definitions for fourth level UDP identifiers</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
&#60;<i class="file">netinet6/udp6_var.h</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 21.00ex;">
definitions for fourth level IPv6 UDP identifiers</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
&#60;<i class="file">netinet6/ipsec.h</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 21.00ex;">
definitions for fourth level IPsec identifiers</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
&#60;<i class="file">netkey/key_var.h</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 21.00ex;">
definitions for third level PF_KEY identifiers</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
&#60;<i class="file">machine/cpu.h</i>&#62;</dt>
<dd class="list-tag" style="margin-left: 21.00ex;">
definitions for second level machdep identifiers</dd>
</dl>
</div>
<div class="section">
<h1 id="x4552524f5253">ERRORS</h1> The following errors may be reported:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">EFAULT</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
The buffer <i class="farg">name</i>, <i class="farg">oldp</i>, <i class="farg">newp</i>, or length pointer <i class="farg">oldlenp</i> contains an invalid address, or the requested value is temporarily unavailable.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">EINVAL</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
The <i class="farg">name</i> array is zero or greater than <span class="define">CTL_MAXNAME</span>; or a non-null <i class="farg">newp</i> is given and its specified length in <i class="farg">newlen</i> is too large or too small, or the given value is not acceptable for the given node.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">EISDIR</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
The <i class="farg">name</i> array specifies an intermediate rather than terminal name.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">ENOENT</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
The <i class="farg">name</i> array specifies a node that does not exist in the tree; or an attempt was made to destroy a node that does not exist, or to create or destroy a node below a node that does not exist.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">ENOMEM</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
The length pointed to by <i class="farg">oldlenp</i> is too short to hold the requested value.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">ENOTDIR</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
The <i class="farg">name</i> array specifies a node below a node that addresses data.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">ENOTEMPTY</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
An attempt was made to destroy a node that still has children.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">EOPNOTSUPP</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
The <i class="farg">name</i> array specifies a value that is unknown or a meta-operation was attempted that the requested node does not support.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">EPERM</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
An attempt is made to set a read-only value; or a process without appropriate privilege attempts to set a value or to create or destroy a node; or an attempt to change a value protected by the current kernel security level is made.</dd>
</dl>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../7/sysctl">sysctl(7)</a>, <a class="link-man" href="../8/sysctl">sysctl(8)</a>, <a class="link-man" href="../9/secmodel_securelevel">secmodel_securelevel(9)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The <b class="name">sysctl</b> function first appeared in <span class="unix">4.4BSD</span>.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
June 13, 2014</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

