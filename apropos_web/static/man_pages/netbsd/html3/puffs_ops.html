<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/../4/strict.dtd">
>
<head>
<meta http-equiv="Content-Type" content="te../; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
PUFFS_OPS(3)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
PUFFS_OPS(3)</td>
<td class="head-vol" align="center">
Library Functions Manual</td>
<td class="head-rtitle" align="right">
PUFFS_OPS(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">puffs_ops</b> &#8212; <span class="desc">puffs callback operations</span></div>
<div class="section">
<h1 id="x4c494252415259">LIBRARY</h1> <span class="lib">puffs Convenience Library (libpuffs, &#45;lpuffs)</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">puffs.h</a>&gt;</b><p>
<i class="ftype">int</i><br>
<b class="fname">puffs_fs_statvfs</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">struct statvfs *sbp</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_fs_sync</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">int waitfor</i>, <i class="farg">const struct puffs_cred *pcr</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_fs_fhtonode</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">void *fid</i>, <i class="farg">size_t fidsize</i>, <i class="farg">struct puffs_newinfo *pni</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_fs_nodetofh</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">puffs_cookie_t cookie</i>, <i class="farg">void *fid</i>, <i class="farg">size_t *fidsize</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">puffs_fs_extattrctl</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">int cmd</i>, <i class="farg">puffs_cookie_t cookie</i>, <i class="farg">int flags</i>, <i class="farg">int attrnamespace</i>, <i class="farg">const char *attrname</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_fs_unmount</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">int flags</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_node_lookup</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">puffs_cookie_t opc</i>, <i class="farg">struct puffs_newinfo *pni</i>, <i class="farg">const struct puffs_cn *pcn</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_node_create</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">puffs_cookie_t opc</i>, <i class="farg">struct puffs_newinfo *pni</i>, <i class="farg">const struct puffs_cn *pcn</i>, <i class="farg">const struct vattr *vap</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_node_mknod</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">puffs_cookie_t opc</i>, <i class="farg">struct puffs_newinfo *pni</i>, <i class="farg">const struct puffs_cn *pcn</i>, <i class="farg">const struct vattr *vap</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_node_open</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">puffs_cookie_t opc</i>, <i class="farg">int mode</i>, <i class="farg">const struct puffs_cred *pcr</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_node_open2</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">puffs_cookie_t opc</i>, <i class="farg">int modep</i>, <i class="farg">const struct puffs_cred *pcr</i>, <i class="farg">int *oflags</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_node_close</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">puffs_cookie_t opc</i>, <i class="farg">int flags</i>, <i class="farg">const struct puffs_cred *pcr</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_node_access</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">puffs_cookie_t opc</i>, <i class="farg">int mode</i>, <i class="farg">const struct puffs_cred *pcr</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_node_getattr</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">puffs_cookie_t opc</i>, <i class="farg">struct vattr *vap</i>, <i class="farg">const struct puffs_cred *pcr</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_node_setattr</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">puffs_cookie_t opc</i>, <i class="farg">const struct vattr *vap</i>, <i class="farg">const struct puffs_cred *pcr</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_node_getattr_ttl</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">puffs_cookie_t opc</i>, <i class="farg">struct vattr *vap</i>, <i class="farg">const struct puffs_cred *pcr</i>, <i class="farg">struct timespec *va_ttl</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_node_setattr_ttl</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">puffs_cookie_t opc</i>, <i class="farg">const struct vattr *vap</i>, <i class="farg">const struct puffs_cred *pcr</i>, <i class="farg">struct timespec *va_ttl</i>, <i class="farg">int xflag</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_node_poll</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">puffs_cookie_t opc</i>, <i class="farg">int *events</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_node_mmap</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">puffs_cookie_t opc</i>, <i class="farg">int flags</i>, <i class="farg">const struct puffs_cred *pcr</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_node_fsync</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">puffs_cookie_t opc</i>, <i class="farg">const struct puffs_cred *pcr</i>, <i class="farg">int flags</i>, <i class="farg">off_t offlo</i>, <i class="farg">off_t offhi</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_node_seek</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">puffs_cookie_t opc</i>, <i class="farg">off_t oldoff</i>, <i class="farg">off_t newoff</i>, <i class="farg">const struct puffs_cred *pcr</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_node_remove</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">puffs_cookie_t opc</i>, <i class="farg">puffs_cookie_t targ</i>, <i class="farg">const struct puffs_cn *pcn</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_node_link</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">puffs_cookie_t opc</i>, <i class="farg">puffs_cookie_t targ</i>, <i class="farg">const struct puffs_cn *pcn</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_node_rename</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">puffs_cookie_t opc</i>, <i class="farg">puffs_cookie_t src</i>, <i class="farg">const struct puffs_cn *pcn_src</i>, <i class="farg">puffs_cookie_t targ_dir</i>, <i class="farg">puffs_cookie_t targ</i>, <i class="farg">const struct puffs_cn *pcn_targ</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_node_mkdir</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">puffs_cookie_t opc</i>, <i class="farg">struct puffs_newinfo *pni</i>, <i class="farg">const struct puffs_cn *pcn</i>, <i class="farg">const struct vattr *vap</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_node_rmdir</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">puffs_cookie_t opc</i>, <i class="farg">puffs_cookie_t targ</i>, <i class="farg">const struct puffs_cn *pcn</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_node_readdir</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">puffs_cookie_t opc</i>, <i class="farg">struct dirent *dent</i>, <i class="farg">off_t *readoff</i>, <i class="farg">size_t *reslen</i>, <i class="farg">const struct puffs_cred *pcr</i>, <i class="farg">int *eofflag</i>, <i class="farg">off_t *cookies</i>, <i class="farg">size_t *ncookies</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_node_symlink</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">puffs_cookie_t opc</i>, <i class="farg">struct puffs_newinfo *pni</i>, <i class="farg">const struct puffs_cn *pcn_src</i>, <i class="farg">const struct vattr *vap</i>, <i class="farg">const char *link_target</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_node_readlink</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">puffs_cookie_t opc</i>, <i class="farg">const struct puffs_cred *pcr</i>, <i class="farg">char *link</i>, <i class="farg">size_t *linklen</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_node_read</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">puffs_cookie_t opc</i>, <i class="farg">uint8_t *buf</i>, <i class="farg">off_t offset</i>, <i class="farg">size_t *resid</i>, <i class="farg">const struct puffs_cred *pcr</i>, <i class="farg">int ioflag</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_node_write</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">puffs_cookie_t opc</i>, <i class="farg">uint8_t *buf</i>, <i class="farg">off_t offset</i>, <i class="farg">size_t *resid</i>, <i class="farg">const struct puffs_cred *pcr</i>, <i class="farg">int ioflag</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_node_write2</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">puffs_cookie_t opc</i>, <i class="farg">uint8_t *buf</i>, <i class="farg">off_t offset</i>, <i class="farg">size_t *resid</i>, <i class="farg">const struct puffs_cred *pcr</i>, <i class="farg">int ioflag</i>, <i class="farg">int xflag</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_node_abortop</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">puffs_cookie_t opc</i>, <i class="farg">const struct puffs_cn *pcn</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_node_getextattr</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">puffs_cookie_t opc</i>, <i class="farg">int attrnamespace</i>, <i class="farg">const char *attrname</i>, <i class="farg">size_t *attrsize</i>, <i class="farg">uint8_t *attr</i>, <i class="farg">size_t *resid</i>, <i class="farg">const struct puffs_cred *pcr</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_node_setextattr</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">puffs_cookie_t opc</i>, <i class="farg">int attrnamespace</i>, <i class="farg">const char *attrname</i>, <i class="farg">uint8_t *attr</i>, <i class="farg">size_t *resid</i>, <i class="farg">const struct puffs_cred *pcr</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_node_listextattr</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">puffs_cookie_t opc</i>, <i class="farg">int attrnamespace</i>, <i class="farg">size_t *attrssize</i>, <i class="farg">uint8_t *attrs</i>, <i class="farg">iint flag</i>, <i class="farg">size_t *resid</i>, <i class="farg">const struct puffs_cred *pcr</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_node_deleteextattr</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">puffs_cookie_t opc</i>, <i class="farg">int attrnamespace</i>, <i class="farg">const char *attrname</i>, <i class="farg">const struct puffs_cred *pcr</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_node_fallocate</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">puffs_cookie_t opc</i>, <i class="farg">off_t pos</i>, <i class="farg">off_t len</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_node_fdiscard</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">puffs_cookie_t opc</i>, <i class="farg">off_t pos</i>, <i class="farg">off_t len</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_node_print</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">puffs_cookie_t opc</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_node_reclaim</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">puffs_cookie_t opc</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_node_reclaim2</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">puffs_cookie_t opc</i>, <i class="farg">int nlookup</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">puffs_node_inactive</b>(<i class="farg">struct puffs_usermount *pu</i>, <i class="farg">puffs_cookie_t opc</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">puffs_setback</b>(<i class="farg" style="white-space:nowrap;">struct puffs_cc *pcc</i>, <i class="farg" style="white-space:nowrap;">int op</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">puffs_newinfo_setcookie</b>(<i class="farg" style="white-space:nowrap;">struct puffs_newinfo *pni</i>, <i class="farg" style="white-space:nowrap;">puffs_cookie_t cookie</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">puffs_newinfo_setvtype</b>(<i class="farg" style="white-space:nowrap;">struct puffs_newinfo *pni</i>, <i class="farg" style="white-space:nowrap;">enum vtype vtype</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">puffs_newinfo_setsize</b>(<i class="farg" style="white-space:nowrap;">struct puffs_newinfo *pni</i>, <i class="farg" style="white-space:nowrap;">voff_t size</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">puffs_newinfo_setrdev</b>(<i class="farg" style="white-space:nowrap;">struct puffs_newinfo *pni</i>, <i class="farg" style="white-space:nowrap;">dev_t rdev</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">puffs_newinfo_setva</b>(<i class="farg" style="white-space:nowrap;">struct puffs_newinfo *pni</i>, <i class="farg" style="white-space:nowrap;">struct vattr *vap</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">puffs_newinfo_setvattl</b>(<i class="farg" style="white-space:nowrap;">struct puffs_newinfo *pni</i>, <i class="farg" style="white-space:nowrap;">struct timespec *va_ttl</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">puffs_newinfo_setcnttl</b>(<i class="farg" style="white-space:nowrap;">struct puffs_newinfo *pni</i>, <i class="farg" style="white-space:nowrap;">struct timespec *cn_ttl</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The operations <b class="name">puffs</b> requires to function can be divided into two categories: file system callbacks and node callbacks. The former affect the entire file system while the latter are targeted at a file or a directory and a file. They are roughly equivalent to the vfs and vnode operations in the kernel.<p>
All callbacks can be prototyped with the file system name and operation name using the macro <b class="fname">PUFFSOP_PROTOS</b>(<i class="farg">fsname</i>).<div class="subsection">
<h2 id="x46696c652073797374656d2063616c6c6261636b73202870756666735f667329">File system callbacks (puffs_fs)</h2><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_fs_statvfs</b>(<i class="farg">pu</i>, <i class="farg">sbp</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The following fields of the argument <i class="farg">sbp</i> need to be filled:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
 * unsigned long  f_bsize;     file system block size 
 * unsigned long  f_frsize;    fundamental file system block size 
 * fsblkcnt_t     f_blocks;    number of blocks in file system, 
 *                                      (in units of f_frsize) 
 * 
 * fsblkcnt_t     f_bfree;     free blocks avail in file system 
 * fsblkcnt_t     f_bavail;    free blocks avail to non-root 
 * fsblkcnt_t     f_bresvd;    blocks reserved for root 
 
 * fsfilcnt_t     f_files;     total file nodes in file system 
 * fsfilcnt_t     f_ffree;     free file nodes in file system 
 * fsfilcnt_t     f_favail;    free file nodes avail to non-root 
 * fsfilcnt_t     f_fresvd;    file nodes reserved for root 
</pre>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_fs_sync</b>(<i class="farg">pu</i>, <i class="farg">waitfor</i>, <i class="farg">pcr</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
All the dirty buffers that have been cached at the file server level including metadata should be committed to stable storage. The <i class="farg">waitfor</i> parameter affects the operation. Possible values are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MNT_WAIT</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Wait for all I/O for complete until returning.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MNT_NOWAIT</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Initiate I/O, but do not wait for completion.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MNT_LAZY</span></dt>
<dd class="list-tag" style="margin-left: 12.00ex;">
Synchorize data not synchoronized by the file system syncer, i.e., data not written when <b class="fname">node_fsync</b>() is called with <span class="define">FSYNC_LAZY</span>.</dd>
</dl>
<p>
The credentials for the initiator of the sync operation are present in <i class="farg">pcr</i> and will usually be either file system or kernel credentials, but might also be user credentials. However, most of the time it is advisable to sync regardless of the credentials of the caller.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_fs_fhtonode</b>(<i class="farg">pu</i>, <i class="farg">fid</i>, <i class="farg">fidsize</i>, <i class="farg">pni</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Translates a file handle <i class="farg">fid</i> to a node. The parameter <i class="farg">fidsize</i> indicates how large the file handle is. In case the file system's handles are static length, this parameter can be ignored as the kernel guarantees all file handles passed to the file server are of correct length. For dynamic length handles the field should be examined and <span class="errno">EINVAL</span> returned in case the file handle length is not correct.<p>
This function provides essentially the same information to the kernel as <b class="fname">puffs_node_lookup</b>(). The information is necessary for creating a new vnode corresponding to the file handle.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_fs_nodetofh</b>(<i class="farg">pu</i>, <i class="farg">cookie</i>, <i class="farg">fid</i>, <i class="farg">fidsize</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Create a file handle from the node described by <i class="farg">cookie</i>. The file handle should contain enough information to reliably identify the node even after reboots and the pathname/inode being replaced by another file. If this is not possible, it is up to the author of the file system to act responsibly and decide if the file system can support file handles at all.<p>
For file systems which want dynamic length file handles, this function must check if the file handle space indicated by <i class="farg">fidsize</i> is large enough to accommodate the file handle for the node. If not, it must fill in the correct size and return <span class="errno">E2BIG</span>. In either case, the handle length should be supplied to the kernel in <i class="farg">fidsize</i>. File systems with static length handles can ignore the size parameter as the kernel always supplies the correct size buffer.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_fs_unmount</b>(<i class="farg">pu</i>, <i class="farg">flags</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Unmount the file system. The kernel has assumedly flushed all cached data when this callback is executed. If the file system cannot currently be safely be unmounted, for whatever reason, the kernel will honor an error value and not forcibly unmount. However, if the flag <span class="define">MNT_FORCE</span> is not honored by the file server, the kernel will forcibly unmount the file system.</dd>
</dl>
</div>
<div class="subsection">
<h2 id="x4e6f64652063616c6c6261636b73">Node callbacks</h2> These operations operate in the level of individual files. The file cookie is always provided as the second argument <i class="farg">opc</i>. If the operation is for a file, it will be the cookie of the file. The case the operation involves a directory (such as &#8220;create file in directory&#8221;), the cookie will be for the directory. Some operations take additional cookies to describe the rest of the operands. The return value 0 signals success, else an appropriate errno value should be returned. Please note that neither this list nor the descriptions are complete.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_node_lookup</b>(<i class="farg">pu</i>, <i class="farg">opc</i>, <i class="farg">pni</i>, <i class="farg">pcn</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
This function is used to locate nodes, or in other words translate pathname components to file system data structures. The implementation should match the name in <i class="farg">pcn</i> against the existing entries in the directory provided by the cookie <i class="farg">opc</i>. If found, the cookie for the located node should be set in <i class="farg">pni</i> using <b class="fname">puffs_newinfo_setcookie</b>(). Additionally, the vnode type and size (latter applicable to regular files only) should be set using <b class="fname">puffs_newinfo_setvtype</b>() and <b class="fname">puffs_newinfo_setsize</b>(), respectively. If the located entry is a block device or character device file, the dev_t for the entry should be set using <b class="fname">puffs_newinfo_setrdev</b>().<p>
If <b class="fname">puffs_init</b>() was called with <span class="define">PUFFS_KFLAG_CACHE_FS_TTL</span> then <b class="fname">puffs_newinfo_setva</b>(), <b class="fname">puffs_newinfo_setvattl</b>(), and <b class="fname">puffs_newinfo_setcnttl</b>() can be called to specify the new node attributes, cached attributes time to live, and cached name time to live.<p>
The type of operation is found from <b class="var">pcn-&gt;pcn_nameiop</b>:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">NAMEI_LOOKUP</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
Normal lookup operation.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">NAMEI_CREATE</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
Lookup to create a node.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">NAMEI_DELETE</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
Lookup for node deletion.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">NAMEI_RENAME</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
Lookup for the target of a rename operation (source will be looked up using <span class="define">NAMEI_DELETE</span>).</dd>
</dl>
<p>
The final component from a pathname lookup usually requires special treatment. It can be identified by looking at the <b class="var">pcn-&gt;pcn_flags</b> fields for the flag <span class="define">PUFFSLOOKUP_ISLASTCN</span>. For example, in most cases the lookup operation will want to check if a delete, rename or create operation has enough credentials to perform the operation.<p>
The return value 0 signals a found node and a nonzero value signals an errno. As a special case, <span class="errno">ENOENT</span> signals "success" for cases where the lookup operation is <span class="define">NAMEI_CREATE</span> or <span class="define">NAMEI_RENAME</span>. Failure in these cases can be signalled by returning another appropriate error code, for example <span class="errno">EACCESS</span>.<p>
Usually a null-terminated string for the next pathname component is provided in <i class="arg">pcn-&gt;pcn_name</i>. In case the file system is using the option <span class="define">PUFFS_KFLAG_LOOKUP_FULLPNBUF</span>, the remainder of the complete pathname under lookup is found in the same location. <i class="arg">pcn-&gt;pcn_namelen</i> always specifies the length of the next component. If operating with a full path, the file system is allowed to consume more than the next component's length in node lookup. This is done by setting <i class="arg">pcn-&gt;pcn_consume</i> to indicate the amount of <span class="emph">extra</span> characters in addition to <i class="arg">pcn-&gt;pcn_namelen</i> processed.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_node_create</b>(<i class="farg">pu</i>, <i class="farg">opc</i>, <i class="farg">pni</i>, <i class="farg">pcn</i>, <i class="farg">va</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_node_mkdir</b>(<i class="farg">pu</i>, <i class="farg">opc</i>, <i class="farg">pni</i>, <i class="farg">pcn</i>, <i class="farg">va</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_node_mknod</b>(<i class="farg">pu</i>, <i class="farg">opc</i>, <i class="farg">pni</i>, <i class="farg">pcn</i>, <i class="farg">va</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
A file node is created in the directory denoted by the cookie <i class="farg">opc</i> by any of the above callbacks. The name of the new file can be found from <i class="farg">pcn</i> and the attributes are specified by <i class="farg">va</i> and the cookie for the newly created node should be set in <i class="farg">pni</i>. The only difference between these three is that they create a regular file, directory and device special file, respectively.<p>
In case of mknod, the device identifier can be found in <i class="farg">va-&gt;va_rdev</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_node_open</b>(<i class="farg">pu</i>, <i class="farg">opc</i>, <i class="farg">mode</i>, <i class="farg">pcr</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_node_open2</b>(<i class="farg">pu</i>, <i class="farg">opc</i>, <i class="farg">mode</i>, <i class="farg">pcr</i>, <i class="farg">oflags</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Open the node denoted by the cookie <i class="farg">opc</i>. The parameter <i class="farg">mode</i> specifies the flags that <a class="link-man" href="../2/open">open(2)</a> was called with, e.g. <span class="define">O_APPEND</span> and <span class="define">O_NONBLOCK</span>. <b class="fname">puffs_node_open2</b>() allows the file system to pass back information for the file in <i class="farg">oflags</i>. The only implemented flag for now is <span class="define">PUFFS_OPEN_IO_DIRECT</span> that cause file read/write to bypass the page cache.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_node_close</b>(<i class="farg">pu</i>, <i class="farg">opc</i>, <i class="farg">flags</i>, <i class="farg">pcr</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Close a node. The parameter <i class="farg">flags</i> parameter describes the flags that the file was opened with.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_node_access</b>(<i class="farg">pu</i>, <i class="farg">opc</i>, <i class="farg">mode</i>, <i class="farg">pcr</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Check if the credentials of <i class="farg">pcr</i> have the right to perform the operation specified by <i class="farg">mode</i> onto the node <i class="farg">opc</i>. The argument <i class="farg">mode</i> can specify read, write or execute by <span class="define">PUFFS_VREAD</span>, <span class="define">PUFFS_VWRITE</span>, and <span class="define">PUFFS_VEXEC</span>, respectively.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_node_getattr</b>(<i class="farg">pu</i>, <i class="farg">opc</i>, <i class="farg">va</i>, <i class="farg">pcr</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The attributes of the node specified by <i class="farg">opc</i> must be copied to the space pointed by <i class="farg">va</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_node_getattr_ttl</b>(<i class="farg">pu</i>, <i class="farg">opc</i>, <i class="farg">va</i>, <i class="farg">pcr</i>, <i class="farg">va_ttl</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Same as <b class="fname">puffs_node_getattr</b>() with cached attribute time to live specified in <i class="farg">va_ttl</i></dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_node_setattr</b>(<i class="farg">pu</i>, <i class="farg">opc</i>, <i class="farg">va</i>, <i class="farg">pcr</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The attributes for the node specified by <i class="farg">opc</i> must be set to those contained in <i class="farg">va</i>. Only fields of <i class="farg">va</i> which contain a value different from <span class="define">PUFFS_VNOVAL</span> (typecast to the field's type!) contain a valid value.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_node_setattr_ttl</b>(<i class="farg">pu</i>, <i class="farg">opc</i>, <i class="farg">va</i>, <i class="farg">pcr</i>, <i class="farg">va_ttl</i>, <i class="farg">xflag</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Same as <b class="fname">puffs_node_setattr</b>() with cached attribute time to live specified in <i class="farg">va_ttl</i>. <span class="define">PUFFS_SETATTR_FAF</span> will be set in <i class="farg">xflag</i> for Fire-And-Forget operations.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_node_poll</b>(<i class="farg">pu</i>, <i class="farg">opc</i>, <i class="farg">events</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Poll for events on node <i class="arg">opc</i>. If <a class="link-man" href="../2/poll">poll(2)</a> events specified in <i class="arg">events</i> are available, the function should set the bitmask to match available events and return immediately. Otherwise, the function should block (yield) until some events in <i class="arg">events</i> become available and only then set the <i class="arg">events</i> bitmask and return.<p>
In case this function returns an error, <span class="define">POLLERR</span> (or its <a class="link-man" href="../2/select">select(2)</a> equivalent) will be delivered to the calling process.<p>
<span class="emph">NOTE!</span> The system call interface for <b class="fname">poll</b>() contains a timeout parameter. At this level, however, the timeout is not supplied. In case input does not arrive, the file system should periodically unblock and return 0 new events to avoid hanging forever. This will hopefully be better supported by libpuffs in the future.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_node_mmap</b>(<i class="farg">pu</i>, <i class="farg">opc</i>, <i class="farg">flags</i>, <i class="farg">pcr</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Called when a regular file is being memory mapped by <a class="link-man" href="../2/mmap">mmap(2)</a>. <i class="farg">flags</i> is currently always 0.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_node_fsync</b>(<i class="farg">pu</i>, <i class="farg">opc</i>, <i class="farg">pcr</i>, <i class="farg">flags</i>, <i class="farg">offlo</i>, <i class="farg">offhi</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Sychronize a node's contents onto stable storage. This is necessary only if the file server caches some information before committing it. The parameter <i class="farg">flags</i> specifies the minimum level of sychronization required (XXX: they are not yet available). The parameters <i class="farg">offlo</i> and <i class="farg">offhi</i> specify the data offsets requiring to be synced. A high offset of 0 means sync from <i class="farg">offlo</i> to the end of the file.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_node_seek</b>(<i class="farg">pu</i>, <i class="farg">opc</i>, <i class="farg">oldoff</i>, <i class="farg">newoff</i>, <i class="farg">pcr</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Test if the node <i class="arg">opc</i> is seekable to the location <i class="arg">newoff</i>. The argument <i class="arg">oldoff</i> specifies the offset we are starting the seek from. Most file systems dealing only with regular will choose to not implement this. However, it is useful for example in cases where files are unseekable streams.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_node_remove</b>(<i class="farg">pu</i>, <i class="farg">opc</i>, <i class="farg">targ</i>, <i class="farg">pcn</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_node_rmdir</b>(<i class="farg">pu</i>, <i class="farg">opc</i>, <i class="farg">targ</i>, <i class="farg">pcn</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Remove the node <i class="farg">targ</i> from the directory indicated by <i class="farg">opc</i>. The directory entry name to be removed is provided by <i class="farg">pcn</i>. The rmdir operation removes only directories, while the remove operation removes all other types except directories.<p>
It is paramount to note that the file system may not remove the node data structures at this point, only the directory entry and prevent lookups from finding the node again. This is to retain the <span class="unix">UNIX</span> open file semantics. The data may be removed only when <b class="fname">puffs_node_reclaim</b>() or <b class="fname">puffs_node_reclaim2</b>() is called for the node, as this assures there are no further users.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_node_link</b>(<i class="farg">pu</i>, <i class="farg">opc</i>, <i class="farg">targ</i>, <i class="farg">pcn</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Create a hard link for the node <i class="farg">targ</i> into the directory <i class="farg">opc</i>. The argument <i class="farg">pcn</i> provides the directory entry name for the new link.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_node_rename</b>(<i class="farg">pu</i>, <i class="farg">src_dir</i>, <i class="farg">src</i>, <i class="farg">pcn_src</i>, <i class="farg">targ_dir</i>, <i class="farg">targ</i>, <i class="farg">pcn_targ</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Rename the node <i class="farg">src</i> with the name specified by <i class="farg">pcn_src</i> from the directory <i class="farg">src_dir</i>. The target directory and target name are given by <i class="farg">targ_dir</i> and <i class="farg">pcn_targ</i>, respectively. <span class="emph">If</span> the target node already exists, it is specified by <i class="farg">targ</i> and must be replaced atomically. Otherwise <i class="farg">targ</i> is gives as <span class="define">NULL</span>.<p>
It is legal to replace a directory node by another directory node with the means of rename if the target directory is empty, otherwise <span class="errno">ENOTEMPTY</span> should be returned. All other types can replace all other types. In case a rename between incompatible types is attempted, the errors <span class="errno">ENOTDIR</span> or <span class="errno">EISDIR</span> should be returned, depending on the target type.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_node_readdir</b>(<i class="farg">pu</i>, <i class="farg">opc</i>, <i class="farg">dent</i>, <i class="farg">readoff</i>, <i class="farg">reslen</i>, <i class="farg">pcr</i>, <i class="farg">eofflag</i>, <i class="farg">cookies</i>, <i class="farg">ncookies</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
To read directory entries, <b class="fname">puffs_node_readdir</b>() is called. It should store directories as <b class="var">struct dirent</b> in the space pointed to by <i class="farg">dent</i>. The amount of space available is given by <i class="farg">reslen</i> and before returning it should be set to the amount of space <span class="emph">remaining</span> in the buffer. The argument <i class="farg">offset</i> is used to specify the offset to the directory. Its intepretation is up to the file system and it should be set to signal the continuation point when there is no more room for the next entry in <i class="farg">dent</i>. It is most performant to return the maximal amount of directory entries each call. It is easiest to generate directory entries by using <b class="fname">puffs_nextdent</b>(), which also automatically advances the necessary pointers.<p>
In case end-of-directory is reached, <i class="farg">eofflag</i> should be set to one. Note that even a new call to readdir may start where <i class="farg">readoff</i> points to end-of-directory.<p>
If the file system supports file handles, the arguments <i class="farg">cookies</i> and <i class="farg">ncookies</i> must be filled out. <i class="farg">cookies</i> is a vector for offsets corresponding to read offsets. One cookie should be filled out for each directory entry. The value of the cookie should equal the offset of the <span class="emph">next</span> directory entry, i.e., which offset should be passed to readdir for the first entry read to be the entry following the current one. <i class="farg">ncookies</i> is the number of slots for cookies in the cookie vector upon entry to the function and must be set to the amount of cookies stored in the vector (i.e., amount of directory entries read) upon exit. There is always enough space in the cookie vector for the maximal number of entries that will fit into the directory entry buffer. For filling out the vector, the helper function <b class="fname">PUFFS_STORE_DCOOKIE</b>(<i class="farg">cookies</i>, <i class="farg">ncookies</i>, <i class="farg">offset</i>) can be used. This properly checks against <i class="farg">cookies</i> being <span class="define">NULL</span>. Note that <i class="farg">ncookies</i> must be initialized to zero before the first call to <b class="fname">PUFFS_STORE_DCOOKIE</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_node_symlink</b>(<i class="farg">pu</i>, <i class="farg">opc</i>, <i class="farg">pni</i>, <i class="farg">pcn_src</i>, <i class="farg">va</i>, <i class="farg">link_target</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Create a symbolic link into the directory <i class="farg">opc</i> with the name in <i class="farg">pcn_src</i> and the initial attributes in <i class="farg">va</i>. The argument <i class="arg">link_target</i> contains a null-terminated string for the link target. The created node cookie should be set in <i class="farg">pni</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_node_readlink</b>(<i class="farg">pu</i>, <i class="farg">opc</i>, <i class="farg">pcr</i>, <i class="farg">link</i>, <i class="farg">linklen</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Read the target of a symbolic link <i class="farg">opc</i>. The result is placed in the buffer pointed to by <i class="farg">link</i>. This buffer's length is given in <i class="farg">linklen</i> and it must be updated to reflect the real link length. A terminating nul character should not be put into the buffer and <span class="emph">must not</span> be included in the link length.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_node_read</b>(<i class="farg">pu</i>, <i class="farg">opc</i>, <i class="farg">buf</i>, <i class="farg">offset</i>, <i class="farg">resid</i>, <i class="farg">pcr</i>, <i class="farg">ioflag</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Read the contents of a file <i class="farg">opc</i>. It will gather the data from <i class="farg">offset</i> in the file and read the number <i class="farg">resid</i> octets. The buffer is guaranteed to have this much space. The amount of data requested by <i class="farg">resid</i> should be read, except in the case of eof-of-file or an error. The parameter <i class="farg">resid</i> should be set to indicate the amount of request NOT completed. In the normal case this should be 0.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_node_write</b>(<i class="farg">pu</i>, <i class="farg">opc</i>, <i class="farg">buf</i>, <i class="farg">offset</i>, <i class="farg">resid</i>, <i class="farg">pcr</i>, <i class="farg">ioflag</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_node_write2</b>(<i class="farg">pu</i>, <i class="farg">opc</i>, <i class="farg">buf</i>, <i class="farg">offset</i>, <i class="farg">resid</i>, <i class="farg">pcr</i>, <i class="farg">ioflag</i>, <i class="farg">xflag</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
<b class="fname">puffs_node_write</b>() writes data to a file <i class="farg">opc</i> at <i class="farg">offset</i> and extend the file if necessary. The number of octets written is indicated by <i class="farg">resid</i>; everything must be written or an error will be generated. The parameter must be set to indicate the amount of data NOT written. In case the ioflag <span class="define">PUFFS_IO_APPEND</span> is specified, the data should be appended to the end of the file. <b class="fname">puffs_node_write2</b>() serves the same purpose as <b class="fname">puffs_node_write</b>() with an additional <i class="farg">xflag</i> in which <span class="define">PUFFS_WRITE_FAF</span> is set for Fire-And-Forget operations.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_node_fallocate</b>(<i class="farg">pu</i>, <i class="farg">opc</i>, <i class="farg">pos</i>, <i class="farg">len</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Allocate <i class="farg">len</i> bytes of backing store at offset <i class="farg">pos</i> for the node referenced by the cookie <i class="farg">opc</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_node_fdiscard</b>(<i class="farg">pu</i>, <i class="farg">opc</i>, <i class="farg">pos</i>, <i class="farg">len</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Free <i class="farg">len</i> bytes of backing store (creating a hole) at offset <i class="farg">pos</i> for the node referenced by the cookie <i class="farg">opc</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_node_print</b>(<i class="farg">pu</i>, <i class="farg">opc</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Print information about node. This is used only for kernel-initiated diagnostic purposes.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_node_reclaim</b>(<i class="farg">pu</i>, <i class="farg">opc</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The kernel will no longer reference the cookie and resources associated with it may be freed. In case the file <i class="farg">opc</i> has a link count of zero, it may be safely removed now.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_node_reclaim2</b>(<i class="farg">pu</i>, <i class="farg">opc</i>, <i class="farg">nlookup</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Same as <b class="fname">puffs_node_reclaim</b>() with an addditional argument for the number of lookups that have been done on the node (Node creation is counted as a lookup). This can be used by the file system to avoid a race condition, where the kernel sends a reclaim while it does not have received the reply for a lookup. If the file system tracks lookup count, and compares to <i class="farg">nlookup</i> it can detect this situation and ignore the reclaim.<p>
If the file system maps cookies to <span class="type">struct puffs_node</span> then the framework will do that work, and <b class="fname">puffs_node_reclaim</b>() can be reliabily used without the race condition.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_node_abortop</b>(<i class="farg">pu</i>, <i class="farg">opc</i>, <i class="farg">pcn</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
In case the operation following lookup (e.g., mkdir or remove) is not executed for some reason, abortop will be issued. This is useful only for servers which cache state between lookup and a directory operation and is generally left unimplemented.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_node_inactive</b>(<i class="farg">pu</i>, <i class="farg">opc</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
The node <i class="farg">opc</i> has lost its last reference in the kernel. However, the cookie must still remain valid until <b class="fname">puffs_node_reclaim</b>() or <b class="fname">puffs_node_reclaim2</b>() is called.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_setback</b>(<i class="farg">pcc</i>, <i class="farg">op</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Issue a "setback" operation which will be handled when the request response is returned to the kernel. Currently this can be only called from mmap, open, remove and rmdir. The valid parameters for <i class="arg">op</i> are <span class="define">PUFFS_SETBACK_INACT_N1</span> and <span class="define">PUFFS_SETBACK_INACT_N2</span>. These signal that a file system mounted with <span class="define">PUFFS_KFLAG_IAONDEMAND</span> should call the file system inactive method for the specified node. The node number 1 always means the operation cookie <i class="arg">opc</i>, while the node number 2 can be used to specify the second node argument present in some methods, e.g., remove.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_newinfo_setcookie</b>(<i class="farg">pni</i>, <i class="farg">cookie</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Set cookie for node provided by this method to <i class="arg">cookie</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_newinfo_setvtype</b>(<i class="farg">pni</i>, <i class="farg">vtype</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Set the type of the newly located node to <i class="arg">vtype</i>. This call is valid only for <b class="fname">lookup</b>() and <b class="fname">fhtonode</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_newinfo_setsize</b>(<i class="farg">pni</i>, <i class="farg">size</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Set the size of the newly located node to <i class="arg">size</i>. If left unset, the value defaults to 0. This call is valid only for <b class="fname">lookup</b>() and <b class="fname">fhtovp</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_newinfo_setrdev</b>(<i class="farg">pni</i>, <i class="farg">rdev</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Set the type of the newly located node to <i class="arg">vtype</i>. This call is valid only for <b class="fname">lookup</b>() and <b class="fname">fhtovp</b>() producing device type nodes.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_newinfo_setva</b>(<i class="farg">pni</i>, <i class="farg">vap</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Set the attributes for newly created vnode. This call is valid for <b class="fname">lookup</b>(), <b class="fname">create</b>(), <b class="fname">mkdir</b>(), <b class="fname">mknod</b>(), and <b class="fname">symlink</b>(), if <b class="fname">puffs_init</b>() was called with <span class="define">PUFFS_KFLAG_CACHE_FS_TTL</span> flag set.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_newinfo_setvattl</b>(<i class="farg">pni</i>, <i class="farg">va_ttl</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Set cached attribute time to live for newly created vnode. This call is valid for <b class="fname">lookup</b>(), <b class="fname">create</b>(), <b class="fname">mkdir</b>(), <b class="fname">mknod</b>(), and <b class="fname">symlink</b>(), if <b class="fname">puffs_init</b>() was called with <span class="define">PUFFS_KFLAG_CACHE_FS_TTL</span> flag set.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">puffs_newinfo_setcnttl</b>(<i class="farg">pni</i>, <i class="farg">cn_ttl</i>)</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
Set cached name time to live for newly created vnode. This call is valid for <b class="fname">lookup</b>(), <b class="fname">create</b>(), <b class="fname">mkdir</b>(), <b class="fname">mknod</b>(), and <b class="fname">symlink</b>(), if <b class="fname">puffs_init</b>() was called with <span class="define">PUFFS_KFLAG_CACHE_FS_TTL</span> flag set.</dd>
</dl>
</div>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../3/puffs">puffs(3)</a>, <a class="link-man" href="../9/vfsops">vfsops(9)</a>, <a class="link-man" href="../9/vnodeops">vnodeops(9)</a></div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
October 31, 2014</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
<>

