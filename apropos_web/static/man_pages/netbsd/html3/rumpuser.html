<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
RUMPUSER(3)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
RUMPUSER(3)</td>
<td class="head-vol" align="center">
Library Functions Manual</td>
<td class="head-rtitle" align="right">
RUMPUSER(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">rumpuser</b> &#8212; <span class="desc">rump kernel hypercall interface</span></div>
<div class="section">
<h1 id="x4c494252415259">LIBRARY</h1> rump User Library (librumpuser, &#45;lrumpuser)</div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">rump/rumpuser.h</a>&gt;</b></div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <b class="name">rumpuser</b> hypercall interfaces allow a rump kernel to access host resources. A hypervisor implementation must implement the routines described in this document to allow a rump kernel to run on the host. The implementation included in <span class="unix">NetBSD</span> is for POSIX-like hosts (*BSD, Linux, etc.). This document is divided into sections based on the functionality group of each hypercall.<p>
Since the hypercall interface is a C function interface, both the rump kernel and the hypervisor must conform to the same ABI. The interface itself attempts to assume as little as possible from the type systems, and for example <span class="type">off_t</span> is passed as <span class="type">int64_t</span> and enums are passed as ints. It is recommended that the hypervisor converts these to the native types before starting to process the hypercall, for example by assigning the ints back to enums.</div>
<div class="section">
<h1 id="x555043414c4c5320414e442052554d50204b45524e454c20434f4e54455854">UPCALLS AND RUMP KERNEL CONTEXT</h1> A hypercall is always entered with the calling thread scheduled in the rump kernel. In case the hypercall intends to block while waiting for an event, the hypervisor must first release the rump kernel scheduling context. In other words, the rump kernel context is a resource and holding on to it while waiting for a rump kernel event/resource may lead to a deadlock. Even when there is no possibility of deadlock in the strict sense of the term, holding on to the rump kernel context while performing a slow hypercall such as reading a device will prevent other threads (including the clock interrupt) from using that rump kernel context.<p>
Releasing the context is done by calling the <b class="fname">hyp_backend_unschedule</b>() upcall which the hypervisor received from rump kernel as a parameter for <b class="fname">rumpuser_init</b>(). Before a hypercall returns back to the rump kernel, the returning thread must carry a rump kernel context. In case the hypercall unscheduled itself, it must reschedule itself by calling <b class="fname">hyp_backend_schedule</b>().</div>
<div class="section">
<h1 id="x485950455243414c4c20494e5445524641434553">HYPERCALL INTERFACES</h1><div class="subsection">
<h2 id="x496e697469616c697a6174696f6e">Initialization</h2> <i class="ftype">int</i> <b class="fname">rumpuser_init</b>(<i class="farg">int version</i>, <i class="farg">struct rump_hyperup *hyp</i>)<p>
Initialize the hypervisor.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">version</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
hypercall interface version number that the kernel expects to be used. In case the hypervisor cannot provide an exact match, this routine must return a non-zero value.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">hyp</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
pointer to a set of upcalls the hypervisor can make into the rump kernel</dd>
</dl>
</div>
<div class="subsection">
<h2 id="x4d656d6f727920616c6c6f636174696f6e">Memory allocation</h2> <i class="ftype">int</i> <b class="fname">rumpuser_malloc</b>(<i class="farg">size_t len</i>, <i class="farg">int alignment</i>, <i class="farg">void **memp</i>)<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">len</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
amount of memory to allocate</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">alignment</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
size the returned memory must be aligned to. For example, if the value passed is 4096, the returned memory must be aligned to a 4k boundary.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">memp</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
return pointer for allocated memory</dd>
</dl>
<p>
<i class="ftype">void</i> <b class="fname">rumpuser_free</b>(<i class="farg">void *mem</i>, <i class="farg">size_t len</i>)<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">mem</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
memory to free</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">len</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
length of allocation. This is always equal to the amount the caller requested from the <b class="fname">rumpuser_malloc</b>() which returned <i class="farg">mem</i>.</dd>
</dl>
</div>
<div class="subsection">
<h2 id="x46696c657320616e6420492f4f">Files and I/O</h2> <i class="ftype">int</i> <b class="fname">rumpuser_open</b>(<i class="farg">const char *name</i>, <i class="farg">int mode</i>, <i class="farg">int *fdp</i>)<p>
Open <i class="farg">name</i> for I/O and associate a file descriptor with it. Notably, there needs to be no mapping between <i class="farg">name</i> and the host's file system namespace. For example, it is possible to associate the file descriptor with device I/O registers for special values of <i class="farg">name</i>.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">name</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
the identifier of the file to open for I/O</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">mode</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
combination of the following:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">RUMPUSER_OPEN_RDONLY</span></dt>
<dd class="list-tag" style="margin-left: 21.00ex;">
open only for reading</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">RUMPUSER_OPEN_WRONLY</span></dt>
<dd class="list-tag" style="margin-left: 21.00ex;">
open only for writing</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">RUMPUSER_OPEN_RDWR</span></dt>
<dd class="list-tag" style="margin-left: 21.00ex;">
open for reading and writing</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">RUMPUSER_OPEN_CREATE</span></dt>
<dd class="list-tag" style="margin-left: 21.00ex;">
do not treat missing <i class="farg">name</i> as an error</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">RUMPUSER_OPEN_EXCL</span></dt>
<dd class="list-tag" style="margin-left: 21.00ex;">
combined with <span class="define">RUMPUSER_OPEN_CREATE</span>, flag an error if <i class="farg">name</i> already exists</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">RUMPUSER_OPEN_BIO</span></dt>
<dd class="list-tag" style="margin-left: 21.00ex;">
the caller will use this file for block I/O, usually used in conjunction with accessing file system media. The hypervisor should treat this flag as advisory and possibly enable some optimizations for <i class="farg">*fdp</i> based on it.</dd>
</dl>
Notably, the permissions of the created file are left up to the hypervisor implementation.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">fdp</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
An integer value denoting the open file is returned here.</dd>
</dl>
<p>
<i class="ftype">int</i> <b class="fname">rumpuser_close</b>(<i class="farg">int fd</i>)<p>
Close a previously opened file descriptor.<p>
<i class="ftype">int</i> <b class="fname">rumpuser_getfileinfo</b>(<i class="farg">const char *name</i>, <i class="farg">uint64_t *size</i>, <i class="farg">int *type</i>)<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">name</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
file for which information is returned. The namespace is equal to that of <b class="fname">rumpuser_open</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">size</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
If non-<span class="define">NULL</span>, size of the file is returned here.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">type</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
If non-<span class="define">NULL</span>, type of the file is returned here. The options are <span class="define">RUMPUSER_FT_DIR</span>, <span class="define">RUMPUSER_FT_REG</span>, <span class="define">RUMPUSER_FT_BLK</span>, <span class="define">RUMPUSER_FT_CHR</span>, or <span class="define">RUMPUSER_FT_OTHER</span> for directory, regular file, block device, character device or unknown, respectively.</dd>
</dl>
<p>
<i class="ftype">void</i> <b class="fname">rumpuser_bio</b>(<i class="farg">int fd</i>, <i class="farg">int op</i>, <i class="farg">void *data</i>, <i class="farg">size_t dlen</i>, <i class="farg">int64_t off</i>, <i class="farg">rump_biodone_fn biodone</i>, <i class="farg">void *donearg</i>);<p>
Initiate block I/O and return immediately.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">fd</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
perform I/O on this file descriptor. The file descriptor must have been opened with <span class="define">RUMPUSER_OPEN_BIO</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">op</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
Transfer data from the file descriptor with <span class="define">RUMPUSER_BIO_READ</span> and transfer data to the file descriptor with <span class="define">RUMPUSER_BIO_WRITE</span>. Unless <span class="define">RUMPUSER_BIO_SYNC</span> is specified, the hypervisor may cache a write instead of committing it to permanent storage.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">data</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
memory address to transfer data to/from</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">dlen</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
length of I/O. The length is guaranteed to be a multiple of 512.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">off</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
offset into <i class="farg">fd</i> where I/O is performed</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">biodone</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
To be called when the I/O is complete. Accessing <i class="farg">data</i> is not legal after the call is made.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">donearg</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
opaque arg that must be passed to <i class="farg">biodone</i>.</dd>
</dl>
<p>
<i class="ftype">int</i> <b class="fname">rumpuser_iovread</b>(<i class="farg">int fd</i>, <i class="farg">struct rumpuser_iovec *ruiov</i>, <i class="farg">size_t iovlen</i>, <i class="farg">int64_t off</i>, <i class="farg">size_t *retv</i>);<p>
<i class="ftype">int</i> <b class="fname">rumpuser_iovwrite</b>(<i class="farg">int fd</i>, <i class="farg">struct rumpuser_iovec *ruiov</i>, <i class="farg">size_t iovlen</i>, <i class="farg">int64_t off</i>, <i class="farg">size_t *retv</i>);<p>
These routines perform scatter-gather I/O which is not block I/O by nature and therefore cannot be handled by <b class="fname">rumpuser_bio</b>().<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">fd</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
file descriptor to perform I/O on</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">ruiov</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
an array of I/O descriptors. It is defined as follows:<pre style="margin-left: 5.00ex;" class="lit display">
struct rumpuser_iovec { 
	void *iov_base; 
	size_t iov_len; 
};</pre>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">iovlen</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
number of elements in <i class="farg">ruiov</i></dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">off</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
offset of <i class="farg">fd</i> to perform I/O on. This can either be a non-negative value or <span class="define">RUMPUSER_IOV_NOSEEK</span>. The latter denotes that no attempt to change the underlying objects offset should be made. Using both types of offsets on a single instance of <i class="farg">fd</i> results in undefined behavior.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">retv</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
number of bytes successfully transferred is returned here</dd>
</dl>
<p>
<i class="ftype">int</i> <b class="fname">rumpuser_syncfd</b>(<i class="farg">int fd</i>, <i class="farg">int flags</i>, <i class="farg">uint64_t start</i>, <i class="farg">uint64_t len</i>);<p>
Synchronizes <i class="farg">fd</i> with respect to backing storage. The other arguments are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">flags</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
controls how synchronization happens. It must contain one of the following:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">RUMPUSER_SYNCFD_READ</span></dt>
<dd class="list-tag" style="margin-left: 24.00ex;">
Make sure that the next read sees writes from all other parties. This is useful for example in the case that <i class="farg">fd</i> represents memory to write a DMA read is being performed.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">RUMPUSER_SYNCFD_WRITE</span></dt>
<dd class="list-tag" style="margin-left: 24.00ex;">
Flush cached writes.</dd>
</dl>
<p>
The following additional parameters may be passed in <i class="farg">flags</i>:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">RUMPUSER_SYNCFD_BARRIER</span></dt>
<dd class="list-tag" style="margin-left: 24.00ex;">
Issue a barrier. Outstanding I/O operations which were started before the barrier complete before any operations after the barrier are performed.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">RUMPUSER_SYNCFD_SYNC</span></dt>
<dd class="list-tag" style="margin-left: 24.00ex;">
Wait for the synchronization operation to fully complete before returning. For example, this could mean that the data to be written to a disk has hit either the disk or non-volatile memory.</dd>
</dl>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">start</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
offset into the object.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">len</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
the number of bytes to synchronize. The value 0 denotes until the end of the object.</dd>
</dl>
</div>
<div class="subsection">
<h2 id="x436c6f636b73">Clocks</h2> The hypervisor should support two clocks, one for wall time and one for monotonically increasing time, the latter of which may be based on some arbitrary time (e.g. system boot time). If this is not possible, the hypervisor must make a reasonable effort to retain semantics.<p>
<i class="ftype">int</i> <b class="fname">rumpuser_clock_gettime</b>(<i class="farg">int enum_rumpclock</i>, <i class="farg">int64_t *sec</i>, <i class="farg">long *nsec</i>)<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">enum_rumpclock</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
specifies the clock type. In case of <span class="define">RUMPUSER_CLOCK_RELWALL</span> the wall time should be returned. In case of <span class="define">RUMPUSER_CLOCK_ABSMONO</span> the time of a monotonic clock should be returned.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">sec</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
return value for seconds</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">nsec</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
return value for nanoseconds</dd>
</dl>
<p>
<i class="ftype">int</i> <b class="fname">rumpuser_clock_sleep</b>(<i class="farg">int enum_rumpclock</i>, <i class="farg">int64_t sec</i>, <i class="farg">long nsec</i>)<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">enum_rumpclock</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
In case of <span class="define">RUMPUSER_CLOCK_RELWALL</span>, the sleep should last at least as long as specified. In case of <span class="define">RUMPUSER_CLOCK_ABSMONO</span>, the sleep should last until the hypervisor monotonic clock hits the specified absolute time.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">sec</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
sleep duration, seconds. exact semantics depend on <i class="farg">clk</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">nsec</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
sleep duration, nanoseconds. exact semantics depend on <i class="farg">clk</i>.</dd>
</dl>
</div>
<div class="subsection">
<h2 id="x506172616d657465722072657472696576616c">Parameter retrieval</h2> <i class="ftype">int</i> <b class="fname">rumpuser_getparam</b>(<i class="farg">const char *name</i>, <i class="farg">void *buf</i>, <i class="farg">size_t buflen</i>)<p>
Retrieve a configuration parameter from the hypervisor. It is up to the hypervisor to decide how the parameters can be set.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">name</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
name of the parameter. If the name starts with an underscore, it means a mandatory parameter. The mandatory parameters are <span class="define">RUMPUSER_PARAM_NCPU</span> which specifies the amount of virtual CPUs bootstrapped by the rump kernel and <span class="define">RUMPUSER_PARAM_HOSTNAME</span> which returns a preferably unique instance name for the rump kernel.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">buf</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
buffer to return the data in as a string</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">buflen</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
length of buffer</dd>
</dl>
</div>
<div class="subsection">
<h2 id="x5465726d696e6174696f6e">Termination</h2> <i class="ftype">void</i> <b class="fname">rumpuser_exit</b>(<i class="farg">int value</i>)<p>
Terminate the rump kernel with exit value <i class="farg">value</i>. If <i class="farg">value</i> is <span class="define">RUMPUSER_PANIC</span> the hypervisor should attempt to provide something akin to a core dump.</div>
<div class="subsection">
<h2 id="x436f6e736f6c65206f7574707574">Console output</h2> Console output is divided into two routines: a per-character one and printf-like one. The former is used e.g. by the rump kernel's internal printf routine. The latter can be used for direct debug prints e.g. very early on in the rump kernel's bootstrap or when using the in-kernel routine causes too much skew in the debug print results (the hypercall runs outside of the rump kernel and therefore does not cause any locking or scheduling events inside the rump kernel).<p>
<i class="ftype">void</i> <b class="fname">rumpuser_putchar</b>(<i class="farg">int ch</i>)<p>
Output <i class="farg">ch</i> on the console.<p>
<i class="ftype">void</i> <b class="fname">rumpuser_dprintf</b>(<i class="farg">const char *fmt</i>, <i class="farg">...</i>)<p>
Do output based on printf-like parameters.</div>
<div class="subsection">
<h2 id="x5369676e616c73">Signals</h2> A rump kernel should be able to send signals to client programs due to some standard interfaces including signal delivery in their specifications. Examples of these interfaces include <a class="link-man" href="../2/setitimer">setitimer(2)</a> and <a class="link-man" href="../2/write">write(2)</a>. The <b class="fname">rumpuser_kill</b>() function advises the hypercall implementation to raise a signal for the process containing the rump kernel.<p>
<i class="ftype">int</i> <b class="fname">rumpuser_kill</b>(<i class="farg">int64_t pid</i>, <i class="farg">int sig</i>)<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">pid</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
The pid of the rump kernel process that the signal is directed to. This value may be used as the hypervisor as a hint on how to deliver the signal. The value <span class="define">RUMPUSER_PID_SELF</span> may also be specified to indicate no hint. This value will be removed in a future version of the hypercall interface.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">sig</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
Number of signal to raise. The value is in NetBSD signal number namespace. In case the host has a native representation for signals, the value should be translated before the signal is raised. In case there is no mapping between <i class="farg">sig</i> and native signals (if any), the behavior is implementation-defined.</dd>
</dl>
<p>
A rump kernel will ignore the return value of this hypercall. The only implication of not implementing <b class="fname">rumpuser_kill</b>() is that some application programs may not experience expected behavior for standard interfaces.<p>
As an aside,the <a class="link-man" href="../7/rump_sp">rump_sp(7)</a> protocol provides equivalent functionality for remote clients.</div>
<div class="subsection">
<h2 id="x52616e646f6d20706f6f6c">Random pool</h2> <i class="ftype">int</i> <b class="fname">rumpuser_getrandom</b>(<i class="farg">void *buf</i>, <i class="farg">size_t buflen</i>, <i class="farg">int flags</i>, <i class="farg">size_t *retp</i>)<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">buf</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
buffer that the randomness is written to</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">buflen</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
number of bytes of randomness requested</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">flags</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
The value 0 or a combination of <span class="define">RUMPUSER_RANDOM_HARD</span> (return true randomness instead of something from a PRNG) and <span class="define">RUMPUSER_RANDOM_NOWAIT</span> (do not block in case the requested amount of bytes is not available).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">retp</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
The number of random bytes written into <i class="farg">buf</i>.</dd>
</dl>
</div>
<div class="subsection">
<h2 id="x54687265616473">Threads</h2> <i class="ftype">int</i> <b class="fname">rumpuser_thread_create</b>(<i class="farg">void *(*fun)(void *)</i>, <i class="farg">void *arg</i>, <i class="farg">const char *thrname</i>, <i class="farg">int mustjoin</i>, <i class="farg">int priority</i>, <i class="farg">int cpuidx</i>, <i class="farg">void **cookie</i>);<p>
Create a schedulable host thread context. The rump kernel will call this interface when it creates a kernel thread. The scheduling policy for the new thread is defined by the hypervisor. In case the hypervisor wants to optimize the scheduling of the threads, it can perform heuristics on the <i class="farg">thrname</i>, <i class="farg">priority</i> and <i class="farg">cpuidx</i> parameters.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">fun</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
function that the new thread must call. This call will never return.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">arg</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
argument to be passed to <i class="farg">fun</i></dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">thrname</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
Name of the new thread.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">mustjoin</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
If 1, the thread will be waited for by <b class="fname">rumpuser_thread_join</b>() when the thread exits.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">priority</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
The priority that the kernel requested the thread to be created at. Higher values mean higher priority. The exact kernel semantics for each value are not available through this interface.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">cpuidx</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
The index of the virtual CPU that the thread is bound to, or &#45;1 if the thread is not bound. The mapping between the virtual CPUs and physical CPUs, if any, is hypervisor implementation specific.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="farg">cookie</i></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
In case <i class="farg">mustjoin</i> is set, the value returned in <i class="farg">cookie</i> will be passed to <b class="fname">rumpuser_thread_join</b>().</dd>
</dl>
<p>
<i class="ftype">void</i> <b class="fname">rumpuser_thread_exit</b>(<i class="farg">void</i>)<p>
Called when a thread created with <b class="fname">rumpuser_thread_create</b>() exits.<p>
<i class="ftype">int</i> <b class="fname">rumpuser_thread_join</b>(<i class="farg">void *cookie</i>)<p>
Wait for a joinable thread to exit. The cookie matches the value from <b class="fname">rumpuser_thread_create</b>().<p>
<i class="ftype">void</i> <b class="fname">rumpuser_curlwpop</b>(<i class="farg">int enum_rumplwpop</i>, <i class="farg">struct lwp *l</i>)<p>
Manipulate the hypervisor's thread context database. The possible operations are create, destroy, and set as specified by <i class="farg">enum_rumplwpop</i>:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">RUMPUSER_LWP_CREATE</span></dt>
<dd class="list-tag" style="margin-left: 21.00ex;">
Inform the hypervisor that <i class="farg">l</i> is now a valid thread context which may be set. A currently valid value of <i class="farg">l</i> may not be specified. This operation is informational and does not mandate any action from the hypervisor.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">RUMPUSER_LWP_DESTROY</span></dt>
<dd class="list-tag" style="margin-left: 21.00ex;">
Inform the hypervisor that <i class="farg">l</i> is no longer a valid thread context. This means that it may no longer be set as the current context. A currently set context or an invalid one may not be destroyed. This operation is informational and does not mandate any action from the hypervisor.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">RUMPUSER_LWP_SET</span></dt>
<dd class="list-tag" style="margin-left: 21.00ex;">
Set <i class="farg">l</i> as the current host thread's rump kernel context. A previous context must not exist.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">RUMPUSER_LWP_CLEAR</span></dt>
<dd class="list-tag" style="margin-left: 21.00ex;">
Clear the context previous set by <span class="define">RUMPUSER_LWP_SET</span>. The value passed in <i class="farg">l</i> is the current thread and is never <span class="define">NULL</span>.</dd>
</dl>
<p>
<i class="ftype">struct lwp *</i> <b class="fname">rumpuser_curlwp</b>(<i class="farg">void</i>)<p>
Retrieve the rump kernel thread context associated with the current host thread, as set by <b class="fname">rumpuser_curlwpop</b>(). This routine may be called when a context is not set and the routine must return <span class="define">NULL</span> in that case. This interface is expected to be called very often. Any optimizations pertaining to the execution speed of this routine should be done in <b class="fname">rumpuser_curlwpop</b>().<p>
<i class="ftype">void</i> <b class="fname">rumpuser_seterrno</b>(<i class="farg">int errno</i>)<p>
Set an errno value in the calling thread's TLS. Note: this is used only if rump kernel clients make rump system calls.</div>
<div class="subsection">
<h2 id="x4d7574657865732c2072776c6f636b7320616e6420636f6e646974696f6e207661726961626c6573">Mutexes, rwlocks and condition variables</h2> The locking interfaces have standard semantics, so we will not discuss each one in detail. The data types <span class="type">struct rumpuser_mtx</span>, <span class="type">struct rumpuser_rw</span> and <span class="type">struct rumpuser_cv</span> used by these interfaces are opaque to the rump kernel, i.e. the hypervisor has complete freedom over them.<p>
Most of these interfaces will (and must) relinquish the rump kernel CPU context in case they block (or intend to block). The exceptions are the "nowrap" variants of the interfaces which may not relinquish rump kernel context.<p>
<i class="ftype">void</i> <b class="fname">rumpuser_mutex_init</b>(<i class="farg">struct rumpuser_mtx **mtxp</i>, <i class="farg">int flags</i>)<p>
<i class="ftype">void</i> <b class="fname">rumpuser_mutex_enter</b>(<i class="farg">struct rumpuser_mtx *mtx</i>)<p>
<i class="ftype">void</i> <b class="fname">rumpuser_mutex_enter_nowrap</b>(<i class="farg">struct rumpuser_mtx *mtx</i>)<p>
<i class="ftype">int</i> <b class="fname">rumpuser_mutex_tryenter</b>(<i class="farg">struct rumpuser_mtx *mtx</i>)<p>
<i class="ftype">void</i> <b class="fname">rumpuser_mutex_exit</b>(<i class="farg">struct rumpuser_mtx *mtx</i>)<p>
<i class="ftype">void</i> <b class="fname">rumpuser_mutex_destroy</b>(<i class="farg">struct rumpuser_mtx *mtx</i>)<p>
<i class="ftype">void</i> <b class="fname">rumpuser_mutex_owner</b>(<i class="farg">struct rumpuser_mtx *mtx</i>, <i class="farg">struct lwp **lp</i>)<p>
Mutexes provide mutually exclusive locking. The flags, of which at least one must be given, are as follows:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">RUMPUSER_MTX_SPIN</span></dt>
<dd class="list-tag" style="margin-left: 20.00ex;">
Create a spin mutex. Locking this type of mutex must not relinquish rump kernel context even when <b class="fname">rumpuser_mutex_enter</b>() is used.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">RUMPUSER_MTX_KMUTEX</span></dt>
<dd class="list-tag" style="margin-left: 20.00ex;">
The mutex must track and be able to return the rump kernel thread that owns the mutex (if any). If this flag is not specified, <b class="fname">rumpuser_mutex_owner</b>() will never be called for that particular mutex.</dd>
</dl>
<p>
<i class="ftype">void</i> <b class="fname">rumpuser_rw_init</b>(<i class="farg">struct rumpuser_rw **rwp</i>)<p>
<i class="ftype">void</i> <b class="fname">rumpuser_rw_enter</b>(<i class="farg">int enum_rumprwlock</i>, <i class="farg">struct rumpuser_rw *rw</i>)<p>
<i class="ftype">int</i> <b class="fname">rumpuser_rw_tryenter</b>(<i class="farg">int enum_rumprwlock</i>, <i class="farg">struct rumpuser_rw *rw</i>)<p>
<i class="ftype">int</i> <b class="fname">rumpuser_rw_tryupgrade</b>(<i class="farg">struct rumpuser_rw *rw</i>)<p>
<i class="ftype">void</i> <b class="fname">rumpuser_rw_downgrade</b>(<i class="farg">struct rumpuser_rw *rw</i>)<p>
<i class="ftype">void</i> <b class="fname">rumpuser_rw_exit</b>(<i class="farg">struct rumpuser_rw *rw</i>)<p>
<i class="ftype">void</i> <b class="fname">rumpuser_rw_destroy</b>(<i class="farg">struct rumpuser_rw *rw</i>)<p>
<i class="ftype">void</i> <b class="fname">rumpuser_rw_held</b>(<i class="farg">int enum_rumprwlock</i>, <i class="farg">struct rumpuser_rw *rw</i>, <i class="farg">int *heldp</i>);<p>
Read/write locks provide either shared or exclusive locking. The possible values for <i class="farg">lk</i> are <span class="define">RUMPUSER_RW_READER</span> and <span class="define">RUMPUSER_RW_WRITER</span>. Upgrading means trying to migrate from an already owned shared lock to an exclusive lock and downgrading means migrating from an already owned exclusive lock to a shared lock.<p>
<i class="ftype">void</i> <b class="fname">rumpuser_cv_init</b>(<i class="farg">struct rumpuser_cv **cvp</i>)<p>
<i class="ftype">void</i> <b class="fname">rumpuser_cv_destroy</b>(<i class="farg">struct rumpuser_cv *cv</i>)<p>
<i class="ftype">void</i> <b class="fname">rumpuser_cv_wait</b>(<i class="farg">struct rumpuser_cv *cv</i>, <i class="farg">struct rumpuser_mtx *mtx</i>)<p>
<i class="ftype">void</i> <b class="fname">rumpuser_cv_wait_nowrap</b>(<i class="farg">struct rumpuser_cv *cv</i>, <i class="farg">struct rumpuser_mtx *mtx</i>)<p>
<i class="ftype">int</i> <b class="fname">rumpuser_cv_timedwait</b>(<i class="farg">struct rumpuser_cv *cv</i>, <i class="farg">struct rumpuser_mtx *mtx</i>, <i class="farg">int64_t sec</i>, <i class="farg">int64_t nsec</i>);<p>
<i class="ftype">void</i> <b class="fname">rumpuser_cv_signal</b>(<i class="farg">struct rumpuser_cv *cv</i>)<p>
<i class="ftype">void</i> <b class="fname">rumpuser_cv_broadcast</b>(<i class="farg">struct rumpuser_cv *cv</i>)<p>
<i class="ftype">void</i> <b class="fname">rumpuser_cv_has_waiters</b>(<i class="farg">struct rumpuser_cv *cv</i>, <i class="farg">int *waitersp</i>)<p>
Condition variables wait for an event. The <i class="farg">mtx</i> interlock eliminates a race between checking the predicate and sleeping on the condition variable; the mutex should be released for the duration of the sleep in the normal atomic manner. The timedwait variant takes a specifier indicating a relative sleep duration after which the routine will return with <span class="errno">ETIMEDOUT</span>. If a timedwait is signaled before the timeout expires, the routine will return 0.<p>
The order in which the hypervisor reacquires the rump kernel context and interlock mutex before returning into the rump kernel is as follows. In case the interlock mutex was initialized with both <span class="define">RUMPUSER_MTX_SPIN</span> and <span class="define">RUMPUSER_MTX_KMUTEX</span>, the rump kernel context is scheduled before the mutex is reacquired. In case of a purely <span class="define">RUMPUSER_MTX_SPIN</span> mutex, the mutex is acquired first. In the final case the order is implementation-defined.</div>
</div>
<div class="section">
<h1 id="x52455455524e2056414c554553">RETURN VALUES</h1> All routines which return an integer return an errno value. The hypervisor must translate the value to the the native errno namespace used by the rump kernel. Routines which do not return an integer may never fail.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../3/rump">rump(3)</a><p>
<span class="ref"><span class="ref-auth">Antti Kantee</span>, <span class="ref-title">Flexible Operating System Internals: The Design and Implementation of the Anykernel and Rump Kernels</span>, <i class="ref-jrnl">Aalto University Doctoral Dissertations</i>, <span class="ref-date">2012</span>, <span class="ref-opt">Section 2.3.2: The Hypercall Interface</span>.</span><p>
For a list of all known implementations of the <b class="name">rumpuser</b> interface, see <a class="link-ext" href="http://wiki.rumpkernel.org/Platforms">http://wiki.rumpkernel.org/Platforms</a>.</div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The rump kernel hypercall API was first introduced in <span class="unix">NetBSD&#160;5.0</span>. The API described above first appeared in <span class="unix">NetBSD&#160;7.0</span>.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
August 24, 2014</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

