<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="/static/man_pages/netbsd/style.css" type="text/css" media="all">
<title>
RPC_SOC(3)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
RPC_SOC(3)</td>
<td class="head-vol" align="center">
Library Functions Manual</td>
<td class="head-rtitle" align="right">
RPC_SOC(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">rpc_soc</b>, <b class="name">auth_destroy</b>, <b class="name">authnone_create</b>, <b class="name">authunix_create</b>, <b class="name">authunix_create_default</b>, <b class="name">callrpc</b>, <b class="name">clnt_broadcast</b>, <b class="name">clnt_call</b>, <b class="name">clnt_control</b>, <b class="name">clnt_create</b>, <b class="name">clnt_destroy</b>, <b class="name">clnt_freeres</b>, <b class="name">clnt_geterr</b>, <b class="name">clnt_pcreateerror</b>, <b class="name">clnt_perrno</b>, <b class="name">clnt_perror</b>, <b class="name">clnt_spcreateerror</b>, <b class="name">clnt_sperrno</b>, <b class="name">clnt_sperror</b>, <b class="name">clntraw_create</b>, <b class="name">clnttcp_create</b>, <b class="name">clntudp_bufcreate</b>, <b class="name">clntudp_create</b>, <b class="name">get_myaddress</b>, <b class="name">pmap_getmaps</b>, <b class="name">pmap_getport</b>, <b class="name">pmap_rmtcall</b>, <b class="name">pmap_set</b>, <b class="name">pmap_unset</b>, <b class="name">registerrpc</b>, <b class="name">rpc_createerr</b>, <b class="name">svc_destroy</b>, <b class="name">svc_fds</b>, <b class="name">svc_fdset</b>, <b class="name">svc_getargs</b>, <b class="name">svc_getcaller</b>, <b class="name">svc_getreg</b>, <b class="name">svc_getregset</b>, <b class="name">svc_getrpccaller</b>, <b class="name">svc_register</b>, <b class="name">svc_run</b>, <b class="name">svc_sendreply</b>, <b class="name">svc_unregister</b>, <b class="name">svcerr_auth</b>, <b class="name">svcerr_decode</b>, <b class="name">svcerr_noproc</b>, <b class="name">svcerr_noprog</b>, <b class="name">svcerr_progvers</b>, <b class="name">svcerr_systemerr</b>, <b class="name">svcerr_weakauth</b>, <b class="name">svcfd_create</b>, <b class="name">svcraw_create</b>, <b class="name">xdr_accepted_reply</b>, <b class="name">xdr_authunix_parms</b>, <b class="name">xdr_callhdr</b>, <b class="name">xdr_callmsg</b>, <b class="name">xdr_opaque_auth</b>, <b class="name">xdr_pmap</b>, <b class="name">xdr_pmaplist</b>, <b class="name">xdr_rejected_reply</b>, <b class="name">xdr_replymsg</b>, <b class="name">xprt_register</b>, <b class="name">xprt_unregister</b> &#8212; <span class="desc">library routines for remote procedure calls</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">rpc/rpc.h</a>&gt;</b><p>
<i class="ftype">void</i><br>
<b class="fname">auth_destroy</b>(<i class="farg" style="white-space:nowrap;">AUTH *auth</i>);<p>
<i class="ftype">AUTH *</i><br>
<b class="fname">authnone_create</b>(<i class="farg" style="white-space:nowrap;">void</i>);<p>
<i class="ftype">AUTH *</i><br>
<b class="fname">authunix_create</b>(<i class="farg" style="white-space:nowrap;">char *host</i>, <i class="farg" style="white-space:nowrap;">int uid</i>, <i class="farg" style="white-space:nowrap;">int gid</i>, <i class="farg" style="white-space:nowrap;">int len</i>, <i class="farg" style="white-space:nowrap;">int *aup_gids</i>);<p>
<i class="ftype">AUTH *</i><br>
<b class="fname">authunix_create_default</b>(<i class="farg" style="white-space:nowrap;">void</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">callrpc</b>(<i class="farg" style="white-space:nowrap;">char *host</i>, <i class="farg" style="white-space:nowrap;">u_long prognum</i>, <i class="farg" style="white-space:nowrap;">u_long versnum</i>, <i class="farg" style="white-space:nowrap;">u_long procnum</i>, <i class="farg" style="white-space:nowrap;">xdrproc_t inproc</i>, <i class="farg" style="white-space:nowrap;">char *in</i>, <i class="farg" style="white-space:nowrap;">xdrproc_t outproc</i>, <i class="farg" style="white-space:nowrap;">char *out</i>);<p>
<i class="ftype">enum clnt_stat</i><br>
<b class="fname">clnt_broadcast</b>(<i class="farg" style="white-space:nowrap;">u_long prognum</i>, <i class="farg" style="white-space:nowrap;">u_long versnum</i>, <i class="farg" style="white-space:nowrap;">u_long procnum</i>, <i class="farg" style="white-space:nowrap;">xdrproc_t inproc</i>, <i class="farg" style="white-space:nowrap;">char *in</i>, <i class="farg" style="white-space:nowrap;">xdrproc_t outproc</i>, <i class="farg" style="white-space:nowrap;">char *out</i>, <i class="farg" style="white-space:nowrap;">resultproc_t eachresult</i>);<p>
<i class="ftype">enum clnt_stat</i><br>
<b class="fname">clnt_call</b>(<i class="farg" style="white-space:nowrap;">CLIENT *clnt</i>, <i class="farg" style="white-space:nowrap;">u_long procnum</i>, <i class="farg" style="white-space:nowrap;">xdrproc_t inproc</i>, <i class="farg" style="white-space:nowrap;">char *in</i>, <i class="farg" style="white-space:nowrap;">xdrproc_t outproc</i>, <i class="farg" style="white-space:nowrap;">char *out</i>, <i class="farg" style="white-space:nowrap;">struct timeval tout</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">clnt_destroy</b>(<i class="farg" style="white-space:nowrap;">CLIENT *clnt</i>);<p>
<i class="ftype">CLIENT *</i><br>
<b class="fname">clnt_create</b>(<i class="farg" style="white-space:nowrap;">char *host</i>, <i class="farg" style="white-space:nowrap;">u_long prog</i>, <i class="farg" style="white-space:nowrap;">u_long vers</i>, <i class="farg" style="white-space:nowrap;">char *proto</i>);<p>
<i class="ftype">bool_t</i><br>
<b class="fname">clnt_control</b>(<i class="farg" style="white-space:nowrap;">CLIENT *cl</i>, <i class="farg" style="white-space:nowrap;">u_int req</i>, <i class="farg" style="white-space:nowrap;">char *info</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">clnt_freeres</b>(<i class="farg" style="white-space:nowrap;">CLIENT *clnt</i>, <i class="farg" style="white-space:nowrap;">xdrproc_t outproc</i>, <i class="farg" style="white-space:nowrap;">char *out</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">clnt_geterr</b>(<i class="farg" style="white-space:nowrap;">CLIENT *clnt</i>, <i class="farg" style="white-space:nowrap;">struct rpc_err errp</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">clnt_pcreateerror</b>(<i class="farg" style="white-space:nowrap;">char *s</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">clnt_perrno</b>(<i class="farg" style="white-space:nowrap;">enum clnt_stat stat</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">clnt_perror</b>(<i class="farg" style="white-space:nowrap;">CLIENT *clnt</i>, <i class="farg" style="white-space:nowrap;">char *s</i>);<p>
<i class="ftype">char *</i><br>
<b class="fname">clnt_spcreateerror</b>(<i class="farg" style="white-space:nowrap;">const char *s</i>);<p>
<i class="ftype">char *</i><br>
<b class="fname">clnt_sperrno</b>(<i class="farg" style="white-space:nowrap;">enum clnt_stat stat</i>);<p>
<i class="ftype">char *</i><br>
<b class="fname">clnt_sperror</b>(<i class="farg" style="white-space:nowrap;">CLIENT *rpch</i>, <i class="farg" style="white-space:nowrap;">char *s</i>);<p>
<i class="ftype">CLIENT *</i><br>
<b class="fname">clntraw_create</b>(<i class="farg" style="white-space:nowrap;">u_long prognum</i>, <i class="farg" style="white-space:nowrap;">u_long versnum</i>);<p>
<i class="ftype">CLIENT *</i><br>
<b class="fname">clnttcp_create</b>(<i class="farg" style="white-space:nowrap;">struct sockaddr_in *addr</i>, <i class="farg" style="white-space:nowrap;">u_long prognum</i>, <i class="farg" style="white-space:nowrap;">u_long versnum</i>, <i class="farg" style="white-space:nowrap;">int *sockp</i>, <i class="farg" style="white-space:nowrap;">u_int sendsz</i>, <i class="farg" style="white-space:nowrap;">u_int recvsz</i>);<p>
<i class="ftype">CLIENT *</i><br>
<b class="fname">clntudp_create</b>(<i class="farg" style="white-space:nowrap;">struct sockaddr_in *addr</i>, <i class="farg" style="white-space:nowrap;">u_long prognum</i>, <i class="farg" style="white-space:nowrap;">u_long versnum</i>, <i class="farg" style="white-space:nowrap;">struct timeval wait</i>, <i class="farg" style="white-space:nowrap;">int *sockp</i>);<p>
<i class="ftype">CLIENT *</i><br>
<b class="fname">clntudp_bufcreate</b>(<i class="farg" style="white-space:nowrap;">struct sockaddr_in *addr</i>, <i class="farg" style="white-space:nowrap;">u_long prognum</i>, <i class="farg" style="white-space:nowrap;">u_long versnum</i>, <i class="farg" style="white-space:nowrap;">struct timeval wait</i>, <i class="farg" style="white-space:nowrap;">int *sockp</i>, <i class="farg" style="white-space:nowrap;">unsigned int sendsize</i>, <i class="farg" style="white-space:nowrap;">unsigned int recosize</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">get_myaddress</b>(<i class="farg" style="white-space:nowrap;">struct sockaddr_in *addr</i>);<p>
<i class="ftype">struct pmaplist *</i><br>
<b class="fname">pmap_getmaps</b>(<i class="farg" style="white-space:nowrap;">struct sockaddr_in *addr</i>);<p>
<i class="ftype">u_short</i><br>
<b class="fname">pmap_getport</b>(<i class="farg" style="white-space:nowrap;">struct sockaddr_in *addr</i>, <i class="farg" style="white-space:nowrap;">u_long prognum</i>, <i class="farg" style="white-space:nowrap;">u_long versnum</i>, <i class="farg" style="white-space:nowrap;">u_long protocol</i>);<p>
<i class="ftype">enum clnt_stat</i><br>
<b class="fname">pmap_rmtcall</b>(<i class="farg">struct sockaddr_in *addr</i>, <i class="farg">u_long prognum</i>, <i class="farg">u_long versnum</i>, <i class="farg">u_long procnum</i>, <i class="farg">xdrproc_t inproc</i>, <i class="farg">char *in</i>, <i class="farg">xdrpoc_t outproc</i>, <i class="farg">char *out</i>, <i class="farg">struct timeval tout</i>, <i class="farg">u_long *portp</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">pmap_set</b>(<i class="farg" style="white-space:nowrap;">u_long prognum</i>, <i class="farg" style="white-space:nowrap;">u_long versnum</i>, <i class="farg" style="white-space:nowrap;">int protocol</i>, <i class="farg" style="white-space:nowrap;">int port</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">pmap_unset</b>(<i class="farg" style="white-space:nowrap;">u_long prognum</i>, <i class="farg" style="white-space:nowrap;">u_long versnum</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">registerrpc</b>(<i class="farg" style="white-space:nowrap;">u_long prognum</i>, <i class="farg" style="white-space:nowrap;">u_long versnum</i>, <i class="farg" style="white-space:nowrap;">u_long procnum</i>, <i class="farg" style="white-space:nowrap;">char *(*procname)()</i>, <i class="farg" style="white-space:nowrap;">xdrproc_t inproc</i>, <i class="farg" style="white-space:nowrap;">xdrproc_t outproc</i>);<p>
<b class="macro">struct rpc_createerr rpc_createerr;</b><p>
<i class="ftype">int</i><br>
<b class="fname">svc_destroy</b>(<i class="farg" style="white-space:nowrap;">SVCXPRT *xprt</i>);<p>
<b class="macro">fd_set svc_fdset;</b><br>
<b class="macro">int svc_fds;</b><p>
<i class="ftype">int</i><br>
<b class="fname">svc_freeargs</b>(<i class="farg" style="white-space:nowrap;">SVCXPRT *xprt</i>, <i class="farg" style="white-space:nowrap;">xdrproc_t inproc</i>, <i class="farg" style="white-space:nowrap;">char *in</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">svc_getargs</b>(<i class="farg" style="white-space:nowrap;">SVCXPRT *xprt</i>, <i class="farg" style="white-space:nowrap;">xdrproc_t inproc</i>, <i class="farg" style="white-space:nowrap;">char *in</i>);<p>
<i class="ftype">struct sockaddr_in *</i><br>
<b class="fname">svc_getcaller</b>(<i class="farg" style="white-space:nowrap;">SVCXPRT *xprt</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">svc_getreqset</b>(<i class="farg" style="white-space:nowrap;">fd_set *rdfds</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">svc_getreq</b>(<i class="farg" style="white-space:nowrap;">int rdfds</i>);<p>
<i class="ftype">struct netbuf *</i><br>
<b class="fname">svc_getrpccaller</b>(<i class="farg" style="white-space:nowrap;">SVCXPRT *xprt</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">svc_register</b>(<i class="farg" style="white-space:nowrap;">SVCXPRT *xprt</i>, <i class="farg" style="white-space:nowrap;">u_long prognum</i>, <i class="farg" style="white-space:nowrap;">u_long versnum</i>, <i class="farg" style="white-space:nowrap;">void (*dispatch)()</i>, <i class="farg" style="white-space:nowrap;">u_long protocol</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">svc_run</b>(<i class="farg" style="white-space:nowrap;">void</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">svc_sendreply</b>(<i class="farg" style="white-space:nowrap;">SVCXPRT *xprt</i>, <i class="farg" style="white-space:nowrap;">xdrproc_t outproc</i>, <i class="farg" style="white-space:nowrap;">char *out</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">svc_unregister</b>(<i class="farg" style="white-space:nowrap;">u_long prognum</i>, <i class="farg" style="white-space:nowrap;">u_long versnum</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">svcerr_auth</b>(<i class="farg" style="white-space:nowrap;">SVCXPRT *xprt</i>, <i class="farg" style="white-space:nowrap;">enum auth_stat why</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">svcerr_decode</b>(<i class="farg" style="white-space:nowrap;">SVCXPRT *xprt</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">svcerr_noproc</b>(<i class="farg" style="white-space:nowrap;">SVCXPRT *xprt</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">svcerr_noprog</b>(<i class="farg" style="white-space:nowrap;">SVCXPRT *xprt</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">svcerr_progvers</b>(<i class="farg" style="white-space:nowrap;">SVCXPRT *xprt</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">svcerr_systemerr</b>(<i class="farg" style="white-space:nowrap;">SVCXPRT *xprt</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">svcerr_weakauth</b>(<i class="farg" style="white-space:nowrap;">SVCXPRT *xprt</i>);<p>
<i class="ftype">SVCXPRT *</i><br>
<b class="fname">svcraw_create</b>(<i class="farg" style="white-space:nowrap;">void</i>);<p>
<i class="ftype">SVCXPRT *</i><br>
<b class="fname">svctcp_create</b>(<i class="farg" style="white-space:nowrap;">int sock</i>, <i class="farg" style="white-space:nowrap;">u_int send_buf_size</i>, <i class="farg" style="white-space:nowrap;">u_int recv_buf_size</i>);<p>
<i class="ftype">SVCXPRT *</i><br>
<b class="fname">svcfd_create</b>(<i class="farg" style="white-space:nowrap;">int fd</i>, <i class="farg" style="white-space:nowrap;">u_int sendsize</i>, <i class="farg" style="white-space:nowrap;">u_int recvsize</i>);<p>
<i class="ftype">SVCXPRT *</i><br>
<b class="fname">svcudp_bufcreate</b>(<i class="farg" style="white-space:nowrap;">int sock</i>, <i class="farg" style="white-space:nowrap;">u_int sendsize</i>, <i class="farg" style="white-space:nowrap;">u_int recosize</i>);<p>
<i class="ftype">SVCXPRT *</i><br>
<b class="fname">svcudp_create</b>(<i class="farg" style="white-space:nowrap;">int sock</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">xdr_accepted_reply</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">struct accepted_reply *ar</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">xdr_authunix_parms</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">struct authunix_parms *aupp</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">xdr_callhdr</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">struct rpc_msg *chdr</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">xdr_callmsg</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">struct rpc_msg *cmsg</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">xdr_opaque_auth</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">struct opaque_auth *ap</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">xdr_pmap</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">struct pmap *regs</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">xdr_pmaplist</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">struct pmaplist **rp</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">xdr_rejected_reply</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">struct rejected_reply *rr</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">xdr_replymsg</b>(<i class="farg" style="white-space:nowrap;">XDR *xdrs</i>, <i class="farg" style="white-space:nowrap;">struct rpc_msg *rmsg</i>);<p>
<i class="ftype">bool_t</i><br>
<b class="fname">xprt_register</b>(<i class="farg" style="white-space:nowrap;">SVCXPRT *xprt</i>);<p>
<i class="ftype">void</i><br>
<b class="fname">xprt_unregister</b>(<i class="farg" style="white-space:nowrap;">SVCXPRT *xprt</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> <span class="emph">The svc and clnt functions described in this page are the old, TS-RPC</span> <span class="emph">interface to the XDR and RPC library, and exist for backward compatibility.</span> <span class="emph">The new interface is described in the pages referenced from</span> <a class="link-man" href="../3/rpc">rpc(3)</a>.<p>
These routines allow C programs to make procedure calls on other machines across the network. First, the client calls a procedure to send a data packet to the server. Upon receipt of the packet, the server calls a dispatch routine to perform the requested service, and then sends back a reply. Finally, the procedure call returns to the client.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">auth_destroy</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A macro that destroys the authentication information associated with <i class="farg">auth</i>. Destruction usually involves deallocation of private data structures. The use of <i class="farg">auth</i> is undefined after calling <b class="fname">auth_destroy</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">authnone_create</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Create and returns an RPC authentication handle that passes nonusable authentication information with each remote procedure call. This is the default authentication used by RPC.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">authunix_create</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Create and return an RPC authentication handle that contains authentication information. The parameter <i class="farg">host</i> is the name of the machine on which the information was created; <i class="farg">uid</i> is the user's user ID; <i class="farg">gid</i> is the user's current group id; <i class="farg">len</i> and <i class="farg">aup_gids</i> refer to a counted array of groups to which the user belongs. It is easy to impersonate a user.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">authunix_create_default</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Calls <b class="fname">authunix_create</b>() with the appropriate parameters.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">callrpc</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Call the remote procedure associated with <i class="farg">prognum</i>, <i class="farg">versnum</i>, and <i class="farg">procnum</i> on the machine, <i class="farg">host</i>. The parameter <i class="farg">in</i> is the address of the procedure's argument(s), and <i class="farg">out</i> is the address of where to place the result(s); <i class="farg">inproc</i> is used to encode the procedure's parameters, and <i class="farg">outproc</i> is used to decode the procedure's results. This routine returns zero if it succeeds, or the value of <b class="var">enum clnt_stat</b> cast to an integer if it fails. The routine <b class="fname">clnt_perrno</b>() is handy for translating failure statuses into messages.<p>
Warning: calling remote procedures with this routine uses UDP/IP as a transport; see <b class="fname">clntudp_create</b>() for restrictions. You do not have control of timeouts or authentication using this routine.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">clnt_broadcast</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Like <b class="fname">callrpc</b>(), except the call message is broadcast to all locally connected broadcast nets. Each time it receives a response, this routine calls <b class="fname">eachresult</b>(), whose form is <i class="ftype">int</i> <b class="fname">eachresult</b>(<i class="farg">char *out</i>, <i class="farg">struct sockaddr_in *addr</i>) where <i class="farg">out</i> is the same as <i class="farg">out</i> passed to <b class="fname">clnt_broadcast</b>(), except that the remote procedure's output is decoded there; <i class="farg">addr</i> points to the address of the machine that sent the results. If <b class="fname">eachresult</b>() returns zero, <b class="fname">clnt_broadcast</b>() waits for more replies; otherwise it returns with appropriate status.<p>
Warning: broadcast sockets are limited in size to the maximum transfer unit of the data link. For ethernet, this value is 1500 bytes.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">clnt_call</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A macro that calls the remote procedure <i class="farg">procnum</i> associated with the client handle, <i class="farg">clnt</i>, which is obtained with an RPC client creation routine such as <b class="fname">clnt_create</b>(). The parameter <i class="farg">in</i> is the address of the procedure's argument(s), and <i class="farg">out</i> is the address of where to place the result(s); <i class="farg">inproc</i> is used to encode the procedure's parameters, and <i class="farg">outproc</i> is used to decode the procedure's results; <i class="farg">tout</i> is the time allowed for results to come back.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">clnt_destroy</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A macro that destroys the client's RPC handle. Destruction usually involves deallocation of private data structures, including <i class="farg">clnt</i> itself. Use of <i class="farg">clnt</i> is undefined after calling <b class="fname">clnt_destroy</b>(). If the RPC library opened the associated socket, it will close it also. Otherwise, the socket remains open.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">clnt_create</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Generic client creation routine. <i class="farg">host</i> identifies the name of the remote host where the server is located. <i class="farg">proto</i> indicates which kind of transport protocol to use. The currently supported values for this field are &#8220;udp&#8221; and &#8220;tcp&#8221;. Default timeouts are set, but can be modified using <b class="fname">clnt_control</b>().<p>
<span class="emph">Warning</span>: Using UDP has its shortcomings. Since UDP-based RPC messages can only hold up to 8 Kbytes of encoded data, this transport cannot be used for procedures that take large arguments or return huge results.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">clnt_control</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A macro used to change or retrieve various information about a client object. <i class="farg">req</i> indicates the type of operation, and <i class="farg">info</i> is a pointer to the information. For both UDP and TCP the supported values of <i class="farg">req</i> and their argument types and what they do are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
CLSET_TIMEOUT</dt>
<dd class="list-tag" style="margin-left: 20.00ex;">
<span class="type">struct timeval</span>; set total timeout.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
CLGET_TIMEOUT</dt>
<dd class="list-tag" style="margin-left: 20.00ex;">
<span class="type">struct timeval</span>; get total timeout.<p>
Note: if you set the timeout using <b class="fname">clnt_control</b>(), the timeout parameter passed to <b class="fname">clnt_call</b>() will be ignored in all future calls.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
CLGET_SERVER_ADDR</dt>
<dd class="list-tag" style="margin-left: 20.00ex;">
<span class="type">struct sockaddr_in</span>; get server's address.</dd>
</dl>
<p>
The following operations are valid for UDP only:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
CLSET_RETRY_TIMEOUT</dt>
<dd class="list-tag" style="margin-left: 19.00ex;">
<span class="type">struct timeval</span>; set the retry timeout.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
CLGET_RETRY_TIMEOUT</dt>
<dd class="list-tag" style="margin-left: 19.00ex;">
<span class="type">struct timeval</span>; get the retry timeout.<p>
The retry timeout is the time that UDP RPC waits for the server to reply before retransmitting the request.</dd>
</dl>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">clnt_freeres</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A macro that frees any data allocated by the RPC/XDR system when it decoded the results of an RPC call. The parameter <i class="farg">out</i> is the address of the results, and <i class="farg">outproc</i> is the XDR routine describing the results. This routine returns one if the results were successfully freed, and zero otherwise.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">clnt_geterr</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A macro that copies the error structure out of the client handle to the structure at address <i class="farg">errp</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">clnt_pcreateerror</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Print a message to standard error indicating why a client RPC handle could not be created. The message is prepended with string <i class="farg">s</i> and a colon. A newline character is appended at the end of the message. Used when a <b class="fname">clnt_create</b>(), <b class="fname">clntraw_create</b>(), <b class="fname">clnttcp_create</b>(), or <b class="fname">clntudp_create</b>() call fails.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">clnt_perrno</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Print a message to standard error corresponding to the condition indicated by <i class="farg">stat</i>. A newline character is appended at the end of the message. Used after <b class="fname">callrpc</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">clnt_perror</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Print a message to standard error indicating why an RPC call failed; <i class="farg">clnt</i> is the handle used to do the call. The message is prepended with string <i class="farg">s</i> and a colon. A newline character is appended at the end of the message. Used after <b class="fname">clnt_call</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">clnt_spcreateerror</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Like <b class="fname">clnt_pcreateerror</b>(), except that it returns a string instead of printing to the standard error.<p>
Bugs: returns pointer to static data that is overwritten on each call.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">clnt_sperrno</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Take the same arguments as <b class="fname">clnt_perrno</b>(), but instead of sending a message to the standard error indicating why an RPC call failed, return a pointer to a string which contains the message.<p>
<b class="fname">clnt_sperrno</b>() is used instead of <b class="fname">clnt_perrno</b>() if the program does not have a standard error (as a program running as a server quite likely does not), or if the programmer does not want the message to be output with <a class="link-man" href="../3/printf">printf(3)</a>, or if a message format different than that supported by <b class="fname">clnt_perrno</b>() is to be used. Note: unlike <b class="fname">clnt_sperror</b>() and <b class="fname">clnt_spcreateerror</b>(), <b class="fname">clnt_sperrno</b>() returns a pointer to static data, but the result will not get overwritten on each call.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">clnt_sperror</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Like <b class="fname">clnt_perror</b>(), except that (like <b class="fname">clnt_sperrno</b>()) it returns a string instead of printing to standard error.<p>
Bugs: returns pointer to static data that is overwritten on each call.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">clntraw_create</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
This routine creates a toy RPC client for the remote program <i class="farg">prognum</i>, version <i class="farg">versnum</i>. The transport used to pass messages to the service is actually a buffer within the process's address space, so the corresponding RPC server should live in the same address space; see <b class="fname">svcraw_create</b>(). This allows simulation of RPC and acquisition of RPC overheads, such as round trip times, without any kernel interference. This routine returns <span class="define">NULL</span> if it fails.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">clnttcp_create</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
This routine creates an RPC client for the remote program <i class="farg">prognum</i>, version <i class="farg">versnum</i>; the client uses TCP/IP as a transport. The remote program is located at Internet address <i class="farg">*addr</i>. If <i class="farg">addr-&gt;sin_port</i> is zero, then it is set to the actual port that the remote program is listening on (the remote <a class="link-man" href="../8/rpcbind">rpcbind(8)</a> or <b class="flag">portmap</b> service is consulted for this information). The parameter <i class="farg">sockp</i> is a socket; if it is <span class="define">RPC_ANYSOCK</span>, then this routine opens a new one and sets <i class="farg">sockp</i>. Since TCP-based RPC uses buffered I/O , the user may specify the size of the send and receive buffers with the parameters <i class="farg">sendsz</i> and <i class="farg">recvsz</i>; values of zero choose suitable defaults. This routine returns <span class="define">NULL</span> if it fails.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">clntudp_create</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
This routine creates an RPC client for the remote program <i class="farg">prognum</i>, version <i class="farg">versnum</i>; the client uses UDP/IP as a transport. The remote program is located at Internet address <i class="farg">addr</i>. If <i class="farg">addr-&gt;sin_port</i> is zero, then it is set to actual port that the remote program is listening on (the remote <a class="link-man" href="../8/rpcbind">rpcbind(8)</a> or <b class="flag">portmap</b> service is consulted for this information). The parameter <i class="farg">sockp</i> is a socket; if it is <span class="define">RPC_ANYSOCK</span>, then this routine opens a new one and sets <i class="farg">sockp</i>. The UDP transport resends the call message in intervals of <i class="farg">wait</i> time until a response is received or until the call times out. The total time for the call to time out is specified by <i class="farg">clnt_call</i>.<p>
Warning: since UDP-based RPC messages can only hold up to 8 Kbytes of encoded data, this transport cannot be used for procedures that take large arguments or return huge results.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">clntudp_bufcreate</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
This routine creates an RPC client for the remote program <i class="farg">prognum</i>, on <i class="farg">versnum</i>; the client uses UDP/IP as a transport. The remote program is located at Internet address <i class="farg">addr</i>. If <i class="farg">addr-&gt;sin_port</i> is zero, then it is set to actual port that the remote program is listening on (the remote <a class="link-man" href="../8/rpcbind">rpcbind(8)</a> or <b class="flag">portmap</b> service is consulted for this information). The parameter <i class="farg">sockp</i> is a socket; if it is <span class="define">RPC_ANYSOCK</span>, then this routine opens a new one and sets <i class="farg">sockp</i>. The UDP transport resends the call message in intervals of <i class="farg">wait</i> time until a response is received or until the call times out. The total time for the call to time out is specified by <i class="farg">clnt_call</i>.<p>
This allows the user to specify the maximum packet size for sending and receiving UDP-based RPC messages.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">get_myaddress</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Stuff the machine's IP address into <i class="farg">*addr</i>, without consulting the library routines that deal with <i class="file">/etc/hosts</i>. The port number is always set to <b class="fname">htons</b>(<i class="farg">PMAPPORT</i>). Returns zero on success, non-zero on failure.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pmap_getmaps</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A user interface to the <a class="link-man" href="../8/rpcbind">rpcbind(8)</a> service, which returns a list of the current RPC program-to-port mappings on the host located at IP address <i class="farg">*addr</i>. This routine can return <span class="define">NULL</span>. The command<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit"><b class="flag">rpcinfo</b> <b class="flag">&#45;p</b></code></div>
</blockquote>
uses this routine.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pmap_getport</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A user interface to the <a class="link-man" href="../8/rpcbind">rpcbind(8)</a> service, which returns the port number on which waits a service that supports program number <i class="farg">prognum</i>, version <i class="farg">versnum</i>, and speaks the transport protocol associated with <i class="farg">protocol</i>. The value of <i class="farg">protocol</i> is most likely <span class="define">IPPROTO_UDP</span> or <span class="define">IPPROTO_TCP</span>. A return value of zero means that the mapping does not exist or that the RPC system failured to contact the remote <a class="link-man" href="../8/rpcbind">rpcbind(8)</a> service. In the latter case, the global variable <b class="fname">rpc_createerr</b>() contains the RPC status.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pmap_rmtcall</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A user interface to the <a class="link-man" href="../8/rpcbind">rpcbind(8)</a> service, which instructs <a class="link-man" href="../8/rpcbind">rpcbind(8)</a> on the host at IP address <i class="farg">*addr</i> to make an RPC call on your behalf to a procedure on that host. The parameter <i class="farg">*portp</i> will be modified to the program's port number if the procedure succeeds. The definitions of other parameters are discussed in <b class="fname">callrpc</b>() and <b class="fname">clnt_call</b>(). This procedure should be used for a &#8220;ping&#8221; and nothing else. See also <b class="fname">clnt_broadcast</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pmap_set</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A user interface to the <a class="link-man" href="../8/rpcbind">rpcbind(8)</a> service, which establishes a mapping between the triple [<i class="farg">prognum</i>, <i class="farg">versnum</i>, <i class="farg">protocol</i>] and <i class="farg">port</i> on the machine's <a class="link-man" href="../8/rpcbind">rpcbind(8)</a> service. The value of <i class="farg">protocol</i> is most likely <span class="define">IPPROTO_UDP</span> or <span class="define">IPPROTO_TCP</span>. This routine returns one if it succeeds, zero otherwise. Automatically done by <b class="fname">svc_register</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">pmap_unset</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A user interface to the <a class="link-man" href="../8/rpcbind">rpcbind(8)</a> service, which destroys all mapping between the triple [<i class="farg">prognum</i>, <i class="farg">versnum</i>, <i class="farg">*</i>] and <i class="farg">ports</i> on the machine's <a class="link-man" href="../8/rpcbind">rpcbind(8)</a> service. This routine returns one if it succeeds, zero otherwise.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">registerrpc</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Register procedure <i class="farg">procname</i> with the RPC service package. If a request arrives for program <i class="farg">prognum</i>, version <i class="farg">versnum</i>, and procedure <i class="farg">procnum</i>, <i class="farg">procname</i> is called with a pointer to its parameter(s); <i class="farg">progname</i> should return a pointer to its static result(s); <i class="farg">inproc</i> is used to decode the parameters while <i class="farg">outproc</i> is used to encode the results. This routine returns zero if the registration succeeded, &#45;1 otherwise.<p>
Warning: remote procedures registered in this form are accessed using the UDP/IP transport; see <b class="fname">svcudp_bufcreate</b>() for restrictions.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
struct rpc_createerr rpc_createerr;</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A global variable whose value is set by any RPC client creation routine that does not succeed. Use the routine <b class="fname">clnt_pcreateerror</b>() to print the reason why.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">svc_destroy</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A macro that destroys the RPC service transport handle, <i class="farg">xprt</i>. Destruction usually involves deallocation of private data structures, including <i class="farg">xprt</i> itself. Use of <i class="farg">xprt</i> is undefined after calling this routine.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
fd_set svc_fdset;</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A global variable reflecting the RPC service side's read file descriptor bit mask; it is suitable as a parameter to the <a class="link-man" href="../2/select">select(2)</a> system call. This is only of interest if a service implementor does not call <b class="fname">svc_run</b>(), but rather does his own asynchronous event processing. This variable is read-only (do not pass its address to <a class="link-man" href="../2/select">select(2)</a>!), yet it may change after calls to <b class="fname">svc_getreqset</b>() or any creation routines.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
int svc_fds;</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Similar to <b class="fname">svc_fedset</b>(), but limited to 32 descriptors. This interface is obsoleted by <b class="fname">svc_fdset</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">svc_freeargs</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A macro that frees any data allocated by the RPC/XDR system when it decoded the arguments to a service procedure using <b class="fname">svc_getargs</b>(). This routine returns 1 if the results were successfully freed, and zero otherwise.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">svc_getargs</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
A macro that decodes the arguments of an RPC request associated with the RPC service transport handle, <i class="farg">xprt</i>. The parameter <i class="farg">in</i> is the address where the arguments will be placed; <i class="farg">inproc</i> is the XDR routine used to decode the arguments. This routine returns one if decoding succeeds, and zero otherwise.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">svc_getcaller</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
The obsolete way of getting the network address of the caller of a procedure associated with the RPC service transport handle, <i class="farg">xprt</i>, use <b class="fname">svc_getrpccaller</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">svc_getreqset</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
This routine is only of interest if a service implementor does not call <b class="fname">svc_run</b>(), but instead implements custom asynchronous event processing. It is called when the <a class="link-man" href="../2/select">select(2)</a> system call has determined that an RPC request has arrived on some RPC socket(s) ; <i class="farg">rdfds</i> is the resultant read file descriptor bit mask. The routine returns when all sockets associated with the value of <i class="farg">rdfds</i> have been serviced.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">svc_getreq</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Similar to <b class="fname">svc_getreqset</b>(), but limited to 32 descriptors. This interface is obsoleted by <b class="fname">svc_getreqset</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">svc_getrpccaller</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
The approved way of getting the network address of the caller of a procedure associated with the RPC service transport handle, <i class="farg">xprt</i>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">svc_register</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Associates <i class="farg">prognum</i> and <i class="farg">versnum</i> with the service dispatch procedure, <i class="farg">dispatch</i>. If <i class="farg">protocol</i> is zero, the service is not registered with the <a class="link-man" href="../8/rpcbind">rpcbind(8)</a> service. If <i class="farg">protocol</i> is non-zero, then a mapping of the triple [<i class="farg">prognum</i>, <i class="farg">versnum</i>, <i class="farg">protocol</i>] to <i class="farg">xprt-&gt;xp_port</i> is established with the local <a class="link-man" href="../8/rpcbind">rpcbind(8)</a> service (generally <i class="farg">protocol</i> is zero, <span class="define">IPPROTO_UDP</span> or <span class="define">IPPROTO_TCP</span>). The procedure <i class="farg">dispatch</i> has the following form: <i class="ftype">int</i> <b class="fname">dispatch</b>(<i class="farg">struct svc_req *request</i>, <i class="farg">SVCXPRT *xprt</i>).<p>
The <b class="fname">svc_register</b>() routine returns one if it succeeds, and zero otherwise.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">svc_run</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
This routine never returns. It waits for RPC requests to arrive, and calls the appropriate service procedure using <b class="fname">svc_getreq</b>() when one arrives. This procedure is usually waiting for a <a class="link-man" href="../2/select">select(2)</a> system call to return.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">svc_sendreply</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Called by an RPC service's dispatch routine to send the results of a remote procedure call. The parameter <i class="farg">xprt</i> is the request's associated transport handle; <i class="farg">outproc</i> is the XDR routine which is used to encode the results; and <i class="farg">out</i> is the address of the results. This routine returns one if it succeeds, zero otherwise.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">svc_unregister</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Remove all mapping of the double [<i class="farg">prognum</i>, <i class="farg">versnum</i>] to dispatch routines, and of the triple [<i class="farg">prognum</i>, <i class="farg">versnum</i>, <i class="farg">*</i>] to port number.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">svcerr_auth</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Called by a service dispatch routine that refuses to perform a remote procedure call due to an authentication error.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">svcerr_decode</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Called by a service dispatch routine that cannot successfully decode its parameters. See also <b class="fname">svc_getargs</b>().</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">svcerr_noproc</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Called by a service dispatch routine that does not implement the procedure number that the caller requests.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">svcerr_noprog</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Called when the desired program is not registered with the RPC package. Service implementors usually do not need this routine.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">svcerr_progvers</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Called when the desired version of a program is not registered with the RPC package. Service implementors usually do not need this routine.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">svcerr_systemerr</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Called by a service dispatch routine when it detects a system error not covered by any particular protocol. For example, if a service can no longer allocate storage, it may call this routine.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">svcerr_weakauth</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Called by a service dispatch routine that refuses to perform a remote procedure call due to insufficient authentication parameters. The routine calls <b class="fname">svcerr_auth</b>(<i class="farg">xprt</i>, <i class="farg">AUTH_TOOWEAK</i>).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">svcraw_create</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
This routine creates a toy RPC service transport, to which it returns a pointer. The transport is really a buffer within the process's address space, so the corresponding RPC client should live in the same address space; see <b class="fname">clntraw_create</b>(). This routine allows simulation of RPC and acquisition of RPC overheads (such as round trip times), without any kernel interference. This routine returns <span class="define">NULL</span> if it fails.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">svctcp_create</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
This routine creates a TCP/IP-based RPC service transport, to which it returns a pointer. The transport is associated with the socket <i class="farg">sock</i>, which may be <span class="define">RPC_ANYSOCK</span>, in which case a new socket is created. If the socket is not bound to a local TCP port, then this routine binds it to an arbitrary port. Upon completion, <i class="farg">xprt-&gt;xp_sock</i> is the transport's socket descriptor, and <i class="farg">xprt-&gt;xp_port</i> is the transport's port number. This routine returns <span class="define">NULL</span> if it fails. Since TCP-based RPC uses buffered I/O , users may specify the size of buffers; values of zero choose suitable defaults.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">svcfd_create</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Create a service on top of any open descriptor. Typically, this descriptor is a connected socket for a stream protocol such as TCP. <i class="farg">sendsize</i> and <i class="farg">recvsize</i> indicate sizes for the send and receive buffers. If they are zero, a reasonable default is chosen.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">svcudp_bufcreate</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
This routine creates a UDP/IP-based RPC service transport, to which it returns a pointer. The transport is associated with the socket <i class="farg">sock</i>, which may be <span class="define">RPC_ANYSOCK</span>, in which case a new socket is created. If the socket is not bound to a local UDP port, then this routine binds it to an arbitrary port. Upon completion, <i class="farg">xprt-&gt;xp_sock</i> is the transport's socket descriptor, and <i class="farg">xprt-&gt;xp_port</i> is the transport's port number. This routine returns <span class="define">NULL</span> if it fails.<p>
This allows the user to specify the maximum packet size for sending and receiving UDP-based RPC messages.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">svcudp_create</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
This acts as <b class="fname">svcudp_bufcreate</b>(<i class="farg">with</i>) predefined sizes for the maximum packet sizes.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdr_accepted_reply</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Used for encoding RPC reply messages. This routine is useful for users who wish to generate RPC-style messages without using the RPC package.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdr_authunix_parms</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Used for describing UNIX credentials. This routine is useful for users who wish to generate these credentials without using the RPC authentication package.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdr_callhdr</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Used for describing RPC call header messages. This routine is useful for users who wish to generate RPC-style messages without using the RPC package.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdr_callmsg</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Used for describing RPC call messages. This routine is useful for users who wish to generate RPC-style messages without using the RPC package.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdr_opaque_auth</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Used for describing RPC authentication information messages. This routine is useful for users who wish to generate RPC-style messages without using the RPC package.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdr_pmap</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Used for describing parameters to various <a class="link-man" href="../8/rpcbind">rpcbind(8)</a> procedures, externally. This routine is useful for users who wish to generate these parameters without using the <span class="emph">pmap</span> interface.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdr_pmaplist</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Used for describing a list of port mappings, externally. This routine is useful for users who wish to generate these parameters without using the <span class="emph">pmap</span> interface.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdr_rejected_reply</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Used for describing RPC reply messages. This routine is useful for users who wish to generate RPC-style messages without using the RPC package.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xdr_replymsg</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Used for describing RPC reply messages. This routine is useful for users who wish to generate RPC-style messages without using the RPC package.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xprt_register</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
After RPC service transport handles are created, they should register themselves with the RPC service package. This routine modifies the global variable <b class="var">svc_fds</b>. Service implementors usually do not need this routine.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="fname">xprt_unregister</b>()</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Before an RPC service transport handle is destroyed, it should unregister itself with the RPC service package. This routine modifies the global variable <b class="var">svc_fds</b>. Service implementors usually do not need this routine.</dd>
</dl>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../3/xdr">xdr(3)</a><p>
The following manuals:<p>
<span class="ref"><i class="ref-book">Remote Procedure Calls: Protocol Specification</i>.</span><p>
<span class="ref"><i class="ref-book">Remote Procedure Call Programming Guide</i>.</span><p>
<span class="ref"><i class="ref-book">rpcgen Programming Guide</i>.</span><p>
<p>
<span class="ref"><span class="ref-auth">Sun Microsystems, Inc., USC-ISI</span>, <span class="ref-title">RPC: Remote Procedure Call Protocol Specification</span>, <i class="ref-jrnl">RFC</i>, <span class="ref-vol">1050</span>.</span></div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
December 12, 2008</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

