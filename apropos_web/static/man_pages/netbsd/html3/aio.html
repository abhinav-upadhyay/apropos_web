<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/../4/strict.dtd">
>
<head>
<meta http-equiv="Content-Type" content="te../; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
AIO(3)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
AIO(3)</td>
<td class="head-vol" align="center">
Library Functions Manual</td>
<td class="head-rtitle" align="right">
AIO(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">aio</b> &#8212; <span class="desc">asynchronous I/O (REALTIME)</span></div>
<div class="section">
<h1 id="x4c494252415259">LIBRARY</h1> <span class="lib">POSIX Real&#45;time Library (librt, &#45;lrt)</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">aio.h</a>&gt;</b></div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The IEEE Std 1003.1-2001 (&#8220;POSIX.1&#8221;) standard defines an interface for asynchronous input and output. Although in <span class="unix">NetBSD</span> this is provided as part of the <span class="lib">POSIX Real&#45;time Library (librt, &#45;lrt)</span>, the implementation largely resides in the kernel.<div class="subsection">
<h2 id="x526174696f6e616c65">Rationale</h2> The rationale can be roughly summarized with the following points.<ol style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 2.00ex;" class="list list-enum">
<li class="list-enum" style="margin-top: 1.00em;">
To increase performance by providing a mechanism to carry out I/O without blocking. Theoretically, if I/O would never block, neither at the software nor at the hardware level, the overhead of I/O would become zero, and processes would no longer be I/O bound.</li>
<li class="list-enum" style="margin-top: 1.00em;">
To segregate the different I/O operations into logically distinctive procedures. Unlike with the standard <a class="link-man" href="../3/stdio">stdio(3)</a>, the <b class="name">aio</b> interface separates queuing and submitting I/O operations to the kernel, and receiving notifications of operation completion from the kernel.</li>
<li class="list-enum" style="margin-top: 1.00em;">
To provide an uniform and standardized framework for asynchronous I/O. For instance, <b class="name">aio</b> avoids the need for (and the overhead of) extra worker threads sometimes used to perform asynchronous I/O.</li>
</ol>
</div>
<div class="subsection">
<h2 id="x4173796e6368726f6e6f757320492f4f20436f6e74726f6c20426c6f636b">Asynchronous I/O Control Block</h2> The Asynchronous I/O Control Block is the basic operational unit behind <b class="name">aio</b>. This is required since an arbitrary number of operations can be started at once, and because each operation can be either input or output. This block is represented by the <span class="emph">aiocb</span> structure, which is defined in the <b class="includes">&lt;<a class="link-includes">aio.h</a>&gt;</b> header. The following fields are available for user applications:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
off_t		 aio_offset; 
void		*aio_buf; 
size_t		 aio_nbytes; 
int		 aio_fildes; 
int		 aio_lio_opcode; 
int		 aio_reqprio; 
struct sigevent	 aio_sigevent;</pre>
<p>
The fields are:<ol style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-enum">
<li class="list-enum" style="margin-top: 1.00em;">
The <b class="var">aio_offset</b> specifies the implicit file offset at which the I/O operations are performed. This cannot be expected to be the actual read/write offset of the file descriptor.</li>
<li class="list-enum" style="margin-top: 1.00em;">
The <b class="var">aio_buf</b> member is a pointer to the buffer to which data is going to be written or to which the read operation stores data.</li>
<li class="list-enum" style="margin-top: 1.00em;">
The <b class="var">aio_nbytes</b> specifies the length of <b class="var">aio_buf</b>.</li>
<li class="list-enum" style="margin-top: 1.00em;">
The <b class="var">aio_fildes</b> specifies the used file descriptor.</li>
<li class="list-enum" style="margin-top: 1.00em;">
The <b class="var">aio_lio_opcode</b> is used by the <b class="fname">lio_listio</b>() function to initialize a list of I/O requests with a single call.</li>
<li class="list-enum" style="margin-top: 1.00em;">
The <b class="var">aio_reqprio</b> member can be used to lower the scheduling priority of an <b class="name">aio</b> operation. This is only available if <span class="define">_POSIX_PRIORITIZED_IO</span> and <span class="define">_POSIX_PRIORITY_SCHEDULING</span> are defined, and the associated file descriptor supports it.</li>
<li class="list-enum" style="margin-top: 1.00em;">
The <b class="var">aio_sigevent</b> member is used to specify how the calling process is notified once an <b class="name">aio</b> operation completes.</li>
</ol>
<p>
The members <b class="var">aio_buf</b>, <b class="var">aio_fildes</b>, and <b class="var">aio_nbytes</b> are conceptually similar to the parameters &#8216;buf&#8217;, &#8216;fildes&#8217;, and &#8216;nbytes&#8217; used in the standard <a class="link-man" href="../2/read">read(2)</a> and <a class="link-man" href="../2/write">write(2)</a> functions. For example, the caller can read <b class="var">aio_nbytes</b> from a file associated with the file descriptor <b class="var">aio_fildes</b> into the buffer <b class="var">aio_buf</b>. All appropriate fields should be initialized by the caller before <b class="fname">aio_read</b>() or <b class="fname">aio_write</b>() is called.</div>
<div class="subsection">
<h2 id="x46696c65204f666673657473">File Offsets</h2> Asynchronous I/O operations are not strictly sequential; operations are carried out in arbitrary order and more than one operation for one file descriptor can be started. The requested read or write operation starts from the absolute position specified by <b class="var">aio_offset</b>, as if <a class="link-man" href="../2/lseek">lseek(2)</a> would have been called with <span class="define">SEEK_SET</span> immediately prior to the operation. The POSIX standard does not specify what happens after an <b class="name">aio</b> operation has been successfully completed. Depending on the implementation, the actual file offset may or may not be updated.</div>
<div class="subsection">
<h2 id="x4572726f727320616e6420436f6d706c6574696f6e">Errors and Completion</h2> Asynchronous I/O operations are said to be complete when:<ul style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 2.00ex;" class="list list-bul">
<li class="list-bul" style="margin-top: 1.00em;">
An error is detected.</li>
<li class="list-bul" style="margin-top: 1.00em;">
The I/O transfer is performed successfully.</li>
<li class="list-bul" style="margin-top: 1.00em;">
The operation is canceled.</li>
</ul>
<p>
If an error condition is detected that prevents an operation from being started, the request is not enqueued. In this case the read and write functions, <b class="fname">aio_read</b>() and <b class="fname">aio_write</b>(), return immediately, setting the global <b class="var">errno</b> to indicate the cause of the error.<p>
After an operation has been successfully enqueued, <b class="fname">aio_error</b>() and <b class="fname">aio_return</b>() must be used to determine the status of the operation and to determine any error conditions. This includes the conditions reported by the standard <a class="link-man" href="../2/read">read(2)</a>, <a class="link-man" href="../2/write">write(2)</a>, and <a class="link-man" href="../2/fsync">fsync(2)</a>. The request remains enqueued and consumes process and system resources until <b class="fname">aio_return</b>() is called.</div>
<div class="subsection">
<h2 id="x57616974696e6720666f7220436f6d706c6574696f6e">Waiting for Completion</h2> The <b class="name">aio</b> interface supports both polling and notification models. The first can be implemented by simply repeatedly calling the <b class="fname">aio_error</b>() function to test the status of an operation. Once the operation has completed, <b class="fname">aio_return</b>() is used to free the <b class="var">aiocb</b> structure for re-use.<p>
The notification model is implemented by using the <b class="var">aio_sigevent</b> member of the Asynchronous I/O Control Block. The operational model and the used structure are described in <a class="link-man" href="../3/sigevent">sigevent(3)</a>.<p>
The <b class="fname">aio_suspend</b>() function can be used to wait for the completion of one or more operations. It is possible to set a timeout so that the process can continue the execution and take recovery actions if the <b class="name">aio</b> operations do not complete as expected.</div>
<div class="subsection">
<h2 id="x43616e63656c6c6174696f6e20616e642053796e6368726f6e697a6174696f6e">Cancellation and Synchronization</h2> The <b class="fname">aio_cancel</b>() function can be used to request cancellation of an asynchronous I/O operation. Note however that not all of them can be canceled. The same <b class="var">aiocb</b> used to start the operation may be used as a handle for identification. It is also possible to request cancellation of all operations pending for a file.<p>
Comparable to <a class="link-man" href="../2/fsync">fsync(2)</a>, the <b class="fname">aio_fsync</b>() function can be used to synchronize the contents of permanent storage when multiple asynchronous I/O operations are outstanding for the file or device. The synchronization operation includes only those requests that have already been successfully enqueued.</div>
</div>
<div class="section">
<h1 id="x46554e4354494f4e53">FUNCTIONS</h1> The following functions comprise the API of the <b class="name">aio</b> interface:<table style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-col">
<col style="width: 12.00ex;">
<col style="min-width: 3.00ex;">
<tbody>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">Function</span></td>
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">Description</span></td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<a class="link-man" href="../3/aio_cancel">aio_cancel(3)</a></td>
<td class="list-col" style="margin-top: 1.00em;">
cancel an outstanding asynchronous I/O operation</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<a class="link-man" href="../3/aio_error">aio_error(3)</a></td>
<td class="list-col" style="margin-top: 1.00em;">
retrieve error status of asynchronous I/O operation</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<a class="link-man" href="../3/aio_fsync">aio_fsync(3)</a></td>
<td class="list-col" style="margin-top: 1.00em;">
asynchronous data synchronization of file</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<a class="link-man" href="../3/aio_read">aio_read(3)</a></td>
<td class="list-col" style="margin-top: 1.00em;">
asynchronous read from a file</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<a class="link-man" href="../3/aio_return">aio_return(3)</a></td>
<td class="list-col" style="margin-top: 1.00em;">
get return status of asynchronous I/O operation</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<a class="link-man" href="../3/aio_suspend">aio_suspend(3)</a></td>
<td class="list-col" style="margin-top: 1.00em;">
suspend until operations or timeout complete</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<a class="link-man" href="../3/aio_write">aio_write(3)</a></td>
<td class="list-col" style="margin-top: 1.00em;">
asynchronous write to a file</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<a class="link-man" href="../3/lio_listio">lio_listio(3)</a></td>
<td class="list-col" style="margin-top: 1.00em;">
list directed I/O</td>
</tr>
</tbody>
</table>
</div>
<div class="section">
<h1 id="x434f4d5041544942494c495459">COMPATIBILITY</h1> Unfortunately, the POSIX asynchronous I/O implementations vary slightly. Some implementations provide a slightly different API with possible extensions. For instance, the <span class="unix">FreeBSD</span> implementation uses a function &#8216;<b class="fname">aio_waitcomplete</b>()&#8217; to wait for the next completion of an <b class="name">aio</b> request.</div>
<div class="section">
<h1 id="x5354414e4441524453">STANDARDS</h1> The <b class="name">aio</b> interface is expected to conform to the IEEE Std 1003.1-2001 (&#8220;POSIX.1&#8221;) standard.</div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The <b class="name">aio</b> interface first appeared in <span class="unix">NetBSD&#160;5.0</span>.</div>
<div class="section">
<h1 id="x43415645415453">CAVEATS</h1> Few limitations can be mentioned:<ul style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-bul">
<li class="list-bul" style="margin-top: 1.00em;">
Undefined behavior results if simultaneous asynchronous operations use the same Asynchronous I/O Control Block.</li>
<li class="list-bul" style="margin-top: 1.00em;">
When an asynchronous read operation is outstanding, undefined behavior may follow if the contents of <b class="var">aiocb</b> are altered, or if memory associated with the structure, or the <b class="var">aio_buf</b> buffer, is deallocated.</li>
</ul>
</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
May 19, 2010</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
<>

