<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/../4/strict.dtd">
>
<head>
<meta http-equiv="Content-Type" content="te../; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
PRINTF(3)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
PRINTF(3)</td>
<td class="head-vol" align="center">
Library Functions Manual</td>
<td class="head-rtitle" align="right">
PRINTF(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">printf</b>, <b class="name">fprintf</b>, <b class="name">dprintf</b> <b class="name">sprintf</b>, <b class="name">snprintf</b>, <b class="name">snprintf_ss</b>, <b class="name">asprintf</b>, <b class="name">vprintf</b>, <b class="name">vfprintf</b>, <b class="name">vsprintf</b>, <b class="name">vdprintf</b>, <b class="name">vsnprintf</b>, <b class="name">vsnprintf_ss</b>, <b class="name">vasprintf</b> &#8212; <span class="desc">formatted output conversion</span></div>
<div class="section">
<h1 id="x4c494252415259">LIBRARY</h1> <span class="lib">Standard C Library (libc, &#45;lc)</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">stdio.h</a>&gt;</b><p>
<i class="ftype">int</i><br>
<b class="fname">printf</b>(<i class="farg" style="white-space:nowrap;">const char * restrict format</i>, <i class="farg" style="white-space:nowrap;">...</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">fprintf</b>(<i class="farg" style="white-space:nowrap;">FILE * restrict stream</i>, <i class="farg" style="white-space:nowrap;">const char * restrict format</i>, <i class="farg" style="white-space:nowrap;">...</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">dprintf</b>(<i class="farg" style="white-space:nowrap;">int fd</i>, <i class="farg" style="white-space:nowrap;">const char * restrict format</i>, <i class="farg" style="white-space:nowrap;">...</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">sprintf</b>(<i class="farg" style="white-space:nowrap;">char * restrict str</i>, <i class="farg" style="white-space:nowrap;">const char * restrict format</i>, <i class="farg" style="white-space:nowrap;">...</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">snprintf</b>(<i class="farg" style="white-space:nowrap;">char * restrict str</i>, <i class="farg" style="white-space:nowrap;">size_t size</i>, <i class="farg" style="white-space:nowrap;">const char * restrict format</i>, <i class="farg" style="white-space:nowrap;">...</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">snprintf_ss</b>(<i class="farg" style="white-space:nowrap;">char * restrict str</i>, <i class="farg" style="white-space:nowrap;">size_t size</i>, <i class="farg" style="white-space:nowrap;">const char * restrict format</i>, <i class="farg" style="white-space:nowrap;">...</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">asprintf</b>(<i class="farg" style="white-space:nowrap;">char ** restrict ret</i>, <i class="farg" style="white-space:nowrap;">const char * restrict format</i>, <i class="farg" style="white-space:nowrap;">...</i>);<p>
<b class="includes">#include &lt;<a class="link-includes">stdarg.h</a>&gt;</b><p>
<i class="ftype">int</i><br>
<b class="fname">vprintf</b>(<i class="farg" style="white-space:nowrap;">const char * restrict format</i>, <i class="farg" style="white-space:nowrap;">va_list ap</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">vfprintf</b>(<i class="farg" style="white-space:nowrap;">FILE * restrict stream</i>, <i class="farg" style="white-space:nowrap;">const char * restrict format</i>, <i class="farg" style="white-space:nowrap;">va_list ap</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">vsprintf</b>(<i class="farg" style="white-space:nowrap;">char * restrict str</i>, <i class="farg" style="white-space:nowrap;">const char * restrict format</i>, <i class="farg" style="white-space:nowrap;">va_list ap</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">vdprintf</b>(<i class="farg" style="white-space:nowrap;">int fd</i>, <i class="farg" style="white-space:nowrap;">const char * restrict format</i>, <i class="farg" style="white-space:nowrap;">va_list ap</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">vsnprintf</b>(<i class="farg" style="white-space:nowrap;">char * restrict str</i>, <i class="farg" style="white-space:nowrap;">size_t size</i>, <i class="farg" style="white-space:nowrap;">const char * restrict format</i>, <i class="farg" style="white-space:nowrap;">va_list ap</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">vsnprintf_ss</b>(<i class="farg" style="white-space:nowrap;">char * restrict str</i>, <i class="farg" style="white-space:nowrap;">size_t size</i>, <i class="farg" style="white-space:nowrap;">const char * restrict format</i>, <i class="farg" style="white-space:nowrap;">va_list ap</i>);<p>
<i class="ftype">int</i><br>
<b class="fname">vasprintf</b>(<i class="farg" style="white-space:nowrap;">char ** restrict ret</i>, <i class="farg" style="white-space:nowrap;">const char * restrict format</i>, <i class="farg" style="white-space:nowrap;">va_list ap</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <b class="fname">printf</b>() family of functions produces output according to a <i class="farg">format</i> as described below. The <b class="fname">printf</b>() and <b class="fname">vprintf</b>() functions write output to <span class="emph">stdout</span>, the standard output stream; <b class="fname">fprintf</b>() and <b class="fname">vfprintf</b>() write output to the given output <i class="farg">stream</i>; <b class="fname">dprintf</b>() and <b class="fname">vdprintf</b>() write output to the given file descriptor <i class="farg">fd</i>; <b class="fname">sprintf</b>(), <b class="fname">snprintf</b>(), <b class="fname">snprintf_ss</b>(), <b class="fname">vsprintf</b>(), <b class="fname">vsnprintf</b>(), and <b class="fname">vsnprintf_ss</b>() write to the character string <i class="farg">str</i>; and <b class="fname">asprintf</b>() and <b class="fname">vasprintf</b>() write to a dynamically allocated string that is stored in <i class="farg">ret</i>.<p>
These functions write the output under the control of a <i class="farg">format</i> string that specifies how subsequent arguments (or arguments accessed via the variable-length argument facilities of <a class="link-man" href="../3/stdarg">stdarg(3)</a>) are converted for output.<p>
<b class="fname">snprintf_ss</b>() and <b class="fname">vsnprintf_ss</b>() are signal-safe standalone versions that do not handle floating point formats, positional arguments, and wide characters.<p>
<b class="fname">asprintf</b>() and <b class="fname">vasprintf</b>() return a pointer to a buffer sufficiently large to hold the string in the <i class="farg">ret</i> argument. This pointer should be passed to <a class="link-man" href="../3/free">free(3)</a> to release the allocated storage when it is no longer needed. If sufficient space cannot be allocated, these functions will return &#45;1 and set <i class="farg">ret</i> to be a <span class="define">NULL</span> pointer. Please note that these functions are not standardized, and not all implementations can be assumed to set the <i class="farg">ret</i> argument to <span class="define">NULL</span> on error. It is more portable to check for a return value of &#45;1 instead.<p>
<b class="fname">snprintf</b>(), <b class="fname">vsnprintf</b>(), and <b class="fname">vsnprintf_ss</b>() will write at most <i class="farg">size</i>&#45;1 of the characters printed into the output string (the <i class="farg">size</i>'th character then gets the terminating &#8216;<code class="lit">&#92;0</code>&#8217;); if the return value is greater than or equal to the <i class="farg">size</i> argument, the string was too short and some of the printed characters were discarded. If <i class="farg">size</i> is zero, nothing is written and <i class="farg">str</i> may be a <span class="define">NULL</span> pointer.<p>
<b class="fname">sprintf</b>() and <b class="fname">vsprintf</b>() effectively assume an infinite <i class="farg">size</i>.<p>
The format string is composed of zero or more directives: ordinary characters (not <b class="flag">%</b>), which are copied unchanged to the output stream; and conversion specifications, each of which results in fetching zero or more subsequent arguments. Each conversion specification is introduced by the character <b class="flag">%</b>. The arguments must correspond properly (after type promotion) with the conversion specifier. After the <b class="flag">%</b>, the following appear in sequence:<ul style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-bul">
<li class="list-bul" style="margin-top: 1.00em;">
An optional field, consisting of a decimal digit string followed by a <b class="flag">$</b>, specifying the next argument to access. If this field is not provided, the argument following the last argument accessed will be used. Arguments are numbered starting at <b class="flag">1</b>. If unaccessed arguments in the format string are interspersed with ones that are accessed the results will be indeterminate.</li>
<li class="list-bul" style="margin-top: 1.00em;">
Zero or more of the following flags:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
&#8216;<b class="flag">#</b>&#8217;</dt>
<dd class="list-tag" style="margin-left: 16.00ex;">
The value should be converted to an &#8220;alternate form&#8221;. For <b class="flag">c</b>, <b class="flag">d</b>, <b class="flag">i</b>, <b class="flag">n</b>, <b class="flag">p</b>, <b class="flag">s</b>, and <b class="flag">u</b> conversions, this option has no effect. For <b class="flag">o</b> conversions, the precision of the number is increased to force the first character of the output string to a zero (except if a zero value is printed with an explicit precision of zero). For <b class="flag">x</b> and <b class="flag">X</b> conversions, a non-zero result has the string &#8216;<code class="lit">0x</code>&#8217; (or &#8216;<code class="lit">0X</code>&#8217; for <b class="flag">X</b> conversions) prepended to it. For <b class="flag">a</b>, <b class="flag">A</b>, <b class="flag">e</b>, <b class="flag">E</b>, <b class="flag">f</b>, <b class="flag">F</b>, <b class="flag">g</b>, and <b class="flag">G</b> conversions, the result will always contain a decimal point, even if no digits follow it (normally, a decimal point appears in the results of those conversions only if a digit follows). For <b class="flag">g</b> and <b class="flag">G</b> conversions, trailing zeros are not removed from the result as they would otherwise be.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#8216;<b class="flag">0</b>&#8217; (zero)</dt>
<dd class="list-tag" style="margin-left: 16.00ex;">
Zero padding. For all conversions except <b class="flag">n</b>, the converted value is padded on the left with zeros rather than blanks. If a precision is given with a numeric conversion (<b class="flag">d</b>, <b class="flag">i</b>, <b class="flag">o</b>, <b class="flag">u</b>, <b class="flag">i</b>, <b class="flag">x</b>, and <b class="flag">X</b>), the <b class="flag">0</b> flag is ignored.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#8216;<b class="flag">&#45;</b>&#8217;</dt>
<dd class="list-tag" style="margin-left: 16.00ex;">
A negative field width flag; the converted value is to be left adjusted on the field boundary. Except for <b class="flag">n</b> conversions, the converted value is padded on the right with blanks, rather than on the left with blanks or zeros. A &#8216;<b class="flag">&#45;</b>&#8217; overrides a &#8216;<b class="flag">0</b>&#8217; if both are given.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#8216;&#160;&#8217; (space)</dt>
<dd class="list-tag" style="margin-left: 16.00ex;">
A blank should be left before a positive number produced by a signed conversion (<b class="flag">a</b>, <b class="flag">A</b> <b class="flag">d</b>, <b class="flag">e</b>, <b class="flag">E</b>, <b class="flag">f</b>, <b class="flag">F</b>, <b class="flag">g</b>, <b class="flag">G</b>, or <b class="flag">i</b>).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#8216;<b class="flag">+</b>&#8217;</dt>
<dd class="list-tag" style="margin-left: 16.00ex;">
A sign must always be placed before a number produced by a signed conversion. A &#8216;<b class="flag">+</b>&#8217; overrides a space if both are used.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#8216;<b class="flag">'</b>&#8217;</dt>
<dd class="list-tag" style="margin-left: 16.00ex;">
Decimal conversions (<b class="flag">d</b>, <b class="flag">u</b>, or <b class="flag">i</b>) or the integral portion of a floating point conversion (<b class="flag">f</b> or <b class="flag">F</b>) should be grouped and separated by thousands using the non-monetary separator returned by <a class="link-man" href="../3/localeconv">localeconv(3)</a>.</dd>
</dl>
</li>
<li class="list-bul" style="margin-top: 1.00em;">
An optional decimal digit string specifying a minimum field width. If the converted value has fewer characters than the field width, it will be padded with spaces on the left (or right, if the left-adjustment flag has been given) to fill out the field width.</li>
<li class="list-bul" style="margin-top: 1.00em;">
An optional precision, in the form of a period &#8216;<b class="flag">.</b>&#8217; followed by an optional digit string. If the digit string is omitted, the precision is taken as zero. This gives the minimum number of digits to appear for <b class="flag">d</b>, <b class="flag">i</b>, <b class="flag">o</b>, <b class="flag">u</b>, <b class="flag">x</b>, and <b class="flag">X</b> conversions, the number of digits to appear after the decimal-point for <b class="flag">a</b>, <b class="flag">A</b>, <b class="flag">e</b>, <b class="flag">E</b>, <b class="flag">f</b>, and <b class="flag">F</b> conversions, the maximum number of significant digits for <b class="flag">g</b> and <b class="flag">G</b> conversions, or the maximum number of characters to be printed from a string for <b class="flag">s</b> conversions.</li>
<li class="list-bul" style="margin-top: 1.00em;">
An optional length modifier, that specifies the size of the argument. The following length modifiers are valid for the <b class="flag">d</b>, <b class="flag">i</b>, <b class="flag">n</b>, <b class="flag">o</b>, <b class="flag">u</b>, <b class="flag">x</b>, or <b class="flag">X</b> conversion:<table style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-col">
<col style="width: 21.00ex;">
<col style="width: 15.00ex;">
<col style="width: 22.00ex;">
<col style="min-width: 15.00ex;">
<tbody>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">Modifier</span></td>
<td class="list-col" style="margin-top: 1.00em;">
<b class="flag">d</b>, <b class="flag">i</b></td>
<td class="list-col" style="margin-top: 1.00em;">
<b class="flag">o</b>, <b class="flag">u</b>, <b class="flag">x</b>, <b class="flag">X</b></td>
<td class="list-col" style="margin-top: 1.00em;">
<b class="flag">n</b></td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<b class="flag">hh</b></td>
<td class="list-col" style="margin-top: 1.00em;">
<span class="type">signed char</span></td>
<td class="list-col" style="margin-top: 1.00em;">
<span class="type">unsigned char</span></td>
<td class="list-col" style="margin-top: 1.00em;">
<span class="type">signed char *</span></td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<b class="flag">h</b></td>
<td class="list-col" style="margin-top: 1.00em;">
<span class="type">short</span></td>
<td class="list-col" style="margin-top: 1.00em;">
<span class="type">unsigned short</span></td>
<td class="list-col" style="margin-top: 1.00em;">
<span class="type">short *</span></td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<b class="flag">l</b> (ell)</td>
<td class="list-col" style="margin-top: 1.00em;">
<span class="type">long</span></td>
<td class="list-col" style="margin-top: 1.00em;">
<span class="type">unsigned long</span></td>
<td class="list-col" style="margin-top: 1.00em;">
<span class="type">long *</span></td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<b class="flag">ll</b> (ell ell)</td>
<td class="list-col" style="margin-top: 1.00em;">
<span class="type">long long</span></td>
<td class="list-col" style="margin-top: 1.00em;">
<span class="type">unsigned long long</span></td>
<td class="list-col" style="margin-top: 1.00em;">
<span class="type">long long *</span></td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<b class="flag">j</b></td>
<td class="list-col" style="margin-top: 1.00em;">
<span class="type">intmax_t</span></td>
<td class="list-col" style="margin-top: 1.00em;">
<span class="type">uintmax_t</span></td>
<td class="list-col" style="margin-top: 1.00em;">
<span class="type">intmax_t *</span></td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<b class="flag">t</b></td>
<td class="list-col" style="margin-top: 1.00em;">
<span class="type">ptrdiff_t</span></td>
<td class="list-col" style="margin-top: 1.00em;">
(see note)</td>
<td class="list-col" style="margin-top: 1.00em;">
<span class="type">ptrdiff_t *</span></td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<b class="flag">z</b></td>
<td class="list-col" style="margin-top: 1.00em;">
(see note)</td>
<td class="list-col" style="margin-top: 1.00em;">
<span class="type">size_t</span></td>
<td class="list-col" style="margin-top: 1.00em;">
(see note)</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<b class="flag">q</b> <span class="emph">(deprecated)</span></td>
<td class="list-col" style="margin-top: 1.00em;">
<span class="type">quad_t</span></td>
<td class="list-col" style="margin-top: 1.00em;">
<span class="type">u_quad_t</span></td>
<td class="list-col" style="margin-top: 1.00em;">
<span class="type">quad_t *</span></td>
</tr>
</tbody>
</table>
<p>
Note: the <b class="flag">t</b> modifier, when applied to a <b class="flag">o</b>, <b class="flag">u</b>, <b class="flag">x</b>, or <b class="flag">X</b> conversion, indicates that the argument is of an unsigned type equivalent in size to a <span class="type">ptrdiff_t</span>. The <b class="flag">z</b> modifier, when applied to a <b class="flag">d</b> or <b class="flag">i</b> conversion, indicates that the argument is of a signed type equivalent in size to a <span class="type">size_t</span>. Similarly, when applied to an <b class="flag">n</b> conversion, it indicates that the argument is a pointer to a signed type equivalent in size to a <span class="type">size_t</span>.<p>
Note: if the standard integer types described in <a class="link-man" href="../3/stdint">stdint(3)</a> are used, it is recommended that the predefined format string specifier macros are used when possible. These are further described in <a class="link-man" href="../3/inttypes">inttypes(3)</a>.<p>
The following length modifier is valid for the <b class="flag">a</b>, <b class="flag">A</b>, <b class="flag">e</b>, <b class="flag">E</b>, <b class="flag">f</b>, <b class="flag">F</b>, <b class="flag">g</b>, or <b class="flag">G</b> conversion:<table style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-col">
<col style="width: 12.00ex;">
<col style="min-width: 33.00ex;">
<tbody>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">Modifier</span></td>
<td class="list-col" style="margin-top: 1.00em;">
<b class="flag">a</b>, <b class="flag">A</b>, <b class="flag">e</b>, <b class="flag">E</b>, <b class="flag">f</b>, <b class="flag">F</b>, <b class="flag">g</b>, <b class="flag">G</b></td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<b class="flag">l</b> (ell)</td>
<td class="list-col" style="margin-top: 1.00em;">
<span class="type">double</span> (ignored, same behavior as without it)</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<b class="flag">L</b></td>
<td class="list-col" style="margin-top: 1.00em;">
<span class="type">long double</span></td>
</tr>
</tbody>
</table>
<p>
The following length modifier is valid for the <b class="flag">c</b> or <b class="flag">s</b> conversion:<table style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-col">
<col style="width: 12.00ex;">
<col style="width: 10.00ex;">
<col style="min-width: 13.00ex;">
<tbody>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">Modifier</span></td>
<td class="list-col" style="margin-top: 1.00em;">
<b class="flag">c</b></td>
<td class="list-col" style="margin-top: 1.00em;">
<b class="flag">s</b></td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<b class="flag">l</b> (ell)</td>
<td class="list-col" style="margin-top: 1.00em;">
<span class="type">wint_t</span></td>
<td class="list-col" style="margin-top: 1.00em;">
<span class="type">wchar_t *</span></td>
</tr>
</tbody>
</table>
</li>
<li class="list-bul" style="margin-top: 1.00em;">
A character that specifies the type of conversion to be applied.</li>
</ul>
<p>
A field width or precision, or both, may be indicated by an asterisk &#8216;<code class="lit">*</code>&#8217; or an asterisk followed by one or more decimal digits and a &#8216;<code class="lit">$</code>&#8217; instead of a digit string. In this case, an <span class="type">int</span> argument supplies the field width or precision. A negative field width is treated as a left adjustment flag followed by a positive field width; a negative precision is treated as though it were missing. If a single format directive mixes positional (<code class="lit">nn$</code>) and non-positional arguments, the results are undefined.<p>
The conversion specifiers and their meanings are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">diouxX</b></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
The <span class="type">int</span> (or appropriate variant) argument is converted to signed decimal (<b class="flag">d</b> and <b class="flag">i</b>), unsigned octal (<b class="flag">o</b>), unsigned decimal (<b class="flag">u</b>), or unsigned hexadecimal (<b class="flag">x</b> and <b class="flag">X</b>) notation. The letters &#8220;<code class="lit">abcdef</code>&#8221; are used for <b class="flag">x</b> conversions; the letters &#8220;<code class="lit">ABCDEF</code>&#8221; are used for <b class="flag">X</b> conversions. The precision, if any, gives the minimum number of digits that must appear; if the converted value requires fewer digits, it is padded on the left with zeros.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">DOU</b></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
The <span class="type">long int</span> argument is converted to signed decimal, unsigned octal, or unsigned decimal, as if the format had been <b class="flag">ld</b>, <b class="flag">lo</b>, or <b class="flag">lu</b> respectively. These conversion characters are deprecated, and will eventually disappear.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">eE</b></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
The <span class="type">double</span> argument is rounded and converted in the style &#91;<span class="opt">&#45;</span>&#93;<i class="arg">d</i><code class="lit">.</code><i class="arg">ddd</i><code class="lit">e&#177;</code><i class="arg">dd</i> where there is one digit before the decimal-point character and the number of digits after it is equal to the precision; if the precision is missing, it is taken as 6; if the precision is zero, no decimal-point character appears. An <b class="flag">E</b> conversion uses the letter &#8216;<code class="lit">E</code>&#8217; (rather than &#8216;<code class="lit">e</code>&#8217;) to introduce the exponent. The exponent always contains at least two digits; if the value is zero, the exponent is 00.<p>
For <b class="flag">a</b>, <b class="flag">A</b>, <b class="flag">e</b>, <b class="flag">E</b>, <b class="flag">f</b>, <b class="flag">F</b>, <b class="flag">g</b>, and <b class="flag">G</b> conversions, positive and negative infinity are represented as <code class="lit">inf</code> and <code class="lit">-inf</code> respectively when using the lowercase conversion character, and <code class="lit">INF</code> and <code class="lit">-INF</code> respectively when using the uppercase conversion character. Similarly, NaN is represented as <code class="lit">nan</code> when using the lowercase conversion, and <code class="lit">NAN</code> when using the uppercase conversion.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">fF</b></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
The <span class="type">double</span> argument is rounded and converted to decimal notation in the style &#91;<span class="opt">&#45;</span>&#93;<i class="arg">ddd</i><code class="lit">.</code><i class="arg">ddd</i>, where the number of digits after the decimal-point character is equal to the precision specification. If the precision is missing, it is taken as 6; if the precision is explicitly zero, no decimal-point character appears. If a decimal point appears, at least one digit appears before it.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">gG</b></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
The <span class="type">double</span> argument is converted in style <b class="flag">f</b> or <b class="flag">e</b> (or in style <b class="flag">F</b> or <b class="flag">E</b> for <b class="flag">G</b> conversions). The precision specifies the number of significant digits. If the precision is missing, 6 digits are given; if the precision is zero, it is treated as 1. Style <b class="flag">e</b> is used if the exponent from its conversion is less than &#45;4 or greater than or equal to the precision. Trailing zeros are removed from the fractional part of the result; a decimal point appears only if it is followed by at least one digit.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">aA</b></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
The <span class="type">double</span> argument is rounded and converted to hexadecimal notation in the style &#91;<span class="opt">&#45;</span>&#93;<code class="lit">0x</code><i class="arg">h</i><code class="lit">.</code><i class="arg">hhhp</i>&#91;<span class="opt">&#177;</span>&#93;<i class="arg">d</i>, where the number of digits after the hexadecimal-point character is equal to the precision specification. If the precision is missing, it is taken as enough to represent the floating-point number exactly, and no rounding occurs. If the precision is zero, no hexadecimal-point character appears. The <b class="flag">p</b> is a literal character &#8216;<code class="lit">p</code>&#8217;, and the exponent consists of a positive or negative sign followed by a decimal number representing an exponent of 2. The <b class="flag">A</b> conversion uses the prefix &#8220;<code class="lit">0X</code>&#8221; (rather than &#8220;<code class="lit">0x</code>&#8221;), the letters &#8220;<code class="lit">ABCDEF</code>&#8221; (rather than &#8220;<code class="lit">abcdef</code>&#8221;) to represent the hex digits, and the letter &#8216;<code class="lit">P</code>&#8217; (rather than &#8216;<code class="lit">p</code>&#8217;) to separate the mantissa and exponent.<p>
Note that there may be multiple valid ways to represent floating-point numbers in this hexadecimal format. For example, <code class="lit">0x3.24p+0</code>, <code class="lit">0x6.48p-1</code> and <code class="lit">0xc.9p-2</code> are all equivalent. The format chosen depends on the internal representation of the number, but the implementation guarantees that the length of the mantissa will be minimized. Zeroes are always represented with a mantissa of 0 (preceded by a &#8216;<code class="lit">-</code>&#8217; if appropriate) and an exponent of <code class="lit">+0</code>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">C</b></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Treated as <b class="flag">c</b> with the <b class="flag">l</b> (ell) modifier.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">c</b></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
The <span class="type">int</span> argument is converted to an <span class="type">unsigned char</span>, and the resulting character is written.<p>
If the <b class="flag">l</b> (ell) modifier is used, the <span class="type">wint_t</span> argument shall be converted to a <span class="type">wchar_t</span>, and the (potentially multi-byte) sequence representing the single wide character is written, including any shift sequences. If a shift sequence is used, the shift state is also restored to the original state after the character.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">S</b></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Treated as <b class="flag">s</b> with the <b class="flag">l</b> (ell) modifier.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">s</b></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
The <span class="type">char *</span> argument is expected to be a pointer to an array of character type (pointer to a string). Characters from the array are written up to (but not including) a terminating <span class="define">NUL</span> character; if a precision is specified, no more than the number specified are written. If a precision is given, no null character need be present; if the precision is not specified, or is greater than the size of the array, the array must contain a terminating <span class="define">NUL</span> character.<p>
If the <b class="flag">l</b> (ell) modifier is used, the <span class="type">wchar_t *</span> argument is expected to be a pointer to an array of wide characters (pointer to a wide string). For each wide character in the string, the (potentially multi-byte) sequence representing the wide character is written, including any shift sequences. If any shift sequence is used, the shift state is also restored to the original state after the string. Wide characters from the array are written up to (but not including) a terminating wide <span class="define">NUL</span> character; if a precision is specified, no more than the number of bytes specified are written (including shift sequences). Partial characters are never written. If a precision is given, no null character need be present; if the precision is not specified, or is greater than the number of bytes required to render the multibyte representation of the string, the array must contain a terminating wide <span class="define">NUL</span> character.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">p</b></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
The <span class="type">void *</span> pointer argument is printed in hexadecimal (as if by &#8216;<code class="lit">%#x</code>&#8217; or &#8216;<code class="lit">%#lx</code>&#8217;).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">n</b></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
The number of characters written so far is stored into the integer indicated by the <span class="type">int *</span> (or variant) pointer argument. No argument is converted.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">%</b></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
A &#8216;<code class="lit">%</code>&#8217; is written. No argument is converted. The complete conversion specification is &#8216;<code class="lit">%%</code>&#8217;.</dd>
</dl>
<p>
The decimal point character is defined in the program's locale (category <span class="define">LC_NUMERIC</span>).<p>
In no case does a non-existent or small field width cause truncation of a numeric field; if the result of a conversion is wider than the field width, the field is expanded to contain the conversion result.</div>
<div class="section">
<h1 id="x52455455524e2056414c554553">RETURN VALUES</h1> These functions return the number of characters printed, or that would be printed if there was adequate space in case of <b class="fname">snprintf</b>(), <b class="fname">vsnprintf</b>(), and <b class="fname">vsnprintf_ss</b>() (not including the trailing &#8216;<code class="lit">&#92;0</code>&#8217; used to end output to strings). If an output error was encountered, these functions shall return a negative value.</div>
<div class="section">
<h1 id="x4558414d504c4553">EXAMPLES</h1> To print a date and time in the form &#8220;<code class="lit">Sunday, July 3, 10:02</code>&#8221;, where <i class="farg">weekday</i> and <i class="farg">month</i> are pointers to strings:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
#include &lt;stdio.h&gt; 
fprintf(stdout, "%s, %s %d, %.2d:%.2d&#92;n", 
	weekday, month, day, hour, min);</pre>
<p>
To print pi to five decimal places:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
#include &lt;math.h&gt; 
#include &lt;stdio.h&gt; 
fprintf(stdout, "pi = %.5f&#92;n", 4 * atan(1.0));</pre>
<p>
To allocate a 128 byte string and print into it:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt; 
#include &lt;stdarg.h&gt; 
char *newfmt(const char *fmt, ...) 
{ 
	char *p; 
	va_list ap; 
	if ((p = malloc(128)) == NULL) 
		return (NULL); 
	va_start(ap, fmt); 
	(void) vsnprintf(p, 128, fmt, ap); 
	va_end(ap); 
	return (p); 
}</pre>
</div>
<div class="section">
<h1 id="x4552524f5253">ERRORS</h1> In addition to the errors documented for the <a class="link-man" href="../2/write">write(2)</a> system call, the <b class="fname">printf</b>() family of functions may fail if:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">EILSEQ</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
An invalid wide-character code was encountered.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">ENOMEM</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
Insufficient storage space is available.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">EOVERFLOW</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
The <i class="farg">size</i> argument exceeds <span class="define">INT_MAX</span>, or the return value would be too large to be represented by an <span class="type">int</span>.</dd>
</dl>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../1/printf">printf(1)</a>, <a class="link-man" href="../3/fmtcheck">fmtcheck(3)</a>, <a class="link-man" href="../3/scanf">scanf(3)</a>, <a class="link-man" href="../3/setlocale">setlocale(3)</a>, <a class="link-man" href="../3/wprintf">wprintf(3)</a>, <a class="link-man" href="../9/printf">printf(9)</a></div>
<div class="section">
<h1 id="x5354414e4441524453">STANDARDS</h1> Subject to the caveats noted in the <i class="link-sec"><a class="link-sec" href="#x42554753">BUGS</a></i> section below, the <b class="fname">fprintf</b>(), <b class="fname">printf</b>(), <b class="fname">sprintf</b>(), <b class="fname">vprintf</b>(), <b class="fname">vfprintf</b>(), and <b class="fname">vsprintf</b>() functions conform to ANSI X3.159-1989 (&#8220;ANSI&#160;C89&#8221;) and ISO/IEC 9899:1999 (&#8220;ISO&#160;C99&#8221;). With the same reservation, the <b class="fname">snprintf</b>() and <b class="fname">vsnprintf</b>() functions conform to ISO/IEC 9899:1999 (&#8220;ISO&#160;C99&#8221;).</div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The functions <b class="fname">snprintf</b>() and <b class="fname">vsnprintf</b>() first appeared in <span class="unix">4.4BSD</span>. The functions <b class="fname">asprintf</b>() and <b class="fname">vasprintf</b>() are modeled on the ones that first appeared in the GNU C library. The function <b class="fname">vsnprintf_ss</b>() is non-standard and appeared in <span class="unix">NetBSD&#160;4.0</span>. The functions <b class="fname">dprintf</b>() and <b class="fname">vdprintf</b>() are parts of IEEE Std 1003.1-2008 (&#8220;POSIX.1&#8221;) and appeared in <span class="unix">NetBSD&#160;6.0</span>.</div>
<div class="section">
<h1 id="x43415645415453">CAVEATS</h1> Because <b class="fname">sprintf</b>() and <b class="fname">vsprintf</b>() assume an infinitely long string, callers must be careful not to overflow the actual space; this is often impossible to assure. For safety, programmers should use the <b class="fname">snprintf</b>() and <b class="fname">asprintf</b>() family of interfaces instead. Unfortunately, the <b class="fname">snprintf</b>() interfaces are not available on older systems and the <b class="fname">asprintf</b>() interfaces are not yet portable.<p>
It is important never to pass a string with user-supplied data as a format without using &#8216;<code class="lit">%s</code>&#8217;. An attacker can put format specifiers in the string to mangle your stack, leading to a possible security hole. This holds true even if you have built the string &#8220;by hand&#8221; using a function like <b class="fname">snprintf</b>(), as the resulting string may still contain user-supplied conversion specifiers for later interpolation by <b class="fname">printf</b>().<p>
Be sure to use the proper secure idiom:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
snprintf(buffer, sizeof(buffer), "%s", string);</pre>
<p>
There is no way for <b class="fname">printf</b>() to know the size of each argument passed. If you use positional arguments you must ensure that all parameters, up to the last positionally specified parameter, are used in the format string. This allows for the format string to be parsed for this information. Failure to do this will mean your code is non-portable and liable to fail.<p>
In this implementation, passing a <span class="define">NULL</span> <span class="type">char *</span> argument to the <b class="flag">%s</b> format specifier will output <span class="emph">(null)</span> instead of crashing. Programs that depend on this behavior are non-portable and may crash on other systems or in the future.</div>
<div class="section">
<h1 id="x42554753">BUGS</h1> The conversion formats <b class="flag">%D</b>, <b class="flag">%O</b>, and <b class="flag">%U</b> are not standard and are provided only for backward compatibility. The effect of padding the <b class="flag">%p</b> format with zeros (either by the &#8216;<b class="flag">0</b>&#8217; flag or by specifying a precision), and the benign effect (i.e. none) of the &#8216;<b class="flag">#</b>&#8217; flag on <b class="flag">%n</b> and <b class="flag">%p</b> conversions, as well as other nonsensical combinations such as <b class="flag">%Ld</b>, are not standard; such combinations should be avoided.<p>
The <b class="name">printf</b> family of functions do not correctly handle multibyte characters in the <i class="farg">format</i> argument.</div>
<div class="section">
<h1 id="x534543555249545920434f4e53494445524154494f4e53">SECURITY CONSIDERATIONS</h1> The <b class="fname">sprintf</b>() and <b class="fname">vsprintf</b>() functions are easily misused in a manner which enables malicious users to arbitrarily change a running program's functionality through a buffer overflow attack. Because <b class="fname">sprintf</b>() and <b class="fname">vsprintf</b>() assume an infinitely long string, callers must be careful not to overflow the actual space; this is often hard to assure. For safety, programmers should use the <b class="fname">snprintf</b>() interface instead. For example:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
void 
foo(const char *arbitrary_string, const char *and_another) 
{ 
	char onstack[8]; 
 
#ifdef BAD 
	/* 
	 * This first sprintf is bad behavior.  Do not use sprintf! 
	 */ 
	sprintf(onstack, "%s, %s", arbitrary_string, and_another); 
#else 
	/* 
	 * The following two lines demonstrate better use of 
	 * snprintf(). 
	 */ 
	snprintf(onstack, sizeof(onstack), "%s, %s", arbitrary_string, 
	    and_another); 
#endif 
}</pre>
<p>
The <b class="fname">printf</b>() and <b class="fname">sprintf</b>() family of functions are also easily misused in a manner allowing malicious users to arbitrarily change a running program's functionality by either causing the program to print potentially sensitive data &#8220;left on the stack&#8221;, or causing it to generate a memory fault or bus error by dereferencing an invalid pointer.<p>
<b class="flag">%n</b> can be used to write arbitrary data to potentially carefully-selected addresses. Programmers are therefore strongly advised to never pass untrusted strings as the <i class="farg">format</i> argument, as an attacker can put format specifiers in the string to mangle your stack, leading to a possible security hole. This holds true even if the string was built using a function like <b class="fname">snprintf</b>(), as the resulting string may still contain user-supplied conversion specifiers for later interpolation by <b class="fname">printf</b>().<p>
Always use the proper secure idiom:<p>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">snprintf(buffer, sizeof(buffer), &#34;%s&#34;, string);</code></div>
</blockquote>
</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
September 29, 2014</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
<>

