<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/../4/strict.dtd">
>
<head>
<meta http-equiv="Content-Type" content="te../; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
UKFS(3)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
UKFS(3)</td>
<td class="head-vol" align="center">
Library Functions Manual</td>
<td class="head-rtitle" align="right">
UKFS(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">ukfs</b> &#8212; <span class="desc">user kernel file system library interface</span></div>
<div class="section">
<h1 id="x4c494252415259">LIBRARY</h1> ukfs Library (libukfs, &#45;lukfs)</div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">rump/ukfs.h</a>&gt;</b></div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <b class="name">ukfs</b> library provides direct access to file systems without having to specially mount a file system. Therefore, accessing a file system through <b class="name">ukfs</b> requires no special kernel support apart from standard POSIX functionality. As <b class="name">ukfs</b> is built upon <a class="link-man" href="../3/rump">rump(3)</a> kernels, all kernel file systems which are supported by rump kernels are available. It allows to write utilities for accessing file systems without having to duplicate file system internals knowledge already present in kernel file system drivers.<p>
<b class="name">ukfs</b> provides a high-level pathname based interface for accessing file systems. If a lower level interface it desired, <a class="link-man" href="../3/rump">rump(3)</a> kernels should be used directly. However, much like system calls, the interfaces of <b class="name">ukfs</b>, are self-contained and require no tracking and release of resources. The only exception is the file system handle <i class="ftype">struct ukfs</i> which should be released after use.</div>
<div class="section">
<h1 id="x494e495449414c495a4154494f4e">INITIALIZATION</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-ohang">
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">int</i></dt>
<dd class="list-ohang">
<b class="fname">ukfs_init</b>()</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">int</i></dt>
<dd class="list-ohang">
<b class="fname">ukfs_modload</b>(<i class="farg">const char *fname</i>)</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">int</i></dt>
<dd class="list-ohang">
<b class="fname">ukfs_modload_dir</b>(<i class="farg">const char *dirname</i>)</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">ssize_t</i></dt>
<dd class="list-ohang">
<b class="fname">ukfs_vfstypes</b>(<i class="farg">char *buf</i>, <i class="farg">size_t buflen</i>)</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">struct ukfs *</i></dt>
<dd class="list-ohang">
<b class="fname">ukfs_mount</b>(<i class="farg">const char *vfsname</i>, <i class="farg">const char *devpath</i>, <i class="farg">const char *mountpath</i>, <i class="farg">int mntflags</i>, <i class="farg">void *arg</i>, <i class="farg">size_t alen</i>)</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">struct ukfs *</i></dt>
<dd class="list-ohang">
<b class="fname">ukfs_mount_disk</b>(<i class="farg">const char *vfsname</i>, <i class="farg">const char *devpath</i>, <i class="farg">int partition</i>, <i class="farg">const char *mountpath</i>, <i class="farg">int mntflags</i>, <i class="farg">void *arg</i>, <i class="farg">size_t alen</i>)</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">int</i></dt>
<dd class="list-ohang">
<b class="fname">ukfs_release</b>(<i class="farg">struct ukfs *ukfs</i>, <i class="farg">int flags</i>)</dd>
</dl>
<p>
<b class="fname">ukfs_init</b>() intializes the library and must be called once per process using <b class="name">ukfs</b>.<p>
<b class="fname">ukfs_modload</b>() is used at runtime to dynamically load a library which contains a file system module. For this to succeed, the <a class="link-man" href="../3/rump">rump(3)</a> kernel and the module targetted must be compiled with compatible kernel versions and the application must be dynamically linked. Additionally, since this routine does not handle dependencies, all the dependencies of the library must be loaded beforehand. The routine returns &#45;1 for fatal error, 0 for dependency failure and 1 for success.<p>
<b class="fname">ukfs_modload_dir</b>() loads all <a class="link-man" href="../3/rump">rump(3)</a> kernel file system components in directory <i class="farg">dirname</i>. It looks for libraries which begin with <i class="file">librumpfs_</i> and end in <i class="file">.so</i>. The routine tries to handle dependencies by retrying to load libraries which failed due to dependencies. <b class="fname">ukfs_modload_dir</b>() returns the number of vfs modules loaded or sets errno and returns &#45;1 in case of a fatal error in directory searching. In case a fatal error occurs after some modules have already been loaded, the number of loaded module is returned. Fatal errors in loading the modules themselves are ignored and <b class="fname">ukfs_modload</b>() should be used directly if finegrained error reporting is desired.<p>
It should be noted that the above routines affect the whole process, not just a specific instance of <b class="name">ukfs</b>. It is preferable to call them from only one thread, as the underlying dynamic library interfaces may not be threadsafe.<p>
<b class="fname">ukfs_vfstypes</b>() queries the available file system types and returns a nul-terminated list of types separated by spaces in <i class="farg">buf</i>. The format of the list is equivalent to the one returned by <a class="link-man" href="../3/sysctl">sysctl(3)</a> on the name <i class="file">vfs.generic.fstypes</i>. The function returns the length of the string without the trailing nul or &#45;1 for error. Notably, the return value 0 means there are no file systems available. If there is not enough room in the caller's buffer for all file system types, as many as fit will be returned.<p>
<b class="fname">ukfs_mount</b>() intializes a file system image. The handle resulting from the operation is passed to all other routines and identifies the instance of the mount analoguous to what a pathname specifies in a normally mounted file system. The parameters are the following:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
vfsname</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Name of the file system to be used, e.g. <span class="define">MOUNT_FFS</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
devpath</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Path of file system image. It can be either a regular file, device or, if the file system does not support the concept of a device, an abitrary string, e.g. network address.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
mountpath</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Path where the file system is mounted to. This parameter is used only by the file system being mounted. Most of the time <span class="define">UKFS_DEFAULTMP</span> is the correct path.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
mntflags</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Flags as passed to the <a class="link-man" href="../2/mount">mount(2)</a> system call, for example <span class="define">MNT_RDONLY</span>. In addition to generic parameters, file system specific parameters such as <span class="define">MNT_LOG</span> (ffs) may be passed here.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
arg</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
File system private argument structure. This is passed directly to the file system. It must match what <i class="farg">vfsname</i> expects.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
alen</dt>
<dd class="list-tag" style="margin-left: 3.00ex;">
Size of said structure.</dd>
</dl>
<p>
The <b class="fname">ukfs_mount_disk</b>() function must be used to mount disk-based file systems. It takes the same arguments as <b class="fname">ukfs_mount</b>(), except for an additional argument signifying the <i class="farg">partition</i> number. If the image <i class="farg">devpath</i> contains a disklabel, this value specifies the number of the partition within the image used as the file system backend. If <i class="farg">devpath</i> does not contain a disklabel, the value <span class="define">UKFS_PARTITION_NONE</span> must be used to signal that the file system backend is the entire image.<p>
<b class="fname">ukfs_release</b>() unmounts the file system and releases the resources associated with <i class="farg">ukfs</i>. The return value signals the return value of the unmount operation. If non-zero, <i class="farg">ukfs</i> will continue to remain valid. The possible values for flags are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">UKFS_RELFLAG_NOUNMOUNT</span></dt>
<dd class="list-tag" style="margin-left: 22.00ex;">
Do not unmount file system, just release ukfs handle. Release always succeeds.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">UKFS_RELFLAG_FORCE</span></dt>
<dd class="list-tag" style="margin-left: 22.00ex;">
Forcefully unmount the file system. This means that any busy nodes (due to e.g. <b class="fname">ukfs_chdir</b>()) will be ignored. Release always succeeds.</dd>
</dl>
</div>
<div class="section">
<h1 id="x4f5045524154494f4e">OPERATION</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-ohang">
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">int</i></dt>
<dd class="list-ohang">
<b class="fname">ukfs_chdir</b>(<i class="farg">struct ukfs *ukfs</i>, <i class="farg">const char *path</i>)</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">int</i></dt>
<dd class="list-ohang">
<b class="fname">ukfs_getdents</b>(<i class="farg">struct ukfs *ukfs</i>, <i class="farg">const char *dirname</i>, <i class="farg">off_t *off</i>, <i class="farg">uint8_t *buf</i>, <i class="farg">size_t bufsize</i>)</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">ssize_t</i></dt>
<dd class="list-ohang">
<b class="fname">ukfs_read</b>(<i class="farg">struct ukfs *ukfs</i>, <i class="farg">const char *filename</i>, <i class="farg">off_t off</i>, <i class="farg">uint8_t *buf</i>, <i class="farg">size_t bufsize</i>)</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">ssize_t</i></dt>
<dd class="list-ohang">
<b class="fname">ukfs_write</b>(<i class="farg">struct ukfs *ukfs</i>, <i class="farg">const char *filename</i>, <i class="farg">off_t off</i>, <i class="farg">uint8_t *buf</i>, <i class="farg">size_t bufsize</i>)</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">int</i></dt>
<dd class="list-ohang">
<b class="fname">ukfs_create</b>(<i class="farg">struct ukfs *ukfs</i>, <i class="farg">const char *filename</i>, <i class="farg">mode_t mode</i>)</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">int</i></dt>
<dd class="list-ohang">
<b class="fname">ukfs_mknod</b>(<i class="farg">struct ukfs *ukfs</i>, <i class="farg">const char *path</i>, <i class="farg">mode_t mode</i>, <i class="farg">dev_t dev</i>)</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">int</i></dt>
<dd class="list-ohang">
<b class="fname">ukfs_mkfifo</b>(<i class="farg">struct ukfs *ukfs</i>, <i class="farg">const char *path</i>, <i class="farg">mode_t mode</i>)</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">int</i></dt>
<dd class="list-ohang">
<b class="fname">ukfs_mkdir</b>(<i class="farg">struct ukfs *ukfs</i>, <i class="farg">const char *filename</i>, <i class="farg">mode_t mode</i>)</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">int</i></dt>
<dd class="list-ohang">
<b class="fname">ukfs_remove</b>(<i class="farg">struct ukfs *ukfs</i>, <i class="farg">const char *filename</i>)</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">int</i></dt>
<dd class="list-ohang">
<b class="fname">ukfs_rmdir</b>(<i class="farg">struct ukfs *ukfs</i>, <i class="farg">const char *filename</i>)</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">int</i></dt>
<dd class="list-ohang">
<b class="fname">ukfs_link</b>(<i class="farg">struct ukfs *ukfs</i>, <i class="farg">const char *filename</i>, <i class="farg">const char *f_create</i>)</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">int</i></dt>
<dd class="list-ohang">
<b class="fname">ukfs_symlink</b>(<i class="farg">struct ukfs *ukfs</i>, <i class="farg">const char *filename</i>, <i class="farg">const char *linkname</i>)</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">ssize_t</i></dt>
<dd class="list-ohang">
<b class="fname">ukfs_readlink</b>(<i class="farg">struct ukfs *ukfs</i>, <i class="farg">const char *filename</i>, <i class="farg">char *linkbuf</i>, <i class="farg">size_t buflen</i>)</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">int</i></dt>
<dd class="list-ohang">
<b class="fname">ukfs_rename</b>(<i class="farg">struct ukfs *ukfs</i>, <i class="farg">const char *from</i>, <i class="farg">const char *to</i>)</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">int</i></dt>
<dd class="list-ohang">
<b class="fname">ukfs_stat</b>(<i class="farg">struct ukfs *ukfs</i>, <i class="farg">const char *filename</i>, <i class="farg">struct stat *file_stat</i>)</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">int</i></dt>
<dd class="list-ohang">
<b class="fname">ukfs_lstat</b>(<i class="farg">struct ukfs *ukfs</i>, <i class="farg">const char *filename</i>, <i class="farg">struct stat *file_stat</i>)</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">int</i></dt>
<dd class="list-ohang">
<b class="fname">ukfs_chmod</b>(<i class="farg">struct ukfs *ukfs</i>, <i class="farg">const char *filename</i>, <i class="farg">mode_t mode</i>)</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">int</i></dt>
<dd class="list-ohang">
<b class="fname">ukfs_lchmod</b>(<i class="farg">struct ukfs *ukfs</i>, <i class="farg">const char *filename</i>, <i class="farg">mode_t mode</i>)</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">int</i></dt>
<dd class="list-ohang">
<b class="fname">ukfs_chown</b>(<i class="farg">struct ukfs *ukfs</i>, <i class="farg">const char *filename</i>, <i class="farg">uid_t uid</i>, <i class="farg">gid_t gid</i>)</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">int</i></dt>
<dd class="list-ohang">
<b class="fname">ukfs_lchown</b>(<i class="farg">struct ukfs *ukfs</i>, <i class="farg">const char *filename</i>, <i class="farg">uid_t uid</i>, <i class="farg">gid_t gid</i>)</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">int</i></dt>
<dd class="list-ohang">
<b class="fname">ukfs_chflags</b>(<i class="farg">struct ukfs *ukfs</i>, <i class="farg">const char *filename</i>, <i class="farg">u_long flags</i>)</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">int</i></dt>
<dd class="list-ohang">
<b class="fname">ukfs_lchflags</b>(<i class="farg">struct ukfs *ukfs</i>, <i class="farg">const char *filename</i>, <i class="farg">u_long flags</i>)</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">int</i></dt>
<dd class="list-ohang">
<b class="fname">ukfs_utimes</b>(<i class="farg">struct ukfs *ukfs</i>, <i class="farg">const char *filename</i>, <i class="farg">const struct timeval *tptr</i>)</dd>
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">int</i></dt>
<dd class="list-ohang">
<b class="fname">ukfs_lutimes</b>(<i class="farg">struct ukfs *ukfs</i>, <i class="farg">const char *filename</i>, <i class="farg">const struct timeval *tptr</i>)</dd>
</dl>
<p>
The above routines operate like their system call counterparts and the system call manual pages without the ukfs_ prefix should be referred to for further information on the parameters.<p>
The only call which modifies <i class="farg">ukfs</i> state is <b class="fname">ukfs_chdir</b>(). It works like <a class="link-man" href="../2/chdir">chdir(2)</a> in the sense that it affects the interpretation of relative paths. If succesful, all relative pathnames will be resolved starting from the current directory. Currently the call affects all accesses to that particular <i class="farg">ukfs</i>, but it might be later changed to be thread private.</div>
<div class="section">
<h1 id="x5554494c4954494553">UTILITIES</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-ohang">
<dt class="list-ohang" style="margin-top: 1.00em;">
<i class="ftype">int</i></dt>
<dd class="list-ohang">
<b class="fname">ukfs_util_builddirs</b>(<i class="farg">struct ukfs *ukfs</i>, <i class="farg">const char *pathname</i>, <i class="farg">mode_t mode</i>)</dd>
</dl>
<p>
Builds a directory hierarchy. Unlike mkdir, the <i class="farg">pathname</i> argument may contain multiple levels of hierarchy. It is not considered an error if any of the directories specified exist already.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../3/rump">rump(3)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> <b class="name">ukfs</b> first appeared in <span class="unix">NetBSD&#160;5.0</span>.</div>
<div class="section">
<h1 id="x415554484f5253">AUTHORS</h1> <span class="author">Antti Kantee</span> &#60;<a class="link-mail" href="mailto:pooka@cs.hut.fi">pooka@cs.hut.fi</a>&#62;</div>
<div class="section">
<h1 id="x4e4f544553">NOTES</h1> <b class="name">ukfs</b> was an early attempt at an interface for kernel file systems running in userspace.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
February 13, 2014</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
<>

