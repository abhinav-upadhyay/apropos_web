<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="/static/man_pages/netbsd/style.css" type="text/css" media="all">
<title>
PCAP_LOOP(3)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
PCAP_LOOP(3)</td>
<td class="head-vol" align="center">
Library Functions Manual</td>
<td class="head-rtitle" align="right">
PCAP_LOOP(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> pcap_loop, pcap_dispatch &#45; process packets from a live capture or savefile</div>
<div class="section">
<h1>SYNOPSIS</h1><br>
#include &lt;pcap/pcap.h&gt;<p>
<br>
typedef void (*pcap_handler)(u_char *user, const struct pcap_pkthdr *h,<br>
			     const u_char *bytes);<p>
<br>
int pcap_loop(pcap_t *p, int cnt,<br>
pcap_handler callback, u_char *user);<br>
int pcap_dispatch(pcap_t *p, int cnt,<br>
pcap_handler callback, u_char *user);<br>
</div>
<div class="section">
<h1>DESCRIPTION</h1> <b>pcap_loop()</b> processes packets from a live capture or ``savefile'' until <i>cnt</i> packets are processed, the end of the ``savefile'' is reached when reading from a ``savefile'', <b>pcap_breakloop()</b> is called, or an error occurs. It does <b>not</b> return when live read timeouts occur. A value of &#45;1 or 0 for <i>cnt</i> is equivalent to infinity, so that packets are processed until another ending condition occurs.<p>
<b>pcap_dispatch()</b> processes packets from a live capture or ``savefile'' until <i>cnt</i> packets are processed, the end of the current bufferful of packets is reached when doing a live capture, the end of the ``savefile'' is reached when reading from a ``savefile'', <b>pcap_breakloop()</b> is called, or an error occurs. Thus, when doing a live capture, <i>cnt</i> is the maximum number of packets to process before returning, but is not a minimum number; when reading a live capture, only one bufferful of packets is read at a time, so fewer than <i>cnt</i> packets may be processed. A value of &#45;1 or 0 for <i>cnt</i> causes all the packets received in one buffer to be processed when reading a live capture, and causes all the packets in the file to be processed when reading a ``savefile''.<p>
Note that, when doing a live capture on some platforms, if the read timeout expires when there are no packets available, <b>pcap_dispatch()</b> will return 0, even when not in non-blocking mode, as there are no packets to process.  Applications should be prepared for this to happen, but must not rely on it happening.<p>
(In older versions of libpcap, the behavior when  <i>cnt</i> was 0 was undefined; different platforms and devices behaved differently, so code that must work with older versions of libpcap should use &#45;1, not 0, as the value of  <i>cnt</i>.)<p>
<i>callback</i> specifies a <i>pcap_handler</i> routine to be called with three arguments: a <i>u_char</i> pointer which is passed in the <i>user</i> argument to <b>pcap_loop()</b> or <b>pcap_dispatch()</b>, a <i>const struct pcap_pkthdr</i> pointer pointing to the packet time stamp and lengths, and a <i>const u_char</i> pointer to the first <b>caplen</b> (as given in the <i>struct pcap_pkthdr</i> a pointer to which is passed to the callback routine) bytes of data from the packet.  The <i>struct pcap_pkthdr</i> and the packet data are not to be freed by the callback routine, and are not guaranteed to be valid after the callback routine returns; if the code needs them to be valid after the callback, it must make a copy of them.<p>
The bytes of data from the packet begin with a link-layer header.  The format of the link-layer header is indicated by the return value of the <b>pcap_datalink()</b> routine when handed the <b>pcap_t</b> value also passed to <b>pcap_loop()</b> or <b>pcap_dispatch()</b>. <i>http://www.tcpdump.org/linktypes</i> lists the values <b>pcap_datalink()</b> can return and describes the packet formats that correspond to those values.  The value it returns will be valid for all packets received unless and until <b>pcap_set_datalink()</b> is called; after a successful call to <b>pcap_set_datalink()</b>, all subsequent packets will have a link-layer header of the type specified by the link-layer header type value passed to <b>pcap_set_datalink()</b>.<p>
Do <b>NOT</b> assume that the packets for a given capture or ``savefile`` will have any given link-layer header type, such as <b>DLT_EN10MB</b> for Ethernet.  For example, the "any" device on Linux will have a link-layer header type of <b>DLT_LINUX_SLL</b> even if all devices on the system at the time the "any" device is opened have some other data link type, such as <b>DLT_EN10MB</b> for Ethernet.</div>
<div class="section">
<h1>RETURN VALUE</h1> <b>pcap_loop()</b> returns 0 if <i>cnt</i> is exhausted or if, when reading from a ``savefile'', no more packets are available.  It returns &#45;1 if an error occurs or &#45;2 if the loop terminated due to a call to <b>pcap_breakloop()</b> before any packets were processed. It does <b>not</b> return when live read timeouts occur; instead, it attempts to read more packets.<p>
<b>pcap_dispatch()</b> returns the number of packets processed on success; this can be 0 if no packets were read from a live capture (if, for example, they were discarded because they didn't pass the packet filter, or if, on platforms that support a read timeout that starts before any packets arrive, the timeout expires before any packets arrive, or if the file descriptor for the capture device is in non-blocking mode and no packets were available to be read) or if no more packets are available in a ``savefile.''  It returns &#45;1 if an error occurs or &#45;2 if the loop terminated due to a call to <b>pcap_breakloop()</b> before any packets were processed. If your application uses pcap_breakloop(), make sure that you explicitly check for &#45;1 and &#45;2, rather than just checking for a return value &lt; 0.<p>
If &#45;1 is returned, <b>pcap_geterr()</b> or <b>pcap_perror()</b> may be called with <i>p</i> as an argument to fetch or display the error text.</div>
<div class="section">
<h1>SEE ALSO</h1> pcap(3), pcap_geterr(3), pcap_breakloop(3), pcap_datalink(3)</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tr>
<td class="foot-date">
13 October 2013</td>
<td class="foot-os" align="right">
</td>
</tr>
</table>
</div>
</body>
</html>

