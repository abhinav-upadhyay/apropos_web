<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="/static/man_pages/netbsd/style.css" type="text/css" media="all">
<title>
RAIDCTL(8)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
RAIDCTL(8)</td>
<td class="head-vol" align="center">
System Manager's Manual</td>
<td class="head-rtitle" align="right">
RAIDCTL(8)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">raidctl</b> &#8212; <span class="desc">configuration utility for the RAIDframe disk driver</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1><table class="synopsis">
<col style="width: 7.00ex;">
<col>
<tbody>
<tr>
<td>
raidctl</td>
<td>
&#91;<span class="opt"><b class="flag">&#45;v</b></span>&#93; <b class="flag">&#45;a</b> <i class="arg">component</i> <i class="arg">dev</i></td>
</tr>
</tbody>
</table>
<br>
<table class="synopsis">
<col style="width: 7.00ex;">
<col>
<tbody>
<tr>
<td>
raidctl</td>
<td>
&#91;<span class="opt"><b class="flag">&#45;v</b></span>&#93; <b class="flag">&#45;A</b> &#91;<span class="opt">yes | no | forceroot | softroot</span>&#93; <i class="arg">dev</i></td>
</tr>
</tbody>
</table>
<br>
<table class="synopsis">
<col style="width: 7.00ex;">
<col>
<tbody>
<tr>
<td>
raidctl</td>
<td>
&#91;<span class="opt"><b class="flag">&#45;v</b></span>&#93; <b class="flag">&#45;B</b> <i class="arg">dev</i></td>
</tr>
</tbody>
</table>
<br>
<table class="synopsis">
<col style="width: 7.00ex;">
<col>
<tbody>
<tr>
<td>
raidctl</td>
<td>
&#91;<span class="opt"><b class="flag">&#45;v</b></span>&#93; <b class="flag">&#45;c</b> <i class="arg">config_file</i> <i class="arg">dev</i></td>
</tr>
</tbody>
</table>
<br>
<table class="synopsis">
<col style="width: 7.00ex;">
<col>
<tbody>
<tr>
<td>
raidctl</td>
<td>
&#91;<span class="opt"><b class="flag">&#45;v</b></span>&#93; <b class="flag">&#45;C</b> <i class="arg">config_file</i> <i class="arg">dev</i></td>
</tr>
</tbody>
</table>
<br>
<table class="synopsis">
<col style="width: 7.00ex;">
<col>
<tbody>
<tr>
<td>
raidctl</td>
<td>
&#91;<span class="opt"><b class="flag">&#45;v</b></span>&#93; <b class="flag">&#45;f</b> <i class="arg">component</i> <i class="arg">dev</i></td>
</tr>
</tbody>
</table>
<br>
<table class="synopsis">
<col style="width: 7.00ex;">
<col>
<tbody>
<tr>
<td>
raidctl</td>
<td>
&#91;<span class="opt"><b class="flag">&#45;v</b></span>&#93; <b class="flag">&#45;F</b> <i class="arg">component</i> <i class="arg">dev</i></td>
</tr>
</tbody>
</table>
<br>
<table class="synopsis">
<col style="width: 7.00ex;">
<col>
<tbody>
<tr>
<td>
raidctl</td>
<td>
&#91;<span class="opt"><b class="flag">&#45;v</b></span>&#93; <b class="flag">&#45;g</b> <i class="arg">component</i> <i class="arg">dev</i></td>
</tr>
</tbody>
</table>
<br>
<table class="synopsis">
<col style="width: 7.00ex;">
<col>
<tbody>
<tr>
<td>
raidctl</td>
<td>
&#91;<span class="opt"><b class="flag">&#45;v</b></span>&#93; <b class="flag">&#45;G</b> <i class="arg">dev</i></td>
</tr>
</tbody>
</table>
<br>
<table class="synopsis">
<col style="width: 7.00ex;">
<col>
<tbody>
<tr>
<td>
raidctl</td>
<td>
&#91;<span class="opt"><b class="flag">&#45;v</b></span>&#93; <b class="flag">&#45;i</b> <i class="arg">dev</i></td>
</tr>
</tbody>
</table>
<br>
<table class="synopsis">
<col style="width: 7.00ex;">
<col>
<tbody>
<tr>
<td>
raidctl</td>
<td>
&#91;<span class="opt"><b class="flag">&#45;v</b></span>&#93; <b class="flag">&#45;I</b> <i class="arg">serial_number</i> <i class="arg">dev</i></td>
</tr>
</tbody>
</table>
<br>
<table class="synopsis">
<col style="width: 7.00ex;">
<col>
<tbody>
<tr>
<td>
raidctl</td>
<td>
&#91;<span class="opt"><b class="flag">&#45;v</b></span>&#93; <b class="flag">&#45;m</b> <i class="arg">dev</i></td>
</tr>
</tbody>
</table>
<br>
<table class="synopsis">
<col style="width: 7.00ex;">
<col>
<tbody>
<tr>
<td>
raidctl</td>
<td>
&#91;<span class="opt"><b class="flag">&#45;v</b></span>&#93; <b class="flag">&#45;M</b> &#91;<span class="opt">yes | no | set <i class="arg">params</i></span>&#93; <i class="arg">dev</i></td>
</tr>
</tbody>
</table>
<br>
<table class="synopsis">
<col style="width: 7.00ex;">
<col>
<tbody>
<tr>
<td>
raidctl</td>
<td>
&#91;<span class="opt"><b class="flag">&#45;v</b></span>&#93; <b class="flag">&#45;p</b> <i class="arg">dev</i></td>
</tr>
</tbody>
</table>
<br>
<table class="synopsis">
<col style="width: 7.00ex;">
<col>
<tbody>
<tr>
<td>
raidctl</td>
<td>
&#91;<span class="opt"><b class="flag">&#45;v</b></span>&#93; <b class="flag">&#45;P</b> <i class="arg">dev</i></td>
</tr>
</tbody>
</table>
<br>
<table class="synopsis">
<col style="width: 7.00ex;">
<col>
<tbody>
<tr>
<td>
raidctl</td>
<td>
&#91;<span class="opt"><b class="flag">&#45;v</b></span>&#93; <b class="flag">&#45;r</b> <i class="arg">component</i> <i class="arg">dev</i></td>
</tr>
</tbody>
</table>
<br>
<table class="synopsis">
<col style="width: 7.00ex;">
<col>
<tbody>
<tr>
<td>
raidctl</td>
<td>
&#91;<span class="opt"><b class="flag">&#45;v</b></span>&#93; <b class="flag">&#45;R</b> <i class="arg">component</i> <i class="arg">dev</i></td>
</tr>
</tbody>
</table>
<br>
<table class="synopsis">
<col style="width: 7.00ex;">
<col>
<tbody>
<tr>
<td>
raidctl</td>
<td>
&#91;<span class="opt"><b class="flag">&#45;v</b></span>&#93; <b class="flag">&#45;s</b> <i class="arg">dev</i></td>
</tr>
</tbody>
</table>
<br>
<table class="synopsis">
<col style="width: 7.00ex;">
<col>
<tbody>
<tr>
<td>
raidctl</td>
<td>
&#91;<span class="opt"><b class="flag">&#45;v</b></span>&#93; <b class="flag">&#45;S</b> <i class="arg">dev</i></td>
</tr>
</tbody>
</table>
<br>
<table class="synopsis">
<col style="width: 7.00ex;">
<col>
<tbody>
<tr>
<td>
raidctl</td>
<td>
&#91;<span class="opt"><b class="flag">&#45;v</b></span>&#93; <b class="flag">&#45;u</b> <i class="arg">dev</i></td>
</tr>
</tbody>
</table>
</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> <b class="name">raidctl</b> is the user-land control program for <a class="link-man" href="../4/raid">raid(4)</a>, the RAIDframe disk device. <b class="name">raidctl</b> is primarily used to dynamically configure and unconfigure RAIDframe disk devices. For more information about the RAIDframe disk device, see <a class="link-man" href="../4/raid">raid(4)</a>.<p>
This document assumes the reader has at least rudimentary knowledge of RAID and RAID concepts.<p>
The command-line options for <b class="name">raidctl</b> are as follows:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">&#45;a</b> <i class="arg">component</i> <i class="arg">dev</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Add <i class="arg">component</i> as a hot spare for the device <i class="arg">dev</i>. Component labels (which identify the location of a given component within a particular RAID set) are automatically added to the hot spare after it has been used and are not required for <i class="arg">component</i> before it is used.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">&#45;A</b> <b class="cmd">yes</b> <i class="arg">dev</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Make the RAID set auto-configurable. The RAID set will be automatically configured at boot <i class="arg">before</i> the root file system is mounted. Note that all components of the set must be of type <span class="define">RAID</span> in the disklabel.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">&#45;A</b> <b class="cmd">no</b> <i class="arg">dev</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Turn off auto-configuration for the RAID set.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">&#45;A</b> <b class="cmd">forceroot</b> <i class="arg">dev</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Make the RAID set auto-configurable, and also mark the set as being eligible to be the root partition. A RAID set configured this way will <i class="arg">override</i> the use of the boot disk as the root device. All components of the set must be of type <span class="define">RAID</span> in the disklabel. Note that only certain architectures (currently alpha, amd64, i386, pmax, sandpoint, sparc, sparc64, and vax) support booting a kernel directly from a RAID set. Please note that <b class="cmd">forceroot</b> mode was referred to as <b class="cmd">root</b> mode on earlier versions of <span class="unix">NetBSD</span>. For compatibility reasons, <b class="cmd">root</b> can be used as an alias for <b class="cmd">forceroot</b>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">&#45;A</b> <b class="cmd">softroot</b> <i class="arg">dev</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Like <b class="cmd">forceroot</b>, but only change the root device if the boot device is part of the RAID set.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">&#45;B</b> <i class="arg">dev</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Initiate a copyback of reconstructed data from a spare disk to its original disk. This is performed after a component has failed, and the failed drive has been reconstructed onto a spare drive.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">&#45;c</b> <i class="arg">config_file</i> <i class="arg">dev</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Configure the RAIDframe device <i class="arg">dev</i> according to the configuration given in <i class="arg">config_file</i>. A description of the contents of <i class="arg">config_file</i> is given later.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">&#45;C</b> <i class="arg">config_file</i> <i class="arg">dev</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
As for <b class="flag">&#45;c</b>, but forces the configuration to take place. Fatal errors due to uninitialized components are ignored. This is required the first time a RAID set is configured.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">&#45;f</b> <i class="arg">component</i> <i class="arg">dev</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This marks the specified <i class="arg">component</i> as having failed, but does not initiate a reconstruction of that component.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">&#45;F</b> <i class="arg">component</i> <i class="arg">dev</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Fails the specified <i class="arg">component</i> of the device, and immediately begin a reconstruction of the failed disk onto an available hot spare. This is one of the mechanisms used to start the reconstruction process if a component does have a hardware failure.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">&#45;g</b> <i class="arg">component</i> <i class="arg">dev</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Get the component label for the specified component.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">&#45;G</b> <i class="arg">dev</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Generate the configuration of the RAIDframe device in a format suitable for use with the <b class="flag">&#45;c</b> or <b class="flag">&#45;C</b> options.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">&#45;i</b> <i class="arg">dev</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Initialize the RAID device. In particular, (re-)write the parity on the selected device. This <span class="emph">MUST</span> be done for <span class="emph">all</span> RAID sets before the RAID device is labeled and before file systems are created on the RAID device.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">&#45;I</b> <i class="arg">serial_number</i> <i class="arg">dev</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Initialize the component labels on each component of the device. <i class="arg">serial_number</i> is used as one of the keys in determining whether a particular set of components belong to the same RAID set. While not strictly enforced, different serial numbers should be used for different RAID sets. This step <span class="emph">MUST</span> be performed when a new RAID set is created.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">&#45;m</b> <i class="arg">dev</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Display status information about the parity map on the RAID set, if any. If used with <b class="flag">&#45;v</b> then the current contents of the parity map will be output (in hexadecimal format) as well.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">&#45;M</b> <b class="cmd">yes</b> <i class="arg">dev</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Enable the use of a parity map on the RAID set; this is the default, and greatly reduces the time taken to check parity after unclean shutdowns at the cost of some very slight overhead during normal operation. Changes to this setting will take effect the next time the set is configured. Note that RAID-0 sets, having no parity, will not use a parity map in any case.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">&#45;M</b> <b class="cmd">no</b> <i class="arg">dev</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Disable the use of a parity map on the RAID set; doing this is not recommended. This will take effect the next time the set is configured.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">&#45;M</b> <b class="cmd">set</b> <i class="arg">cooldown</i> <i class="arg">tickms</i> <i class="arg">regions</i> <i class="arg">dev</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Alter the parameters of the parity map; parameters to leave unchanged can be given as 0, and trailing zeroes may be omitted. The RAID set is divided into <i class="arg">regions</i> regions; each region is marked dirty for at most <i class="arg">cooldown</i> intervals of <i class="arg">tickms</i> milliseconds each after a write to it, and at least <i class="arg">cooldown</i> &#45; 1 such intervals. Changes to <i class="arg">regions</i> take effect the next time is configured, while changes to the other parameters are applied immediately. The default parameters are expected to be reasonable for most workloads.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">&#45;p</b> <i class="arg">dev</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Check the status of the parity on the RAID set. Displays a status message, and returns successfully if the parity is up-to-date.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">&#45;P</b> <i class="arg">dev</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Check the status of the parity on the RAID set, and initialize (re-write) the parity if the parity is not known to be up-to-date. This is normally used after a system crash (and before a <a class="link-man" href="../8/fsck">fsck(8)</a>) to ensure the integrity of the parity.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">&#45;r</b> <i class="arg">component</i> <i class="arg">dev</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Remove the spare disk specified by <i class="arg">component</i> from the set of available spare components.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">&#45;R</b> <i class="arg">component</i> <i class="arg">dev</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Fails the specified <i class="arg">component</i>, if necessary, and immediately begins a reconstruction back to <i class="arg">component</i>. This is useful for reconstructing back onto a component after it has been replaced following a failure.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">&#45;s</b> <i class="arg">dev</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Display the status of the RAIDframe device for each of the components and spares.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">&#45;S</b> <i class="arg">dev</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Check the status of parity re-writing, component reconstruction, and component copyback. The output indicates the amount of progress achieved in each of these areas.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">&#45;u</b> <i class="arg">dev</i></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Unconfigure the RAIDframe device. This does not remove any component labels or change any configuration settings (e.g. auto-configuration settings) for the RAID set.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">&#45;v</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Be more verbose. For operations such as reconstructions, parity re-writing, and copybacks, provide a progress indicator.</dd>
</dl>
<p>
The device used by <b class="name">raidctl</b> is specified by <i class="arg">dev</i>. <i class="arg">dev</i> may be either the full name of the device, e.g., <i class="file">/dev/rraid0d</i>, for the i386 architecture, or <i class="file">/dev/rraid0c</i> for many others, or just simply <i class="file">raid0</i> (for <i class="file">/dev/rraid0[cd]</i>). It is recommended that the partitions used to represent the RAID device are not used for file systems.<div class="subsection">
<h2 id="x436f6e66696775726174696f6e2066696c65">Configuration file</h2> The format of the configuration file is complex, and only an abbreviated treatment is given here. In the configuration files, a &#8216;#&#8217; indicates the beginning of a comment.<p>
There are 4 required sections of a configuration file, and 2 optional sections. Each section begins with a &#8216;START&#8217;, followed by the section name, and the configuration parameters associated with that section. The first section is the &#8216;array&#8217; section, and it specifies the number of rows, columns, and spare disks in the RAID set. For example:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
START array 
1 3 0</pre>
<p>
indicates an array with 1 row, 3 columns, and 0 spare disks. Note that although multi-dimensional arrays may be specified, they are <span class="emph">NOT</span> supported in the driver.<p>
The second section, the &#8216;disks&#8217; section, specifies the actual components of the device. For example:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
START disks 
/dev/sd0e 
/dev/sd1e 
/dev/sd2e</pre>
<p>
specifies the three component disks to be used in the RAID device. If any of the specified drives cannot be found when the RAID device is configured, then they will be marked as &#8216;failed&#8217;, and the system will operate in degraded mode. Note that it is <span class="emph">imperative</span> that the order of the components in the configuration file does not change between configurations of a RAID device. Changing the order of the components will result in data loss if the set is configured with the <b class="flag">&#45;C</b> option. In normal circumstances, the RAID set will not configure if only <b class="flag">&#45;c</b> is specified, and the components are out-of-order.<p>
The next section, which is the &#8216;spare&#8217; section, is optional, and, if present, specifies the devices to be used as &#8216;hot spares&#8217; &#8212; devices which are on-line, but are not actively used by the RAID driver unless one of the main components fail. A simple &#8216;spare&#8217; section might be:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
START spare 
/dev/sd3e</pre>
<p>
for a configuration with a single spare component. If no spare drives are to be used in the configuration, then the &#8216;spare&#8217; section may be omitted.<p>
The next section is the &#8216;layout&#8217; section. This section describes the general layout parameters for the RAID device, and provides such information as sectors per stripe unit, stripe units per parity unit, stripe units per reconstruction unit, and the parity configuration to use. This section might look like:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
START layout 
# sectPerSU SUsPerParityUnit SUsPerReconUnit RAID_level 
32 1 1 5</pre>
<p>
The sectors per stripe unit specifies, in blocks, the interleave factor; i.e., the number of contiguous sectors to be written to each component for a single stripe. Appropriate selection of this value (32 in this example) is the subject of much research in RAID architectures. The stripe units per parity unit and stripe units per reconstruction unit are normally each set to 1. While certain values above 1 are permitted, a discussion of valid values and the consequences of using anything other than 1 are outside the scope of this document. The last value in this section (5 in this example) indicates the parity configuration desired. Valid entries include:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
0</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
RAID level 0. No parity, only simple striping.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
1</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
RAID level 1. Mirroring. The parity is the mirror.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
4</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
RAID level 4. Striping across components, with parity stored on the last component.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
5</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
RAID level 5. Striping across components, parity distributed across all components.</dd>
</dl>
<p>
There are other valid entries here, including those for Even-Odd parity, RAID level 5 with rotated sparing, Chained declustering, and Interleaved declustering, but as of this writing the code for those parity operations has not been tested with <span class="unix">NetBSD</span>.<p>
The next required section is the &#8216;queue&#8217; section. This is most often specified as:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
START queue 
fifo 100</pre>
<p>
where the queuing method is specified as fifo (first-in, first-out), and the size of the per-component queue is limited to 100 requests. Other queuing methods may also be specified, but a discussion of them is beyond the scope of this document.<p>
The final section, the &#8216;debug&#8217; section, is optional. For more details on this the reader is referred to the RAIDframe documentation discussed in the <i class="link-sec"><a class="link-sec" href="#x484953544f5259">HISTORY</a></i> section.<p>
See <i class="link-sec"><a class="link-sec" href="#x4558414d504c4553">EXAMPLES</a></i> for a more complete configuration file example.</div>
</div>
<div class="section">
<h1 id="x46494c4553">FILES</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="file">/dev/{,r}raid*</i></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
<b class="flag">raid</b> device special files.</dd>
</dl>
</div>
<div class="section">
<h1 id="x4558414d504c4553">EXAMPLES</h1> It is highly recommended that before using the RAID driver for real file systems that the system administrator(s) become quite familiar with the use of <b class="name">raidctl</b>, and that they understand how the component reconstruction process works. The examples in this section will focus on configuring a number of different RAID sets of varying degrees of redundancy. By working through these examples, administrators should be able to develop a good feel for how to configure a RAID set, and how to initiate reconstruction of failed components.<p>
In the following examples &#8216;raid0&#8217; will be used to denote the RAID device. Depending on the architecture, <i class="file">/dev/rraid0c</i> or <i class="file">/dev/rraid0d</i> may be used in place of <i class="file">raid0</i>.<div class="subsection">
<h2 id="x496e697469616c697a6174696f6e20616e6420436f6e66696775726174696f6e">Initialization and Configuration</h2> The initial step in configuring a RAID set is to identify the components that will be used in the RAID set. All components should be the same size. Each component should have a disklabel type of <span class="define">FS_RAID</span>, and a typical disklabel entry for a RAID component might look like:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
f:  1800000  200495     RAID              # (Cyl.  405*- 4041*)</pre>
<p>
While <span class="define">FS_BSDFFS</span> will also work as the component type, the type <span class="define">FS_RAID</span> is preferred for RAIDframe use, as it is required for features such as auto-configuration. As part of the initial configuration of each RAID set, each component will be given a &#8216;component label&#8217;. A &#8216;component label&#8217; contains important information about the component, including a user-specified serial number, the row and column of that component in the RAID set, the redundancy level of the RAID set, a &#8216;modification counter&#8217;, and whether the parity information (if any) on that component is known to be correct. Component labels are an integral part of the RAID set, since they are used to ensure that components are configured in the correct order, and used to keep track of other vital information about the RAID set. Component labels are also required for the auto-detection and auto-configuration of RAID sets at boot time. For a component label to be considered valid, that particular component label must be in agreement with the other component labels in the set. For example, the serial number, &#8216;modification counter&#8217;, number of rows and number of columns must all be in agreement. If any of these are different, then the component is not considered to be part of the set. See <a class="link-man" href="../4/raid">raid(4)</a> for more information about component labels.<p>
Once the components have been identified, and the disks have appropriate labels, <b class="name">raidctl</b> is then used to configure the <a class="link-man" href="../4/raid">raid(4)</a> device. To configure the device, a configuration file which looks something like:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
START array 
# numRow numCol numSpare 
1 3 1 
 
START disks 
/dev/sd1e 
/dev/sd2e 
/dev/sd3e 
 
START spare 
/dev/sd4e 
 
START layout 
# sectPerSU SUsPerParityUnit SUsPerReconUnit RAID_level_5 
32 1 1 5 
 
START queue 
fifo 100</pre>
<p>
is created in a file. The above configuration file specifies a RAID 5 set consisting of the components <i class="file">/dev/sd1e</i>, <i class="file">/dev/sd2e</i>, and <i class="file">/dev/sd3e</i>, with <i class="file">/dev/sd4e</i> available as a &#8216;hot spare&#8217; in case one of the three main drives should fail. A RAID 0 set would be specified in a similar way:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
START array 
# numRow numCol numSpare 
1 4 0 
 
START disks 
/dev/sd10e 
/dev/sd11e 
/dev/sd12e 
/dev/sd13e 
 
START layout 
# sectPerSU SUsPerParityUnit SUsPerReconUnit RAID_level_0 
64 1 1 0 
 
START queue 
fifo 100</pre>
<p>
In this case, devices <i class="file">/dev/sd10e</i>, <i class="file">/dev/sd11e</i>, <i class="file">/dev/sd12e</i>, and <i class="file">/dev/sd13e</i> are the components that make up this RAID set. Note that there are no hot spares for a RAID 0 set, since there is no way to recover data if any of the components fail.<p>
For a RAID 1 (mirror) set, the following configuration might be used:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
START array 
# numRow numCol numSpare 
1 2 0 
 
START disks 
/dev/sd20e 
/dev/sd21e 
 
START layout 
# sectPerSU SUsPerParityUnit SUsPerReconUnit RAID_level_1 
128 1 1 1 
 
START queue 
fifo 100</pre>
<p>
In this case, <i class="file">/dev/sd20e</i> and <i class="file">/dev/sd21e</i> are the two components of the mirror set. While no hot spares have been specified in this configuration, they easily could be, just as they were specified in the RAID 5 case above. Note as well that RAID 1 sets are currently limited to only 2 components. At present, n-way mirroring is not possible.<p>
The first time a RAID set is configured, the <b class="flag">&#45;C</b> option must be used:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
raidctl -C raid0.conf raid0</pre>
<p>
where <i class="file">raid0.conf</i> is the name of the RAID configuration file. The <b class="flag">&#45;C</b> forces the configuration to succeed, even if any of the component labels are incorrect. The <b class="flag">&#45;C</b> option should not be used lightly in situations other than initial configurations, as if the system is refusing to configure a RAID set, there is probably a very good reason for it. After the initial configuration is done (and appropriate component labels are added with the <b class="flag">&#45;I</b> option) then raid0 can be configured normally with:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
raidctl -c raid0.conf raid0</pre>
<p>
When the RAID set is configured for the first time, it is necessary to initialize the component labels, and to initialize the parity on the RAID set. Initializing the component labels is done with:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
raidctl -I 112341 raid0</pre>
<p>
where &#8216;112341&#8217; is a user-specified serial number for the RAID set. This initialization step is <span class="emph">required</span> for all RAID sets. As well, using different serial numbers between RAID sets is <span class="emph">strongly encouraged</span>, as using the same serial number for all RAID sets will only serve to decrease the usefulness of the component label checking.<p>
Initializing the RAID set is done via the <b class="flag">&#45;i</b> option. This initialization <span class="emph">MUST</span> be done for <span class="emph">all</span> RAID sets, since among other things it verifies that the parity (if any) on the RAID set is correct. Since this initialization may be quite time-consuming, the <b class="flag">&#45;v</b> option may be also used in conjunction with <b class="flag">&#45;i</b>:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
raidctl -iv raid0</pre>
<p>
This will give more verbose output on the status of the initialization:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
Initiating re-write of parity 
Parity Re-write status: 
 10% |****                                   | ETA:    06:03 /</pre>
<p>
The output provides a &#8216;Percent Complete&#8217; in both a numeric and graphical format, as well as an estimated time to completion of the operation.<p>
Since it is the parity that provides the &#8216;redundancy&#8217; part of RAID, it is critical that the parity is correct as much as possible. If the parity is not correct, then there is no guarantee that data will not be lost if a component fails.<p>
Once the parity is known to be correct, it is then safe to perform <a class="link-man" href="../8/disklabel">disklabel(8)</a>, <a class="link-man" href="../8/newfs">newfs(8)</a>, or <a class="link-man" href="../8/fsck">fsck(8)</a> on the device or its file systems, and then to mount the file systems for use.<p>
Under certain circumstances (e.g., the additional component has not arrived, or data is being migrated off of a disk destined to become a component) it may be desirable to configure a RAID 1 set with only a single component. This can be achieved by using the word &#8220;absent&#8221; to indicate that a particular component is not present. In the following:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
START array 
# numRow numCol numSpare 
1 2 0 
 
START disks 
absent 
/dev/sd0e 
 
START layout 
# sectPerSU SUsPerParityUnit SUsPerReconUnit RAID_level_1 
128 1 1 1 
 
START queue 
fifo 100</pre>
<p>
<i class="file">/dev/sd0e</i> is the real component, and will be the second disk of a RAID 1 set. The first component is simply marked as being absent. Configuration (using <b class="flag">&#45;C</b> and <b class="flag">&#45;I</b> <i class="arg">12345</i> as above) proceeds normally, but initialization of the RAID set will have to wait until all physical components are present. After configuration, this set can be used normally, but will be operating in degraded mode. Once a second physical component is obtained, it can be hot-added, the existing data mirrored, and normal operation resumed.<p>
The size of the resulting RAID set will depend on the number of data components in the set. Space is automatically reserved for the component labels, and the actual amount of space used for data on a component will be rounded down to the largest possible multiple of the sectors per stripe unit (sectPerSU) value. Thus, the amount of space provided by the RAID set will be less than the sum of the size of the components.</div>
<div class="subsection">
<h2 id="x4d61696e74656e616e6365206f6620746865205241494420736574">Maintenance of the RAID set</h2> After the parity has been initialized for the first time, the command:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
raidctl -p raid0</pre>
<p>
can be used to check the current status of the parity. To check the parity and rebuild it necessary (for example, after an unclean shutdown) the command:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
raidctl -P raid0</pre>
<p>
is used. Note that re-writing the parity can be done while other operations on the RAID set are taking place (e.g., while doing a <a class="link-man" href="../8/fsck">fsck(8)</a> on a file system on the RAID set). However: for maximum effectiveness of the RAID set, the parity should be known to be correct before any data on the set is modified.<p>
To see how the RAID set is doing, the following command can be used to show the RAID set's status:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
raidctl -s raid0</pre>
<p>
The output will look something like:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
Components: 
           /dev/sd1e: optimal 
           /dev/sd2e: optimal 
           /dev/sd3e: optimal 
Spares: 
           /dev/sd4e: spare 
Component label for /dev/sd1e: 
   Row: 0 Column: 0 Num Rows: 1 Num Columns: 3 
   Version: 2 Serial Number: 13432 Mod Counter: 65 
   Clean: No Status: 0 
   sectPerSU: 32 SUsPerPU: 1 SUsPerRU: 1 
   RAID Level: 5  blocksize: 512 numBlocks: 1799936 
   Autoconfig: No 
   Last configured as: raid0 
Component label for /dev/sd2e: 
   Row: 0 Column: 1 Num Rows: 1 Num Columns: 3 
   Version: 2 Serial Number: 13432 Mod Counter: 65 
   Clean: No Status: 0 
   sectPerSU: 32 SUsPerPU: 1 SUsPerRU: 1 
   RAID Level: 5  blocksize: 512 numBlocks: 1799936 
   Autoconfig: No 
   Last configured as: raid0 
Component label for /dev/sd3e: 
   Row: 0 Column: 2 Num Rows: 1 Num Columns: 3 
   Version: 2 Serial Number: 13432 Mod Counter: 65 
   Clean: No Status: 0 
   sectPerSU: 32 SUsPerPU: 1 SUsPerRU: 1 
   RAID Level: 5  blocksize: 512 numBlocks: 1799936 
   Autoconfig: No 
   Last configured as: raid0 
Parity status: clean 
Reconstruction is 100% complete. 
Parity Re-write is 100% complete. 
Copyback is 100% complete.</pre>
<p>
This indicates that all is well with the RAID set. Of importance here are the component lines which read &#8216;optimal&#8217;, and the &#8216;Parity status&#8217; line. &#8216;Parity status: clean&#8217; indicates that the parity is up-to-date for this RAID set, whether or not the RAID set is in redundant or degraded mode. &#8216;Parity status: DIRTY&#8217; indicates that it is not known if the parity information is consistent with the data, and that the parity information needs to be checked. Note that if there are file systems open on the RAID set, the individual components will not be &#8216;clean&#8217; but the set as a whole can still be clean.<p>
To check the component label of <i class="file">/dev/sd1e</i>, the following is used:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
raidctl -g /dev/sd1e raid0</pre>
<p>
The output of this command will look something like:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
Component label for /dev/sd1e: 
   Row: 0 Column: 0 Num Rows: 1 Num Columns: 3 
   Version: 2 Serial Number: 13432 Mod Counter: 65 
   Clean: No Status: 0 
   sectPerSU: 32 SUsPerPU: 1 SUsPerRU: 1 
   RAID Level: 5  blocksize: 512 numBlocks: 1799936 
   Autoconfig: No 
   Last configured as: raid0</pre>
</div>
<div class="subsection">
<h2 id="x4465616c696e67207769746820436f6d706f6e656e74204661696c75726573">Dealing with Component Failures</h2> If for some reason (perhaps to test reconstruction) it is necessary to pretend a drive has failed, the following will perform that function:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
raidctl -f /dev/sd2e raid0</pre>
<p>
The system will then be performing all operations in degraded mode, where missing data is re-computed from existing data and the parity. In this case, obtaining the status of raid0 will return (in part):<p>
<pre style="margin-left: 5.00ex;" class="lit display">
Components: 
           /dev/sd1e: optimal 
           /dev/sd2e: failed 
           /dev/sd3e: optimal 
Spares: 
           /dev/sd4e: spare</pre>
<p>
Note that with the use of <b class="flag">&#45;f</b> a reconstruction has not been started. To both fail the disk and start a reconstruction, the <b class="flag">&#45;F</b> option must be used:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
raidctl -F /dev/sd2e raid0</pre>
<p>
The <b class="flag">&#45;f</b> option may be used first, and then the <b class="flag">&#45;F</b> option used later, on the same disk, if desired. Immediately after the reconstruction is started, the status will report:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
Components: 
           /dev/sd1e: optimal 
           /dev/sd2e: reconstructing 
           /dev/sd3e: optimal 
Spares: 
           /dev/sd4e: used_spare 
[...] 
Parity status: clean 
Reconstruction is 10% complete. 
Parity Re-write is 100% complete. 
Copyback is 100% complete.</pre>
<p>
This indicates that a reconstruction is in progress. To find out how the reconstruction is progressing the <b class="flag">&#45;S</b> option may be used. This will indicate the progress in terms of the percentage of the reconstruction that is completed. When the reconstruction is finished the <b class="flag">&#45;s</b> option will show:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
Components: 
           /dev/sd1e: optimal 
           /dev/sd2e: spared 
           /dev/sd3e: optimal 
Spares: 
           /dev/sd4e: used_spare 
[...] 
Parity status: clean 
Reconstruction is 100% complete. 
Parity Re-write is 100% complete. 
Copyback is 100% complete.</pre>
<p>
At this point there are at least two options. First, if <i class="file">/dev/sd2e</i> is known to be good (i.e., the failure was either caused by <b class="flag">&#45;f</b> or <b class="flag">&#45;F</b>, or the failed disk was replaced), then a copyback of the data can be initiated with the <b class="flag">&#45;B</b> option. In this example, this would copy the entire contents of <i class="file">/dev/sd4e</i> to <i class="file">/dev/sd2e</i>. Once the copyback procedure is complete, the status of the device would be (in part):<p>
<pre style="margin-left: 5.00ex;" class="lit display">
Components: 
           /dev/sd1e: optimal 
           /dev/sd2e: optimal 
           /dev/sd3e: optimal 
Spares: 
           /dev/sd4e: spare</pre>
<p>
and the system is back to normal operation.<p>
The second option after the reconstruction is to simply use <i class="file">/dev/sd4e</i> in place of <i class="file">/dev/sd2e</i> in the configuration file. For example, the configuration file (in part) might now look like:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
START array 
1 3 0 
 
START disks 
/dev/sd1e 
/dev/sd4e 
/dev/sd3e</pre>
<p>
This can be done as <i class="file">/dev/sd4e</i> is completely interchangeable with <i class="file">/dev/sd2e</i> at this point. Note that extreme care must be taken when changing the order of the drives in a configuration. This is one of the few instances where the devices and/or their orderings can be changed without loss of data! In general, the ordering of components in a configuration file should <span class="emph">never</span> be changed.<p>
If a component fails and there are no hot spares available on-line, the status of the RAID set might (in part) look like:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
Components: 
           /dev/sd1e: optimal 
           /dev/sd2e: failed 
           /dev/sd3e: optimal 
No spares.</pre>
<p>
In this case there are a number of options. The first option is to add a hot spare using:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
raidctl -a /dev/sd4e raid0</pre>
<p>
After the hot add, the status would then be:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
Components: 
           /dev/sd1e: optimal 
           /dev/sd2e: failed 
           /dev/sd3e: optimal 
Spares: 
           /dev/sd4e: spare</pre>
<p>
Reconstruction could then take place using <b class="flag">&#45;F</b> as describe above.<p>
A second option is to rebuild directly onto <i class="file">/dev/sd2e</i>. Once the disk containing <i class="file">/dev/sd2e</i> has been replaced, one can simply use:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
raidctl -R /dev/sd2e raid0</pre>
<p>
to rebuild the <i class="file">/dev/sd2e</i> component. As the rebuilding is in progress, the status will be:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
Components: 
           /dev/sd1e: optimal 
           /dev/sd2e: reconstructing 
           /dev/sd3e: optimal 
No spares.</pre>
<p>
and when completed, will be:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
Components: 
           /dev/sd1e: optimal 
           /dev/sd2e: optimal 
           /dev/sd3e: optimal 
No spares.</pre>
<p>
In circumstances where a particular component is completely unavailable after a reboot, a special component name will be used to indicate the missing component. For example:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
Components: 
           /dev/sd2e: optimal 
          component1: failed 
No spares.</pre>
<p>
indicates that the second component of this RAID set was not detected at all by the auto-configuration code. The name &#8216;component1&#8217; can be used anywhere a normal component name would be used. For example, to add a hot spare to the above set, and rebuild to that hot spare, the following could be done:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
raidctl -a /dev/sd3e raid0 
raidctl -F component1 raid0</pre>
<p>
at which point the data missing from &#8216;component1&#8217; would be reconstructed onto <i class="file">/dev/sd3e</i>.<p>
When more than one component is marked as &#8216;failed&#8217; due to a non-component hardware failure (e.g., loss of power to two components, adapter problems, termination problems, or cabling issues) it is quite possible to recover the data on the RAID set. The first thing to be aware of is that the first disk to fail will almost certainly be out-of-sync with the remainder of the array. If any IO was performed between the time the first component is considered &#8216;failed&#8217; and when the second component is considered &#8216;failed&#8217;, then the first component to fail will <span class="emph">not</span> contain correct data, and should be ignored. When the second component is marked as failed, however, the RAID device will (currently) panic the system. At this point the data on the RAID set (not including the first failed component) is still self consistent, and will be in no worse state of repair than had the power gone out in the middle of a write to a file system on a non-RAID device. The problem, however, is that the component labels may now have 3 different &#8216;modification counters&#8217; (one value on the first component that failed, one value on the second component that failed, and a third value on the remaining components). In such a situation, the RAID set will not autoconfigure, and can only be forcibly re-configured with the <b class="flag">&#45;C</b> option. To recover the RAID set, one must first remedy whatever physical problem caused the multiple-component failure. After that is done, the RAID set can be restored by forcibly configuring the raid set <span class="emph">without</span> the component that failed first. For example, if <i class="file">/dev/sd1e</i> and <i class="file">/dev/sd2e</i> fail (in that order) in a RAID set of the following configuration:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
START array 
1 4 0 
 
START disks 
/dev/sd1e 
/dev/sd2e 
/dev/sd3e 
/dev/sd4e 
 
START layout 
# sectPerSU SUsPerParityUnit SUsPerReconUnit RAID_level_5 
64 1 1 5 
 
START queue 
fifo 100 
</pre>
<p>
then the following configuration (say "recover_raid0.conf")<p>
<pre style="margin-left: 5.00ex;" class="lit display">
START array 
1 4 0 
 
START disks 
absent 
/dev/sd2e 
/dev/sd3e 
/dev/sd4e 
 
START layout 
# sectPerSU SUsPerParityUnit SUsPerReconUnit RAID_level_5 
64 1 1 5 
 
START queue 
fifo 100</pre>
<p>
can be used with<p>
<pre style="margin-left: 5.00ex;" class="lit display">
raidctl -C recover_raid0.conf raid0</pre>
<p>
to force the configuration of raid0. A<p>
<pre style="margin-left: 5.00ex;" class="lit display">
raidctl -I 12345 raid0</pre>
<p>
will be required in order to synchronize the component labels. At this point the file systems on the RAID set can then be checked and corrected. To complete the re-construction of the RAID set, <i class="file">/dev/sd1e</i> is simply hot-added back into the array, and reconstructed as described earlier.</div>
<div class="subsection">
<h2 id="x52414944206f6e2052414944">RAID on RAID</h2> RAID sets can be layered to create more complex and much larger RAID sets. A RAID 0 set, for example, could be constructed from four RAID 5 sets. The following configuration file shows such a setup:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
START array 
# numRow numCol numSpare 
1 4 0 
 
START disks 
/dev/raid1e 
/dev/raid2e 
/dev/raid3e 
/dev/raid4e 
 
START layout 
# sectPerSU SUsPerParityUnit SUsPerReconUnit RAID_level_0 
128 1 1 0 
 
START queue 
fifo 100</pre>
<p>
A similar configuration file might be used for a RAID 0 set constructed from components on RAID 1 sets. In such a configuration, the mirroring provides a high degree of redundancy, while the striping provides additional speed benefits.</div>
<div class="subsection">
<h2 id="x4175746f1e636f6e66696775726174696f6e20616e6420526f6f74206f6e2052414944">Auto-configuration and Root on RAID</h2> RAID sets can also be auto-configured at boot. To make a set auto-configurable, simply prepare the RAID set as above, and then do a:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
raidctl -A yes raid0</pre>
<p>
to turn on auto-configuration for that set. To turn off auto-configuration, use:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
raidctl -A no raid0</pre>
<p>
RAID sets which are auto-configurable will be configured before the root file system is mounted. These RAID sets are thus available for use as a root file system, or for any other file system. A primary advantage of using the auto-configuration is that RAID components become more independent of the disks they reside on. For example, SCSI ID's can change, but auto-configured sets will always be configured correctly, even if the SCSI ID's of the component disks have become scrambled.<p>
Having a system's root file system (<i class="file">/</i>) on a RAID set is also allowed, with the &#8216;a&#8217; partition of such a RAID set being used for <i class="file">/</i>. To use raid0a as the root file system, simply use:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
raidctl -A forceroot raid0</pre>
<p>
To return raid0a to be just an auto-configuring set simply use the <b class="flag">&#45;A</b> <i class="arg">yes</i> arguments.<p>
Note that kernels can only be directly read from RAID 1 components on architectures that support that (currently alpha, i386, pmax, sandpoint, sparc, sparc64, and vax). On those architectures, the <span class="define">FS_RAID</span> file system is recognized by the bootblocks, and will properly load the kernel directly from a RAID 1 component. For other architectures, or to support the root file system on other RAID sets, some other mechanism must be used to get a kernel booting. For example, a small partition containing only the secondary boot-blocks and an alternate kernel (or two) could be used. Once a kernel is booting however, and an auto-configuring RAID set is found that is eligible to be root, then that RAID set will be auto-configured and used as the root device. If two or more RAID sets claim to be root devices, then the user will be prompted to select the root device. At this time, RAID 0, 1, 4, and 5 sets are all supported as root devices.<p>
A typical RAID 1 setup with root on RAID might be as follows:<ol style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-enum">
<li class="list-enum" style="margin-top: 1.00em;">
wd0a - a small partition, which contains a complete, bootable, basic <span class="unix">NetBSD</span> installation.</li>
<li class="list-enum" style="margin-top: 1.00em;">
wd1a - also contains a complete, bootable, basic <span class="unix">NetBSD</span> installation.</li>
<li class="list-enum" style="margin-top: 1.00em;">
wd0e and wd1e - a RAID 1 set, raid0, used for the root file system.</li>
<li class="list-enum" style="margin-top: 1.00em;">
wd0f and wd1f - a RAID 1 set, raid1, which will be used only for swap space.</li>
<li class="list-enum" style="margin-top: 1.00em;">
wd0g and wd1g - a RAID 1 set, raid2, used for <i class="file">/usr</i>, <i class="file">/home</i>, or other data, if desired.</li>
<li class="list-enum" style="margin-top: 1.00em;">
wd0h and wd1h - a RAID 1 set, raid3, if desired.</li>
</ol>
<p>
RAID sets raid0, raid1, and raid2 are all marked as auto-configurable. raid0 is marked as being a root file system. When new kernels are installed, the kernel is not only copied to <i class="file">/</i>, but also to wd0a and wd1a. The kernel on wd0a is required, since that is the kernel the system boots from. The kernel on wd1a is also required, since that will be the kernel used should wd0 fail. The important point here is to have redundant copies of the kernel available, in the event that one of the drives fail.<p>
There is no requirement that the root file system be on the same disk as the kernel. For example, obtaining the kernel from wd0a, and using sd0e and sd1e for raid0, and the root file system, is fine. It <span class="emph">is</span> critical, however, that there be multiple kernels available, in the event of media failure.<p>
Multi-layered RAID devices (such as a RAID 0 set made up of RAID 1 sets) are <span class="emph">not</span> supported as root devices or auto-configurable devices at this point. (Multi-layered RAID devices <span class="emph">are</span> supported in general, however, as mentioned earlier.) Note that in order to enable component auto-detection and auto-configuration of RAID devices, the line:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
options    RAID_AUTOCONFIG</pre>
<p>
must be in the kernel configuration file. See <a class="link-man" href="../4/raid">raid(4)</a> for more details.</div>
<div class="subsection">
<h2 id="x5377617070696e67206f6e2052414944">Swapping on RAID</h2> A RAID device can be used as a swap device. In order to ensure that a RAID device used as a swap device is correctly unconfigured when the system is shutdown or rebooted, it is recommended that the line<p>
<pre style="margin-left: 5.00ex;" class="lit display">
swapoff=YES</pre>
<p>
be added to <i class="file">/etc/rc.conf</i>.</div>
<div class="subsection">
<h2 id="x556e636f6e66696775726174696f6e">Unconfiguration</h2> The final operation performed by <b class="name">raidctl</b> is to unconfigure a <a class="link-man" href="../4/raid">raid(4)</a> device. This is accomplished via a simple:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
raidctl -u raid0</pre>
<p>
at which point the device is ready to be reconfigured.</div>
<div class="subsection">
<h2 id="x506572666f726d616e63652054756e696e67">Performance Tuning</h2> Selection of the various parameter values which result in the best performance can be quite tricky, and often requires a bit of trial-and-error to get those values most appropriate for a given system. A whole range of factors come into play, including:<ol style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-enum">
<li class="list-enum" style="margin-top: 1.00em;">
Types of components (e.g., SCSI vs. IDE) and their bandwidth</li>
<li class="list-enum" style="margin-top: 1.00em;">
Types of controller cards and their bandwidth</li>
<li class="list-enum" style="margin-top: 1.00em;">
Distribution of components among controllers</li>
<li class="list-enum" style="margin-top: 1.00em;">
IO bandwidth</li>
<li class="list-enum" style="margin-top: 1.00em;">
file system access patterns</li>
<li class="list-enum" style="margin-top: 1.00em;">
CPU speed</li>
</ol>
<p>
As with most performance tuning, benchmarking under real-life loads may be the only way to measure expected performance. Understanding some of the underlying technology is also useful in tuning. The goal of this section is to provide pointers to those parameters which may make significant differences in performance.<p>
For a RAID 1 set, a SectPerSU value of 64 or 128 is typically sufficient. Since data in a RAID 1 set is arranged in a linear fashion on each component, selecting an appropriate stripe size is somewhat less critical than it is for a RAID 5 set. However: a stripe size that is too small will cause large IO's to be broken up into a number of smaller ones, hurting performance. At the same time, a large stripe size may cause problems with concurrent accesses to stripes, which may also affect performance. Thus values in the range of 32 to 128 are often the most effective.<p>
Tuning RAID 5 sets is trickier. In the best case, IO is presented to the RAID set one stripe at a time. Since the entire stripe is available at the beginning of the IO, the parity of that stripe can be calculated before the stripe is written, and then the stripe data and parity can be written in parallel. When the amount of data being written is less than a full stripe worth, the &#8216;small write&#8217; problem occurs. Since a &#8216;small write&#8217; means only a portion of the stripe on the components is going to change, the data (and parity) on the components must be updated slightly differently. First, the &#8216;old parity&#8217; and &#8216;old data&#8217; must be read from the components. Then the new parity is constructed, using the new data to be written, and the old data and old parity. Finally, the new data and new parity are written. All this extra data shuffling results in a serious loss of performance, and is typically 2 to 4 times slower than a full stripe write (or read). To combat this problem in the real world, it may be useful to ensure that stripe sizes are small enough that a &#8216;large IO&#8217; from the system will use exactly one large stripe write. As is seen later, there are some file system dependencies which may come into play here as well.<p>
Since the size of a &#8216;large IO&#8217; is often (currently) only 32K or 64K, on a 5-drive RAID 5 set it may be desirable to select a SectPerSU value of 16 blocks (8K) or 32 blocks (16K). Since there are 4 data sectors per stripe, the maximum data per stripe is 64 blocks (32K) or 128 blocks (64K). Again, empirical measurement will provide the best indicators of which values will yield better performance.<p>
The parameters used for the file system are also critical to good performance. For <a class="link-man" href="../8/newfs">newfs(8)</a>, for example, increasing the block size to 32K or 64K may improve performance dramatically. As well, changing the cylinders-per-group parameter from 16 to 32 or higher is often not only necessary for larger file systems, but may also have positive performance implications.</div>
<div class="subsection">
<h2 id="x53756d6d617279">Summary</h2> Despite the length of this man-page, configuring a RAID set is a relatively straight-forward process. All that needs to be done is the following steps:<ol style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-enum">
<li class="list-enum" style="margin-top: 1.00em;">
Use <a class="link-man" href="../8/disklabel">disklabel(8)</a> to create the components (of type RAID).</li>
<li class="list-enum" style="margin-top: 1.00em;">
Construct a RAID configuration file: e.g., <i class="file">raid0.conf</i></li>
<li class="list-enum" style="margin-top: 1.00em;">
Configure the RAID set with:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
raidctl -C raid0.conf raid0</pre>
</li>
<li class="list-enum" style="margin-top: 1.00em;">
Initialize the component labels with:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
raidctl -I 123456 raid0</pre>
</li>
<li class="list-enum" style="margin-top: 1.00em;">
Initialize other important parts of the set with:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
raidctl -i raid0</pre>
</li>
<li class="list-enum" style="margin-top: 1.00em;">
Get the default label for the RAID set:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
disklabel raid0 &gt; /tmp/label</pre>
</li>
<li class="list-enum" style="margin-top: 1.00em;">
Edit the label:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
vi /tmp/label</pre>
</li>
<li class="list-enum" style="margin-top: 1.00em;">
Put the new label on the RAID set:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
disklabel -R -r raid0 /tmp/label</pre>
</li>
<li class="list-enum" style="margin-top: 1.00em;">
Create the file system:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
newfs /dev/rraid0e</pre>
</li>
<li class="list-enum" style="margin-top: 1.00em;">
Mount the file system:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
mount /dev/raid0e /mnt</pre>
</li>
<li class="list-enum" style="margin-top: 1.00em;">
Use:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
raidctl -c raid0.conf raid0</pre>
<p>
To re-configure the RAID set the next time it is needed, or put <i class="file">raid0.conf</i> into <i class="file">/etc</i> where it will automatically be started by the <i class="file">/etc/rc.d</i> scripts.</li>
</ol>
</div>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../4/ccd">ccd(4)</a>, <a class="link-man" href="../4/raid">raid(4)</a>, <a class="link-man" href="../8/rc">rc(8)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> RAIDframe is a framework for rapid prototyping of RAID structures developed by the folks at the Parallel Data Laboratory at Carnegie Mellon University (CMU). A more complete description of the internals and functionality of RAIDframe is found in the paper "RAIDframe: A Rapid Prototyping Tool for RAID Systems", by William V. Courtright II, Garth Gibson, Mark Holland, LeAnn Neal Reilly, and Jim Zelenka, and published by the Parallel Data Laboratory of Carnegie Mellon University.<p>
The <b class="name">raidctl</b> command first appeared as a program in CMU's RAIDframe v1.1 distribution. This version of <b class="name">raidctl</b> is a complete re-write, and first appeared in <span class="unix">NetBSD&#160;1.4</span>.</div>
<div class="section">
<h1 id="x434f50595249474854">COPYRIGHT</h1><pre style="margin-left: 0.00ex;" class="lit display">
The RAIDframe Copyright is as follows: 
 
Copyright (c) 1994-1996 Carnegie-Mellon University. 
All rights reserved. 
 
Permission to use, copy, modify and distribute this software and 
its documentation is hereby granted, provided that both the copyright 
notice and this permission notice appear in all copies of the 
software, derivative works or modified versions, and any portions 
thereof, and that both notices appear in supporting documentation. 
 
CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE. 
 
Carnegie Mellon requests users of this software to return to 
 
 Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU 
 School of Computer Science 
 Carnegie Mellon University 
 Pittsburgh PA 15213-3890 
 
any improvements or extensions that they make and grant Carnegie the 
rights to redistribute these changes.</pre>
</div>
<div class="section">
<h1 id="x5741524e494e4753">WARNINGS</h1> Certain RAID levels (1, 4, 5, 6, and others) can protect against some data loss due to component failure. However the loss of two components of a RAID 4 or 5 system, or the loss of a single component of a RAID 0 system will result in the entire file system being lost. RAID is <span class="emph">NOT</span> a substitute for good backup practices.<p>
Recomputation of parity <span class="emph">MUST</span> be performed whenever there is a chance that it may have been compromised. This includes after system crashes, or before a RAID device has been used for the first time. Failure to keep parity correct will be catastrophic should a component ever fail &#8212; it is better to use RAID 0 and get the additional space and speed, than it is to use parity, but not keep the parity correct. At least with RAID 0 there is no perception of increased data security.<p>
When replacing a failed component of a RAID set, it is a good idea to zero out the first 64 blocks of the new component to insure the RAIDframe driver doesn't erroneously detect a component label in the new component. This is particularly true on <span class="emph">RAID 1</span> sets because there is at most one correct component label in a failed RAID 1 installation, and the RAIDframe driver picks the component label with the highest serial number and modification value as the authoritative source for the failed RAID set when choosing which component label to use to configure the RAID set.</div>
<div class="section">
<h1 id="x42554753">BUGS</h1> Hot-spare removal is currently not available.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
June 30, 2015</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

