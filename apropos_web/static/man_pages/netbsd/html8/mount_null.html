<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/../4/strict.dtd">
>
<head>
<meta http-equiv="Content-Type" content="te../; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
MOUNT_NULL(8)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
MOUNT_NULL(8)</td>
<td class="head-vol" align="center">
System Manager's Manual</td>
<td class="head-rtitle" align="right">
MOUNT_NULL(8)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">mount_null</b> &#8212; <span class="desc">mount a loopback filesystem sub-tree; demonstrate the use of a null file system layer</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1><table class="synopsis">
<col style="width: 10.00ex;">
<col>
<tbody>
<tr>
<td>
mount_null</td>
<td>
&#91;<span class="opt"><b class="flag">&#45;o</b> <i class="arg">options</i></span>&#93; <i class="arg">target</i> <i class="arg">mount-point</i></td>
</tr>
</tbody>
</table>
</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <b class="name">mount_null</b> command creates a null layer, duplicating a sub-tree of the file system name space under another part of the global file system namespace. This allows existing files and directories to be accessed using a different pathname.<p>
The primary differences between a virtual copy of the filesystem and a symbolic link are that <a class="link-man" href="../3/getcwd">getcwd(3)</a> functions correctly in the virtual copy, and that other filesystems may be mounted on the virtual copy without affecting the original. A different device number for the virtual copy is returned by <a class="link-man" href="../2/stat">stat(2)</a>, but in other respects it is indistinguishable from the original.<p>
The <b class="name">mount_null</b> filesystem differs from a traditional loopback file system in two respects: it is implemented using a stackable layers technique, and its &#8220;null-nodes&#8221; stack above all lower-layer vnodes (not just above directory vnodes).<p>
Both <i class="arg">target</i> and <i class="arg">mount-point</i> are converted to absolute paths before use.<p>
The options are as follows:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">&#45;o</b></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Options are specified with a <b class="flag">&#45;o</b> flag followed by a comma separated string of options. See the <a class="link-man" href="../8/mount">mount(8)</a> man page for possible options and their meanings.</dd>
</dl>
<p>
The null layer has two purposes. First, it serves as a demonstration of layering by providing a layer which does nothing. Second, the null layer can serve as a prototype layer. Since it provides all necessary layer framework, new file system layers can be created very easily by starting with a null layer.<p>
The remainder of this man page examines the null layer as a basis for constructing new layers.</div>
<div class="section">
<h1 id="x494e5354414e54494154494e47204e4557204e554c4c204c4159455253">INSTANTIATING NEW NULL LAYERS</h1> New null layers are created with <b class="name">mount_null</b>. <b class="name">mount_null</b> takes two arguments, the pathname of the lower vfs (target-pn) and the pathname where the null layer will appear in the namespace (mount-point-pn). After the null layer is put into place, the contents of target-pn subtree will be aliased under mount-point-pn.</div>
<div class="section">
<h1 id="x4f5045524154494f4e204f462041204e554c4c204c41594552">OPERATION OF A NULL LAYER</h1> The null layer is the minimum file system layer, simply passing all possible operations to the lower layer for processing there. The majority of its activity centers on the bypass routine, through which nearly all vnode operations pass.<p>
The bypass routine accepts arbitrary vnode operations for handling by the lower layer. It begins by examining vnode operation arguments and replacing any null-nodes by their lower-layer equivalents. It then invokes the operation on the lower layer. Finally, it replaces the null-nodes in the arguments and, if a vnode is returned by the operation, stacks a null-node on top of the returned vnode.<p>
Although bypass handles most operations, <span class="emph">vop_getattr</span>, <span class="emph">vop_inactive</span>, <span class="emph">vop_reclaim</span>, and <span class="emph">vop_print</span> are not bypassed. <span class="emph">vop_getattr</span> must change the fsid being returned. <span class="emph">vop_inactive</span> and vop_reclaim are not bypassed so that they can handle freeing null-layer specific data. <span class="emph">vop_print</span> is not bypassed to avoid excessive debugging information.</div>
<div class="section">
<h1 id="x494e5354414e54494154494e4720564e4f444520535441434b53">INSTANTIATING VNODE STACKS</h1> Mounting associates the null layer with a lower layer, in effect stacking two VFSes. Vnode stacks are instead created on demand as files are accessed.<p>
The initial mount creates a single vnode stack for the root of the new null layer. All other vnode stacks are created as a result of vnode operations on this or other null vnode stacks.<p>
New vnode stacks come into existence as a result of an operation which returns a vnode. The bypass routine stacks a null-node above the new vnode before returning it to the caller.<p>
For example, imagine mounting a null layer with<p>
<pre style="margin-left: 5.00ex;" class="lit display">
mount_null /usr/include /dev/layer/null</pre>
Changing directory to <i class="file">/dev/layer/null</i> will assign the root null-node (which was created when the null layer was mounted). Now consider opening <i class="file">sys</i>. A vop_lookup would be done on the root null-node. This operation would bypass through to the lower layer which would return a vnode representing the UFS <i class="file">sys</i>. null_bypass then builds a null-node aliasing the UFS <i class="file">sys</i> and returns this to the caller. Later operations on the null-node <i class="file">sys</i> will repeat this process when constructing other vnode stacks.</div>
<div class="section">
<h1 id="x4352454154494e47204f544845522046494c452053595354454d204c4159455253">CREATING OTHER FILE SYSTEM LAYERS</h1> One of the easiest ways to construct new file system layers is to make a copy of the null layer, rename all files and variables, and then begin modifying the copy. <a class="link-man" href="../1/sed">sed(1)</a> can be used to easily rename all variables.<p>
The umap layer is an example of a layer descended from the null layer.</div>
<div class="section">
<h1 id="x494e564f4b494e47204f5045524154494f4e53204f4e204c4f574552204c4159455253">INVOKING OPERATIONS ON LOWER LAYERS</h1> There are two techniques to invoke operations on a lower layer when the operation cannot be completely bypassed. Each method is appropriate in different situations. In both cases, it is the responsibility of the aliasing layer to make the operation arguments "correct" for the lower layer by mapping any vnode arguments to the lower layer.<p>
The first approach is to call the aliasing layer's bypass routine. This method is most suitable when you wish to invoke the operation currently being handled on the lower layer. It has the advantage that the bypass routine already must do argument mapping. An example of this is <span class="emph">null_getattrs</span> in the null layer.<p>
A second approach is to directly invoke vnode operations on the lower layer with the <span class="emph">VOP_OPERATIONNAME</span> interface. The advantage of this method is that it is easy to invoke arbitrary operations on the lower layer. The disadvantage is that vnode arguments must be manually mapped.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../8/mount">mount(8)</a><p>
UCLA Technical Report CSD-910056, <span class="emph">Stackable Layers: an Architecture for File System Development</span>.</div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The <b class="name">mount_null</b> utility first appeared in <span class="unix">4.4BSD</span>.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
May 1, 1995</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
<>

