<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="/static/man_pages/netbsd/style.css" type="text/css" media="all">
<title>
BPF(4)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
BPF(4)</td>
<td class="head-vol" align="center">
Kernel Interfaces Manual</td>
<td class="head-rtitle" align="right">
BPF(4)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">bpf</b> &#8212; <span class="desc">Berkeley Packet Filter raw network interface</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="config">pseudo-device bpfilter</b></div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The Berkeley Packet Filter provides a raw interface to data link layers in a protocol independent fashion. All packets on the network, even those destined for other hosts, are accessible through this mechanism.<p>
The packet filter appears as a character special device, <i class="file">/dev/bpf</i>. After opening the device, the file descriptor must be bound to a specific network interface with the <span class="define">BIOCSETIF</span> ioctl. A given interface can be shared by multiple listeners, and the filter underlying each descriptor will see an identical packet stream.<p>
Associated with each open instance of a <b class="name">bpf</b> file is a user-settable packet filter. Whenever a packet is received by an interface, all file descriptors listening on that interface apply their filter. Each descriptor that accepts the packet receives its own copy.<p>
Reads from these files return the next group of packets that have matched the filter. To improve performance, the buffer passed to read must be the same size as the buffers used internally by <b class="name">bpf</b>. This size is returned by the <span class="define">BIOCGBLEN</span> ioctl (see below), and can be set with <span class="define">BIOCSBLEN</span>. Note that an individual packet larger than this size is necessarily truncated.<p>
Since packet data is in network byte order, applications should use the <a class="link-man" href="../3/byteorder">byteorder(3)</a> macros to extract multi-byte values.<p>
A packet can be sent out on the network by writing to a <b class="name">bpf</b> file descriptor. The writes are unbuffered, meaning only one packet can be processed per write. Currently, only writes to Ethernets and SLIP links are supported.</div>
<div class="section">
<h1 id="x494f43544c53">IOCTLS</h1> The <a class="link-man" href="../2/ioctl">ioctl(2)</a> command codes below are defined in <b class="includes">&lt;<a class="link-includes">net/bpf.h</a>&gt;</b>. All commands require these includes:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
#include &lt;sys/types.h&gt; 
#include &lt;sys/time.h&gt; 
#include &lt;sys/ioctl.h&gt; 
#include &lt;net/bpf.h&gt;</pre>
<p>
Additionally, <span class="define">BIOCGETIF</span> and <span class="define">BIOCSETIF</span> require <i class="file">&lt;net/if.h&gt;</i>.<p>
The (third) argument to the <a class="link-man" href="../2/ioctl">ioctl(2)</a> should be a pointer to the type indicated.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">BIOCGBLEN (u_int)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Returns the required buffer length for reads on <b class="name">bpf</b> files.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">BIOCSBLEN (u_int)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Sets the buffer length for reads on <b class="name">bpf</b> files. The buffer must be set before the file is attached to an interface with <span class="define">BIOCSETIF</span>. If the requested buffer size cannot be accommodated, the closest allowable size will be set and returned in the argument. A read call will result in <span class="errno">EINVAL</span> if it is passed a buffer that is not this size.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">BIOCGDLT (u_int)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Returns the type of the data link layer underlying the attached interface. <span class="errno">EINVAL</span> is returned if no interface has been specified. The device types, prefixed with &#8220;DLT_&#8221;, are defined in <b class="includes">&lt;<a class="link-includes">net/bpf.h</a>&gt;</b>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">BIOCGDLTLIST (struct bpf_dltlist)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Returns an array of the available types of the data link layer underlying the attached interface:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
struct bpf_dltlist { 
	u_int bfl_len; 
	u_int *bfl_list; 
};</pre>
<p>
The available types are returned in the array pointed to by the <b class="var">bfl_list</b> field while their length in u_int is supplied to the <b class="var">bfl_len</b> field. <span class="errno">ENOMEM</span> is returned if there is not enough buffer space and <span class="errno">EFAULT</span> is returned if a bad address is encountered. The <b class="var">bfl_len</b> field is modified on return to indicate the actual length in u_int of the array returned. If <b class="var">bfl_list</b> is <span class="define">NULL</span>, the <b class="var">bfl_len</b> field is set to indicate the required length of an array in u_int.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">BIOCSDLT (u_int)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Changes the type of the data link layer underlying the attached interface. <span class="errno">EINVAL</span> is returned if no interface has been specified or the specified type is not available for the interface.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">BIOCPROMISC</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Forces the interface into promiscuous mode. All packets, not just those destined for the local host, are processed. Since more than one file can be listening on a given interface, a listener that opened its interface non-promiscuously may receive packets promiscuously. This problem can be remedied with an appropriate filter.<p>
The interface remains in promiscuous mode until all files listening promiscuously are closed.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">BIOCFLUSH</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Flushes the buffer of incoming packets, and resets the statistics that are returned by <span class="define">BIOCGSTATS</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">BIOCGETIF (struct ifreq)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Returns the name of the hardware interface that the file is listening on. The name is returned in the ifr_name field of <i class="farg">ifr</i>. All other fields are undefined.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">BIOCSETIF (struct ifreq)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Sets the hardware interface associated with the file. This command must be performed before any packets can be read. The device is indicated by name using the <span class="define">ifr_name</span> field of the <i class="farg">ifreq</i>. Additionally, performs the actions of <span class="define">BIOCFLUSH</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">BIOCSRTIMEOUT, BIOCGRTIMEOUT (struct timeval)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Sets or gets the read timeout parameter. The <i class="farg">timeval</i> specifies the length of time to wait before timing out on a read request. This parameter is initialized to zero by <a class="link-man" href="../2/open">open(2)</a>, indicating no timeout.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">BIOCGSTATS (struct bpf_stat)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Returns the following structure of packet statistics:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
struct bpf_stat { 
	uint64_t bs_recv; 
	uint64_t bs_drop; 
	uint64_t bs_capt; 
	uint64_t bs_padding[13]; 
};</pre>
<p>
The fields are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">bs_recv</b></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
the number of packets received by the descriptor since opened or reset (including any buffered since the last read call);</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">bs_drop</b></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
the number of packets which were accepted by the filter but dropped by the kernel because of buffer overflows (i.e., the application's reads aren't keeping up with the packet traffic); and</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">bs_capt</b></dt>
<dd class="list-tag" style="margin-left: 7.00ex;">
the number of packets accepted by the filter.</dd>
</dl>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">BIOCIMMEDIATE (u_int)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Enables or disables &#8220;immediate mode&#8221;, based on the truth value of the argument. When immediate mode is enabled, reads return immediately upon packet reception. Otherwise, a read will block until either the kernel buffer becomes full or a timeout occurs. This is useful for programs like <a class="link-man" href="../8/rarpd">rarpd(8)</a>, which must respond to messages in real time. The default for a new file is off.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">BIOCSETF (struct bpf_program)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Sets the filter program used by the kernel to discard uninteresting packets. An array of instructions and its length are passed in using the following structure:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
struct bpf_program { 
	u_int bf_len; 
	struct bpf_insn *bf_insns; 
};</pre>
<p>
The filter program is pointed to by the <b class="var">bf_insns</b> field while its length in units of &#8216;struct bpf_insn&#8217; is given by the <b class="var">bf_len</b> field. Also, the actions of <span class="define">BIOCFLUSH</span> are performed.<p>
See section <span class="symb">FILTER MACHINE</span> for an explanation of the filter language.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">BIOCVERSION (struct bpf_version)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Returns the major and minor version numbers of the filter language currently recognized by the kernel. Before installing a filter, applications must check that the current version is compatible with the running kernel. Version numbers are compatible if the major numbers match and the application minor is less than or equal to the kernel minor. The kernel version number is returned in the following structure:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
struct bpf_version { 
	u_short bv_major; 
	u_short bv_minor; 
};</pre>
<p>
The current version numbers are given by <span class="define">BPF_MAJOR_VERSION</span> and <span class="define">BPF_MINOR_VERSION</span> from <b class="includes">&lt;<a class="link-includes">net/bpf.h</a>&gt;</b>. An incompatible filter may result in undefined behavior (most likely, an error returned by <a class="link-man" href="../2/ioctl">ioctl(2)</a> or haphazard packet matching).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">BIOCSRSIG BIOCGRSIG (u_int)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Sets or gets the receive signal. This signal will be sent to the process or process group specified by <span class="define">FIOSETOWN</span>. It defaults to <span class="define">SIGIO</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">BIOCGHDRCMPLT BIOCSHDRCMPLT (u_int)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Sets or gets the status of the &#8220;header complete&#8221; flag. Set to zero if the link level source address should be filled in automatically by the interface output routine. Set to one if the link level source address will be written, as provided, to the wire. This flag is initialized to zero by default.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">BIOCGSEESENT BIOCSSEESENT (u_int)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Enable/disable or get the &#8220;see sent&#8221; flag status. If enabled, packets sent by the host (not from <b class="name">bpf</b>) will be passed to the filter. By default, the flag is enabled (value is 1).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">BIOCFEEDBACK BIOCSFEEDBACK BIOCGFEEDBACK (u_int)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Set (or get) &#8220;packet feedback mode&#8221;. This allows injected packets to be fed back as input to the interface when output via the interface is successful. The first name is meant for <span class="unix">FreeBSD</span> compatibility, the two others follow the Get/Set convention. Injected outgoing packets are not returned by BPF to avoid duplication. This flag is initialized to zero by default.</dd>
</dl>
</div>
<div class="section">
<h1 id="x5354414e4441524420494f43544c53">STANDARD IOCTLS</h1> <b class="name">bpf</b> now supports several standard <a class="link-man" href="../2/ioctl">ioctl(2)</a>'s which allow the user to do async and/or non-blocking I/O to an open <b class="name">bpf</b> file descriptor.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">FIONREAD (int)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Returns the number of bytes that are immediately available for reading.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">FIONBIO (int)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Set or clear non-blocking I/O. If arg is non-zero, then doing a <a class="link-man" href="../2/read">read(2)</a> when no data is available will return -1 and <b class="var">errno</b> will be set to <span class="errno">EAGAIN</span>. If arg is zero, non-blocking I/O is disabled. Note: setting this overrides the timeout set by <span class="define">BIOCSRTIMEOUT</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">FIOASYNC (int)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Enable or disable async I/O. When enabled (arg is non-zero), the process or process group specified by <span class="define">FIOSETOWN</span> will start receiving SIGIO's when packets arrive. Note that you must do an <span class="define">FIOSETOWN</span> in order for this to take effect, as the system will not default this for you. The signal may be changed via <span class="define">BIOCSRSIG</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">FIOSETOWN FIOGETOWN (int)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Set or get the process or process group (if negative) that should receive SIGIO when packets are available. The signal may be changed using <span class="define">BIOCSRSIG</span> (see above).</dd>
</dl>
</div>
<div class="section">
<h1 id="x42504620484541444552">BPF HEADER</h1> The following structure is prepended to each packet returned by <a class="link-man" href="../2/read">read(2)</a>:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
struct bpf_hdr { 
	struct bpf_timeval bh_tstamp; 
	uint32_t bh_caplen; 
	uint32_t bh_datalen; 
	uint16_t bh_hdrlen; 
};</pre>
<p>
The fields, whose values are stored in host order, are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">bh_tstamp</b></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
The time at which the packet was processed by the packet filter. This structure differs from the standard <span class="type">struct timeval</span> in that both members are of type <span class="type">long</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">bh_caplen</b></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
The length of the captured portion of the packet. This is the minimum of the truncation amount specified by the filter and the length of the packet.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">bh_datalen</b></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
The length of the packet off the wire. This value is independent of the truncation amount specified by the filter.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="var">bh_hdrlen</b></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
The length of the BPF header, which may not be equal to <span class="emph">sizeof(struct bpf_hdr)</span>.</dd>
</dl>
<p>
The <b class="var">bh_hdrlen</b> field exists to account for padding between the header and the link level protocol. The purpose here is to guarantee proper alignment of the packet data structures, which is required on alignment sensitive architectures and improves performance on many other architectures. The packet filter ensures that the <b class="var">bpf_hdr</b> and the <span class="emph">network layer</span> header will be word aligned. Suitable precautions must be taken when accessing the link layer protocol fields on alignment restricted machines. (This isn't a problem on an Ethernet, since the type field is a short falling on an even offset, and the addresses are probably accessed in a bytewise fashion).<p>
Additionally, individual packets are padded so that each starts on a word boundary. This requires that an application has some knowledge of how to get from packet to packet. The macro <span class="define">BPF_WORDALIGN</span> is defined in <b class="includes">&lt;<a class="link-includes">net/bpf.h</a>&gt;</b> to facilitate this process. It rounds up its argument to the nearest word aligned value (where a word is <span class="define">BPF_ALIGNMENT</span> bytes wide).<p>
For example, if &#8216;<b class="var">p</b>&#8217; points to the start of a packet, this expression will advance it to the next packet:<p>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">p = (char *)p + BPF_WORDALIGN(p-&gt;bh_hdrlen + p-&gt;bh_caplen)</code></div>
</blockquote>
<p>
For the alignment mechanisms to work properly, the buffer passed to <a class="link-man" href="../2/read">read(2)</a> must itself be word aligned. <a class="link-man" href="../3/malloc">malloc(3)</a> will always return an aligned buffer.</div>
<div class="section">
<h1 id="x46494c544552204d414348494e45">FILTER MACHINE</h1> A filter program is an array of instructions, with all branches forwardly directed, terminated by a <span class="symb">return</span> instruction. Each instruction performs some action on the pseudo-machine state, which consists of an accumulator, index register, scratch memory store, and implicit program counter.<p>
The following structure defines the instruction format:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
struct bpf_insn { 
	uint16_t code; 
	u_char 	jt; 
	u_char 	jf; 
	uint32_t k; 
};</pre>
<p>
The <b class="var">k</b> field is used in different ways by different instructions, and the <b class="var">jt</b> and <b class="var">jf</b> fields are used as offsets by the branch instructions. The opcodes are encoded in a semi-hierarchical fashion. There are eight classes of instructions: BPF_LD, BPF_LDX, BPF_ST, BPF_STX, BPF_ALU, BPF_JMP, BPF_RET, and BPF_MISC. Various other mode and operator bits are or'd into the class to give the actual instructions. The classes and modes are defined in <b class="includes">&lt;<a class="link-includes">net/bpf.h</a>&gt;</b>.<p>
Below are the semantics for each defined BPF instruction. We use the convention that A is the accumulator, X is the index register, P[] packet data, and M[] scratch memory store. P[i:n] gives the data at byte offset &#8220;i&#8221; in the packet, interpreted as a word (n=4), unsigned halfword (n=2), or unsigned byte (n=1). M[i] gives the i'th word in the scratch memory store, which is only addressed in word units. The memory store is indexed from 0 to BPF_MEMWORDS-1. <b class="var">k</b>, <b class="var">jt</b>, and <b class="var">jf</b> are the corresponding fields in the instruction definition. &#8220;len&#8221; refers to the length of the packet.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="symb">BPF_LD</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
These instructions copy a value into the accumulator. The type of the source operand is specified by an &#8220;addressing mode&#8221; and can be a constant (<span class="symb">BPF_IMM</span>), packet data at a fixed offset (<span class="symb">BPF_ABS</span>), packet data at a variable offset (<span class="symb">BPF_IND</span>), the packet length (<span class="symb">BPF_LEN</span>), or a word in the scratch memory store (<span class="symb">BPF_MEM</span>). For <span class="symb">BPF_IND</span> and <span class="symb">BPF_ABS</span>, the data size must be specified as a word (<span class="symb">BPF_W</span>), halfword (<span class="symb">BPF_H</span>), or byte (<span class="symb">BPF_B</span>). Arithmetic overflow when calculating a variable offset terminates the filter program and the packet is ignored. The semantics of all the recognized BPF_LD instructions follow.<table style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-col">
<col style="width: 20.00ex;">
<col style="min-width: 11.00ex;">
<tbody>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_LD+BPF_W+BPF_ABS</span></td>
<td class="list-col" style="margin-top: 1.00em;">
A &lt;- P[k:4]</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_LD+BPF_H+BPF_ABS</span></td>
<td class="list-col" style="margin-top: 1.00em;">
A &lt;- P[k:2]</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_LD+BPF_B+BPF_ABS</span></td>
<td class="list-col" style="margin-top: 1.00em;">
A &lt;- P[k:1]</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_LD+BPF_W+BPF_IND</span></td>
<td class="list-col" style="margin-top: 1.00em;">
A &lt;- P[X+k:4]</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_LD+BPF_H+BPF_IND</span></td>
<td class="list-col" style="margin-top: 1.00em;">
A &lt;- P[X+k:2]</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_LD+BPF_B+BPF_IND</span></td>
<td class="list-col" style="margin-top: 1.00em;">
A &lt;- P[X+k:1]</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_LD+BPF_W+BPF_LEN</span></td>
<td class="list-col" style="margin-top: 1.00em;">
A &lt;- len</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_LD+BPF_IMM</span></td>
<td class="list-col" style="margin-top: 1.00em;">
A &lt;- k</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_LD+BPF_MEM</span></td>
<td class="list-col" style="margin-top: 1.00em;">
A &lt;- M[k]</td>
</tr>
</tbody>
</table>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="symb">BPF_LDX</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
These instructions load a value into the index register. Note that the addressing modes are more restricted than those of the accumulator loads, but they include <span class="symb">BPF_MSH</span>, a hack for efficiently loading the IP header length.<table style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-col">
<col style="width: 21.00ex;">
<col style="min-width: 6.00ex;">
<tbody>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_LDX+BPF_W+BPF_IMM</span></td>
<td class="list-col" style="margin-top: 1.00em;">
X &lt;- k</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_LDX+BPF_W+BPF_MEM</span></td>
<td class="list-col" style="margin-top: 1.00em;">
X &lt;- M[k]</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_LDX+BPF_W+BPF_LEN</span></td>
<td class="list-col" style="margin-top: 1.00em;">
X &lt;- len</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_LDX+BPF_B+BPF_MSH</span></td>
<td class="list-col" style="margin-top: 1.00em;">
X &lt;- 4*(P[k:1]&amp;0xf)</td>
</tr>
</tbody>
</table>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="symb">BPF_ST</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This instruction stores the accumulator into the scratch memory. We do not need an addressing mode since there is only one possibility for the destination.<table style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-col">
<col style="width: 6.00ex;">
<col style="min-width: 9.00ex;">
<tbody>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_ST</span></td>
<td class="list-col" style="margin-top: 1.00em;">
M[k] &lt;- A</td>
</tr>
</tbody>
</table>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="symb">BPF_STX</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
This instruction stores the index register in the scratch memory store.<table style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-col">
<col style="width: 7.00ex;">
<col style="min-width: 9.00ex;">
<tbody>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_STX</span></td>
<td class="list-col" style="margin-top: 1.00em;">
M[k] &lt;- X</td>
</tr>
</tbody>
</table>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="symb">BPF_ALU</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The alu instructions perform operations between the accumulator and index register or constant, and store the result back in the accumulator. For binary operations, a source mode is required (<span class="symb">BPF_K</span> or <span class="symb">BPF_X</span>).<table style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-col">
<col style="width: 21.00ex;">
<col style="min-width: 10.00ex;">
<tbody>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_ALU+BPF_ADD+BPF_K</span></td>
<td class="list-col" style="margin-top: 1.00em;">
A &lt;- A + k</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_ALU+BPF_SUB+BPF_K</span></td>
<td class="list-col" style="margin-top: 1.00em;">
A &lt;- A - k</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_ALU+BPF_MUL+BPF_K</span></td>
<td class="list-col" style="margin-top: 1.00em;">
A &lt;- A * k</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_ALU+BPF_DIV+BPF_K</span></td>
<td class="list-col" style="margin-top: 1.00em;">
A &lt;- A / k</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_ALU+BPF_AND+BPF_K</span></td>
<td class="list-col" style="margin-top: 1.00em;">
A &lt;- A &amp; k</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_ALU+BPF_OR+BPF_K</span></td>
<td class="list-col" style="margin-top: 1.00em;">
A &lt;- A | k</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_ALU+BPF_LSH+BPF_K</span></td>
<td class="list-col" style="margin-top: 1.00em;">
A &lt;- A &lt;&lt; k</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_ALU+BPF_RSH+BPF_K</span></td>
<td class="list-col" style="margin-top: 1.00em;">
A &lt;- A &gt;&gt; k</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_ALU+BPF_ADD+BPF_X</span></td>
<td class="list-col" style="margin-top: 1.00em;">
A &lt;- A + X</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_ALU+BPF_SUB+BPF_X</span></td>
<td class="list-col" style="margin-top: 1.00em;">
A &lt;- A - X</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_ALU+BPF_MUL+BPF_X</span></td>
<td class="list-col" style="margin-top: 1.00em;">
A &lt;- A * X</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_ALU+BPF_DIV+BPF_X</span></td>
<td class="list-col" style="margin-top: 1.00em;">
A &lt;- A / X</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_ALU+BPF_AND+BPF_X</span></td>
<td class="list-col" style="margin-top: 1.00em;">
A &lt;- A &amp; X</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_ALU+BPF_OR+BPF_X</span></td>
<td class="list-col" style="margin-top: 1.00em;">
A &lt;- A | X</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_ALU+BPF_LSH+BPF_X</span></td>
<td class="list-col" style="margin-top: 1.00em;">
A &lt;- A &lt;&lt; X</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_ALU+BPF_RSH+BPF_X</span></td>
<td class="list-col" style="margin-top: 1.00em;">
A &lt;- A &gt;&gt; X</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_ALU+BPF_NEG</span></td>
<td class="list-col" style="margin-top: 1.00em;">
A &lt;- -A</td>
</tr>
</tbody>
</table>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="symb">BPF_JMP</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The jump instructions alter flow of control. Conditional jumps compare the accumulator against a constant (<span class="symb">BPF_K</span>) or the index register (<span class="symb">BPF_X</span>). If the result is true (or non-zero), the true branch is taken, otherwise the false branch is taken. Jump offsets are encoded in 8 bits so the longest jump is 256 instructions. However, the jump always (<span class="symb">BPF_JA</span>) opcode uses the 32 bit <b class="var">k</b> field as the offset, allowing arbitrarily distant destinations. All conditionals use unsigned comparison conventions.<table style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-col">
<col style="width: 21.00ex;">
<col style="min-width: 23.00ex;">
<tbody>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_JMP+BPF_JA</span></td>
<td class="list-col" style="margin-top: 1.00em;">
pc += k</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_JMP+BPF_JGT+BPF_K</span></td>
<td class="list-col" style="margin-top: 1.00em;">
pc += (A &gt; k) ? jt : jf</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_JMP+BPF_JGE+BPF_K</span></td>
<td class="list-col" style="margin-top: 1.00em;">
pc += (A &#8805; k) ? jt : jf</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_JMP+BPF_JEQ+BPF_K</span></td>
<td class="list-col" style="margin-top: 1.00em;">
pc += (A == k) ? jt : jf</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_JMP+BPF_JSET+BPF_K</span></td>
<td class="list-col" style="margin-top: 1.00em;">
pc += (A &amp; k) ? jt : jf</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_JMP+BPF_JGT+BPF_X</span></td>
<td class="list-col" style="margin-top: 1.00em;">
pc += (A &gt; X) ? jt : jf</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_JMP+BPF_JGE+BPF_X</span></td>
<td class="list-col" style="margin-top: 1.00em;">
pc += (A &#8805; X) ? jt : jf</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_JMP+BPF_JEQ+BPF_X</span></td>
<td class="list-col" style="margin-top: 1.00em;">
pc += (A == X) ? jt : jf</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_JMP+BPF_JSET+BPF_X</span></td>
<td class="list-col" style="margin-top: 1.00em;">
pc += (A &amp; X) ? jt : jf</td>
</tr>
</tbody>
</table>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="symb">BPF_RET</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The return instructions terminate the filter program and specify the amount of packet to accept (i.e., they return the truncation amount). A return value of zero indicates that the packet should be ignored. The return value is either a constant (<span class="symb">BPF_K</span>) or the accumulator (<span class="symb">BPF_A</span>).<table style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-col">
<col style="width: 13.00ex;">
<col style="min-width: 14.00ex;">
<tbody>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_RET+BPF_A</span></td>
<td class="list-col" style="margin-top: 1.00em;">
accept A bytes</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_RET+BPF_K</span></td>
<td class="list-col" style="margin-top: 1.00em;">
accept k bytes</td>
</tr>
</tbody>
</table>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="symb">BPF_MISC</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
The miscellaneous category was created for anything that doesn't fit into the above classes, and for any new instructions that might need to be added. Currently, these are the register transfer instructions that copy the index register to the accumulator or vice versa.<table style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-col">
<col style="width: 16.00ex;">
<col style="min-width: 6.00ex;">
<tbody>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_MISC+BPF_TAX</span></td>
<td class="list-col" style="margin-top: 1.00em;">
X &lt;- A</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_MISC+BPF_TXA</span></td>
<td class="list-col" style="margin-top: 1.00em;">
A &lt;- X</td>
</tr>
</tbody>
</table>
<p>
Also, two instructions to call a "coprocessor" if initialized by the kernel component. There is no coprocessor by default.<table style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-col">
<col style="width: 16.00ex;">
<col style="min-width: 18.00ex;">
<tbody>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_MISC+BPF_COP</span></td>
<td class="list-col" style="margin-top: 1.00em;">
A &lt;- funcs[k](..)</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 1.00em;">
<span class="symb">BPF_MISC+BPF_COPX</span></td>
<td class="list-col" style="margin-top: 1.00em;">
A &lt;- funcs[X](..)</td>
</tr>
</tbody>
</table>
<p>
If the coprocessor is not set or the function index is out of range, these instructions will abort the program and return zero.</dd>
</dl>
<p>
The BPF interface provides the following macros to facilitate array initializers:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
<span class="symb">BPF_STMT</span> (opcode, operand) 
<span class="symb">BPF_JUMP</span> (opcode, operand, true_offset, false_offset)</pre>
</div>
<div class="section">
<h1 id="x53595343544c53">SYSCTLS</h1> The following sysctls are available when <b class="name">bpf</b> is enabled:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">net.bpf.maxbufsize</code></dt>
<dd class="list-tag" style="margin-left: 21.00ex;">
Sets the maximum buffer size available for <b class="name">bpf</b> peers.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">net.bpf.stats</code></dt>
<dd class="list-tag" style="margin-left: 21.00ex;">
Shows <b class="name">bpf</b> statistics. They can be retrieved with the <a class="link-man" href="../1/netstat">netstat(1)</a> utility.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">net.bpf.peers</code></dt>
<dd class="list-tag" style="margin-left: 21.00ex;">
Shows the current <b class="name">bpf</b> peers. This is only available to the super user and can also be retrieved with the <a class="link-man" href="../1/netstat">netstat(1)</a> utility.</dd>
</dl>
<p>
On architectures with <a class="link-man" href="../4/bpfjit">bpfjit(4)</a> support, the additional sysctl is available:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">net.bpf.jit</code></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
Toggle <span class="symb">Just-In-Time</span> compilation of new filter programs. In order to enable Just-In-Time compilation, the bpfjit kernel module must be loaded. Changing a value of this sysctl doesn't affect existing filter programs.</dd>
</dl>
</div>
<div class="section">
<h1 id="x46494c4553">FILES</h1> <i class="file">/dev/bpf</i></div>
<div class="section">
<h1 id="x4558414d504c4553">EXAMPLES</h1> The following filter is taken from the Reverse ARP Daemon. It accepts only Reverse ARP requests.<p>
<pre style="margin-left: 5.00ex;" class="lit display">
struct bpf_insn insns[] = { 
	BPF_STMT(BPF_LD+BPF_H+BPF_ABS, 12), 
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, ETHERTYPE_REVARP, 0, 3), 
	BPF_STMT(BPF_LD+BPF_H+BPF_ABS, 20), 
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, REVARP_REQUEST, 0, 1), 
	BPF_STMT(BPF_RET+BPF_K, sizeof(struct ether_arp) + 
	    sizeof(struct ether_header)), 
	BPF_STMT(BPF_RET+BPF_K, 0), 
};</pre>
<p>
This filter accepts only IP packets between host 128.3.112.15 and 128.3.112.35.<p>
<pre style="margin-left: 5.00ex;" class="lit display">
struct bpf_insn insns[] = { 
	BPF_STMT(BPF_LD+BPF_H+BPF_ABS, 12), 
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, ETHERTYPE_IP, 0, 8), 
	BPF_STMT(BPF_LD+BPF_W+BPF_ABS, 26), 
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x8003700f, 0, 2), 
	BPF_STMT(BPF_LD+BPF_W+BPF_ABS, 30), 
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x80037023, 3, 4), 
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x80037023, 0, 3), 
	BPF_STMT(BPF_LD+BPF_W+BPF_ABS, 30), 
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x8003700f, 0, 1), 
	BPF_STMT(BPF_RET+BPF_K, (u_int)-1), 
	BPF_STMT(BPF_RET+BPF_K, 0), 
};</pre>
<p>
Finally, this filter returns only TCP finger packets. We must parse the IP header to reach the TCP header. The <span class="symb">BPF_JSET</span> instruction checks that the IP fragment offset is 0 so we are sure that we have a TCP header.<p>
<pre style="margin-left: 5.00ex;" class="lit display">
struct bpf_insn insns[] = { 
	BPF_STMT(BPF_LD+BPF_H+BPF_ABS, 12), 
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, ETHERTYPE_IP, 0, 10), 
	BPF_STMT(BPF_LD+BPF_B+BPF_ABS, 23), 
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, IPPROTO_TCP, 0, 8), 
	BPF_STMT(BPF_LD+BPF_H+BPF_ABS, 20), 
	BPF_JUMP(BPF_JMP+BPF_JSET+BPF_K, 0x1fff, 6, 0), 
	BPF_STMT(BPF_LDX+BPF_B+BPF_MSH, 14), 
	BPF_STMT(BPF_LD+BPF_H+BPF_IND, 14), 
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 79, 2, 0), 
	BPF_STMT(BPF_LD+BPF_H+BPF_IND, 16), 
	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 79, 0, 1), 
	BPF_STMT(BPF_RET+BPF_K, (u_int)-1), 
	BPF_STMT(BPF_RET+BPF_K, 0), 
};</pre>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../2/ioctl">ioctl(2)</a>, <a class="link-man" href="../2/read">read(2)</a>, <a class="link-man" href="../2/select">select(2)</a>, <a class="link-man" href="../3/signal">signal(3)</a>, <a class="link-man" href="../4/bpfjit">bpfjit(4)</a>, <a class="link-man" href="../8/tcpdump">tcpdump(8)</a><p>
<span class="ref"><span class="ref-auth">S. McCanne</span> and <span class="ref-auth">V. Jacobson</span>, <span class="ref-title">The BSD Packet Filter: A New Architecture for User-level Packet Capture</span>, <i class="ref-jrnl">Proceedings of the 1993 Winter USENIX</i>, <span class="ref-city">Technical Conference, San Diego, CA</span>.</span></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The Enet packet filter was created in 1980 by Mike Accetta and Rick Rashid at Carnegie-Mellon University. Jeffrey Mogul, at Stanford, ported the code to BSD and continued its development from 1983 on. Since then, it has evolved into the ULTRIX Packet Filter at DEC, a STREAMS NIT module under SunOS 4.1, and BPF.</div>
<div class="section">
<h1 id="x415554484f5253">AUTHORS</h1> <span class="author"></span><span class="author">Steven McCanne</span>, of Lawrence Berkeley Laboratory, implemented BPF in Summer 1990. The design was in collaboration with <span class="author">Van Jacobson</span>, also of Lawrence Berkeley Laboratory.</div>
<div class="section">
<h1 id="x42554753">BUGS</h1> The read buffer must be of a fixed size (returned by the <span class="define">BIOCGBLEN</span> ioctl).<p>
A file that does not request promiscuous mode may receive promiscuously received packets as a side effect of another file requesting this mode on the same hardware interface. This could be fixed in the kernel with additional processing overhead. However, we favor the model where all files must assume that the interface is promiscuous, and if so desired, must use a filter to reject foreign packets.<p>
Under SunOS, if a BPF application reads more than 2^31 bytes of data, read will fail in <span class="errno">EINVAL</span>. You can either fix the bug in SunOS, or lseek to 0 when read fails for this reason.<p>
&#8220;Immediate mode&#8221; and the &#8220;read timeout&#8221; are misguided features. This functionality can be emulated with non-blocking mode and <a class="link-man" href="../2/select">select(2)</a>.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
July 24, 2014</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

