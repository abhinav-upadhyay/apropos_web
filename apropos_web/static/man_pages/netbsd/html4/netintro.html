<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/../4/strict.dtd">
>
<head>
<meta http-equiv="Content-Type" content="te../; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
NETINTRO(4)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
NETINTRO(4)</td>
<td class="head-vol" align="center">
Kernel Interfaces Manual</td>
<td class="head-rtitle" align="right">
NETINTRO(4)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">netintro</b> &#8212; <span class="desc">introduction to networking facilities</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/types.h</a>&gt;</b><br>
<b class="includes">#include &lt;<a class="link-includes">sys/socket.h</a>&gt;</b><br>
<b class="includes">#include &lt;<a class="link-includes">net/route.h</a>&gt;</b><br>
<b class="includes">#include &lt;<a class="link-includes">net/if.h</a>&gt;</b></div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> This section is a general introduction to the networking facilities available in the system. Documentation in this part of section 4 is broken up into three areas: <span class="emph">protocol families</span> (domains), <span class="emph">protocols</span>, and <span class="emph">network interfaces</span>.<p>
All network protocols are associated with a specific <span class="emph">protocol family</span>. A protocol family provides basic services to the protocol implementation to allow it to function within a specific network environment. These services may include packet fragmentation and reassembly, routing, addressing, and basic transport. A protocol family may support multiple methods of addressing, though the current protocol implementations do not. A protocol family normally comprises a number of protocols, one per <a class="link-man" href="../2/socket">socket(2)</a> type. It is not required that a protocol family support all socket types. A protocol family may contain multiple protocols supporting the same socket abstraction.<p>
A protocol supports one of the socket abstractions detailed in <a class="link-man" href="../2/socket">socket(2)</a>. A specific protocol may be accessed either by creating a socket of the appropriate type and protocol family, or by requesting the protocol explicitly when creating a socket. Protocols normally accept only one type of address format, usually determined by the addressing structure inherent in the design of the protocol family/network architecture. Certain semantics of the basic socket abstractions are protocol specific. All protocols are expected to support the basic model for their particular socket type, but may, in addition, provide non-standard facilities or extensions to a mechanism. For example, a protocol supporting the <span class="define">SOCK_STREAM</span> abstraction may allow more than one byte of out-of-band data to be transmitted per out-of-band message.<p>
A network interface is similar to a device interface. Network interfaces comprise the lowest layer of the networking subsystem, interacting with the actual transport hardware. An interface may support one or more protocol families and/or address formats. The <span class="emph">SYNOPSIS</span> section of each network interface entry gives a sample specification of the related drivers for use in providing a system description to the <a class="link-man" href="../1/config">config(1)</a> program.<p>
The <span class="emph">DIAGNOSTICS</span> section lists messages which may appear on the console and/or in the system error log, <i class="file">/var/log/messages</i> (see <a class="link-man" href="../8/syslogd">syslogd(8)</a>), due to errors in device operation.</div>
<div class="section">
<h1 id="x50524f544f434f4c53">PROTOCOLS</h1> The system currently supports the Internet protocols and some of the ISO OSI protocols. Raw socket interfaces are provided to the IP protocol layer of the Internet, and to the IDP protocol of Xerox NS. Consult the appropriate manual pages in this section for more information regarding the support for each protocol family.</div>
<div class="section">
<h1 id="x41444452455353494e47">ADDRESSING</h1> Associated with each protocol family is an address format. All network address adhere to a general structure, called a sockaddr, described below. However, each protocol imposes finer and more specific structure, generally renaming the variant, which is discussed in the protocol family manual page alluded to above.<p>
<pre style="margin-left: 5.00ex;" class="lit display">
struct sockaddr { 
	u_char	sa_len; 
    	u_char	sa_family; 
    	char	sa_data[14]; 
};</pre>
<p>
The field <i class="arg">sa_len</i> contains the total length of the of the structure, which may exceed 16 bytes. The following address values for <i class="arg">sa_family</i> are known to the system (and additional formats are defined for possible future implementation):<p>
<pre style="margin-left: 0.00ex;" class="lit display">
#define    AF_LOCAL     1    /* local to host */ 
#define    AF_INET      2    /* internetwork: UDP, TCP, etc. */ 
#define    AF_NS        6    /* Xerox NS protocols */ 
#define    AF_CCITT     10   /* CCITT protocols, X.25 etc */ 
#define    AF_HYLINK    15   /* NSC Hyperchannel */ 
#define    AF_INET6     24   /* internetwork, v6: UDP, TCP, etc. */</pre>
</div>
<div class="section">
<h1 id="x524f5554494e47">ROUTING</h1> <span class="unix">UNIX</span> provides some packet routing facilities. The kernel maintains a routing information database, which is used in selecting the appropriate network interface when transmitting packets.<p>
A user process (or possibly multiple co-operating processes) maintains this database by sending messages over a special kind of socket. This supplants fixed size <a class="link-man" href="../2/ioctl">ioctl(2)</a> used in earlier releases.<p>
This facility is described in <a class="link-man" href="../4/route">route(4)</a>.</div>
<div class="section">
<h1 id="x494e5445524641434553">INTERFACES</h1> Each network interface in a system corresponds to a path through which messages may be sent and received. A network interface usually has a hardware device associated with it, though certain interfaces such as the loopback interface, <a class="link-man" href="../4/lo">lo(4)</a>, do not.<p>
The following <a class="link-man" href="../2/ioctl">ioctl(2)</a> calls may be used to manipulate network interfaces. The <a class="link-man" href="../2/ioctl">ioctl(2)</a> is made on a socket (typically of type <span class="define">SOCK_DGRAM</span>) in the desired domain. Most of the requests supported in earlier releases take an <i class="arg">ifreq</i> structure as its parameter. This structure has the form<p>
<pre style="margin-left: 0.00ex;" class="lit display">
struct	ifreq { 
#define    IFNAMSIZ    16 
    char    ifr_name[IFNAMSIZ];         /* if name, e.g. "en0" */ 
    union { 
        struct    sockaddr ifru_addr; 
        struct    sockaddr ifru_dstaddr; 
        struct    sockaddr ifru_broadaddr; 
        short     ifru_flags; 
        int       ifru_metric; 
        void   *ifru_data; 
    } ifr_ifru; 
#define ifr_addr      ifr_ifru.ifru_addr    /* address */ 
#define ifr_dstaddr   ifr_ifru.ifru_dstaddr /* other end of p-to-p link */ 
#define ifr_broadaddr ifr_ifru.ifru_broadaddr /* broadcast address */ 
#define ifr_space     ifr_ifru.ifru_space     /* sockaddr_storage */ 
#define ifr_flags     ifr_ifru.ifru_flags   /* flags */ 
#define ifr_metric    ifr_ifru.ifru_metric  /* metric */ 
#define ifr_mtu       ifr_ifru.ifru_mtu       /* mtu */ 
#define ifr_dlt       ifr_ifru.ifru_dlt       /* data link type (DLT_*) */ 
#define ifr_value     ifr_ifru.ifru_value     /* generic value */ 
#define ifr_media     ifr_ifru.ifru_metric    /* media options (overload) */ 
#define ifr_data      ifr_ifru.ifru_data    /* for use by interface */ 
#define ifr_buf       ifr_ifru.ifru_b.b_buf   /* new interface ioctls */ 
#define ifr_buflen    ifr_ifru.ifru_b.b_buflen 
#define ifr_index     ifr_ifru.ifru_value     /* interface index */ 
};</pre>
<p>
Calls which are now deprecated are:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCSIFADDR</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
Set interface address for protocol family. Following the address assignment, the ``initialization'' routine for the interface is called.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCSIFDSTADDR</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
Set point to point address for protocol family and interface.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCSIFBRDADDR</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
Set broadcast address for protocol family and interface.</dd>
</dl>
<p>
<a class="link-man" href="../2/ioctl">ioctl(2)</a> requests to obtain addresses and requests both to set and retrieve other data are still fully supported and use the <i class="arg">ifreq</i> structure:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCGIFADDR</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
Get interface address for protocol family.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCGIFDSTADDR</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
Get point to point address for protocol family and interface.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCGIFBRDADDR</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
Get broadcast address for protocol family and interface.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCSIFFLAGS</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
Set interface flags field. If the interface is marked down, any processes currently routing packets through the interface are notified; some interfaces may be reset so that incoming packets are no longer received. When marked up again, the interface is reinitialized.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCGIFFLAGS</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
Get interface flags.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCSIFMETRIC</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
Set interface routing metric. The metric is used only by user-level routers.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCGIFMETRIC</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
Get interface metric.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCGIFINDEX</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
Get the interface index and populate ifr_index.</dd>
</dl>
<p>
There are two requests that make use of a new structure:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCAIFADDR</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
An interface may have more than one address associated with it in some protocols. This request provides a means to add additional addresses (or modify characteristics of the primary address if the default address for the address family is specified). Rather than making separate calls to set destination or broadcast addresses, or network masks (now an integral feature of multiple protocols) a separate structure, <i class="arg">ifaliasreq</i>, is used to specify all three facets simultaneously (see below). One would use a slightly tailored version of this struct specific to each family (replacing each sockaddr by one of the family-specific type). Where the sockaddr itself is larger than the default size, one needs to modify the <a class="link-man" href="../2/ioctl">ioctl(2)</a> identifier itself to include the total size, as described in <a class="link-man" href="../2/ioctl">ioctl(2)</a>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCDIFADDR</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
This requests deletes the specified address from the list associated with an interface. It also uses the <i class="arg">ifaliasreq</i> structure to allow for the possibility of protocols allowing multiple masks or destination addresses, and also adopts the convention that specification of the default address means to delete the first address for the interface belonging to the address family in which the original socket was opened.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCGIFALIAS</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
This request provides means to get additional addresses together with netmask and broadcast/destination from an interface. It also uses the <i class="arg">ifaliasreq</i> structure.</dd>
</dl>
<p>
Request making use of the <i class="arg">ifconf</i> structure:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">SIOCGIFCONF</span></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
Get interface configuration list. This request takes an <i class="arg">ifconf</i> structure (see below) as a value-result parameter. The <i class="arg">ifc_len</i> field should be initially set to the size of the buffer pointed to by <i class="arg">ifc_buf</i>. On return it will contain the length, in bytes, of the configuration list.</dd>
</dl>
<p>
<pre style="margin-left: 0.00ex;" class="lit display">
/* 
* Structure used in SIOC[AD]IFADDR request. 
*/ 
struct ifaliasreq { 
        char    ifra_name[IFNAMSIZ];   /* if name, e.g. "en0" */ 
        struct  sockaddr        ifra_addr; 
        struct  sockaddr        ifra_dstaddr; 
#define	ifra_broadaddr  ifra_dstaddr 
        struct  sockaddr        ifra_mask; 
};</pre>
<p>
<pre style="margin-left: 0.00ex;" class="lit display">
/* 
* Structure used in SIOCGIFCONF request. 
* Used to retrieve interface configuration 
* for machine (useful for programs which 
* must know all networks accessible). 
*/ 
struct ifconf { 
    int   ifc_len;		/* size of associated buffer */ 
    union { 
        void    *ifcu_buf; 
        struct     ifreq *ifcu_req; 
    } ifc_ifcu; 
#define ifc_buf ifc_ifcu.ifcu_buf /* buffer address */ 
#define ifc_req ifc_ifcu.ifcu_req /* array of structures returned */ 
};</pre>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../1/config">config(1)</a>, <a class="link-man" href="../2/ioctl">ioctl(2)</a>, <a class="link-man" href="../2/socket">socket(2)</a>, <a class="link-man" href="../4/intro">intro(4)</a>, <a class="link-man" href="../8/routed">routed(8)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The <b class="name">netintro</b> manual appeared in <span class="unix">4.3BSD-Tahoe</span>.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
July 13, 2014</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
<>

