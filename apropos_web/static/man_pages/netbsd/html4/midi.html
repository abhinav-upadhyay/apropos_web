<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
MIDI(4)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
MIDI(4)</td>
<td class="head-vol" align="center">
Kernel Interfaces Manual</td>
<td class="head-rtitle" align="right">
MIDI(4)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">midi</b> &#8212; <span class="desc">device-independent MIDI driver layer</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="config">midi* at midibus?</b><br>
<b class="config">midi* at pcppi?</b><br>
<b class="config">pseudo-device sequencer</b><p>
<br>
<b class="includes">#include &lt;<a class="link-includes">sys/types.h</a>&gt;</b><br>
<b class="includes">#include &lt;<a class="link-includes">sys/midiio.h</a>&gt;</b></div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <b class="name">midi</b> driver is the machine independent layer over anything that can source or sink a MIDI data stream, whether a physical MIDI IN or MIDI OUT jack on a soundcard, cabled to some external synthesizer or input controller, an on-board programmable tone generator, or a single jack, synthesizer, or controller component within a complex USB or IEEE1394 MIDI device that has several such components and appears as several MIDI streams.<div class="subsection">
<h2 id="x436f6e6365707473">Concepts</h2> One MIDI data stream is a unidirectional stream of MIDI messages, as could be carried over one MIDI cable in the MIDI 1.0 specification. Many MIDI messages carry a four-bit channel number, creating up to 16 MIDI channels within a single MIDI stream. There may be multiple consumers of a MIDI stream, each configured to react only to messages on specific channels; the sets of channels different consumers react to need not be disjoint. Many modern devices such as multitimbral keyboards and tone generators listen on all 16 channels, or may be viewed as collections of 16 independent consumers each listening on one channel. MIDI defines some messages that take no channel number, and apply to all consumers of the stream on which they are sent. For an inbound stream, <b class="name">midi</b> is a promiscuous receiver, capturing all messages regardless of channel number. For an outbound stream, the writer can specify a channel number per message; there is no notion of binding the stream to one destination channel in advance.<p>
A single <b class="name">midi</b> device instance is the endpoint of one outbound stream, one inbound stream, or one of each. In the third case, the write and read sides are independent MIDI streams. For example, a soundcard driver may map its MIDI OUT and MIDI IN jacks to the write and read sides of a single device instance, but those jacks can be cabled to completely different pieces of gear. Information from <a class="link-man" href="../8/dmesg">dmesg(8)</a>, and a diagram of any external MIDI cabling, will help clarify the mapping.</div>
<div class="subsection">
<h2 id="x556e6465726c79696e67206472697665727320616e64204d4944492070726f746f636f6c">Underlying drivers and MIDI protocol</h2> Drivers <b class="name">midi</b> can attach include soundcard drivers, many of which support a UART resembling Roland's MPU401 and handled by <a class="link-man" href="../4/mpu">mpu(4)</a>, USB MIDI devices via <a class="link-man" href="../4/umidi">umidi(4)</a>, and on-board devices that can make sounds, whether a lowly PC speaker or a Yamaha OPL. Serial port and IEEE1394 connections are currently science fiction.<p>
The MIDI protocol permits some forms of message compression such as running status and hidden note-off. Received messages on inbound streams are always canonicalized by <b class="name">midi</b> before presentation to higher layers. Messages for transmission are accepted by <b class="name">midi</b> in any valid form.</div>
<div class="subsection">
<h2 id="x44657669636520616363657373">Device access</h2> Access to <b class="name">midi</b> device instances can be through the raw device nodes, <i class="file">/dev/rmidiN</i>, or through the sequencer, <i class="file">/dev/music</i>.</div>
<div class="subsection">
<h2 id="x526177204d49444920616363657373">Raw MIDI access</h2> A <i class="file">/dev/rmidiN</i> device supports <a class="link-man" href="../2/read">read(2)</a>, <a class="link-man" href="../2/write">write(2)</a>, <a class="link-man" href="../2/ioctl">ioctl(2)</a>, <a class="link-man" href="../2/select">select(2)</a>/<a class="link-man" href="../2/poll">poll(2)</a> and the corresponding <a class="link-man" href="../2/kevent">kevent(2)</a> filters, and may be opened only when it is not already open. It may be opened in <span class="define">O_RDONLY</span>, <span class="define">O_WRONLY</span>, or <span class="define">O_RDWR</span> mode, but a later <a class="link-man" href="../2/read">read(2)</a> or <a class="link-man" href="../2/write">write(2)</a> will return &#45;1 if the device has no associated input or output stream, respectively.<p>
Bytes written are passed as quickly as possible to the underlying driver as complete MIDI messages; a maximum of two bytes at the end of a <a class="link-man" href="../2/write">write(2)</a> may remain buffered if they do not complete a message, until completed by a following <a class="link-man" href="../2/write">write(2)</a>.<p>
A <a class="link-man" href="../2/read">read(2)</a> will not block or return <span class="errno">EWOULDBLOCK</span> when it could immediately return any nonzero count, and MIDI messages received are available to <a class="link-man" href="../2/read">read(2)</a> as soon as they are complete, with a maximum of two received bytes remaining buffered if they do not complete a message.<p>
As all MIDI messages are three bytes or fewer except for System Exclusive, which can have arbitrary length, these rules imply that System Exclusive messages are the only ones of which some bytes can be delivered before all are available.<p>
System Realtime messages are passed with minimum delay in either direction, ahead of any possible buffered incomplete message. As a result, they will never interrupt any MIDI message except possibly System Exclusive.<p>
A <a class="link-man" href="../2/read">read(2)</a> with a buffer large enough to accommodate the first complete message available will be satisfied with as many complete messages as will fit. A buffer too small for the first complete message will be filled to capacity. Therefore, an application that reads from an <i class="file">rmidi</i> device with buffers of three bytes or larger need never parse across read boundaries to assemble a received message, except possibly in the case of a System Exclusive message. However, if the application reads through a buffering layer such as <a class="link-man" href="../3/fread">fread(3)</a>, this property will not be preserved.<p>
The <b class="name">midi</b> driver itself supports the <a class="link-man" href="../2/ioctl">ioctl(2)</a> operations <span class="define">FIOASYNC</span>, <span class="define">FIONBIO</span>, and <span class="define">FIONREAD</span>. Underlying devices may support others. The value returned for <span class="define">FIONREAD</span> reflects the size in bytes of complete messages (or System Exclusive chunks) ready to read. If the <a class="link-man" href="../2/ioctl">ioctl(2)</a> returns <b class="var">n</b> and a <a class="link-man" href="../2/read">read(2)</a> of size <b class="var">n</b> is issued, <b class="var">n</b> bytes will be read, but if a <a class="link-man" href="../2/read">read(2)</a> of size <b class="var">m</b> &lt; <b class="var">n</b> is issued, fewer than <b class="var">m</b> bytes may be read if <b class="var">m</b> does not fall on a message/chunk boundary.<p>
Raw MIDI access can be used to receive bulk dumps from synthesizers, download bulk data to them, and so on. Simple patching of one device to another can be done at the command line, as with<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">$ cat -u 0&lt;&gt;/dev/rmidi0 1&gt;&amp;0</code></div>
</blockquote>
which will loop all messages received on the input stream of <i class="file">rmidi0</i> input stream  back to its output stream in real time. However, an attempt to record and play back music with<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">$ cat /dev/rmidiN &gt;foo; cat foo &gt;/dev/rmidiN</code></div>
</blockquote>
will be disappointing. The file <i class="file">foo</i> will contain all of the notes that were played, but because MIDI messages carry no explicit timing, the &#8216;playback&#8217; will reproduce them all at once, as fast as they can be transmitted. To preserve timing information, the sequencer device can be used.</div>
<div class="subsection">
<h2 id="x4163746976652053656e73696e67">Active Sensing</h2> The MIDI protocol includes a keepalive function called Active Sensing. In any receiver that has <span class="emph">not</span> received at least one Active Sense MIDI message, the feature is suppressed and no timeout applies. If at least one such message has been received, the lapse of any subsequent 300 ms interval without receipt of any message reflects loss of communication, and the receiver should silence any currently sounding notes and return to non-Active-Sensing behavior. A sender using Active Sensing generally avoids 300 ms gaps in transmission by sending Active Sense messages (which have no other effect) as needed when there is no other traffic to send in the interval. This feature can be important for MIDI, which relies on separate Note On and Note Off messages, to avoid notes stuck on indefinitely if communication is interrupted before a Note Off message arrives.<p>
This protocol is supported in <b class="name">midi</b>. An outbound stream will be kept alive by sending Active Sense messages as needed, beginning after any real traffic is sent on the stream, and continuing until the stream is closed. On an inbound stream, if any Active Sense has been received, then a process reading an <i class="file">rmidi</i> device will see an end-of-file indication if the input timeout elapses. The stream remains open, the driver reverts to enforcing no timeout, and the process may continue to read for more input. Subsequent receipt of an Active Sense message will re-arm the timeout. As received Active Sense messages are handled by <b class="name">midi</b>, they are not included among messages read from the <i class="file">/dev/rmidiN</i> device.<p>
These rules support end-to-end Active Sensing behavior in simple cases without special action in an application. For example, in<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">$ cat -u /dev/rmidi0 &gt;/dev/rmidi1</code></div>
</blockquote>
if the input stream to <i class="file">rmidi0</i> is lost, the <a class="link-man" href="../1/cat">cat(1)</a> command exits; on the <a class="link-man" href="../2/close">close(2)</a> of <i class="file">rmidi1</i>, <b class="name">midi</b> ceases to send Active Sense messages, and the receiving device will detect the loss and silence any outstanding notes.</div>
<div class="subsection">
<h2 id="x416363657373207468726f756768207468652073657175656e636572">Access through the sequencer</h2> To play music using the raw MIDI API would require an application to issue many small writes with very precise timing. The sequencer device, <i class="file">/dev/music</i>, can manage the timing of MIDI data in the kernel, to avoid such demanding real-time constraints on a user process.<p>
The <i class="file">/dev/music</i> device can be opened only when it is not already open. When opened, the sequencer internally opens all MIDI instances existing in the system that are not already open at their raw nodes; any attempts to open them at their raw nodes while the sequencer is open will fail. All access to the corresponding MIDI streams will then be through the sequencer.<p>
Reads and writes of <i class="file">/dev/music</i> pass eight-byte event structures defined in <b class="includes">&lt;<a class="link-includes">sys/midiio.h</a>&gt;</b> (which see for their documentation and examples of use). Some events correspond to MIDI messages, and carry an integer <b class="var">device</b> field to identify one of the MIDI devices opened by the sequencer. Other events carry timing information interpreted or generated by the sequencer itself.<p>
A message received on an input stream is wrapped in a sequencer event along with the device index of the stream it arrived on, and queued for the reader of <i class="file">/dev/music</i>. If a measurable time interval passed since the last preceding message, a timing event that represents a delay for that interval is queued ahead of the received event. The sequencer handles output events by interpreting any timing event, and routing any MIDI message event at the proper time to an underlying output stream according to its <b class="var">device</b> index. Therefore<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">$ cat /dev/music &gt;foo; cat foo &gt;/dev/music</code></div>
</blockquote>
can be expected to capture and reproduce an input performance including timing.<p>
The process of playing back a complex MIDI file is illustrated below. The file may contain several tracks&#8212;four, in this example&#8212;of MIDI events, each marked with a device index and a time stamp, that may overlap in time. In the example, <b class="var">a</b>, <b class="var">b</b>, and <b class="var">c</b> are device indices of the three output MIDI streams; the left-hand digit in each input event represents a MIDI channel on the selected stream, and the right-hand digit represents a time for the event's occurrence. As illustrated, the input tracks are not firmly associated with output streams; any track may contain events for any stream.<p>
<pre style="margin-left: 0.00ex;" class="lit display">
     |      |     a2|4     | 
   a0|3     |     c1|3   c0|3 
     |    b0|2    b1|2     | 
     |    b1|1      |    c0|1 
   a0|0     |     b0|0     | 
     v      v       v      v 
  +---------------------------+ 
  | merge to 1 ordered stream | 
  | user code, eg midiplay(1) | 
  +---------------------------+ 
              b1|2 
              b0|2 
              c0|1 
              b1|1 
              b0|0 
              a0|0 
                v 
  _______+-------------+_______user 
         | /dev/music  |     kernel 
         | (sequencer) | 
         +-------------+ 
           |    1    0 
     +-----'    |    '-----. 
     0          0          | 
     v          v          v 
  +-------+ +--------+ +---------+ 
  |midi(4)| |midi(4) | |midi(4)  | 
  |rmidia | |rmidib  | |rmidic   | 
  +-------+ +--------+ +---------+ 
  | mpu(4)| |umidi(4)| |midisyn  | 
  +-------+ +--------+ +---------+ 
  |  HW   |     |      | opl(4)  | 
  | MIDI  |     U      +---------+ 
  | UART  |      S     | internal| 
  +-------+       B    |   tone  | 
      |           |    |generator| 
      v           |    +---------+ 
   external       v 
  MIDI device  external 
              MIDI device</pre>
<p>
A user process must merge the tracks into a single stream of sequencer MIDI and timing events in order by desired timing. The sequencer obeys the timing events and distributes the MIDI events to the three destinations, in this case two external devices connected to a sound card UART and a USB interface, and an OPL tone generator on a sound card.</div>
</div>
<div class="section">
<h1 id="x4e4f544553">NOTES</h1> Use of <a class="link-man" href="../2/select">select(2)</a>/<a class="link-man" href="../2/poll">poll(2)</a> with the sequencer is supported, however, there is no guarantee that a <a class="link-man" href="../2/write">write(2)</a> will not block or return <span class="errno">EWOULDBLOCK</span> if it begins with a timer-wait event, even if <a class="link-man" href="../2/select">select(2)</a>/<a class="link-man" href="../2/poll">poll(2)</a> reported the sequencer writable.<p>
The delivery of a realtime message ahead of buffered bytes of an incomplete message may cause the realtime message to seem, in a saved byte stream, to have arrived up to 640 us earlier than it really did, at MIDI 1.0 data rates. Higher data rates make the effect less significant.<p>
Another sequencer device, <i class="file">/dev/sequencer</i>, is provided only for backward compatibility with an obsolete OSS interface in which some sequencer events were four-byte records. It is not further documented here, and the <i class="file">/dev/music</i> API should be used in new code. The <i class="file">/dev/sequencer</i> emulation is implemented only for writing, and that might not be complete.</div>
<div class="section">
<h1 id="x494d504c454d454e544154494f4e204e4f544553">IMPLEMENTATION NOTES</h1> Some hardware devices supporting <b class="name">midi</b> lack transmit-ready interrupts, and some have the capability in hardware but currently lack driver support. They can be recognized by the annotation <code class="lit">(CPU-intensive output)</code> in <a class="link-man" href="../8/dmesg">dmesg(8)</a>. While suitable for music playback, they may have an objectionable impact on system responsiveness during bulk transmission such as patch downloads, and are best avoided for that purpose if other suitable devices are present.<p>
Buffer space in <b class="name">midi</b> itself is adequate for about 200 ms of traffic at MIDI 1.0 data rates, per stream.<p>
Event counters record bytes and messages discarded because of protocol errors or buffer overruns, and can be viewed with <code class="lit">vmstat -e</code>. They can be useful in diagnosing flaky cables and other communication problems.<p>
A raw sound generator uses the <span class="symb">midisyn</span> layer to present a MIDI message-driven interface attachable by <b class="name">midi</b>.<p>
While <b class="name">midi</b> accepts messages for transmission in any valid mixture of compressed or canonical form, they are always presented to an underlying driver in the form it prefers. Drivers for simple UART-like devices register their preference for a compressed byte stream, while those like <a class="link-man" href="../4/umidi">umidi(4)</a>, which uses a packet protocol, or <span class="symb">midisyn</span>, which interprets complete messages, register for intact canonical messages. This design eliminates the need for compression and canonicalization logic from all layers above and below <b class="name">midi</b> itself.</div>
<div class="section">
<h1 id="x46494c4553">FILES</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="file">/dev/rmidiN</i></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="file">/dev/music</i></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="file">/dev/sequencer</i></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
</dd>
</dl>
</div>
<div class="section">
<h1 id="x4552524f5253">ERRORS</h1> In addition to other errors documented for the <a class="link-man" href="../2/write">write(2)</a> family of system calls, <span class="errno">EPROTO</span> can be returned if the bytes to be written on a raw <b class="name">midi</b> device would violate MIDI protocol.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../1/midiplay">midiplay(1)</a>, <a class="link-man" href="../2/ioctl">ioctl(2)</a>, <a class="link-man" href="../3/ossaudio">ossaudio(3)</a>, <a class="link-man" href="../4/audio">audio(4)</a>, <a class="link-man" href="../4/mpu">mpu(4)</a>, <a class="link-man" href="../4/opl">opl(4)</a>, <a class="link-man" href="../4/umidi">umidi(4)</a><p>
For ports using the ISA bus: <a class="link-man" href="../4/cms">cms(4)</a>, <a class="link-man" href="../4/pcppi">pcppi(4)</a>, <a class="link-man" href="../4/sb">sb(4)</a><p>
For ports using the PCI bus: <a class="link-man" href="../4/autri">autri(4)</a>, <a class="link-man" href="../4/clcs">clcs(4)</a>, <a class="link-man" href="../4/eap">eap(4)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The <b class="name">midi</b> driver first appeared in <span class="unix">NetBSD&#160;1.4</span>. It was overhauled and this manual page rewritten for <span class="unix">NetBSD&#160;4.0</span>.</div>
<div class="section">
<h1 id="x42554753">BUGS</h1> Some OSS sequencer events and <a class="link-man" href="../2/ioctl">ioctl(2)</a> operations are unimplemented, as <b class="includes">&lt;<a class="link-includes">sys/midiio.h</a>&gt;</b> notes.<p>
OSS source-compatible sequencer macros should be added to <b class="includes">&lt;<a class="link-includes">sys/soundcard.h</a>&gt;</b>, implemented with the <span class="unix">NetBSD</span> ones in <b class="includes">&lt;<a class="link-includes">sys/midiio.h</a>&gt;</b>, so sources written for OSS can be easily compiled.<p>
The sequencer blocks (or returns <span class="errno">EWOULDBLOCK</span>) only when its buffer physically fills, which can represent an arbitrary latency because of buffered timing events. As a result, interrupting a process writing the sequencer may not interrupt music playback for a considerable time. The sequencer could enforce a reasonable latency bound by examining timing events as they are enqueued and blocking appropriately.<p>
<span class="define">FIOASYNC</span> enables signal delivery to the calling process only; <span class="define">FIOSETOWN</span> is not supported.<p>
The sequencer can only be a timing master, but does not send timing messages to synchronize any slave device; it cannot be slaved to timing messages received on any interface (which would presumably require a PLL algorithm similar to NTP's, and expertise in that area to implement it). The sequencer ignores timing messages received on any interface and does not pass them along to the reading process, and the OSS operations to change that behavior are unimplemented.<p>
The <span class="define">SEQUENCER_TMR_TIMEBASE</span> <a class="link-man" href="../2/ioctl">ioctl(2)</a> will report successfully setting any timebase up to ridiculously high resolutions, though the actual resolution, and therefore jitter, is constrained by <a class="link-man" href="../9/hz">hz(9)</a>. Comparable sequencer implementations typically allow a selection from available sources of time interrupts that may be programmable.<p>
The device number in a sequencer event is treated on <a class="link-man" href="../2/write">write(2)</a> as index into the array of MIDI devices the sequencer has opened, but on <a class="link-man" href="../2/read">read(2)</a> as the unit number of the source MIDI device; these are usually the same if the sequencer has opened all the MIDI devices (that is, none was already open at its raw node when the sequencer was opened), but might not be the same otherwise.<p>
There is at present no way to make reception nonpromiscuous, should anyone have a reason to want to.<p>
There should be ways to override default Active Sense behavior. As one obvious case, if an application is seen to send Active Sense explicitly, <b class="name">midi</b> should refrain from adding its own. On receive, there should be an option to pass Active Sense through rather than interpreting it, for apps that wish to handle or ignore it themselves and never see <span class="define">EOF</span>.<p>
When a <b class="name">midi</b> stream is open by the sequencer, Active Sense messages received on the stream are passed to the sequencer and not interpreted by <b class="name">midi</b>. The sequencer at present neither does anything itself with Active Sense messages received, nor supports the OSS API for making them available to the user process.<p>
System Exclusive messages can be received by reading a raw device, but not by reading the sequencer; they are discarded on receipt when the stream is open by the sequencer, rather than being presented as the OSS-defined sequencer events.<p>
<span class="symb">midisyn</span> is too rudimentary at present to get satisfactory results from any onboard synth. It lacks the required special interpretation of the General MIDI percussion channel in GM mode. More devices should be supported; some sound cards with synthesis capability have <span class="unix">NetBSD</span> drivers that implement the <a class="link-man" href="../4/audio">audio(4)</a> but not the <span class="symb">midisyn</span> interface. Voice stealing algorithm does not follow the General MIDI Developer Guidelines.<p>
ALSA sequencer compatibility is lacking, but becoming important to applications. It would require the function of merging multiple tracks into a single ordered stream to be moved from user space into the sequencer. Assuming the sequencer driven by periodic interrupts, timing wheels could be used as in <a class="link-man" href="../9/hardclock">hardclock(9)</a> itself. Similar functionality will be in OSS4; with the right infrastructure it should be possible to support both. When merging MIDI streams, a notion of transaction is needed to group critical message sequences. If ALSA or OSS4 have no such notion, it should be provided as an upward-compatible extension.<p>
I would rather have <a class="link-man" href="../2/open">open(2)</a> itself return an error (by the POSIX description <span class="errno">ENODEV</span> looks most appropriate) if a read or write mode is requested that is not supported by the instance, rather than letting <a class="link-man" href="../2/open">open(2)</a> succeed and <a class="link-man" href="../2/read">read(2)</a> or <a class="link-man" href="../2/write">write(2)</a> return &#45;1, but so help me, the latter seems the more common <span class="unix">UNIX</span> practice.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
May 6, 2006</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

