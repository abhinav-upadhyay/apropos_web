<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="/static/man_pages/netbsd/style.css" type="text/css" media="all">
<title>
IPF(4)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
IPF(4)</td>
<td class="head-vol" align="center">
Kernel Interfaces Manual</td>
<td class="head-rtitle" align="right">
IPF(4)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> ipf &#45; packet filtering kernel interface</div>
<div class="section">
<h1>SYNOPSIS</h1> #include &lt;netinet/ip_compat.h&gt;<div style="height: 0.00em;">
&#160;</div>
#include &lt;netinet/ip_fil.h&gt;</div>
<div class="section">
<h1>IOCTLS</h1> To add and delete rules to the filter list, three 'basic' ioctls are provided for use.  The ioctl's are called as:<p>
<br>
	ioctl(fd, SIOCADDFR, struct frentry **)<br>
	ioctl(fd, SIOCDELFR, struct frentry **)<br>
	ioctl(fd, SIOCIPFFL, int *)<br>
<p>
However, the full complement is as follows:<p>
<br>
	ioctl(fd, SIOCADAFR, struct frentry **) (same as SIOCADDFR)<br>
	ioctl(fd, SIOCRMAFR, struct frentry **) (same as SIOCDELFR)<br>
	ioctl(fd, SIOCADIFR, struct frentry **)<br>
	ioctl(fd, SIOCRMIFR, struct frentry **)<br>
	ioctl(fd, SIOCINAFR, struct frentry **)<br>
	ioctl(fd, SIOCINIFR, struct frentry **)<br>
	ioctl(fd, SIOCSETFF, u_int *)<br>
	ioctl(fd, SIOGGETFF, u_int *)<br>
	ioctl(fd, SIOCGETFS, struct friostat **)<br>
	ioctl(fd, SIOCIPFFL, int *)<br>
	ioctl(fd, SIOCIPFFB, int *)<br>
	ioctl(fd, SIOCSWAPA, u_int *)<br>
	ioctl(fd, SIOCFRENB, u_int *)<br>
	ioctl(fd, SIOCFRSYN, u_int *)<br>
	ioctl(fd, SIOCFRZST, struct friostat **)<br>
	ioctl(fd, SIOCZRLST, struct frentry **)<br>
	ioctl(fd, SIOCAUTHW, struct fr_info **)<br>
	ioctl(fd, SIOCAUTHR, struct fr_info **)<br>
	ioctl(fd, SIOCATHST, struct fr_authstat **)<br>
<p>
The variations, SIOCADAFR vs. SIOCADIFR, allow operation on the two lists, active and inactive, respectively.  All of these ioctl's are implemented as being routing ioctls and thus the same rules for the various routing ioctls and the file descriptor are employed, mainly being that the fd must be that of the device associated with the module (i.e., /dev/ipl).<p>
The three groups of ioctls above perform adding rules to the end of the list (SIOCAD*), deletion of rules from any place in the list (SIOCRM*) and insertion of a rule into the list (SIOCIN*).  The rule place into which it is inserted is stored in the "fr_hits" field, below.<p>
<br>
typedef struct  frentry {<br>
        struct  frentry *fr_next;<br>
        u_short fr_group;       /* group to which this rule belongs */<br>
        u_short fr_grhead;      /* group # which this rule starts */<br>
        struct  frentry *fr_grp;<br>
        int     fr_ref;         /* reference count - for grouping */<br>
        void    *fr_ifa;<br>
#if BSD &gt;= 199306<br>
        void    *fr_oifa;<br>
#endif<br>
        /*<br>
         * These are only incremented when a packet  matches this rule and<br>
         * it is the last match<br>
         */<br>
        U_QUAD_T        fr_hits;<br>
        U_QUAD_T        fr_bytes;<br>
        /*<br>
         * Fields after this may not change whilst in the kernel.<br>
         */<br>
        struct  fr_ip   fr_ip;<br>
        struct  fr_ip   fr_mip; /* mask structure */<p>
<br>
        u_char  fr_tcpfm;       /* tcp flags mask */<br>
        u_char  fr_tcpf;        /* tcp flags */<p>
<br>
        u_short fr_icmpm;       /* data for ICMP packets (mask) */<br>
        u_short fr_icmp;<p>
<br>
        u_char  fr_scmp;        /* data for port comparisons */<br>
        u_char  fr_dcmp;<br>
        u_short fr_dport;<br>
        u_short fr_sport;<br>
        u_short fr_stop;        /* top port for &lt;&gt; and &gt;&lt; */<br>
        u_short fr_dtop;        /* top port for &lt;&gt; and &gt;&lt; */<br>
        u_32_t  fr_flags;       /* per-rule flags &amp;&amp; options (see below) */<br>
        u_short fr_skip;        /* # of rules to skip */<br>
        u_short fr_loglevel;    /* syslog log facility + priority */<br>
        int     (*fr_func) __P((int, ip_t *, fr_info_t *));<br>
        char    fr_icode;       /* return ICMP code */<br>
        char    fr_ifname[IFNAMSIZ];<br>
#if BSD &gt; 199306<br>
        char    fr_oifname[IFNAMSIZ];<br>
#endif<br>
        struct  frdest  fr_tif; /* "to" interface */<br>
        struct  frdest  fr_dif; /* duplicate packet interfaces */<br>
} frentry_t;<br>
<p>
When adding a new rule, all unused fields (in the filter rule) should be initialised to be zero.  To insert a rule, at a particular position in the filter list, the number of the rule which it is to be inserted before must be put in the "fr_hits" field (the first rule is number 0).<p>
Flags which are recognised in fr_flags:<p>
<br>
     FR_BLOCK        0x000001   /* do not allow packet to pass */<br>
     FR_PASS         0x000002   /* allow packet to pass */<br>
     FR_OUTQUE       0x000004   /* outgoing packets */<br>
     FR_INQUE        0x000008   /* ingoing packets */<br>
     FR_LOG          0x000010   /* Log */<br>
     FR_LOGB         0x000011   /* Log-fail */<br>
     FR_LOGP         0x000012   /* Log-pass */<br>
     FR_LOGBODY      0x000020   /* log the body of packets too */<br>
     FR_LOGFIRST     0x000040   /* log only the first packet to match */<br>
     FR_RETRST       0x000080   /* return a TCP RST packet if blocked */<br>
     FR_RETICMP      0x000100   /* return an ICMP packet if blocked */<br>
     FR_FAKEICMP     0x00180    /* Return ICMP unreachable with fake source */<br>
     FR_NOMATCH      0x000200   /* no match occured */<br>
     FR_ACCOUNT      0x000400   /* count packet bytes */<br>
     FR_KEEPFRAG     0x000800   /* keep fragment information */<br>
     FR_KEEPSTATE    0x001000   /* keep `connection' state information */<br>
     FR_INACTIVE     0x002000<br>
     FR_QUICK        0x004000   /* match &amp; stop processing list */<br>
     FR_FASTROUTE    0x008000   /* bypass normal routing */<br>
     FR_CALLNOW      0x010000   /* call another function (fr_func) if matches */<br>
     FR_DUP          0x020000   /* duplicate the packet */<br>
     FR_LOGORBLOCK   0x040000   /* block the packet if it can't be logged */<br>
     FR_NOTSRCIP     0x080000   /* not the src IP# */<br>
     FR_NOTDSTIP     0x100000   /* not the dst IP# */<br>
     FR_AUTH         0x200000   /* use authentication */<br>
     FR_PREAUTH      0x400000   /* require preauthentication */<p>
<br>
<p>
Values for fr_scomp and fr_dcomp (source and destination port value comparisons) :<p>
<br>
	FR_NONE         0<br>
	FR_EQUAL        1<br>
	FR_NEQUAL       2<br>
	FR_LESST        3<br>
	FR_GREATERT     4<br>
	FR_LESSTE       5<br>
	FR_GREATERTE    6<br>
	FR_OUTRANGE     7<br>
	FR_INRANGE      8<br>
<p>
The third ioctl, SIOCIPFFL, flushes either the input filter list, the output filter list or both and it returns the number of filters removed from the list(s).  The values which it will take and recognise are FR_INQUE and FR_OUTQUE (see above).  This ioctl is also implemented for  <b>/dev/ipstate</b> and will flush all state tables entries if passed 0 or just all those which are not established if passed 1.<div style="height: 1.00em;">
&#160;</div>
<dl>
<dt>
<b>General Logging Flags</b></dt>
<dd>
There are two flags which can be set to log packets independently of the rules used.  These allow for packets which are either passed or blocked to be logged.  To set (and clear)/get these flags, two ioctls are provided:</dd>
</dl>
<dl>
<dt>
SIOCSETFF</dt>
<dd>
Takes an unsigned integer as the parameter.  The flags are then set to those provided (clearing/setting all in one).<p>
<br>
	FF_LOGPASS	0x10000000<br>
	FF_LOGBLOCK	0x20000000<br>
	FF_LOGNOMATCH	0x40000000<br>
	FF_BLOCKNONIP	0x80000000    /* Solaris 2.x only */<br>
</dd>
</dl>
<dl>
<dt>
SIOCGETFF</dt>
<dd>
Takes a pointer to an unsigned integer as the parameter.  A copy of the flags currently in used is copied to user space.</dd>
</dl>
<dl>
<dt>
<b>Filter statistics</b></dt>
<dd>
Statistics on the various operations performed by this package on packets is kept inside the kernel.  These statistics apply to packets traversing through the kernel.  To retrieve this structure, use this ioctl:<p>
<br>
	ioctl(fd, SIOCGETFS, struct friostat *)<p>
<br>
struct  friostat        {<br>
        struct  filterstats     f_st[2];<br>
        struct  frentry         *f_fin[2];<br>
        struct  frentry         *f_fout[2];<br>
        struct  frentry         *f_acctin[2];<br>
        struct  frentry         *f_acctout[2];<br>
        struct  frentry         *f_auth;<br>
        u_long  f_froute[2];<br>
        int     f_active;       /* 1 or 0 - active rule set */<br>
        int     f_defpass;      /* default pass - from fr_pass */<br>
        int     f_running;      /* 1 if running, else 0 */<br>
        int     f_logging;      /* 1 if enabled, else 0 */<br>
        char    f_version[32];  /* version string */<br>
};<p>
<br>
struct	filterstats {<br>
        u_long  fr_pass;        /* packets allowed */<br>
        u_long  fr_block;       /* packets denied */<br>
        u_long  fr_nom;         /* packets which don't match any rule */<br>
        u_long  fr_ppkl;        /* packets allowed and logged */<br>
        u_long  fr_bpkl;        /* packets denied and logged */<br>
        u_long  fr_npkl;        /* packets unmatched and logged */<br>
        u_long  fr_pkl;         /* packets logged */<br>
        u_long  fr_skip;        /* packets to be logged but buffer full */<br>
        u_long  fr_ret;         /* packets for which a return is sent */<br>
        u_long  fr_acct;        /* packets for which counting was performed */<br>
        u_long  fr_bnfr;        /* bad attempts to allocate fragment state */<br>
        u_long  fr_nfr;         /* new fragment state kept */<br>
        u_long  fr_cfr;         /* add new fragment state but complete pkt */<br>
        u_long  fr_bads;        /* bad attempts to allocate packet state */<br>
        u_long  fr_ads;         /* new packet state kept */<br>
        u_long  fr_chit;        /* cached hit */<br>
        u_long  fr_pull[2];     /* good and bad pullup attempts */<br>
#if SOLARIS<br>
        u_long  fr_notdata;     /* PROTO/PCPROTO that have no data */<br>
        u_long  fr_nodata;      /* mblks that have no data */<br>
        u_long  fr_bad;         /* bad IP packets to the filter */<br>
        u_long  fr_notip;       /* packets passed through no on ip queue */<br>
        u_long  fr_drop;        /* packets dropped - no info for them! */<br>
#endif<br>
};<br>
If we wanted to retrieve all the statistics and reset the counters back to 0, then the ioctl() call would be made to SIOCFRZST rather than SIOCGETFS. In addition to the statistics above, each rule keeps a hit count, counting both number of packets and bytes.  To reset these counters for a rule, load the various rule information into a frentry structure and call SIOCZRLST.</dd>
</dl>
<dl>
<dt>
Swapping Active lists</dt>
<dd>
IP Filter supports two lists of rules for filtering and accounting: an active list and an inactive list.  This allows for large scale rule base changes to be put in place atomically with otherwise minimal interruption. Which of the two is active can be changed using the SIOCSWAPA ioctl.  It is important to note that no passed argument is recognised and that the value returned is that of the list which is now inactive.<div style="height: 0.00em;">
&#160;</div>
</dd>
</dl>
</div>
<div class="section">
<h1>FILES</h1> /dev/ipauth<div style="height: 0.00em;">
&#160;</div>
/dev/ipl<div style="height: 0.00em;">
&#160;</div>
/dev/ipnat<div style="height: 0.00em;">
&#160;</div>
/dev/ipstate</div>
<div class="section">
<h1>SEE ALSO</h1> ipl(4), ipnat(4), ipf(5), ipf(8), ipfstat(8)</div>
<div class="section">
<h1>BUGS</h1> When a packet encapsulated by ipsec(4) tunnel comes in, ipf(4) looks at wire-format packet on inbound and outbound. ipf(4) will not look at decapsulated packets on inbound, nor packets prior to encapsulation on outbound.<p>
When tunneled packets arrive at the node and are handled by a tunneling pseudo interface like gif(4), the packets may go through ipf(4) twice, before and after decapsulation. In some cases it may be necessary to check, in the ipf(4) rules, if the inbound interface is a tunneling pseudo interface or not.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tr>
<td class="foot-date">
</td>
<td class="foot-os" align="right">
</td>
</tr>
</table>
</div>
</body>
</html>

