<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/../4/strict.dtd">
>
<head>
<meta http-equiv="Content-Type" content="te../; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
RAID(4)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
RAID(4)</td>
<td class="head-vol" align="center">
Kernel Interfaces Manual</td>
<td class="head-rtitle" align="right">
RAID(4)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">raid</b> &#8212; <span class="desc">RAIDframe disk driver</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="config">options RAID_AUTOCONFIG</b><br>
<b class="config">options RAID_DIAGNOSTIC</b><br>
<b class="config">options RF_ACC_TRACE=n</b><br>
<b class="config">options RF_DEBUG_MAP=n</b><br>
<b class="config">options RF_DEBUG_PSS=n</b><br>
<b class="config">options RF_DEBUG_QUEUE=n</b><br>
<b class="config">options RF_DEBUG_QUIESCE=n</b><br>
<b class="config">options RF_DEBUG_RECON=n</b><br>
<b class="config">options RF_DEBUG_STRIPELOCK=n</b><br>
<b class="config">options RF_DEBUG_VALIDATE_DAG=n</b><br>
<b class="config">options RF_DEBUG_VERIFYPARITY=n</b><br>
<b class="config">options RF_INCLUDE_CHAINDECLUSTER=n</b><br>
<b class="config">options RF_INCLUDE_EVENODD=n</b><br>
<b class="config">options RF_INCLUDE_INTERDECLUSTER=n</b><br>
<b class="config">options RF_INCLUDE_PARITY_DECLUSTERING=n</b><br>
<b class="config">options RF_INCLUDE_PARITY_DECLUSTERING_DS=n</b><br>
<b class="config">options RF_INCLUDE_PARITYLOGGING=n</b><br>
<b class="config">options RF_INCLUDE_RAID5_RS=n</b><p>
<br>
<b class="config">pseudo-device raid</b></div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <b class="name">raid</b> driver provides RAID 0, 1, 4, and 5 (and more!) capabilities to <span class="unix">NetBSD</span>. This document assumes that the reader has at least some familiarity with RAID and RAID concepts. The reader is also assumed to know how to configure disks and pseudo-devices into kernels, how to generate kernels, and how to partition disks.<p>
RAIDframe provides a number of different RAID levels including:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
RAID 0</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
provides simple data striping across the components.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
RAID 1</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
provides mirroring.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
RAID 4</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
provides data striping across the components, with parity stored on a dedicated drive (in this case, the last component).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
RAID 5</dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
provides data striping across the components, with parity distributed across all the components.</dd>
</dl>
<p>
There are a wide variety of other RAID levels supported by RAIDframe. The configuration file options to enable them are briefly outlined at the end of this section.<p>
Depending on the parity level configured, the device driver can support the failure of component drives. The number of failures allowed depends on the parity level selected. If the driver is able to handle drive failures, and a drive does fail, then the system is operating in "degraded mode". In this mode, all missing data must be reconstructed from the data and parity present on the other components. This results in much slower data accesses, but does mean that a failure need not bring the system to a complete halt.<p>
The RAID driver supports and enforces the use of &#8216;component labels&#8217;. A &#8216;component label&#8217; contains important information about the component, including a user-specified serial number, the row and column of that component in the RAID set, and whether the data (and parity) on the component is &#8216;clean&#8217;. The component label currently lives at the half-way point of the &#8216;reserved section&#8217; located at the beginning of each component. This &#8216;reserved section&#8217; is RF_PROTECTED_SECTORS in length (64 blocks or 32Kbytes) and the component label is currently 1Kbyte in size.<p>
If the driver determines that the component labels are very inconsistent with respect to each other (e.g. two or more serial numbers do not match) or that the component label is not consistent with its assigned place in the set (e.g. the component label claims the component should be the 3rd one in a 6-disk set, but the RAID set has it as the 3rd component in a 5-disk set) then the device will fail to configure. If the driver determines that exactly one component label seems to be incorrect, and the RAID set is being configured as a set that supports a single failure, then the RAID set will be allowed to configure, but the incorrectly labeled component will be marked as &#8216;failed&#8217;, and the RAID set will begin operation in degraded mode. If all of the components are consistent among themselves, the RAID set will configure normally.<p>
Component labels are also used to support the auto-detection and autoconfiguration of RAID sets. A RAID set can be flagged as autoconfigurable, in which case it will be configured automatically during the kernel boot process. RAID file systems which are automatically configured are also eligible to be the root file system. There is currently only limited support (alpha, amd64, i386, pmax, sparc, sparc64, and vax architectures) for booting a kernel directly from a RAID 1 set, and no support for booting from any other RAID sets. To use a RAID set as the root file system, a kernel is usually obtained from a small non-RAID partition, after which any autoconfiguring RAID set can be used for the root file system. See <a class="link-man" href="../8/raidctl">raidctl(8)</a> for more information on autoconfiguration of RAID sets. Note that with autoconfiguration of RAID sets, it is no longer necessary to hard-code SCSI IDs of drives. The autoconfiguration code will correctly configure a device even after any number of the components have had their device IDs changed or device names changed.<p>
The driver supports &#8216;hot spares&#8217;, disks which are on-line, but are not actively used in an existing file system. Should a disk fail, the driver is capable of reconstructing the failed disk onto a hot spare or back onto a replacement drive. If the components are hot swappable, the failed disk can then be removed, a new disk put in its place, and a copyback operation performed. The copyback operation, as its name indicates, will copy the reconstructed data from the hot spare to the previously failed (and now replaced) disk. Hot spares can also be hot-added using <a class="link-man" href="../8/raidctl">raidctl(8)</a>.<p>
If a component cannot be detected when the RAID device is configured, that component will be simply marked as 'failed'.<p>
The user-land utility for doing all <b class="name">raid</b> configuration and other operations is <a class="link-man" href="../8/raidctl">raidctl(8)</a>. Most importantly, <a class="link-man" href="../8/raidctl">raidctl(8)</a> must be used with the <b class="flag">&#45;i</b> option to initialize all RAID sets. In particular, this initialization includes re-building the parity data. This rebuilding of parity data is also required when either a) a new RAID device is brought up for the first time or b) after an un-clean shutdown of a RAID device. By using the <b class="flag">&#45;P</b> option to <a class="link-man" href="../8/raidctl">raidctl(8)</a>, and performing this on-demand recomputation of all parity before doing a <a class="link-man" href="../8/fsck">fsck(8)</a> or a <a class="link-man" href="../8/newfs">newfs(8)</a>, file system integrity and parity integrity can be ensured. It bears repeating again that parity recomputation is <i class="arg">required</i> before any file systems are created or used on the RAID device. If the parity is not correct, then missing data cannot be correctly recovered.<p>
RAID levels may be combined in a hierarchical fashion. For example, a RAID 0 device can be constructed out of a number of RAID 5 devices (which, in turn, may be constructed out of the physical disks, or of other RAID devices).<p>
The first step to using the <b class="name">raid</b> driver is to ensure that it is suitably configured in the kernel. This is done by adding a line similar to:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
pseudo-device   raid         # RAIDframe disk device</pre>
<p>
to the kernel configuration file. The RAIDframe drivers are configured dynamically as needed. To turn on component auto-detection and autoconfiguration of RAID sets, simply add:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
options RAID_AUTOCONFIG</pre>
<p>
to the kernel configuration file.<p>
All component partitions must be of the type <span class="define">FS_BSDFFS</span> (e.g. 4.2BSD) or <span class="define">FS_RAID</span>. The use of the latter is strongly encouraged, and is required if autoconfiguration of the RAID set is desired. Since RAIDframe leaves room for disklabels, RAID components can be simply raw disks, or partitions which use an entire disk.<p>
A more detailed treatment of actually using a <b class="name">raid</b> device is found in <a class="link-man" href="../8/raidctl">raidctl(8)</a>. It is highly recommended that the steps to reconstruct, copyback, and re-compute parity are well understood by the system administrator(s) <i class="arg">before</i> a component failure. Doing the wrong thing when a component fails may result in data loss.<p>
Additional internal consistency checking can be enabled by specifying:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
options RAID_DIAGNOSTIC</pre>
<p>
These assertions are disabled by default in order to improve performance.<p>
RAIDframe supports an access tracing facility for tracking both requests made and performance of various parts of the RAID systems as the request is processed. To enable this tracing the following option may be specified:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
options RF_ACC_TRACE=1</pre>
<p>
For extensive debugging there are a number of kernel options which will aid in performing extra diagnosis of various parts of the RAIDframe sub-systems. Note that in order to make full use of these options it is often necessary to enable one or more debugging options as listed in <i class="file">src/sys/dev/raidframe/rf_options.h</i>. As well, these options are also only typically useful for people who wish to debug various parts of RAIDframe. The options include:<p>
For debugging the code which maps RAID addresses to physical addresses:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
options RF_DEBUG_MAP=1</pre>
<p>
Parity stripe status debugging is enabled with:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
options RF_DEBUG_PSS=1</pre>
<p>
Additional debugging for queuing is enabled with:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
options RF_DEBUG_QUEUE=1</pre>
<p>
Problems with non-quiescent file systems should be easier to debug if the following is enabled:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
options RF_DEBUG_QUIESCE=1</pre>
<p>
Stripelock debugging is enabled with:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
options RF_DEBUG_STRIPELOCK=1</pre>
<p>
Additional diagnostic checks during reconstruction are enabled with:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
options RF_DEBUG_RECON=1</pre>
<p>
Validation of the DAGs (Directed Acyclic Graphs) used to describe an I/O access can be performed when the following is enabled:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
options RF_DEBUG_VALIDATE_DAG=1</pre>
<p>
Additional diagnostics during parity verification are enabled with:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
options RF_DEBUG_VERIFYPARITY=1</pre>
<p>
There are a number of less commonly used RAID levels supported by RAIDframe. These additional RAID types should be considered experimental, and may not be ready for production use. The various types and the options to enable them are shown here:<p>
For Even-Odd parity:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
options RF_INCLUDE_EVENODD=1</pre>
<p>
For RAID level 5 with rotated sparing:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
options RF_INCLUDE_RAID5_RS=1</pre>
<p>
For Parity Logging (highly experimental):<p>
<pre style="margin-left: 5.00ex;" class="lit display">
options RF_INCLUDE_PARITYLOGGING=1</pre>
<p>
For Chain Declustering:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
options RF_INCLUDE_CHAINDECLUSTER=1</pre>
<p>
For Interleaved Declustering:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
options RF_INCLUDE_INTERDECLUSTER=1</pre>
<p>
For Parity Declustering:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
options RF_INCLUDE_PARITY_DECLUSTERING=1</pre>
<p>
For Parity Declustering with Distributed Spares:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
options RF_INCLUDE_PARITY_DECLUSTERING_DS=1</pre>
<p>
The reader is referred to the RAIDframe documentation mentioned in the <i class="link-sec"><a class="link-sec" href="#x484953544f5259">HISTORY</a></i> section for more detail on these various RAID configurations.</div>
<div class="section">
<h1 id="x5741524e494e4753">WARNINGS</h1> Certain RAID levels (1, 4, 5, 6, and others) can protect against some data loss due to component failure. However the loss of two components of a RAID 4 or 5 system, or the loss of a single component of a RAID 0 system, will result in the entire file systems on that RAID device being lost. RAID is <i class="arg">NOT</i> a substitute for good backup practices.<p>
Recomputation of parity <i class="arg">MUST</i> be performed whenever there is a chance that it may have been compromised. This includes after system crashes, or before a RAID device has been used for the first time. Failure to keep parity correct will be catastrophic should a component ever fail -- it is better to use RAID 0 and get the additional space and speed, than it is to use parity, but not keep the parity correct. At least with RAID 0 there is no perception of increased data security.</div>
<div class="section">
<h1 id="x46494c4553">FILES</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="file">/dev/{,r}raid*</i></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
<b class="name">raid</b> device special files.</dd>
</dl>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../1/config">config(1)</a>, <a class="link-man" href="../4/sd">sd(4)</a>, <a class="link-man" href="../8/fsck">fsck(8)</a>, <a class="link-man" href="../8/MAKEDEV">MAKEDEV(8)</a>, <a class="link-man" href="../8/mount">mount(8)</a>, <a class="link-man" href="../8/newfs">newfs(8)</a>, <a class="link-man" href="../8/raidctl">raidctl(8)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The <b class="name">raid</b> driver in <span class="unix">NetBSD</span> is a port of RAIDframe, a framework for rapid prototyping of RAID structures developed by the folks at the Parallel Data Laboratory at Carnegie Mellon University (CMU). RAIDframe, as originally distributed by CMU, provides a RAID simulator for a number of different architectures, and a user-level device driver and a kernel device driver for Digital Unix. The <b class="name">raid</b> driver is a kernelized version of RAIDframe v1.1.<p>
A more complete description of the internals and functionality of RAIDframe is found in the paper "RAIDframe: A Rapid Prototyping Tool for RAID Systems", by William V. Courtright II, Garth Gibson, Mark Holland, LeAnn Neal Reilly, and Jim Zelenka, and published by the Parallel Data Laboratory of Carnegie Mellon University. The <b class="name">raid</b> driver first appeared in <span class="unix">NetBSD&#160;1.4</span>.</div>
<div class="section">
<h1 id="x434f50595249474854">COPYRIGHT</h1><pre style="margin-left: 0.00ex;" class="lit display">
The RAIDframe Copyright is as follows: 
<p>
Copyright (c) 1994-1996 Carnegie-Mellon University. 
All rights reserved. 
<p>
Permission to use, copy, modify and distribute this software and 
its documentation is hereby granted, provided that both the copyright 
notice and this permission notice appear in all copies of the 
software, derivative works or modified versions, and any portions 
thereof, and that both notices appear in supporting documentation. 
<p>
CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE. 
<p>
Carnegie Mellon requests users of this software to return to 
<p>
 Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU 
 School of Computer Science 
 Carnegie Mellon University 
 Pittsburgh PA 15213-3890 
<p>
any improvements or extensions that they make and grant Carnegie the 
rights to redistribute these changes.</pre>
</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
August 6, 2007</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
<>

