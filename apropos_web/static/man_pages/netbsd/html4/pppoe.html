<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
PPPOE(4)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
PPPOE(4)</td>
<td class="head-vol" align="center">
Kernel Interfaces Manual</td>
<td class="head-rtitle" align="right">
PPPOE(4)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">pppoe</b> &#8212; <span class="desc">PPP over Ethernet protocol network interface</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="config">pseudo-device pppoe</b></div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <b class="name">pppoe</b> interface encapsulates <span class="emph">Point-to-Point Protocol (PPP)</span> packets inside Ethernet frames as defined by <code class="lit">RFC2516</code>.<p>
This is often used to connect a router via a DSL modem to an access concentrator. The <b class="name">pppoe</b> interface does not by itself transmit or receive frames, but needs an Ethernet interface to do so. This Ethernet interface is connected to the <b class="name">pppoe</b> interface via <a class="link-man" href="../8/pppoectl">pppoectl(8)</a>. The Ethernet interface needs to be marked UP, but does not need to have an IP address.<p>
There are two basic modes of operation, controlled via the <span class="emph">link1</span> switch. The default mode, <span class="emph">link1</span> not being set, tries to keep the configured session open all the time. If the session is disconnected, a new connection attempt is started immediately. The &#8220;dial on demand&#8221; mode, selected by setting <span class="emph">link1</span>, only establishes a connection when data is being sent to the interface.<p>
If the kernel is compiled with options <span class="define">PPPOE_SERVER</span>, there are two modes of connection, controlled via the <span class="emph">link0</span> switch. The default mode, <span class="emph">link0</span> not being set, is client mode. The &#8220;PPPoE server&#8221; mode, selected by setting <span class="emph">link0</span>, is to wait for incoming PPPoE session.<p>
Before a <b class="name">pppoe</b> interface is usable, it needs to be configured. The following steps are necessary:<ul style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-bul">
<li class="list-bul" style="margin-top: 1.00em;">
Create the interface.</li>
<li class="list-bul" style="margin-top: 1.00em;">
Connect an Ethernet interface. This interface is used for the physical communication. As noted above it must be marked UP, but need not have an IP address.</li>
<li class="list-bul" style="margin-top: 1.00em;">
Configure authentication. The PPP session needs to identify the client to the peer. For more details on the available options see <a class="link-man" href="../8/pppoectl">pppoectl(8)</a>.</li>
</ul>
<p>
This all is typically accomplished using an <i class="file">/etc/ifconfig.pppoe0</i> file.<div class="subsection">
<h2 id="x4d53532f4d54552070726f626c656d73">MSS/MTU problems</h2> If you are using a <b class="name">pppoe</b> interface, you will have an unusually low MTU for today's Internet. Combined with a lot of misconfigured sites (host using path MTU discovery behind a router blocking all ICMP traffic) this will often cause problems. Connections to these servers will only work if your system advertises the right MSS in the TCP three way handshake. To get the right MSS, you need to set<p>
<pre style="margin-left: 5.00ex;" class="lit display">
# Obey interface MTUs when calculating MSS 
net.inet.tcp.mss_ifmtu=1</pre>
<p>
in your <i class="file">/etc/sysctl.conf</i> file. This causes the calculated MSS to be based on the MTU of the interface via which the packet is sent. This is always the right value if you are sure the answer to this packet will be received on the same interface (i.e., you only have one interface connected to the Internet.)<p>
Unfortunately this sysctl does not fix the MSS advertised by hosts in the network behind a <b class="name">pppoe</b> connected router. To fix this you need <span class="emph">MSS-clamping</span>, explained below.</div>
<div class="subsection">
<h2 id="x53657474696e67207570204e41542077697468204d53531e636c616d70696e67">Setting up NAT with MSS-clamping</h2> Some systems behind misconfigured firewalls try to use Path-MTU-Discovery, while their firewall blocks all ICMP messages. This is an illegal, but not uncommon, setup. Typically you will have no chance to fix this (remote, outside of your control) setup. And sometimes you will have to use such remote systems (to download data from them, or to do your online banking).<p>
Without special care systems as described above will not be able to send larger chunks of data to a system connected via <b class="name">pppoe</b>. But there is a workaround (some may call it cheating): pretend to not be able to handle large packets, by sending a small MSS (maximum segment size) option during initial TCP handshake.<p>
For connections originating from your <b class="name">pppoe</b> connected machines, this is accomplished by setting the sysctl variable <span class="define">net.inet.tcp.mss_ifmtu</span> to 1 (see above). For connections originating from systems behind your <b class="name">pppoe</b> router, you need to set the <span class="define">mssclamp</span> options in your NAT rules, like in this example of <i class="file">/etc/ipnat.conf</i>:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
map pppoe0 192.168.1.0/24 -&gt; 0/32 portmap tcp/udp 44000:49999 mssclamp 1440 
map pppoe0 192.168.1.0/24 -&gt; 0/32 mssclamp 1440</pre>
<p>
If you do not use NAT, you need to set up a 1:1 NAT rule, just to get the clamping:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
map pppoe0 x.x.x.x/24 -&gt; 0/0 mssclamp 1440</pre>
<p>
The above examples assume a MTU of 1492 bytes. If the MTU on your PPPoE connection is smaller use the MTU &#45; 52 bytes for clamping e.g. 1408 bytes for a MTU of 1460 bytes. <span class="emph">Note</span>: The theoretically correct value for the above example would be 1452 bytes (it accounts for the smaller PPPoE MTU, the TCP header and the maximum of 0x40 bytes of TCP options) but it seems to not be sufficient in some cases. Experiments conducted by various people have shown that clamping to the MSS values suggested above works best.</div>
</div>
<div class="section">
<h1 id="x4558414d504c4553">EXAMPLES</h1> A typical <i class="file">/etc/ifconfig.pppoe0</i> file looks like this:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
create 
! /sbin/ifconfig ne0 up 
! /sbin/pppoectl -e ne0 $int 
! /sbin/pppoectl $int myauthproto=pap myauthname=testcaller myauthsecret=donttell 
inet 0.0.0.0 0.0.0.1 netmask 0xffffffff 
#! /sbin/route add default -iface 0.0.0.1 
up</pre>
The commented out call to <a class="link-man" href="../8/route">route(8)</a> may be omitted and the route added in the ip-up script called by <a class="link-man" href="../8/ifwatchd">ifwatchd(8)</a> when the real IP address is known. This is easy in the &#8220;connect always&#8221; mode (link1 not set), but hard to accomplish in the &#8220;dial on demand&#8221; mode (link1 set). In the latter case adding an iface route is an easy workaround.<p>
The <b class="name">pppoe</b> interfaces operate completely inside the kernel, without any userland support. Because of this, a special daemon is used to fire ip-up or down scripts to execute arbitrary code when the PPP session is established and addresses of the interface become available. To enable the usage of <i class="file">/etc/ppp/ip-up</i> and <i class="file">/etc/ppp/ip-down</i> for this purpose, simply add<p>
<pre style="margin-left: 5.00ex;" class="lit display">
ifwatchd=YES</pre>
<p>
to <i class="file">/etc/rc.conf</i>. See <a class="link-man" href="../8/ifwatchd">ifwatchd(8)</a> for details and parameters passed to these scripts.<p>
Since this is a PPP interface, the addresses assigned to the interface may change during PPP negotiation. There is no fine grained control available for deciding which addresses are acceptable and which are not. For the local side and the remote address there is exactly one choice: hard coded address or wildcard. If a real address is assigned to one side of the connection, PPP negotiation will only agree to exactly this address. If one side is wildcarded, every address suggested by the peer will be accepted.<p>
To wildcard the local address set it to 0.0.0.0, to wildcard the remote address set it to 0.0.0.1. Wildcarding is not available (nor necessary) for IPv6 operation.</div>
<div class="section">
<h1 id="x4f5054494f4e53">OPTIONS</h1> A <b class="name">pppoe</b> enabled kernel will not interfere with other <b class="name">PPPoE</b> implementations running on the same machine. Under special circumstances (details below) this is not desirable, so the <b class="name">pppoe</b> driver can be told to kill all unknown <b class="name">PPPoE</b> sessions received by the Ethernet interface used for a configured <b class="name">pppoe</b> interface. To do this, add the following to your kernel config file:<p>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">options PPPOE_TERM_UNKNOWN_SESSIONS</code></div>
</blockquote>
<p>
Note that this will break all userland <b class="name">PPPoE</b> implementations using the same Ethernet interface!<p>
This option is only useful if you have a static IP address assigned and your ISP does not use LCP echo requests to monitor the link status. After a crash or power failure the peer device still tries to send data to the no longer active session on your computer, and might refuse to reestablish a new connection, because there already is an open session. On receipt of such packets, the <b class="name">pppoe</b> driver with this option set will send a PADT packet (request to terminate the session). The peer will immediately disconnect the orphaned session and allow a new one to be established.<p>
To enable <b class="name">pppoe</b> server support in the kernel, use<p>
<blockquote style="margin-top: 0.00em;margin-bottom: 0.00em;">
<div class="display">
<code class="lit">options PPPOE_SERVER</code></div>
</blockquote>
<p>
As described above, this allows <b class="name">pppoe</b> interfaces to be created and configured for incoming connections by setting the &#8220;<code class="lit">link0</code>&#8221; flag with <a class="link-man" href="../8/ifconfig">ifconfig(8)</a>.</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../8/ifwatchd">ifwatchd(8)</a>, <a class="link-man" href="../8/pppoectl">pppoectl(8)</a><p>
<span class="ref"><span class="ref-title">A Method for Transmitting PPP Over Ethernet (PPPoE)</span>, <span class="ref-rep">RFC</span>, <span class="ref-num">2516</span>, <span class="ref-date">February 1999</span>.</span><p>
<span class="ref"><span class="ref-title">Accommodating a Maximum Transit Unit/Maximum Receive Unit (MTU/MRU) Greater Than 1492 in the Point-to-Point Protocol over Ethernet (PPPoE)</span>, <span class="ref-rep">RFC</span>, <span class="ref-num">4638</span>, <span class="ref-date">September 2006</span>.</span></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The <b class="name">pppoe</b> device appeared in <span class="unix">NetBSD&#160;1.6</span>.</div>
<div class="section">
<h1 id="x444556494154494f4e532046524f4d205354414e44415244">DEVIATIONS FROM STANDARD</h1> The original PPPoE standard, <code class="lit">RFC2516</code>, requires a maximal MTU of 1492 octets. This value is the maximum conservative value possible, based on the PPPoE header size and the minimum frame size Ethernet interfaces are required to support.<p>
In practice most modern Ethernet interfaces support bigger frames, and many PPPoE services allow the use of (slightly) larger MTUs, to avoid the problems described above.<p>
This implementation allows MTU values as large as possible with the actual MTU of the used Ethernet interface and conforms to the enhancement to the PPPoE standard, <code class="lit">RFC4638</code>, to request the use of this larger MTU value with the PPPoE server.</div>
<div class="section">
<h1 id="x42554753">BUGS</h1> When using the wildcard address 0.0.0.0 (as described above) it is important to specify the proper &#8220;<code class="lit">netmask</code>&#8221; to <a class="link-man" href="../8/ifconfig">ifconfig(8)</a>, in most setups &#8220;<code class="lit">0xffffffff</code>&#8221;. If the netmask is unspecified, it will be set to 8 when 0.0.0.0 is configured to the interface, and it will persist after negotiation.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
February 24, 2012</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

