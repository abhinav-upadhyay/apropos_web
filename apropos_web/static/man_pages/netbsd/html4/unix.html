<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/../4/strict.dtd">
>
<head>
<meta http-equiv="Content-Type" content="te../; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
UNIX(4)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
UNIX(4)</td>
<td class="head-vol" align="center">
Kernel Interfaces Manual</td>
<td class="head-rtitle" align="right">
UNIX(4)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">unix</b> &#8212; <span class="desc">UNIX-domain protocol family</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/types.h</a>&gt;</b><br>
<b class="includes">#include &lt;<a class="link-includes">sys/un.h</a>&gt;</b></div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The UNIX-domain protocol family is a collection of protocols that provides local (on-machine) interprocess communication through the normal <a class="link-man" href="../2/socket">socket(2)</a> mechanisms. The UNIX-domain family supports the <span class="define">SOCK_STREAM</span>, <span class="define">SOCK_SEQPACKET</span>, and <span class="define">SOCK_DGRAM</span> socket types and uses filesystem pathnames for addressing.</div>
<div class="section">
<h1 id="x41444452455353494e47">ADDRESSING</h1> UNIX-domain addresses are variable-length filesystem pathnames of at most 104 characters. The include file <b class="includes">&lt;<a class="link-includes">sys/un.h</a>&gt;</b> defines this address:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
struct sockaddr_un { 
	u_char	sun_len; 
	u_char	sun_family; 
	char	sun_path[104]; 
};</pre>
<p>
Binding a name to a UNIX-domain socket with <a class="link-man" href="../2/bind">bind(2)</a> causes a socket file to be created in the filesystem. This file is <span class="emph">not</span> removed when the socket is closed&#8212;<a class="link-man" href="../2/unlink">unlink(2)</a> must be used to remove the file.<p>
The length of UNIX-domain address, required by <a class="link-man" href="../2/bind">bind(2)</a> and <a class="link-man" href="../2/connect">connect(2)</a>, can be calculated by the macro <b class="fname">SUN_LEN</b>() defined in <b class="includes">&lt;<a class="link-includes">sys/un.h</a>&gt;</b>. The <i class="arg">sun_path</i> field must be terminated by a NUL character to be used with <b class="fname">SUN_LEN</b>(), but the terminating NUL is <span class="emph">not</span> part of the address. The <span class="unix">NetBSD</span> kernel ignores any user-set value in the <b class="var">sun_len</b> member of the structure.<p>
The UNIX-domain protocol family does not support broadcast addressing or any form of &#8220;wildcard&#8221; matching on incoming messages. All addresses are absolute- or relative-pathnames of other UNIX-domain sockets. Normal filesystem access-control mechanisms are also applied when referencing pathnames; e.g., the destination of a <a class="link-man" href="../2/connect">connect(2)</a> or <a class="link-man" href="../2/sendto">sendto(2)</a> must be writable.</div>
<div class="section">
<h1 id="x50524f544f434f4c53">PROTOCOLS</h1> The UNIX-domain protocol family comprises simple transport protocols that support the <span class="define">SOCK_STREAM</span>, <span class="define">SOCK_SEQPACKET</span>, and <span class="define">SOCK_DGRAM</span> abstractions. <span class="define">SOCK_STREAM</span> and <span class="define">SOCK_SEQPACKET</span> sockets also support the communication of <span class="unix">UNIX</span> file descriptors through the use of the <i class="arg">msg_control</i> field in the <i class="arg">msg</i> argument to <a class="link-man" href="../2/sendmsg">sendmsg(2)</a> and <a class="link-man" href="../2/recvmsg">recvmsg(2)</a>.<p>
Any valid descriptor may be sent in a message. The file descriptor(s) to be passed are described using a <i class="arg">struct cmsghdr</i> that is defined in the include file <b class="includes">&lt;<a class="link-includes">sys/socket.h</a>&gt;</b>. The type of the message is <span class="define">SCM_RIGHTS</span>, and the data portion of the messages is an array of integers representing the file descriptors to be passed. The number of descriptors being passed is defined by the length field of the message; the length field is the sum of the size of the header plus the size of the array of file descriptors.<p>
The received descriptor is a <span class="emph">duplicate</span> of the sender's descriptor, as if it were created with a call to <a class="link-man" href="../2/dup">dup(2)</a>. Per-process descriptor flags, set with <a class="link-man" href="../2/fcntl">fcntl(2)</a>, are <span class="emph">not</span> passed to a receiver. Descriptors that are awaiting delivery, or that are purposely not received, are automatically closed by the system when the destination socket is closed.<p>
A UNIX-domain socket supports two socket-level options for use with <a class="link-man" href="../2/setsockopt">setsockopt(2)</a> and <a class="link-man" href="../2/getsockopt">getsockopt(2)</a>:<p>
The <span class="define">LOCAL_CREDS</span> option may be enabled on a <span class="define">SOCK_DGRAM</span>, <span class="define">SOCK_SEQPACKET</span>, or a <span class="define">SOCK_STREAM</span> socket. This option provides a mechanism for the receiver to receive the credentials of the process as a <a class="link-man" href="../2/recvmsg">recvmsg(2)</a> control message. The msg_control field in the msghdr structure points to a buffer that contains a cmsghdr structure followed by a variable length sockcred structure, defined in <b class="includes">&lt;<a class="link-includes">sys/socket.h</a>&gt;</b> as follows:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
struct sockcred { 
	uid_t	sc_uid;			/* real user id */ 
	uid_t	sc_euid;		/* effective user id */ 
	gid_t	sc_gid;			/* real group id */ 
	gid_t	sc_egid;		/* effective group id */ 
	int	sc_ngroups;		/* number of supplemental groups */ 
	gid_t	sc_groups[1];		/* variable length */ 
};</pre>
<p>
The <span class="define">LOCAL_PEEREID</span> option may be used with <a class="link-man" href="../2/getsockopt">getsockopt(2)</a> to get the PID and effective user and group IDs of a <span class="define">SOCK_STREAM</span> or <span class="define">SOCK_SEQPACKET</span> peer when it did <a class="link-man" href="../2/connect">connect(2)</a> or <a class="link-man" href="../2/bind">bind(2)</a>. The returned structure is<p>
<pre style="margin-left: 0.00ex;" class="lit display">
struct unpcbid { 
	pid_t unp_pid;			/* process id */ 
	uid_t unp_euid;			/* effective user id */ 
	gid_t unp_egid;			/* effective group id */ 
};</pre>
as defined in <b class="includes">&lt;<a class="link-includes">sys/un.h</a>&gt;</b>.<p>
The <b class="fname">SOCKCREDSIZE</b>() macro computes the size of the sockcred structure for a specified number of groups. The cmsghdr fields have the following values:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
cmsg_len = CMSG_LEN(SOCKCREDSIZE(ngroups)) 
cmsg_level = SOL_SOCKET 
cmsg_type = SCM_CREDS</pre>
</div>
<div class="section">
<h1 id="x4558414d504c4553">EXAMPLES</h1> The following code fragment shows how to bind a socket to pathname:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
const char *pathname = "/path/to/socket"; 
struct sockaddr_un addr; 
int ret; 
 
memset(&amp;addr, 0, sizeof(addr)); 
addr.sun_family = AF_LOCAL; 
if (strlen(pathname) &#8805; sizeof(addr.sun_path)) 
	goto too_long; 
strncpy(addr.sun_path, pathname, sizeof(addr.sun_path)); 
ret = bind(s, (const struct sockaddr *)&amp;addr, SUN_LEN(&amp;addr)); 
if (ret != 0) 
	goto bind_failed; 
... 
</pre>
</div>
<div class="section">
<h1 id="x434f4d5041544942494c495459">COMPATIBILITY</h1> The <i class="arg">sun_len</i> field exists only in system derived from 4.4BSD. On systems which don't have the <b class="fname">SUN_LEN</b>() macro, the following definition is recommended:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
#ifndef SUN_LEN 
#define SUN_LEN(su)	sizeof(struct(sockaddr_un)) 
#endif</pre>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../2/socket">socket(2)</a>, <a class="link-man" href="../3/CMSG_DATA">CMSG_DATA(3)</a>, <a class="link-man" href="../4/intro">intro(4)</a><p>
<span class="ref"><span class="ref-auth">Stuart Sechrest</span>, <span class="ref-title">An Introductory 4.4BSD Interprocess Communication Tutorial</span>.</span> (see <i class="file">/usr/share/doc/psd/20.ipctut</i>)<p>
<span class="ref"><span class="ref-auth">Samuel J. Leffler</span>, <span class="ref-auth">Robert S. Fabry</span>, <span class="ref-auth">William N. Joy</span>, <span class="ref-auth">Phil Lapsley</span>, <span class="ref-auth">Steve Miller</span>, and <span class="ref-auth">Chris Torek</span>, <span class="ref-title">Advanced 4.4BSD IPC Tutorial</span>.</span> (see <i class="file">/usr/share/doc/psd/21.ipc</i>)</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
May 29, 2011</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
<>

