<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/../4/strict.dtd">
>
<head>
<meta http-equiv="Content-Type" content="te../; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
PLIP(4)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
PLIP(4)</td>
<td class="head-vol" align="center">
Kernel Interfaces Manual</td>
<td class="head-rtitle" align="right">
PLIP(4)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">plip</b> &#8212; <span class="desc">printer port Internet Protocol driver</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="config">plip* at ppbus?</b><br>
<b class="config">options PLIP_DEBUG</b></div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <b class="name">plip</b> driver allows a PC parallel printer port to be used as a point-to-point network interface between two similarly configured systems. Data is transferred 4 bits at a time, using the printer status lines for input: hence there is no requirement for special bidirectional hardware and any standard AT-compatible printer port with working interrupts may be used.<p>
During the boot process, for each <a class="link-man" href="../4/ppbus">ppbus(4)</a> device which is attached and has an interrupt capability, a corresponding <b class="name">plip</b> device is attached. The <b class="name">plip</b> device is configured using <a class="link-man" href="../8/ifconfig">ifconfig(8)</a> using the options for a point-to-point network interface:<p>
<b class="name">ifconfig</b> <i class="arg">plip0</i> <i class="arg">hostaddress destaddress</i> &#91;<span class="opt"><b class="flag">&#45;link0|link0</b></span>&#93; &#91;<span class="opt">up|down</span>&#93; &#91;<span class="opt">...</span>&#93;<p>
Configuring a <b class="name">plip</b> device &#8220;up&#8221; with <a class="link-man" href="../8/ifconfig">ifconfig(8)</a> causes the corresponding <a class="link-man" href="../4/ppbus">ppbus(4)</a> to be reserved for PLIP until the network interface is configured &#8220;down&#8221;.<p>
The communication protocol is selected by the <b class="flag">link0</b> flag:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">&#45;link0</b></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
(default) Use <span class="unix">FreeBSD</span> mode (LPIP). This is the simpler of the two modes and therefore slightly more efficient.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<b class="flag">link0</b></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Use Crynwr/Linux compatible mode (CLPIP). This mode has a simulated ethernet packet header, and is easier to interface to other types of equipment.</dd>
</dl>
<p>
The interface MTU defaults to 1500, but may be set to any value. Both ends of the link must be configured with the same MTU. See <a class="link-man" href="../8/ifconfig">ifconfig(8)</a> for details on configuring network interfaces.<div class="subsection">
<h2 id="x4361626c6520436f6e6e656374696f6e73">Cable Connections</h2> The cable connecting the two parallel ports should be wired as follows:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
	Pin	Pin	Description 
	2	15	Data0 -&gt; ERROR* 
	3	13	Data1 -&gt; SLCT 
	4	12	Data2 -&gt; PE 
	5	10	Data3 -&gt; ACK* 
	6	11	Data4 -&gt; BUSY 
	15	2	ERROR* -&gt; Data0 
	13	3	SLCT   -&gt; Data1 
	12	4	PE     -&gt; Data2 
	10	5	ACK*   -&gt; Data3 
	11	6	BUSY   -&gt; Data4 
	18-25	18-25	Ground</pre>
<p>
Cables with this wiring are widely available as &#8220;Laplink&#8221; cables, and are often colored yellow.<p>
The connections are symmetric, and provide 5 lines in each direction (four data plus one handshake). The two modes use the same wiring, but make a different choice of which line to use as handshake.</div>
<div class="subsection">
<h2 id="x46726565425344204c504950206d6f6465">FreeBSD LPIP mode</h2> The signal lines are used as follows:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="emph">Data0 (Pin 2)</span></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
Data out, bit 0.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="emph">Data1 (Pin 3)</span></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
Data out, bit 1.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="emph">Data2 (Pin 4)</span></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
Data out, bit 2.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="emph">Data3 (Pin 5)</span></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
Handshake out.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="emph">Data4 (Pin 6)</span></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
Data out, bit 3.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="emph">ERROR* (pin 15)</span></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
Data in, bit 0.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="emph">SLCT (pin 13)</span></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
Data in, bit 1.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="emph">PE (pin 12)</span></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
Data in, bit 2.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="emph">BUSY (pin 11)</span></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
Data in, bit 3.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="emph">ACK* (pin 10)</span></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
Handshake in.</dd>
</dl>
<p>
When idle, all data lines are at zero. Each byte is signaled in four steps:  sender writes the 4 most significant bits and raises the handshake line; receiver reads the 4 bits and raises its handshake to acknowledge; sender places the 4 least significant bits on the data lines and lowers the handshake; receiver reads the data and lowers its handshake.<p>
The packet format has a two-byte header, comprising the fixed values 0x08, 0x00, immediately followed by the IP header and data.<p>
The start of a packet is indicated by simply signaling the first byte of the header. The end of the packet is indicated by inverting the data lines (i.e. writing the ones-complement of the previous nibble to be transmitted) without changing the state of the handshake.<p>
Note that the end-of-packet marker assumes that the handshake signal and the data-out bits can be written in a single instruction - otherwise certain byte values in the packet data would falsely be interpreted as end-of-packet. This is not a problem for the PC printer port, but requires care when implementing this protocol on other equipment.</div>
<div class="subsection">
<h2 id="x4372796e77722f4c696e757820434c504950206d6f6465">Crynwr/Linux CLPIP mode</h2> The signal lines are used as follows:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="emph">Data0 (Pin 2)</span></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
Data out, bit 0.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="emph">Data1 (Pin 3)</span></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
Data out, bit 1.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="emph">Data2 (Pin 4)</span></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
Data out, bit 2.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="emph">Data3 (Pin 5)</span></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
Data out, bit 3.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="emph">Data4 (Pin 6)</span></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
Handshake out.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="emph">ERROR* (pin 15)</span></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
Data in, bit 0.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="emph">SLCT (pin 13)</span></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
Data in, bit 1.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="emph">PE (pin 12)</span></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
Data in, bit 2.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="emph">ACK* (pin 10)</span></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
Data in, bit 3.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="emph">BUSY (pin 11)</span></dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
Handshake in.</dd>
</dl>
<p>
When idle, all data lines are at zero. Each byte is signaled in four steps:  sender writes the 4 least significant bits and raises the handshake line; receiver reads the 4 bits and raises its handshake to acknowledge; sender places the 4 most significant bits on the data lines and lowers the handshake; receiver reads the data and lowers its handshake. [Note that this is the opposite nibble order to LPIP mode].<p>
Packet format is:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
Length (least significant byte) 
Length (most significant byte) 
12 bytes of supposed MAC addresses (ignored by FreeBSD). 
Fixed byte 0x08 
Fixed byte 0x00 
&lt;IP datagram&gt; 
Checksum byte.</pre>
<p>
The length includes the 14 header bytes, but not the length bytes themselves nor the checksum byte.<p>
The checksum is a simple arithmetic sum of all the bytes (again, including the header but not checksum or length bytes). <span class="unix">FreeBSD</span> calculates outgoing checksums, but does not validate incoming ones.<p>
The start of packet has to be signaled specially, since the line chosen for handshake-in cannot be used to generate an interrupt. The sender writes the value 0x08 to the data lines, and waits for the receiver to respond by writing 0x01 to its data lines. The sender then starts signaling the first byte of the packet (the length byte).<p>
End of packet is deduced from the packet length and is not signaled specially (although the data lines are restored to the zero, idle state to avoid spuriously indicating the start of the next packet).</div>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../4/atppc">atppc(4)</a>, <a class="link-man" href="../4/ppbus">ppbus(4)</a>, <a class="link-man" href="../8/ifconfig">ifconfig(8)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The <b class="name">plip</b> driver was implemented for <a class="link-man" href="../4/ppbus">ppbus(4)</a> in <span class="unix">FreeBSD</span> and imported into <span class="unix">NetBSD</span>. Crynwr packet drivers implemented PLIP for MS-DOS. Linux also has a PLIP driver. The protocols are know as LPIP (<span class="unix">FreeBSD</span>) and CLPIP (Crynwr/Linux) in the documentation and code of this port. LPIP originally appeared in <span class="unix">FreeBSD</span>.</div>
<div class="section">
<h1 id="x415554484f5253">AUTHORS</h1> This manual page is based on the <span class="unix">FreeBSD</span> <b class="name">lp</b> manual page. The information has been updated for the <span class="unix">NetBSD</span> port by Gary Thorpe.</div>
<div class="section">
<h1 id="x42554753">BUGS</h1> Busy-waiting loops are used while handshaking bytes (and worse still when waiting for the receiving system to respond to an interrupt for the start of a packet). Hence a fast system talking to a slow one will consume excessive amounts of CPU. This is unavoidable in the case of CLPIP mode due to the choice of handshake lines; it could theoretically be improved in the case of LPIP mode.<p>
Regardless of the speed difference between hosts, PLIP is CPU-intensive and its made worse by having to send nibbles (4 bits) at a time.<p>
Polling timeouts are controlled by counting loop iterations rather than timers, and so are dependent on CPU speed. This is somewhat stabilized by the need to perform (slow) ISA bus cycles to actually read the port.<p>
In the <span class="unix">FreeBSD</span> implementation, the idle state was not properly being restored on errors or when finishing transmitting/receiving. This implementation attempts to fix this problem which would result in an unresponsive interface that could no longer be used (the port bits get stuck in a state and nothing can progress) by zeroing the data register when necessary.<p>
For unknown reasons, the more complex protocol (CLPIP) yields higher data transfer rates during testing so far. This could possibly be because the other side can reliably detect when the host is transmitting in this implementation of CLPIP (this may not necessarily be true in Linux or MS-DOS packet drivers). CLPIP gets about 70 KB/sec (the best expected is about 75 KB/sec) and LPIP get about 55 KB/sec. This is despite LPIP being able to send more packets over the interface (tested with &#8220;<b class="cmd">ping</b> <b class="flag">&#45;f</b>&#8221;) compared to CLPIP.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
January 28, 2004</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
<>

