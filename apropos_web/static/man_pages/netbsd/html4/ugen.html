<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
UGEN(4)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
UGEN(4)</td>
<td class="head-vol" align="center">
Kernel Interfaces Manual</td>
<td class="head-rtitle" align="right">
UGEN(4)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">ugen</b> &#8212; <span class="desc">USB generic device support</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="config">ugen* at uhub? flags N</b></div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <b class="name">ugen</b> driver provides support for all USB devices that do not have a special driver. It supports access to all parts of the device, but not in a way that is as convenient as a special purpose driver.<p>
Normally the <b class="name">ugen</b> driver is used when no other driver attaches to a device. If &#8220;flags 1&#8221; is specified, the <b class="name">ugen</b> will instead attach with a very high priority and always be used. Together with the <b class="config">vendor</b> and <b class="config">product</b> locators this can be used to force the <b class="name">ugen</b> driver to be used for a certain device.<p>
There can be up to 127 USB devices connected to a USB bus. Each USB device can have up to 16 endpoints. Each of these endpoints will communicate in one of four different modes: control, isochronous, bulk, or interrupt. Each of the endpoints will have a different device node. The four least significant bits in the minor device number determines which endpoint the device accesses and the rest of the bits determines which USB device.<p>
If an endpoint address is used both for input and output the device can be opened for both read or write.<p>
To find out what endpoints exist there are a series of <a class="link-man" href="../html2/ioctl.html">ioctl(2)</a> operations on the control endpoint that return the USB descriptors of the device, configurations, interfaces, and endpoints.<p>
The control transfer mode can only happen on the control endpoint which is always endpoint 0. The control endpoint accepts requests and may respond with an answer to such requests. Control requests are issued by <a class="link-man" href="../html2/ioctl.html">ioctl(2)</a> calls.<p>
The bulk transfer mode can be in or out depending on the endpoint. To perform IO on a bulk endpoint <a class="link-man" href="../html2/read.html">read(2)</a> and <a class="link-man" href="../html2/write.html">write(2)</a> should be used. All IO operations on a bulk endpoint are normally unbuffered. The <span class="define">USB_SET_BULK_RA</span> and <span class="define">USB_SET_BULK_WB</span> <a class="link-man" href="../html2/ioctl.html">ioctl(2)</a> calls enable read-ahead and write-behind buffering, respectively. This buffering supports fixed-sized USB transfers and is intended for devices with regular and continuing data transfers. When read-ahead or write-behind are enabled, the file descriptor may be set to use non-blocking IO.<p>
When in a read-ahead/writeback mode, <a class="link-man" href="../html2/select.html">select(2)</a> for read and write operates normally, returning true if there is data in the read buffer and space in the write buffer, respectively. When not, <a class="link-man" href="../html2/select.html">select(2)</a> always returns true, because there is no way to predict how the device will respond to a read or write request.<p>
The interrupt transfer mode can be in or out depending on the endpoint. To perform IO on an interrupt endpoint <a class="link-man" href="../html2/read.html">read(2)</a> and <a class="link-man" href="../html2/write.html">write(2)</a> should be used. A moderate amount of buffering is done by the driver.<p>
All endpoints handle the following <a class="link-man" href="../html2/ioctl.html">ioctl(2)</a> calls:<p>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">USB_SET_SHORT_XFER (int)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Allow short read transfer. Normally a transfer from the device which is shorter than the request specified is reported as an error.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">USB_SET_TIMEOUT (int)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Set the timeout on the device operations, the time is specified in milliseconds. The value 0 is used to indicate that there is no timeout.</dd>
</dl>
<p>
The control endpoint (endpoint 0) handles the following <a class="link-man" href="../html2/ioctl.html">ioctl(2)</a> calls:<p>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">USB_GET_CONFIG (int)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Get the device configuration number.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">USB_SET_CONFIG (int)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Set the device into the given configuration number.<p>
This operation can only be performed when the control endpoint is the sole open endpoint.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">USB_GET_ALTINTERFACE (struct usb_alt_interface)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Get the alternative setting number for the interface with the given index. The <span class="define">config_index</span> is ignored in this call.<p>
<pre style="margin-left: 0.00ex;" class="lit display">
struct usb_alt_interface { 
	int	uai_config_index; 
	int	uai_interface_index; 
	int	uai_alt_no; 
};</pre>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">USB_SET_ALTINTERFACE (struct usb_alt_interface)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Set the alternative setting to the given number in the interface with the given index. The <span class="define">uai_config_index</span> is ignored in this call.<p>
This operation can only be performed when no endpoints for the interface are open.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">USB_GET_NO_ALT (struct usb_alt_interface)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Return the number of different alternate settings in the <span class="define">uai_alt_no</span> field.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">USB_GET_DEVICE_DESC (usb_device_descriptor_t)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Return the device descriptor.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">USB_GET_CONFIG_DESC (struct usb_config_desc)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Return the descriptor for the configuration with the given index. For convenience the current configuration can be specified by <span class="define">USB_CURRENT_CONFIG_INDEX</span>.<p>
<pre style="margin-left: 0.00ex;" class="lit display">
struct usb_config_desc { 
	int	ucd_config_index; 
	usb_config_descriptor_t ucd_desc; 
};</pre>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">USB_GET_INTERFACE_DESC (struct usb_interface_desc)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Return the interface descriptor for an interface specified by its configuration index, interface index, and alternative index. For convenience the current alternative can be specified by <span class="define">USB_CURRENT_ALT_INDEX</span>.<p>
<pre style="margin-left: 0.00ex;" class="lit display">
struct usb_interface_desc { 
	int	uid_config_index; 
	int	uid_interface_index; 
	int	uid_alt_index; 
	usb_interface_descriptor_t uid_desc; 
};</pre>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">USB_GET_ENDPOINT_DESC (struct usb_endpoint_desc)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Return the endpoint descriptor for the endpoint specified by its configuration index, interface index, alternative index, and endpoint index.<p>
<pre style="margin-left: 0.00ex;" class="lit display">
struct usb_endpoint_desc { 
	int	ued_config_index; 
	int	ued_interface_index; 
	int	ued_alt_index; 
	int	ued_endpoint_index; 
	usb_endpoint_descriptor_t ued_desc; 
};</pre>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">USB_GET_FULL_DESC (struct usb_full_desc)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Return all the descriptors for the given configuration.<p>
<pre style="margin-left: 0.00ex;" class="lit display">
struct usb_full_desc { 
	int	ufd_config_index; 
	u_int	ufd_size; 
	u_char	*ufd_data; 
};</pre>
The <span class="define">ufd_data</span> field should point to a memory area of the size given in the <span class="define">ufd_size</span> field. The proper size can be determined by first issuing a <span class="define">USB_GET_CONFIG_DESC</span> and inspecting the <span class="define">wTotalLength</span> field.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">USB_GET_STRING_DESC (struct usb_string_desc)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Get a string descriptor for the given language id and string index.<p>
<pre style="margin-left: 0.00ex;" class="lit display">
struct usb_string_desc { 
	int	usd_string_index; 
	int	usd_language_id; 
	usb_string_descriptor_t usd_desc; 
};</pre>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">USB_DO_REQUEST</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Send a USB request to the device on the control endpoint. Any data sent to/from the device is located at <span class="define">data</span>. The size of the transferred data is determined from the <span class="define">request</span>. The <span class="define">ucr_addr</span> field is ignored in this call. The <span class="define">ucr_flags</span> field can be used to flag that the request is allowed to be shorter than the requested size, and the <span class="define">ucr_actlen</span> field will contain the actual size on completion.<p>
<pre style="margin-left: 0.00ex;" class="lit display">
struct usb_ctl_request { 
	int	ucr_addr; 
	usb_device_request_t ucr_request; 
	void	*ucr_data; 
	int	ucr_flags; 
#define USBD_SHORT_XFER_OK	0x04	/* allow short reads */ 
	int	ucr_actlen;		/* actual length transferred */ 
};</pre>
This is a dangerous operation in that it can perform arbitrary operations on the device. Some of the most dangerous (e.g., changing the device address) are not allowed.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">USB_GET_DEVICEINFO (struct usb_device_info)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Get an information summary for the device. This call will not issue any USB transactions.</dd>
</dl>
<p>
Bulk endpoints handle the following <a class="link-man" href="../html2/ioctl.html">ioctl(2)</a> calls:<p>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">USB_SET_BULK_RA (int)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Enable or disable bulk read-ahead. When enabled, the driver will begin to read data from the device into a buffer, and will perform reads from the device whenever there is room in the buffer. The <a class="link-man" href="../html2/read.html">read(2)</a> call will read data from this buffer, blocking if necessary until there is enough data to read the length of data requested. The buffer size and the read request length can be set by the <span class="define">USB_SET_BULK_RA_OPT</span> <a class="link-man" href="../html2/ioctl.html">ioctl(2)</a> call.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">USB_SET_BULK_WB (int)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Enable or disable bulk write-behind. When enabled, the driver will buffer data from the <a class="link-man" href="../html2/write.html">write(2)</a> call before writing it to the device, enabling the <a class="link-man" href="../html2/write.html">write(2)</a> call to return immediately. <a class="link-man" href="../html2/write.html">write(2)</a> will block if there is not enough room in the buffer for all the data. The buffer size and the write request length can be set by the <span class="define">USB_SET_BULK_WB_OPT</span> <a class="link-man" href="../html2/ioctl.html">ioctl(2)</a> call.</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">USB_SET_BULK_RA_OPT (struct usb_bulk_ra_wb_opt)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Set the size of the buffer and the length of the read requests used by the driver when bulk read-ahead is enabled. The changes do not take effect until the next time bulk read-ahead is enabled. Read requests are made for the length specified, and the host controller driver (i.e., <a class="link-man" href="../html4/ehci.html">ehci(4)</a>, <a class="link-man" href="../html4/ohci.html">ohci(4)</a>, and <a class="link-man" href="../html4/uhci.html">uhci(4)</a>) will perform as many bus transfers as required. If transfers from the device should be smaller than the maximum length, <span class="define">ra_wb_request_size</span> must be set to the required length.<p>
<pre style="margin-left: 0.00ex;" class="lit display">
struct usb_bulk_ra_wb_opt { 
	u_int	ra_wb_buffer_size; 
	u_int	ra_wb_request_size; 
};</pre>
</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<span class="define">USB_SET_BULK_WB_OPT (struct usb_bulk_ra_wb_opt)</span></dt>
<dd class="list-tag" style="margin-left: 6.00ex;">
Set the size of the buffer and the length of the write requests used by the driver when bulk write-behind is enabled. The changes do not take effect until the next time bulk write-behind is enabled.</dd>
</dl>
<p>
Note that there are two different ways of addressing configurations, interfaces, alternatives, and endpoints: by index or by number. The index is the ordinal number (starting from 0) of the descriptor as presented by the device. The number is the respective number of the entity as found in its descriptor. Enumeration of descriptors use the index, getting and setting typically uses numbers.<p>
Example: All endpoints (except the control endpoint) for the current configuration can be found by iterating the <span class="define">interface_index</span> from 0 to <span class="define">config_desc-&gt;bNumInterface-1</span> and for each of these iterating the <span class="define">endpoint_index</span> from 0 to <span class="define">interface_desc-&gt;bNumEndpoints</span>. The <span class="define">config_index</span> should set to <span class="define">USB_CURRENT_CONFIG_INDEX</span> and <span class="define">alt_index</span> should be set to <span class="define">USB_CURRENT_ALT_INDEX</span>.</div>
<div class="section">
<h1 id="x46494c4553">FILES</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="file">/dev/ugenN.EE</i></dt>
<dd class="list-tag" style="margin-left: 32.00ex;">
Endpoint <i class="file">EE</i> of device <i class="file">N</i>.</dd>
</dl>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html4/usb.html">usb(4)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The <b class="name">ugen</b> driver appeared in <span class="unix">NetBSD&#160;1.4</span>.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
December 23, 2009</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

