<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/../4/strict.dtd">
>
<head>
<meta http-equiv="Content-Type" content="te../; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
TAP(4)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
TAP(4)</td>
<td class="head-vol" align="center">
Kernel Interfaces Manual</td>
<td class="head-rtitle" align="right">
TAP(4)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">tap</b> &#8212; <span class="desc">virtual Ethernet device</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="config">pseudo-device tap</b></div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <b class="name">tap</b> driver allows the creation and use of virtual Ethernet devices. Those interfaces appear just as any real Ethernet NIC to the kernel, but can also be accessed by userland through a character device node in order to read frames being sent by the system or to inject frames.<p>
In that respect it is very similar to what <a class="link-man" href="../4/tun">tun(4)</a> provides, but the added Ethernet layer allows easy integration with machine emulators or virtual Ethernet networks through the use of <a class="link-man" href="../4/bridge">bridge(4)</a> with tunneling.<div class="subsection">
<h2 id="x494e54455246414345204352454154494f4e">INTERFACE CREATION</h2> Interfaces may be created in two different ways: using the <a class="link-man" href="../8/ifconfig">ifconfig(8)</a> <b class="flag">create</b> command with a specified device number, or its <a class="link-man" href="../2/ioctl">ioctl(2)</a> equivalent, <span class="define">SIOCIFCREATE</span>, or using the special cloning device <i class="file">/dev/tap</i>.<p>
The former works the same as any other cloning network interface: the administrator can create and destroy interfaces at any time, notably at boot time. This is the easiest way of combining <b class="name">tap</b> and <a class="link-man" href="../4/bridge">bridge(4)</a>. Later, userland will actually access the interfaces through the specific device nodes <i class="file">/dev/tapN</i>.<p>
The latter is aimed at applications that need a virtual Ethernet device for the duration of their execution. A new interface is created at the opening of <i class="file">/dev/tap</i>, and is later destroyed when the last process using the file descriptor closes it.</div>
<div class="subsection">
<h2 id="x4348415241435445522044455649434553">CHARACTER DEVICES</h2> Whether the <b class="name">tap</b> devices are accessed through the special cloning device <i class="file">/dev/tap</i> or through the specific devices <i class="file">/dev/tapN</i>, the possible actions to control the matching interface are the same.<p>
When using <i class="file">/dev/tap</i> though, as the interface is created on-the-fly, its name is not known immediately by the application. Therefore the <span class="define">TAPGIFNAME</span> ioctl is provided. It should be the first action an application using the special cloning device will do. It takes a pointer to a <i class="ftype">struct ifreq</i> as an argument.<p>
Ethernet frames sent out by the kernel on a <b class="name">tap</b> interface can be obtained by the controlling application with <a class="link-man" href="../2/read">read(2)</a>. It can also inject frames in the kernel with <a class="link-man" href="../2/write">write(2)</a>. There is absolutely no validation of the content of the injected frame, it can be any data, of any length.<p>
One call of <a class="link-man" href="../2/write">write(2)</a> will inject a single frame in the kernel, as one call of <a class="link-man" href="../2/read">read(2)</a> will retrieve a single frame from the queue, to the extent of the provided buffer. If the buffer is not large enough, the frame will be truncated.<p>
<b class="name">tap</b> character devices support the <span class="define">FIONREAD</span> ioctl which returns the size of the next available frame, or 0 if there is no available frame in the queue.<p>
They also support non-blocking I/O through the <span class="define">FIONBIO</span> ioctl. In that mode, <span class="errno">EWOULDBLOCK</span> is returned by <a class="link-man" href="../2/read">read(2)</a> when no data is available.<p>
Asynchronous I/O is supported through the <span class="define">FIOASYNC</span>, <span class="define">FIOSETOWN</span>, and <span class="define">FIOGETOWN</span> ioctls. The first will enable <span class="define">SIGIO</span> generation, while the two other configure the process group that will receive the signal when data is ready.<p>
Synchronisation may also be achieved through the use of <a class="link-man" href="../2/select">select(2)</a>, <a class="link-man" href="../2/poll">poll(2)</a>, or <a class="link-man" href="../2/kevent">kevent(2)</a>.</div>
<div class="subsection">
<h2 id="x45544845524e45542041444452455353">ETHERNET ADDRESS</h2> When a <b class="name">tap</b> device is created, it is assigned an Ethernet address of the form f2:0b:a4:xx:xx:xx. This address can later be changed using <a class="link-man" href="../8/ifconfig">ifconfig(8)</a> to add an active link layer address, or directly via the <span class="define">SIOCALIFADDR</span> ioctl on a <span class="define">PF_LINK</span> socket, as it is not available on the ioctl handler of the character device interface.</div>
</div>
<div class="section">
<h1 id="x46494c4553">FILES</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="file">/dev/tap</i></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
cloning device</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="file">/dev/tap[0-9]*</i></dt>
<dd class="list-tag" style="margin-left: 14.00ex;">
individual character device nodes</dd>
</dl>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../4/bridge">bridge(4)</a>, <a class="link-man" href="../4/etherip">etherip(4)</a>, <a class="link-man" href="../4/tun">tun(4)</a>, <a class="link-man" href="../8/ifconfig">ifconfig(8)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The <b class="name">tap</b> driver first appeared in <span class="unix">NetBSD&#160;3.0</span>.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
March 10, 2009</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
<>

