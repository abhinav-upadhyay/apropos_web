<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../../style.css" type="text/css" media="all">
<title>
PS(4) (VAX)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
PS(4)</td>
<td class="head-vol" align="center">
Kernel Interfaces Manual (VAX)</td>
<td class="head-rtitle" align="right">
PS(4)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">ps</b> &#8212; <span class="desc">Evans and Sutherland Picture System 2 graphics device interface</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="config">ps0 at uba? csr 0172460 vector psclockintr pssystemintr</b></div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> NOTE: This driver has not been ported from <span class="unix">4.4BSD</span> yet.<p>
The <b class="name">ps</b> driver provides access to an Evans and Sutherland Picture System 2 graphics device. Each minor device is a new PS2. When the device is opened, its interface registers are mapped, via virtual memory, into a user process's address space. This allows the user process very high bandwidth to the device with no system call overhead.<p>
DMA to and from the PS2 is not supported. All read and write system calls will fail. All data is moved to and from the PS2 via programmed I/O using the device's interface registers.<p>
Commands are fed to and from the driver using the following <a class="link-man" href="../../2/ioctl">ioctl(2)</a>s:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">PSIOGETADDR</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
Returns the virtual address through which the user process can access the device's interface registers.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">PSIOAUTOREFRESH</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
Start auto refreshing the screen. The argument is an address in user space where the following data resides. The first longword is a <span class="emph">count</span> of the number of static refresh buffers. The next <span class="emph">count</span> longwords are the addresses in refresh memory where the refresh buffers lie. The driver will cycle through these refresh buffers displaying them one by one on the screen.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">PSIOAUTOMAP</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
Start automatically passing the display file through the matrix processor and into the refresh buffer. The argument is an address in user memory where the following data resides. The first longword is a <span class="emph">count</span> of the number of display files to operate on. The next <span class="emph">count</span> longwords are the address of these display files. The final longword is the address in refresh buffer memory where transformed coordinates are to be placed if the driver is not in double buffer mode (see below).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">PSIODOUBLEBUFFER</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
Cause the driver to double buffer the output from the map that is going to the refresh buffer. The argument is again a user space address where the real arguments are stored. The first argument is the starting address of refresh memory where the two double buffers are located. The second argument is the length of each double buffer. The refresh mechanism displays the current double buffer, in addition to its static refresh lists, when in double buffer mode.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">PSIOSINGLEREFRESH</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
Single step the refresh process. That is, the driver does not continually refresh the screen.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">PSIOSINGLEMAP</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
Single step the matrix process. The driver does not automatically feed display files through the matrix unit.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">PSIOSINGLEBUFFER</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
Turn off double buffering.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">PSIOTIMEREFRESH</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
The argument is a count of the number of refresh interrupts to take before turning off the screen.  This is used to do time exposures.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">PSIOWAITREFRESH</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
Suspend the user process until a refresh interrupt has occurred. If in <span class="define">TIMEREFRESH</span> mode, suspend until count refreshes have occurred.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">PSIOSTOPREFRESH</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
Wait for the next refresh, stop all refreshes, and then return to user process.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">PSIOWAITMAP</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
Wait until a map done interrupt has occurred.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">PSIOSTOPMAP</span></dt>
<dd class="list-tag" style="margin-left: 17.00ex;">
Wait for a map done interrupt, do not restart the map, and then return to the user.</dd>
</dl>
</div>
<div class="section">
<h1 id="x46494c4553">FILES</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<i class="file">/dev/ps</i></dt>
<dd class="list-tag" style="margin-left: 9.00ex;">
</dd>
</dl>
</div>
<div class="section">
<h1 id="x444941474e4f5354494353">DIAGNOSTICS</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-diag">
<dt class="list-diag" style="margin-top: 1.00em;">
<b class="diag">ps device intr.</b></dt>
<dd class="list-diag">
</dd>
<dt class="list-diag" style="margin-top: 1.00em;">
<b class="diag">ps DMA intr.</b></dt>
<dd class="list-diag">
An interrupt was received from the device. This shouldn't happen, check your device configuration for overlapping interrupt vectors.</dd>
</dl>
</div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The <b class="name">ps</b> driver appeared in <span class="unix">4.2BSD</span>.</div>
<div class="section">
<h1 id="x42554753">BUGS</h1> An invalid access (e.g., longword) to a mapped interface register can cause the system to crash with a machine check. A user process could possibly cause infinite interrupts hence bringing things to a crawl.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
June 5, 1993</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

