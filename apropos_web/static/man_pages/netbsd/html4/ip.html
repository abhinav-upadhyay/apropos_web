<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/../4/strict.dtd">
>
<head>
<meta http-equiv="Content-Type" content="te../; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
IP(4)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
IP(4)</td>
<td class="head-vol" align="center">
Kernel Interfaces Manual</td>
<td class="head-rtitle" align="right">
IP(4)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">ip</b> &#8212; <span class="desc">Internet Protocol</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="includes">#include &lt;<a class="link-includes">sys/socket.h</a>&gt;</b><br>
<b class="includes">#include &lt;<a class="link-includes">netinet/in.h</a>&gt;</b><p>
<i class="ftype">int</i><br>
<b class="fname">socket</b>(<i class="farg" style="white-space:nowrap;">AF_INET</i>, <i class="farg" style="white-space:nowrap;">SOCK_RAW</i>, <i class="farg" style="white-space:nowrap;">proto</i>);</div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> IP is the network layer protocol used by the Internet protocol family. Options may be set at the IP level when using higher-level protocols that are based on IP (such as TCP and UDP). It may also be accessed through a &#8220;raw socket&#8221; when developing new protocols, or special-purpose applications.<p>
There are several IP-level <a class="link-man" href="../2/setsockopt">setsockopt(2)</a>/<a class="link-man" href="../2/getsockopt">getsockopt(2)</a> options. <span class="define">IP_OPTIONS</span> may be used to provide IP options to be transmitted in the IP header of each outgoing packet or to examine the header options on incoming packets. IP options may be used with any socket type in the Internet family. The format of IP options to be sent is that specified by the IP protocol specification (RFC 791), with one exception: the list of addresses for Source Route options must include the first-hop gateway at the beginning of the list of gateways. The first-hop gateway address will be extracted from the option list and the size adjusted accordingly before use. To disable previously specified options, use a zero-length buffer:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
setsockopt(s, IPPROTO_IP, IP_OPTIONS, NULL, 0);</pre>
<p>
<span class="define">IP_TOS</span> and <span class="define">IP_TTL</span> may be used to set the type-of-service and time-to-live fields in the IP header for <span class="define">SOCK_STREAM</span> and <span class="define">SOCK_DGRAM</span> sockets. For example,<p>
<pre style="margin-left: 0.00ex;" class="lit display">
int tos = IPTOS_LOWDELAY;       /* see &lt;netinet/ip.h&gt; */ 
setsockopt(s, IPPROTO_IP, IP_TOS, &amp;tos, sizeof(tos)); 
 
int ttl = 60;                   /* max = 255 */ 
setsockopt(s, IPPROTO_IP, IP_TTL, &amp;ttl, sizeof(ttl));</pre>
<p>
<span class="define">IP_IPSEC_POLICY</span> controls IPSec policy for sockets. For example,<p>
<pre style="margin-left: 0.00ex;" class="lit display">
const char *policy = "in ipsec ah/transport//require"; 
char *buf = ipsec_set_policy(policy, strlen(policy)); 
setsockopt(s, IPPROTO_IP, IP_IPSEC_POLICY, buf, ipsec_get_policylen(buf));</pre>
<p>
The <span class="define">IP_PKTINFO</span> option can be used to turn on receiving of information about the source address of the packet, and the interface index. The information is passed in a <span class="type">struct in_pktinfo</span> structure, which contains<p>
<pre style="margin-left: 0.00ex;" class="lit display">
	struct in_addr ipi_addr;	/* the source or destination address */ 
	unsigned int ipi_ifindex;	/* the interface index */</pre>
and added to the control portion of the message: The cmsghdr fields have the following values:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
cmsg_len = CMSG_LEN(sizeof(struct in_pktinfo)) 
cmsg_level = IPPROTO_IP 
cmsg_type = IP_PKTINFO</pre>
<p>
The <span class="define">IP_PORTALGO</span> can be used to randomize the port selection. Valid algorithms are described in <a class="link-man" href="../7/rfc6056">rfc6056(7)</a> and their respective constants are in <b class="includes">&lt;<a class="link-includes">netinet/portalgo.h</a>&gt;</b>. For example,<p>
<pre style="margin-left: 0.00ex;" class="lit display">
int algo = PORTALGO_ALGO_RANDOM_PICK;       /* see &lt;netinet/portalgo.h&gt; */ 
setsockopt(s, IPPROTO_IP, IP_PORTALGO, &amp;algo, sizeof(algo));</pre>
<p>
The port selection can be also viewed and controlled at a global level for all IP sockets using the following <a class="link-man" href="../7/sysctl">sysctl(7)</a> variables: <span class="define">net.inet.ip.anonportalgo.available</span> and <span class="define">net.inet.ip.anonportalgo.selected</span>.<p>
<span class="define">IP_PORTRANGE</span> controls how ephemeral ports are allocated for <span class="define">SOCK_STREAM</span> and <span class="define">SOCK_DGRAM</span> sockets. For example,<p>
<pre style="margin-left: 0.00ex;" class="lit display">
int range = IP_PORTRANGE_LOW;       /* see &lt;netinet/in.h&gt; */ 
setsockopt(s, IPPROTO_IP, IP_PORTRANGE, &amp;range, sizeof(range));</pre>
<p>
If the <span class="define">IP_RECVDSTADDR</span> option is enabled on a <span class="define">SOCK_DGRAM</span> or <span class="define">SOCK_RAW</span> socket, the <a class="link-man" href="../2/recvmsg">recvmsg(2)</a> call will return the destination IP address for a UDP datagram. The msg_control field in the msghdr structure points to a buffer that contains a cmsghdr structure followed by the IP address. The cmsghdr fields have the following values:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
cmsg_len = CMSG_LEN(sizeof(struct in_addr)) 
cmsg_level = IPPROTO_IP 
cmsg_type = IP_RECVDSTADDR</pre>
<p>
If the <span class="define">IP_RECVIF</span> option is enabled on a <span class="define">SOCK_DGRAM</span> or <span class="define">SOCK_RAW</span> socket, the <a class="link-man" href="../2/recvmsg">recvmsg(2)</a> call will return a struct sockaddr_dl corresponding to the interface on which the packet was received. the msg_control field in the msghdr structure points to a buffer that contains a cmsghdr structure followed by the struct sockaddr_dl. The cmsghdr fields have the following values:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
cmsg_len = CMSG_LEN(sizeof(struct sockaddr_dl)) 
cmsg_level = IPPROTO_IP 
cmsg_type = IP_RECVIF</pre>
<p>
The <span class="define">IP_RECVPKTINFO</span> option is similar to the <span class="define">IP_PKTINFO</span> one, only in this case the inbound information is returned.<p>
If the <span class="define">IP_RECVTTL</span> option is enabled on a <span class="define">SOCK_DGRAM</span> socket, the <a class="link-man" href="../2/recvmsg">recvmsg(2)</a> call will return the TTL of the received datagram. The msg_control field in the msghdr structure points to a buffer that contains a cmsghdr structure followed by the TTL value. The cmsghdr fields have the following values:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
cmsg_len = CMSG_LEN(sizeof(uint8_t)) 
cmsg_level = IPPROTO_IP 
cmsg_type = IP_RECVTTL</pre>
<p>
The <span class="define">IP_MINTTL</span> option may be used on <span class="define">SOCK_DGRAM</span> or <span class="define">SOCK_STREAM</span> sockets to discard packets with a TTL lower than the option value. This can be used to implement the <span class="emph">Generalized TTL Security Mechanism (GTSM)</span> according to RFC 3682. To discard all packets with a TTL lower than 255:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
int minttl = 255; 
setsockopt(s, IPPROTO_IP, IP_MINTTL, &amp;minttl, sizeof(minttl));</pre>
<div class="subsection">
<h2 id="x4d554c544943415354204f5054494f4e53">MULTICAST OPTIONS</h2> IP multicasting is supported only on <span class="define">AF_INET</span> sockets of type <span class="define">SOCK_DGRAM</span> and <span class="define">SOCK_RAW</span>, and only on networks where the interface driver supports multicasting.<p>
The <span class="define">IP_MULTICAST_TTL</span> option changes the time-to-live (TTL) for outgoing multicast datagrams in order to control the scope of the multicasts:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
u_char ttl;	/* range: 0 to 255, default = 1 */ 
setsockopt(s, IPPROTO_IP, IP_MULTICAST_TTL, &amp;ttl, sizeof(ttl));</pre>
<p>
Datagrams with a TTL of 1 are not forwarded beyond the local network. Multicast datagrams with a TTL of 0 will not be transmitted on any network, but may be delivered locally if the sending host belongs to the destination group and if multicast loopback has not been disabled on the sending socket (see below). Multicast datagrams with TTL greater than 1 may be forwarded to other networks if a multicast router is attached to the local network.<p>
For hosts with multiple interfaces, each multicast transmission is sent from the primary network interface. The <span class="define">IP_MULTICAST_IF</span> option overrides the default for subsequent transmissions from a given socket:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
struct in_addr addr; 
setsockopt(s, IPPROTO_IP, IP_MULTICAST_IF, &amp;addr, sizeof(addr));</pre>
<p>
where "addr" is the local IP address of the desired interface or <span class="define">INADDR_ANY</span> to specify the default interface. An interface's local IP address and multicast capability can be obtained via the <span class="define">SIOCGIFCONF</span> and <span class="define">SIOCGIFFLAGS</span> ioctls. An application may also specify an alternative to the default network interface by index:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
struct uint32_t idx = htonl(ifindex); 
setsockopt(s, IPPROTO_IP, IP_MULTICAST_IF, &amp;idx, sizeof(idx));</pre>
<p>
where "ifindex" is an interface index as returned by <a class="link-man" href="../3/if_nametoindex">if_nametoindex(3)</a>.<p>
Normal applications should not need to use <span class="define">IP_MULTICAST_IF</span>.<p>
If a multicast datagram is sent to a group to which the sending host itself belongs (on the outgoing interface), a copy of the datagram is, by default, looped back by the IP layer for local delivery. The <span class="define">IP_MULTICAST_LOOP</span> option gives the sender explicit control over whether or not subsequent datagrams are looped back:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
u_char loop;	/* 0 = disable, 1 = enable (default) */ 
setsockopt(s, IPPROTO_IP, IP_MULTICAST_LOOP, &amp;loop, sizeof(loop));</pre>
<p>
This option improves performance for applications that may have no more than one instance on a single host (such as a router demon), by eliminating the overhead of receiving their own transmissions. It should generally not be used by applications for which there may be more than one instance on a single host (such as a conferencing program) or for which the sender does not belong to the destination group (such as a time querying program).<p>
A multicast datagram sent with an initial TTL greater than 1 may be delivered to the sending host on a different interface from that on which it was sent, if the host belongs to the destination group on that other interface. The loopback control option has no effect on such delivery.<p>
A host must become a member of a multicast group before it can receive datagrams sent to the group. To join a multicast group, use the <span class="define">IP_ADD_MEMBERSHIP</span> option:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
struct ip_mreq mreq; 
setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;mreq, sizeof(mreq));</pre>
<p>
where <i class="farg">mreq</i> is the following structure:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
struct ip_mreq { 
    struct in_addr imr_multiaddr; /* multicast group to join */ 
    struct in_addr imr_interface; /* interface to join on */ 
}</pre>
<p>
<span class="define">imr_interface</span> should be <span class="define">INADDR_ANY</span> to choose the default multicast interface, or the IP address of a particular multicast-capable interface if the host is multihomed. Membership is associated with a single interface; programs running on multihomed hosts may need to join the same group on more than one interface. Up to <span class="define">IP_MAX_MEMBERSHIPS</span> (currently 20) memberships may be added on a single socket.<p>
To drop a membership, use:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
struct ip_mreq mreq; 
setsockopt(s, IPPROTO_IP, IP_DROP_MEMBERSHIP, &amp;mreq, sizeof(mreq));</pre>
<p>
where <i class="farg">mreq</i> contains the same values as used to add the membership. Memberships are dropped when the socket is closed or the process exits.</div>
<div class="subsection">
<h2 id="x52415720495020534f434b455453">RAW IP SOCKETS</h2> Raw IP sockets are connectionless, and are normally used with the <a class="link-man" href="../2/sendto">sendto(2)</a> and <a class="link-man" href="../2/recvfrom">recvfrom(2)</a> calls, though the <a class="link-man" href="../2/connect">connect(2)</a> call may also be used to fix the destination for future packets (in which case the <a class="link-man" href="../2/read">read(2)</a> or <a class="link-man" href="../2/recv">recv(2)</a> and <a class="link-man" href="../2/write">write(2)</a> or <a class="link-man" href="../2/send">send(2)</a> system calls may be used).<p>
If <i class="farg">proto</i> is 0, the default protocol <span class="define">IPPROTO_RAW</span> is used for outgoing packets, and only incoming packets destined for that protocol are received. If <i class="farg">proto</i> is non-zero, that protocol number will be used on outgoing packets and to filter incoming packets.<p>
Outgoing packets automatically have an IP header prepended to them (based on the destination address and the protocol number the socket is created with), unless the <span class="define">IP_HDRINCL</span> option has been set. Incoming packets are received with IP header and options intact.<p>
<span class="define">IP_HDRINCL</span> indicates the complete IP header is included with the data and may be used only with the <span class="define">SOCK_RAW</span> type.<p>
<pre style="margin-left: 0.00ex;" class="lit display">
#include &lt;netinet/ip.h&gt; 
 
int hincl = 1;                  /* 1 = on, 0 = off */ 
setsockopt(s, IPPROTO_IP, IP_HDRINCL, &amp;hincl, sizeof(hincl));</pre>
<p>
Unlike previous <span class="unix">BSD</span> releases, the program must set all the fields of the IP header, including the following:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
ip-&gt;ip_v = IPVERSION; 
ip-&gt;ip_hl = hlen &gt;&gt; 2; 
ip-&gt;ip_id = 0;  /* 0 means kernel set appropriate value */ 
ip-&gt;ip_off = offset;</pre>
<p>
If the header source address is set to <span class="define">INADDR_ANY</span>, the kernel will choose an appropriate address.</div>
</div>
<div class="section">
<h1 id="x444941474e4f5354494353">DIAGNOSTICS</h1> A socket operation may fail with one of the following errors returned:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">EISCONN</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
when trying to establish a connection on a socket which already has one, or when trying to send a datagram with the destination address specified and the socket is already connected;</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">ENOTCONN</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
when trying to send a datagram, but no destination address is specified, and the socket hasn't been connected;</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">ENOBUFS</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
when the system runs out of memory for an internal data structure;</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">EADDRNOTAVAIL</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
when an attempt is made to create a socket with a network address for which no network interface exists.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">EACCES</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
when an attempt is made to create a raw IP socket by a non-privileged process.</dd>
</dl>
<p>
The following errors specific to IP may occur when setting or getting IP options:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">EINVAL</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
An unknown socket option name was given.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
&#91;<span class="errno">EINVAL</span>&#93;</dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
The IP option field was improperly formed; an option field was shorter than the minimum value or longer than the option buffer provided.</dd>
</dl>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../2/getsockopt">getsockopt(2)</a>, <a class="link-man" href="../2/recv">recv(2)</a>, <a class="link-man" href="../2/send">send(2)</a>, <a class="link-man" href="../3/CMSG_DATA">CMSG_DATA(3)</a>, <a class="link-man" href="../3/ipsec_set_policy">ipsec_set_policy(3)</a>, <a class="link-man" href="../4/icmp">icmp(4)</a>, <a class="link-man" href="../4/inet">inet(4)</a>, <a class="link-man" href="../4/intro">intro(4)</a><p>
<span class="ref"><span class="ref-title">Internet Protocol</span>, <span class="ref-rep">RFC</span>, <span class="ref-num">791</span>, <span class="ref-date">September 1981</span>.</span><p>
<span class="ref"><span class="ref-title">Host Extensions for IP Multicasting</span>, <span class="ref-rep">RFC</span>, <span class="ref-num">1112</span>, <span class="ref-date">August 1989</span>.</span><p>
<span class="ref"><span class="ref-title">Requirements for Internet Hosts -- Communication Layers</span>, <span class="ref-rep">RFC</span>, <span class="ref-num">1122</span>, <span class="ref-date">October 1989</span>.</span></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The <b class="name">ip</b> protocol appeared in <span class="unix">4.2BSD</span>.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
June 27, 2013</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
<>

