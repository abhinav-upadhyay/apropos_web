<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
PPBUS(4)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
PPBUS(4)</td>
<td class="head-vol" align="center">
Kernel Interfaces Manual</td>
<td class="head-rtitle" align="right">
PPBUS(4)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">ppbus</b> &#8212; <span class="desc">Parallel Port Bus system with GPIO</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="config">ppbus* at atppc?</b><br>
<b class="config">options PPBUS_VERBOSE</b><br>
<b class="config">options PPBUS_DEBUG</b><br>
<b class="config">options DEBUG_1284</b><p>
<br>
<b class="config">gpio* at ppbus?</b><br>
<b class="config">lpt* at ppbus?</b><br>
<b class="config">plip* at ppbus?</b><br>
<b class="config">pps* at ppbus?</b></div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <b class="name">ppbus</b> system provides a uniform, modular, and architecture-independent system for the implementation of drivers to control various parallel devices, and to use different parallel port chip sets.</div>
<div class="section">
<h1 id="x4445564943452044524956455253">DEVICE DRIVERS</h1> In order to write new drivers or port existing drivers, the <b class="name">ppbus</b> system provides the following facilities:<ul style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-bul">
<li class="list-bul" style="margin-top: 1.00em;">
architecture-independent macros or functions to access parallel ports</li>
<li class="list-bul" style="margin-top: 1.00em;">
mechanism to allow various devices to share the same parallel port</li>
<li class="list-bul" style="margin-top: 1.00em;">
a <a class="link-man" href="../html4/gpio.html">gpio(4)</a> interface to access the individual pins</li>
<li class="list-bul" style="margin-top: 1.00em;">
a user interface named <a class="link-man" href="../html4/ppi.html">ppi(4)</a> that allows parallel port access from outside the kernel without conflicting with kernel-in drivers.</li>
</ul>
<div class="subsection">
<h2 id="x446576656c6f70696e67206e65772064726976657273">Developing new drivers</h2> The <b class="name">ppbus</b> system has been designed to support the development of standard and non-standard software:<p>
<table style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-col">
<col style="min-width: 6.00ex;">
<tbody>
<tr class="list-col">
<td class="list-col" style="margin-top: 0.00em;">
<span class="emph">Driver</span></td>
<td class="list-col" style="margin-top: 0.00em;">
<span class="emph">Description</span> It uses standard and non-standard parallel port accesses.</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 0.00em;">
<span class="symb">ppi</span></td>
<td class="list-col" style="margin-top: 0.00em;">
Parallel port interface for general I/O</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 0.00em;">
<span class="symb">pps</span></td>
<td class="list-col" style="margin-top: 0.00em;">
Pulse per second Timing Interface</td>
</tr>
</tbody>
</table>
</div>
<div class="subsection">
<h2 id="x506f7274696e67206578697374696e672064726976657273">Porting existing drivers</h2> Another approach to the <b class="name">ppbus</b> system is to port existing drivers. Various drivers have already been ported:<p>
<table style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-col">
<col style="min-width: 6.00ex;">
<tbody>
<tr class="list-col">
<td class="list-col" style="margin-top: 0.00em;">
<span class="emph">Driver</span></td>
<td class="list-col" style="margin-top: 0.00em;">
<span class="emph">Description</span></td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 0.00em;">
<span class="symb">lpt</span></td>
<td class="list-col" style="margin-top: 0.00em;">
lpt printer driver</td>
</tr>
<tr class="list-col">
<td class="list-col" style="margin-top: 0.00em;">
<span class="symb">lp</span></td>
<td class="list-col" style="margin-top: 0.00em;">
plip network interface driver</td>
</tr>
</tbody>
</table>
<p>
<b class="name">ppbus</b> should let you port any other software even from other operating systems that provide similar services.</div>
</div>
<div class="section">
<h1 id="x504152414c4c454c20504f525420434849502053455453">PARALLEL PORT CHIP SETS</h1> Parallel port chip set support is provided by <a class="link-man" href="../html4/atppc.html">atppc(4)</a>.<p>
The <b class="name">ppbus</b> system provides functions and macros to request service from the <b class="name">ppbus</b> including reads, writes, setting of parameters, and bus requests/releases.<p>
<a class="link-man" href="../html4/atppc.html">atppc(4)</a> detects chip set and capabilities and sets up interrupt handling. It makes methods available for use to the <b class="name">ppbus</b> system.</div>
<div class="section">
<h1 id="x504152414c4c454c20504f5254204d4f44454c">PARALLEL PORT MODEL</h1> The logical parallel port model chosen for the <b class="name">ppbus</b> system is the AT parallel port model. Consequently, for the <span class="emph">atppc</span> implementation of <b class="name">ppbus</b>, most of the services provided by <b class="name">ppbus</b> will translate into I/O instructions on actual registers. However, other parallel port implementations may require more than one I/O instruction to do a single logical register operation on data, status and control virtual registers.<div class="subsection">
<h2 id="x4465736372697074696f6e">Description</h2> The parallel port may operate in the following modes:<ul style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-bul">
<li class="list-bul" style="margin-top: 1.00em;">
Compatible (Centronics -- the standard parallel port mode) mode, output byte</li>
<li class="list-bul" style="margin-top: 1.00em;">
Nibble mode, input 4-bits</li>
<li class="list-bul" style="margin-top: 1.00em;">
Byte (PS/2) mode, input byte</li>
<li class="list-bul" style="margin-top: 1.00em;">
Extended Capability Port (ECP) mode, bidirectional byte</li>
<li class="list-bul" style="margin-top: 1.00em;">
Enhanced Parallel Port (EPP) mode, bidirectional byte</li>
</ul>
</div>
<div class="subsection">
<h2 id="x436f6d70617469626c65206d6f6465">Compatible mode</h2> This mode defines the protocol used by most PCs to transfer data to a printer. In this mode, data is placed on the port's data lines, the printer status is checked for no errors and that it is not busy, and then a data Strobe is generated by the software to clock the data to the printer.<p>
Many I/O controllers have implemented a mode that uses a FIFO buffer to transfer data with the Compatibility mode protocol. This mode is referred to as &#8220;Fast Centronics&#8221; or &#8220;Parallel Port FIFO mode&#8221;.</div>
<div class="subsection">
<h2 id="x4e6962626c65206d6f6465">Nibble mode</h2> The Nibble mode is the most common way to get reverse channel data from a printer or peripheral. When combined with the standard host to printer mode, a bidirectional data channel is created. Inputs are accomplished by reading 4 of the 8 bits of the status register.</div>
<div class="subsection">
<h2 id="x42797465206d6f6465">Byte mode</h2> In this mode, the data register is used either for outputs and inputs. All transfers are 8-bits long. Channel direction must be negotiated when doing IEEE 1248 compliant operations.</div>
<div class="subsection">
<h2 id="x457874656e646564204361706162696c69747920506f7274206d6f6465">Extended Capability Port mode</h2> The ECP protocol was proposed as an advanced mode for communication with printer and scanner type peripherals. Like the EPP protocol, ECP mode provides for a high performance bidirectional communication path between the host adapter and the peripheral.<p>
ECP protocol features include:<ul style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-item">
<li class="list-item" style="margin-top: 1.00em;">
Run_Length_Encoding (RLE) data compression for host adapters (not supported in these drivers)</li>
<li class="list-item" style="margin-top: 1.00em;">
FIFO's for both the forward and reverse channels</li>
<li class="list-item" style="margin-top: 1.00em;">
DMA or programmed I/O for the host register interface.</li>
</ul>
</div>
<div class="subsection">
<h2 id="x456e68616e63656420506172616c6c656c20506f7274206d6f6465">Enhanced Parallel Port mode</h2> The EPP protocol was originally developed as a means to provide a high performance parallel port link that would still be compatible with the standard parallel port.<p>
The EPP mode has two types of cycle: address and data. What makes the difference at hardware level is the strobe of the byte placed on the data lines. Data are strobed with nAutofeed, addresses are strobed with nSelectin signals.<p>
A particularity of the ISA implementation of the EPP protocol is that an EPP cycle fits in an ISA cycle. In this fashion, parallel port peripherals can operate at close to the same performance levels as an equivalent ISA plug-in card.<p>
At software level, you may implement the protocol you wish, using data and address cycles as you want. This is for the IEEE 1284 compatible part. Peripheral vendors may implement protocol handshake with the following status lines: PError, nFault and Select. Try to know how these lines toggle with your peripheral, allowing the peripheral to request more data, stop the transfer and so on.<p>
At any time, the peripheral may interrupt the host with the nAck signal without disturbing the current transfer.</div>
<div class="subsection">
<h2 id="x4d69786564206d6f646573">Mixed modes</h2> Some manufacturers, like SMC, have implemented chip sets that support mixed modes. With such chip sets, mode switching is available at any time by accessing the extended control register. All ECP-capable chip sets can switch between standard, byte, fast centronics, and ECP modes. Some ECP chip sets also support switching to EPP mode.</div>
</div>
<div class="section">
<h1 id="x4945454520313238342031393934205374616e64617264">IEEE 1284 1994 Standard</h1><div class="subsection">
<h2 id="x4261636b67726f756e64">Background</h2> This standard is also named &#8220;IEEE Standard Signaling Method for a Bidirectional Parallel Peripheral Interface for Personal Computers&#8221;. It defines a signaling method for asynchronous, fully interlocked, bidirectional parallel communications between hosts and printers or other peripherals. It also specifies a format for a peripheral identification string and a method of returning this string to the host.<p>
This standard is architecture independent and only specifies dialog handshake at signal level. One should refer to architecture specific documentation in order to manipulate machine dependent registers, mapped memory or other methods to control these signals.<p>
The IEEE 1284 protocol is fully oriented with all supported parallel port modes. The computer acts as master and the peripheral as slave.<p>
Any transfer is defined as a finite state automate. It allows software to properly manage the fully interlocked scheme of the signaling method. The compatible mode is supported &#8220;as is&#8221; without any negotiation because it is the default, backward-compatible transfer mode. Any other mode must be firstly negotiated by the host to check it is supported by the peripheral, then to enter one of the forward idle states.<p>
At any time, the slave may want to send data to the host. The host must negotiate to permit the peripheral to complete the transfer. Interrupt lines may be dedicated to the requesting signals to prevent time consuming polling methods.<p>
If the host accepts the transfer, it must firstly negotiate the reverse mode and then start the transfer. At any time during reverse transfer, the host may terminate the transfer or the slave may drive wires to signal that no more data is available.</div>
<div class="subsection">
<h2 id="x496d706c656d656e746174696f6e">Implementation</h2> IEEE 1284 Standard support has been implemented at the top of the <b class="name">ppbus</b> system as a set of procedures that perform high level functions like negotiation, termination, transfer in any mode without bothering you with low level characteristics of the standard.<p>
IEEE 1284 interacts with the <b class="name">ppbus</b> system as little as possible. That means you still have to request the <b class="name">ppbus</b> when you want to access it, and of course, release it when finished.</div>
</div>
<div class="section">
<h1 id="x415243484954454354555245">ARCHITECTURE</h1><div class="subsection">
<h2 id="x43686970207365742c20707062757320616e6420646576696365206c6179657273">Chip set, ppbus and device layers</h2> First, there is the <span class="emph">chip set</span> layer, the lowest of the <b class="name">ppbus</b> system. It provides chip set abstraction through a set of low level functions that maps the logical model to the underlying hardware.<p>
Secondly, there is the <span class="emph">ppbus</span> layer that provides functions to:<ol style="margin-top: 0.00em;margin-bottom: 0.00em;margin-left: 5.00ex;" class="list list-enum">
<li class="list-enum" style="margin-top: 1.00em;">
share the parallel port bus among the daisy-chain like connected devices</li>
<li class="list-enum" style="margin-top: 1.00em;">
manage devices linked to <b class="name">ppbus</b></li>
<li class="list-enum" style="margin-top: 1.00em;">
propose an arch-independent interface to access the hardware layer.</li>
</ol>
<p>
Finally, the <span class="emph">device</span> layer represents the traditional device drivers such as <a class="link-man" href="../html4/lpt.html">lpt(4)</a> which now use an abstraction instead of real hardware.</div>
<div class="subsection">
<h2 id="x506172616c6c656c20706f7274206d6f6465206d616e6167656d656e74">Parallel port mode management</h2> Operating modes are differentiated at various <b class="name">ppbus</b> system layers. There is a difference between a <span class="emph">capability</span> and a <span class="emph">mode</span>. A chip set may have a combination of capabilities, but at any one time the <b class="name">ppbus</b> system operates in a single mode.<p>
Nibble mode is a <span class="emph">virtual</span> mode: the actual chip set would be in standard mode and the driver would change its behavior to drive the right lines on the parallel port.<p>
Each child device of <b class="name">ppbus</b> must set its operating mode and other parameters whenever it requests and gets access to its parent <b class="name">ppbus</b>.</div>
</div>
<div class="section">
<h1 id="x4645415455524553">FEATURES</h1><div class="subsection">
<h2 id="x54686520626f6f742070726f63657373">The boot process</h2> <b class="name">ppbus</b> attachment tries to detect any PnP parallel peripheral (according to <span class="ref-title">Plug and Play Parallel Port Devices draft from (c)1993-4</span> Microsoft Corporation) then probes and attaches known device drivers.<p>
During probe, device drivers should request the <b class="name">ppbus</b> and try to determine if the right capabilities are present in the system.</div>
<div class="subsection">
<h2 id="x427573207265717565737420616e6420696e7465727275707473">Bus request and interrupts</h2> <b class="name">ppbus</b> reservation via a bus request is mandatory not to corrupt I/O of other devices. For example, when the <a class="link-man" href="../html4/lpt.html">lpt(4)</a> device is opened, the bus will be &#8220;allocated&#8221; to the device driver and attempts to reserve the bus for another device will fail until the <a class="link-man" href="../html4/lpt.html">lpt(4)</a> driver releases the bus.<p>
Child devices can also register interrupt handlers to be called when a hardware interrupt occurs. In order to attach a handler, drivers must own the bus. Drivers should have interrupt handlers that check to see if the device still owns the bus when they are called and/or ensure that these handlers are removed whenever the device does not own the bus.</div>
<div class="subsection">
<h2 id="x4d6963726f1e73657175656e636573">Micro-sequences</h2> <span class="emph">Micro-sequences</span> are a general purpose mechanism to allow fast low-level manipulation of the parallel port. Micro-sequences may be used to do either standard (in IEEE 1284 modes) or non-standard transfers. The philosophy of micro-sequences is to avoid the overhead of the <b class="name">ppbus</b> layer for a sequence of operations and do most of the job at the chip set level.<p>
A micro-sequence is an array of opcodes and parameters. Each opcode codes an operation (opcodes are described in <a class="link-man" href="../html9/microseq.html">microseq(9)</a>). Standard I/O operations are implemented at ppbus level whereas basic I/O operations and microseq language are coded at adapter level for efficiency.</div>
<div class="subsection">
<h2 id="x4750494f20696e74657266616365">GPIO interface</h2> Pins 1 through 17 of the parallel port can be controlled through the <a class="link-man" href="../html4/gpio.html">gpio(4)</a> interface, pins 18 through 25 are hardwired to ground. Pins 10 through 13 and pin 15 are input pins, the others are output pins. Some of the pins are inverted by the hardware, the values read or written are adjusted accordingly. Note that the <a class="link-man" href="../html4/gpio.html">gpio(4)</a> interface starts at 0 when numbering pins.</div>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html4/atppc.html">atppc(4)</a>, <a class="link-man" href="../html4/gpio.html">gpio(4)</a>, <a class="link-man" href="../html4/lpt.html">lpt(4)</a>, <a class="link-man" href="../html4/plip.html">plip(4)</a>, <a class="link-man" href="../html4/ppi.html">ppi(4)</a>, <a class="link-man" href="../html9/microseq.html">microseq(9)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The <b class="name">ppbus</b> system first appeared in <span class="unix">FreeBSD&#160;3.0</span>.</div>
<div class="section">
<h1 id="x415554484f5253">AUTHORS</h1> This manual page is based on the <span class="unix">FreeBSD</span> <b class="name">ppbus</b> manual page. The information has been updated for the <span class="unix">NetBSD</span> port by Gary Thorpe.</div>
<div class="section">
<h1 id="x42554753">BUGS</h1> The <b class="name">ppbus</b> framework is still experimental and not enabled by default yet.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
August 19, 2009</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

