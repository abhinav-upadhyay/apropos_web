<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
ST(4)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
ST(4)</td>
<td class="head-vol" align="center">
Kernel Interfaces Manual</td>
<td class="head-rtitle" align="right">
ST(4)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">st</b> &#8212; <span class="desc">SCSI/ATAPI tape driver</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="config">st* at scsibus? target ? lun ?</b><br>
<b class="config">st1 at scsibus0 target 4 lun 0</b><br>
<b class="config">st* at atapibus? drive ? flags 0x0000</b></div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> The <b class="name">st</b> driver provides support for SCSI and Advanced Technology Attachment Packet Interface (ATAPI) tape drives. It allows a tape drive to be run in several different modes depending on minor numbers and supports several different &#8216;sub-modes&#8217;. The device can have both a <span class="emph">raw</span> interface and a <span class="emph">block</span> interface; however, only the raw interface is usually used (or recommended).<p>
SCSI and ATAPI devices have a relatively high level interface and talk to the system via a SCSI or ATAPI adapter and a SCSI or ATAPI adapter driver (e.g. <a class="link-man" href="../4/ahc">ahc(4)</a>, <a class="link-man" href="../4/pciide">pciide(4)</a>). A SCSI or ATAPI adapter must also be separately configured into the system before a SCSI or ATAPI tape can be configured.<p>
As the SCSI or ATAPI adapter is probed during boot, the SCSI or ATAPI bus is scanned for devices. Any devices found which answer as &#8216;<span class="emph">Sequential</span>&#8217; type devices will be attached to the <b class="name">st</b> driver.</div>
<div class="section">
<h1 id="x4d4f554e542053455353494f4e53">MOUNT SESSIONS</h1> The <b class="name">st</b> driver is based around the concept of a &#8220;<span class="emph">mount session</span>&#8221;, which is defined as the period between the time that a tape is mounted, and the time when it is unmounted. Any parameters set during a mount session remain in effect for the remainder of the session or until replaced. The tape can be unmounted, bringing the session to a close in several ways. These include:<ol style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-enum">
<li class="list-enum" style="margin-top: 1.00em;">
Closing an &#8216;unmount device&#8217;, referred to as sub-mode 00 below. An example is <i class="file">/dev/rst0</i>.</li>
<li class="list-enum" style="margin-top: 1.00em;">
Using the <span class="define">MTOFFL</span> <a class="link-man" href="../2/ioctl">ioctl(2)</a> command, reachable through the &#8216;<b class="flag">offline</b>&#8217; command of <a class="link-man" href="../1/mt">mt(1)</a>.</li>
<li class="list-enum" style="margin-top: 1.00em;">
Opening a different mode will implicitly unmount the tape, thereby closing off the mode that was previously mounted. All parameters will be loaded freshly from the new mode (See below for more on modes).</li>
</ol>
</div>
<div class="section">
<h1 id="x4d4f44455320414e44205355421e4d4f444553">MODES AND SUB-MODES</h1> There are several different &#8216;operation&#8217; modes. These are controlled by bits 2 and 3 of the minor number and are designed to allow users to easily read and write different formats of tape on devices that allow multiple formats. The parameters for each mode can be set individually by hand with the <a class="link-man" href="../1/mt">mt(1)</a> command. When a device corresponding to a particular mode is first mounted, The operating parameters for that mount session are copied from that mode. Further changes to the parameters during the session will change those in effect for the session but not those set in the operation mode. To change the parameters for an operation mode, one must compile them into the &#8220;<span class="emph">quirk</span>&#8221; table in the driver's source code.<p>
In addition to the operating modes mentioned above, bits 0 and 1 of the minor number are interpreted as &#8216;sub-modes&#8217;. The sub-modes differ in the action taken when the device is closed:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
00</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
A close will rewind the device; if the tape has been written, then a file mark will be written before the rewind is requested. The device is unmounted.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
01</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
A close will leave the tape mounted. If the tape was written to, a file mark will be written. No other head positioning takes place. Any further reads or writes will occur directly after the last read, or the written file mark.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
10</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
A close will rewind the device. If the tape has been written, then a file mark will be written before the rewind is requested. On completion of the rewind an unload command will be issued. The device is unmounted.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
11</dt>
<dd class="list-tag" style="margin-left: 4.00ex;">
This is Control mode, which  allows the tape driver to be opened without a tape inserted to allow various ioctls (e.g. MTIOCGET or MTIOCTOP to set density or blocksize) and raw SCSI command on through. I/O can be done in this mode, if desired, with the same rewind/eject behaviour as mode 01. This isn't really an 'action taken on close' type of distinction, but this seems to be the place to put this mode.</dd>
</dl>
</div>
<div class="section">
<h1 id="x424c4f434b494e47204d4f444553">BLOCKING MODES</h1> SCSI tapes may run in either &#8216;<span class="emph">variable</span>&#8217; or &#8216;<span class="emph">fixed</span>&#8217; block-size modes. Most QIC-type devices run in fixed block-size mode, where most nine-track tapes and many new cartridge formats allow variable block-size. The difference between the two is as follows:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-inset">
<dt class="list-inset" style="margin-top: 1.00em;">
Variable block-size</dt>
<dd class="list-inset">
Each write made to the device results in a single logical record written to the tape. One can never read or write <span class="emph">part</span> of a record from tape (though you may request a larger block and read a smaller record); nor can one read multiple blocks. Data from a single write is therefore read by a single read. The block size used may be any value supported by the device, the SCSI adapter and the system (usually between 1 byte and 64 Kbytes, sometimes more).<p>
When reading a variable record/block from the tape, the head is logically considered to be immediately after the last item read, and before the next item after that. If the next item is a file mark, but it was never read, then the next process to read will immediately hit the file mark and receive an end-of-file notification.</dd>
<dt class="list-inset" style="margin-top: 1.00em;">
Fixed block-size</dt>
<dd class="list-inset">
Data written by the user is passed to the tape as a succession of fixed size blocks. It may be contiguous in memory, but it is considered to be a series of independent blocks. One may never write an amount of data that is not an exact multiple of the blocksize. One may read and write the same data as a different set of records, In other words, blocks that were written together may be read separately, and vice-versa.<p>
If one requests more blocks than remain in the file, the drive will encounter the file mark. Because there is some data to return (unless there were no records before the file mark), the read will succeed, returning that data. The next read will return immediately with an EOF (as above, if the file mark is never read, it remains for the next process to read if in no-rewind mode).</dd>
</dl>
</div>
<div class="section">
<h1 id="x46494c45204d41524b2048414e444c494e47">FILE MARK HANDLING</h1> The handling of file marks on write is automatic. If the user has written to the tape, and has not done a read since the last write, then a file mark will be written to the tape when the device is closed. If a rewind is requested after a write, then the driver assumes that the last file on the tape has been written, and ensures that there are two file marks written to the tape. The exception to this is that there seems to be a standard (which we follow, but don't understand why) that certain types of tape do not actually write two file marks to tape, but when read, report a &#8216;phantom&#8217; file mark when the last file is read. These devices include the QIC family of devices (it might be that this set of devices is the same set as that of fixed block devices. This has not been determined yet, and they are treated as separate behaviors by the driver at this time).</div>
<div class="section">
<h1 id="x454f4d2048414e444c494e47">EOM HANDLING</h1> Attempts to write past EOM and how EOM is reported are handled slightly differently based upon whether EARLY WARNING recognition is enabled in the driver.<p>
If EARLY WARNING recognitions is <span class="emph">not</span> enabled, then detection of EOM (as reported in SCSI Sense Data with an EOM indicator) causes the write operation to be flagged with I/O error (EIO). This has the effect for the user application of not knowing actually how many bytes were read (since the return of the <a class="link-man" href="../2/read">read(2)</a> system call is set to &#8722;1).<p>
If EARLY WARNING recognition <span class="emph">is</span> enabled, then detection of EOM (as reported in SCSI Sense Data with an EOM indicator) has no immediate effect except that the driver notes that EOM has been detected. If the write completing didn't transfer all data that was requested, then the residual count (counting bytes <span class="emph">not</span> written) is returned to the user application. In any event, the next attempt to write (if that is the next action the user application takes) is immediately completed with no data transferred, and a residual returned to the user application indicating that no data was transferred. This is the traditional UNIX EOF indication. The state that EOM had been seen is then cleared.<p>
In either mode of operation, the driver does not prohibit the user application from writing more data, if it chooses to do so. This will continue up until the physical end of media, which is usually signalled internally to the driver as a CHECK CONDITION with the Sense Key set to VOLUME OVERFLOW. When this or any otherwise unhandled error occurs, an error return of EIO will be transmitted to the user application.  This does indeed mean that if EARLY WARNING is enables and the device continues to set EOM indicators prior to hitting physical end of media, that an indeterminate number of 'short write returns' as described in the previous paragraph will occur. However, the expected user application behaviour (in common with other systems) is to close the tape and rewind and request another tape upon the receipt of the first EOM indicator, possibly after writing one trailer record.</div>
<div class="section">
<h1 id="x4b45524e454c20434f4e46494755524154494f4e">KERNEL CONFIGURATION</h1> Because different tape drives behave differently, there is a mechanism within the source to <b class="name">st</b> to quickly and conveniently recognize and deal with brands and models of drive that have special requirements.<p>
There is a table (called the &#8220;<span class="emph">quirk table</span>&#8221;) in which the identification strings of known errant drives can be stored. Alongside each is a set of flags that allows the setting of densities and blocksizes for each of the modes, along with a set of `QUIRK' flags that can be used to enable or disable sections of code within the driver if a particular drive is recognized.</div>
<div class="section">
<h1 id="x494f43544c53">IOCTLS</h1> The following <a class="link-man" href="../2/ioctl">ioctl(2)</a> calls apply to SCSI tapes. Some also apply to other tapes. They are defined in the header file <b class="includes">&lt;<a class="link-includes">sys/mtio.h</a>&gt;</b>.<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MTIOCGET</span></dt>
<dd class="list-tag" style="margin-left: 9.00ex;">
(<code class="lit">struct mtget</code>) Retrieve the status and parameters of the tape. Error status and residual is unlatched and cleared by the driver when it receives this ioctl.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MTIOCTOP</span></dt>
<dd class="list-tag" style="margin-left: 9.00ex;">
(<code class="lit">struct mtop</code>) Perform a multiplexed operation. The argument structure is as follows:<p>
<pre style="margin-left: 5.00ex;" class="lit display">
struct mtop { 
	short	mt_op; 
	daddr_t	mt_count; 
};</pre>
<p>
The following operation values are defined for <b class="var">mt_op</b>:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MTWEOF</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Write <b class="var">mt_count</b> end of file marks at the present head position.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MTFSF</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Skip over <b class="var">mt_count</b> file marks. Leave the head on the EOM side of the last skipped file mark.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MTBSF</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Skip <span class="emph">backwards</span> over <b class="var">mt_count</b> file marks. Leave the head on the BOM (beginning of media) side of the last skipped file mark.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MTFSR</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Skip forwards over <b class="var">mt_count</b> records.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MTBSR</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Skip backwards over <b class="var">mt_count</b> records.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MTREW</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Rewind the device to the beginning of the media.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MTOFFL</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Rewind the media (and, if possible, eject). Even if the device cannot eject the media it will often no longer respond to normal requests.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MTNOP</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
No-op; set status only.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MTERASE</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Erase the media from current position. If the field <b class="var">mt_count</b> is nonzero, a full erase is done (from current position to end of media). If <b class="var">mt_count</b> is zero, only an erase gap is written. It is hard to say which drives support only one but not the other option</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MTCACHE</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Enable controller buffering.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MTNOCACHE</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Disable controller buffering.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MTSETBSIZ</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Set the blocksize to use for the device/mode. If the device is capable of variable blocksize operation, and the blocksize is set to 0, then the drive will be driven in variable mode. This parameter is in effect for the present mount session only, unless the device was opened in Control Mode (in which case this set value persists until a reboot).</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MTSETDNSTY</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Set the density value (see <a class="link-man" href="../1/mt">mt(1)</a>) to use when running in the mode opened (minor bits 2 and 3). This parameter is in effect for the present mount session only, unless the device was opened in Control Mode (in which case this set value persists until a reboot). Any byte sized value may be specified. Note that only a very small number of them will actually usefully work. The rest will cause the tape drive to spit up.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MTCMPRESS</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Enable or disable tape drive data compression. Typically tape drives will quite contentedly ignore settings on reads, and will probably keep you from changing density for writing anywhere but BOT.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MTEWARN</span></dt>
<dd class="list-tag" style="margin-left: 10.00ex;">
Enable or disable EARLY WARNING at EOM behaviour (using the count as a boolean value).</dd>
</dl>
</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MTIOCRDSPOS</span></dt>
<dd class="list-tag" style="margin-left: 9.00ex;">
(<code class="lit">uint32_t</code>) Read device logical block position. Not all drives support this option.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MTIOCRDHPOS</span></dt>
<dd class="list-tag" style="margin-left: 9.00ex;">
(<code class="lit">uint32_t</code>) Read device hardware block position. Not all drives support this option.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MTIOCSLOCATE</span></dt>
<dd class="list-tag" style="margin-left: 9.00ex;">
(<code class="lit">uint32_t</code>) Position the tape to the specified device logical block position.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<span class="define">MTIOCHLOCATE</span></dt>
<dd class="list-tag" style="margin-left: 9.00ex;">
(<code class="lit">uint32_t</code>) Position the tape to the specified hardware block position. Not all drives support this option.</dd>
</dl>
</div>
<div class="section">
<h1 id="x46494c4553">FILES</h1><dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="file">/dev/[n][e]rst[0-9]</i></dt>
<dd class="list-tag" style="margin-left: 19.00ex;">
general form:</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="file">/dev/rst0</i></dt>
<dd class="list-tag" style="margin-left: 19.00ex;">
Mode 0, Rewind on close</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="file">/dev/nrst0</i></dt>
<dd class="list-tag" style="margin-left: 19.00ex;">
Mode 1, No rewind on close</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="file">/dev/erst0</i></dt>
<dd class="list-tag" style="margin-left: 19.00ex;">
Mode 2, Eject on close (if capable)</dd>
<dt class="list-tag" style="margin-top: 0.00em;">
<i class="file">/dev/enrst0</i></dt>
<dd class="list-tag" style="margin-left: 19.00ex;">
Mode 3, Control Mode (elsewise like mode 0)</dd>
</dl>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../1/mt">mt(1)</a>, <a class="link-man" href="../4/intro">intro(4)</a>, <a class="link-man" href="../4/mtio">mtio(4)</a>, <a class="link-man" href="../4/scsi">scsi(4)</a></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> This <b class="name">st</b> driver was originally written for Mach 2.5 by Julian Elischer, and was ported to <span class="unix">NetBSD</span> by Charles Hannum. This man page was edited for <span class="unix">NetBSD</span> by Jon Buller.</div>
<div class="section">
<h1 id="x42554753">BUGS</h1> The selection of compression could possibly also be usefully done as with a minor device bit.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
August 23, 1996</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

