<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="resource-type" content="document">
<link rel="stylesheet" href="../style.css" type="text/css" media="all">
<title>
MPLS(4)</title>
</head>
<body>
<div class="mandoc">
<table summary="Document Header" class="head" width="100%">
<col width="30%">
<col width="30%">
<col width="30%">
<tbody>
<tr>
<td class="head-ltitle">
MPLS(4)</td>
<td class="head-vol" align="center">
Kernel Interfaces Manual</td>
<td class="head-rtitle" align="right">
MPLS(4)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1 id="x4e414d45">NAME</h1> <b class="name">mpls</b> &#8212; <span class="desc">Multiprotocol Label Switching</span></div>
<div class="section">
<h1 id="x53594e4f50534953">SYNOPSIS</h1> <b class="config">options MPLS</b><br>
<b class="config">pseudo-device ifmpls</b><br>
<b class="includes">#include &lt;<a class="link-includes">sys/types.h</a>&gt;</b><br>
<b class="includes">#include &lt;<a class="link-includes">netmpls/mpls.h</a>&gt;</b></div>
<div class="section">
<h1 id="x4445534352495054494f4e">DESCRIPTION</h1> MultiProtocol Label Switching represents a mechanism which directs and carries data in high-performance networks, its techniques being applicable to any network layer protocol.<p>
In an MPLS domain the assignment of a particular packet a particular Forward Equivalence Class is done just once, as the packet enters the network. The FEC to which the packet is assigned is encoded as a short fixed length value known as a &#8220;label&#8221;. When a packet is forwarded to the next hop, the label is sent along with it; that is, the packets are &#8220;labeled&#8221; before they are forwarded.<p>
A router capable of receiving and forwarding MPLS frames is called &#8220;Label Switch Router&#8221; or LSR. Label scope is generally router-wide meaning that a certain label has a specific meaning only for a certain LSR.<p>
Currently, <span class="unix">NetBSD</span> supports MPLS over Ethernet interfaces and GRE tunnels. For these kind of interfaces, a label is contained by a fixed sized &#8220;shim&#8221; that precedes any network layer headers, just after data link layer headers.<div class="subsection">
<h2 id="x4d504c53207368696d2068656164657220737472756374757265">MPLS shim header structure</h2> In network bit order:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
------------------------------------------- 
|               |        |       |        | 
| Label         | TC     | BoS   | TTL    | 
| 20 bits       | 3 bits | 1 bit | 8 bits | 
|               |        |       |        | 
-------------------------------------------</pre>
<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
Label</dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
20 bits representing FEC, consequently the only information used to forward the frame to next-hop</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
Traffic Class Field</dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
3 bits that are used for specifying a traffic class, usually used for defining a type of service. This field was named the "Experimental Field" in most early (pre-<code class="lit">RFC 5462</code>) documents.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
Bottom of Stack</dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
One bit that is set for the last entry in the shim stack and 0 for all others. An MPLS frame may contain more than one shim, the last one before the network headers being marked by setting the BoS bit.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
TTL</dt>
<dd class="list-tag" style="margin-left: 15.00ex;">
8 bits, representing Time to Live, decremented at every LSR.</dd>
</dl>
</div>
</div>
<div class="section">
<h1 id="x5553414745">USAGE</h1> The MPLS behavior is controlled by the <code class="lit">net.mpls</code> <a class="link-man" href="../html8/sysctl.html">sysctl(8)</a> tree:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">net.mpls.accept</code></dt>
<dd class="list-tag" style="margin-left: 23.00ex;">
If zero, MPLS frames are dropped on sight on ingress interfaces.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">net.mpls.forwarding</code></dt>
<dd class="list-tag" style="margin-left: 23.00ex;">
If zero, MPLS frames are not forwarded to next-hop.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">net.mpls.ttl</code></dt>
<dd class="list-tag" style="margin-left: 23.00ex;">
The default ttl for self generated MPLS frames.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">net.mpls.inet_mapttl</code></dt>
<dd class="list-tag" style="margin-left: 23.00ex;">
If set, TTL field from IP header will be mapped into the MPLS shim on encapsulation, and the TTL field from MPLS shim will be copied into IP header on decapsulation.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">net.mpls.inet6_mapttl</code></dt>
<dd class="list-tag" style="margin-left: 23.00ex;">
The IPv6 version of the above.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">net.mpls.inet_map_prec</code></dt>
<dd class="list-tag" style="margin-left: 23.00ex;">
If set, precedence field from IP header will be mapped into MPLS shim in TC field on encapsulation, and the MPLS TC field will be copied into IP Precedence field on decapsulation.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">net.mpls.inet6_map_prec</code></dt>
<dd class="list-tag" style="margin-left: 23.00ex;">
The IPv6 version of the above.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">net.mpls.icmp_respond</code></dt>
<dd class="list-tag" style="margin-left: 23.00ex;">
Returns ICMP TTL exceeded in transit when an MPLS frame is dropped because of TTL = 0 on egress interface.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
<code class="lit">net.mpls.rfc4182</code></dt>
<dd class="list-tag" style="margin-left: 23.00ex;">
Pop the Explicit Null labels as specified by <code class="lit">RFC 4182</code></dd>
</dl>
In order to encapsulate and decapsulate to and from MPLS, an mpls pseudo-interface must be created and packets that should be encapsulated must be routed to that interface.<p>
MPLS routes may be created using <span class="define">AF_MPLS</span> <code class="lit">sa_family</code> sockaddrs for destination and tag fields. Other protocols can be encapsulated using routes pointing to mpls pseudo-interfaces, and <span class="define">AF_MPLS</span> sockaddrs for tags. Decapsulation can be made using values of reserved labels set in the tag field (see below). For more information about doing this using userland utilities see the <i class="link-sec"><a class="link-sec" href="#x4558414d504c4553">EXAMPLES</a></i> section of this manual page.<p>
The <a class="link-man" href="../html1/netstat.html">netstat(1)</a> and <a class="link-man" href="../html8/route.html">route(8)</a> utilities should be used to manage routes from userland.<p>
The <span class="unix">NetBSD</span> implementation stores route tagging information into a sockaddr_mpls structure that is referenced by the rt_tag field of rtentry struct. For storing multiple labels associated with the next-hop, the current implementation abuses the sockaddr_mpls structure, extending it in order to fit a stack of labels.<p>
<a class="link-man" href="../html8/ldpd.html">ldpd(8)</a> should be used in order to automatically import, manage and distribute labels among LSRs in the same MPLS domain.<div class="subsection">
<h2 id="x5245534552564544204c4142454c53">RESERVED LABELS</h2> MPLS labels 0 through 15 are reserved. Out of those, only four are currently defined:<dl style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-tag">
<dt class="list-tag" style="margin-top: 1.00em;">
0</dt>
<dd class="list-tag" style="margin-left: 1.00ex;">
IPv4 Explicit NULL label. This label value is only legal at the bottom of the label stack. It indicates that the label stack must be popped, and the forwarding of the packet must then be based on the IPv4 header.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
1</dt>
<dd class="list-tag" style="margin-left: 1.00ex;">
Router Alert Label. Currently not implemented in <span class="unix">NetBSD</span>.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
2</dt>
<dd class="list-tag" style="margin-left: 1.00ex;">
IPv6 Explicit NULL label. It indicates that the label stack must be popped, and the forwarding of the packet must then be based on the IPv6 header.</dd>
<dt class="list-tag" style="margin-top: 1.00em;">
3</dt>
<dd class="list-tag" style="margin-left: 1.00ex;">
Implicit NULL label. This is a label that an LSR may assign and distribute, but which never actually appears in the encapsulation. When an LSR would otherwise replace the label at the top of the stack with a new label, but the new label is &#8220;Implicit NULL&#8221;, the LSR will pop the stack instead of doing the replacement. In this case, the LSR will have to deduce by itself what is the original address family of the encapsulated network packet. Currently, <span class="unix">NetBSD</span> implementation is assuming that the latter address family is equal to the next-hop address family specified in the Implicit Null Label MPLS route.</dd>
</dl>
</div>
</div>
<div class="section">
<h1 id="x4558414d504c4553">EXAMPLES</h1><ol style="margin-top: 0.00em;margin-bottom: 0.00em;" class="list list-enum">
<li class="list-enum" style="margin-top: 1.00em;">
Create an MPLS interface and set an IP address:<p>
<pre style="margin-left: 0.00ex;" class="lit display">
# ifconfig mpls0 create up 
# ifconfig mpls0 inet 192.168.0.1/32</pre>
</li>
<li class="list-enum" style="margin-top: 1.00em;">
Route IP packets into MPLS domain with a specific tag<p>
<pre style="margin-left: 0.00ex;" class="lit display">
# route add 10.0.0.0/8 -ifp mpls0 -tag 25 -inet 192.168.1.100</pre>
</li>
<li class="list-enum" style="margin-top: 1.00em;">
Create a static MPLS forwarding rule - swap the incoming label 50 to 33 and forward the frame to 192.168.1.101 and verify the route<p>
<pre style="margin-left: 0.00ex;" class="lit display">
# route add -mpls 50 -tag 33 -inet 192.168.1.101 
add host 50: gateway 192.168.1.101 
# route -n get -mpls 50 
   route to: 50 
destination: 50 
    gateway: 192.168.1.101 
        Tag: 33 
 local addr: 192.168.1.180 
  interface: sk0 
      flags: &lt;UP,GATEWAY,HOST,DONE,STATIC&gt; 
recvpipe  sendpipe  ssthresh  rtt,msec    rttvar  hopcount      mtu     expire 
      0         0         0         0         0         0         0         0 
sockaddrs: &lt;DST,GATEWAY,IFP,IFA,TAG&gt;</pre>
</li>
<li class="list-enum" style="margin-top: 1.00em;">
Route IP packets into MPLS domain but use a different source address for local generated packets.<p>
<pre style="margin-left: 0.00ex;" class="lit display">
# route add 10.0.0.0/8 -ifa 192.168.1.180 -ifp mpls0 -tag 25 -inet 192.168.1.100</pre>
For the latter example, setting an IP address for the mpls0 interface is not necessary.</li>
<li class="list-enum" style="margin-top: 1.00em;">
Route MPLS packets encapsulated with label 60 to 192.168.1.100 and POP label<p>
<pre style="margin-left: 0.00ex;" class="lit display">
# route add -mpls 60 -tag 3 -inet 192.168.1.100</pre>
</li>
<li class="list-enum" style="margin-top: 1.00em;">
Route IP packets into MPLS domain and prepend more tags<p>
<pre style="margin-left: 0.00ex;" class="lit display">
# route add 10/8 -ifa 192.168.1.200 -ifp mpls0 -tag 20,30,40 -inet 192.168.1.100</pre>
For the above example, tag 20 will be inserted at Bottom of Stack, while tag 40 will be set into the outermost shim.</li>
<li class="list-enum" style="margin-top: 1.00em;">
Replace label 60 with label 30, prepend two more labels: 40 and 41 (in this order) and forward the result to 192.168.1.100<p>
<pre style="margin-left: 0.00ex;" class="lit display">
# route add -mpls 60 -tag 30,40,41 -inet 192.168.1.100</pre>
</li>
</ol>
</div>
<div class="section">
<h1 id="x53454520414c534f">SEE ALSO</h1> <a class="link-man" href="../html1/netstat.html">netstat(1)</a>, <a class="link-man" href="../html4/route.html">route(4)</a>, <a class="link-man" href="../html8/ldpd.html">ldpd(8)</a>, <a class="link-man" href="../html8/route.html">route(8)</a>, <a class="link-man" href="../html8/sysctl.html">sysctl(8)</a><p>
<span class="ref"><span class="ref-title">Multiprotocol Label Switching Architecture</span>, <span class="ref-rep">RFC 3031</span>.</span><p>
<span class="ref"><span class="ref-title">MPLS Label Stack Encoding</span>, <span class="ref-rep">RFC 3032</span>.</span><p>
<span class="ref"><span class="ref-title">Removing a Restriction on the use of MPLS Explicit NULL</span>, <span class="ref-rep">RFC 4182</span>.</span><p>
<span class="ref"><span class="ref-title">MPLS Label Stack Entry: EXP Field Renamed to Traffic Class Field</span>, <span class="ref-rep">RFC 5462</span>.</span></div>
<div class="section">
<h1 id="x484953544f5259">HISTORY</h1> The <b class="name">mpls</b> support appeared in <span class="unix">NetBSD&#160;6.0</span>.</div>
<div class="section">
<h1 id="x534543555249545920434f4e53494445524154494f4e53">SECURITY CONSIDERATIONS</h1> User must be aware that encapsulating IP packets in MPLS implies a major security effect when using firewalls. Currently neither <a class="link-man" href="../html4/ipf.html">ipf(4)</a> nor <a class="link-man" href="../html4/pf.html">pf(4)</a> implement the heuristics in order to look inside an MPLS frame. Moreover, it's technically impossible in most cases for an LSR to know information related to encapsulated packet. Therefore, MPLS Domains should be strictly controlled and, in most cases, limited to trusted connections inside the same Autonomous System.<p>
Users must be aware that the MPLS forwarding domain is entirely separated from the inner (IP, IPv6 etc.) forwarding domain and once a packet is encapsulated in MPLS, the former forwarding is used. This could result in a different path for MPLS encapsulated packets than the original non-MPLS one.<p>
IP or IPv6 forwarding is not necessary for MPLS forwarding. Your system may still forward IP or IPv6 packets encapsulated into MPLS if <code class="lit">net.mpls.forwarding</code> is set.</div>
<table summary="Document Footer" class="foot" width="100%">
<col width="50%">
<col width="50%">
<tbody>
<tr>
<td class="foot-date">
July 24, 2013</td>
<td class="foot-os" align="right">
NetBSD 7.99</td>
</tr>
</tbody>
</table>
</div>
</body>
</html>

