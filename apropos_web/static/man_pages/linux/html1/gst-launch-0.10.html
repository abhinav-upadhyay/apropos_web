<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
GStreamer(1)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
GStreamer(1)</td>
<td class="head-vol">
General Commands Manual</td>
<td class="head-rtitle">
GStreamer(1)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> gst-launch - build and run a GStreamer pipeline</div>
<div class="section">
<h1>SYNOPSIS</h1>  <b>gst-launch</b> <i>[OPTION...]</i> PIPELINE-DESCRIPTION</div>
<div class="section">
<h1>DESCRIPTION</h1>  <i>gst-launch</i> is a tool that builds and runs basic  <i>GStreamer</i> pipelines.<div style="height: 1.00em;">
&#160;</div>
In simple form, a PIPELINE-DESCRIPTION is a list of elements separated by exclamation marks (!). Properties may be appended to elements, in the form  <i>property=value</i>.<div style="height: 1.00em;">
&#160;</div>
For a complete description of possible PIPELINE-DESCRIPTIONS see the section  <i>pipeline description</i> below or consult the GStreamer documentation.<div style="height: 1.00em;">
&#160;</div>
Please note that <i>gst-launch</i> is primarily a debugging tool for developers and users. You should not build applications on top of it. For applications, use the gst_parse_launch() function of the GStreamer API as an easy way to construct pipelines from pipeline descriptions.</div>
<div class="section">
<h1>OPTIONS</h1>  <i>gst-launch</i> accepts the following options:<dl>
<dt>
<b>--help</b></dt>
<dd>
Print help synopsis and available FLAGS</dd>
</dl>
<dl>
<dt>
<b>-v, --verbose</b></dt>
<dd>
Output status information and property notifications</dd>
</dl>
<dl>
<dt>
<b>-q, --quiet</b></dt>
<dd>
Do not print any progress information</dd>
</dl>
<dl>
<dt>
<b>-m, --messages</b></dt>
<dd>
Output messages posted on the pipeline's bus</dd>
</dl>
<dl>
<dt>
<b>-t, --tags</b></dt>
<dd>
Output tags (also known as metadata)</dd>
</dl>
<dl>
<dt>
<b>-e, --eos-on-shutdown</b></dt>
<dd>
Force an EOS event on sources before shutting the pipeline down. This is useful to make sure muxers create readable files when a muxing pipeline is shut down forcefully via Control-C.</dd>
</dl>
<dl>
<dt>
<b>-i, --index</b></dt>
<dd>
Gather and print index statistics. This is mostly useful for playback or recording pipelines.</dd>
</dl>
<dl>
<dt>
<b>-o FILE, --output=FILE</b></dt>
<dd>
Save XML representation of pipeline to FILE and exit (DEPRECATED, DO NOT USE)</dd>
</dl>
<dl>
<dt>
<b>-f, --no-fault</b></dt>
<dd>
Do not install a fault handler</dd>
</dl>
<dl>
<dt>
<b>--no-sigusr-handler</b></dt>
<dd>
Do not install signal handlers for SIGUSR1 (play) and SIGUSR2 (stop)</dd>
</dl>
<dl>
<dt>
<b>-T, --trace</b></dt>
<dd>
Print memory allocation traces. The feature must be enabled at compile time to work.</dd>
</dl>
</div>
<div class="section">
<h1>GSTREAMER OPTIONS</h1>  <i>gst-launch</i> also accepts the following options that are common to all GStreamer applications:<dl>
<dt>
<b>--gst-version</b></dt>
<dd>
Prints the version string of the <i>GStreamer</i> core library.</dd>
</dl>
<dl>
<dt>
<b>--gst-fatal-warnings</b></dt>
<dd>
Causes <i>GStreamer</i> to abort if a warning message occurs. This is equivalent to setting the environment variable G_DEBUG to 'fatal_warnings' (see the section  <i>environment variables</i> below for further information).</dd>
</dl>
<dl>
<dt>
<b>--gst-debug=STRING</b></dt>
<dd>
A comma separated list of category_name:level pairs to specify debugging levels for each category. Level is in the range 0-5 where 0 will show no messages, and 5 will show all messages. The wildcard * can be used to match category names.<div style="height: 1.00em;">
&#160;</div>
Use --gst-debug-help to show category names<div style="height: 1.00em;">
&#160;</div>
Example: GST_CAT:5,GST_ELEMENT_*:3,oggdemux:5<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<dl>
<dt>
<b>--gst-debug-level=LEVEL</b></dt>
<dd>
Sets the threshold for printing debugging messages.  A higher level will print more messages.  The useful range is 0-5, with the default being 0.</dd>
</dl>
<dl>
<dt>
<b>--gst-debug-no-color</b></dt>
<dd>
<i>GStreamer</i> normally prints debugging messages so that the messages are color-coded when printed to a terminal that handles ANSI escape sequences.  Using this option causes  <i>GStreamer</i> to print messages without color. Setting the  <b>GST_DEBUG_NO_COLOR</b> environment variable will achieve the same thing.</dd>
</dl>
<dl>
<dt>
<b>--gst-debug-disable</b></dt>
<dd>
Disables debugging.</dd>
</dl>
<dl>
<dt>
<b>--gst-debug-help</b></dt>
<dd>
Prints a list of available debug categories and their default debugging level.</dd>
</dl>
<dl>
<dt>
<b>--gst-plugin-spew</b></dt>
<dd>
<i>GStreamer</i> info flags to set Enable printout of errors while loading  <i>GStreamer</i> plugins</dd>
</dl>
<dl>
<dt>
<b>--gst-plugin-path=PATH</b></dt>
<dd>
Add directories separated with ':' to the plugin search path</dd>
</dl>
<dl>
<dt>
<b>--gst-plugin-load=PLUGINS</b></dt>
<dd>
Preload plugins specified in a comma-separated list. Another way to specify plugins to preload is to use the environment variable GST_PLUGIN_PATH<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
</div>
<div class="section">
<h1>PIPELINE DESCRIPTION</h1> A pipeline consists  <i>elements</i> and <i>links</i>. <i>Elements</i> can be put into  <i>bins</i> of different sorts. <i>Elements</i>, <i>links</i> and <i>bins</i> can be specified in a pipeline description in any order.<div style="height: 1.00em;">
&#160;</div>
<b>Elements</b><div style="height: 1.00em;">
&#160;</div>
ELEMENTTYPE <i>[PROPERTY1 ...]</i><div style="height: 1.00em;">
&#160;</div>
Creates an element of type ELEMENTTYPE and sets the PROPERTIES.<div style="height: 1.00em;">
&#160;</div>
<b>Properties</b><div style="height: 1.00em;">
&#160;</div>
PROPERTY=VALUE ...<div style="height: 1.00em;">
&#160;</div>
Sets the property to the specified value. You can use <b>gst-inspect</b>(1) to find out about properties and allowed values of different elements.<div style="height: 0.00em;">
&#160;</div>
Enumeration properties can be set by name, nick or value.<div style="height: 1.00em;">
&#160;</div>
<b>Bins</b><div style="height: 1.00em;">
&#160;</div>
<i>[BINTYPE.]</i> ( <i>[PROPERTY1 ...]</i> PIPELINE-DESCRIPTION )<div style="height: 0.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
Specifies that a bin of type BINTYPE is created and the given properties are set. Every element between the braces is put into the bin. Please note the dot that has to be used after the BINTYPE. You will almost never need this functionality, it is only really useful for applications using the gst_launch_parse() API with 'bin' as bintype. That way it is possible to build partial pipelines instead of a full-fledged top-level pipeline.<div style="height: 1.00em;">
&#160;</div>
<b>Links</b><div style="height: 1.00em;">
&#160;</div>
<i>[[SRCELEMENT].[PAD1,...]]</i> ! <i>[[SINKELEMENT].[PAD1,...]]</i>  <i>[[SRCELEMENT].[PAD1,...]]</i> ! CAPS ! <i>[[SINKELEMENT].[PAD1,...]]</i><div style="height: 1.00em;">
&#160;</div>
Links the element with name SRCELEMENT to the element with name SINKELEMENT, using the caps specified in CAPS as a filter. Names can be set on elements with the name property. If the name is omitted, the element that was specified directly in front of or after the link is used. This works across bins. If a padname is given, the link is done with these pads. If no pad names are given all possibilities are tried and a matching pad is used. If multiple padnames are given, both sides must have the same number of pads specified and multiple links are done in the given order.<div style="height: 0.00em;">
&#160;</div>
So the simplest link is a simple exclamation mark, that links the element to the left of it to the element right of it.<div style="height: 0.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>Caps</b><div style="height: 1.00em;">
&#160;</div>
MIMETYPE <i>[, PROPERTY[, PROPERTY ...]]]</i> <i>[; CAPS[; CAPS ...]]</i><div style="height: 1.00em;">
&#160;</div>
Creates a capability with the given mimetype and optionally with given properties. The mimetype can be escaped using &quot; or '. If you want to chain caps, you can add more caps in the same format afterwards.<div style="height: 1.00em;">
&#160;</div>
<b>Properties</b><div style="height: 1.00em;">
&#160;</div>
NAME=<i>[(TYPE)]</i>VALUE<div style="height: 0.00em;">
&#160;</div>
in lists and ranges: <i>[(TYPE)]</i>VALUE<div style="height: 1.00em;">
&#160;</div>
Sets the requested property in capabilities. The name is an alphanumeric value and the type can have the following case-insensitive values:<div style="height: 0.00em;">
&#160;</div>
- <b>i</b> or <b>int</b> for integer values or ranges<div style="height: 0.00em;">
&#160;</div>
- <b>f</b> or <b>float</b> for float values or ranges<div style="height: 0.00em;">
&#160;</div>
- <b>4</b> or <b>fourcc</b> for FOURCC values<div style="height: 0.00em;">
&#160;</div>
- <b>b</b>, <b>bool</b> or <b>boolean</b> for boolean values<div style="height: 0.00em;">
&#160;</div>
- <b>s</b>, <b>str</b> or <b>string</b> for strings<div style="height: 0.00em;">
&#160;</div>
- <b>fraction</b> for fractions (framerate, pixel-aspect-ratio)<div style="height: 0.00em;">
&#160;</div>
- <b>l</b> or <b>list</b> for lists<div style="height: 0.00em;">
&#160;</div>
If no type was given, the following order is tried: integer, float, boolean, string.<div style="height: 0.00em;">
&#160;</div>
Integer values must be parsable by <b>strtol()</b>, floats by <b>strtod()</b>. FOURCC values may either be integers or strings. Boolean values are (case insensitive)  <i>yes</i>,  <i>no</i>, <i>true</i> or <i>false</i> and may like strings be escaped with &quot; or '.<div style="height: 0.00em;">
&#160;</div>
Ranges are in this format:  [ VALUE, VALUE ]<div style="height: 0.00em;">
&#160;</div>
Lists use this format:      ( VALUE <i>[, VALUE ...]</i> )<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>PIPELINE CONTROL</h1> A pipeline can be controlled by signals. SIGUSR2 will stop the pipeline (GST_STATE_NULL); SIGUSR1 will put it back to play (GST_STATE_PLAYING). By default, the pipeline will start in the playing state.<div style="height: 0.00em;">
&#160;</div>
There are currently no signals defined to go into the ready or pause (GST_STATE_READY and GST_STATE_PAUSED) state explicitly.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>PIPELINE EXAMPLES</h1> The examples below assume that you have the correct plug-ins available. In general, &quot;osssink&quot; can be substituted with another audio output plug-in such as &quot;esdsink&quot;, &quot;alsasink&quot;, &quot;osxaudiosink&quot;, or &quot;artsdsink&quot;. Likewise, &quot;xvimagesink&quot; can be substituted with &quot;ximagesink&quot;, &quot;sdlvideosink&quot;, &quot;osxvideosink&quot;, or &quot;aasink&quot;. Keep in mind though that different sinks might accept different formats and even the same sink might accept different formats on different machines, so you might need to add converter elements like audioconvert and audioresample (for audio) or ffmpegcolorspace (for video) in front of the sink to make things work.<div style="height: 1.00em;">
&#160;</div>
<b>Audio playback</b><div style="height: 1.00em;">
&#160;</div>
<b><br/>
        gst-launch filesrc location=music.mp3 ! mad ! audioconvert ! audioresample ! osssink</b><div style="height: 0.00em;">
&#160;</div>
Play the mp3 music file &quot;music.mp3&quot; using a libmad-based plug-in and output to an OSS device<div style="height: 1.00em;">
&#160;</div>
<b><br/>
        gst-launch filesrc location=music.ogg ! oggdemux ! vorbisdec ! audioconvert ! audioresample ! osssink</b><div style="height: 0.00em;">
&#160;</div>
Play an Ogg Vorbis format file<div style="height: 1.00em;">
&#160;</div>
<b><br/>
        gst-launch gnomevfssrc location=music.mp3 ! mad ! osssink</b><div style="height: 0.00em;">
&#160;</div>
<b><br/>
        gst-launch gnomevfssrc location=http://domain.com/music.mp3 ! mad ! audioconvert ! audioresample ! osssink</b><div style="height: 0.00em;">
&#160;</div>
Play an mp3 file or an http stream using GNOME-VFS<div style="height: 1.00em;">
&#160;</div>
<b><br/>
        gst-launch gnomevfssrc location=smb://computer/music.mp3 ! mad ! audioconvert ! audioresample ! osssink</b><div style="height: 0.00em;">
&#160;</div>
Use GNOME-VFS to play an mp3 file located on an SMB server<div style="height: 1.00em;">
&#160;</div>
<b>Format conversion</b><div style="height: 1.00em;">
&#160;</div>
<b><br/>
        gst-launch filesrc location=music.mp3 ! mad ! audioconvert ! vorbisenc ! oggmux ! filesink location=music.ogg</b><div style="height: 0.00em;">
&#160;</div>
Convert an mp3 music file to an Ogg Vorbis file<div style="height: 1.00em;">
&#160;</div>
<b><br/>
        gst-launch filesrc location=music.mp3 ! mad ! audioconvert ! flacenc ! filesink location=test.flac</b><div style="height: 0.00em;">
&#160;</div>
Convert to the FLAC format<div style="height: 1.00em;">
&#160;</div>
<b>Other</b><div style="height: 1.00em;">
&#160;</div>
<b><br/>
        gst-launch filesrc location=music.wav ! wavparse ! audioconvert ! audioresample ! osssink</b><div style="height: 0.00em;">
&#160;</div>
Plays a .WAV file that contains raw audio data (PCM).<div style="height: 1.00em;">
&#160;</div>
<b><br/>
        gst-launch filesrc location=music.wav ! wavparse ! audioconvert ! vorbisenc ! oggmux ! filesink location=music.ogg</b><div style="height: 0.00em;">
&#160;</div>
<b><br/>
        gst-launch filesrc location=music.wav ! wavparse ! audioconvert ! lame ! filesink location=music.mp3</b><div style="height: 0.00em;">
&#160;</div>
Convert a .WAV file containing raw audio data into an Ogg Vorbis or mp3 file<div style="height: 1.00em;">
&#160;</div>
<b><br/>
        gst-launch cdparanoiasrc mode=continuous ! audioconvert ! lame ! id3v2mux ! filesink location=cd.mp3</b><div style="height: 0.00em;">
&#160;</div>
rips all tracks from compact disc and convert them into a single mp3 file<div style="height: 1.00em;">
&#160;</div>
<b><br/>
        gst-launch cdparanoiasrc track=5 ! audioconvert ! lame ! id3v2mux ! filesink location=track5.mp3</b><div style="height: 0.00em;">
&#160;</div>
rips track 5 from the CD and converts it into a single mp3 file<div style="height: 1.00em;">
&#160;</div>
Using <b>gst-inspect</b>(1), it is possible to discover settings like the above for cdparanoiasrc that will tell it to rip the entire cd or only tracks of it. Alternatively, you can use an URI and gst-launch-0.10 will find an element (such as cdparanoia) that supports that protocol for you, e.g.: <b><br/>
       gst-launch cdda://5 ! lame vbr=new vbr-quality=6 ! filesink location=track5.mp3</b><div style="height: 1.00em;">
&#160;</div>
<b><br/>
        gst-launch osssrc ! audioconvert ! vorbisenc ! oggmux ! filesink location=input.ogg</b><div style="height: 0.00em;">
&#160;</div>
records sound from your audio input and encodes it into an ogg file<div style="height: 1.00em;">
&#160;</div>
<b>Video</b><div style="height: 1.00em;">
&#160;</div>
<b><br/>
        gst-launch filesrc location=JB_FF9_TheGravityOfLove.mpg ! dvddemux ! mpeg2dec ! xvimagesink</b><div style="height: 0.00em;">
&#160;</div>
Display only the video portion of an MPEG-1 video file, outputting to an X display window<div style="height: 1.00em;">
&#160;</div>
<b><br/>
        gst-launch filesrc location=/flflfj.vob ! dvddemux ! mpeg2dec ! sdlvideosink</b><div style="height: 0.00em;">
&#160;</div>
Display the video portion of a .vob file (used on DVDs), outputting to an SDL window<div style="height: 1.00em;">
&#160;</div>
<b><br/>
        gst-launch filesrc location=movie.mpg ! dvddemux name=demuxer  demuxer. ! queue ! mpeg2dec ! sdlvideosink  demuxer. ! queue ! mad ! audioconvert ! audioresample ! osssink</b><div style="height: 0.00em;">
&#160;</div>
Play both video and audio portions of an MPEG movie<div style="height: 1.00em;">
&#160;</div>
<b><br/>
        gst-launch filesrc location=movie.mpg ! mpegdemux name=demuxer  demuxer. ! queue ! mpeg2dec ! ffmpegcolorspace ! sdlvideosink   demuxer. ! queue ! mad ! audioconvert ! audioresample ! osssink</b><div style="height: 0.00em;">
&#160;</div>
Play an AVI movie with an external text subtitle stream<div style="height: 1.00em;">
&#160;</div>
This example also shows how to refer to specific pads by name if an element (here: textoverlay) has multiple sink or source pads.<div style="height: 1.00em;">
&#160;</div>
<b><br/>
        gst-launch textoverlay name=overlay ! ffmpegcolorspace ! videoscale ! autovideosink   filesrc location=movie.avi ! decodebin2 ! ffmpegcolorspace ! overlay.video_sink   filesrc location=movie.srt ! subparse ! overlay.text_sink</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 0.00em;">
&#160;</div>
Play an AVI movie with an external text subtitle stream using playbin2<div style="height: 1.00em;">
&#160;</div>
<b><br/>
        gst-launch playbin2 uri=file:///path/to/movie.avi suburi=file:///path/to/movie.srt</b><div style="height: 1.00em;">
&#160;</div>
<b>Network streaming</b><div style="height: 1.00em;">
&#160;</div>
Stream video using RTP and network elements.<div style="height: 1.00em;">
&#160;</div>
<b><br/>
        gst-launch v4l2src ! video/x-raw-yuv,width=128,height=96,format='(fourcc)'UYVY ! ffmpegcolorspace ! ffenc_h263 ! video/x-h263 ! rtph263ppay pt=96 ! udpsink host=192.168.1.1 port=5000 sync=false</b><div style="height: 0.00em;">
&#160;</div>
This command would be run on the transmitter<div style="height: 1.00em;">
&#160;</div>
<b><br/>
        gst-launch udpsrc port=5000 ! application/x-rtp, clock-rate=90000,payload=96 ! rtph263pdepay queue-delay=0 ! ffdec_h263 ! xvimagesink</b><div style="height: 0.00em;">
&#160;</div>
Use this command on the receiver<div style="height: 1.00em;">
&#160;</div>
<b>Diagnostic</b><div style="height: 1.00em;">
&#160;</div>
<b><br/>
        gst-launch -v fakesrc num-buffers=16 ! fakesink</b><div style="height: 0.00em;">
&#160;</div>
Generate a null stream and ignore it (and print out details).<div style="height: 1.00em;">
&#160;</div>
<b><br/>
        gst-launch audiotestsrc ! audioconvert ! audioresample ! osssink</b><div style="height: 0.00em;">
&#160;</div>
Generate a pure sine tone to test the audio output<div style="height: 1.00em;">
&#160;</div>
<b><br/>
        gst-launch videotestsrc ! xvimagesink</b><div style="height: 0.00em;">
&#160;</div>
<b><br/>
        gst-launch videotestsrc ! ximagesink</b><div style="height: 0.00em;">
&#160;</div>
Generate a familiar test pattern to test the video output<div style="height: 1.00em;">
&#160;</div>
<b>Automatic linking</b><div style="height: 1.00em;">
&#160;</div>
You can use the decodebin element to automatically select the right elements to get a working pipeline.<div style="height: 1.00em;">
&#160;</div>
<b><br/>
        gst-launch filesrc location=musicfile ! decodebin ! audioconvert ! audioresample ! osssink</b><div style="height: 0.00em;">
&#160;</div>
Play any supported audio format<div style="height: 1.00em;">
&#160;</div>
<b><br/>
        gst-launch filesrc location=videofile ! decodebin name=decoder  decoder. ! queue ! audioconvert ! audioresample ! osssink   decoder. ! ffmpegcolorspace ! xvimagesink</b><div style="height: 0.00em;">
&#160;</div>
Play any supported video format with video and audio output. Threads are used automatically. To make this even easier, you can use the playbin element:<div style="height: 1.00em;">
&#160;</div>
<b><br/>
        gst-launch playbin uri=file:///home/joe/foo.avi</b><div style="height: 0.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>Filtered connections</b><div style="height: 1.00em;">
&#160;</div>
These examples show you how to use filtered caps.<div style="height: 1.00em;">
&#160;</div>
<b><br/>
        gst-launch videotestsrc ! 'video/x-raw-yuv,format=(fourcc)YUY2;video/x-raw-yuv,format=(fourcc)YV12' ! xvimagesink</b><div style="height: 0.00em;">
&#160;</div>
Show a test image and use the YUY2 or YV12 video format for this.<div style="height: 1.00em;">
&#160;</div>
<b><br/>
        gst-launch osssrc ! 'audio/x-raw-int,rate=[32000,64000],width=[16,32],depth={16,24,32},signed=(boolean)true' ! wavenc ! filesink location=recording.wav</b><div style="height: 0.00em;">
&#160;</div>
record audio and write it to a .wav file. Force usage of signed 16 to 32 bit samples and a sample rate between 32kHz and 64KHz.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>ENVIRONMENT VARIABLES</h1><dl>
<dt>
<b>GST_DEBUG</b></dt>
<dd>
Comma-separated list of debug categories and levels, e.g. GST_DEBUG=totem:4,typefind:5</dd>
</dl>
<dl>
<dt>
<b>GST_DEBUG_NO_COLOR</b></dt>
<dd>
When this environment variable is set, coloured debug output is disabled.</dd>
</dl>
<dl>
<dt>
<b>GST_DEBUG_DUMP_DOT_DIR</b></dt>
<dd>
When set to a filesystem path, store dot files of pipeline graphs there.</dd>
</dl>
<dl>
<dt>
<b>GST_REGISTRY</b></dt>
<dd>
Path of the plugin registry file. Default is ~/.gstreamer-0.10/registry-CPU.xml where CPU is the machine/cpu type GStreamer was compiled for, e.g. 'i486', 'i686', 'x86-64', 'ppc', etc. (check the output of &quot;uname -i&quot; and &quot;uname -m&quot; for details).</dd>
</dl>
<dl>
<dt>
<b>GST_REGISTRY_UPDATE</b></dt>
<dd>
Set to &quot;no&quot; to force GStreamer to assume that no plugins have changed, been added or been removed. This will make GStreamer skip the initial check whether a rebuild of the registry cache is required or not. This may be useful in embedded environments where the installed plugins never change. Do not use this option in any other setup.</dd>
</dl>
<dl>
<dt>
<b>GST_PLUGIN_PATH</b></dt>
<dd>
Specifies a list of directories to scan for additional plugins. These take precedence over the system plugins.</dd>
</dl>
<dl>
<dt>
<b>GST_PLUGIN_SYSTEM_PATH</b></dt>
<dd>
Specifies a list of plugins that are always loaded by default.  If not set, this defaults to the system-installed path, and the plugins installed in the user's home directory</dd>
</dl>
<dl>
<dt>
<b>ORC_CODE</b></dt>
<dd>
Useful Orc environment variable. Set ORC_CODE=debug to enable debuggers such as gdb to create useful backtraces from Orc-generated code.  Set ORC_CODE=backup or ORC_CODE=emulate if you suspect Orc's SIMD code generator is producing incorrect code.  (Quite a few important GStreamer plugins like videotestsrc, audioconvert or audioresample use Orc).</dd>
</dl>
<dl>
<dt>
<b>G_DEBUG</b></dt>
<dd>
Useful GLib environment variable. Set G_DEBUG=fatal_warnings to make GStreamer programs abort when a critical warning such as an assertion failure occurs. This is useful if you want to find out which part of the code caused that warning to be triggered and under what circumstances. Simply set G_DEBUG as mentioned above and run the program in gdb (or let it core dump). Then get a stack trace in the usual way.</dd>
</dl>
</div>
<div class="section">
<h1>FILES</h1><dl>
<dt>
~/.gstreamer-0.10/registry-*.xml</dt>
<dd>
The xml plugin database; can be deleted at any time, will be re-created automatically when it does not exist yet or plugins change.</dd>
</dl>
</div>
<div class="section">
<h1>SEE ALSO</h1> <b>gst-feedback</b>(1), <b>gst-inspect</b>(1), <b>gst-typefind</b>(1)</div>
<div class="section">
<h1>AUTHOR</h1> The GStreamer team at http://gstreamer.freedesktop.org/</div>
<table class="foot">
<tr>
<td class="foot-date">
May 2007</td>
<td class="foot-os">
</td>
</tr>
</table>
</div>
</body>
</html>

