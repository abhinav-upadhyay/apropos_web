<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
uuencode(1)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
uuencode(1)</td>
<td class="head-vol">
General Commands Manual</td>
<td class="head-rtitle">
uuencode(1)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> uuencode, uudecode - encode a binary file, or decode its representation</div>
<div class="section">
<h1>SYNOPSIS</h1> <b>uuencode</b> [-m] [ file ] name<div class="spacer">
</div>
<b>uudecode</b> [-o outfile] [ file ]...</div>
<div class="section">
<h1>DESCRIPTION</h1> <i>Uuencode</i> and <i>uudecode</i> are used to transmit binary files over channels that support only simple ASCII data.<div class="spacer">
</div>
<i>Uuencode</i> reads <i>file</i> (or by default the standard input) and writes an encoded version to the standard output, using only printable ASCII characters. The encoded output begins with a header, for use by <i>uudecode</i>, which records the mode of the input file and suggests <i>name</i> for the decoded file that will be created.  (If <i>name</i> is <i>/dev/stdout</i> then <i>uudecode</i> will decode to standard output.)  The encoding has the format documented at uuencode(5), unless the option <i>-m</i> is given, when <b>base64</b> encoding is used instead.<div class="spacer">
</div>
<b>Note:</b> <i>uuencode</i> uses buffered input and assumes that it is not hand typed from a tty. The consequence is that at a tty, you may need to hit Ctl-D several times to terminate input.<div class="spacer">
</div>
<i>Uudecode</i> transforms uuencoded <i>files</i> (or standard input) into the original form. The resulting file is named <i>name</i> (or <i>outfile</i> if the -o option is given) and will have the mode of the original file except that setuid and execute bits are not retained.  If <i>outfile</i> or <i>name</i> is /dev/stdout the result will be written to standard output. <i>Uudecode</i> ignores any leading and trailing lines.  The program determines from the header which of the two supported encoding schemes was used.</div>
<div class="section">
<h1>EXAMPLES</h1> The following example packages up a source tree, compresses it, uuencodes it and mails it to a user on another system. When <i>uudecode</i> is run on the target system, the file ``src_tree.tar.Z'' will be created which may then be uncompressed and extracted into the original tree.<dl>
<dt>
</dt>
<dd>
tar cf - src_tree | compress | uuencode src_tree.tar.Z | mail sys1!sys2!user</dd>
</dl>
</div>
<div class="section">
<h1>SEE ALSO</h1> compress(1), mail(1), uucp(1), uuencode(5)</div>
<div class="section">
<h1>STANDARDS</h1> This implementation is compliant with P1003.2b/D11.</div>
<div class="section">
<h1>BUGS</h1> If more than one file is given to <i>uudecode</i> and the -o option is given or more than one <i>name</i> in the encoded files are the same the result is probably not what is expected.<div class="spacer">
</div>
The encoded form of the file is expanded by 37% for UU encoding and by 35% for base64 encoding (3 bytes become 4 plus control information).</div>
<div class="section">
<h1>REPORTING BUGS</h1> Report bugs to &lt;bug-gnu-utils@gnu.org&gt;.  Please put <i>sharutils</i> or <i>uuencode</i> in the subject line.  It helps to spot the message.</div>
<div class="section">
<h1>HISTORY</h1> The <i>uuencode</i> command appeared in BSD 4.0.</div>
<table class="foot">
<tr>
<td class="foot-date">
</td>
<td class="foot-os">
</td>
</tr>
</table>
</div>
</body>
</html>

