<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
FIND2PERL(1)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
FIND2PERL(1)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
FIND2PERL(1)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> find2perl - translate find command lines to Perl code</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
        find2perl [paths] [predicates] | perl<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> find2perl is a little translator to convert find command lines to equivalent Perl code.  The resulting code is typically faster than running find itself.<div class="spacer">
</div>
&quot;paths&quot; are a set of paths where find2perl will start its searches and &quot;predicates&quot; are taken from the following list.<dl>
<dt>
&quot;! PREDICATE&quot;</dt>
<dd>
Negate the sense of the following predicate.  The &quot;!&quot; must be passed as a distinct argument, so it may need to be surrounded by whitespace and/or quoted from interpretation by the shell using a backslash (just as with using find(1)).</dd>
</dl>
<dl>
<dt>
&quot;( PREDICATES )&quot;</dt>
<dd>
Group the given PREDICATES.  The parentheses must be passed as distinct arguments, so they may need to be surrounded by whitespace and/or quoted from interpretation by the shell using a backslash (just as with using find(1)).</dd>
</dl>
<dl>
<dt>
&quot;PREDICATE1 PREDICATE2&quot;</dt>
<dd>
True if _both_ PREDICATE1 and PREDICATE2 are true; PREDICATE2 is not evaluated if PREDICATE1 is false.</dd>
</dl>
<dl>
<dt>
&quot;PREDICATE1 -o PREDICATE2&quot;</dt>
<dd>
True if either one of PREDICATE1 or PREDICATE2 is true; PREDICATE2 is not evaluated if PREDICATE1 is true.</dd>
</dl>
<dl>
<dt>
&quot;-follow&quot;</dt>
<dd>
Follow (dereference) symlinks.  The checking of file attributes depends on the position of the &quot;-follow&quot; option. If it precedes the file check option, an &quot;stat&quot; is done which means the file check applies to the file the symbolic link is pointing to. If &quot;-follow&quot; option follows the file check option, this now applies to the symbolic link itself, i.e. an &quot;lstat&quot; is done.</dd>
</dl>
<dl>
<dt>
&quot;-depth&quot;</dt>
<dd>
Change directory traversal algorithm from breadth-first to depth-first.</dd>
</dl>
<dl>
<dt>
&quot;-prune&quot;</dt>
<dd>
Do not descend into the directory currently matched.</dd>
</dl>
<dl>
<dt>
&quot;-xdev&quot;</dt>
<dd>
Do not traverse mount points (prunes search at mount-point directories).</dd>
</dl>
<dl>
<dt>
&quot;-name GLOB&quot;</dt>
<dd>
File name matches specified GLOB wildcard pattern.  GLOB may need to be quoted to avoid interpretation by the shell (just as with using find(1)).</dd>
</dl>
<dl>
<dt>
&quot;-iname GLOB&quot;</dt>
<dd>
Like &quot;-name&quot;, but the match is case insensitive.</dd>
</dl>
<dl>
<dt>
&quot;-path GLOB&quot;</dt>
<dd>
Path name matches specified GLOB wildcard pattern.</dd>
</dl>
<dl>
<dt>
&quot;-ipath GLOB&quot;</dt>
<dd>
Like &quot;-path&quot;, but the match is case insensitive.</dd>
</dl>
<dl>
<dt>
&quot;-perm PERM&quot;</dt>
<dd>
Low-order 9 bits of permission match octal value PERM.</dd>
</dl>
<dl>
<dt>
&quot;-perm -PERM&quot;</dt>
<dd>
The bits specified in PERM are all set in file's permissions.</dd>
</dl>
<dl>
<dt>
&quot;-type X&quot;</dt>
<dd>
The file's type matches perl's &quot;-X&quot; operator.</dd>
</dl>
<dl>
<dt>
&quot;-fstype TYPE&quot;</dt>
<dd>
Filesystem of current path is of type TYPE (only NFS/non-NFS distinction is implemented).</dd>
</dl>
<dl>
<dt>
&quot;-user USER&quot;</dt>
<dd>
True if USER is owner of file.</dd>
</dl>
<dl>
<dt>
&quot;-group GROUP&quot;</dt>
<dd>
True if file's group is GROUP.</dd>
</dl>
<dl>
<dt>
&quot;-nouser&quot;</dt>
<dd>
True if file's owner is not in password database.</dd>
</dl>
<dl>
<dt>
&quot;-nogroup&quot;</dt>
<dd>
True if file's group is not in group database.</dd>
</dl>
<dl>
<dt>
&quot;-inum INUM&quot;</dt>
<dd>
True file's inode number is INUM.</dd>
</dl>
<dl>
<dt>
&quot;-links N&quot;</dt>
<dd>
True if (hard) link count of file matches N (see below).</dd>
</dl>
<dl>
<dt>
&quot;-size N&quot;</dt>
<dd>
True if file's size matches N (see below) N is normally counted in 512-byte blocks, but a suffix of &quot;c&quot; specifies that size should be counted in characters (bytes) and a suffix of &quot;k&quot; specifies that size should be counted in 1024-byte blocks.</dd>
</dl>
<dl>
<dt>
&quot;-atime N&quot;</dt>
<dd>
True if last-access time of file matches N (measured in days) (see below).</dd>
</dl>
<dl>
<dt>
&quot;-ctime N&quot;</dt>
<dd>
True if last-changed time of file's inode matches N (measured in days, see below).</dd>
</dl>
<dl>
<dt>
&quot;-mtime N&quot;</dt>
<dd>
True if last-modified time of file matches N (measured in days, see below).</dd>
</dl>
<dl>
<dt>
&quot;-newer FILE&quot;</dt>
<dd>
True if last-modified time of file matches N.</dd>
</dl>
<dl>
<dt>
&quot;-print&quot;</dt>
<dd>
Print out path of file (always true). If none of &quot;-exec&quot;, &quot;-ls&quot;, &quot;-print0&quot;, or &quot;-ok&quot; is specified, then &quot;-print&quot; will be added implicitly.</dd>
</dl>
<dl>
<dt>
&quot;-print0&quot;</dt>
<dd>
Like -print, but terminates with \0 instead of \n.</dd>
</dl>
<dl>
<dt>
&quot;-exec OPTIONS ;&quot;</dt>
<dd>
<i>exec()</i> the arguments in OPTIONS in a subprocess; any occurrence of {} in OPTIONS will first be substituted with the path of the current file.  Note that the command &quot;rm&quot; has been special-cased to use perl's  <i>unlink()</i> function instead (as an optimization).  The &quot;;&quot; must be passed as a distinct argument, so it may need to be surrounded by whitespace and/or quoted from interpretation by the shell using a backslash (just as with using find(1)).</dd>
</dl>
<dl>
<dt>
&quot;-ok OPTIONS ;&quot;</dt>
<dd>
Like -exec, but first prompts user; if user's response does not begin with a y, skip the exec.  The &quot;;&quot; must be passed as a distinct argument, so it may need to be surrounded by whitespace and/or quoted from interpretation by the shell using a backslash (just as with using find(1)).</dd>
</dl>
<dl>
<dt>
&quot;-eval EXPR&quot;</dt>
<dd>
Has the perl script <i>eval()</i> the EXPR.</dd>
</dl>
<dl>
<dt>
&quot;-ls&quot;</dt>
<dd>
Simulates &quot;-exec ls -dils {} ;&quot;</dd>
</dl>
<dl>
<dt>
&quot;-tar FILE&quot;</dt>
<dd>
Adds current output to tar-format FILE.</dd>
</dl>
<dl>
<dt>
&quot;-cpio FILE&quot;</dt>
<dd>
Adds current output to old-style cpio-format FILE.</dd>
</dl>
<dl>
<dt>
&quot;-ncpio FILE&quot;</dt>
<dd>
Adds current output to &quot;new&quot;-style cpio-format FILE.</dd>
</dl>
<div class="spacer">
</div>
Predicates which take a numeric argument N can come in three forms:<div class="spacer">
</div>
<br/>
   * N is prefixed with a +: match values greater than N<br/>
   * N is prefixed with a -: match values less than N<br/>
   * N is not prefixed with either + or -: match only values equal to N<br/>
</div>
<div class="section">
<h1>SEE ALSO</h1> find, File::Find.</div>
<table class="foot">
<tr>
<td class="foot-date">
2016-03-01</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

