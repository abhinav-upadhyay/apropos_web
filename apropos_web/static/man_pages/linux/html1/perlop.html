<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
PERLOP(1)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
PERLOP(1)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
PERLOP(1)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> perlop - Perl operators and precedence</div>
<div class="section">
<h1>DESCRIPTION</h1><div class="subsection">
<h2>Operator Precedence and Associativity</h2> Operator precedence and associativity work in Perl more or less like they do in mathematics.<div class="spacer">
</div>
<i>Operator precedence</i> means some operators are evaluated before others.  For example, in &quot;2 + 4 * 5&quot;, the multiplication has higher precedence so &quot;4 * 5&quot; is evaluated first yielding &quot;2 + 20 == 22&quot; and not &quot;6 * 5 == 30&quot;.<div class="spacer">
</div>
<i>Operator associativity</i> defines what happens if a sequence of the same operators is used one after another: whether the evaluator will evaluate the left operations first or the right.  For example, in &quot;8 - 4 - 2&quot;, subtraction is left associative so Perl evaluates the expression left to right.  &quot;8 - 4&quot; is evaluated first making the expression &quot;4 - 2 == 2&quot; and not &quot;8 - 2 == 6&quot;.<div class="spacer">
</div>
Perl operators have the following associativity and precedence, listed from highest precedence to lowest.  Operators borrowed from C keep the same precedence relationship with each other, even where C's precedence is slightly screwy.  (This makes learning Perl easier for C folks.)  With very few exceptions, these all operate on scalar values only, not array values.<div class="spacer">
</div>
<br/>
    left        terms and list operators (leftward)<br/>
    left        -&gt;<br/>
    nonassoc    ++ --<br/>
    right       **<br/>
    right       ! ~ \ and unary + and -<br/>
    left        =~ !~<br/>
    left        * / % x<br/>
    left        + - .<br/>
    left        &lt;&lt; &gt;&gt;<br/>
    nonassoc    named unary operators<br/>
    nonassoc    &lt; &gt; &lt;= &gt;= lt gt le ge<br/>
    nonassoc    == != &lt;=&gt; eq ne cmp ~~<br/>
    left        &amp;<br/>
    left        | ^<br/>
    left        &amp;&amp;<br/>
    left        || //<br/>
    nonassoc    ..  ...<br/>
    right       ?:<br/>
    right       = += -= *= etc.<br/>
    left        , =&gt;<br/>
    nonassoc    list operators (rightward)<br/>
    right       not<br/>
    left        and<br/>
    left        or xor<br/>
<div class="spacer">
</div>
In the following sections, these operators are covered in precedence order.<div class="spacer">
</div>
Many operators can be overloaded for objects.  See overload.</div>
<div class="subsection">
<h2>Terms and List Operators (Leftward)</h2> A TERM has the highest precedence in Perl.  They include variables, quote and quote-like operators, any expression in parentheses, and any function whose arguments are parenthesized.  Actually, there aren't really functions in this sense, just list operators and unary operators behaving as functions because you put parentheses around the arguments.  These are all documented in perlfunc.<div class="spacer">
</div>
If any list operator (<i>print()</i>, etc.) or any unary operator (<i>chdir()</i>, etc.) is followed by a left parenthesis as the next token, the operator and arguments within parentheses are taken to be of highest precedence, just like a normal function call.<div class="spacer">
</div>
In the absence of parentheses, the precedence of list operators such as &quot;print&quot;, &quot;sort&quot;, or &quot;chmod&quot; is either very high or very low depending on whether you are looking at the left side or the right side of the operator. For example, in<div class="spacer">
</div>
<br/>
    @ary = (1, 3, sort 4, 2);<br/>
    print @ary;         # prints 1324<br/>
<div class="spacer">
</div>
the commas on the right of the sort are evaluated before the sort, but the commas on the left are evaluated after.  In other words, list operators tend to gobble up all arguments that follow, and then act like a simple TERM with regard to the preceding expression. Be careful with parentheses:<div class="spacer">
</div>
<br/>
    # These evaluate exit before doing the print:<br/>
    print($foo, exit);  # Obviously not what you want.<br/>
    print $foo, exit;   # Nor is this.<br/>
<br/>
    # These do the print before evaluating exit:<br/>
    (print $foo), exit; # This is what you want.<br/>
    print($foo), exit;  # Or this.<br/>
    print ($foo), exit; # Or even this.<br/>
<div class="spacer">
</div>
Also note that<div class="spacer">
</div>
<br/>
    print ($foo &amp; 255) + 1, &quot;\n&quot;;<br/>
<div class="spacer">
</div>
probably doesn't do what you expect at first glance.  The parentheses enclose the argument list for &quot;print&quot; which is evaluated (printing the result of &quot;$foo &amp; 255&quot;).  Then one is added to the return value of &quot;print&quot; (usually 1).  The result is something like this:<div class="spacer">
</div>
<br/>
    1 + 1, &quot;\n&quot;;    # Obviously not what you meant.<br/>
<div class="spacer">
</div>
To do what you meant properly, you must write:<div class="spacer">
</div>
<br/>
    print(($foo &amp; 255) + 1, &quot;\n&quot;);<br/>
<div class="spacer">
</div>
See &quot;Named Unary Operators&quot; for more discussion of this.<div class="spacer">
</div>
Also parsed as terms are the &quot;do {}&quot; and &quot;eval {}&quot; constructs, as well as subroutine and method calls, and the anonymous constructors &quot;[]&quot; and &quot;{}&quot;.<div class="spacer">
</div>
See also &quot;Quote and Quote-like Operators&quot; toward the end of this section, as well as &quot;I/O Operators&quot;.</div>
<div class="subsection">
<h2>The Arrow Operator</h2> &quot;&quot;-&gt;&quot;&quot; is an infix dereference operator, just as it is in C and C++.  If the right side is either a &quot;[...]&quot;, &quot;{...}&quot;, or a &quot;(...)&quot; subscript, then the left side must be either a hard or symbolic reference to an array, a hash, or a subroutine respectively. (Or technically speaking, a location capable of holding a hard reference, if it's an array or hash reference being used for assignment.)  See perlreftut and perlref.<div class="spacer">
</div>
Otherwise, the right side is a method name or a simple scalar variable containing either the method name or a subroutine reference, and the left side must be either an object (a blessed reference) or a class name (that is, a package name).  See perlobj.</div>
<div class="subsection">
<h2>Auto-increment and Auto-decrement</h2> &quot;++&quot; and &quot;--&quot; work as in C.  That is, if placed before a variable, they increment or decrement the variable by one before returning the value, and if placed after, increment or decrement after returning the value.<div class="spacer">
</div>
<br/>
    $i = 0;  $j = 0;<br/>
    print $i++;  # prints 0<br/>
    print ++$j;  # prints 1<br/>
<div class="spacer">
</div>
Note that just as in C, Perl doesn't define <b>when</b> the variable is incremented or decremented. You just know it will be done sometime before or after the value is returned. This also means that modifying a variable twice in the same statement will lead to undefined behavior. Avoid statements like:<div class="spacer">
</div>
<br/>
    $i = $i ++;<br/>
    print ++ $i + $i ++;<br/>
<div class="spacer">
</div>
Perl will not guarantee what the result of the above statements is.<div class="spacer">
</div>
The auto-increment operator has a little extra builtin magic to it.  If you increment a variable that is numeric, or that has ever been used in a numeric context, you get a normal increment.  If, however, the variable has been used in only string contexts since it was set, and has a value that is not the empty string and matches the pattern &quot;/^[a-zA-Z]*[0-9]*\z/&quot;, the increment is done as a string, preserving each character within its range, with carry:<div class="spacer">
</div>
<br/>
    print ++($foo = &quot;99&quot;);      # prints &quot;100&quot;<br/>
    print ++($foo = &quot;a0&quot;);      # prints &quot;a1&quot;<br/>
    print ++($foo = &quot;Az&quot;);      # prints &quot;Ba&quot;<br/>
    print ++($foo = &quot;zz&quot;);      # prints &quot;aaa&quot;<br/>
<div class="spacer">
</div>
&quot;undef&quot; is always treated as numeric, and in particular is changed to 0 before incrementing (so that a post-increment of an undef value will return 0 rather than &quot;undef&quot;).<div class="spacer">
</div>
The auto-decrement operator is not magical.</div>
<div class="subsection">
<h2>Exponentiation</h2> Binary &quot;**&quot; is the exponentiation operator.  It binds even more tightly than unary minus, so -2**4 is -(2**4), not (-2)**4. (This is implemented using C's  <i>pow</i>(3) function, which actually works on doubles internally.)</div>
<div class="subsection">
<h2>Symbolic Unary Operators</h2> Unary &quot;!&quot; performs logical negation, i.e., &quot;not&quot;.  See also &quot;not&quot; for a lower precedence version of this.<div class="spacer">
</div>
Unary &quot;-&quot; performs arithmetic negation if the operand is numeric, including any string that looks like a number.  If the operand is an identifier, a string consisting of a minus sign concatenated with the identifier is returned.  Otherwise, if the string starts with a plus or minus, a string starting with the opposite sign is returned.  One effect of these rules is that -bareword is equivalent to the string &quot;-bareword&quot;.  If, however, the string begins with a non-alphabetic character (excluding &quot;+&quot; or &quot;-&quot;), Perl will attempt to convert the string to a numeric and the arithmetic negation is performed. If the string cannot be cleanly converted to a numeric, Perl will give the warning  <b>Argument &quot;the string&quot; isn't numeric in negation (-) at ...</b>.<div class="spacer">
</div>
Unary &quot;~&quot; performs bitwise negation, i.e., 1's complement.  For example, &quot;0666 &amp; ~027&quot; is 0640.  (See also &quot;Integer Arithmetic&quot; and &quot;Bitwise String Operators&quot;.)  Note that the width of the result is platform-dependent: ~0 is 32 bits wide on a 32-bit platform, but 64 bits wide on a 64-bit platform, so if you are expecting a certain bit width, remember to use the &quot;&amp;&quot; operator to mask off the excess bits.<div class="spacer">
</div>
When complementing strings, if all characters have ordinal values under 256, then their complements will, also.  But if they do not, all characters will be in either 32- or 64-bit complements, depending on your architecture.  So for example, &quot;~&quot;\x{3B1}&quot;&quot; is &quot;\x{FFFF_FC4E}&quot; on 32-bit machines and &quot;\x{FFFF_FFFF_FFFF_FC4E}&quot; on 64-bit machines.<div class="spacer">
</div>
Unary &quot;+&quot; has no effect whatsoever, even on strings.  It is useful syntactically for separating a function name from a parenthesized expression that would otherwise be interpreted as the complete list of function arguments.  (See examples above under &quot;Terms and List Operators (Leftward)&quot;.)<div class="spacer">
</div>
Unary &quot;\&quot; creates a reference to whatever follows it.  See perlreftut and perlref.  Do not confuse this behavior with the behavior of backslash within a string, although both forms do convey the notion of protecting the next thing from interpolation.</div>
<div class="subsection">
<h2>Binding Operators</h2> Binary &quot;=~&quot; binds a scalar expression to a pattern match.  Certain operations search or modify the string $_ by default.  This operator makes that kind of operation work on some other string.  The right argument is a search pattern, substitution, or transliteration.  The left argument is what is supposed to be searched, substituted, or transliterated instead of the default $_.  When used in scalar context, the return value generally indicates the success of the operation.  The exceptions are substitution (s///) and transliteration (y///) with the &quot;/r&quot; (non-destructive) option, which cause the  <b>r</b>eturn value to be the result of the substitution. Behavior in list context depends on the particular operator. See &quot;Regexp Quote-Like Operators&quot; for details and perlretut for examples using these operators.<div class="spacer">
</div>
If the right argument is an expression rather than a search pattern, substitution, or transliteration, it is interpreted as a search pattern at run time. Note that this means that its contents will be interpolated twice, so<div class="spacer">
</div>
<br/>
  '\\' =~ q'\\';<br/>
<div class="spacer">
</div>
is not ok, as the regex engine will end up trying to compile the pattern &quot;\&quot;, which it will consider a syntax error.<div class="spacer">
</div>
Binary &quot;!~&quot; is just like &quot;=~&quot; except the return value is negated in the logical sense.<div class="spacer">
</div>
Binary &quot;!~&quot; with a non-destructive substitution (s///r) or transliteration (y///r) is a syntax error.</div>
<div class="subsection">
<h2>Multiplicative Operators</h2> Binary &quot;*&quot; multiplies two numbers.<div class="spacer">
</div>
Binary &quot;/&quot; divides two numbers.<div class="spacer">
</div>
Binary &quot;%&quot; is the modulo operator, which computes the division remainder of its first argument with respect to its second argument. Given integer operands $a and $b: If $b is positive, then &quot;$a % $b&quot; is $a minus the largest multiple of $b less than or equal to $a.  If $b is negative, then &quot;$a % $b&quot; is $a minus the smallest multiple of $b that is not less than $a (i.e. the result will be less than or equal to zero).  If the operands $a and $b are floating point values and the absolute value of $b (that is &quot;abs($b)&quot;) is less than &quot;(UV_MAX + 1)&quot;, only the integer portion of $a and $b will be used in the operation (Note: here &quot;UV_MAX&quot; means the maximum of the unsigned integer type). If the absolute value of the right operand (&quot;abs($b)&quot;) is greater than or equal to &quot;(UV_MAX + 1)&quot;, &quot;%&quot; computes the floating-point remainder $r in the equation &quot;($r = $a - $i*$b)&quot; where $i is a certain integer that makes $r have the same sign as the right operand $b ( <b>not</b> as the left operand $a like C function &quot;fmod()&quot;) and the absolute value less than that of $b. Note that when &quot;use integer&quot; is in scope, &quot;%&quot; gives you direct access to the modulo operator as implemented by your C compiler.  This operator is not as well defined for negative operands, but it will execute faster.<div class="spacer">
</div>
Binary &quot;x&quot; is the repetition operator.  In scalar context or if the left operand is not enclosed in parentheses, it returns a string consisting of the left operand repeated the number of times specified by the right operand.  In list context, if the left operand is enclosed in parentheses or is a list formed by &quot;qw/STRING/&quot;, it repeats the list. If the right operand is zero or negative, it returns an empty string or an empty list, depending on the context.<div class="spacer">
</div>
<br/>
    print '-' x 80;             # print row of dashes<br/>
<br/>
    print &quot;\t&quot; x ($tab/8), ' ' x ($tab%8);      # tab over<br/>
<br/>
    @ones = (1) x 80;           # a list of 80 1's<br/>
    @ones = (5) x @ones;        # set all elements to 5<br/>
</div>
<div class="subsection">
<h2>Additive Operators</h2> Binary &quot;+&quot; returns the sum of two numbers.<div class="spacer">
</div>
Binary &quot;-&quot; returns the difference of two numbers.<div class="spacer">
</div>
Binary &quot;.&quot; concatenates two strings.</div>
<div class="subsection">
<h2>Shift Operators</h2> Binary &quot;&lt;&lt;&quot; returns the value of its left argument shifted left by the number of bits specified by the right argument.  Arguments should be integers.  (See also &quot;Integer Arithmetic&quot;.)<div class="spacer">
</div>
Binary &quot;&gt;&gt;&quot; returns the value of its left argument shifted right by the number of bits specified by the right argument.  Arguments should be integers.  (See also &quot;Integer Arithmetic&quot;.)<div class="spacer">
</div>
Note that both &quot;&lt;&lt;&quot; and &quot;&gt;&gt;&quot; in Perl are implemented directly using &quot;&lt;&lt;&quot; and &quot;&gt;&gt;&quot; in C.  If &quot;use integer&quot; (see &quot;Integer Arithmetic&quot;) is in force then signed C integers are used, else unsigned C integers are used.  Either way, the implementation isn't going to generate results larger than the size of the integer type Perl was built with (32 bits or 64 bits).<div class="spacer">
</div>
The result of overflowing the range of the integers is undefined because it is undefined also in C.  In other words, using 32-bit integers, &quot;1 &lt;&lt; 32&quot; is undefined.  Shifting by a negative number of bits is also undefined.</div>
<div class="subsection">
<h2>Named Unary Operators</h2> The various named unary operators are treated as functions with one argument, with optional parentheses.<div class="spacer">
</div>
If any list operator (<i>print()</i>, etc.) or any unary operator (<i>chdir()</i>, etc.) is followed by a left parenthesis as the next token, the operator and arguments within parentheses are taken to be of highest precedence, just like a normal function call.  For example, because named unary operators are higher precedence than ||:<div class="spacer">
</div>
<br/>
    chdir $foo    || die;       # (chdir $foo) || die<br/>
    chdir($foo)   || die;       # (chdir $foo) || die<br/>
    chdir ($foo)  || die;       # (chdir $foo) || die<br/>
    chdir +($foo) || die;       # (chdir $foo) || die<br/>
<div class="spacer">
</div>
but, because * is higher precedence than named operators:<div class="spacer">
</div>
<br/>
    chdir $foo * 20;    # chdir ($foo * 20)<br/>
    chdir($foo) * 20;   # (chdir $foo) * 20<br/>
    chdir ($foo) * 20;  # (chdir $foo) * 20<br/>
    chdir +($foo) * 20; # chdir ($foo * 20)<br/>
<br/>
    rand 10 * 20;       # rand (10 * 20)<br/>
    rand(10) * 20;      # (rand 10) * 20<br/>
    rand (10) * 20;     # (rand 10) * 20<br/>
    rand +(10) * 20;    # rand (10 * 20)<br/>
<div class="spacer">
</div>
Regarding precedence, the filetest operators, like &quot;-f&quot;, &quot;-M&quot;, etc. are treated like named unary operators, but they don't follow this functional parenthesis rule.  That means, for example, that &quot;-f($file).&quot;.bak&quot;&quot; is equivalent to &quot;-f &quot;$file.bak&quot;&quot;.<div class="spacer">
</div>
See also &quot;Terms and List Operators (Leftward)&quot;.</div>
<div class="subsection">
<h2>Relational Operators</h2> Binary &quot;&lt;&quot; returns true if the left argument is numerically less than the right argument.<div class="spacer">
</div>
Binary &quot;&gt;&quot; returns true if the left argument is numerically greater than the right argument.<div class="spacer">
</div>
Binary &quot;&lt;=&quot; returns true if the left argument is numerically less than or equal to the right argument.<div class="spacer">
</div>
Binary &quot;&gt;=&quot; returns true if the left argument is numerically greater than or equal to the right argument.<div class="spacer">
</div>
Binary &quot;lt&quot; returns true if the left argument is stringwise less than the right argument.<div class="spacer">
</div>
Binary &quot;gt&quot; returns true if the left argument is stringwise greater than the right argument.<div class="spacer">
</div>
Binary &quot;le&quot; returns true if the left argument is stringwise less than or equal to the right argument.<div class="spacer">
</div>
Binary &quot;ge&quot; returns true if the left argument is stringwise greater than or equal to the right argument.</div>
<div class="subsection">
<h2>Equality Operators</h2> Binary &quot;==&quot; returns true if the left argument is numerically equal to the right argument.<div class="spacer">
</div>
Binary &quot;!=&quot; returns true if the left argument is numerically not equal to the right argument.<div class="spacer">
</div>
Binary &quot;&lt;=&gt;&quot; returns -1, 0, or 1 depending on whether the left argument is numerically less than, equal to, or greater than the right argument.  If your platform supports NaNs (not-a-numbers) as numeric values, using them with &quot;&lt;=&gt;&quot; returns undef.  NaN is not &quot;&lt;&quot;, &quot;==&quot;, &quot;&gt;&quot;, &quot;&lt;=&quot; or &quot;&gt;=&quot; anything (even NaN), so those 5 return false. NaN != NaN returns true, as does NaN != anything else. If your platform doesn't support NaNs then NaN is just a string with numeric value 0.<div class="spacer">
</div>
<br/>
    perl -le '$a = &quot;NaN&quot;; print &quot;No NaN support here&quot; if $a == $a'<br/>
    perl -le '$a = &quot;NaN&quot;; print &quot;NaN support here&quot; if $a != $a'<br/>
<div class="spacer">
</div>
Binary &quot;eq&quot; returns true if the left argument is stringwise equal to the right argument.<div class="spacer">
</div>
Binary &quot;ne&quot; returns true if the left argument is stringwise not equal to the right argument.<div class="spacer">
</div>
Binary &quot;cmp&quot; returns -1, 0, or 1 depending on whether the left argument is stringwise less than, equal to, or greater than the right argument.<div class="spacer">
</div>
Binary &quot;~~&quot; does a smart match between its arguments. Smart matching is described in &quot;Smart matching in detail&quot; in perlsyn.<div class="spacer">
</div>
&quot;lt&quot;, &quot;le&quot;, &quot;ge&quot;, &quot;gt&quot; and &quot;cmp&quot; use the collation (sort) order specified by the current locale if &quot;use locale&quot; is in effect.  See perllocale.</div>
<div class="subsection">
<h2>Bitwise And</h2> Binary &quot;&amp;&quot; returns its operands ANDed together bit by bit. (See also &quot;Integer Arithmetic&quot; and &quot;Bitwise String Operators&quot;.)<div class="spacer">
</div>
Note that &quot;&amp;&quot; has lower priority than relational operators, so for example the brackets are essential in a test like<div class="spacer">
</div>
<br/>
        print &quot;Even\n&quot; if ($x &amp; 1) == 0;<br/>
</div>
<div class="subsection">
<h2>Bitwise Or and Exclusive Or</h2> Binary &quot;|&quot; returns its operands ORed together bit by bit. (See also &quot;Integer Arithmetic&quot; and &quot;Bitwise String Operators&quot;.)<div class="spacer">
</div>
Binary &quot;^&quot; returns its operands XORed together bit by bit. (See also &quot;Integer Arithmetic&quot; and &quot;Bitwise String Operators&quot;.)<div class="spacer">
</div>
Note that &quot;|&quot; and &quot;^&quot; have lower priority than relational operators, so for example the brackets are essential in a test like<div class="spacer">
</div>
<br/>
        print &quot;false\n&quot; if (8 | 2) != 10;<br/>
</div>
<div class="subsection">
<h2>C-style Logical And</h2> Binary &quot;&amp;&amp;&quot; performs a short-circuit logical AND operation.  That is, if the left operand is false, the right operand is not even evaluated. Scalar or list context propagates down to the right operand if it is evaluated.</div>
<div class="subsection">
<h2>C-style Logical Or</h2> Binary &quot;||&quot; performs a short-circuit logical OR operation.  That is, if the left operand is true, the right operand is not even evaluated. Scalar or list context propagates down to the right operand if it is evaluated.</div>
<div class="subsection">
<h2>C-style Logical Defined-Or</h2> Although it has no direct equivalent in C, Perl's &quot;//&quot; operator is related to its C-style or.  In fact, it's exactly the same as &quot;||&quot;, except that it tests the left hand side's definedness instead of its truth.  Thus, &quot;$a // $b&quot; is similar to &quot;defined($a) || $b&quot; (except that it returns the value of $a rather than the value of &quot;defined($a)&quot;) and yields the same result as &quot;defined($a) ? $a : $b&quot; (except that the ternary-operator form can be used as a lvalue, while &quot;$a // $b&quot; cannot).  This is very useful for providing default values for variables.  If you actually want to test if at least one of $a and $b is defined, use &quot;defined($a // $b)&quot;.<div class="spacer">
</div>
The &quot;||&quot;, &quot;//&quot; and &quot;&amp;&amp;&quot; operators return the last value evaluated (unlike C's &quot;||&quot; and &quot;&amp;&amp;&quot;, which return 0 or 1). Thus, a reasonably portable way to find out the home directory might be:<div class="spacer">
</div>
<br/>
    $home =  $ENV{HOME}<br/>
          // $ENV{LOGDIR}<br/>
          // (getpwuid($&lt;))[7]<br/>
          // die &quot;You're homeless!\n&quot;;<br/>
<div class="spacer">
</div>
In particular, this means that you shouldn't use this for selecting between two aggregates for assignment:<div class="spacer">
</div>
<br/>
    @a = @b || @c;              # this is wrong<br/>
    @a = scalar(@b) || @c;      # really meant this<br/>
    @a = @b ? @b : @c;          # this works fine, though<br/>
<div class="spacer">
</div>
As more readable alternatives to &quot;&amp;&amp;&quot; and &quot;||&quot; when used for control flow, Perl provides the &quot;and&quot; and &quot;or&quot; operators (see below). The short-circuit behavior is identical.  The precedence of &quot;and&quot; and &quot;or&quot; is much lower, however, so that you can safely use them after a list operator without the need for parentheses:<div class="spacer">
</div>
<br/>
    unlink &quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;<br/>
            or gripe(), next LINE;<br/>
<div class="spacer">
</div>
With the C-style operators that would have been written like this:<div class="spacer">
</div>
<br/>
    unlink(&quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot;)<br/>
            || (gripe(), next LINE);<br/>
<div class="spacer">
</div>
Using &quot;or&quot; for assignment is unlikely to do what you want; see below.</div>
<div class="subsection">
<h2>Range Operators</h2> Binary &quot;..&quot; is the range operator, which is really two different operators depending on the context.  In list context, it returns a list of values counting (up by ones) from the left value to the right value.  If the left value is greater than the right value then it returns the empty list.  The range operator is useful for writing &quot;foreach (1..10)&quot; loops and for doing slice operations on arrays. In the current implementation, no temporary array is created when the range operator is used as the expression in &quot;foreach&quot; loops, but older versions of Perl might burn a lot of memory when you write something like this:<div class="spacer">
</div>
<br/>
    for (1 .. 1_000_000) {<br/>
        # code<br/>
    }<br/>
<div class="spacer">
</div>
The range operator also works on strings, using the magical auto-increment, see below.<div class="spacer">
</div>
In scalar context, &quot;..&quot; returns a boolean value.  The operator is bistable, like a flip-flop, and emulates the line-range (comma) operator of  <b>sed</b>, <b>awk</b>, and various editors. Each &quot;..&quot; operator maintains its own boolean state, even across calls to a subroutine that contains it. It is false as long as its left operand is false. Once the left operand is true, the range operator stays true until the right operand is true,  <i>AFTER</i> which the range operator becomes false again.  It doesn't become false till the next time the range operator is evaluated.  It can test the right operand and become false on the same evaluation it became true (as in  <b>awk</b>), but it still returns true once. If you don't want it to test the right operand until the next evaluation, as in  <b>sed</b>, just use three dots (&quot;...&quot;) instead of two.  In all other regards, &quot;...&quot; behaves just like &quot;..&quot; does.<div class="spacer">
</div>
The right operand is not evaluated while the operator is in the &quot;false&quot; state, and the left operand is not evaluated while the operator is in the &quot;true&quot; state.  The precedence is a little lower than || and &amp;&amp;.  The value returned is either the empty string for false, or a sequence number (beginning with 1) for true.  The sequence number is reset for each range encountered.  The final sequence number in a range has the string &quot;E0&quot; appended to it, which doesn't affect its numeric value, but gives you something to search for if you want to exclude the endpoint.  You can exclude the beginning point by waiting for the sequence number to be greater than 1.<div class="spacer">
</div>
If either operand of scalar &quot;..&quot; is a constant expression, that operand is considered true if it is equal (&quot;==&quot;) to the current input line number (the $. variable).<div class="spacer">
</div>
To be pedantic, the comparison is actually &quot;int(EXPR) == int(EXPR)&quot;, but that is only an issue if you use a floating point expression; when implicitly using $. as described in the previous paragraph, the comparison is &quot;int(EXPR) == int($.)&quot; which is only an issue when $. is set to a floating point value and you are not reading from a file. Furthermore, &quot;span&quot; .. &quot;spat&quot; or &quot;2.18 .. 3.14&quot; will not do what you want in scalar context because each of the operands are evaluated using their integer representation.<div class="spacer">
</div>
Examples:<div class="spacer">
</div>
As a scalar operator:<div class="spacer">
</div>
<br/>
    if (101 .. 200) { print; } # print 2nd hundred lines, short for<br/>
                               #  if ($. == 101 .. $. == 200) { print; }<br/>
<br/>
    next LINE if (1 .. /^$/);  # skip header lines, short for<br/>
                               #   next LINE if ($. == 1 .. /^$/);<br/>
                               # (typically in a loop labeled LINE)<br/>
<br/>
    s/^/&gt; / if (/^$/ .. eof());  # quote body<br/>
<br/>
    # parse mail messages<br/>
    while (&lt;&gt;) {<br/>
        $in_header =   1  .. /^$/;<br/>
        $in_body   = /^$/ .. eof;<br/>
        if ($in_header) {<br/>
            # do something<br/>
        } else { # in body<br/>
            # do something else<br/>
        }<br/>
    } continue {<br/>
        close ARGV if eof;             # reset $. each file<br/>
    }<br/>
<div class="spacer">
</div>
Here's a simple example to illustrate the difference between the two range operators:<div class="spacer">
</div>
<br/>
    @lines = (&quot;   - Foo&quot;,<br/>
              &quot;01 - Bar&quot;,<br/>
              &quot;1  - Baz&quot;,<br/>
              &quot;   - Quux&quot;);<br/>
<br/>
    foreach (@lines) {<br/>
        if (/0/ .. /1/) {<br/>
            print &quot;$_\n&quot;;<br/>
        }<br/>
    }<br/>
<div class="spacer">
</div>
This program will print only the line containing &quot;Bar&quot;. If the range operator is changed to &quot;...&quot;, it will also print the &quot;Baz&quot; line.<div class="spacer">
</div>
And now some examples as a list operator:<div class="spacer">
</div>
<br/>
    for (101 .. 200) { print; } # print $_ 100 times<br/>
    @foo = @foo[0 .. $#foo];    # an expensive no-op<br/>
    @foo = @foo[$#foo-4 .. $#foo];      # slice last 5 items<br/>
<div class="spacer">
</div>
The range operator (in list context) makes use of the magical auto-increment algorithm if the operands are strings.  You can say<div class="spacer">
</div>
<br/>
    @alphabet = (&quot;A&quot; .. &quot;Z&quot;);<br/>
<div class="spacer">
</div>
to get all normal letters of the English alphabet, or<div class="spacer">
</div>
<br/>
    $hexdigit = (0 .. 9, &quot;a&quot; .. &quot;f&quot;)[$num &amp; 15];<br/>
<div class="spacer">
</div>
to get a hexadecimal digit, or<div class="spacer">
</div>
<br/>
    @z2 = (&quot;01&quot; .. &quot;31&quot;);  print $z2[$mday];<br/>
<div class="spacer">
</div>
to get dates with leading zeros.<div class="spacer">
</div>
If the final value specified is not in the sequence that the magical increment would produce, the sequence goes until the next value would be longer than the final value specified.<div class="spacer">
</div>
If the initial value specified isn't part of a magical increment sequence (that is, a non-empty string matching &quot;/^[a-zA-Z]*[0-9]*\z/&quot;), only the initial value will be returned.  So the following will only return an alpha:<div class="spacer">
</div>
<br/>
    use charnames &quot;greek&quot;;<br/>
    my @greek_small =  (&quot;\N{alpha}&quot; .. &quot;\N{omega}&quot;);<br/>
<div class="spacer">
</div>
To get the 25 traditional lowercase Greek letters, including both sigmas, you could use this instead:<div class="spacer">
</div>
<br/>
    use charnames &quot;greek&quot;;<br/>
    my @greek_small =  map { chr }<br/>
                       ord &quot;\N{alpha}&quot; .. ord &quot;\N{omega}&quot;;<br/>
<div class="spacer">
</div>
However, because there are <i>many</i> other lowercase Greek characters than just those, to match lowercase Greek characters in a regular expression, you would use the pattern &quot;/(?:(?=\p{Greek})\p{Lower})+/&quot;.<div class="spacer">
</div>
Because each operand is evaluated in integer form, &quot;2.18 .. 3.14&quot; will return two elements in list context.<div class="spacer">
</div>
<br/>
    @list = (2.18 .. 3.14); # same as @list = (2 .. 3);<br/>
</div>
<div class="subsection">
<h2>Conditional Operator</h2> Ternary &quot;?:&quot; is the conditional operator, just as in C.  It works much like an if-then-else.  If the argument before the ? is true, the argument before the : is returned, otherwise the argument after the : is returned.  For example:<div class="spacer">
</div>
<br/>
    printf &quot;I have %d dog%s.\n&quot;, $n,<br/>
            ($n == 1) ? &quot;&quot; : &quot;s&quot;;<br/>
<div class="spacer">
</div>
Scalar or list context propagates downward into the 2nd or 3rd argument, whichever is selected.<div class="spacer">
</div>
<br/>
    $a = $ok ? $b : $c;  # get a scalar<br/>
    @a = $ok ? @b : @c;  # get an array<br/>
    $a = $ok ? @b : @c;  # oops, that's just a count!<br/>
<div class="spacer">
</div>
The operator may be assigned to if both the 2nd and 3rd arguments are legal lvalues (meaning that you can assign to them):<div class="spacer">
</div>
<br/>
    ($a_or_b ? $a : $b) = $c;<br/>
<div class="spacer">
</div>
Because this operator produces an assignable result, using assignments without parentheses will get you in trouble.  For example, this:<div class="spacer">
</div>
<br/>
    $a % 2 ? $a += 10 : $a += 2<br/>
<div class="spacer">
</div>
Really means this:<div class="spacer">
</div>
<br/>
    (($a % 2) ? ($a += 10) : $a) += 2<br/>
<div class="spacer">
</div>
Rather than this:<div class="spacer">
</div>
<br/>
    ($a % 2) ? ($a += 10) : ($a += 2)<br/>
<div class="spacer">
</div>
That should probably be written more simply as:<div class="spacer">
</div>
<br/>
    $a += ($a % 2) ? 10 : 2;<br/>
</div>
<div class="subsection">
<h2>Assignment Operators</h2> &quot;=&quot; is the ordinary assignment operator.<div class="spacer">
</div>
Assignment operators work as in C.  That is,<div class="spacer">
</div>
<br/>
    $a += 2;<br/>
<div class="spacer">
</div>
is equivalent to<div class="spacer">
</div>
<br/>
    $a = $a + 2;<br/>
<div class="spacer">
</div>
although without duplicating any side effects that dereferencing the lvalue might trigger, such as from  <i>tie()</i>.  Other assignment operators work similarly. The following are recognized:<div class="spacer">
</div>
<br/>
    **=    +=    *=    &amp;=    &lt;&lt;=    &amp;&amp;=<br/>
           -=    /=    |=    &gt;&gt;=    ||=<br/>
           .=    %=    ^=           //=<br/>
                 x=<br/>
<div class="spacer">
</div>
Although these are grouped by family, they all have the precedence of assignment.<div class="spacer">
</div>
Unlike in C, the scalar assignment operator produces a valid lvalue. Modifying an assignment is equivalent to doing the assignment and then modifying the variable that was assigned to.  This is useful for modifying a copy of something, like this:<div class="spacer">
</div>
<br/>
    ($tmp = $global) =~ tr [0-9] [a-j];<br/>
<div class="spacer">
</div>
Likewise,<div class="spacer">
</div>
<br/>
    ($a += 2) *= 3;<br/>
<div class="spacer">
</div>
is equivalent to<div class="spacer">
</div>
<br/>
    $a += 2;<br/>
    $a *= 3;<br/>
<div class="spacer">
</div>
Similarly, a list assignment in list context produces the list of lvalues assigned to, and a list assignment in scalar context returns the number of elements produced by the expression on the right hand side of the assignment.</div>
<div class="subsection">
<h2>The Triple-Dot Operator</h2> The triple-dot operator, &quot;...&quot;, sometimes called the &quot;whatever operator&quot;, the &quot;yada-yada operator&quot;, or the &quot; <i>et cetera</i>&quot; operator, is a placeholder for code.  Perl parses it without error, but when you try to execute a whatever, it throws an exception with the text &quot;Unimplemented&quot;:<div class="spacer">
</div>
<br/>
    sub unimplemented { ... }<br/>
<br/>
    eval { unimplemented() };<br/>
    if ($@ eq &quot;Unimplemented&quot; ) {<br/>
        say &quot;Oh look, an exception--whatever.&quot;;<br/>
    }<br/>
<div class="spacer">
</div>
You can only use the triple-dot operator to stand in for a complete statement. These examples of the triple-dot work:<div class="spacer">
</div>
<br/>
    { ... }<br/>
<br/>
    sub foo { ... }<br/>
<br/>
    ...;<br/>
<br/>
    eval { ... };<br/>
<br/>
    sub foo {<br/>
        my ($self) = shift;<br/>
        ...;<br/>
    }<br/>
<br/>
    do {<br/>
        my $variable;<br/>
        ...;<br/>
        say &quot;Hurrah!&quot;;<br/>
    } while $cheering;<br/>
<div class="spacer">
</div>
The yada-yada--or whatever--cannot stand in for an expression that is part of a larger statement since the &quot;...&quot; is also the three-dot version of the binary range operator (see &quot;Range Operators&quot;).  These examples of the whatever operator are still syntax errors:<div class="spacer">
</div>
<br/>
    print ...;<br/>
<br/>
    open(PASSWD, &quot;&gt;&quot;, &quot;/dev/passwd&quot;) or ...;<br/>
<br/>
    if ($condition &amp;&amp; ...) { say &quot;Hello&quot; }<br/>
<div class="spacer">
</div>
There are some cases where Perl can't immediately tell the difference between an expression and a statement. For instance, the syntax for a block and an anonymous hash reference constructor look the same unless there's something in the braces that give Perl a hint. The whatever is a syntax error if Perl doesn't guess that the &quot;{ ... }&quot; is a block. In that case, it doesn't think the &quot;...&quot; is the whatever because it's expecting an expression instead of a statement:<div class="spacer">
</div>
<br/>
    my @transformed = map { ... } @input;  # syntax error<br/>
<div class="spacer">
</div>
You can use a &quot;;&quot; inside your block to denote that the &quot;{ ... }&quot; is a block and not a hash reference constructor. Now the whatever works:<div class="spacer">
</div>
<br/>
    my @transformed = map {; ... } @input; # ; disambiguates<br/>
<br/>
    my @transformed = map { ...; } @input; # ; disambiguates<br/>
</div>
<div class="subsection">
<h2>Comma Operator</h2> Binary &quot;,&quot; is the comma operator.  In scalar context it evaluates its left argument, throws that value away, then evaluates its right argument and returns that value.  This is just like C's comma operator.<div class="spacer">
</div>
In list context, it's just the list argument separator, and inserts both its arguments into the list.  These arguments are also evaluated from left to right.<div class="spacer">
</div>
The &quot;=&gt;&quot; operator is a synonym for the comma except that it causes its left operand to be interpreted as a string if it begins with a letter or underscore and is composed only of letters, digits and underscores. This includes operands that might otherwise be interpreted as operators, constants, single number v-strings or function calls. If in doubt about this behavior, the left operand can be quoted explicitly.<div class="spacer">
</div>
Otherwise, the &quot;=&gt;&quot; operator behaves exactly as the comma operator or list argument separator, according to context.<div class="spacer">
</div>
For example:<div class="spacer">
</div>
<br/>
    use constant FOO =&gt; &quot;something&quot;;<br/>
<br/>
    my %h = ( FOO =&gt; 23 );<br/>
<div class="spacer">
</div>
is equivalent to:<div class="spacer">
</div>
<br/>
    my %h = (&quot;FOO&quot;, 23);<br/>
<div class="spacer">
</div>
It is <i>NOT</i>:<div class="spacer">
</div>
<br/>
    my %h = (&quot;something&quot;, 23);<br/>
<div class="spacer">
</div>
The &quot;=&gt;&quot; operator is helpful in documenting the correspondence between keys and values in hashes, and other paired elements in lists.<div class="spacer">
</div>
<br/>
        %hash = ( $key =&gt; $value );<br/>
        login( $username =&gt; $password );<br/>
</div>
<div class="subsection">
<h2>List Operators (Rightward)</h2> On the right side of a list operator, the comma has very low precedence, such that it controls all comma-separated expressions found there. The only operators with lower precedence are the logical operators &quot;and&quot;, &quot;or&quot;, and &quot;not&quot;, which may be used to evaluate calls to list operators without the need for extra parentheses:<div class="spacer">
</div>
<br/>
    open HANDLE, &quot;&lt; $file&quot;<br/>
        or die &quot;Can't open $file: $!\n&quot;;<br/>
<div class="spacer">
</div>
See also discussion of list operators in &quot;Terms and List Operators (Leftward)&quot;.</div>
<div class="subsection">
<h2>Logical Not</h2> Unary &quot;not&quot; returns the logical negation of the expression to its right. It's the equivalent of &quot;!&quot; except for the very low precedence.</div>
<div class="subsection">
<h2>Logical And</h2> Binary &quot;and&quot; returns the logical conjunction of the two surrounding expressions.  It's equivalent to &quot;&amp;&amp;&quot; except for the very low precedence.  This means that it short-circuits: the right expression is evaluated only if the left expression is true.</div>
<div class="subsection">
<h2>Logical or, Defined or, and Exclusive Or</h2> Binary &quot;or&quot; returns the logical disjunction of the two surrounding expressions.  It's equivalent to &quot;||&quot; except for the very low precedence. This makes it useful for control flow:<div class="spacer">
</div>
<br/>
    print FH $data              or die &quot;Can't write to FH: $!&quot;;<br/>
<div class="spacer">
</div>
This means that it short-circuits: the right expression is evaluated only if the left expression is false.  Due to its precedence, you must be careful to avoid using it as replacement for the &quot;||&quot; operator. It usually works out better for flow control than in assignments:<div class="spacer">
</div>
<br/>
    $a = $b or $c;              # bug: this is wrong<br/>
    ($a = $b) or $c;            # really means this<br/>
    $a = $b || $c;              # better written this way<br/>
<div class="spacer">
</div>
However, when it's a list-context assignment and you're trying to use &quot;||&quot; for control flow, you probably need &quot;or&quot; so that the assignment takes higher precedence.<div class="spacer">
</div>
<br/>
    @info = stat($file) || die;     # oops, scalar sense of stat!<br/>
    @info = stat($file) or die;     # better, now @info gets its due<br/>
<div class="spacer">
</div>
Then again, you could always use parentheses.<div class="spacer">
</div>
Binary &quot;xor&quot; returns the exclusive-OR of the two surrounding expressions. It cannot short-circuit (of course).</div>
<div class="subsection">
<h2>C Operators Missing From Perl</h2> Here is what C has that Perl doesn't:<dl>
<dt>
unary &amp;</dt>
<dd>
Address-of operator.  (But see the &quot;\&quot; operator for taking a reference.)</dd>
</dl>
<dl>
<dt>
unary *</dt>
<dd>
Dereference-address operator. (Perl's prefix dereferencing operators are typed: $, @, %, and &amp;.)</dd>
</dl>
<dl>
<dt>
(TYPE)</dt>
<dd>
Type-casting operator.</dd>
</dl>
</div>
<div class="subsection">
<h2>Quote and Quote-like Operators</h2> While we usually think of quotes as literal values, in Perl they function as operators, providing various kinds of interpolating and pattern matching capabilities.  Perl provides customary quote characters for these behaviors, but also provides a way for you to choose your quote character for any of them.  In the following table, a &quot;{}&quot; represents any pair of delimiters you choose.<div class="spacer">
</div>
<br/>
    Customary  Generic        Meaning        Interpolates<br/>
        ''       q{}          Literal             no<br/>
        &quot;&quot;      qq{}          Literal             yes<br/>
        ``      qx{}          Command             yes*<br/>
                qw{}         Word list            no<br/>
        //       m{}       Pattern match          yes*<br/>
                qr{}          Pattern             yes*<br/>
                 s{}{}      Substitution          yes*<br/>
                tr{}{}    Transliteration         no (but see below)<br/>
                 y{}{}    Transliteration         no (but see below)<br/>
        &lt;&lt;EOF                 here-doc            yes*<br/>
<br/>
        * unless the delimiter is ''.<br/>
<div class="spacer">
</div>
Non-bracketing delimiters use the same character fore and aft, but the four sorts of ASCII brackets (round, angle, square, curly) all nest, which means that<div class="spacer">
</div>
<br/>
    q{foo{bar}baz}<br/>
<div class="spacer">
</div>
is the same as<div class="spacer">
</div>
<br/>
    'foo{bar}baz'<br/>
<div class="spacer">
</div>
Note, however, that this does not always work for quoting Perl code:<div class="spacer">
</div>
<br/>
    $s = q{ if($a eq &quot;}&quot;) ... }; # WRONG<br/>
<div class="spacer">
</div>
is a syntax error. The &quot;Text::Balanced&quot; module (standard as of v5.8, and from CPAN before then) is able to do this properly.<div class="spacer">
</div>
There can be whitespace between the operator and the quoting characters, except when &quot;#&quot; is being used as the quoting character. &quot;q#foo#&quot; is parsed as the string &quot;foo&quot;, while &quot;q #foo#&quot; is the operator &quot;q&quot; followed by a comment.  Its argument will be taken from the next line.  This allows you to write:<div class="spacer">
</div>
<br/>
    s {foo}  # Replace foo<br/>
      {bar}  # with bar.<br/>
<div class="spacer">
</div>
The following escape sequences are available in constructs that interpolate, and in transliterations:<div class="spacer">
</div>
<br/>
    Sequence     Note  Description<br/>
    \t                  tab               (HT, TAB)<br/>
    \n                  newline           (NL)<br/>
    \r                  return            (CR)<br/>
    \f                  form feed         (FF)<br/>
    \b                  backspace         (BS)<br/>
    \a                  alarm (bell)      (BEL)<br/>
    \e                  escape            (ESC)<br/>
    \x{263A}     [1,8]  hex char          (example: SMILEY)<br/>
    \x1b         [2,8]  restricted range hex char (example: ESC)<br/>
    \N{name}     [3]    named Unicode character or character sequence<br/>
    \N{U+263D}   [4,8]  Unicode character (example: FIRST QUARTER MOON)<br/>
    \c[          [5]    control char      (example: chr(27))<br/>
    \o{23072}    [6,8]  octal char        (example: SMILEY)<br/>
    \033         [7,8]  restricted range octal char  (example: ESC)<br/>
<dl>
<dt>
[1]</dt>
<dd>
The result is the character specified by the hexadecimal number between the braces.  See &quot;[8]&quot; below for details on which character.<div style="height: 1.00em;">
&#160;</div>
Only hexadecimal digits are valid between the braces. If an invalid character is encountered, a warning will be issued and the invalid character and all subsequent characters (valid or invalid) within the braces will be discarded.<div style="height: 1.00em;">
&#160;</div>
If there are no valid digits between the braces, the generated character is the NULL character (&quot;\x{00}&quot;).  However, an explicit empty brace (&quot;\x{}&quot;) will not cause a warning (currently).</dd>
</dl>
<dl>
<dt>
[2]</dt>
<dd>
The result is the character specified by the hexadecimal number in the range 0x00 to 0xFF.  See &quot;[8]&quot; below for details on which character.<div style="height: 1.00em;">
&#160;</div>
Only hexadecimal digits are valid following &quot;\x&quot;.  When &quot;\x&quot; is followed by fewer than two valid digits, any valid digits will be zero-padded.  This means that &quot;\x7&quot; will be interpreted as &quot;\x07&quot;, and a lone &lt;\x&gt; will be interpreted as &quot;\x00&quot;.  Except at the end of a string, having fewer than two valid digits will result in a warning.  Note that although the warning says the illegal character is ignored, it is only ignored as part of the escape and will still be used as the subsequent character in the string. For example:<div style="height: 1.00em;">
&#160;</div>
<br/>
  Original    Result    Warns?<br/>
  &quot;\x7&quot;       &quot;\x07&quot;    no<br/>
  &quot;\x&quot;        &quot;\x00&quot;    no<br/>
  &quot;\x7q&quot;      &quot;\x07q&quot;   yes<br/>
  &quot;\xq&quot;       &quot;\x00q&quot;   yes<br/>
</dd>
</dl>
<dl>
<dt>
[3]</dt>
<dd>
The result is the Unicode character or character sequence given by <i>name</i>. See charnames.</dd>
</dl>
<dl>
<dt>
[4]</dt>
<dd>
&quot;\N{U+<i>hexadecimal number</i>}&quot; means the Unicode character whose Unicode code point is  <i>hexadecimal number</i>.</dd>
</dl>
<dl>
<dt>
[5]</dt>
<dd>
The character following &quot;\c&quot; is mapped to some other character as shown in the table:<div style="height: 1.00em;">
&#160;</div>
<br/>
 Sequence   Value<br/>
   \c@      chr(0)<br/>
   \cA      chr(1)<br/>
   \ca      chr(1)<br/>
   \cB      chr(2)<br/>
   \cb      chr(2)<br/>
   ...<br/>
   \cZ      chr(26)<br/>
   \cz      chr(26)<br/>
   \c[      chr(27)<br/>
   \c]      chr(29)<br/>
   \c^      chr(30)<br/>
   \c?      chr(127)<br/>
<div style="height: 1.00em;">
&#160;</div>
Also, &quot;\c\<i>X</i>&quot; yields &quot; chr(28) . &quot;<i>X</i>&quot;&quot; for any <i>X</i>, but cannot come at the end of a string, because the backslash would be parsed as escaping the end quote.<div style="height: 1.00em;">
&#160;</div>
On ASCII platforms, the resulting characters from the list above are the complete set of ASCII controls.  This isn't the case on EBCDIC platforms; see &quot;OPERATOR DIFFERENCES&quot; in perlebcdic for the complete list of what these sequences mean on both ASCII and EBCDIC platforms.<div style="height: 1.00em;">
&#160;</div>
Use of any other character following the &quot;c&quot; besides those listed above is discouraged, and some are deprecated with the intention of removing those in Perl 5.16.  What happens for any of these other characters currently though, is that the value is derived by inverting the 7th bit (0x40).<div style="height: 1.00em;">
&#160;</div>
To get platform independent controls, you can use &quot;\N{...}&quot;.</dd>
</dl>
<dl>
<dt>
[6]</dt>
<dd>
The result is the character specified by the octal number between the braces. See &quot;[8]&quot; below for details on which character.<div style="height: 1.00em;">
&#160;</div>
If a character that isn't an octal digit is encountered, a warning is raised, and the value is based on the octal digits before it, discarding it and all following characters up to the closing brace.  It is a fatal error if there are no octal digits at all.</dd>
</dl>
<dl>
<dt>
[7]</dt>
<dd>
The result is the character specified by the three-digit octal number in the range 000 to 777 (but best to not use above 077, see next paragraph).  See &quot;[8]&quot; below for details on which character.<div style="height: 1.00em;">
&#160;</div>
Some contexts allow 2 or even 1 digit, but any usage without exactly three digits, the first being a zero, may give unintended results.  (For example, see &quot;Octal escapes&quot; in perlrebackslash.)  Starting in Perl 5.14, you may use &quot;\o{}&quot; instead, which avoids all these problems.  Otherwise, it is best to use this construct only for ordinals &quot;\077&quot; and below, remembering to pad to the left with zeros to make three digits.  For larger ordinals, either use &quot;\o{}&quot; , or convert to something else, such as to hex and use &quot;\x{}&quot; instead.<div style="height: 1.00em;">
&#160;</div>
Having fewer than 3 digits may lead to a misleading warning message that says that what follows is ignored.  For example, &quot;\128&quot; in the ASCII character set is equivalent to the two characters &quot;\n8&quot;, but the warning &quot;Illegal octal digit '8' ignored&quot; will be thrown.  To avoid this warning, make sure to pad your octal number with 0's: &quot;\0128&quot;.</dd>
</dl>
<dl>
<dt>
[8]</dt>
<dd>
Several constructs above specify a character by a number.  That number gives the character's position in the character set encoding (indexed from 0). This is called synonymously its ordinal, code position, or code point.  Perl works on platforms that have a native encoding currently of either ASCII/Latin1 or EBCDIC, each of which allow specification of 256 characters.  In general, if the number is 255 (0xFF, 0377) or below, Perl interprets this in the platform's native encoding.  If the number is 256 (0x100, 0400) or above, Perl interprets it as a Unicode code point and the result is the corresponding Unicode character.  For example &quot;\x{50}&quot; and &quot;\o{120}&quot; both are the number 80 in decimal, which is less than 256, so the number is interpreted in the native character set encoding.  In ASCII the character in the 80th position (indexed from 0) is the letter &quot;P&quot;, and in EBCDIC it is the ampersand symbol &quot;&amp;&quot;. &quot;\x{100}&quot; and &quot;\o{400}&quot; are both 256 in decimal, so the number is interpreted as a Unicode code point no matter what the native encoding is.  The name of the character in the 100th position (indexed by 0) in Unicode is &quot;LATIN CAPITAL LETTER A WITH MACRON&quot;.<div style="height: 1.00em;">
&#160;</div>
There are a couple of exceptions to the above rule.  &quot;\N{U+<i>hex number</i>}&quot; is always interpreted as a Unicode code point, so that &quot;\N{U+0050}&quot; is &quot;P&quot; even on EBCDIC platforms.  And if &quot;use&#160;encoding&quot; is in effect, the number is considered to be in that encoding, and is translated from that into the platform's native encoding if there is a corresponding native character; otherwise to Unicode.</dd>
</dl>
<div class="spacer">
</div>
<b>NOTE</b>: Unlike C and other languages, Perl has no &quot;\v&quot; escape sequence for the vertical tab (VT - ASCII 11), but you may use &quot;\ck&quot; or &quot;\x0b&quot;.  (&quot;\v&quot; does have meaning in regular expression patterns in Perl, see perlre.)<div class="spacer">
</div>
The following escape sequences are available in constructs that interpolate, but not in transliterations.<div class="spacer">
</div>
<br/>
    \l          lowercase next character only<br/>
    \u          titlecase (not uppercase!) next character only<br/>
    \L          lowercase all characters till \E seen<br/>
    \U          uppercase all characters till \E seen<br/>
    \Q          quote non-word characters till \E<br/>
    \E          end either case modification or quoted section<br/>
                (whichever was last seen)<br/>
<div class="spacer">
</div>
&quot;\L&quot;, &quot;\U&quot;, and &quot;\Q&quot; can stack, in which case you need one &quot;\E&quot; for each.  For example:<div class="spacer">
</div>
<br/>
        say &quot;This \Qquoting \ubusiness \Uhere isn't quite\E done yet,\E is it?&quot;;<br/>
    This quoting\ Business\ HERE\ ISN\'T\ QUITE\ done\ yet\, is it?<br/>
<div class="spacer">
</div>
If &quot;use locale&quot; is in effect, the case map used by &quot;\l&quot;, &quot;\L&quot;, &quot;\u&quot;, and &quot;\U&quot; is taken from the current locale.  See perllocale. If Unicode (for example, &quot;\N{}&quot; or code points of 0x100 or beyond) is being used, the case map used by &quot;\l&quot;, &quot;\L&quot;, &quot;\u&quot;, and &quot;\U&quot; is as defined by Unicode.  That means that case-mapping a single character can sometimes produce several characters.<div class="spacer">
</div>
All systems use the virtual &quot;\n&quot; to represent a line terminator, called a &quot;newline&quot;.  There is no such thing as an unvarying, physical newline character.  It is only an illusion that the operating system, device drivers, C libraries, and Perl all conspire to preserve.  Not all systems read &quot;\r&quot; as ASCII CR and &quot;\n&quot; as ASCII LF.  For example, on the ancient Macs (pre-MacOS X) of yesteryear, these used to be reversed, and on systems without line terminator, printing &quot;\n&quot; might emit no actual data.  In general, use &quot;\n&quot; when you mean a &quot;newline&quot; for your system, but use the literal ASCII when you need an exact character.  For example, most networking protocols expect and prefer a CR+LF (&quot;\015\012&quot; or &quot;\cM\cJ&quot;) for line terminators, and although they often accept just &quot;\012&quot;, they seldom tolerate just &quot;\015&quot;.  If you get in the habit of using &quot;\n&quot; for networking, you may be burned some day.<div class="spacer">
</div>
For constructs that do interpolate, variables beginning with &quot;&quot;$&quot;&quot; or &quot;&quot;@&quot;&quot; are interpolated.  Subscripted variables such as $a[3] or &quot;$href-&gt;{key}[0]&quot; are also interpolated, as are array and hash slices. But method calls such as &quot;$obj-&gt;meth&quot; are not.<div class="spacer">
</div>
Interpolating an array or slice interpolates the elements in order, separated by the value of $&quot;, so is equivalent to interpolating &quot;join $&quot;, @array&quot;.  &quot;Punctuation&quot; arrays such as &quot;@*&quot; are usually interpolated only if the name is enclosed in braces &quot;@{*}&quot;, but the arrays @_, &quot;@+&quot;, and &quot;@-&quot; are interpolated even without braces.<div class="spacer">
</div>
For double-quoted strings, the quoting from &quot;\Q&quot; is applied after interpolation and escapes are processed.<div class="spacer">
</div>
<br/>
    &quot;abc\Qfoo\tbar$s\Exyz&quot;<br/>
<div class="spacer">
</div>
is equivalent to<div class="spacer">
</div>
<br/>
    &quot;abc&quot; . quotemeta(&quot;foo\tbar$s&quot;) . &quot;xyz&quot;<br/>
<div class="spacer">
</div>
For the pattern of regex operators (&quot;qr//&quot;, &quot;m//&quot; and &quot;s///&quot;), the quoting from &quot;\Q&quot; is applied after interpolation is processed, but before escapes are processed. This allows the pattern to match literally (except for &quot;$&quot; and &quot;@&quot;). For example, the following matches:<div class="spacer">
</div>
<br/>
    '\s\t' =~ /\Q\s\t/<br/>
<div class="spacer">
</div>
Because &quot;$&quot; or &quot;@&quot; trigger interpolation, you'll need to use something like &quot;/\Quser\E\@\Qhost/&quot; to match them literally.<div class="spacer">
</div>
Patterns are subject to an additional level of interpretation as a regular expression.  This is done as a second pass, after variables are interpolated, so that regular expressions may be incorporated into the pattern from the variables.  If this is not what you want, use &quot;\Q&quot; to interpolate a variable literally.<div class="spacer">
</div>
Apart from the behavior described above, Perl does not expand multiple levels of interpolation.  In particular, contrary to the expectations of shell programmers, back-quotes do  <i>NOT</i> interpolate within double quotes, nor do single quotes impede evaluation of variables when used within double quotes.</div>
<div class="subsection">
<h2>Regexp Quote-Like Operators</h2> Here are the quote-like operators that apply to pattern matching and related activities.<dl>
<dt>
qr/STRING/msixpodual</dt>
<dd>
This operator quotes (and possibly compiles) its <i>STRING</i> as a regular expression.   <i>STRING</i> is interpolated the same way as <i>PATTERN</i> in &quot;m/PATTERN/&quot;.  If &quot;'&quot; is used as the delimiter, no interpolation is done.  Returns a Perl value which may be used instead of the corresponding &quot;/STRING/msixpodual&quot; expression. The returned value is a normalized version of the original pattern. It magically differs from a string containing the same characters: &quot;ref(qr/x/)&quot; returns &quot;Regexp&quot;, even though dereferencing the result returns undef.<div style="height: 1.00em;">
&#160;</div>
For example,<div style="height: 1.00em;">
&#160;</div>
<br/>
    $rex = qr/my.STRING/is;<br/>
    print $rex;                 # prints (?si-xm:my.STRING)<br/>
    s/$rex/foo/;<br/>
<div style="height: 1.00em;">
&#160;</div>
is equivalent to<div style="height: 1.00em;">
&#160;</div>
<br/>
    s/my.STRING/foo/is;<br/>
<div style="height: 1.00em;">
&#160;</div>
The result may be used as a subpattern in a match:<div style="height: 1.00em;">
&#160;</div>
<br/>
    $re = qr/$pattern/;<br/>
    $string =~ /foo${re}bar/;   # can be interpolated in other patterns<br/>
    $string =~ $re;             # or used standalone<br/>
    $string =~ /$re/;           # or this way<br/>
<div style="height: 1.00em;">
&#160;</div>
Since Perl may compile the pattern at the moment of execution of the <i>qr()</i> operator, using  <i>qr()</i> may have speed advantages in some situations, notably if the result of  <i>qr()</i> is used standalone:<div style="height: 1.00em;">
&#160;</div>
<br/>
    sub match {<br/>
        my $patterns = shift;<br/>
        my @compiled = map qr/$_/i, @$patterns;<br/>
        grep {<br/>
            my $success = 0;<br/>
            foreach my $pat (@compiled) {<br/>
                $success = 1, last if /$pat/;<br/>
            }<br/>
            $success;<br/>
        } @_;<br/>
    }<br/>
<div style="height: 1.00em;">
&#160;</div>
Precompilation of the pattern into an internal representation at the moment of  <i>qr()</i> avoids a need to recompile the pattern every time a match &quot;/$pat/&quot; is attempted.  (Perl has many other internal optimizations, but none would be triggered in the above example if we did not use  <i>qr()</i> operator.)<div style="height: 1.00em;">
&#160;</div>
Options (specified by the following modifiers) are:<div style="height: 1.00em;">
&#160;</div>
<br/>
    m   Treat string as multiple lines.<br/>
    s   Treat string as single line. (Make . match a newline)<br/>
    i   Do case-insensitive pattern matching.<br/>
    x   Use extended regular expressions.<br/>
    p   When matching preserve a copy of the matched string so<br/>
        that ${^PREMATCH}, ${^MATCH}, ${^POSTMATCH} will be defined.<br/>
    o   Compile pattern only once.<br/>
    l   Use the locale<br/>
    u   Use Unicode rules<br/>
    a   Use ASCII for \d, \s, \w; specifying two a's further restricts<br/>
        /i matching so that no ASCII character will match a non-ASCII<br/>
        one<br/>
    d   Use Unicode or native charset, as in 5.12 and earlier<br/>
<div style="height: 1.00em;">
&#160;</div>
If a precompiled pattern is embedded in a larger pattern then the effect of &quot;msixpluad&quot; will be propagated appropriately.  The effect the &quot;o&quot; modifier has is not propagated, being restricted to those patterns explicitly using it.<div style="height: 1.00em;">
&#160;</div>
The last four modifiers listed above, added in Perl 5.14, control the character set semantics.<div style="height: 1.00em;">
&#160;</div>
See perlre for additional information on valid syntax for STRING, and for a detailed look at the semantics of regular expressions.  In particular, all the modifiers execpt &quot;/o&quot; are further explained in &quot;Modifiers&quot; in perlre.  &quot;/o&quot; is described in the next section.</dd>
</dl>
<dl>
<dt>
m/PATTERN/msixpodualgc</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
/PATTERN/msixpodualgc</dt>
<dd>
Searches a string for a pattern match, and in scalar context returns true if it succeeds, false if it fails.  If no string is specified via the &quot;=~&quot; or &quot;!~&quot; operator, the $_ string is searched.  (The string specified with &quot;=~&quot; need not be an lvalue--it may be the result of an expression evaluation, but remember the &quot;=~&quot; binds rather tightly.)  See also perlre.<div style="height: 1.00em;">
&#160;</div>
Options are as described in &quot;qr//&quot; above; in addition, the following match process modifiers are available:<div style="height: 1.00em;">
&#160;</div>
<br/>
 g  Match globally, i.e., find all occurrences.<br/>
 c  Do not reset search position on a failed match when /g is in effect.<br/>
<div style="height: 1.00em;">
&#160;</div>
If &quot;/&quot; is the delimiter then the initial &quot;m&quot; is optional.  With the &quot;m&quot; you can use any pair of non-whitespace (ASCII) characters as delimiters.  This is particularly useful for matching path names that contain &quot;/&quot;, to avoid LTS (leaning toothpick syndrome).  If &quot;?&quot; is the delimiter, then a match-only-once rule applies, described in &quot;m?PATTERN?&quot; below. If &quot;'&quot; is the delimiter, no interpolation is performed on the PATTERN. When using a character valid in an identifier, whitespace is required after the &quot;m&quot;.<div style="height: 1.00em;">
&#160;</div>
PATTERN may contain variables, which will be interpolated every time the pattern search is evaluated, except for when the delimiter is a single quote.  (Note that $(, $), and $| are not interpolated because they look like end-of-string tests.) Perl will not recompile the pattern unless an interpolated variable that it contains changes.  You can force Perl to skip the test and never recompile by adding a &quot;/o&quot; (which stands for &quot;once&quot;) after the trailing delimiter. Once upon a time, Perl would recompile regular expressions unnecessarily, and this modifier was useful to tell it not to do so, in the interests of speed.  But now, the only reasons to use &quot;/o&quot; are either:</dd>
</dl>
<div style="margin-left: 8.00ex;">
<dl>
<dt>
1.</dt>
<dd>
The variables are thousands of characters long and you know that they don't change, and you need to wring out the last little bit of speed by having Perl skip testing for that.  (There is a maintenance penalty for doing this, as mentioning &quot;/o&quot; constitutes a promise that you won't change the variables in the pattern.  If you change them, Perl won't even notice.)</dd>
</dl>
<dl>
<dt>
2.</dt>
<dd>
you want the pattern to use the initial values of the variables regardless of whether they change or not.  (But there are saner ways of accomplishing this than using &quot;/o&quot;.)</dd>
</dl>
</div>
<div style="margin-left: 8.00ex;">
</div>
<dl>
<dt>
The empty pattern //</dt>
<dd>
If the PATTERN evaluates to the empty string, the last  <i>successfully</i> matched regular expression is used instead. In this case, only the &quot;g&quot; and &quot;c&quot; flags on the empty pattern are honored; the other flags are taken from the original pattern. If no match has previously succeeded, this will (silently) act instead as a genuine empty pattern (which will always match).<div style="height: 1.00em;">
&#160;</div>
Note that it's possible to confuse Perl into thinking &quot;//&quot; (the empty regex) is really &quot;//&quot; (the defined-or operator).  Perl is usually pretty good about this, but some pathological cases might trigger this, such as &quot;$a///&quot; (is that &quot;($a) / (//)&quot; or &quot;$a // /&quot;?) and &quot;print $fh //&quot; (&quot;print $fh(//&quot; or &quot;print($fh //&quot;?).  In all of these examples, Perl will assume you meant defined-or.  If you meant the empty regex, just use parentheses or spaces to disambiguate, or even prefix the empty regex with an &quot;m&quot; (so &quot;//&quot; becomes &quot;m//&quot;).</dd>
</dl>
<dl>
<dt>
Matching in list context</dt>
<dd>
If the &quot;/g&quot; option is not used, &quot;m//&quot; in list context returns a list consisting of the subexpressions matched by the parentheses in the pattern, i.e., ($1, $2, $3...).  (Note that here $1 etc. are also set, and that this differs from Perl 4's behavior.)  When there are no parentheses in the pattern, the return value is the list &quot;(1)&quot; for success.  With or without parentheses, an empty list is returned upon failure.<div style="height: 1.00em;">
&#160;</div>
Examples:<div style="height: 1.00em;">
&#160;</div>
<br/>
    open(TTY, &quot;+&gt;/dev/tty&quot;)<br/>
        || die &quot;can't access /dev/tty: $!&quot;;<br/>
<br/>
    &lt;TTY&gt; =~ /^y/i &amp;&amp; foo();    # do foo if desired<br/>
<br/>
    if (/Version: *([0-9.]*)/) { $version = $1; }<br/>
<br/>
    next if m#^/usr/spool/uucp#;<br/>
<br/>
    # poor man's grep<br/>
    $arg = shift;<br/>
    while (&lt;&gt;) {<br/>
        print if /$arg/o;       # compile only once (no longer needed!)<br/>
    }<br/>
<br/>
    if (($F1, $F2, $Etc) = ($foo =~ /^(\S+)\s+(\S+)\s*(.*)/))<br/>
<div style="height: 1.00em;">
&#160;</div>
This last example splits $foo into the first two words and the remainder of the line, and assigns those three fields to $F1, $F2, and $Etc.  The conditional is true if any variables were assigned; that is, if the pattern matched.<div style="height: 1.00em;">
&#160;</div>
The &quot;/g&quot; modifier specifies global pattern matching--that is, matching as many times as possible within the string. How it behaves depends on the context. In list context, it returns a list of the substrings matched by any capturing parentheses in the regular expression. If there are no parentheses, it returns a list of all the matched strings, as if there were parentheses around the whole pattern.<div style="height: 1.00em;">
&#160;</div>
In scalar context, each execution of &quot;m//g&quot; finds the next match, returning true if it matches, and false if there is no further match. The position after the last match can be read or set using the &quot;pos()&quot; function; see &quot;pos&quot; in perlfunc. A failed match normally resets the search position to the beginning of the string, but you can avoid that by adding the &quot;/c&quot; modifier (e.g. &quot;m//gc&quot;). Modifying the target string also resets the search position.</dd>
</dl>
<dl>
<dt>
\G assertion</dt>
<dd>
You can intermix &quot;m//g&quot; matches with &quot;m/\G.../g&quot;, where &quot;\G&quot; is a zero-width assertion that matches the exact position where the previous &quot;m//g&quot;, if any, left off. Without the &quot;/g&quot; modifier, the &quot;\G&quot; assertion still anchors at &quot;pos()&quot; as it was at the start of the operation (see &quot;pos&quot; in perlfunc), but the match is of course only attempted once. Using &quot;\G&quot; without &quot;/g&quot; on a target string that has not previously had a &quot;/g&quot; match applied to it is the same as using the &quot;\A&quot; assertion to match the beginning of the string.  Note also that, currently, &quot;\G&quot; is only properly supported when anchored at the very beginning of the pattern.<div style="height: 1.00em;">
&#160;</div>
Examples:<div style="height: 1.00em;">
&#160;</div>
<br/>
    # list context<br/>
    ($one,$five,$fifteen) = (`uptime` =~ /(\d+\.\d+)/g);<br/>
<br/>
    # scalar context<br/>
    local $/ = &quot;&quot;;<br/>
    while ($paragraph = &lt;&gt;) {<br/>
        while ($paragraph =~ /\p{Ll}['&quot;)]*[.!?]+['&quot;)]*\s/g) {<br/>
            $sentences++;<br/>
        }<br/>
    }<br/>
    say $sentences;<br/>
<div style="height: 1.00em;">
&#160;</div>
Here's another way to check for sentences in a paragraph:<div style="height: 1.00em;">
&#160;</div>
<br/>
    my $sentence_rx = qr{<br/>
        (?: (?&lt;= ^ ) | (?&lt;= \s ) )  # after start-of-string or whitespace<br/>
        \p{Lu}                      # capital letter<br/>
        .*?                         # a bunch of anything<br/>
        (?&lt;= \S )                   # that ends in non-whitespace<br/>
        (?&lt;! \b [DMS]r  )           # but isn't a common abbreviation<br/>
        (?&lt;! \b Mrs )<br/>
        (?&lt;! \b Sra )<br/>
        (?&lt;! \b St  )<br/>
        [.?!]                       # followed by a sentence ender<br/>
        (?= $ | \s )                # in front of end-of-string or whitespace<br/>
    }sx;<br/>
    local $/ = &quot;&quot;;<br/>
    while (my $paragraph = &lt;&gt;) {<br/>
        say &quot;NEW PARAGRAPH&quot;;<br/>
        my $count = 0;<br/>
        while ($paragraph =~ /($sentence_rx)/g) {<br/>
            printf &quot;\tgot sentence %d: &lt;%s&gt;\n&quot;, ++$count, $1;<br/>
        }<br/>
    }<br/>
<div style="height: 1.00em;">
&#160;</div>
Here's how to use &quot;m//gc&quot; with &quot;\G&quot;:<div style="height: 1.00em;">
&#160;</div>
<br/>
    $_ = &quot;ppooqppqq&quot;;<br/>
    while ($i++ &lt; 2) {<br/>
        print &quot;1: '&quot;;<br/>
        print $1 while /(o)/gc; print &quot;', pos=&quot;, pos, &quot;\n&quot;;<br/>
        print &quot;2: '&quot;;<br/>
        print $1 if /\G(q)/gc;  print &quot;', pos=&quot;, pos, &quot;\n&quot;;<br/>
        print &quot;3: '&quot;;<br/>
        print $1 while /(p)/gc; print &quot;', pos=&quot;, pos, &quot;\n&quot;;<br/>
    }<br/>
    print &quot;Final: '$1', pos=&quot;,pos,&quot;\n&quot; if /\G(.)/;<br/>
<div style="height: 1.00em;">
&#160;</div>
The last example should print:<div style="height: 1.00em;">
&#160;</div>
<br/>
    1: 'oo', pos=4<br/>
    2: 'q', pos=5<br/>
    3: 'pp', pos=7<br/>
    1: '', pos=7<br/>
    2: 'q', pos=8<br/>
    3: '', pos=8<br/>
    Final: 'q', pos=8<br/>
<div style="height: 1.00em;">
&#160;</div>
Notice that the final match matched &quot;q&quot; instead of &quot;p&quot;, which a match without the &quot;\G&quot; anchor would have done. Also note that the final match did not update &quot;pos&quot;. &quot;pos&quot; is only updated on a &quot;/g&quot; match. If the final match did indeed match &quot;p&quot;, it's a good bet that you're running a very old (pre-5.6.0) version of Perl.<div style="height: 1.00em;">
&#160;</div>
A useful idiom for &quot;lex&quot;-like scanners is &quot;/\G.../gc&quot;.  You can combine several regexps like this to process a string part-by-part, doing different actions depending on which regexp matched.  Each regexp tries to match where the previous one leaves off.<div style="height: 1.00em;">
&#160;</div>
<br/>
 $_ = &lt;&lt;'EOL';<br/>
    $url = URI::URL-&gt;new( &quot;http://example.com/&quot; ); die if $url eq &quot;xXx&quot;;<br/>
 EOL<br/>
<br/>
 LOOP: {<br/>
     print(&quot; digits&quot;),       redo LOOP if /\G\d+\b[,.;]?\s*/gc;<br/>
     print(&quot; lowercase&quot;),    redo LOOP if /\G\p{Ll}+\b[,.;]?\s*/gc;<br/>
     print(&quot; UPPERCASE&quot;),    redo LOOP if /\G\p{Lu}+\b[,.;]?\s*/gc;<br/>
     print(&quot; Capitalized&quot;),  redo LOOP if /\G\p{Lu}\p{Ll}+\b[,.;]?\s*/gc;<br/>
     print(&quot; MiXeD&quot;),        redo LOOP if /\G\pL+\b[,.;]?\s*/gc;<br/>
     print(&quot; alphanumeric&quot;), redo LOOP if /\G[\p{Alpha}\pN]+\b[,.;]?\s*/gc;<br/>
     print(&quot; line-noise&quot;),   redo LOOP if /\G\W+/gc;<br/>
     print &quot;. That's all!\n&quot;;<br/>
 }<br/>
<div style="height: 1.00em;">
&#160;</div>
Here is the output (split into several lines):<div style="height: 1.00em;">
&#160;</div>
<br/>
    line-noise lowercase line-noise UPPERCASE line-noise UPPERCASE<br/>
    line-noise lowercase line-noise lowercase line-noise lowercase<br/>
    lowercase line-noise lowercase lowercase line-noise lowercase<br/>
    lowercase line-noise MiXeD line-noise. That's all!<br/>
</dd>
</dl>
<dl>
<dt>
m?PATTERN?msixpodualgc</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
?PATTERN?msixpodualgc</dt>
<dd>
This is just like the &quot;m/PATTERN/&quot; search, except that it matches only once between calls to the  <i>reset()</i> operator.  This is a useful optimization when you want to see only the first occurrence of something in each file of a set of files, for instance.  Only &quot;m??&quot; patterns local to the current package are reset.<div style="height: 1.00em;">
&#160;</div>
<br/>
    while (&lt;&gt;) {<br/>
        if (m?^$?) {<br/>
                            # blank line between header and body<br/>
        }<br/>
    } continue {<br/>
        reset if eof;       # clear m?? status for next file<br/>
    }<br/>
<div style="height: 1.00em;">
&#160;</div>
Another example switched the first &quot;latin1&quot; encoding it finds to &quot;utf8&quot; in a pod file:<div style="height: 1.00em;">
&#160;</div>
<br/>
    s//utf8/ if m? ^ =encoding \h+ \K latin1 ?x;<br/>
<div style="height: 1.00em;">
&#160;</div>
The match-once behavior is controlled by the match delimiter being &quot;?&quot;; with any other delimiter this is the normal &quot;m//&quot; operator.<div style="height: 1.00em;">
&#160;</div>
For historical reasons, the leading &quot;m&quot; in &quot;m?PATTERN?&quot; is optional, but the resulting &quot;?PATTERN?&quot; syntax is deprecated, will warn on usage and might be removed from a future stable release of Perl (without further notice!).</dd>
</dl>
<dl>
<dt>
s/PATTERN/REPLACEMENT/msixpodualgcer</dt>
<dd>
Searches a string for a pattern, and if found, replaces that pattern with the replacement text and returns the number of substitutions made.  Otherwise it returns false (specifically, the empty string).<div style="height: 1.00em;">
&#160;</div>
If the &quot;/r&quot; (non-destructive) option is used then it runs the substitution on a copy of the string and instead of returning the number of substitutions, it returns the copy whether or not a substitution occurred.  The original string is never changed when &quot;/r&quot; is used.  The copy will always be a plain string, even if the input is an object or a tied variable.<div style="height: 1.00em;">
&#160;</div>
If no string is specified via the &quot;=~&quot; or &quot;!~&quot; operator, the $_ variable is searched and modified.  Unless the &quot;/r&quot; option is used, the string specified must be a scalar variable, an array element, a hash element, or an assignment to one of those; that is, some sort of scalar lvalue.<div style="height: 1.00em;">
&#160;</div>
If the delimiter chosen is a single quote, no interpolation is done on either the PATTERN or the REPLACEMENT.  Otherwise, if the PATTERN contains a $ that looks like a variable rather than an end-of-string test, the variable will be interpolated into the pattern at run-time.  If you want the pattern compiled only once the first time the variable is interpolated, use the &quot;/o&quot; option.  If the pattern evaluates to the empty string, the last successfully executed regular expression is used instead.  See perlre for further explanation on these.<div style="height: 1.00em;">
&#160;</div>
Options are as with m// with the addition of the following replacement specific options:<div style="height: 1.00em;">
&#160;</div>
<br/>
    e   Evaluate the right side as an expression.<br/>
    ee  Evaluate the right side as a string then eval the result.<br/>
    r   Return substitution and leave the original string untouched.<br/>
<div style="height: 1.00em;">
&#160;</div>
Any non-whitespace delimiter may replace the slashes.  Add space after the &quot;s&quot; when using a character allowed in identifiers.  If single quotes are used, no interpretation is done on the replacement string (the &quot;/e&quot; modifier overrides this, however).  Unlike Perl 4, Perl 5 treats backticks as normal delimiters; the replacement text is not evaluated as a command. If the PATTERN is delimited by bracketing quotes, the REPLACEMENT has its own pair of quotes, which may or may not be bracketing quotes, e.g., &quot;s(foo)(bar)&quot; or &quot;s&lt;foo&gt;/bar/&quot;.  A &quot;/e&quot; will cause the replacement portion to be treated as a full-fledged Perl expression and evaluated right then and there.  It is, however, syntax checked at compile-time. A second &quot;e&quot; modifier will cause the replacement portion to be &quot;eval&quot;ed before being run as a Perl expression.<div style="height: 1.00em;">
&#160;</div>
Examples:<div style="height: 1.00em;">
&#160;</div>
<br/>
    s/\bgreen\b/mauve/g;                # don't change wintergreen<br/>
<br/>
    $path =~ s|/usr/bin|/usr/local/bin|;<br/>
<br/>
    s/Login: $foo/Login: $bar/; # run-time pattern<br/>
<br/>
    ($foo = $bar) =~ s/this/that/;      # copy first, then change<br/>
    ($foo = &quot;$bar&quot;) =~ s/this/that/;    # convert to string, copy, then change<br/>
    $foo = $bar =~ s/this/that/r;       # Same as above using /r<br/>
    $foo = $bar =~ s/this/that/r<br/>
                =~ s/that/the other/r;  # Chained substitutes using /r<br/>
    @foo = map { s/this/that/r } @bar   # /r is very useful in maps<br/>
<br/>
    $count = ($paragraph =~ s/Mister\b/Mr./g);  # get change-count<br/>
<br/>
    $_ = 'abc123xyz';<br/>
    s/\d+/$&amp;*2/e;               # yields 'abc246xyz'<br/>
    s/\d+/sprintf(&quot;%5d&quot;,$&amp;)/e;  # yields 'abc  246xyz'<br/>
    s/\w/$&amp; x 2/eg;             # yields 'aabbcc  224466xxyyzz'<br/>
<br/>
    s/%(.)/$percent{$1}/g;      # change percent escapes; no /e<br/>
    s/%(.)/$percent{$1} || $&amp;/ge;       # expr now, so /e<br/>
    s/^=(\w+)/pod($1)/ge;       # use function call<br/>
<br/>
    $_ = 'abc123xyz';<br/>
    $a = s/abc/def/r;           # $a is 'def123xyz' and<br/>
                                # $_ remains 'abc123xyz'.<br/>
<br/>
    # expand variables in $_, but dynamics only, using<br/>
    # symbolic dereferencing<br/>
    s/\$(\w+)/${$1}/g;<br/>
<br/>
    # Add one to the value of any numbers in the string<br/>
    s/(\d+)/1 + $1/eg;<br/>
<br/>
    # Titlecase words in the last 30 characters only<br/>
    substr($str, -30) =~ s/\b(\p{Alpha}+)\b/\u\L$1/g;<br/>
<br/>
    # This will expand any embedded scalar variable<br/>
    # (including lexicals) in $_ : First $1 is interpolated<br/>
    # to the variable name, and then evaluated<br/>
    s/(\$\w+)/$1/eeg;<br/>
<br/>
    # Delete (most) C comments.<br/>
    $program =~ s {<br/>
        /\*     # Match the opening delimiter.<br/>
        .*?     # Match a minimal number of characters.<br/>
        \*/     # Match the closing delimiter.<br/>
    } []gsx;<br/>
<br/>
    s/^\s*(.*?)\s*$/$1/;        # trim whitespace in $_, expensively<br/>
<br/>
    for ($variable) {           # trim whitespace in $variable, cheap<br/>
        s/^\s+//;<br/>
        s/\s+$//;<br/>
    }<br/>
<br/>
    s/([^ ]*) *([^ ]*)/$2 $1/;  # reverse 1st two fields<br/>
<div style="height: 1.00em;">
&#160;</div>
Note the use of $ instead of \ in the last example.  Unlike  <b>sed</b>, we use the \&lt;<i>digit</i>&gt; form in only the left hand side. Anywhere else it's $&lt; <i>digit</i>&gt;.<div style="height: 1.00em;">
&#160;</div>
Occasionally, you can't use just a &quot;/g&quot; to get all the changes to occur that you might want.  Here are two common cases:<div style="height: 1.00em;">
&#160;</div>
<br/>
    # put commas in the right places in an integer<br/>
    1 while s/(\d)(\d\d\d)(?!\d)/$1,$2/g;<br/>
<br/>
    # expand tabs to 8-column spacing<br/>
    1 while s/\t+/' ' x (length($&amp;)*8 - length($`)%8)/e;<br/>
<div style="height: 1.00em;">
&#160;</div>
&quot;s///le&quot; is treated as a substitution followed by the &quot;le&quot; operator, not the &quot;/le&quot; flags.  This may change in a future version of Perl.  It produces a warning if warnings are enabled.  To disambiguate, use a space or change the order of the flags:<div style="height: 1.00em;">
&#160;</div>
<br/>
    s/foo/bar/ le 5;  # &quot;le&quot; infix operator<br/>
    s/foo/bar/el;     # &quot;e&quot; and &quot;l&quot; flags<br/>
</dd>
</dl>
</div>
<div class="subsection">
<h2>Quote-Like Operators</h2><dl>
<dt>
q/STRING/</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
'STRING'</dt>
<dd>
A single-quoted, literal string.  A backslash represents a backslash unless followed by the delimiter or another backslash, in which case the delimiter or backslash is interpolated.<div style="height: 1.00em;">
&#160;</div>
<br/>
    $foo = q!I said, &quot;You said, 'She said it.'&quot;!;<br/>
    $bar = q('This is it.');<br/>
    $baz = '\n';                # a two-character string<br/>
</dd>
</dl>
<dl>
<dt>
qq/STRING/</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
&quot;STRING&quot;</dt>
<dd>
A double-quoted, interpolated string.<div style="height: 1.00em;">
&#160;</div>
<br/>
    $_ .= qq<br/>
     (*** The previous line contains the naughty word &quot;$1&quot;.\n)<br/>
                if /\b(tcl|java|python)\b/i;      # :-)<br/>
    $baz = &quot;\n&quot;;                # a one-character string<br/>
</dd>
</dl>
<dl>
<dt>
qx/STRING/</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
`STRING`</dt>
<dd>
A string which is (possibly) interpolated and then executed as a system command with &quot;/bin/sh&quot; or its equivalent.  Shell wildcards, pipes, and redirections will be honored.  The collected standard output of the command is returned; standard error is unaffected.  In scalar context, it comes back as a single (potentially multi-line) string, or undef if the command failed.  In list context, returns a list of lines (however you've defined lines with $/ or $INPUT_RECORD_SEPARATOR), or an empty list if the command failed.<div style="height: 1.00em;">
&#160;</div>
Because backticks do not affect standard error, use shell file descriptor syntax (assuming the shell supports this) if you care to address this. To capture a command's STDERR and STDOUT together:<div style="height: 1.00em;">
&#160;</div>
<br/>
    $output = `cmd 2&gt;&amp;1`;<br/>
<div style="height: 1.00em;">
&#160;</div>
To capture a command's STDOUT but discard its STDERR:<div style="height: 1.00em;">
&#160;</div>
<br/>
    $output = `cmd 2&gt;/dev/null`;<br/>
<div style="height: 1.00em;">
&#160;</div>
To capture a command's STDERR but discard its STDOUT (ordering is important here):<div style="height: 1.00em;">
&#160;</div>
<br/>
    $output = `cmd 2&gt;&amp;1 1&gt;/dev/null`;<br/>
<div style="height: 1.00em;">
&#160;</div>
To exchange a command's STDOUT and STDERR in order to capture the STDERR but leave its STDOUT to come out the old STDERR:<div style="height: 1.00em;">
&#160;</div>
<br/>
    $output = `cmd 3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3 3&gt;&amp;-`;<br/>
<div style="height: 1.00em;">
&#160;</div>
To read both a command's STDOUT and its STDERR separately, it's easiest to redirect them separately to files, and then read from those files when the program is done:<div style="height: 1.00em;">
&#160;</div>
<br/>
    system(&quot;program args 1&gt;program.stdout 2&gt;program.stderr&quot;);<br/>
<div style="height: 1.00em;">
&#160;</div>
The STDIN filehandle used by the command is inherited from Perl's STDIN. For example:<div style="height: 1.00em;">
&#160;</div>
<br/>
    open(SPLAT, &quot;stuff&quot;)   || die &quot;can't open stuff: $!&quot;;<br/>
    open(STDIN, &quot;&lt;&amp;SPLAT&quot;) || die &quot;can't dupe SPLAT: $!&quot;;<br/>
    print STDOUT `sort`;<br/>
<div style="height: 1.00em;">
&#160;</div>
will print the sorted contents of the file named <i>&quot;stuff&quot;</i>.<div style="height: 1.00em;">
&#160;</div>
Using single-quote as a delimiter protects the command from Perl's double-quote interpolation, passing it on to the shell instead:<div style="height: 1.00em;">
&#160;</div>
<br/>
    $perl_info  = qx(ps $$);            # that's Perl's $$<br/>
    $shell_info = qx'ps $$';            # that's the new shell's $$<br/>
<div style="height: 1.00em;">
&#160;</div>
How that string gets evaluated is entirely subject to the command interpreter on your system.  On most platforms, you will have to protect shell metacharacters if you want them treated literally.  This is in practice difficult to do, as it's unclear how to escape which characters. See perlsec for a clean and safe example of a manual  <i>fork()</i> and <i>exec()</i> to emulate backticks safely.<div style="height: 1.00em;">
&#160;</div>
On some platforms (notably DOS-like ones), the shell may not be capable of dealing with multiline commands, so putting newlines in the string may not get you what you want.  You may be able to evaluate multiple commands in a single line by separating them with the command separator character, if your shell supports that (e.g. &quot;;&quot; on many Unix shells; &quot;&amp;&quot; on the Windows NT &quot;cmd&quot; shell).<div style="height: 1.00em;">
&#160;</div>
Beginning with v5.6.0, Perl will attempt to flush all files opened for output before starting the child process, but this may not be supported on some platforms (see perlport).  To be safe, you may need to set $| ($AUTOFLUSH in English) or call the &quot;autoflush()&quot; method of &quot;IO::Handle&quot; on any open handles.<div style="height: 1.00em;">
&#160;</div>
Beware that some command shells may place restrictions on the length of the command line.  You must ensure your strings don't exceed this limit after any necessary interpolations.  See the platform-specific release notes for more details about your particular environment.<div style="height: 1.00em;">
&#160;</div>
Using this operator can lead to programs that are difficult to port, because the shell commands called vary between systems, and may in fact not be present at all.  As one example, the &quot;type&quot; command under the POSIX shell is very different from the &quot;type&quot; command under DOS. That doesn't mean you should go out of your way to avoid backticks when they're the right way to get something done.  Perl was made to be a glue language, and one of the things it glues together is commands. Just understand what you're getting yourself into.<div style="height: 1.00em;">
&#160;</div>
See &quot;I/O Operators&quot; for more discussion.</dd>
</dl>
<dl>
<dt>
qw/STRING/</dt>
<dd>
Evaluates to a list of the words extracted out of STRING, using embedded whitespace as the word delimiters.  It can be understood as being roughly equivalent to:<div style="height: 1.00em;">
&#160;</div>
<br/>
    split(&quot; &quot;, q/STRING/);<br/>
<div style="height: 1.00em;">
&#160;</div>
the differences being that it generates a real list at compile time, and in scalar context it returns the last element in the list.  So this expression:<div style="height: 1.00em;">
&#160;</div>
<br/>
    qw(foo bar baz)<br/>
<div style="height: 1.00em;">
&#160;</div>
is semantically equivalent to the list:<div style="height: 1.00em;">
&#160;</div>
<br/>
    &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;<br/>
<div style="height: 1.00em;">
&#160;</div>
Some frequently seen examples:<div style="height: 1.00em;">
&#160;</div>
<br/>
    use POSIX qw( setlocale localeconv )<br/>
    @EXPORT = qw( foo bar baz );<br/>
<div style="height: 1.00em;">
&#160;</div>
A common mistake is to try to separate the words with comma or to put comments into a multi-line &quot;qw&quot;-string.  For this reason, the &quot;use warnings&quot; pragma and the  <b>-w</b> switch (that is, the $^W variable) produces warnings if the STRING contains the &quot;,&quot; or the &quot;#&quot; character.</dd>
</dl>
<dl>
<dt>
tr/SEARCHLIST/REPLACEMENTLIST/cdsr</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
y/SEARCHLIST/REPLACEMENTLIST/cdsr</dt>
<dd>
Transliterates all occurrences of the characters found in the search list with the corresponding character in the replacement list.  It returns the number of characters replaced or deleted.  If no string is specified via the &quot;=~&quot; or &quot;!~&quot; operator, the $_ string is transliterated.<div style="height: 1.00em;">
&#160;</div>
If the &quot;/r&quot; (non-destructive) option is present, a new copy of the string is made and its characters transliterated, and this copy is returned no matter whether it was modified or not: the original string is always left unchanged.  The new copy is always a plain string, even if the input string is an object or a tied variable.<div style="height: 1.00em;">
&#160;</div>
Unless the &quot;/r&quot; option is used, the string specified with &quot;=~&quot; must be a scalar variable, an array element, a hash element, or an assignment to one of those; in other words, an lvalue.<div style="height: 1.00em;">
&#160;</div>
A character range may be specified with a hyphen, so &quot;tr/A-J/0-9/&quot; does the same replacement as &quot;tr/ACEGIBDFHJ/0246813579/&quot;. For  <b>sed</b> devotees, &quot;y&quot; is provided as a synonym for &quot;tr&quot;.  If the SEARCHLIST is delimited by bracketing quotes, the REPLACEMENTLIST has its own pair of quotes, which may or may not be bracketing quotes; for example, &quot;tr[aeiouy][yuoiea]&quot; or &quot;tr(+\-*/)/ABCD/&quot;.<div style="height: 1.00em;">
&#160;</div>
Note that &quot;tr&quot; does <b>not</b> do regular expression character classes such as &quot;\d&quot; or &quot;\pL&quot;.  The &quot;tr&quot; operator is not equivalent to the  <i>tr</i>(1) utility.  If you want to map strings between lower/upper cases, see &quot;lc&quot; in perlfunc and &quot;uc&quot; in perlfunc, and in general consider using the &quot;s&quot; operator if you need regular expressions.  The &quot;\U&quot;, &quot;\u&quot;, &quot;\L&quot;, and &quot;\l&quot; string-interpolation escapes on the right side of a substitution operator will perform correct case-mappings, but &quot;tr[a-z][A-Z]&quot; will not (except sometimes on legacy 7-bit data).<div style="height: 1.00em;">
&#160;</div>
Note also that the whole range idea is rather unportable between character sets--and even within character sets they may cause results you probably didn't expect.  A sound principle is to use only ranges that begin from and end at either alphabets of equal case (a-e, A-E), or digits (0-4).  Anything else is unsafe.  If in doubt, spell out the character sets in full.<div style="height: 1.00em;">
&#160;</div>
Options:<div style="height: 1.00em;">
&#160;</div>
<br/>
    c   Complement the SEARCHLIST.<br/>
    d   Delete found but unreplaced characters.<br/>
    s   Squash duplicate replaced characters.<br/>
    r   Return the modified string and leave the original string<br/>
        untouched.<br/>
<div style="height: 1.00em;">
&#160;</div>
If the &quot;/c&quot; modifier is specified, the SEARCHLIST character set is complemented.  If the &quot;/d&quot; modifier is specified, any characters specified by SEARCHLIST not found in REPLACEMENTLIST are deleted. (Note that this is slightly more flexible than the behavior of some  <b>tr</b> programs, which delete anything they find in the SEARCHLIST, period.) If the &quot;/s&quot; modifier is specified, sequences of characters that were transliterated to the same character are squashed down to a single instance of the character.<div style="height: 1.00em;">
&#160;</div>
If the &quot;/d&quot; modifier is used, the REPLACEMENTLIST is always interpreted exactly as specified.  Otherwise, if the REPLACEMENTLIST is shorter than the SEARCHLIST, the final character is replicated till it is long enough.  If the REPLACEMENTLIST is empty, the SEARCHLIST is replicated. This latter is useful for counting characters in a class or for squashing character sequences in a class.<div style="height: 1.00em;">
&#160;</div>
Examples:<div style="height: 1.00em;">
&#160;</div>
<br/>
    $ARGV[1] =~ tr/A-Z/a-z/;    # canonicalize to lower case ASCII<br/>
<br/>
    $cnt = tr/*/*/;             # count the stars in $_<br/>
<br/>
    $cnt = $sky =~ tr/*/*/;     # count the stars in $sky<br/>
<br/>
    $cnt = tr/0-9//;            # count the digits in $_<br/>
<br/>
    tr/a-zA-Z//s;               # bookkeeper -&gt; bokeper<br/>
<br/>
    ($HOST = $host) =~ tr/a-z/A-Z/;<br/>
     $HOST = $host  =~ tr/a-z/A-Z/r;   # same thing<br/>
<br/>
    $HOST = $host =~ tr/a-z/A-Z/r    # chained with s///r<br/>
                  =~ s/:/ -p/r;<br/>
<br/>
    tr/a-zA-Z/ /cs;             # change non-alphas to single space<br/>
<br/>
    @stripped = map tr/a-zA-Z/ /csr, @original;<br/>
                                # /r with map<br/>
<br/>
    tr [\200-\377]<br/>
       [\000-\177];             # wickedly delete 8th bit<br/>
<div style="height: 1.00em;">
&#160;</div>
If multiple transliterations are given for a character, only the first one is used:<div style="height: 1.00em;">
&#160;</div>
<br/>
    tr/AAA/XYZ/<br/>
<div style="height: 1.00em;">
&#160;</div>
will transliterate any A to X.<div style="height: 1.00em;">
&#160;</div>
Because the transliteration table is built at compile time, neither the SEARCHLIST nor the REPLACEMENTLIST are subjected to double quote interpolation.  That means that if you want to use variables, you must use an  <i>eval()</i>:<div style="height: 1.00em;">
&#160;</div>
<br/>
    eval &quot;tr/$oldlist/$newlist/&quot;;<br/>
    die $@ if $@;<br/>
<br/>
    eval &quot;tr/$oldlist/$newlist/, 1&quot; or die $@;<br/>
</dd>
</dl>
<dl>
<dt>
&lt;&lt;EOF</dt>
<dd>
A line-oriented form of quoting is based on the shell &quot;here-document&quot; syntax.  Following a &quot;&lt;&lt;&quot; you specify a string to terminate the quoted material, and all lines following the current line down to the terminating string are the value of the item.<div style="height: 1.00em;">
&#160;</div>
The terminating string may be either an identifier (a word), or some quoted text.  An unquoted identifier works like double quotes. There may not be a space between the &quot;&lt;&lt;&quot; and the identifier, unless the identifier is explicitly quoted.  (If you put a space it will be treated as a null identifier, which is valid, and matches the first empty line.)  The terminating string must appear by itself (unquoted and with no surrounding whitespace) on the terminating line.<div style="height: 1.00em;">
&#160;</div>
If the terminating string is quoted, the type of quotes used determine the treatment of the text.</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
Double Quotes</dt>
<dd>
Double quotes indicate that the text will be interpolated using exactly the same rules as normal double quoted strings.<div style="height: 1.00em;">
&#160;</div>
<br/>
       print &lt;&lt;EOF;<br/>
    The price is $Price.<br/>
    EOF<br/>
<br/>
       print &lt;&lt; &quot;EOF&quot;; # same as above<br/>
    The price is $Price.<br/>
    EOF<br/>
</dd>
</dl>
<dl>
<dt>
Single Quotes</dt>
<dd>
Single quotes indicate the text is to be treated literally with no interpolation of its content. This is similar to single quoted strings except that backslashes have no special meaning, with &quot;\\&quot; being treated as two backslashes and not one as they would in every other quoting construct.<div style="height: 1.00em;">
&#160;</div>
Just as in the shell, a backslashed bareword following the &quot;&lt;&lt;&quot; means the same thing as a single-quoted string does:<div style="height: 1.00em;">
&#160;</div>
<br/>
        $cost = &lt;&lt;'VISTA';  # hasta la ...<br/>
    That'll be $10 please, ma'am.<br/>
    VISTA<br/>
<br/>
        $cost = &lt;&lt;\VISTA;   # Same thing!<br/>
    That'll be $10 please, ma'am.<br/>
    VISTA<br/>
<div style="height: 1.00em;">
&#160;</div>
This is the only form of quoting in perl where there is no need to worry about escaping content, something that code generators can and do make good use of.</dd>
</dl>
<dl>
<dt>
Backticks</dt>
<dd>
The content of the here doc is treated just as it would be if the string were embedded in backticks. Thus the content is interpolated as though it were double quoted and then executed via the shell, with the results of the execution returned.<div style="height: 1.00em;">
&#160;</div>
<br/>
       print &lt;&lt; `EOC`; # execute command and get results<br/>
    echo hi there<br/>
    EOC<br/>
</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">
&#160;</div>
It is possible to stack multiple here-docs in a row:<div style="height: 1.00em;">
&#160;</div>
<br/>
       print &lt;&lt;&quot;foo&quot;, &lt;&lt;&quot;bar&quot;; # you can stack them<br/>
    I said foo.<br/>
    foo<br/>
    I said bar.<br/>
    bar<br/>
<br/>
       myfunc(&lt;&lt; &quot;THIS&quot;, 23, &lt;&lt;'THAT');<br/>
    Here's a line<br/>
    or two.<br/>
    THIS<br/>
    and here's another.<br/>
    THAT<br/>
<div style="height: 1.00em;">
&#160;</div>
Just don't forget that you have to put a semicolon on the end to finish the statement, as Perl doesn't know you're not going to try to do this:<div style="height: 1.00em;">
&#160;</div>
<br/>
       print &lt;&lt;ABC<br/>
    179231<br/>
    ABC<br/>
       + 20;<br/>
<div style="height: 1.00em;">
&#160;</div>
If you want to remove the line terminator from your here-docs, use &quot;chomp()&quot;.<div style="height: 1.00em;">
&#160;</div>
<br/>
    chomp($string = &lt;&lt;'END');<br/>
    This is a string.<br/>
    END<br/>
<div style="height: 1.00em;">
&#160;</div>
If you want your here-docs to be indented with the rest of the code, you'll need to remove leading whitespace from each line manually:<div style="height: 1.00em;">
&#160;</div>
<br/>
    ($quote = &lt;&lt;'FINIS') =~ s/^\s+//gm;<br/>
       The Road goes ever on and on,<br/>
       down from the door where it began.<br/>
    FINIS<br/>
<div style="height: 1.00em;">
&#160;</div>
If you use a here-doc within a delimited construct, such as in &quot;s///eg&quot;, the quoted material must come on the lines following the final delimiter. So instead of<div style="height: 1.00em;">
&#160;</div>
<br/>
    s/this/&lt;&lt;E . 'that'<br/>
    the other<br/>
    E<br/>
     . 'more '/eg;<br/>
<div style="height: 1.00em;">
&#160;</div>
you have to write<div style="height: 1.00em;">
&#160;</div>
<br/>
    s/this/&lt;&lt;E . 'that'<br/>
     . 'more '/eg;<br/>
    the other<br/>
    E<br/>
<div style="height: 1.00em;">
&#160;</div>
If the terminating identifier is on the last line of the program, you must be sure there is a newline after it; otherwise, Perl will give the warning  <b>Can't find string terminator &quot;END&quot; anywhere before EOF...</b>.<div style="height: 1.00em;">
&#160;</div>
Additionally, quoting rules for the end-of-string identifier are unrelated to Perl's quoting rules. &quot;q()&quot;, &quot;qq()&quot;, and the like are not supported in place of '' and &quot;&quot;, and the only interpolation is for backslashing the quoting character:<div style="height: 1.00em;">
&#160;</div>
<br/>
    print &lt;&lt; &quot;abc\&quot;def&quot;;<br/>
    testing...<br/>
    abc&quot;def<br/>
<div style="height: 1.00em;">
&#160;</div>
Finally, quoted strings cannot span multiple lines.  The general rule is that the identifier must be a string literal.  Stick with that, and you should be safe.</div>
</div>
<div class="subsection">
<h2>Gory details of parsing quoted constructs</h2> When presented with something that might have several different interpretations, Perl uses the  <b>DWIM</b> (that's &quot;Do What I Mean&quot;) principle to pick the most probable interpretation.  This strategy is so successful that Perl programmers often do not suspect the ambivalence of what they write.  But from time to time, Perl's notions differ substantially from what the author honestly meant.<div class="spacer">
</div>
This section hopes to clarify how Perl handles quoted constructs. Although the most common reason to learn this is to unravel labyrinthine regular expressions, because the initial steps of parsing are the same for all quoting operators, they are all discussed together.<div class="spacer">
</div>
The most important Perl parsing rule is the first one discussed below: when processing a quoted construct, Perl first finds the end of that construct, then interprets its contents.  If you understand this rule, you may skip the rest of this section on the first reading.  The other rules are likely to contradict the user's expectations much less frequently than this first one.<div class="spacer">
</div>
Some passes discussed below are performed concurrently, but because their results are the same, we consider them individually.  For different quoting constructs, Perl performs different numbers of passes, from one to four, but these passes are always performed in the same order.<dl>
<dt>
Finding the end</dt>
<dd>
The first pass is finding the end of the quoted construct, where the information about the delimiters is used in parsing. During this search, text between the starting and ending delimiters is copied to a safe location. The text copied gets delimiter-independent.<div style="height: 1.00em;">
&#160;</div>
If the construct is a here-doc, the ending delimiter is a line that has a terminating string as the content. Therefore &quot;&lt;&lt;EOF&quot; is terminated by &quot;EOF&quot; immediately followed by &quot;\n&quot; and starting from the first column of the terminating line. When searching for the terminating line of a here-doc, nothing is skipped. In other words, lines after the here-doc syntax are compared with the terminating string line by line.<div style="height: 1.00em;">
&#160;</div>
For the constructs except here-docs, single characters are used as starting and ending delimiters. If the starting delimiter is an opening punctuation (that is &quot;(&quot;, &quot;[&quot;, &quot;{&quot;, or &quot;&lt;&quot;), the ending delimiter is the corresponding closing punctuation (that is &quot;)&quot;, &quot;]&quot;, &quot;}&quot;, or &quot;&gt;&quot;). If the starting delimiter is an unpaired character like &quot;/&quot; or a closing punctuation, the ending delimiter is same as the starting delimiter. Therefore a &quot;/&quot; terminates a &quot;qq//&quot; construct, while a &quot;]&quot; terminates &quot;qq[]&quot; and &quot;qq]]&quot; constructs.<div style="height: 1.00em;">
&#160;</div>
When searching for single-character delimiters, escaped delimiters and &quot;\\&quot; are skipped. For example, while searching for terminating &quot;/&quot;, combinations of &quot;\\&quot; and &quot;\/&quot; are skipped.  If the delimiters are bracketing, nested pairs are also skipped.  For example, while searching for closing &quot;]&quot; paired with the opening &quot;[&quot;, combinations of &quot;\\&quot;, &quot;\]&quot;, and &quot;\[&quot; are all skipped, and nested &quot;[&quot; and &quot;]&quot; are skipped as well. However, when backslashes are used as the delimiters (like &quot;qq\\&quot; and &quot;tr\\\&quot;), nothing is skipped. During the search for the end, backslashes that escape delimiters are removed (exactly speaking, they are not copied to the safe location).<div style="height: 1.00em;">
&#160;</div>
For constructs with three-part delimiters (&quot;s///&quot;, &quot;y///&quot;, and &quot;tr///&quot;), the search is repeated once more. If the first delimiter is not an opening punctuation, three delimiters must be same such as &quot;s!!!&quot; and &quot;tr)))&quot;, in which case the second delimiter terminates the left part and starts the right part at once. If the left part is delimited by bracketing punctuation (that is &quot;()&quot;, &quot;[]&quot;, &quot;{}&quot;, or &quot;&lt;&gt;&quot;), the right part needs another pair of delimiters such as &quot;s(){}&quot; and &quot;tr[]//&quot;.  In these cases, whitespace and comments are allowed between both parts, though the comment must follow at least one whitespace character; otherwise a character expected as the start of the comment may be regarded as the starting delimiter of the right part.<div style="height: 1.00em;">
&#160;</div>
During this search no attention is paid to the semantics of the construct. Thus:<div style="height: 1.00em;">
&#160;</div>
<br/>
    &quot;$hash{&quot;$foo/$bar&quot;}&quot;<br/>
<div style="height: 1.00em;">
&#160;</div>
or:<div style="height: 1.00em;">
&#160;</div>
<br/>
    m/<br/>
      bar       # NOT a comment, this slash / terminated m//!<br/>
     /x<br/>
<div style="height: 1.00em;">
&#160;</div>
do not form legal quoted expressions.   The quoted part ends on the first &quot;&quot;&quot; and &quot;/&quot;, and the rest happens to be a syntax error. Because the slash that terminated &quot;m//&quot; was followed by a &quot;SPACE&quot;, the example above is not &quot;m//x&quot;, but rather &quot;m//&quot; with no &quot;/x&quot; modifier.  So the embedded &quot;#&quot; is interpreted as a literal &quot;#&quot;.<div style="height: 1.00em;">
&#160;</div>
Also no attention is paid to &quot;\c\&quot; (multichar control char syntax) during this search. Thus the second &quot;\&quot; in &quot;qq/\c\/&quot; is interpreted as a part of &quot;\/&quot;, and the following &quot;/&quot; is not recognized as a delimiter. Instead, use &quot;\034&quot; or &quot;\x1c&quot; at the end of quoted constructs.</dd>
</dl>
<dl>
<dt>
Interpolation</dt>
<dd>
The next step is interpolation in the text obtained, which is now delimiter-independent.  There are multiple cases.</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
&quot;&lt;&lt;'EOF'&quot;</dt>
<dd>
No interpolation is performed. Note that the combination &quot;\\&quot; is left intact, since escaped delimiters are not available for here-docs.</dd>
</dl>
<dl>
<dt>
&quot;m''&quot;, the pattern of &quot;s'''&quot;</dt>
<dd>
No interpolation is performed at this stage. Any backslashed sequences including &quot;\\&quot; are treated at the stage to &quot;parsing regular expressions&quot;.</dd>
</dl>
<dl>
<dt>
'', &quot;q//&quot;, &quot;tr'''&quot;, &quot;y'''&quot;, the replacement of &quot;s'''&quot;</dt>
<dd>
The only interpolation is removal of &quot;\&quot; from pairs of &quot;\\&quot;. Therefore &quot;-&quot; in &quot;tr'''&quot; and &quot;y'''&quot; is treated literally as a hyphen and no character range is available. &quot;\1&quot; in the replacement of &quot;s'''&quot; does not work as $1.</dd>
</dl>
<dl>
<dt>
&quot;tr///&quot;, &quot;y///&quot;</dt>
<dd>
No variable interpolation occurs.  String modifying combinations for case and quoting such as &quot;\Q&quot;, &quot;\U&quot;, and &quot;\E&quot; are not recognized. The other escape sequences such as &quot;\200&quot; and &quot;\t&quot; and backslashed characters such as &quot;\\&quot; and &quot;\-&quot; are converted to appropriate literals. The character &quot;-&quot; is treated specially and therefore &quot;\-&quot; is treated as a literal &quot;-&quot;.</dd>
</dl>
<dl>
<dt>
&quot;&quot;, &quot;``&quot;, &quot;qq//&quot;, &quot;qx//&quot;, &quot;&lt;file*glob&gt;&quot;, &quot;&lt;&lt;&quot;EOF&quot;&quot;</dt>
<dd>
&quot;\Q&quot;, &quot;\U&quot;, &quot;\u&quot;, &quot;\L&quot;, &quot;\l&quot; (possibly paired with &quot;\E&quot;) are converted to corresponding Perl constructs.  Thus, &quot;$foo\Qbaz$bar&quot; is converted to &quot;$foo . (quotemeta(&quot;baz&quot; . $bar))&quot; internally. The other escape sequences such as &quot;\200&quot; and &quot;\t&quot; and backslashed characters such as &quot;\\&quot; and &quot;\-&quot; are replaced with appropriate expansions.<div style="height: 1.00em;">
&#160;</div>
Let it be stressed that <i>whatever falls between </i><i>&quot;\Q&quot;</i><i> and </i><i>&quot;\E&quot;</i><i></i> is interpolated in the usual way.  Something like &quot;\Q\\E&quot; has no &quot;\E&quot; inside.  instead, it has &quot;\Q&quot;, &quot;\\&quot;, and &quot;E&quot;, so the result is the same as for &quot;\\\\E&quot;.  As a general rule, backslashes between &quot;\Q&quot; and &quot;\E&quot; may lead to counterintuitive results.  So, &quot;\Q\t\E&quot; is converted to &quot;quotemeta(&quot;\t&quot;)&quot;, which is the same as &quot;\\\t&quot; (since TAB is not alphanumeric).  Note also that:<div style="height: 1.00em;">
&#160;</div>
<br/>
  $str = '\t';<br/>
  return &quot;\Q$str&quot;;<br/>
<div style="height: 1.00em;">
&#160;</div>
may be closer to the conjectural <i>intention</i> of the writer of &quot;\Q\t\E&quot;.<div style="height: 1.00em;">
&#160;</div>
Interpolated scalars and arrays are converted internally to the &quot;join&quot; and &quot;.&quot; catenation operations.  Thus, &quot;$foo XXX '@arr'&quot; becomes:<div style="height: 1.00em;">
&#160;</div>
<br/>
  $foo . &quot; XXX '&quot; . (join $&quot;, @arr) . &quot;'&quot;;<br/>
<div style="height: 1.00em;">
&#160;</div>
All operations above are performed simultaneously, left to right.<div style="height: 1.00em;">
&#160;</div>
Because the result of &quot;\Q STRING \E&quot; has all metacharacters quoted, there is no way to insert a literal &quot;$&quot; or &quot;@&quot; inside a &quot;\Q\E&quot; pair.  If protected by &quot;\&quot;, &quot;$&quot; will be quoted to became &quot;\\\$&quot;; if not, it is interpreted as the start of an interpolated scalar.<div style="height: 1.00em;">
&#160;</div>
Note also that the interpolation code needs to make a decision on where the interpolated scalar ends.  For instance, whether &quot;a $b -&gt; {c}&quot; really means:<div style="height: 1.00em;">
&#160;</div>
<br/>
  &quot;a &quot; . $b . &quot; -&gt; {c}&quot;;<br/>
<div style="height: 1.00em;">
&#160;</div>
or:<div style="height: 1.00em;">
&#160;</div>
<br/>
  &quot;a &quot; . $b -&gt; {c};<br/>
<div style="height: 1.00em;">
&#160;</div>
Most of the time, the longest possible text that does not include spaces between components and which contains matching braces or brackets.  because the outcome may be determined by voting based on heuristic estimators, the result is not strictly predictable. Fortunately, it's usually correct for ambiguous cases.</dd>
</dl>
<dl>
<dt>
the replacement of &quot;s///&quot;</dt>
<dd>
Processing of &quot;\Q&quot;, &quot;\U&quot;, &quot;\u&quot;, &quot;\L&quot;, &quot;\l&quot;, and interpolation happens as with &quot;qq//&quot; constructs.<div style="height: 1.00em;">
&#160;</div>
It is at this step that &quot;\1&quot; is begrudgingly converted to $1 in the replacement text of &quot;s///&quot;, in order to correct the incorrigible  <i>sed</i> hackers who haven't picked up the saner idiom yet.  A warning is emitted if the &quot;use warnings&quot; pragma or the  <b>-w</b> command-line flag (that is, the $^W variable) was set.</dd>
</dl>
<dl>
<dt>
&quot;RE&quot; in &quot;?RE?&quot;, &quot;/RE/&quot;, &quot;m/RE/&quot;, &quot;s/RE/foo/&quot;,</dt>
<dd>
Processing of &quot;\Q&quot;, &quot;\U&quot;, &quot;\u&quot;, &quot;\L&quot;, &quot;\l&quot;, &quot;\E&quot;, and interpolation happens (almost) as with &quot;qq//&quot; constructs.<div style="height: 1.00em;">
&#160;</div>
Processing of &quot;\N{...}&quot; is also done here, and compiled into an intermediate form for the regex compiler.  (This is because, as mentioned below, the regex compilation may be done at execution time, and &quot;\N{...}&quot; is a compile-time construct.)<div style="height: 1.00em;">
&#160;</div>
However any other combinations of &quot;\&quot; followed by a character are not substituted but only skipped, in order to parse them as regular expressions at the following step. As &quot;\c&quot; is skipped at this step, &quot;@&quot; of &quot;\c@&quot; in RE is possibly treated as an array symbol (for example @foo), even though the same text in &quot;qq//&quot; gives interpolation of &quot;\c@&quot;.<div style="height: 1.00em;">
&#160;</div>
Moreover, inside &quot;(?{BLOCK})&quot;, &quot;(?# comment )&quot;, and a &quot;#&quot;-comment in a &quot;//x&quot;-regular expression, no processing is performed whatsoever.  This is the first step at which the presence of the &quot;//x&quot; modifier is relevant.<div style="height: 1.00em;">
&#160;</div>
Interpolation in patterns has several quirks: $|, $(, $), &quot;@+&quot; and &quot;@-&quot; are not interpolated, and constructs $var[SOMETHING] are voted (by several different estimators) to be either an array element or $var followed by an RE alternative.  This is where the notation &quot;${arr[$bar]}&quot; comes handy: &quot;/${arr[0-9]}/&quot; is interpreted as array element &quot;-9&quot;, not as a regular expression from the variable $arr followed by a digit, which would be the interpretation of &quot;/$arr[0-9]/&quot;.  Since voting among different estimators may occur, the result is not predictable.<div style="height: 1.00em;">
&#160;</div>
The lack of processing of &quot;\\&quot; creates specific restrictions on the post-processed text.  If the delimiter is &quot;/&quot;, one cannot get the combination &quot;\/&quot; into the result of this step.  &quot;/&quot; will finish the regular expression, &quot;\/&quot; will be stripped to &quot;/&quot; on the previous step, and &quot;\\/&quot; will be left as is.  Because &quot;/&quot; is equivalent to &quot;\/&quot; inside a regular expression, this does not matter unless the delimiter happens to be character special to the RE engine, such as in &quot;s*foo*bar*&quot;, &quot;m[foo]&quot;, or &quot;?foo?&quot;; or an alphanumeric char, as in:<div style="height: 1.00em;">
&#160;</div>
<br/>
  m m ^ a \s* b mmx;<br/>
<div style="height: 1.00em;">
&#160;</div>
In the RE above, which is intentionally obfuscated for illustration, the delimiter is &quot;m&quot;, the modifier is &quot;mx&quot;, and after delimiter-removal the RE is the same as for &quot;m/ ^ a \s* b /mx&quot;.  There's more than one reason you're encouraged to restrict your delimiters to non-alphanumeric, non-whitespace choices.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">
&#160;</div>
This step is the last one for all constructs except regular expressions, which are processed further.</div>
<dl>
<dt>
parsing regular expressions</dt>
<dd>
Previous steps were performed during the compilation of Perl code, but this one happens at run time, although it may be optimized to be calculated at compile time if appropriate.  After preprocessing described above, and possibly after evaluation if concatenation, joining, casing translation, or metaquoting are involved, the resulting  <i>string</i> is passed to the RE engine for compilation.<div style="height: 1.00em;">
&#160;</div>
Whatever happens in the RE engine might be better discussed in perlre, but for the sake of continuity, we shall do so here.<div style="height: 1.00em;">
&#160;</div>
This is another step where the presence of the &quot;//x&quot; modifier is relevant.  The RE engine scans the string from left to right and converts it to a finite automaton.<div style="height: 1.00em;">
&#160;</div>
Backslashed characters are either replaced with corresponding literal strings (as with &quot;\{&quot;), or else they generate special nodes in the finite automaton (as with &quot;\b&quot;).  Characters special to the RE engine (such as &quot;|&quot;) generate corresponding nodes or groups of nodes.  &quot;(?#...)&quot; comments are ignored.  All the rest is either converted to literal strings to match, or else is ignored (as is whitespace and &quot;#&quot;-style comments if &quot;//x&quot; is present).<div style="height: 1.00em;">
&#160;</div>
Parsing of the bracketed character class construct, &quot;[...]&quot;, is rather different than the rule used for the rest of the pattern. The terminator of this construct is found using the same rules as for finding the terminator of a &quot;{}&quot;-delimited construct, the only exception being that &quot;]&quot; immediately following &quot;[&quot; is treated as though preceded by a backslash.  Similarly, the terminator of &quot;(?{...})&quot; is found using the same rules as for finding the terminator of a &quot;{}&quot;-delimited construct.<div style="height: 1.00em;">
&#160;</div>
It is possible to inspect both the string given to RE engine and the resulting finite automaton.  See the arguments &quot;debug&quot;/&quot;debugcolor&quot; in the &quot;use re&quot; pragma, as well as Perl's  <b>-Dr</b> command-line switch documented in &quot;Command Switches&quot; in perlrun.</dd>
</dl>
<dl>
<dt>
Optimization of regular expressions</dt>
<dd>
This step is listed for completeness only.  Since it does not change semantics, details of this step are not documented and are subject to change without notice.  This step is performed over the finite automaton that was generated during the previous pass.<div style="height: 1.00em;">
&#160;</div>
It is at this stage that &quot;split()&quot; silently optimizes &quot;/^/&quot; to mean &quot;/^/m&quot;.</dd>
</dl>
</div>
<div class="subsection">
<h2>I/O Operators</h2> There are several I/O operators you should know about.<div class="spacer">
</div>
A string enclosed by backticks (grave accents) first undergoes double-quote interpolation.  It is then interpreted as an external command, and the output of that command is the value of the backtick string, like in a shell.  In scalar context, a single string consisting of all output is returned.  In list context, a list of values is returned, one per line of output.  (You can set $/ to use a different line terminator.)  The command is executed each time the pseudo-literal is evaluated.  The status value of the command is returned in $? (see perlvar for the interpretation of $?). Unlike in  <b>csh</b>, no translation is done on the return data--newlines remain newlines.  Unlike in any of the shells, single quotes do not hide variable names in the command from interpretation.  To pass a literal dollar-sign through to the shell you need to hide it with a backslash.  The generalized form of backticks is &quot;qx//&quot;.  (Because backticks always undergo shell expansion as well, see perlsec for security concerns.)<div class="spacer">
</div>
In scalar context, evaluating a filehandle in angle brackets yields the next line from that file (the newline, if any, included), or &quot;undef&quot; at end-of-file or on error.  When $/ is set to &quot;undef&quot; (sometimes known as file-slurp mode) and the file is empty, it returns '' the first time, followed by &quot;undef&quot; subsequently.<div class="spacer">
</div>
Ordinarily you must assign the returned value to a variable, but there is one situation where an automatic assignment happens.  If and only if the input symbol is the only thing inside the conditional of a &quot;while&quot; statement (even if disguised as a &quot;for(;;)&quot; loop), the value is automatically assigned to the global variable $_, destroying whatever was there previously.  (This may seem like an odd thing to you, but you'll use the construct in almost every Perl script you write.)  The $_ variable is not implicitly localized. You'll have to put a &quot;local $_;&quot; before the loop if you want that to happen.<div class="spacer">
</div>
The following lines are equivalent:<div class="spacer">
</div>
<br/>
    while (defined($_ = &lt;STDIN&gt;)) { print; }<br/>
    while ($_ = &lt;STDIN&gt;) { print; }<br/>
    while (&lt;STDIN&gt;) { print; }<br/>
    for (;&lt;STDIN&gt;;) { print; }<br/>
    print while defined($_ = &lt;STDIN&gt;);<br/>
    print while ($_ = &lt;STDIN&gt;);<br/>
    print while &lt;STDIN&gt;;<br/>
<div class="spacer">
</div>
This also behaves similarly, but avoids $_ :<div class="spacer">
</div>
<br/>
    while (my $line = &lt;STDIN&gt;) { print $line }<br/>
<div class="spacer">
</div>
In these loop constructs, the assigned value (whether assignment is automatic or explicit) is then tested to see whether it is defined.  The defined test avoids problems where line has a string value that would be treated as false by Perl, for example a &quot;&quot; or a &quot;0&quot; with no trailing newline.  If you really mean for such values to terminate the loop, they should be tested for explicitly:<div class="spacer">
</div>
<br/>
    while (($_ = &lt;STDIN&gt;) ne '0') { ... }<br/>
    while (&lt;STDIN&gt;) { last unless $_; ... }<br/>
<div class="spacer">
</div>
In other boolean contexts, &quot;&lt;filehandle&gt;&quot; without an explicit &quot;defined&quot; test or comparison elicits a warning if the &quot;use warnings&quot; pragma or the  <b>-w</b> command-line switch (the $^W variable) is in effect.<div class="spacer">
</div>
The filehandles STDIN, STDOUT, and STDERR are predefined.  (The filehandles &quot;stdin&quot;, &quot;stdout&quot;, and &quot;stderr&quot; will also work except in packages, where they would be interpreted as local identifiers rather than global.)  Additional filehandles may be created with the  <i>open()</i> function, amongst others.  See perlopentut and &quot;open&quot; in perlfunc for details on this.<div class="spacer">
</div>
If a &lt;FILEHANDLE&gt; is used in a context that is looking for a list, a list comprising all input lines is returned, one line per list element.  It's easy to grow to a rather large data space this way, so use with care.<div class="spacer">
</div>
&lt;FILEHANDLE&gt; may also be spelled &quot;readline(*FILEHANDLE)&quot;. See &quot;readline&quot; in perlfunc.<div class="spacer">
</div>
The null filehandle &lt;&gt; is special: it can be used to emulate the behavior of  <b>sed</b> and <b>awk</b>.  Input from &lt;&gt; comes either from standard input, or from each file listed on the command line.  Here's how it works: the first time &lt;&gt; is evaluated, the @ARGV array is checked, and if it is empty, $ARGV[0] is set to &quot;-&quot;, which when opened gives you standard input.  The @ARGV array is then processed as a list of filenames.  The loop<div class="spacer">
</div>
<br/>
    while (&lt;&gt;) {<br/>
        ...                     # code for each line<br/>
    }<br/>
<div class="spacer">
</div>
is equivalent to the following Perl-like pseudo code:<div class="spacer">
</div>
<br/>
    unshift(@ARGV, '-') unless @ARGV;<br/>
    while ($ARGV = shift) {<br/>
        open(ARGV, $ARGV);<br/>
        while (&lt;ARGV&gt;) {<br/>
            ...         # code for each line<br/>
        }<br/>
    }<br/>
<div class="spacer">
</div>
except that it isn't so cumbersome to say, and will actually work. It really does shift the @ARGV array and put the current filename into the $ARGV variable.  It also uses filehandle  <i>ARGV</i> internally. &lt;&gt; is just a synonym for &lt;ARGV&gt;, which is magical.  (The pseudo code above doesn't work because it treats &lt;ARGV&gt; as non-magical.)<div class="spacer">
</div>
Since the null filehandle uses the two argument form of &quot;open&quot; in perlfunc it interprets special characters, so if you have a script like this:<div class="spacer">
</div>
<br/>
    while (&lt;&gt;) {<br/>
        print;<br/>
    }<br/>
<div class="spacer">
</div>
and call it with &quot;perl dangerous.pl 'rm -rfv *|'&quot;, it actually opens a pipe, executes the &quot;rm&quot; command and reads &quot;rm&quot;'s output from that pipe. If you want all items in @ARGV to be interpreted as file names, you can use the module &quot;ARGV::readonly&quot; from CPAN.<div class="spacer">
</div>
You can modify @ARGV before the first &lt;&gt; as long as the array ends up containing the list of filenames you really want.  Line numbers ($.) continue as though the input were one big happy file.  See the example in &quot;eof&quot; in perlfunc for how to reset line numbers on each file.<div class="spacer">
</div>
If you want to set @ARGV to your own list of files, go right ahead. This sets @ARGV to all plain text files if no @ARGV was given:<div class="spacer">
</div>
<br/>
    @ARGV = grep { -f &amp;&amp; -T } glob('*') unless @ARGV;<br/>
<div class="spacer">
</div>
You can even set them to pipe commands.  For example, this automatically filters compressed arguments through  <b>gzip</b>:<div class="spacer">
</div>
<br/>
    @ARGV = map { /\.(gz|Z)$/ ? &quot;gzip -dc &lt; $_ |&quot; : $_ } @ARGV;<br/>
<div class="spacer">
</div>
If you want to pass switches into your script, you can use one of the Getopts modules or put a loop on the front like this:<div class="spacer">
</div>
<br/>
    while ($_ = $ARGV[0], /^-/) {<br/>
        shift;<br/>
        last if /^--$/;<br/>
        if (/^-D(.*)/) { $debug = $1 }<br/>
        if (/^-v/)     { $verbose++  }<br/>
        # ...           # other switches<br/>
    }<br/>
<br/>
    while (&lt;&gt;) {<br/>
        # ...           # code for each line<br/>
    }<br/>
<div class="spacer">
</div>
The &lt;&gt; symbol will return &quot;undef&quot; for end-of-file only once. If you call it again after this, it will assume you are processing another @ARGV list, and if you haven't set @ARGV, will read input from STDIN.<div class="spacer">
</div>
If what the angle brackets contain is a simple scalar variable (e.g., &lt;$foo&gt;), then that variable contains the name of the filehandle to input from, or its typeglob, or a reference to the same.  For example:<div class="spacer">
</div>
<br/>
    $fh = \*STDIN;<br/>
    $line = &lt;$fh&gt;;<br/>
<div class="spacer">
</div>
If what's within the angle brackets is neither a filehandle nor a simple scalar variable containing a filehandle name, typeglob, or typeglob reference, it is interpreted as a filename pattern to be globbed, and either a list of filenames or the next filename in the list is returned, depending on context.  This distinction is determined on syntactic grounds alone.  That means &quot;&lt;$x&gt;&quot; is always a  <i>readline()</i> from an indirect handle, but &quot;&lt;$hash{key}&gt;&quot; is always a  <i>glob()</i>. That's because $x is a simple scalar variable, but $hash{key} is not--it's a hash element.  Even &quot;&lt;$x &gt;&quot; (note the extra space) is treated as &quot;glob(&quot;$x &quot;)&quot;, not &quot;readline($x)&quot;.<div class="spacer">
</div>
One level of double-quote interpretation is done first, but you can't say &quot;&lt;$foo&gt;&quot; because that's an indirect filehandle as explained in the previous paragraph.  (In older versions of Perl, programmers would insert curly brackets to force interpretation as a filename glob: &quot;&lt;${foo}&gt;&quot;.  These days, it's considered cleaner to call the internal function directly as &quot;glob($foo)&quot;, which is probably the right way to have done it in the first place.)  For example:<div class="spacer">
</div>
<br/>
    while (&lt;*.c&gt;) {<br/>
        chmod 0644, $_;<br/>
    }<br/>
<div class="spacer">
</div>
is roughly equivalent to:<div class="spacer">
</div>
<br/>
    open(FOO, &quot;echo *.c | tr -s ' \t\r\f' '\\012\\012\\012\\012'|&quot;);<br/>
    while (&lt;FOO&gt;) {<br/>
        chomp;<br/>
        chmod 0644, $_;<br/>
    }<br/>
<div class="spacer">
</div>
except that the globbing is actually done internally using the standard &quot;File::Glob&quot; extension.  Of course, the shortest way to do the above is:<div class="spacer">
</div>
<br/>
    chmod 0644, &lt;*.c&gt;;<br/>
<div class="spacer">
</div>
A (file)glob evaluates its (embedded) argument only when it is starting a new list.  All values must be read before it will start over.  In list context, this isn't important because you automatically get them all anyway.  However, in scalar context the operator returns the next value each time it's called, or &quot;undef&quot; when the list has run out.  As with filehandle reads, an automatic &quot;defined&quot; is generated when the glob occurs in the test part of a &quot;while&quot;, because legal glob returns (e.g. a file called  <i>0</i>) would otherwise terminate the loop.  Again, &quot;undef&quot; is returned only once.  So if you're expecting a single value from a glob, it is much better to say<div class="spacer">
</div>
<br/>
    ($file) = &lt;blurch*&gt;;<br/>
<div class="spacer">
</div>
than<div class="spacer">
</div>
<br/>
    $file = &lt;blurch*&gt;;<br/>
<div class="spacer">
</div>
because the latter will alternate between returning a filename and returning false.<div class="spacer">
</div>
If you're trying to do variable interpolation, it's definitely better to use the  <i>glob()</i> function, because the older notation can cause people to become confused with the indirect filehandle notation.<div class="spacer">
</div>
<br/>
    @files = glob(&quot;$dir/*.[ch]&quot;);<br/>
    @files = glob($files[$i]);<br/>
</div>
<div class="subsection">
<h2>Constant Folding</h2> Like C, Perl does a certain amount of expression evaluation at compile time whenever it determines that all arguments to an operator are static and have no side effects.  In particular, string concatenation happens at compile time between literals that don't do variable substitution.  Backslash interpolation also happens at compile time.  You can say<div class="spacer">
</div>
<br/>
    'Now is the time for all' . &quot;\n&quot; .<br/>
        'good men to come to.'<br/>
<div class="spacer">
</div>
and this all reduces to one string internally.  Likewise, if you say<div class="spacer">
</div>
<br/>
    foreach $file (@filenames) {<br/>
        if (-s $file &gt; 5 + 100 * 2**16) {  }<br/>
    }<br/>
<div class="spacer">
</div>
the compiler will precompute the number which that expression represents so that the interpreter won't have to.</div>
<div class="subsection">
<h2>No-ops</h2> Perl doesn't officially have a no-op operator, but the bare constants 0 and 1 are special-cased to not produce a warning in a void context, so you can for example safely do<div class="spacer">
</div>
<br/>
    1 while foo();<br/>
</div>
<div class="subsection">
<h2>Bitwise String Operators</h2> Bitstrings of any size may be manipulated by the bitwise operators (&quot;~ | &amp; ^&quot;).<div class="spacer">
</div>
If the operands to a binary bitwise op are strings of different sizes,  <b>|</b> and <b>^</b> ops act as though the shorter operand had additional zero bits on the right, while the  <b>&amp;</b> op acts as though the longer operand were truncated to the length of the shorter. The granularity for such extension or truncation is one or more bytes.<div class="spacer">
</div>
<br/>
    # ASCII-based examples<br/>
    print &quot;j p \n&quot; ^ &quot; a h&quot;;            # prints &quot;JAPH\n&quot;<br/>
    print &quot;JA&quot; | &quot;  ph\n&quot;;              # prints &quot;japh\n&quot;<br/>
    print &quot;japh\nJunk&quot; &amp; '_____';       # prints &quot;JAPH\n&quot;;<br/>
    print 'p N$' ^ &quot; E&lt;H\n&quot;;            # prints &quot;Perl\n&quot;;<br/>
<div class="spacer">
</div>
If you are intending to manipulate bitstrings, be certain that you're supplying bitstrings: If an operand is a number, that will imply a  <b>numeric</b> bitwise operation.  You may explicitly show which type of operation you intend by using &quot;&quot; or &quot;0+&quot;, as in the examples below.<div class="spacer">
</div>
<br/>
    $foo =  150  |  105;        # yields 255  (0x96 | 0x69 is 0xFF)<br/>
    $foo = '150' |  105;        # yields 255<br/>
    $foo =  150  | '105';       # yields 255<br/>
    $foo = '150' | '105';       # yields string '155' (under ASCII)<br/>
<br/>
    $baz = 0+$foo &amp; 0+$bar;     # both ops explicitly numeric<br/>
    $biz = &quot;$foo&quot; ^ &quot;$bar&quot;;     # both ops explicitly stringy<br/>
<div class="spacer">
</div>
See &quot;vec&quot; in perlfunc for information on how to manipulate individual bits in a bit vector.</div>
<div class="subsection">
<h2>Integer Arithmetic</h2> By default, Perl assumes that it must do most of its arithmetic in floating point.  But by saying<div class="spacer">
</div>
<br/>
    use integer;<br/>
<div class="spacer">
</div>
you may tell the compiler to use integer operations (see integer for a detailed explanation) from here to the end of the enclosing BLOCK.  An inner BLOCK may countermand this by saying<div class="spacer">
</div>
<br/>
    no integer;<br/>
<div class="spacer">
</div>
which lasts until the end of that BLOCK.  Note that this doesn't mean everything is an integer, merely that Perl will use integer operations for arithmetic, comparison, and bitwise operators.  For example, even under &quot;use integer&quot;, if you take the sqrt(2), you'll still get 1.4142135623731 or so.<div class="spacer">
</div>
Used on numbers, the bitwise operators (&quot;&amp;&quot;, &quot;|&quot;, &quot;^&quot;, &quot;~&quot;, &quot;&lt;&lt;&quot;, and &quot;&gt;&gt;&quot;) always produce integral results.  (But see also &quot;Bitwise String Operators&quot;.)  However, &quot;use integer&quot; still has meaning for them.  By default, their results are interpreted as unsigned integers, but if &quot;use integer&quot; is in effect, their results are interpreted as signed integers.  For example, &quot;~0&quot; usually evaluates to a large integral value.  However, &quot;use integer; ~0&quot; is &quot;-1&quot; on two's-complement machines.</div>
<div class="subsection">
<h2>Floating-point Arithmetic</h2> While &quot;use integer&quot; provides integer-only arithmetic, there is no analogous mechanism to provide automatic rounding or truncation to a certain number of decimal places.  For rounding to a certain number of digits,  <i>sprintf()</i> or <i>printf()</i> is usually the easiest route. See perlfaq4.<div class="spacer">
</div>
Floating-point numbers are only approximations to what a mathematician would call real numbers.  There are infinitely more reals than floats, so some corners must be cut.  For example:<div class="spacer">
</div>
<br/>
    printf &quot;%.20g\n&quot;, 123456789123456789;<br/>
    #        produces 123456789123456784<br/>
<div class="spacer">
</div>
Testing for exact floating-point equality or inequality is not a good idea.  Here's a (relatively expensive) work-around to compare whether two floating-point numbers are equal to a particular number of decimal places.  See Knuth, volume II, for a more robust treatment of this topic.<div class="spacer">
</div>
<br/>
    sub fp_equal {<br/>
        my ($X, $Y, $POINTS) = @_;<br/>
        my ($tX, $tY);<br/>
        $tX = sprintf(&quot;%.${POINTS}g&quot;, $X);<br/>
        $tY = sprintf(&quot;%.${POINTS}g&quot;, $Y);<br/>
        return $tX eq $tY;<br/>
    }<br/>
<div class="spacer">
</div>
The POSIX module (part of the standard perl distribution) implements  <i>ceil()</i>, <i>floor()</i>, and other mathematical and trigonometric functions. The Math::Complex module (part of the standard perl distribution) defines mathematical functions that work on both the reals and the imaginary numbers.  Math::Complex not as efficient as POSIX, but POSIX can't work with complex numbers.<div class="spacer">
</div>
Rounding in financial applications can have serious implications, and the rounding method used should be specified precisely.  In these cases, it probably pays not to trust whichever system rounding is being used by Perl, but to instead implement the rounding function you need yourself.</div>
<div class="subsection">
<h2>Bigger Numbers</h2> The standard &quot;Math::BigInt&quot;, &quot;Math::BigRat&quot;, and &quot;Math::BigFloat&quot; modules, along with the &quot;bigint&quot;, &quot;bigrat&quot;, and &quot;bitfloat&quot; pragmas, provide variable-precision arithmetic and overloaded operators, although they're currently pretty slow. At the cost of some space and considerable speed, they avoid the normal pitfalls associated with limited-precision representations.<div class="spacer">
</div>
<br/>
        use 5.010;<br/>
        use bigint;  # easy interface to Math::BigInt<br/>
        $x = 123456789123456789;<br/>
        say $x * $x;<br/>
    +15241578780673678515622620750190521<br/>
<div class="spacer">
</div>
Or with rationals:<div class="spacer">
</div>
<br/>
        use 5.010;<br/>
        use bigrat;<br/>
        $a = 3/22;<br/>
        $b = 4/6;<br/>
        say &quot;a/b is &quot;, $a/$b;<br/>
        say &quot;a*b is &quot;, $a*$b;<br/>
    a/b is 9/44<br/>
    a*b is 1/11<br/>
<div class="spacer">
</div>
Several modules let you calculate with (bound only by memory and CPU time) unlimited or fixed precision. There are also some non-standard modules that provide faster implementations via external C libraries.<div class="spacer">
</div>
Here is a short, but incomplete summary:<div class="spacer">
</div>
<br/>
  Math::Fraction         big, unlimited fractions like 9973 / 12967<br/>
  Math::String           treat string sequences like numbers<br/>
  Math::FixedPrecision   calculate with a fixed precision<br/>
  Math::Currency         for currency calculations<br/>
  Bit::Vector            manipulate bit vectors fast (uses C)<br/>
  Math::BigIntFast       Bit::Vector wrapper for big numbers<br/>
  Math::Pari             provides access to the Pari C library<br/>
  Math::BigInteger       uses an external C library<br/>
  Math::Cephes           uses external Cephes C library (no big numbers)<br/>
  Math::Cephes::Fraction fractions via the Cephes library<br/>
  Math::GMP              another one using an external C library<br/>
<div class="spacer">
</div>
Choose wisely.</div>
</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-09-26</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

