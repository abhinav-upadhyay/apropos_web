<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
IRB1.8(1)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
IRB1.8(1)</td>
<td class="head-vol">
General Commands Manual</td>
<td class="head-rtitle">
IRB1.8(1)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> irb1.8 - interactive ruby</div>
<div class="section">
<h1>SYNOPSIS</h1> <b>irb</b> [ <i>options</i>]</div>
<div class="section">
<h1>DESCRIPTION</h1> irb stands for `interactive ruby'. irb is a tool to execute interactively ruby expressions read from stdin. Use of irb is easy if you know ruby.  Executing irb, prompts are displayed as follows. Then, enter expression of ruby. A input is executed when it is syntacticaly completed.<div style="height: 1.00em;">
&#160;</div>
<br/>
    $ irb1.8<br/>
    irb(main):001:0&gt; 1+2<br/>
    3<br/>
    irb(main):002:0&gt; class Foo<br/>
    irb(main):003:1&gt;  def foo<br/>
    irb(main):004:2&gt;    print 1<br/>
    irb(main):005:2&gt;  end<br/>
    irb(main):006:1&gt; end<br/>
    nil<br/>
    irb(main):007:0&gt; <br/>
<div style="height: 1.00em;">
&#160;</div>
And, Readline extesion module can be used with irb. Using Readline is the standard default action if Readline is installed.</div>
<div class="section">
<h1>OPTIONS</h1><div style="height: 1.00em;">
&#160;</div>
<br/>
<b>-f</b> suppress read ~/.irbrc<br/>
<b>-m</b> bc mode (fraction or matrix are available)<br/>
<b>-d</b> set $DEBUG  to true (same as `ruby -d')<br/>
<b>-r load-module</b> same as `ruby -r'<br/>
<b>--inspect</b> uses `inspect' for output (the default except bc mode)<br/>
<b>--noinspect</b> doesn't uses inspect for output<br/>
<b>--readline</b> uses Readline extension module<br/>
<b>--noreadline</b> doesn't use Readline extension module<br/>
<b>--prompt prompt-mode</b><br/>
<b>--prompt-mode prompt-mode</b> switches prompt mode. Pre-defined prompt modes are `default', `simple', `xmp' and `inf-ruby'<br/>
<b>--inf-ruby-mode</b> uses prompt appreciate for inf-ruby-mode on emacs. Suppresses --readline.<br/>
<b>--simple-prompt</b> simple prompt mode<br/>
<b>--noprompt</b> no prompt<br/>
<b>--tracer</b> display trace for each execution of commands.<br/>
<b>--back-trace-limit n</b> displayes backtrace top n and tail n. The default value is 16.<br/>
<b>--irb_debug n</b> sets internal debug level to n (It shouldn't be used)<br/>
<b>-v, --version</b> prints the version of irb</div>
<div class="section">
<h1>CONFIGURATIONS</h1> irb reads `~/.irbrc' when it is invoked. If `~/.irbrb' doesn't exist irb try to read in the order `.irbrc', `irb.rc', `_irbrc' then `$irbrc'. The following is altanative to the command line option. To use them type as follows in an irb session.<div style="height: 1.00em;">
&#160;</div>
<br/>
    IRB.conf[:IRB_NAME]=&quot;irb&quot;<br/>
    IRB.conf[:MATH_MODE]=false<br/>
    IRB.conf[:USE_TRACER]=false<br/>
    IRB.conf[:USE_LOADER]=false<br/>
    IRB.conf[:IGNORE_SIGINT]=true<br/>
    IRB.conf[:IGNORE_EOF]=false<br/>
    IRB.conf[:INSPECT_MODE]=nil<br/>
    IRB.conf[:IRB_RC] = nil<br/>
    IRB.conf[:BACK_TRACE_LIMIT]=16<br/>
    IRB.conf[:USE_LOADER] = false<br/>
    IRB.conf[:USE_READLINE] = nil<br/>
    IRB.conf[:USE_TRACER] = false<br/>
    IRB.conf[:IGNORE_SIGINT] = true<br/>
    IRB.conf[:IGNORE_EOF] = false<br/>
    IRB.conf[:PROMPT_MODE] = :DEFALUT<br/>
    IRB.conf[:PROMPT] = {...}<br/>
    IRB.conf[:DEBUG_LEVEL]=0<br/>
    IRB.conf[:VERBOSE]=true<br/>
</div>
<div class="section">
<h1>Customizing prompt</h1> To costomize the prompt you set a variable<div style="height: 1.00em;">
&#160;</div>
<br/>
    IRB.conf[:PROMPT]<br/>
<div style="height: 1.00em;">
&#160;</div>
For example, describe as follows in `.irbrc'.<div style="height: 1.00em;">
&#160;</div>
<br/>
    IRB.conf[:PROMPT][:MY_PROMPT] = { # name of prompt mode<br/>
      :PROMPT_I =&gt; nil,		  # normal prompt<br/>
      :PROMPT_S =&gt; nil,		  # prompt for continuated strings<br/>
      :PROMPT_C =&gt; nil,		  # prompt for continuated statement<br/>
      :RETURN =&gt; &quot;    ==&gt;%s\n&quot;	  # format to return value<br/>
    }<br/>
<div style="height: 1.00em;">
&#160;</div>
Then, invoke irb with the above prompt mode by<div style="height: 1.00em;">
&#160;</div>
<br/>
    $ irb1.8 --prompt my-prompt<br/>
<div style="height: 1.00em;">
&#160;</div>
Or add the following in `.irbrc'.<div style="height: 1.00em;">
&#160;</div>
<br/>
    IRB.conf[:PROMPT_MODE] = :MY_PROMPT<br/>
<div style="height: 1.00em;">
&#160;</div>
Constants PROMPT_I, PROMPT_S and PROMPT_C specifies the format. In the prompt specification, some special strings are available.<div style="height: 1.00em;">
&#160;</div>
<br/>
    %N	command name which is running<br/>
    %m	to_s of main object (self)<br/>
    %M	inspect of main object (self)<br/>
    %l	type of string(&quot;, ', /, ]), `]' is inner %w[...]<br/>
    %NNi	indent level. NN is degits and means as same as printf(&quot;%NNd&quot;). <br/>
          It can be ommited<br/>
    %NNn	line number. <br/>
    %%    %<br/>
For instance, the default prompt mode is defined as follows: IRB.conf[:PROMPT_MODE][:DEFAULT] = {<br/>
<b>PROMPT_I =&gt; &quot;%N(%m):%03n:%i&gt; &quot;,</b><br/>
<b>PROMPT_S =&gt; &quot;%N(%m):%03n:%i%l &quot;,</b><br/>
<b>PROMPT_C =&gt; &quot;%N(%m):%03n:%i* &quot;,</b><br/>
<b>RETURN =&gt; &quot;%s\n&quot;}</b> RETURN is used to printf.</div>
<div class="section">
<h1>Configurating subirb</h1> The command line option or IRB.conf specify the default behavior of (sub)irb. On the other hand, each conf of in the next sction `6. Command' is used to individually configurate (sub)irb. If proc is set to IRB.conf[:IRB_RC], its subirb will be invoked after execution of that proc under giving the context of irb as its aregument. By this mechanism each subirb can be configurated.</div>
<div class="section">
<h1>Command</h1> For irb commands, both simple name and `irb_'-prefixed name are prepared.<br/>
<b>exit, quit, irb_exit</b> Quits (sub)irb. if you've done cb (see below), exit from the binding mode.<div style="height: 1.00em;">
&#160;</div>
<br/>
<b>conf, irb_context</b> Displays current configuration. Modifing the configuration is achieved by sending message to `conf'.<br/>
<b>conf.back_trace_limit</b> Sets display lines of backtrace as top n and tail n. The default value is 16.<br/>
<b>conf.debug_level = N</b> Sets debug level of irb.<br/>
<b>conf.ignore_eof = true/false</b> Whether ^D (control-d) will be ignored or not. If false is set, ^D means quit.<br/>
<b>conf.ignore_sigint= true/false</b> Whether ^C (control-c) will be ignored or not. If false is set, ^D means quit.  If true,<br/>
    during input:   cancel inputing then return to top level. <br/>
    during execute: abondon current execution. <br/>
<br/>
<b>conf.inf_ruby_mode = true/false</b> Whether inf-ruby-mode or not. The default value is false.<br/>
<b>conf.inspect_mode = true/false/nil</b> Specifies inspect mode. true:  display inspect false: display to_s nil:   inspect mode in non math mode,<br/>
    non inspect mode in math mode. <br/>
<br/>
<b>conf.irb_level</b> The level of cb.<br/>
<b>conf.math_mode</b> Whether bc mode or not.<br/>
<b>conf.use_loader = true/false</b> Whether irb's own file reader method is used when load/require or not. This mode is globaly affected (irb wide).<br/>
<b>conf.prompt_c</b> prompt for a continuating statement (e.g, immediately after of `if')<br/>
<b>conf.prompt_i</b> standard prompt<br/>
<b>conf.prompt_s</b> prompt for a continuating string<br/>
<b>conf.rc</b> Whether ~/.irbrc is read or not.<br/>
<b>conf.use_prompt = true/false</b> Prompting or not.<br/>
<b>conf.use_readline = true/false/nil</b> Whether readline is used or not. true: uses false: doen't use nil: intends to use readline except for inf-reuby-mode (default)<br/>
<b>conf.verbose=T/F</b> Whether verbose messages are display or not.<br/>
<b>cb, irb_change_binding [obj]</b> Enter new binding which has a distinct scope of local variables. If obj is given, obj will be self.<br/>
<b>irb [obj]</b> Invoke subirb. If obj is given, obj will be self.<br/>
<b>jobs, irb_jobs</b> List of subirb<br/>
<b>fg n, irb_fg n</b> Switch into specified subirb. The following is candidates of n:<br/>
    irb number<br/>
    thhread<br/>
    irb object<br/>
    self(obj which is specified of irb obj)<br/>
<br/>
<b>kill n, irb_kill n</b> Kill subirb. The means of n is as same as the case of irb_fg.</div>
<div class="section">
<h1>System variable</h1><div style="height: 1.00em;">
&#160;</div>
<br/>
<b>_</b> The latest value of evaluation (it is local)</div>
<div class="section">
<h1>Session Example</h1><br/>
    $ irb1.8<br/>
    irb(main):001:0&gt; irb                        # invoke subirb<br/>
    irb#1(main):001:0&gt; jobs                     # list of subirbs<br/>
    #0-&gt;irb on main (#&lt;Thread:0x400fb7e4&gt; : stop)<br/>
    #1-&gt;irb#1 on main (#&lt;Thread:0x40125d64&gt; : running)<br/>
    nil<br/>
    irb#1(main):002:0&gt; fg 0                     # switch job<br/>
    nil<br/>
    irb(main):002:0&gt; class Foo;end<br/>
    nil<br/>
    irb(main):003:0&gt; irb Foo                    # invoke subirb which has the <br/>
<br/>
    #              context of Foo<br/>
<br/>
    irb#2(Foo):001:0&gt; def foo                   # define Foo#foo<br/>
    irb#2(Foo):002:1&gt;   print 1<br/>
    irb#2(Foo):003:1&gt; end<br/>
    nil<br/>
    irb#2(Foo):004:0&gt; fg 0                      # switch job<br/>
    nil<br/>
    irb(main):004:0&gt; jobs                       # list of job<br/>
    #0-&gt;irb on main (#&lt;Thread:0x400fb7e4&gt; : running)<br/>
    #1-&gt;irb#1 on main (#&lt;Thread:0x40125d64&gt; : stop)<br/>
    #2-&gt;irb#2 on Foo (#&lt;Thread:0x4011d54c&gt; : stop)<br/>
    nil<br/>
    irb(main):005:0&gt; Foo.instance_methods       # Foo#foo is defined asurely<br/>
    [&quot;foo&quot;]<br/>
    irb(main):006:0&gt; fg 2                       # switch job<br/>
    nil<br/>
    irb#2(Foo):005:0&gt; def bar                   # define Foo#bar<br/>
    irb#2(Foo):006:1&gt;  print &quot;bar&quot;<br/>
    irb#2(Foo):007:1&gt; end<br/>
    nil<br/>
    irb#2(Foo):010:0&gt;  Foo.instance_methods<br/>
    [&quot;bar&quot;, &quot;foo&quot;]<br/>
    irb#2(Foo):011:0&gt; fg 0                      <br/>
    nil<br/>
    irb(main):007:0&gt; f = Foo.new<br/>
    #&lt;Foo:0x4010af3c&gt;<br/>
    irb(main):008:0&gt; irb f                      # invoke subirb which has the<br/>
<br/>
    #  context of f (instance of Foo)<br/>
<br/>
    irb#3(#&lt;Foo:0x4010af3c&gt;):001:0&gt; jobs<br/>
    #0-&gt;irb on main (#&lt;Thread:0x400fb7e4&gt; : stop)<br/>
    #1-&gt;irb#1 on main (#&lt;Thread:0x40125d64&gt; : stop)<br/>
    #2-&gt;irb#2 on Foo (#&lt;Thread:0x4011d54c&gt; : stop)<br/>
    #3-&gt;irb#3 on #&lt;Foo:0x4010af3c&gt; (#&lt;Thread:0x4010a1e0&gt; : running)<br/>
    nil<br/>
    irb#3(#&lt;Foo:0x4010af3c&gt;):002:0&gt; foo         # evaluate f.foo<br/>
    1nil<br/>
    irb#3(#&lt;Foo:0x4010af3c&gt;):003:0&gt; bar         # evaluate f.bar<br/>
    barnil<br/>
    irb#3(#&lt;Foo:0x4010af3c&gt;):004:0&gt; kill 1, 2, 3# kill job<br/>
    nil<br/>
    irb(main):009:0&gt; jobs<br/>
    #0-&gt;irb on main (#&lt;Thread:0x400fb7e4&gt; : running)<br/>
    nil<br/>
    irb(main):010:0&gt; exit                       # exit<br/>
</div>
<div class="section">
<h1>Restrictions</h1> Because irb evaluates the inputs immediately after the imput is syntactically completed, irb gives slight different result than directly use ruby. Known difference is pointed out here.</div>
<div class="section">
<h1>Declaration of the local variable</h1> The following causes an error in ruby:<div style="height: 1.00em;">
&#160;</div>
<br/>
    eval &quot;foo = 0&quot;<br/>
    foo<br/>
    --<br/>
    -:2: undefined local variable or method `foo' for #&lt;Object:0x40283118&gt; (NameError)<br/>
    ---<br/>
    NameError<br/>
<div style="height: 1.00em;">
&#160;</div>
Though, the above will successfully done by irb.<div style="height: 1.00em;">
&#160;</div>
<br/>
    &gt;&gt; eval &quot;foo = 0&quot;<br/>
<br/>
    =&gt; 0<br/>
    &gt;&gt; foo<br/>
    =&gt; 0<br/>
<div style="height: 1.00em;">
&#160;</div>
Ruby evaluates a code after reading entire of code and determination of the scope of local variables. On the other hand, irb do immediately. More precisely, irb evaluate at first<div style="height: 1.00em;">
&#160;</div>
<br/>
    evel &quot;foo = 0&quot; <br/>
<div style="height: 1.00em;">
&#160;</div>
then foo is defined on this timing. It is because of this incompatibility. If you'd like to detect those differences, begin...end can be used:<div style="height: 1.00em;">
&#160;</div>
<br/>
    &gt;&gt; begin<br/>
    ?&gt;   eval &quot;foo = 0&quot;<br/>
    &gt;&gt;   foo<br/>
    &gt;&gt; end<br/>
    NameError: undefined local variable or method `foo' for #&lt;Object:0x4013d0f0&gt;<br/>
    (irb):3<br/>
    (irb_local_binding):1:in `eval'<br/>
</div>
<div class="section">
<h1>Here-document</h1> Implementation of Here-document is incomplete.</div>
<div class="section">
<h1>Symbol</h1> Irb can not always recognize a symbol as to be Symbol. Concretely, an expression have completed, however Irb regard it as continuation line.<div style="height: 1.00em;">
&#160;</div>
</div>
<table class="foot">
<tr>
<td class="foot-date">
December 2002</td>
<td class="foot-os">
</td>
</tr>
</table>
</div>
</body>
</html>

