<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
AVPROBE(1)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
AVPROBE(1)</td>
<td class="head-vol">
 </td>
<td class="head-rtitle">
AVPROBE(1)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> avprobe - avprobe media prober</div>
<div class="section">
<h1>SYNOPSIS</h1> avprobe [options] [ <i>input_file</i>]</div>
<div class="section">
<h1>DESCRIPTION</h1> avprobe gathers information from multimedia streams and prints it in human- and machine-readable fashion.<div class="spacer">
</div>
For example it can be used to check the format of the container used by a multimedia stream and the format and type of each media stream contained in it.<div class="spacer">
</div>
If a filename is specified in input, avprobe will try to open and probe the file content. If the file cannot be opened or recognized as a multimedia file, a positive exit code is returned.<div class="spacer">
</div>
avprobe may be employed both as a standalone application or in combination with a textual filter, which may perform more sophisticated processing, e.g. statistical processing or plotting.<div class="spacer">
</div>
Options are used to list some of the formats supported by avprobe or for specifying which information to display, and for setting how avprobe will show it.<div class="spacer">
</div>
avprobe output is designed to be easily parsable by a textual filter, and consists of one or more sections of the form:<div class="spacer">
</div>
<br/>
        [SECTION]<br/>
        key1=val1<br/>
        ...<br/>
        keyN=valN<br/>
        [/SECTION]<br/>
<div class="spacer">
</div>
Metadata tags stored in the container or in the streams are recognized and printed in the corresponding &quot;FORMAT&quot; or &quot;STREAM&quot; section, and are prefixed by the string &quot;TAG:&quot;.</div>
<div class="section">
<h1>OPTIONS</h1> All the numerical options, if not specified otherwise, accept in input a string representing a number, which may contain one of the International System number postfixes, for example 'K', 'M', 'G'. If 'i' is appended after the postfix, powers of 2 are used instead of powers of 10. The 'B' postfix multiplies the value for 8, and can be appended after another postfix or used alone. This allows using for example 'KB', 'MiB', 'G' and 'B' as postfix.<div class="spacer">
</div>
Options which do not take arguments are boolean options, and set the corresponding value to true. They can be set to false by prefixing with &quot;no&quot; the option name, for example using &quot;-nofoo&quot; in the command line will set to false the boolean option with name &quot;foo&quot;.<div class="subsection">
<h2>Stream specifiers</h2> Some options are applied per-stream, e.g. bitrate or codec. Stream specifiers are used to precisely specify which stream(s) does a given option belong to.<div class="spacer">
</div>
A stream specifier is a string generally appended to the option name and separated from it by a colon. E.g. &quot;-codec:a:1 ac3&quot; option contains &quot;a:1&quot; stream specifer, which matches the second audio stream. Therefore it would select the ac3 codec for the second audio stream.<div class="spacer">
</div>
A stream specifier can match several stream, the option is then applied to all of them. E.g. the stream specifier in &quot;-b:a 128k&quot; matches all audio streams.<div class="spacer">
</div>
An empty stream specifier matches all streams, for example &quot;-codec copy&quot; or &quot;-codec: copy&quot; would copy all the streams without reencoding.<div class="spacer">
</div>
Possible forms of stream specifiers are:<dl>
<dt>
<i>stream_index</i></dt>
<dd>
Matches the stream with this index. E.g. &quot;-threads:1 4&quot; would set the thread count for the second stream to 4.</dd>
</dl>
<dl>
<dt>
<i>stream_type</i><b>[:</b><i>stream_index</i><b>]</b></dt>
<dd>
<i>stream_type</i> is one of: 'v' for video, 'a' for audio, 's' for subtitle, 'd' for data and 't' for attachments. If  <i>stream_index</i> is given, then matches stream number  <i>stream_index</i> of this type. Otherwise matches all streams of this type.</dd>
</dl>
<dl>
<dt>
<b>p:</b><i>program_id</i><b>[:</b><i>stream_index</i><b>]</b></dt>
<dd>
If <i>stream_index</i> is given, then matches stream number <i>stream_index</i> in program with id  <i>program_id</i>. Otherwise matches all streams in this program.</dd>
</dl>
</div>
<div class="subsection">
<h2>Generic options</h2> These options are shared amongst the av* tools.<dl>
<dt>
<b>-L</b></dt>
<dd>
Show license.</dd>
</dl>
<dl>
<dt>
<b>-h, -?, -help, --help</b></dt>
<dd>
Show help.</dd>
</dl>
<dl>
<dt>
<b>-version</b></dt>
<dd>
Show version.</dd>
</dl>
<dl>
<dt>
<b>-formats</b></dt>
<dd>
Show available formats.<div style="height: 1.00em;">
&#160;</div>
The fields preceding the format names have the following meanings:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
<b>D</b></dt>
<dd>
Decoding available</dd>
</dl>
<dl>
<dt>
<b>E</b></dt>
<dd>
Encoding available</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
</div>
<dl>
<dt>
<b>-codecs</b></dt>
<dd>
Show available codecs.<div style="height: 1.00em;">
&#160;</div>
The fields preceding the codec names have the following meanings:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
<b>D</b></dt>
<dd>
Decoding available</dd>
</dl>
<dl>
<dt>
<b>E</b></dt>
<dd>
Encoding available</dd>
</dl>
<dl>
<dt>
<b>V/A/S</b></dt>
<dd>
Video/audio/subtitle codec</dd>
</dl>
<dl>
<dt>
<b>S</b></dt>
<dd>
Codec supports slices</dd>
</dl>
<dl>
<dt>
<b>D</b></dt>
<dd>
Codec supports direct rendering</dd>
</dl>
<dl>
<dt>
<b>T</b></dt>
<dd>
Codec can handle input truncated at random locations instead of only at frame boundaries</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
</div>
<dl>
<dt>
<b>-bsfs</b></dt>
<dd>
Show available bitstream filters.</dd>
</dl>
<dl>
<dt>
<b>-protocols</b></dt>
<dd>
Show available protocols.</dd>
</dl>
<dl>
<dt>
<b>-filters</b></dt>
<dd>
Show available libavfilter filters.</dd>
</dl>
<dl>
<dt>
<b>-pix_fmts</b></dt>
<dd>
Show available pixel formats.</dd>
</dl>
<dl>
<dt>
<b>-sample_fmts</b></dt>
<dd>
Show available sample formats.</dd>
</dl>
<dl>
<dt>
<b>-loglevel</b> <i>loglevel</i> <b>| -v</b> <i>loglevel</i></dt>
<dd>
Set the logging level used by the library.  <i>loglevel</i> is a number or a string containing one of the following values:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
<b>quiet</b></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<b>panic</b></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<b>fatal</b></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<b>error</b></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<b>warning</b></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<b>info</b></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<b>verbose</b></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<b>debug</b></dt>
<dd>
</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">
&#160;</div>
By default the program logs to stderr, if coloring is supported by the terminal, colors are used to mark errors and warnings. Log coloring can be disabled setting the environment variable  <b>AV_LOG_FORCE_NOCOLOR</b> or <b>NO_COLOR</b>, or can be forced setting the environment variable  <b>AV_LOG_FORCE_COLOR</b>. The use of the environment variable  <b>NO_COLOR</b> is deprecated and will be dropped in a following Libav version.</div>
</div>
<div class="subsection">
<h2>AVOptions</h2> These options are provided directly by the libavformat, libavdevice and libavcodec libraries. To see the list of available AVOptions, use the  <b>-help</b> option. They are separated into two categories:<dl>
<dt>
<b>generic</b></dt>
<dd>
These options can be set for any container, codec or device. Generic options are listed under AVFormatContext options for containers/devices and under AVCodecContext options for codecs.</dd>
</dl>
<dl>
<dt>
<b>private</b></dt>
<dd>
These options are specific to the given container, device or codec. Private options are listed under their corresponding containers/devices/codecs.</dd>
</dl>
<div class="spacer">
</div>
For example to write an ID3v2.3 header instead of a default ID3v2.4 to an MP3 file, use the  <b>id3v2_version</b> private option of the MP3 muxer:<div class="spacer">
</div>
<br/>
        avconv -i input.flac -id3v2_version 3 out.mp3<br/>
<div class="spacer">
</div>
All codec AVOptions are obviously per-stream, so the chapter on stream specifiers applies to them<div class="spacer">
</div>
Note <b>-nooption</b> syntax cannot be used for boolean AVOptions, use  <b>-option 0</b>/<b>-option 1</b>.<div class="spacer">
</div>
Note2 old undocumented way of specifying per-stream AVOptions by prepending v/a/s to the options name is now obsolete and will be removed soon.</div>
<div class="subsection">
<h2>Main options</h2><dl>
<dt>
<b>-f</b> <i>format</i></dt>
<dd>
Force format to use.</dd>
</dl>
<dl>
<dt>
<b>-unit</b></dt>
<dd>
Show the unit of the displayed values.</dd>
</dl>
<dl>
<dt>
<b>-prefix</b></dt>
<dd>
Use SI prefixes for the displayed values. Unless the &quot;-byte_binary_prefix&quot; option is used all the prefixes are decimal.</dd>
</dl>
<dl>
<dt>
<b>-byte_binary_prefix</b></dt>
<dd>
Force the use of binary prefixes for byte values.</dd>
</dl>
<dl>
<dt>
<b>-sexagesimal</b></dt>
<dd>
Use sexagesimal format HH:MM:SS.MICROSECONDS for time values.</dd>
</dl>
<dl>
<dt>
<b>-pretty</b></dt>
<dd>
Prettify the format of the displayed values, it corresponds to the options &quot;-unit -prefix -byte_binary_prefix -sexagesimal&quot;.</dd>
</dl>
<dl>
<dt>
<b>-show_format</b></dt>
<dd>
Show information about the container format of the input multimedia stream.<div style="height: 1.00em;">
&#160;</div>
All the container format information is printed within a section with name &quot;FORMAT&quot;.</dd>
</dl>
<dl>
<dt>
<b>-show_packets</b></dt>
<dd>
Show information about each packet contained in the input multimedia stream.<div style="height: 1.00em;">
&#160;</div>
The information for each single packet is printed within a dedicated section with name &quot;PACKET&quot;.</dd>
</dl>
<dl>
<dt>
<b>-show_streams</b></dt>
<dd>
Show information about each media stream contained in the input multimedia stream.<div style="height: 1.00em;">
&#160;</div>
Each media stream information is printed within a dedicated section with name &quot;STREAM&quot;.</dd>
</dl>
</div>
</div>
<div class="section">
<h1>DEMUXERS</h1> Demuxers are configured elements in Libav which allow to read the multimedia streams from a particular type of file.<div class="spacer">
</div>
When you configure your Libav build, all the supported demuxers are enabled by default. You can list all available ones using the configure option &quot;--list-demuxers&quot;.<div class="spacer">
</div>
You can disable all the demuxers using the configure option &quot;--disable-demuxers&quot;, and selectively enable a single demuxer with the option &quot;--enable-demuxer= <i>DEMUXER</i>&quot;, or disable it with the option &quot;--disable-demuxer= <i>DEMUXER</i>&quot;.<div class="spacer">
</div>
The option &quot;-formats&quot; of the av* tools will display the list of enabled demuxers.<div class="spacer">
</div>
The description of some of the currently available demuxers follows.<div class="subsection">
<h2>image2</h2> Image file demuxer.<div class="spacer">
</div>
This demuxer reads from a list of image files specified by a pattern.<div class="spacer">
</div>
The pattern may contain the string &quot;%d&quot; or &quot;%0<i>N</i>d&quot;, which specifies the position of the characters representing a sequential number in each filename matched by the pattern. If the form &quot;%d0 <i>N</i>d&quot; is used, the string representing the number in each filename is 0-padded and  <i>N</i> is the total number of 0-padded digits representing the number. The literal character '%' can be specified in the pattern with the string &quot;%%&quot;.<div class="spacer">
</div>
If the pattern contains &quot;%d&quot; or &quot;%0<i>N</i>d&quot;, the first filename of the file list specified by the pattern must contain a number inclusively contained between 0 and 4, all the following numbers must be sequential. This limitation may be hopefully fixed.<div class="spacer">
</div>
The pattern may contain a suffix which is used to automatically determine the format of the images contained in the files.<div class="spacer">
</div>
For example the pattern &quot;img-%03d.bmp&quot; will match a sequence of filenames of the form  <i>img-001.bmp</i>, <i>img-002.bmp</i>, ...,  <i>img-010.bmp</i>, etc.; the pattern &quot;i%%m%%g-%d.jpg&quot; will match a sequence of filenames of the form  <i>i%m%g-1.jpg</i>,  <i>i%m%g-2.jpg</i>, ..., <i>i%m%g-10.jpg</i>, etc.<div class="spacer">
</div>
The size, the pixel format, and the format of each image must be the same for all the files in the sequence.<div class="spacer">
</div>
The following example shows how to use <b>avconv</b> for creating a video from the images in the file sequence  <i>img-001.jpeg</i>,  <i>img-002.jpeg</i>, ..., assuming an input framerate of 10 frames per second:<div class="spacer">
</div>
<br/>
        avconv -i 'img-%03d.jpeg' -r 10 out.mkv<br/>
<div class="spacer">
</div>
Note that the pattern must not necessarily contain &quot;%d&quot; or &quot;%0 <i>N</i>d&quot;, for example to convert a single image file  <i>img.jpeg</i> you can employ the command:<div class="spacer">
</div>
<br/>
        avconv -i img.jpeg img.png<br/>
</div>
<div class="subsection">
<h2>applehttp</h2> Apple HTTP Live Streaming demuxer.<div class="spacer">
</div>
This demuxer presents all AVStreams from all variant streams. The id field is set to the bitrate variant index number. By setting the discard flags on AVStreams (by pressing 'a' or 'v' in avplay), the caller can decide which variant streams to actually receive. The total bitrate of the variant that the stream belongs to is available in a metadata key named &quot;variant_bitrate&quot;.</div>
</div>
<div class="section">
<h1>MUXERS</h1> Muxers are configured elements in Libav which allow writing multimedia streams to a particular type of file.<div class="spacer">
</div>
When you configure your Libav build, all the supported muxers are enabled by default. You can list all available muxers using the configure option &quot;--list-muxers&quot;.<div class="spacer">
</div>
You can disable all the muxers with the configure option &quot;--disable-muxers&quot; and selectively enable / disable single muxers with the options &quot;--enable-muxer= <i>MUXER</i>&quot; / &quot;--disable-muxer= <i>MUXER</i>&quot;.<div class="spacer">
</div>
The option &quot;-formats&quot; of the av* tools will display the list of enabled muxers.<div class="spacer">
</div>
A description of some of the currently available muxers follows.<div class="subsection">
<h2>crc</h2> CRC (Cyclic Redundancy Check) testing format.<div class="spacer">
</div>
This muxer computes and prints the Adler-32 CRC of all the input audio and video frames. By default audio frames are converted to signed 16-bit raw audio and video frames to raw video before computing the CRC.<div class="spacer">
</div>
The output of the muxer consists of a single line of the form: CRC=0x <i>CRC</i>, where <i>CRC</i> is a hexadecimal number 0-padded to 8 digits containing the CRC for all the decoded input frames.<div class="spacer">
</div>
For example to compute the CRC of the input, and store it in the file  <i>out.crc</i>:<div class="spacer">
</div>
<br/>
        avconv -i INPUT -f crc out.crc<br/>
<div class="spacer">
</div>
You can print the CRC to stdout with the command:<div class="spacer">
</div>
<br/>
        avconv -i INPUT -f crc -<br/>
<div class="spacer">
</div>
You can select the output format of each frame with <b>avconv</b> by specifying the audio and video codec and format. For example to compute the CRC of the input audio converted to PCM unsigned 8-bit and the input video converted to MPEG-2 video, use the command:<div class="spacer">
</div>
<br/>
        avconv -i INPUT -c:a pcm_u8 -c:v mpeg2video -f crc -<br/>
<div class="spacer">
</div>
See also the framecrc muxer.</div>
<div class="subsection">
<h2>framecrc</h2> Per-frame CRC (Cyclic Redundancy Check) testing format.<div class="spacer">
</div>
This muxer computes and prints the Adler-32 CRC for each decoded audio and video frame. By default audio frames are converted to signed 16-bit raw audio and video frames to raw video before computing the CRC.<div class="spacer">
</div>
The output of the muxer consists of a line for each audio and video frame of the form:  <i>stream_index</i>, <i>frame_dts</i>,  <i>frame_size</i>, 0x<i>CRC</i>, where <i>CRC</i> is a hexadecimal number 0-padded to 8 digits containing the CRC of the decoded frame.<div class="spacer">
</div>
For example to compute the CRC of each decoded frame in the input, and store it in the file  <i>out.crc</i>:<div class="spacer">
</div>
<br/>
        avconv -i INPUT -f framecrc out.crc<br/>
<div class="spacer">
</div>
You can print the CRC of each decoded frame to stdout with the command:<div class="spacer">
</div>
<br/>
        avconv -i INPUT -f framecrc -<br/>
<div class="spacer">
</div>
You can select the output format of each frame with <b>avconv</b> by specifying the audio and video codec and format. For example, to compute the CRC of each decoded input audio frame converted to PCM unsigned 8-bit and of each decoded input video frame converted to MPEG-2 video, use the command:<div class="spacer">
</div>
<br/>
        avconv -i INPUT -c:a pcm_u8 -c:v mpeg2video -f framecrc -<br/>
<div class="spacer">
</div>
See also the crc muxer.</div>
<div class="subsection">
<h2>image2</h2> Image file muxer.<div class="spacer">
</div>
The image file muxer writes video frames to image files.<div class="spacer">
</div>
The output filenames are specified by a pattern, which can be used to produce sequentially numbered series of files. The pattern may contain the string &quot;%d&quot; or &quot;%0 <i>N</i>d&quot;, this string specifies the position of the characters representing a numbering in the filenames. If the form &quot;%0 <i>N</i>d&quot; is used, the string representing the number in each filename is 0-padded to  <i>N</i> digits. The literal character '%' can be specified in the pattern with the string &quot;%%&quot;.<div class="spacer">
</div>
If the pattern contains &quot;%d&quot; or &quot;%0<i>N</i>d&quot;, the first filename of the file list specified will contain the number 1, all the following numbers will be sequential.<div class="spacer">
</div>
The pattern may contain a suffix which is used to automatically determine the format of the image files to write.<div class="spacer">
</div>
For example the pattern &quot;img-%03d.bmp&quot; will specify a sequence of filenames of the form  <i>img-001.bmp</i>, <i>img-002.bmp</i>, ...,  <i>img-010.bmp</i>, etc. The pattern &quot;img%%-%d.jpg&quot; will specify a sequence of filenames of the form  <i>img%-1.jpg</i>, <i>img%-2.jpg</i>, ..., <i>img%-10.jpg</i>, etc.<div class="spacer">
</div>
The following example shows how to use <b>avconv</b> for creating a sequence of files  <i>img-001.jpeg</i>, <i>img-002.jpeg</i>, ..., taking one image every second from the input video:<div class="spacer">
</div>
<br/>
        avconv -i in.avi -vsync 1 -r 1 -f image2 'img-%03d.jpeg'<br/>
<div class="spacer">
</div>
Note that with <b>avconv</b>, if the format is not specified with the &quot;-f&quot; option and the output filename specifies an image file format, the image2 muxer is automatically selected, so the previous command can be written as:<div class="spacer">
</div>
<br/>
        avconv -i in.avi -vsync 1 -r 1 'img-%03d.jpeg'<br/>
<div class="spacer">
</div>
Note also that the pattern must not necessarily contain &quot;%d&quot; or &quot;%0 <i>N</i>d&quot;, for example to create a single image file  <i>img.jpeg</i> from the input video you can employ the command:<div class="spacer">
</div>
<br/>
        avconv -i in.avi -f image2 -frames:v 1 img.jpeg<br/>
</div>
<div class="subsection">
<h2>mpegts</h2> MPEG transport stream muxer.<div class="spacer">
</div>
This muxer implements ISO 13818-1 and part of ETSI EN 300 468.<div class="spacer">
</div>
The muxer options are:<dl>
<dt>
<b>-mpegts_original_network_id</b> <i>number</i></dt>
<dd>
Set the original_network_id (default 0x0001). This is unique identifier of a network in DVB. Its main use is in the unique identification of a service through the path Original_Network_ID, Transport_Stream_ID.</dd>
</dl>
<dl>
<dt>
<b>-mpegts_transport_stream_id</b> <i>number</i></dt>
<dd>
Set the transport_stream_id (default 0x0001). This identifies a transponder in DVB.</dd>
</dl>
<dl>
<dt>
<b>-mpegts_service_id</b> <i>number</i></dt>
<dd>
Set the service_id (default 0x0001) also known as program in DVB.</dd>
</dl>
<dl>
<dt>
<b>-mpegts_pmt_start_pid</b> <i>number</i></dt>
<dd>
Set the first PID for PMT (default 0x1000, max 0x1f00).</dd>
</dl>
<dl>
<dt>
<b>-mpegts_start_pid</b> <i>number</i></dt>
<dd>
Set the first PID for data packets (default 0x0100, max 0x0f00).</dd>
</dl>
<div class="spacer">
</div>
The recognized metadata settings in mpegts muxer are &quot;service_provider&quot; and &quot;service_name&quot;. If they are not set the default for &quot;service_provider&quot; is &quot;Libav&quot; and the default for &quot;service_name&quot; is &quot;Service01&quot;.<div class="spacer">
</div>
<br/>
        avconv -i file.mpg -c copy \<br/>
             -mpegts_original_network_id 0x1122 \<br/>
             -mpegts_transport_stream_id 0x3344 \<br/>
             -mpegts_service_id 0x5566 \<br/>
             -mpegts_pmt_start_pid 0x1500 \<br/>
             -mpegts_start_pid 0x150 \<br/>
             -metadata service_provider=&quot;Some provider&quot; \<br/>
             -metadata service_name=&quot;Some Channel&quot; \<br/>
             -y out.ts<br/>
</div>
<div class="subsection">
<h2>null</h2> Null muxer.<div class="spacer">
</div>
This muxer does not generate any output file, it is mainly useful for testing or benchmarking purposes.<div class="spacer">
</div>
For example to benchmark decoding with <b>avconv</b> you can use the command:<div class="spacer">
</div>
<br/>
        avconv -benchmark -i INPUT -f null out.null<br/>
<div class="spacer">
</div>
Note that the above command does not read or write the <i>out.null</i> file, but specifying the output file is required by the  <b>avconv</b> syntax.<div class="spacer">
</div>
Alternatively you can write the command as:<div class="spacer">
</div>
<br/>
        avconv -benchmark -i INPUT -f null -<br/>
</div>
<div class="subsection">
<h2>matroska</h2> Matroska container muxer.<div class="spacer">
</div>
This muxer implements the matroska and webm container specs.<div class="spacer">
</div>
The recognized metadata settings in this muxer are:<dl>
<dt>
<b>title=</b><i>title name</i></dt>
<dd>
Name provided to a single track</dd>
</dl>
<dl>
<dt>
<b>language=</b><i>language name</i></dt>
<dd>
Specifies the language of the track in the Matroska languages form</dd>
</dl>
<dl>
<dt>
<b>STEREO_MODE=</b><i>mode</i></dt>
<dd>
Stereo 3D video layout of two views in a single video track</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
<b>mono</b></dt>
<dd>
video is not stereo</dd>
</dl>
<dl>
<dt>
<b>left_right</b></dt>
<dd>
Both views are arranged side by side, Left-eye view is on the left</dd>
</dl>
<dl>
<dt>
<b>bottom_top</b></dt>
<dd>
Both views are arranged in top-bottom orientation, Left-eye view is at bottom</dd>
</dl>
<dl>
<dt>
<b>top_bottom</b></dt>
<dd>
Both views are arranged in top-bottom orientation, Left-eye view is on top</dd>
</dl>
<dl>
<dt>
<b>checkerboard_rl</b></dt>
<dd>
Each view is arranged in a checkerboard interleaved pattern, Left-eye view being first</dd>
</dl>
<dl>
<dt>
<b>checkerboard_lr</b></dt>
<dd>
Each view is arranged in a checkerboard interleaved pattern, Right-eye view being first</dd>
</dl>
<dl>
<dt>
<b>row_interleaved_rl</b></dt>
<dd>
Each view is constituted by a row based interleaving, Right-eye view is first row</dd>
</dl>
<dl>
<dt>
<b>row_interleaved_lr</b></dt>
<dd>
Each view is constituted by a row based interleaving, Left-eye view is first row</dd>
</dl>
<dl>
<dt>
<b>col_interleaved_rl</b></dt>
<dd>
Both views are arranged in a column based interleaving manner, Right-eye view is first column</dd>
</dl>
<dl>
<dt>
<b>col_interleaved_lr</b></dt>
<dd>
Both views are arranged in a column based interleaving manner, Left-eye view is first column</dd>
</dl>
<dl>
<dt>
<b>anaglyph_cyan_red</b></dt>
<dd>
All frames are in anaglyph format viewable through red-cyan filters</dd>
</dl>
<dl>
<dt>
<b>right_left</b></dt>
<dd>
Both views are arranged side by side, Right-eye view is on the left</dd>
</dl>
<dl>
<dt>
<b>anaglyph_green_magenta</b></dt>
<dd>
All frames are in anaglyph format viewable through green-magenta filters</dd>
</dl>
<dl>
<dt>
<b>block_lr</b></dt>
<dd>
Both eyes laced in one Block, Left-eye view is first</dd>
</dl>
<dl>
<dt>
<b>block_rl</b></dt>
<dd>
Both eyes laced in one Block, Right-eye view is first</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
</div>
<div class="spacer">
</div>
For example a 3D WebM clip can be created using the following command line:<div class="spacer">
</div>
<br/>
        avconv -i sample_left_right_clip.mpg -an -c:v libvpx -metadata STEREO_MODE=left_right -y stereo_clip.webm<br/>
</div>
<div class="subsection">
<h2>segment</h2> Basic stream segmenter.<div class="spacer">
</div>
The segmenter muxer outputs streams to a number of separate files of nearly fixed duration. Output filename pattern can be set in a fashion similar to image2.<div class="spacer">
</div>
Every segment starts with a video keyframe, if a video stream is present. The segment muxer works best with a single constant frame rate video.<div class="spacer">
</div>
Optionally it can generate a flat list of the created segments, one segment per line.<dl>
<dt>
<b>segment_format</b> <i>format</i></dt>
<dd>
Override the inner container format, by default it is guessed by the filename extension.</dd>
</dl>
<dl>
<dt>
<b>segment_time</b> <i>t</i></dt>
<dd>
Set segment duration to <i>t</i> seconds.</dd>
</dl>
<dl>
<dt>
<b>segment_list</b> <i>name</i></dt>
<dd>
Generate also a listfile named <i>name</i>.</dd>
</dl>
<dl>
<dt>
<b>segment_list_size</b> <i>size</i></dt>
<dd>
Overwrite the listfile once it reaches <i>size</i> entries.</dd>
</dl>
<div class="spacer">
</div>
<br/>
        avconv -i in.mkv -c copy -map 0 -f segment -list out.list out%03d.nut<br/>
</div>
</div>
<div class="section">
<h1>PROTOCOLS</h1> Protocols are configured elements in Libav which allow to access resources which require the use of a particular protocol.<div class="spacer">
</div>
When you configure your Libav build, all the supported protocols are enabled by default. You can list all available ones using the configure option &quot;--list-protocols&quot;.<div class="spacer">
</div>
You can disable all the protocols using the configure option &quot;--disable-protocols&quot;, and selectively enable a protocol using the option &quot;--enable-protocol= <i>PROTOCOL</i>&quot;, or you can disable a particular protocol using the option &quot;--disable-protocol= <i>PROTOCOL</i>&quot;.<div class="spacer">
</div>
The option &quot;-protocols&quot; of the av* tools will display the list of supported protocols.<div class="spacer">
</div>
A description of the currently available protocols follows.<div class="subsection">
<h2>applehttp</h2> Read Apple HTTP Live Streaming compliant segmented stream as a uniform one. The M3U8 playlists describing the segments can be remote HTTP resources or local files, accessed using the standard file protocol. HTTP is default, specific protocol can be declared by specifying &quot;+ <i>proto</i>&quot; after the applehttp URI scheme name, where <i>proto</i> is either &quot;file&quot; or &quot;http&quot;.<div class="spacer">
</div>
<br/>
        applehttp://host/path/to/remote/resource.m3u8<br/>
        applehttp+http://host/path/to/remote/resource.m3u8<br/>
        applehttp+file://path/to/local/resource.m3u8<br/>
</div>
<div class="subsection">
<h2>concat</h2> Physical concatenation protocol.<div class="spacer">
</div>
Allow to read and seek from many resource in sequence as if they were a unique resource.<div class="spacer">
</div>
A URL accepted by this protocol has the syntax:<div class="spacer">
</div>
<br/>
        concat:&lt;URL1&gt;|&lt;URL2&gt;|...|&lt;URLN&gt;<br/>
<div class="spacer">
</div>
where <i>URL1</i>, <i>URL2</i>, ..., <i>URLN</i> are the urls of the resource to be concatenated, each one possibly specifying a distinct protocol.<div class="spacer">
</div>
For example to read a sequence of files <i>split1.mpeg</i>,  <i>split2.mpeg</i>, <i>split3.mpeg</i> with <i>avplay</i> use the command:<div class="spacer">
</div>
<br/>
        avplay concat:split1.mpeg\|split2.mpeg\|split3.mpeg<br/>
<div class="spacer">
</div>
Note that you may need to escape the character &quot;|&quot; which is special for many shells.</div>
<div class="subsection">
<h2>file</h2> File access protocol.<div class="spacer">
</div>
Allow to read from or read to a file.<div class="spacer">
</div>
For example to read from a file <i>input.mpeg</i> with <b>avconv</b> use the command:<div class="spacer">
</div>
<br/>
        avconv -i file:input.mpeg output.mpeg<br/>
<div class="spacer">
</div>
The av* tools default to the file protocol, that is a resource specified with the name &quot;FILE.mpeg&quot; is interpreted as the URL &quot;file:FILE.mpeg&quot;.</div>
<div class="subsection">
<h2>gopher</h2> Gopher protocol.</div>
<div class="subsection">
<h2>http</h2> HTTP (Hyper Text Transfer Protocol).</div>
<div class="subsection">
<h2>mmst</h2> MMS (Microsoft Media Server) protocol over TCP.</div>
<div class="subsection">
<h2>mmsh</h2> MMS (Microsoft Media Server) protocol over HTTP.<div class="spacer">
</div>
The required syntax is:<div class="spacer">
</div>
<br/>
        mmsh://&lt;server&gt;[:&lt;port&gt;][/&lt;app&gt;][/&lt;playpath&gt;]<br/>
</div>
<div class="subsection">
<h2>md5</h2> MD5 output protocol.<div class="spacer">
</div>
Computes the MD5 hash of the data to be written, and on close writes this to the designated output or stdout if none is specified. It can be used to test muxers without writing an actual file.<div class="spacer">
</div>
Some examples follow.<div class="spacer">
</div>
<br/>
        # Write the MD5 hash of the encoded AVI file to the file output.avi.md5.<br/>
        avconv -i input.flv -f avi -y md5:output.avi.md5<br/>
        <br/>
        # Write the MD5 hash of the encoded AVI file to stdout.<br/>
        avconv -i input.flv -f avi -y md5:<br/>
<div class="spacer">
</div>
Note that some formats (typically MOV) require the output protocol to be seekable, so they will fail with the MD5 output protocol.</div>
<div class="subsection">
<h2>pipe</h2> UNIX pipe access protocol.<div class="spacer">
</div>
Allow to read and write from UNIX pipes.<div class="spacer">
</div>
The accepted syntax is:<div class="spacer">
</div>
<br/>
        pipe:[&lt;number&gt;]<br/>
<div class="spacer">
</div>
<i>number</i> is the number corresponding to the file descriptor of the pipe (e.g. 0 for stdin, 1 for stdout, 2 for stderr).  If  <i>number</i> is not specified, by default the stdout file descriptor will be used for writing, stdin for reading.<div class="spacer">
</div>
For example to read from stdin with <b>avconv</b>:<div class="spacer">
</div>
<br/>
        cat test.wav | avconv -i pipe:0<br/>
        # ...this is the same as...<br/>
        cat test.wav | avconv -i pipe:<br/>
<div class="spacer">
</div>
For writing to stdout with <b>avconv</b>:<div class="spacer">
</div>
<br/>
        avconv -i test.wav -f avi pipe:1 | cat &gt; test.avi<br/>
        # ...this is the same as...<br/>
        avconv -i test.wav -f avi pipe: | cat &gt; test.avi<br/>
<div class="spacer">
</div>
Note that some formats (typically MOV), require the output protocol to be seekable, so they will fail with the pipe output protocol.</div>
<div class="subsection">
<h2>rtmp</h2> Real-Time Messaging Protocol.<div class="spacer">
</div>
The Real-Time Messaging Protocol (RTMP) is used for streaming multimedia content across a TCP/IP network.<div class="spacer">
</div>
The required syntax is:<div class="spacer">
</div>
<br/>
        rtmp://&lt;server&gt;[:&lt;port&gt;][/&lt;app&gt;][/&lt;playpath&gt;]<br/>
<div class="spacer">
</div>
The accepted parameters are:<dl>
<dt>
<b>server</b></dt>
<dd>
The address of the RTMP server.</dd>
</dl>
<dl>
<dt>
<b>port</b></dt>
<dd>
The number of the TCP port to use (by default is 1935).</dd>
</dl>
<dl>
<dt>
<b>app</b></dt>
<dd>
It is the name of the application to access. It usually corresponds to the path where the application is installed on the RTMP server (e.g.  <i>/ondemand/</i>, <i>/flash/live/</i>, etc.).</dd>
</dl>
<dl>
<dt>
<b>playpath</b></dt>
<dd>
It is the path or name of the resource to play with reference to the application specified in  <i>app</i>, may be prefixed by &quot;mp4:&quot;.</dd>
</dl>
<div class="spacer">
</div>
For example to read with <i>avplay</i> a multimedia resource named &quot;sample&quot; from the application &quot;vod&quot; from an RTMP server &quot;myserver&quot;:<div class="spacer">
</div>
<br/>
        avplay rtmp://myserver/vod/sample<br/>
</div>
<div class="subsection">
<h2>rtmp, rtmpe, rtmps, rtmpt, rtmpte</h2> Real-Time Messaging Protocol and its variants supported through librtmp.<div class="spacer">
</div>
Requires the presence of the librtmp headers and library during configuration. You need to explicitly configure the build with &quot;--enable-librtmp&quot;. If enabled this will replace the native RTMP protocol.<div class="spacer">
</div>
This protocol provides most client functions and a few server functions needed to support RTMP, RTMP tunneled in HTTP (RTMPT), encrypted RTMP (RTMPE), RTMP over SSL/TLS (RTMPS) and tunneled variants of these encrypted types (RTMPTE, RTMPTS).<div class="spacer">
</div>
The required syntax is:<div class="spacer">
</div>
<br/>
        &lt;rtmp_proto&gt;://&lt;server&gt;[:&lt;port&gt;][/&lt;app&gt;][/&lt;playpath&gt;] &lt;options&gt;<br/>
<div class="spacer">
</div>
where <i>rtmp_proto</i> is one of the strings &quot;rtmp&quot;, &quot;rtmpt&quot;, &quot;rtmpe&quot;, &quot;rtmps&quot;, &quot;rtmpte&quot;, &quot;rtmpts&quot; corresponding to each RTMP variant, and  <i>server</i>, <i>port</i>, <i>app</i> and <i>playpath</i> have the same meaning as specified for the RTMP native protocol.  <i>options</i> contains a list of space-separated options of the form  <i>key</i>=<i>val</i>.<div class="spacer">
</div>
See the librtmp manual page (man 3 librtmp) for more information.<div class="spacer">
</div>
For example, to stream a file in real-time to an RTMP server using  <b>avconv</b>:<div class="spacer">
</div>
<br/>
        avconv -re -i myfile -f flv rtmp://myserver/live/mystream<br/>
<div class="spacer">
</div>
To play the same stream using <i>avplay</i>:<div class="spacer">
</div>
<br/>
        avplay &quot;rtmp://myserver/live/mystream live=1&quot;<br/>
</div>
<div class="subsection">
<h2>rtp</h2> Real-Time Protocol.</div>
<div class="subsection">
<h2>rtsp</h2> RTSP is not technically a protocol handler in libavformat, it is a demuxer and muxer. The demuxer supports both normal RTSP (with data transferred over RTP; this is used by e.g. Apple and Microsoft) and Real-RTSP (with data transferred over RDT).<div class="spacer">
</div>
The muxer can be used to send a stream using RTSP ANNOUNCE to a server supporting it (currently Darwin Streaming Server and Mischa Spiegelmock's<br/>
 RTSP server (&quot;http://github.com/revmischa/rtsp-server&quot;)).<div class="spacer">
</div>
The required syntax for a RTSP url is:<div class="spacer">
</div>
<br/>
        rtsp://&lt;hostname&gt;[:&lt;port&gt;]/&lt;path&gt;<br/>
<div class="spacer">
</div>
The following options (set on the <b>avconv</b>/<i>avplay</i> command line, or set in code via &quot;AVOption&quot;s or in &quot;avformat_open_input&quot;), are supported:<div class="spacer">
</div>
Flags for &quot;rtsp_transport&quot;:<dl>
<dt>
<b>udp</b></dt>
<dd>
Use UDP as lower transport protocol.</dd>
</dl>
<dl>
<dt>
<b>tcp</b></dt>
<dd>
Use TCP (interleaving within the RTSP control channel) as lower transport protocol.</dd>
</dl>
<dl>
<dt>
<b>udp_multicast</b></dt>
<dd>
Use UDP multicast as lower transport protocol.</dd>
</dl>
<dl>
<dt>
<b>http</b></dt>
<dd>
Use HTTP tunneling as lower transport protocol, which is useful for passing proxies.</dd>
</dl>
<div class="spacer">
</div>
Multiple lower transport protocols may be specified, in that case they are tried one at a time (if the setup of one fails, the next one is tried). For the muxer, only the &quot;tcp&quot; and &quot;udp&quot; options are supported.<div class="spacer">
</div>
Flags for &quot;rtsp_flags&quot;:<dl>
<dt>
<b>filter_src</b></dt>
<dd>
Accept packets only from negotiated peer address and port.</dd>
</dl>
<div class="spacer">
</div>
When receiving data over UDP, the demuxer tries to reorder received packets (since they may arrive out of order, or packets may get lost totally). In order for this to be enabled, a maximum delay must be specified in the &quot;max_delay&quot; field of AVFormatContext.<div class="spacer">
</div>
When watching multi-bitrate Real-RTSP streams with <i>avplay</i>, the streams to display can be chosen with &quot;-vst&quot;  <i>n</i> and &quot;-ast&quot;  <i>n</i> for video and audio respectively, and can be switched on the fly by pressing &quot;v&quot; and &quot;a&quot;.<div class="spacer">
</div>
Example command lines:<div class="spacer">
</div>
To watch a stream over UDP, with a max reordering delay of 0.5 seconds:<div class="spacer">
</div>
<br/>
        avplay -max_delay 500000 -rtsp_transport udp rtsp://server/video.mp4<br/>
<div class="spacer">
</div>
To watch a stream tunneled over HTTP:<div class="spacer">
</div>
<br/>
        avplay -rtsp_transport http rtsp://server/video.mp4<br/>
<div class="spacer">
</div>
To send a stream in realtime to a RTSP server, for others to watch:<div class="spacer">
</div>
<br/>
        avconv -re -i &lt;input&gt; -f rtsp -muxdelay 0.1 rtsp://server/live.sdp<br/>
</div>
<div class="subsection">
<h2>sap</h2> Session Announcement Protocol (RFC 2974). This is not technically a protocol handler in libavformat, it is a muxer and demuxer. It is used for signalling of RTP streams, by announcing the SDP for the streams regularly on a separate port.<div class="spacer">
</div>
<i>Muxer</i><div class="spacer">
</div>
The syntax for a SAP url given to the muxer is:<div class="spacer">
</div>
<br/>
        sap://&lt;destination&gt;[:&lt;port&gt;][?&lt;options&gt;]<br/>
<div class="spacer">
</div>
The RTP packets are sent to <i>destination</i> on port <i>port</i>, or to port 5004 if no port is specified.  <i>options</i> is a &quot;&amp;&quot;-separated list. The following options are supported:<dl>
<dt>
<b>announce_addr=</b><i>address</i></dt>
<dd>
Specify the destination IP address for sending the announcements to. If omitted, the announcements are sent to the commonly used SAP announcement multicast address 224.2.127.254 (sap.mcast.net), or ff0e::2:7ffe if  <i>destination</i> is an IPv6 address.</dd>
</dl>
<dl>
<dt>
<b>announce_port=</b><i>port</i></dt>
<dd>
Specify the port to send the announcements on, defaults to 9875 if not specified.</dd>
</dl>
<dl>
<dt>
<b>ttl=</b><i>ttl</i></dt>
<dd>
Specify the time to live value for the announcements and RTP packets, defaults to 255.</dd>
</dl>
<dl>
<dt>
<b>same_port=</b><i>0|1</i></dt>
<dd>
If set to 1, send all RTP streams on the same port pair. If zero (the default), all streams are sent on unique ports, with each stream on a port 2 numbers higher than the previous. VLC/Live555 requires this to be set to 1, to be able to receive the stream. The RTP stack in libavformat for receiving requires all streams to be sent on unique ports.</dd>
</dl>
<div class="spacer">
</div>
Example command lines follow.<div class="spacer">
</div>
To broadcast a stream on the local subnet, for watching in VLC:<div class="spacer">
</div>
<br/>
        avconv -re -i &lt;input&gt; -f sap sap://224.0.0.255?same_port=1<br/>
<div class="spacer">
</div>
Similarly, for watching in avplay:<div class="spacer">
</div>
<br/>
        avconv -re -i &lt;input&gt; -f sap sap://224.0.0.255<br/>
<div class="spacer">
</div>
And for watching in avplay, over IPv6:<div class="spacer">
</div>
<br/>
        avconv -re -i &lt;input&gt; -f sap sap://[ff0e::1:2:3:4]<br/>
<div class="spacer">
</div>
<i>Demuxer</i><div class="spacer">
</div>
The syntax for a SAP url given to the demuxer is:<div class="spacer">
</div>
<br/>
        sap://[&lt;address&gt;][:&lt;port&gt;]<br/>
<div class="spacer">
</div>
<i>address</i> is the multicast address to listen for announcements on, if omitted, the default 224.2.127.254 (sap.mcast.net) is used.  <i>port</i> is the port that is listened on, 9875 if omitted.<div class="spacer">
</div>
The demuxers listens for announcements on the given address and port. Once an announcement is received, it tries to receive that particular stream.<div class="spacer">
</div>
Example command lines follow.<div class="spacer">
</div>
To play back the first stream announced on the normal SAP multicast address:<div class="spacer">
</div>
<br/>
        avplay sap://<br/>
<div class="spacer">
</div>
To play back the first stream announced on one the default IPv6 SAP multicast address:<div class="spacer">
</div>
<br/>
        avplay sap://[ff0e::2:7ffe]<br/>
</div>
<div class="subsection">
<h2>tcp</h2> Trasmission Control Protocol.<div class="spacer">
</div>
The required syntax for a TCP url is:<div class="spacer">
</div>
<br/>
        tcp://&lt;hostname&gt;:&lt;port&gt;[?&lt;options&gt;]<br/>
<dl>
<dt>
<b>listen</b></dt>
<dd>
Listen for an incoming connection<div style="height: 1.00em;">
&#160;</div>
<br/>
        avconv -i &lt;input&gt; -f &lt;format&gt; tcp://&lt;hostname&gt;:&lt;port&gt;?listen<br/>
        avplay tcp://&lt;hostname&gt;:&lt;port&gt;<br/>
</dd>
</dl>
</div>
<div class="subsection">
<h2>udp</h2> User Datagram Protocol.<div class="spacer">
</div>
The required syntax for a UDP url is:<div class="spacer">
</div>
<br/>
        udp://&lt;hostname&gt;:&lt;port&gt;[?&lt;options&gt;]<br/>
<div class="spacer">
</div>
<i>options</i> contains a list of &amp;-seperated options of the form <i>key</i>=<i>val</i>. Follow the list of supported options.<dl>
<dt>
<b>buffer_size=</b><i>size</i></dt>
<dd>
set the UDP buffer size in bytes</dd>
</dl>
<dl>
<dt>
<b>localport=</b><i>port</i></dt>
<dd>
override the local UDP port to bind with</dd>
</dl>
<dl>
<dt>
<b>localaddr=</b><i>addr</i></dt>
<dd>
Choose the local IP address. This is useful e.g. if sending multicast and the host has multiple interfaces, where the user can choose which interface to send on by specifying the IP address of that interface.</dd>
</dl>
<dl>
<dt>
<b>pkt_size=</b><i>size</i></dt>
<dd>
set the size in bytes of UDP packets</dd>
</dl>
<dl>
<dt>
<b>reuse=</b><i>1|0</i></dt>
<dd>
explicitly allow or disallow reusing UDP sockets</dd>
</dl>
<dl>
<dt>
<b>ttl=</b><i>ttl</i></dt>
<dd>
set the time to live value (for multicast only)</dd>
</dl>
<dl>
<dt>
<b>connect=</b><i>1|0</i></dt>
<dd>
Initialize the UDP socket with &quot;connect()&quot;. In this case, the destination address can't be changed with ff_udp_set_remote_url later. If the destination address isn't known at the start, this option can be specified in ff_udp_set_remote_url, too. This allows finding out the source address for the packets with getsockname, and makes writes return with AVERROR(ECONNREFUSED) if &quot;destination unreachable&quot; is received. For receiving, this gives the benefit of only receiving packets from the specified peer address/port.</dd>
</dl>
<div class="spacer">
</div>
Some usage examples of the udp protocol with <b>avconv</b> follow.<div class="spacer">
</div>
To stream over UDP to a remote endpoint:<div class="spacer">
</div>
<br/>
        avconv -i &lt;input&gt; -f &lt;format&gt; udp://&lt;hostname&gt;:&lt;port&gt;<br/>
<div class="spacer">
</div>
To stream in mpegts format over UDP using 188 sized UDP packets, using a large input buffer:<div class="spacer">
</div>
<br/>
        avconv -i &lt;input&gt; -f mpegts udp://&lt;hostname&gt;:&lt;port&gt;?pkt_size=188&amp;buffer_size=65535<br/>
<div class="spacer">
</div>
To receive over UDP from a remote endpoint:<div class="spacer">
</div>
<br/>
        avconv -i udp://[&lt;multicast-address&gt;]:&lt;port&gt;<br/>
</div>
</div>
<div class="section">
<h1>INPUT DEVICES</h1> Input devices are configured elements in Libav which allow to access the data coming from a multimedia device attached to your system.<div class="spacer">
</div>
When you configure your Libav build, all the supported input devices are enabled by default. You can list all available ones using the configure option &quot;--list-indevs&quot;.<div class="spacer">
</div>
You can disable all the input devices using the configure option &quot;--disable-indevs&quot;, and selectively enable an input device using the option &quot;--enable-indev= <i>INDEV</i>&quot;, or you can disable a particular input device using the option &quot;--disable-indev= <i>INDEV</i>&quot;.<div class="spacer">
</div>
The option &quot;-formats&quot; of the av* tools will display the list of supported input devices (amongst the demuxers).<div class="spacer">
</div>
A description of the currently available input devices follows.<div class="subsection">
<h2>alsa</h2> ALSA (Advanced Linux Sound Architecture) input device.<div class="spacer">
</div>
To enable this input device during configuration you need libasound installed on your system.<div class="spacer">
</div>
This device allows capturing from an ALSA device. The name of the device to capture has to be an ALSA card identifier.<div class="spacer">
</div>
An ALSA identifier has the syntax:<div class="spacer">
</div>
<br/>
        hw:&lt;CARD&gt;[,&lt;DEV&gt;[,&lt;SUBDEV&gt;]]<br/>
<div class="spacer">
</div>
where the <i>DEV</i> and <i>SUBDEV</i> components are optional.<div class="spacer">
</div>
The three arguments (in order: <i>CARD</i>,<i>DEV</i>,<i>SUBDEV</i>) specify card number or identifier, device number and subdevice number (-1 means any).<div class="spacer">
</div>
To see the list of cards currently recognized by your system check the files  <i>/proc/asound/cards</i> and <i>/proc/asound/devices</i>.<div class="spacer">
</div>
For example to capture with <b>avconv</b> from an ALSA device with card id 0, you may run the command:<div class="spacer">
</div>
<br/>
        avconv -f alsa -i hw:0 alsaout.wav<br/>
<div class="spacer">
</div>
For more information see: &lt; <b>http://www.alsa-project.org/alsa-doc/alsa-lib/pcm.html</b>&gt;</div>
<div class="subsection">
<h2>bktr</h2> BSD video input device.</div>
<div class="subsection">
<h2>dv1394</h2> Linux DV 1394 input device.</div>
<div class="subsection">
<h2>fbdev</h2> Linux framebuffer input device.<div class="spacer">
</div>
The Linux framebuffer is a graphic hardware-independent abstraction layer to show graphics on a computer monitor, typically on the console. It is accessed through a file device node, usually  <i>/dev/fb0</i>.<div class="spacer">
</div>
For more detailed information read the file Documentation/fb/framebuffer.txt included in the Linux source tree.<div class="spacer">
</div>
To record from the framebuffer device <i>/dev/fb0</i> with  <b>avconv</b>:<div class="spacer">
</div>
<br/>
        avconv -f fbdev -r 10 -i /dev/fb0 out.avi<br/>
<div class="spacer">
</div>
You can take a single screenshot image with the command:<div class="spacer">
</div>
<br/>
        avconv -f fbdev -frames:v 1 -r 1 -i /dev/fb0 screenshot.jpeg<br/>
<div class="spacer">
</div>
See also &lt;<b>http://linux-fbdev.sourceforge.net/</b>&gt;, and <i>fbset</i>(1).</div>
<div class="subsection">
<h2>jack</h2> JACK input device.<div class="spacer">
</div>
To enable this input device during configuration you need libjack installed on your system.<div class="spacer">
</div>
A JACK input device creates one or more JACK writable clients, one for each audio channel, with name  <i>client_name</i>:input_<i>N</i>, where  <i>client_name</i> is the name provided by the application, and <i>N</i> is a number which identifies the channel. Each writable client will send the acquired data to the Libav input device.<div class="spacer">
</div>
Once you have created one or more JACK readable clients, you need to connect them to one or more JACK writable clients.<div class="spacer">
</div>
To connect or disconnect JACK clients you can use the  <i>jack_connect</i> and <i>jack_disconnect</i> programs, or do it through a graphical interface, for example with  <i>qjackctl</i>.<div class="spacer">
</div>
To list the JACK clients and their properties you can invoke the command  <i>jack_lsp</i>.<div class="spacer">
</div>
Follows an example which shows how to capture a JACK readable client with  <b>avconv</b>.<div class="spacer">
</div>
<br/>
        # Create a JACK writable client with name &quot;libav&quot;.<br/>
        $ avconv -f jack -i libav -y out.wav<br/>
        <br/>
        # Start the sample jack_metro readable client.<br/>
        $ jack_metro -b 120 -d 0.2 -f 4000<br/>
        <br/>
        # List the current JACK clients.<br/>
        $ jack_lsp -c<br/>
        system:capture_1<br/>
        system:capture_2<br/>
        system:playback_1<br/>
        system:playback_2<br/>
        libav:input_1<br/>
        metro:120_bpm<br/>
        <br/>
        # Connect metro to the avconv writable client.<br/>
        $ jack_connect metro:120_bpm libav:input_1<br/>
<div class="spacer">
</div>
For more information read: &lt; <b>http://jackaudio.org/</b>&gt;</div>
<div class="subsection">
<h2>libdc1394</h2> IIDC1394 input device, based on libdc1394 and libraw1394.</div>
<div class="subsection">
<h2>oss</h2> Open Sound System input device.<div class="spacer">
</div>
The filename to provide to the input device is the device node representing the OSS input device, and is usually set to  <i>/dev/dsp</i>.<div class="spacer">
</div>
For example to grab from <i>/dev/dsp</i> using <b>avconv</b> use the command:<div class="spacer">
</div>
<br/>
        avconv -f oss -i /dev/dsp /tmp/oss.wav<br/>
<div class="spacer">
</div>
For more information about OSS see: &lt; <b>http://manuals.opensound.com/usersguide/dsp.html</b>&gt;</div>
<div class="subsection">
<h2>pulse</h2> pulseaudio input device.<div class="spacer">
</div>
To enable this input device during configuration you need libpulse-simple installed in your system.<div class="spacer">
</div>
The filename to provide to the input device is a source device or the string &quot;default&quot;<div class="spacer">
</div>
To list the pulse source devices and their properties you can invoke the command  <i>pactl list sources</i>.<div class="spacer">
</div>
<br/>
        avconv -f pulse -i default /tmp/pulse.wav<br/>
<div class="spacer">
</div>
<i></i><i>server</i><i> AVOption</i><div class="spacer">
</div>
The syntax is:<div class="spacer">
</div>
<br/>
        -server &lt;server name&gt;<br/>
<div class="spacer">
</div>
Connects to a specific server.<div class="spacer">
</div>
<i></i><i>name</i><i> AVOption</i><div class="spacer">
</div>
The syntax is:<div class="spacer">
</div>
<br/>
        -name &lt;application name&gt;<br/>
<div class="spacer">
</div>
Specify the application name pulse will use when showing active clients, by default it is &quot;libav&quot;<div class="spacer">
</div>
<i></i><i>stream_name</i><i> AVOption</i><div class="spacer">
</div>
The syntax is:<div class="spacer">
</div>
<br/>
        -stream_name &lt;stream name&gt;<br/>
<div class="spacer">
</div>
Specify the stream name pulse will use when showing active streams, by default it is &quot;record&quot;<div class="spacer">
</div>
<i></i><i>sample_rate</i><i> AVOption</i><div class="spacer">
</div>
The syntax is:<div class="spacer">
</div>
<br/>
        -sample_rate &lt;samplerate&gt;<br/>
<div class="spacer">
</div>
Specify the samplerate in Hz, by default 48kHz is used.<div class="spacer">
</div>
<i></i><i>channels</i><i> AVOption</i><div class="spacer">
</div>
The syntax is:<div class="spacer">
</div>
<br/>
        -channels &lt;N&gt;<br/>
<div class="spacer">
</div>
Specify the channels in use, by default 2 (stereo) is set.<div class="spacer">
</div>
<i></i><i>frame_size</i><i> AVOption</i><div class="spacer">
</div>
The syntax is:<div class="spacer">
</div>
<br/>
        -frame_size &lt;bytes&gt;<br/>
<div class="spacer">
</div>
Specify the number of byte per frame, by default it is set to 1024.<div class="spacer">
</div>
<i></i><i>fragment_size</i><i> AVOption</i><div class="spacer">
</div>
The syntax is:<div class="spacer">
</div>
<br/>
        -fragment_size &lt;bytes&gt;<br/>
<div class="spacer">
</div>
Specify the minimal buffering fragment in pulseaudio, it will affect the audio latency. By default it is unset.</div>
<div class="subsection">
<h2>sndio</h2> sndio input device.<div class="spacer">
</div>
To enable this input device during configuration you need libsndio installed on your system.<div class="spacer">
</div>
The filename to provide to the input device is the device node representing the sndio input device, and is usually set to  <i>/dev/audio0</i>.<div class="spacer">
</div>
For example to grab from <i>/dev/audio0</i> using <b>avconv</b> use the command:<div class="spacer">
</div>
<br/>
        avconv -f sndio -i /dev/audio0 /tmp/oss.wav<br/>
</div>
<div class="subsection">
<h2>video4linux and video4linux2</h2> Video4Linux and Video4Linux2 input video devices.<div class="spacer">
</div>
The name of the device to grab is a file device node, usually Linux systems tend to automatically create such nodes when the device (e.g. an USB webcam) is plugged into the system, and has a name of the kind  <i>/dev/video</i><i>N</i><i></i>, where <i>N</i> is a number associated to the device.<div class="spacer">
</div>
Video4Linux and Video4Linux2 devices only support a limited set of  <i>width</i>x<i>height</i> sizes and framerates. You can check which are supported for example with the command  <i>dov4l</i> for Video4Linux devices and using  <b>-list_formats all</b> for Video4Linux2 devices.<div class="spacer">
</div>
If the size for the device is set to 0x0, the input device will try to autodetect the size to use. Only for the video4linux2 device, if the frame rate is set to 0/0 the input device will use the frame rate value already set in the driver.<div class="spacer">
</div>
Video4Linux support is deprecated since Linux 2.6.30, and will be dropped in later versions.<div class="spacer">
</div>
Follow some usage examples of the video4linux devices with the av* tools.<div class="spacer">
</div>
<br/>
        # Grab and show the input of a video4linux device, frame rate is set<br/>
        # to the default of 25/1.<br/>
        avplay -s 320x240 -f video4linux /dev/video0<br/>
        <br/>
        # Grab and show the input of a video4linux2 device, autoadjust size.<br/>
        avplay -f video4linux2 /dev/video0<br/>
        <br/>
        # Grab and record the input of a video4linux2 device, autoadjust size,<br/>
        # frame rate value defaults to 0/0 so it is read from the video4linux2<br/>
        # driver.<br/>
        avconv -f video4linux2 -i /dev/video0 out.mpeg<br/>
</div>
<div class="subsection">
<h2>vfwcap</h2> VfW (Video for Windows) capture input device.<div class="spacer">
</div>
The filename passed as input is the capture driver number, ranging from 0 to 9. You may use &quot;list&quot; as filename to print a list of drivers. Any other filename will be interpreted as device number 0.</div>
<div class="subsection">
<h2>x11grab</h2> X11 video input device.<div class="spacer">
</div>
This device allows to capture a region of an X11 display.<div class="spacer">
</div>
The filename passed as input has the syntax:<div class="spacer">
</div>
<br/>
        [&lt;hostname&gt;]:&lt;display_number&gt;.&lt;screen_number&gt;[+&lt;x_offset&gt;,&lt;y_offset&gt;]<br/>
<div class="spacer">
</div>
<i>hostname</i>:<i>display_number</i>.<i>screen_number</i> specifies the X11 display name of the screen to grab from.  <i>hostname</i> can be ommitted, and defaults to &quot;localhost&quot;. The environment variable  <b>DISPLAY</b> contains the default display name.<div class="spacer">
</div>
<i>x_offset</i> and <i>y_offset</i> specify the offsets of the grabbed area with respect to the top-left border of the X11 screen. They default to 0.<div class="spacer">
</div>
Check the X11 documentation (e.g. man X) for more detailed information.<div class="spacer">
</div>
Use the <i>dpyinfo</i> program for getting basic information about the properties of your X11 display (e.g. grep for &quot;name&quot; or &quot;dimensions&quot;).<div class="spacer">
</div>
For example to grab from <i>:0.0</i> using <b>avconv</b>:<div class="spacer">
</div>
<br/>
        avconv -f x11grab -r 25 -s cif -i :0.0 out.mpg<br/>
        <br/>
        # Grab at position 10,20.<br/>
        avconv -f x11grab -r 25 -s cif -i :0.0+10,20 out.mpg<br/>
<div class="spacer">
</div>
<i></i><i>follow_mouse</i><i> AVOption</i><div class="spacer">
</div>
The syntax is:<div class="spacer">
</div>
<br/>
        -follow_mouse centered|&lt;PIXELS&gt;<br/>
<div class="spacer">
</div>
When it is specified with &quot;centered&quot;, the grabbing region follows the mouse pointer and keeps the pointer at the center of region; otherwise, the region follows only when the mouse pointer reaches within  <i>PIXELS</i> (greater than zero) to the edge of region.<div class="spacer">
</div>
For example:<div class="spacer">
</div>
<br/>
        avconv -f x11grab -follow_mouse centered -r 25 -s cif -i :0.0 out.mpg<br/>
        <br/>
        # Follows only when the mouse pointer reaches within 100 pixels to edge<br/>
        avconv -f x11grab -follow_mouse 100 -r 25 -s cif -i :0.0 out.mpg<br/>
<div class="spacer">
</div>
<i></i><i>show_region</i><i> AVOption</i><div class="spacer">
</div>
The syntax is:<div class="spacer">
</div>
<br/>
        -show_region 1<br/>
<div class="spacer">
</div>
If <i>show_region</i> AVOption is specified with <i>1</i>, then the grabbing region will be indicated on screen. With this option, it's easy to know what is being grabbed if only a portion of the screen is grabbed.<div class="spacer">
</div>
For example:<div class="spacer">
</div>
<br/>
        avconv -f x11grab -show_region 1 -r 25 -s cif -i :0.0+10,20 out.mpg<br/>
        <br/>
        # With follow_mouse<br/>
        avconv -f x11grab -follow_mouse centered -show_region 1  -r 25 -s cif -i :0.0 out.mpg<br/>
</div>
</div>
<div class="section">
<h1>SEE ALSO</h1>  <i>avconv</i>(1), <i>avplay</i>(1) and the Libav HTML documentation</div>
<div class="section">
<h1>AUTHORS</h1> The Libav developers</div>
<table class="foot">
<tr>
<td class="foot-date">
2016-04-01</td>
<td class="foot-os">
 </td>
</tr>
</table>
</div>
</body>
</html>

