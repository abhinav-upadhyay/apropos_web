<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
GIT-CHERRY(1)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
GIT-CHERRY(1)</td>
<td class="head-vol">
Git Manual</td>
<td class="head-rtitle">
GIT-CHERRY(1)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> git-cherry - Find commits yet to be applied to upstream</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
<i>git cherry</i> [-v] [&lt;upstream&gt; [&lt;head&gt; [&lt;limit&gt;]]]<br/>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>DESCRIPTION</h1> Determine whether there are commits in &lt;head&gt;..&lt;upstream&gt; that are equivalent to those in the range &lt;limit&gt;..&lt;head&gt;.<div style="height: 1.00em;">
&#160;</div>
The equivalence test is based on the diff, after removing whitespace and line numbers. git-cherry therefore detects when commits have been &quot;copied&quot; by means of <b>git-cherry-pick</b>(1), <b>git-am</b>(1) or <b>git-rebase</b>(1).<div style="height: 1.00em;">
&#160;</div>
Outputs the SHA1 of every commit in &lt;limit&gt;..&lt;head&gt;, prefixed with - for commits that have an equivalent in &lt;upstream&gt;, and + for commits that do not.</div>
<div class="section">
<h1>OPTIONS</h1> -v<div style="margin-left: 4.00ex;">
Show the commit subjects next to the SHA1s.</div>
<div class="spacer">
</div>
&lt;upstream&gt;<div style="margin-left: 4.00ex;">
Upstream branch to search for equivalent commits. Defaults to the upstream branch of HEAD.</div>
<div class="spacer">
</div>
&lt;head&gt;<div style="margin-left: 4.00ex;">
Working branch; defaults to HEAD.</div>
<div class="spacer">
</div>
&lt;limit&gt;<div style="margin-left: 4.00ex;">
Do not report commits up to (and including) limit.</div>
</div>
<div class="section">
<h1>EXAMPLES</h1><div class="subsection">
<h2>Patch workflows</h2> git-cherry is frequently used in patch-based workflows (see  <b>gitworkflows</b>(7)) to determine if a series of patches has been applied by the upstream maintainer. In such a workflow you might create and send a topic branch like this:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
$ git checkout -b topic origin/master<br/>
# work and create some commits<br/>
$ git format-patch origin/master<br/>
$ git send-email ... 00*<br/>
</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
Later, you can see whether your changes have been applied by saying (still on topic):<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
$ git fetch  # update your notion of origin/master<br/>
$ git cherry -v<br/>
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>Concrete example</h2> In a situation where topic consisted of three commits, and the maintainer applied two of them, the situation might look like:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
$ git log --graph --oneline --decorate --boundary origin/master...topic<br/>
* 7654321 (origin/master) upstream tip commit<br/>
[... snip some other commits ...]<br/>
* cccc111 cherry-pick of C<br/>
* aaaa111 cherry-pick of A<br/>
[... snip a lot more that has happened ...]<br/>
| * cccc000 (topic) commit C<br/>
| * bbbb000 commit B<br/>
| * aaaa000 commit A<br/>
|/<br/>
o 1234567 branch point<br/>
</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
In such cases, git-cherry shows a concise summary of what has yet to be applied:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
$ git cherry origin/master topic<br/>
- cccc000... commit C<br/>
+ bbbb000... commit B<br/>
- aaaa000... commit A<br/>
</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
Here, we see that the commits A and C (marked with -) can be dropped from your topic branch when you rebase it on top of origin/master, while the commit B (marked with +) still needs to be kept so that it will be sent to be applied to origin/master.</div>
<div class="subsection">
<h2>Using a limit</h2> The optional &lt;limit&gt; is useful in cases where your topic is based on other work that is not in upstream. Expanding on the previous example, this might look like:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
$ git log --graph --oneline --decorate --boundary origin/master...topic<br/>
* 7654321 (origin/master) upstream tip commit<br/>
[... snip some other commits ...]<br/>
* cccc111 cherry-pick of C<br/>
* aaaa111 cherry-pick of A<br/>
[... snip a lot more that has happened ...]<br/>
| * cccc000 (topic) commit C<br/>
| * bbbb000 commit B<br/>
| * aaaa000 commit A<br/>
| * 0000fff (base) unpublished stuff F<br/>
[... snip ...]<br/>
| * 0000aaa unpublished stuff A<br/>
|/<br/>
o 1234567 merge-base between upstream and topic<br/>
</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
By specifying base as the limit, you can avoid listing commits between base and topic:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
$ git cherry origin/master topic base<br/>
- cccc000... commit C<br/>
+ bbbb000... commit B<br/>
- aaaa000... commit A<br/>
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
</div>
<div class="section">
<h1>SEE ALSO</h1>  <b>git-patch-id</b>(1)</div>
<div class="section">
<h1>GIT</h1> Part of the  <b>git</b>(1) suite</div>
<table class="foot">
<tr>
<td class="foot-date">
04/03/2016</td>
<td class="foot-os">
Git 2.8.1</td>
</tr>
</table>
</div>
</body>
</html>

