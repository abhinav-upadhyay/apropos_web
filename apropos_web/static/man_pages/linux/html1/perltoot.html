<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
PERLTOOT(1)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
PERLTOOT(1)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
PERLTOOT(1)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> perltoot - Tom's object-oriented tutorial for perl</div>
<div class="section">
<h1>DESCRIPTION</h1> Object-oriented programming is a big seller these days.  Some managers would rather have objects than sliced bread.  Why is that?  What's so special about an object?  Just what  <i>is</i> an object anyway?<div class="spacer">
</div>
An object is nothing but a way of tucking away complex behaviours into a neat little easy-to-use bundle.  (This is what professors call abstraction.) Smart people who have nothing to do but sit around for weeks on end figuring out really hard problems make these nifty objects that even regular people can use. (This is what professors call software reuse.)  Users (well, programmers) can play with this little bundle all they want, but they aren't to open it up and mess with the insides.  Just like an expensive piece of hardware, the contract says that you void the warranty if you muck with the cover.  So don't do that.<div class="spacer">
</div>
The heart of objects is the class, a protected little private namespace full of data and functions.  A class is a set of related routines that addresses some problem area.  You can think of it as a user-defined type. The Perl package mechanism, also used for more traditional modules, is used for class modules as well.  Objects &quot;live&quot; in a class, meaning that they belong to some package.<div class="spacer">
</div>
More often than not, the class provides the user with little bundles. These bundles are objects.  They know whose class they belong to, and how to behave.  Users ask the class to do something, like &quot;give me an object.&quot;  Or they can ask one of these objects to do something. Asking a class to do something for you is calling a  <i>class method</i>. Asking an object to do something for you is calling an  <i>object method</i>. Asking either a class (usually) or an object (sometimes) to give you back an object is calling a  <i>constructor</i>, which is just a kind of method.<div class="spacer">
</div>
That's all well and good, but how is an object different from any other Perl data type?  Just what is an object  <i>really</i>; that is, what's its fundamental type?  The answer to the first question is easy.  An object is different from any other data type in Perl in one and only one way: you may dereference it using not merely string or numeric subscripts as with simple arrays and hashes, but with named subroutine calls. In a word, with  <i>methods</i>.<div class="spacer">
</div>
The answer to the second question is that it's a reference, and not just any reference, mind you, but one whose referent has been  <i>bless</i>()ed into a particular class (read: package).  What kind of reference?  Well, the answer to that one is a bit less concrete.  That's because in Perl the designer of the class can employ any sort of reference they'd like as the underlying intrinsic data type.  It could be a scalar, an array, or a hash reference.  It could even be a code reference.  But because of its inherent flexibility, an object is usually a hash reference.</div>
<div class="section">
<h1>Creating a Class</h1> Before you create a class, you need to decide what to name it.  That's because the class (package) name governs the name of the file used to house it, just as with regular modules.  Then, that class (package) should provide one or more ways to generate objects.  Finally, it should provide mechanisms to allow users of its objects to indirectly manipulate these objects from a distance.<div class="spacer">
</div>
For example, let's make a simple Person class module.  It gets stored in the file Person.pm.  If it were called a Happy::Person class, it would be stored in the file Happy/Person.pm, and its package would become Happy::Person instead of just Person.  (On a personal computer not running Unix or Plan 9, but something like Mac OS or VMS, the directory separator may be different, but the principle is the same.)  Do not assume any formal relationship between modules based on their directory names. This is merely a grouping convenience, and has no effect on inheritance, variable accessibility, or anything else.<div class="spacer">
</div>
For this module we aren't going to use Exporter, because we're a well-behaved class module that doesn't export anything at all. In order to manufacture objects, a class needs to have a  <i>constructor</i>  <i>method</i>.  A constructor gives you back not just a regular data type, but a brand-new object in that class.  This magic is taken care of by the  <i>bless()</i> function, whose sole purpose is to enable its referent to be used as an object.  Remember: being an object really means nothing more than that methods may now be called against it.<div class="spacer">
</div>
While a constructor may be named anything you'd like, most Perl programmers seem to like to call theirs  <i>new()</i>.  However, <i>new()</i> is not a reserved word, and a class is under no obligation to supply such. Some programmers have also been known to use a function with the same name as the class as the constructor.<div class="subsection">
<h2>Object Representation</h2> By far the most common mechanism used in Perl to represent a Pascal record, a C struct, or a C++ class is an anonymous hash.  That's because a hash has an arbitrary number of data fields, each conveniently accessed by an arbitrary name of your own devising.<div class="spacer">
</div>
If you were just doing a simple struct-like emulation, you would likely go about it something like this:<div class="spacer">
</div>
<br/>
    $rec = {<br/>
        name  =&gt; &quot;Jason&quot;,<br/>
        age   =&gt; 23,<br/>
        peers =&gt; [ &quot;Norbert&quot;, &quot;Rhys&quot;, &quot;Phineas&quot;],<br/>
    };<br/>
<div class="spacer">
</div>
If you felt like it, you could add a bit of visual distinction by up-casing the hash keys:<div class="spacer">
</div>
<br/>
    $rec = {<br/>
        NAME  =&gt; &quot;Jason&quot;,<br/>
        AGE   =&gt; 23,<br/>
        PEERS =&gt; [ &quot;Norbert&quot;, &quot;Rhys&quot;, &quot;Phineas&quot;],<br/>
    };<br/>
<div class="spacer">
</div>
And so you could get at &quot;$rec-&gt;{NAME}&quot; to find &quot;Jason&quot;, or &quot;@{ $rec-&gt;{PEERS} }&quot; to get at &quot;Norbert&quot;, &quot;Rhys&quot;, and &quot;Phineas&quot;. (Have you ever noticed how many 23-year-old programmers seem to be named &quot;Jason&quot; these days? :-)<div class="spacer">
</div>
This same model is often used for classes, although it is not considered the pinnacle of programming propriety for folks from outside the class to come waltzing into an object, brazenly accessing its data members directly.  Generally speaking, an object should be considered an opaque cookie that you use  <i>object methods</i> to access.  Visually, methods look like you're dereffing a reference using a function name instead of brackets or braces.</div>
<div class="subsection">
<h2>Class Interface</h2> Some languages provide a formal syntactic interface to a class's methods, but Perl does not.  It relies on you to read the documentation of each class.  If you try to call an undefined method on an object, Perl won't complain, but the program will trigger an exception while it's running. Likewise, if you call a method expecting a prime number as its argument with a non-prime one instead, you can't expect the compiler to catch this. (Well, you can expect it all you like, but it's not going to happen.)<div class="spacer">
</div>
Let's suppose you have a well-educated user of your Person class, someone who has read the docs that explain the prescribed interface.  Here's how they might use the Person class:<div class="spacer">
</div>
<br/>
    use Person;<br/>
<br/>
    $him = Person-&gt;new();<br/>
    $him-&gt;name(&quot;Jason&quot;);<br/>
    $him-&gt;age(23);<br/>
    $him-&gt;peers( &quot;Norbert&quot;, &quot;Rhys&quot;, &quot;Phineas&quot; );<br/>
<br/>
    push @All_Recs, $him;  # save object in array for later<br/>
<br/>
    printf &quot;%s is %d years old.\n&quot;, $him-&gt;name, $him-&gt;age;<br/>
    print &quot;His peers are: &quot;, join(&quot;, &quot;, $him-&gt;peers), &quot;\n&quot;;<br/>
<br/>
    printf &quot;Last rec's name is %s\n&quot;, $All_Recs[-1]-&gt;name;<br/>
<div class="spacer">
</div>
As you can see, the user of the class doesn't know (or at least, has no business paying attention to the fact) that the object has one particular implementation or another.  The interface to the class and its objects is exclusively via methods, and that's all the user of the class should ever play with.</div>
<div class="subsection">
<h2>Constructors and Instance Methods</h2> Still,  <i>someone</i> has to know what's in the object.  And that someone is the class.  It implements methods that the programmer uses to access the object.  Here's how to implement the Person class using the standard hash-ref-as-an-object idiom.  We'll make a class method called  <i>new()</i> to act as the constructor, and three object methods called  <i>name()</i>, <i>age()</i>, and  <i>peers()</i> to get at per-object data hidden away in our anonymous hash.<div class="spacer">
</div>
<br/>
    package Person;<br/>
    use strict;<br/>
<br/>
    ##################################################<br/>
    ## the object constructor (simplistic version)  ##<br/>
    ##################################################<br/>
    sub new {<br/>
        my $self  = {};<br/>
        $self-&gt;{NAME}   = undef;<br/>
        $self-&gt;{AGE}    = undef;<br/>
        $self-&gt;{PEERS}  = [];<br/>
        bless($self);           # but see below<br/>
        return $self;<br/>
    }<br/>
<br/>
    ##############################################<br/>
    ## methods to access per-object data        ##<br/>
    ##                                          ##<br/>
    ## With args, they set the value.  Without  ##<br/>
    ## any, they only retrieve it/them.         ##<br/>
    ##############################################<br/>
<br/>
    sub name {<br/>
        my $self = shift;<br/>
        if (@_) { $self-&gt;{NAME} = shift }<br/>
        return $self-&gt;{NAME};<br/>
    }<br/>
<br/>
    sub age {<br/>
        my $self = shift;<br/>
        if (@_) { $self-&gt;{AGE} = shift }<br/>
        return $self-&gt;{AGE};<br/>
    }<br/>
<br/>
    sub peers {<br/>
        my $self = shift;<br/>
        if (@_) { @{ $self-&gt;{PEERS} } = @_ }<br/>
        return @{ $self-&gt;{PEERS} };<br/>
    }<br/>
<br/>
    1;  # so the require or use succeeds<br/>
<div class="spacer">
</div>
We've created three methods to access an object's data, <i>name()</i>, <i>age()</i>, and  <i>peers()</i>.  These are all substantially similar.  If called with an argument, they set the appropriate field; otherwise they return the value held by that field, meaning the value of that hash key.</div>
<div class="subsection">
<h2>Planning for the Future: Better Constructors</h2> Even though at this point you may not even know what it means, someday you're going to worry about inheritance.  (You can safely ignore this for now and worry about it later if you'd like.)  To ensure that this all works out smoothly, you must use the double-argument form of  <i>bless()</i>. The second argument is the class into which the referent will be blessed. By not assuming our own class as the default second argument and instead using the class passed into us, we make our constructor inheritable.<div class="spacer">
</div>
<br/>
    sub new {<br/>
        my $class = shift;<br/>
        my $self  = {};<br/>
        $self-&gt;{NAME}   = undef;<br/>
        $self-&gt;{AGE}    = undef;<br/>
        $self-&gt;{PEERS}  = [];<br/>
        bless ($self, $class);<br/>
        return $self;<br/>
    }<br/>
<div class="spacer">
</div>
That's about all there is for constructors.  These methods bring objects to life, returning neat little opaque bundles to the user to be used in subsequent method calls.</div>
<div class="subsection">
<h2>Destructors</h2> Every story has a beginning and an end.  The beginning of the object's story is its constructor, explicitly called when the object comes into existence.  But the ending of its story is the  <i>destructor</i>, a method implicitly called when an object leaves this life.  Any per-object clean-up code is placed in the destructor, which must (in Perl) be called DESTROY.<div class="spacer">
</div>
If constructors can have arbitrary names, then why not destructors? Because while a constructor is explicitly called, a destructor is not. Destruction happens automatically via Perl's garbage collection (GC) system, which is a quick but somewhat lazy reference-based GC system. To know what to call, Perl insists that the destructor be named DESTROY. Perl's notion of the right time to call a destructor is not well-defined currently, which is why your destructors should not rely on when they are called.<div class="spacer">
</div>
Why is DESTROY in all caps?  Perl on occasion uses purely uppercase function names as a convention to indicate that the function will be automatically called by Perl in some way.  Others that are called implicitly include BEGIN, END, AUTOLOAD, plus all methods used by tied objects, described in perltie.<div class="spacer">
</div>
In really good object-oriented programming languages, the user doesn't care when the destructor is called.  It just happens when it's supposed to.  In low-level languages without any GC at all, there's no way to depend on this happening at the right time, so the programmer must explicitly call the destructor to clean up memory and state, crossing their fingers that it's the right time to do so.   Unlike C++, an object destructor is nearly never needed in Perl, and even when it is, explicit invocation is uncalled for.  In the case of our Person class, we don't need a destructor because Perl takes care of simple matters like memory deallocation.<div class="spacer">
</div>
The only situation where Perl's reference-based GC won't work is when there's a circularity in the data structure, such as:<div class="spacer">
</div>
<br/>
    $this-&gt;{WHATEVER} = $this;<br/>
<div class="spacer">
</div>
In that case, you must delete the self-reference manually if you expect your program not to leak memory.  While admittedly error-prone, this is the best we can do right now.  Nonetheless, rest assured that when your program is finished, its objects' destructors are all duly called. So you are guaranteed that an object  <i>eventually</i> gets properly destroyed, except in the unique case of a program that never exits. (If you're running Perl embedded in another application, this full GC pass happens a bit more frequently--whenever a thread shuts down.)</div>
<div class="subsection">
<h2>Other Object Methods</h2> The methods we've talked about so far have either been constructors or else simple &quot;data methods&quot;, interfaces to data stored in the object. These are a bit like an object's data members in the C++ world, except that strangers don't access them as data.  Instead, they should only access the object's data indirectly via its methods.  This is an important rule: in Perl, access to an object's data should  <i>only</i> be made through methods.<div class="spacer">
</div>
Perl doesn't impose restrictions on who gets to use which methods. The public-versus-private distinction is by convention, not syntax. (Well, unless you use the Alias module described below in &quot;Data Members as Variables&quot;.)  Occasionally you'll see method names beginning or ending with an underscore or two.  This marking is a convention indicating that the methods are private to that class alone and sometimes to its closest acquaintances, its immediate subclasses.  But this distinction is not enforced by Perl itself.  It's up to the programmer to behave.<div class="spacer">
</div>
There's no reason to limit methods to those that simply access data. Methods can do anything at all.  The key point is that they're invoked against an object or a class.  Let's say we'd like object methods that do more than fetch or set one particular field.<div class="spacer">
</div>
<br/>
    sub exclaim {<br/>
        my $self = shift;<br/>
        return sprintf &quot;Hi, I'm %s, age %d, working with %s&quot;,<br/>
            $self-&gt;{NAME}, $self-&gt;{AGE}, join(&quot;, &quot;, @{$self-&gt;{PEERS}});<br/>
    }<br/>
<div class="spacer">
</div>
Or maybe even one like this:<div class="spacer">
</div>
<br/>
    sub happy_birthday {<br/>
        my $self = shift;<br/>
        return ++$self-&gt;{AGE};<br/>
    }<br/>
<div class="spacer">
</div>
Some might argue that one should go at these this way:<div class="spacer">
</div>
<br/>
    sub exclaim {<br/>
        my $self = shift;<br/>
        return sprintf &quot;Hi, I'm %s, age %d, working with %s&quot;,<br/>
            $self-&gt;name, $self-&gt;age, join(&quot;, &quot;, $self-&gt;peers);<br/>
    }<br/>
<br/>
    sub happy_birthday {<br/>
        my $self = shift;<br/>
        return $self-&gt;age( $self-&gt;age() + 1 );<br/>
    }<br/>
<div class="spacer">
</div>
But since these methods are all executing in the class itself, this may not be critical.  There are tradeoffs to be made.  Using direct hash access is faster (about an order of magnitude faster, in fact), and it's more convenient when you want to interpolate in strings.  But using methods (the external interface) internally shields not just the users of your class but even you yourself from changes in your data representation.</div>
</div>
<div class="section">
<h1>Class Data</h1> What about &quot;class data&quot;, data items common to each object in a class? What would you want that for?  Well, in your Person class, you might like to keep track of the total people alive.  How do you implement that?<div class="spacer">
</div>
You <i>could</i> make it a global variable called $Person::Census.  But about only reason you'd do that would be if you  <i>wanted</i> people to be able to get at your class data directly.  They could just say $Person::Census and play around with it.  Maybe this is ok in your design scheme. You might even conceivably want to make it an exported variable.  To be exportable, a variable must be a (package) global.  If this were a traditional module rather than an object-oriented one, you might do that.<div class="spacer">
</div>
While this approach is expected in most traditional modules, it's generally considered rather poor form in most object modules.  In an object module, you should set up a protective veil to separate interface from implementation.  So provide a class method to access class data just as you provide object methods to access object data.<div class="spacer">
</div>
So, you <i>could</i> still keep $Census as a package global and rely upon others to honor the contract of the module and therefore not play around with its implementation.  You could even be supertricky and make $Census a tied object as described in perltie, thereby intercepting all accesses.<div class="spacer">
</div>
But more often than not, you just want to make your class data a file-scoped lexical.  To do so, simply put this at the top of the file:<div class="spacer">
</div>
<br/>
    my $Census = 0;<br/>
<div class="spacer">
</div>
Even though the scope of a <i>my()</i> normally expires when the block in which it was declared is done (in this case the whole file being required or used), Perl's deep binding of lexical variables guarantees that the variable will not be deallocated, remaining accessible to functions declared within that scope.  This doesn't work with global variables given temporary values via  <i>local()</i>, though.<div class="spacer">
</div>
Irrespective of whether you leave $Census a package global or make it instead a file-scoped lexical, you should make these changes to your  <i>Person::new()</i> constructor:<div class="spacer">
</div>
<br/>
    sub new {<br/>
        my $class = shift;<br/>
        my $self  = {};<br/>
        $Census++;<br/>
        $self-&gt;{NAME}   = undef;<br/>
        $self-&gt;{AGE}    = undef;<br/>
        $self-&gt;{PEERS}  = [];<br/>
        bless ($self, $class);<br/>
        return $self;<br/>
    }<br/>
<br/>
    sub population {<br/>
        return $Census;<br/>
    }<br/>
<div class="spacer">
</div>
Now that we've done this, we certainly do need a destructor so that when Person is destroyed, the $Census goes down.  Here's how this could be done:<div class="spacer">
</div>
<br/>
    sub DESTROY { --$Census }<br/>
<div class="spacer">
</div>
Notice how there's no memory to deallocate in the destructor?  That's something that Perl takes care of for you all by itself.<div class="spacer">
</div>
Alternatively, you could use the Class::Data::Inheritable module from CPAN.<div class="subsection">
<h2>Accessing Class Data</h2> It turns out that this is not really a good way to go about handling class data.  A good scalable rule is that  <i>you must never reference class</i>  <i>data directly from an object method</i>.  Otherwise you aren't building a scalable, inheritable class.  The object must be the rendezvous point for all operations, especially from an object method.  The globals (class data) would in some sense be in the &quot;wrong&quot; package in your derived classes.  In Perl, methods execute in the context of the class they were defined in,  <i>not</i> that of the object that triggered them. Therefore, namespace visibility of package globals in methods is unrelated to inheritance.<div class="spacer">
</div>
Got that?  Maybe not.  Ok, let's say that some other class &quot;borrowed&quot; (well, inherited) the DESTROY method as it was defined above.  When those objects are destroyed, the original $Census variable will be altered, not the one in the new class's package namespace.  Perhaps this is what you want, but probably it isn't.<div class="spacer">
</div>
Here's how to fix this.  We'll store a reference to the data in the value accessed by the hash key &quot;_CENSUS&quot;.  Why the underscore?  Well, mostly because an initial underscore already conveys strong feelings of magicalness to a C programmer.  It's really just a mnemonic device to remind ourselves that this field is special and not to be used as a public data member in the same way that NAME, AGE, and PEERS are. (Because we've been developing this code under the strict pragma, prior to perl version 5.004 we'll have to quote the field name.)<div class="spacer">
</div>
<br/>
    sub new {<br/>
        my $class = shift;<br/>
        my $self  = {};<br/>
        $self-&gt;{NAME}     = undef;<br/>
        $self-&gt;{AGE}      = undef;<br/>
        $self-&gt;{PEERS}    = [];<br/>
        # &quot;private&quot; data<br/>
        $self-&gt;{&quot;_CENSUS&quot;} = \$Census;<br/>
        bless ($self, $class);<br/>
        ++ ${ $self-&gt;{&quot;_CENSUS&quot;} };<br/>
        return $self;<br/>
    }<br/>
<br/>
    sub population {<br/>
        my $self = shift;<br/>
        if (ref $self) {<br/>
            return ${ $self-&gt;{&quot;_CENSUS&quot;} };<br/>
        } else {<br/>
            return $Census;<br/>
        }<br/>
    }<br/>
<br/>
    sub DESTROY {<br/>
        my $self = shift;<br/>
        -- ${ $self-&gt;{&quot;_CENSUS&quot;} };<br/>
    }<br/>
</div>
<div class="subsection">
<h2>Debugging Methods</h2> It's common for a class to have a debugging mechanism.  For example, you might want to see when objects are created or destroyed.  To do that, add a debugging variable as a file-scoped lexical.  For this, we'll pull in the standard Carp module to emit our warnings and fatal messages. That way messages will come out with the caller's filename and line number instead of our own; if we wanted them to be from our own perspective, we'd just use  <i>die()</i> and <i>warn()</i> directly instead of <i>croak()</i> and  <i>carp()</i> respectively.<div class="spacer">
</div>
<br/>
    use Carp;<br/>
    my $Debugging = 0;<br/>
<div class="spacer">
</div>
Now add a new class method to access the variable.<div class="spacer">
</div>
<br/>
    sub debug {<br/>
        my $class = shift;<br/>
        if (ref $class)  { confess &quot;Class method called as object method&quot; }<br/>
        unless (@_ == 1) { confess &quot;usage: CLASSNAME-&gt;debug(level)&quot; }<br/>
        $Debugging = shift;<br/>
    }<br/>
<div class="spacer">
</div>
Now fix up DESTROY to murmur a bit as the moribund object expires:<div class="spacer">
</div>
<br/>
    sub DESTROY {<br/>
        my $self = shift;<br/>
        if ($Debugging) { carp &quot;Destroying $self &quot; . $self-&gt;name }<br/>
        -- ${ $self-&gt;{&quot;_CENSUS&quot;} };<br/>
    }<br/>
<div class="spacer">
</div>
One could conceivably make a per-object debug state.  That way you could call both of these:<div class="spacer">
</div>
<br/>
    Person-&gt;debug(1);   # entire class<br/>
    $him-&gt;debug(1);     # just this object<br/>
<div class="spacer">
</div>
To do so, we need our debugging method to be a &quot;bimodal&quot; one, one that works on both classes  <i>and</i> objects.  Therefore, adjust the <i>debug()</i> and DESTROY methods as follows:<div class="spacer">
</div>
<br/>
    sub debug {<br/>
        my $self = shift;<br/>
        confess &quot;usage: thing-&gt;debug(level)&quot;    unless @_ == 1;<br/>
        my $level = shift;<br/>
        if (ref($self))  {<br/>
            $self-&gt;{&quot;_DEBUG&quot;} = $level;         # just myself<br/>
        } else {<br/>
            $Debugging        = $level;         # whole class<br/>
        }<br/>
    }<br/>
<br/>
    sub DESTROY {<br/>
        my $self = shift;<br/>
        if ($Debugging || $self-&gt;{&quot;_DEBUG&quot;}) {<br/>
            carp &quot;Destroying $self &quot; . $self-&gt;name;<br/>
        }<br/>
        -- ${ $self-&gt;{&quot;_CENSUS&quot;} };<br/>
    }<br/>
<div class="spacer">
</div>
What happens if a derived class (which we'll call Employee) inherits methods from this Person base class?  Then &quot;Employee-&gt;debug()&quot;, when called as a class method, manipulates $Person::Debugging not $Employee::Debugging.</div>
<div class="subsection">
<h2>Class Destructors</h2> The object destructor handles the death of each distinct object.  But sometimes you want a bit of cleanup when the entire class is shut down, which currently only happens when the program exits.  To make such a  <i>class destructor</i>, create a function in that class's package named END.  This works just like the END function in traditional modules, meaning that it gets called whenever your program exits unless it execs or dies of an uncaught signal.  For example,<div class="spacer">
</div>
<br/>
    sub END {<br/>
        if ($Debugging) {<br/>
            print &quot;All persons are going away now.\n&quot;;<br/>
        }<br/>
    }<br/>
<div class="spacer">
</div>
When the program exits, all the class destructors (END functions) are be called in the opposite order that they were loaded in (LIFO order).</div>
<div class="subsection">
<h2>Documenting the Interface</h2> And there you have it: we've just shown you the  <i>implementation</i> of this Person class.  Its  <i>interface</i> would be its documentation.  Usually this means putting it in pod (&quot;plain old documentation&quot;) format right there in the same file.  In our Person example, we would place the following docs anywhere in the Person.pm file.  Even though it looks mostly like code, it's not.  It's embedded documentation such as would be used by the pod2man, pod2html, or pod2text programs.  The Perl compiler ignores pods entirely, just as the translators ignore code.  Here's an example of some pods describing the informal interface:<div class="spacer">
</div>
<br/>
    =head1 NAME<br/>
<br/>
    Person - class to implement people<br/>
<br/>
    =head1 SYNOPSIS<br/>
<br/>
     use Person;<br/>
<br/>
     #################<br/>
     # class methods #<br/>
     #################<br/>
     $ob    = Person-&gt;new;<br/>
     $count = Person-&gt;population;<br/>
<br/>
     #######################<br/>
     # object data methods #<br/>
     #######################<br/>
<br/>
     ### get versions ###<br/>
         $who   = $ob-&gt;name;<br/>
         $years = $ob-&gt;age;<br/>
         @pals  = $ob-&gt;peers;<br/>
<br/>
     ### set versions ###<br/>
         $ob-&gt;name(&quot;Jason&quot;);<br/>
         $ob-&gt;age(23);<br/>
         $ob-&gt;peers( &quot;Norbert&quot;, &quot;Rhys&quot;, &quot;Phineas&quot; );<br/>
<br/>
     ########################<br/>
     # other object methods #<br/>
     ########################<br/>
<br/>
     $phrase = $ob-&gt;exclaim;<br/>
     $ob-&gt;happy_birthday;<br/>
<br/>
    =head1 DESCRIPTION<br/>
<br/>
    The Person class implements dah dee dah dee dah....<br/>
<div class="spacer">
</div>
That's all there is to the matter of interface versus implementation. A programmer who opens up the module and plays around with all the private little shiny bits that were safely locked up behind the interface contract has voided the warranty, and you shouldn't worry about their fate.</div>
</div>
<div class="section">
<h1>Aggregation</h1> Suppose you later want to change the class to implement better names. Perhaps you'd like to support both given names (called Christian names, irrespective of one's religion) and family names (called surnames), plus nicknames and titles.  If users of your Person class have been properly accessing it through its documented interface, then you can easily change the underlying implementation.  If they haven't, then they lose and it's their fault for breaking the contract and voiding their warranty.<div class="spacer">
</div>
To do this, we'll make another class, this one called Fullname.  What's the Fullname class look like?  To answer that question, you have to first figure out how you want to use it.  How about we use it this way:<div class="spacer">
</div>
<br/>
    $him = Person-&gt;new();<br/>
    $him-&gt;fullname-&gt;title(&quot;St&quot;);<br/>
    $him-&gt;fullname-&gt;christian(&quot;Thomas&quot;);<br/>
    $him-&gt;fullname-&gt;surname(&quot;Aquinas&quot;);<br/>
    $him-&gt;fullname-&gt;nickname(&quot;Tommy&quot;);<br/>
    printf &quot;His normal name is %s\n&quot;, $him-&gt;name;<br/>
    printf &quot;But his real name is %s\n&quot;, $him-&gt;fullname-&gt;as_string;<br/>
<div class="spacer">
</div>
Ok.  To do this, we'll change <i>Person::new()</i> so that it supports a full name field this way:<div class="spacer">
</div>
<br/>
    sub new {<br/>
        my $class = shift;<br/>
        my $self  = {};<br/>
        $self-&gt;{FULLNAME} = Fullname-&gt;new();<br/>
        $self-&gt;{AGE}      = undef;<br/>
        $self-&gt;{PEERS}    = [];<br/>
        $self-&gt;{&quot;_CENSUS&quot;} = \$Census;<br/>
        bless ($self, $class);<br/>
        ++ ${ $self-&gt;{&quot;_CENSUS&quot;} };<br/>
        return $self;<br/>
    }<br/>
<br/>
    sub fullname {<br/>
        my $self = shift;<br/>
        return $self-&gt;{FULLNAME};<br/>
    }<br/>
<div class="spacer">
</div>
Then to support old code, define <i>Person::name()</i> this way:<div class="spacer">
</div>
<br/>
    sub name {<br/>
        my $self = shift;<br/>
        return $self-&gt;{FULLNAME}-&gt;nickname(@_)<br/>
          ||   $self-&gt;{FULLNAME}-&gt;christian(@_);<br/>
    }<br/>
<div class="spacer">
</div>
Here's the Fullname class.  We'll use the same technique of using a hash reference to hold data fields, and methods by the appropriate name to access them:<div class="spacer">
</div>
<br/>
    package Fullname;<br/>
    use strict;<br/>
<br/>
    sub new {<br/>
        my $class = shift;<br/>
        my $self  = {<br/>
            TITLE       =&gt; undef,<br/>
            CHRISTIAN   =&gt; undef,<br/>
            SURNAME     =&gt; undef,<br/>
            NICK        =&gt; undef,<br/>
        };<br/>
        bless ($self, $class);<br/>
        return $self;<br/>
    }<br/>
<br/>
    sub christian {<br/>
        my $self = shift;<br/>
        if (@_) { $self-&gt;{CHRISTIAN} = shift }<br/>
        return $self-&gt;{CHRISTIAN};<br/>
    }<br/>
<br/>
    sub surname {<br/>
        my $self = shift;<br/>
        if (@_) { $self-&gt;{SURNAME} = shift }<br/>
        return $self-&gt;{SURNAME};<br/>
    }<br/>
<br/>
    sub nickname {<br/>
        my $self = shift;<br/>
        if (@_) { $self-&gt;{NICK} = shift }<br/>
        return $self-&gt;{NICK};<br/>
    }<br/>
<br/>
    sub title {<br/>
        my $self = shift;<br/>
        if (@_) { $self-&gt;{TITLE} = shift }<br/>
        return $self-&gt;{TITLE};<br/>
    }<br/>
<br/>
    sub as_string {<br/>
        my $self = shift;<br/>
        my $name = join(&quot; &quot;, @$self{'CHRISTIAN', 'SURNAME'});<br/>
        if ($self-&gt;{TITLE}) {<br/>
            $name = $self-&gt;{TITLE} . &quot; &quot; . $name;<br/>
        }<br/>
        return $name;<br/>
    }<br/>
<br/>
    1;<br/>
<div class="spacer">
</div>
Finally, here's the test program:<div class="spacer">
</div>
<br/>
    #!/usr/bin/perl -w<br/>
    use strict;<br/>
    use Person;<br/>
    sub END { show_census() }<br/>
<br/>
    sub show_census ()  {<br/>
        printf &quot;Current population: %d\n&quot;, Person-&gt;population;<br/>
    }<br/>
<br/>
    Person-&gt;debug(1);<br/>
<br/>
    show_census();<br/>
<br/>
    my $him = Person-&gt;new();<br/>
<br/>
    $him-&gt;fullname-&gt;christian(&quot;Thomas&quot;);<br/>
    $him-&gt;fullname-&gt;surname(&quot;Aquinas&quot;);<br/>
    $him-&gt;fullname-&gt;nickname(&quot;Tommy&quot;);<br/>
    $him-&gt;fullname-&gt;title(&quot;St&quot;);<br/>
    $him-&gt;age(1);<br/>
<br/>
    printf &quot;%s is really %s.\n&quot;, $him-&gt;name, $him-&gt;fullname-&gt;as_string;<br/>
    printf &quot;%s's age: %d.\n&quot;, $him-&gt;name, $him-&gt;age;<br/>
    $him-&gt;happy_birthday;<br/>
    printf &quot;%s's age: %d.\n&quot;, $him-&gt;name, $him-&gt;age;<br/>
<br/>
    show_census();<br/>
</div>
<div class="section">
<h1>Inheritance</h1> Object-oriented programming systems all support some notion of inheritance.  Inheritance means allowing one class to piggy-back on top of another one so you don't have to write the same code again and again.  It's about software reuse, and therefore related to Laziness, the principal virtue of a programmer.  (The import/export mechanisms in traditional modules are also a form of code reuse, but a simpler one than the true inheritance that you find in object modules.)<div class="spacer">
</div>
Sometimes the syntax of inheritance is built into the core of the language, and sometimes it's not.  Perl has no special syntax for specifying the class (or classes) to inherit from.  Instead, it's all strictly in the semantics.  Each package can have a variable called @ISA, which governs (method) inheritance.  If you try to call a method on an object or class, and that method is not found in that object's package, Perl then looks to @ISA for other packages to go looking through in search of the missing method.<div class="spacer">
</div>
Like the special per-package variables recognized by Exporter (such as @EXPORT, @EXPORT_OK, @EXPORT_FAIL, %EXPORT_TAGS, and $VERSION), the @ISA array  <i>must</i> be a package-scoped global and not a file-scoped lexical created via  <i>my()</i>.  Most classes have just one item in their @ISA array. In this case, we have what's called &quot;single inheritance&quot;, or SI for short.<div class="spacer">
</div>
Consider this class:<div class="spacer">
</div>
<br/>
    package Employee;<br/>
    use Person;<br/>
    @ISA = (&quot;Person&quot;);<br/>
    1;<br/>
<div class="spacer">
</div>
Not a lot to it, eh?  All it's doing so far is loading in another class and stating that this one will inherit methods from that other class if need be.  We have given it none of its own methods. We rely upon an Employee to behave just like a Person.<div class="spacer">
</div>
Setting up an empty class like this is called the &quot;empty subclass test&quot;; that is, making a derived class that does nothing but inherit from a base class.  If the original base class has been designed properly, then the new derived class can be used as a drop-in replacement for the old one.  This means you should be able to write a program like this:<div class="spacer">
</div>
<br/>
    use Employee;<br/>
    my $empl = Employee-&gt;new();<br/>
    $empl-&gt;name(&quot;Jason&quot;);<br/>
    $empl-&gt;age(23);<br/>
    printf &quot;%s is age %d.\n&quot;, $empl-&gt;name, $empl-&gt;age;<br/>
<div class="spacer">
</div>
By proper design, we mean always using the two-argument form of <i>bless()</i>, avoiding direct access of global data, and not exporting anything.  If you look back at the  <i>Person::new()</i> function we defined above, we were careful to do that.  There's a bit of package data used in the constructor, but the reference to this is stored on the object itself and all other methods access package data via that reference, so we should be ok.<div class="spacer">
</div>
What do we mean by the <i>Person::new()</i> function? Isn't that actually a method?  Well, in principle, yes.  A method is just a function that expects as its first argument a class name (package) or object (blessed reference).    <i>Person::new()</i> is the function that both the &quot;Person-&gt;new()&quot; method and the &quot;Employee-&gt;new()&quot; method end up calling.  Understand that while a method call looks a lot like a function call, they aren't really quite the same, and if you treat them as the same, you'll very soon be left with nothing but broken programs. First, the actual underlying calling conventions are different: method calls get an extra argument.  Second, function calls don't do inheritance, but methods do.<div class="spacer">
</div>
<br/>
        Method Call             Resulting Function Call<br/>
        -----------             ------------------------<br/>
        Person-&gt;new()           Person::new(&quot;Person&quot;)<br/>
        Employee-&gt;new()         Person::new(&quot;Employee&quot;)<br/>
<div class="spacer">
</div>
So don't use function calls when you mean to call a method.<div class="spacer">
</div>
If an employee is just a Person, that's not all too very interesting. So let's add some other methods.  We'll give our employee data fields to access their salary, their employee ID, and their start date.<div class="spacer">
</div>
If you're getting a little tired of creating all these nearly identical methods just to get at the object's data, do not despair.  Later, we'll describe several different convenience mechanisms for shortening this up.  Meanwhile, here's the straight-forward way:<div class="spacer">
</div>
<br/>
    sub salary {<br/>
        my $self = shift;<br/>
        if (@_) { $self-&gt;{SALARY} = shift }<br/>
        return $self-&gt;{SALARY};<br/>
    }<br/>
<br/>
    sub id_number {<br/>
        my $self = shift;<br/>
        if (@_) { $self-&gt;{ID} = shift }<br/>
        return $self-&gt;{ID};<br/>
    }<br/>
<br/>
    sub start_date {<br/>
        my $self = shift;<br/>
        if (@_) { $self-&gt;{START_DATE} = shift }<br/>
        return $self-&gt;{START_DATE};<br/>
    }<br/>
<div class="subsection">
<h2>Overridden Methods</h2> What happens when both a derived class and its base class have the same method defined?  Well, then you get the derived class's version of that method.  For example, let's say that we want the  <i>peers()</i> method called on an employee to act a bit differently.  Instead of just returning the list of peer names, let's return slightly different strings.  So doing this:<div class="spacer">
</div>
<br/>
    $empl-&gt;peers(&quot;Peter&quot;, &quot;Paul&quot;, &quot;Mary&quot;);<br/>
    printf &quot;His peers are: %s\n&quot;, join(&quot;, &quot;, $empl-&gt;peers);<br/>
<div class="spacer">
</div>
will produce:<div class="spacer">
</div>
<br/>
    His peers are: PEON=PETER, PEON=PAUL, PEON=MARY<br/>
<div class="spacer">
</div>
To do this, merely add this definition into the Employee.pm file:<div class="spacer">
</div>
<br/>
    sub peers {<br/>
        my $self = shift;<br/>
        if (@_) { @{ $self-&gt;{PEERS} } = @_ }<br/>
        return map { &quot;PEON=\U$_&quot; } @{ $self-&gt;{PEERS} };<br/>
    }<br/>
<div class="spacer">
</div>
There, we've just demonstrated the high-falutin' concept known in certain circles as  <i>polymorphism</i>.  We've taken on the form and behaviour of an existing object, and then we've altered it to suit our own purposes. This is a form of Laziness.  (Getting polymorphed is also what happens when the wizard decides you'd look better as a frog.)<div class="spacer">
</div>
Every now and then you'll want to have a method call trigger both its derived class (also known as &quot;subclass&quot;) version as well as its base class (also known as &quot;superclass&quot;) version.  In practice, constructors and destructors are likely to want to do this, and it probably also makes sense in the  <i>debug()</i> method we showed previously.<div class="spacer">
</div>
To do this, add this to Employee.pm:<div class="spacer">
</div>
<br/>
    use Carp;<br/>
    my $Debugging = 0;<br/>
<br/>
    sub debug {<br/>
        my $self = shift;<br/>
        confess &quot;usage: thing-&gt;debug(level)&quot;    unless @_ == 1;<br/>
        my $level = shift;<br/>
        if (ref($self))  {<br/>
            $self-&gt;{&quot;_DEBUG&quot;} = $level;<br/>
        } else {<br/>
            $Debugging = $level;            # whole class<br/>
        }<br/>
        Person::debug($self, $Debugging);   # don't really do this<br/>
    }<br/>
<div class="spacer">
</div>
As you see, we turn around and call the Person package's <i>debug()</i> function. But this is far too fragile for good design.  What if Person doesn't have a  <i>debug()</i> function, but is inheriting <i>its</i> <i>debug()</i> method from elsewhere?  It would have been slightly better to say<div class="spacer">
</div>
<br/>
    Person-&gt;debug($Debugging);<br/>
<div class="spacer">
</div>
But even that's got too much hard-coded.  It's somewhat better to say<div class="spacer">
</div>
<br/>
    $self-&gt;Person::debug($Debugging);<br/>
<div class="spacer">
</div>
Which is a funny way to say to start looking for a <i>debug()</i> method up in Person.  This strategy is more often seen on overridden object methods than on overridden class methods.<div class="spacer">
</div>
There is still something a bit off here.  We've hard-coded our superclass's name.  This in particular is bad if you change which classes you inherit from, or add others.  Fortunately, the pseudoclass SUPER comes to the rescue here.<div class="spacer">
</div>
<br/>
    $self-&gt;SUPER::debug($Debugging);<br/>
<div class="spacer">
</div>
This way it starts looking in my class's @ISA.  This only makes sense from  <i>within</i> a method call, though.  Don't try to access anything in SUPER:: from anywhere else, because it doesn't exist outside an overridden method call. Note that &quot;SUPER&quot; refers to the superclass of the current package,  <i>not</i> to the superclass of $self.<div class="spacer">
</div>
Things are getting a bit complicated here.  Have we done anything we shouldn't?  As before, one way to test whether we're designing a decent class is via the empty subclass test.  Since we already have an Employee class that we're trying to check, we'd better get a new empty subclass that can derive from Employee.  Here's one:<div class="spacer">
</div>
<br/>
    package Boss;<br/>
    use Employee;        # :-)<br/>
    @ISA = qw(Employee);<br/>
<div class="spacer">
</div>
And here's the test program:<div class="spacer">
</div>
<br/>
    #!/usr/bin/perl -w<br/>
    use strict;<br/>
    use Boss;<br/>
    Boss-&gt;debug(1);<br/>
<br/>
    my $boss = Boss-&gt;new();<br/>
<br/>
    $boss-&gt;fullname-&gt;title(&quot;Don&quot;);<br/>
    $boss-&gt;fullname-&gt;surname(&quot;Pichon Alvarez&quot;);<br/>
    $boss-&gt;fullname-&gt;christian(&quot;Federico Jesus&quot;);<br/>
    $boss-&gt;fullname-&gt;nickname(&quot;Fred&quot;);<br/>
<br/>
    $boss-&gt;age(47);<br/>
    $boss-&gt;peers(&quot;Frank&quot;, &quot;Felipe&quot;, &quot;Faust&quot;);<br/>
<br/>
    printf &quot;%s is age %d.\n&quot;, $boss-&gt;fullname-&gt;as_string, $boss-&gt;age;<br/>
    printf &quot;His peers are: %s\n&quot;, join(&quot;, &quot;, $boss-&gt;peers);<br/>
<div class="spacer">
</div>
Running it, we see that we're still ok.  If you'd like to dump out your object in a nice format, somewhat like the way the 'x' command works in the debugger, you could use the Data::Dumper module from CPAN this way:<div class="spacer">
</div>
<br/>
    use Data::Dumper;<br/>
    print &quot;Here's the boss:\n&quot;;<br/>
    print Dumper($boss);<br/>
<div class="spacer">
</div>
Which shows us something like this:<div class="spacer">
</div>
<br/>
    Here's the boss:<br/>
    $VAR1 = bless( {<br/>
         _CENSUS =&gt; \1,<br/>
         FULLNAME =&gt; bless( {<br/>
                              TITLE =&gt; 'Don',<br/>
                              SURNAME =&gt; 'Pichon Alvarez',<br/>
                              NICK =&gt; 'Fred',<br/>
                              CHRISTIAN =&gt; 'Federico Jesus'<br/>
                            }, 'Fullname' ),<br/>
         AGE =&gt; 47,<br/>
         PEERS =&gt; [<br/>
                    'Frank',<br/>
                    'Felipe',<br/>
                    'Faust'<br/>
                  ]<br/>
       }, 'Boss' );<br/>
<div class="spacer">
</div>
Hm.... something's missing there.  What about the salary, start date, and ID fields?  Well, we never set them to anything, even undef, so they don't show up in the hash's keys.  The Employee class has no  <i>new()</i> method of its own, and the  <i>new()</i> method in Person doesn't know about Employees. (Nor should it: proper OO design dictates that a subclass be allowed to know about its immediate superclass, but never vice-versa.)  So let's fix up  <i>Employee::new()</i> this way:<div class="spacer">
</div>
<br/>
    sub new {<br/>
        my $class = shift;<br/>
        my $self  = $class-&gt;SUPER::new();<br/>
        $self-&gt;{SALARY}        = undef;<br/>
        $self-&gt;{ID}            = undef;<br/>
        $self-&gt;{START_DATE}    = undef;<br/>
        bless ($self, $class);          # reconsecrate<br/>
        return $self;<br/>
    }<br/>
<div class="spacer">
</div>
Now if you dump out an Employee or Boss object, you'll find that new fields show up there now.</div>
<div class="subsection">
<h2>Multiple Inheritance</h2> Ok, at the risk of confusing beginners and annoying OO gurus, it's time to confess that Perl's object system includes that controversial notion known as multiple inheritance, or MI for short.  All this means is that rather than having just one parent class who in turn might itself have a parent class, etc., that you can directly inherit from two or more parents.  It's true that some uses of MI can get you into trouble, although hopefully not quite so much trouble with Perl as with dubiously-OO languages like C++.<div class="spacer">
</div>
The way it works is actually pretty simple: just put more than one package name in your @ISA array.  When it comes time for Perl to go finding methods for your object, it looks at each of these packages in order. Well, kinda.  It's actually a fully recursive, depth-first order by default (see mro for alternate method resolution orders). Consider a bunch of @ISA arrays like this:<div class="spacer">
</div>
<br/>
    @First::ISA    = qw( Alpha );<br/>
    @Second::ISA   = qw( Beta );<br/>
    @Third::ISA    = qw( First Second );<br/>
<div class="spacer">
</div>
If you have an object of class Third:<div class="spacer">
</div>
<br/>
    my $ob = Third-&gt;new();<br/>
    $ob-&gt;spin();<br/>
<div class="spacer">
</div>
How do we find a <i>spin()</i> method (or a <i>new()</i> method for that matter)? Because the search is depth-first, classes will be looked up in the following order: Third, First, Alpha, Second, and Beta.<div class="spacer">
</div>
In practice, few class modules have been seen that actually make use of MI.  One nearly always chooses simple containership of one class within another over MI.  That's why our Person object  <i>contained</i> a Fullname object.  That doesn't mean it  <i>was</i> one.<div class="spacer">
</div>
However, there is one particular area where MI in Perl is rampant: borrowing another class's class methods.  This is rather common, especially with some bundled &quot;objectless&quot; classes, like Exporter, DynaLoader, AutoLoader, and SelfLoader.  These classes do not provide constructors; they exist only so you may inherit their class methods.  (It's not entirely clear why inheritance was done here rather than traditional module importation.)<div class="spacer">
</div>
For example, here is the POSIX module's @ISA:<div class="spacer">
</div>
<br/>
    package POSIX;<br/>
    @ISA = qw(Exporter DynaLoader);<br/>
<div class="spacer">
</div>
The POSIX module isn't really an object module, but then, neither are Exporter or DynaLoader.  They're just lending their classes' behaviours to POSIX.<div class="spacer">
</div>
Why don't people use MI for object methods much?  One reason is that it can have complicated side-effects.  For one thing, your inheritance graph (no longer a tree) might converge back to the same base class. Although Perl guards against recursive inheritance, merely having parents who are related to each other via a common ancestor, incestuous though it sounds, is not forbidden.  What if in our Third class shown above we wanted its  <i>new()</i> method to also call both overridden constructors in its two parent classes?  The SUPER notation would only find the first one. Also, what about if the Alpha and Beta classes both had a common ancestor, like Nought?  If you kept climbing up the inheritance tree calling overridden methods, you'd end up calling  <i>Nought::new()</i> twice, which might well be a bad idea.</div>
<div class="subsection">
<h2>UNIVERSAL: The Root of All Objects</h2> Wouldn't it be convenient if all objects were rooted at some ultimate base class?  That way you could give every object common methods without having to go and add it to each and every @ISA.  Well, it turns out that you can.  You don't see it, but Perl tacitly and irrevocably assumes that there's an extra element at the end of @ISA: the class UNIVERSAL. In version 5.003, there were no predefined methods there, but you could put whatever you felt like into it.<div class="spacer">
</div>
However, as of version 5.004 (or some subversive releases, like 5.003_08), UNIVERSAL has some methods in it already.  These are builtin to your Perl binary, so they don't take any extra time to load.  Predefined methods include  <i>isa()</i>, <i>can()</i>, and <i>VERSION()</i>.  <i>isa()</i> tells you whether an object or class &quot;is&quot; another one without having to traverse the hierarchy yourself:<div class="spacer">
</div>
<br/>
   $has_io = $fd-&gt;isa(&quot;IO::Handle&quot;);<br/>
   $itza_handle = IO::Socket-&gt;isa(&quot;IO::Handle&quot;);<br/>
<div class="spacer">
</div>
The <i>can()</i> method, called against that object or class, reports back whether its string argument is a callable method name in that class. In fact, it gives you back a function reference to that method:<div class="spacer">
</div>
<br/>
   $his_print_method = $obj-&gt;can('as_string');<br/>
<div class="spacer">
</div>
Finally, the VERSION method checks whether the class (or the object's class) has a package global called $VERSION that's high enough, as in:<div class="spacer">
</div>
<br/>
    Some_Module-&gt;VERSION(3.0);<br/>
    $his_vers = $ob-&gt;VERSION();<br/>
<div class="spacer">
</div>
However, we don't usually call VERSION ourselves.  (Remember that an all uppercase function name is a Perl convention that indicates that the function will be automatically used by Perl in some way.)  In this case, it happens when you say<div class="spacer">
</div>
<br/>
    use Some_Module 3.0;<br/>
<div class="spacer">
</div>
If you wanted to add version checking to your Person class explained above, just add this to Person.pm:<div class="spacer">
</div>
<br/>
    our $VERSION = '1.1';<br/>
<div class="spacer">
</div>
and then in Employee.pm you can say<div class="spacer">
</div>
<br/>
    use Person 1.1;<br/>
<div class="spacer">
</div>
And it would make sure that you have at least that version number or higher available.   This is not the same as loading in that exact version number.  No mechanism currently exists for concurrent installation of multiple versions of a module.  Lamentably.</div>
<div class="subsection">
<h2>Deeper UNIVERSAL details</h2> It is also valid (though perhaps unwise in most cases) to put other packages' names in @UNIVERSAL::ISA.  These packages will also be implicitly inherited by all classes, just as UNIVERSAL itself is. However, neither UNIVERSAL nor any of its parents from the @ISA tree are explicit base classes of all objects.  To clarify, given the following:<div class="spacer">
</div>
<br/>
    @UNIVERSAL::ISA = ('REALLYUNIVERSAL');<br/>
<br/>
    package REALLYUNIVERSAL;<br/>
    sub special_method { return &quot;123&quot; }<br/>
<br/>
    package Foo;<br/>
    sub normal_method { return &quot;321&quot; }<br/>
<div class="spacer">
</div>
Calling Foo-&gt;<i>special_method()</i> will return &quot;123&quot;, but calling Foo-&gt;isa('REALLYUNIVERSAL') or Foo-&gt;isa('UNIVERSAL') will return false.<div class="spacer">
</div>
If your class is using an alternate mro like C3 (see mro), method resolution within UNIVERSAL / @UNIVERSAL::ISA will still occur in the default depth-first left-to-right manner, after the class's C3 mro is exhausted.<div class="spacer">
</div>
All of the above is made more intuitive by realizing what really happens during method lookup, which is roughly like this ugly pseudo-code:<div class="spacer">
</div>
<br/>
    get_mro(class) {<br/>
        # recurses down the @ISA's starting at class,<br/>
        # builds a single linear array of all<br/>
        # classes to search in the appropriate order.<br/>
        # The method resolution order (mro) to use<br/>
        # for the ordering is whichever mro &quot;class&quot;<br/>
        # has set on it (either default (depth first<br/>
        # l-to-r) or C3 ordering).<br/>
        # The first entry in the list is the class<br/>
        # itself.<br/>
    }<br/>
<br/>
    find_method(class, methname) {<br/>
        foreach $class (get_mro(class)) {<br/>
            if($class-&gt;has_method(methname)) {<br/>
                return ref_to($class-&gt;$methname);<br/>
            }<br/>
        }<br/>
        foreach $class (get_mro(UNIVERSAL)) {<br/>
            if($class-&gt;has_method(methname)) {<br/>
                return ref_to($class-&gt;$methname);<br/>
            }<br/>
        }<br/>
        return undef;<br/>
    }<br/>
<div class="spacer">
</div>
However the code that implements UNIVERSAL::isa does not search in UNIVERSAL itself, only in the package's actual @ISA.</div>
</div>
<div class="section">
<h1>Alternate Object Representations</h1> Nothing requires objects to be implemented as hash references.  An object can be any sort of reference so long as its referent has been suitably blessed.  That means scalar, array, and code references are also fair game.<div class="spacer">
</div>
A scalar would work if the object has only one datum to hold.  An array would work for most cases, but makes inheritance a bit dodgy because you have to invent new indices for the derived classes.<div class="subsection">
<h2>Arrays as Objects</h2> If the user of your class honors the contract and sticks to the advertised interface, then you can change its underlying interface if you feel like it.  Here's another implementation that conforms to the same interface specification.  This time we'll use an array reference instead of a hash reference to represent the object.<div class="spacer">
</div>
<br/>
    package Person;<br/>
    use strict;<br/>
<br/>
    my($NAME, $AGE, $PEERS) = ( 0 .. 2 );<br/>
<br/>
    ############################################<br/>
    ## the object constructor (array version) ##<br/>
    ############################################<br/>
    sub new {<br/>
        my $self = [];<br/>
        $self-&gt;[$NAME]   = undef;  # this is unnecessary<br/>
        $self-&gt;[$AGE]    = undef;  # as is this<br/>
        $self-&gt;[$PEERS]  = [];     # but this isn't, really<br/>
        bless($self);<br/>
        return $self;<br/>
    }<br/>
<br/>
    sub name {<br/>
        my $self = shift;<br/>
        if (@_) { $self-&gt;[$NAME] = shift }<br/>
        return $self-&gt;[$NAME];<br/>
    }<br/>
<br/>
    sub age {<br/>
        my $self = shift;<br/>
        if (@_) { $self-&gt;[$AGE] = shift }<br/>
        return $self-&gt;[$AGE];<br/>
    }<br/>
<br/>
    sub peers {<br/>
        my $self = shift;<br/>
        if (@_) { @{ $self-&gt;[$PEERS] } = @_ }<br/>
        return @{ $self-&gt;[$PEERS] };<br/>
    }<br/>
<br/>
    1;  # so the require or use succeeds<br/>
<div class="spacer">
</div>
You might guess that the array access would be a lot faster than the hash access, but they're actually comparable.  The array is a  <i>little</i> bit faster, but not more than ten or fifteen percent, even when you replace the variables above like $AGE with literal numbers, like 1. A bigger difference between the two approaches can be found in memory use. A hash representation takes up more memory than an array representation because you have to allocate memory for the keys as well as for the values. However, it really isn't that bad, especially since as of version 5.004, memory is only allocated once for a given hash key, no matter how many hashes have that key.  It's expected that sometime in the future, even these differences will fade into obscurity as more efficient underlying representations are devised.<div class="spacer">
</div>
Still, the tiny edge in speed (and somewhat larger one in memory) is enough to make some programmers choose an array representation for simple classes.  There's still a little problem with scalability, though, because later in life when you feel like creating subclasses, you'll find that hashes just work out better.</div>
<div class="subsection">
<h2>Closures as Objects</h2> Using a code reference to represent an object offers some fascinating possibilities.  We can create a new anonymous function (closure) who alone in all the world can see the object's data.  This is because we put the data into an anonymous hash that's lexically visible only to the closure we create, bless, and return as the object.  This object's methods turn around and call the closure as a regular subroutine call, passing it the field we want to affect.  (Yes, the double-function call is slow, but if you wanted fast, you wouldn't be using objects at all, eh? :-)<div class="spacer">
</div>
Use would be similar to before:<div class="spacer">
</div>
<br/>
    use Person;<br/>
    $him = Person-&gt;new();<br/>
    $him-&gt;name(&quot;Jason&quot;);<br/>
    $him-&gt;age(23);<br/>
    $him-&gt;peers( [ &quot;Norbert&quot;, &quot;Rhys&quot;, &quot;Phineas&quot; ] );<br/>
    printf &quot;%s is %d years old.\n&quot;, $him-&gt;name, $him-&gt;age;<br/>
    print &quot;His peers are: &quot;, join(&quot;, &quot;, @{$him-&gt;peers}), &quot;\n&quot;;<br/>
<div class="spacer">
</div>
but the implementation would be radically, perhaps even sublimely different:<div class="spacer">
</div>
<br/>
    package Person;<br/>
<br/>
    sub new {<br/>
         my $class  = shift;<br/>
         my $self = {<br/>
            NAME  =&gt; undef,<br/>
            AGE   =&gt; undef,<br/>
            PEERS =&gt; [],<br/>
         };<br/>
         my $closure = sub {<br/>
            my $field = shift;<br/>
            if (@_) { $self-&gt;{$field} = shift }<br/>
            return    $self-&gt;{$field};<br/>
        };<br/>
        bless($closure, $class);<br/>
        return $closure;<br/>
    }<br/>
<br/>
    sub name   { &amp;{ $_[0] }(&quot;NAME&quot;,  @_[ 1 .. $#_ ] ) }<br/>
    sub age    { &amp;{ $_[0] }(&quot;AGE&quot;,   @_[ 1 .. $#_ ] ) }<br/>
    sub peers  { &amp;{ $_[0] }(&quot;PEERS&quot;, @_[ 1 .. $#_ ] ) }<br/>
<br/>
    1;<br/>
<div class="spacer">
</div>
Because this object is hidden behind a code reference, it's probably a bit mysterious to those whose background is more firmly rooted in standard procedural or object-based programming languages than in functional programming languages whence closures derive.  The object created and returned by the  <i>new()</i> method is itself not a data reference as we've seen before.  It's an anonymous code reference that has within it access to a specific version (lexical binding and instantiation) of the object's data, which are stored in the private variable $self. Although this is the same function each time, it contains a different version of $self.<div class="spacer">
</div>
When a method like &quot;$him-&gt;name(&quot;Jason&quot;)&quot; is called, its implicit zeroth argument is the invoking object--just as it is with all method calls.  But in this case, it's our code reference (something like a function pointer in C++, but with deep binding of lexical variables). There's not a lot to be done with a code reference beyond calling it, so that's just what we do when we say &quot;&amp;{$_[0]}&quot;.  This is just a regular function call, not a method call.  The initial argument is the string &quot;NAME&quot;, and any remaining arguments are whatever had been passed to the method itself.<div class="spacer">
</div>
Once we're executing inside the closure that had been created in <i>new()</i>, the $self hash reference suddenly becomes visible.  The closure grabs its first argument (&quot;NAME&quot; in this case because that's what the  <i>name()</i> method passed it), and uses that string to subscript into the private hash hidden in its unique version of $self.<div class="spacer">
</div>
Nothing under the sun will allow anyone outside the executing method to be able to get at this hidden data.  Well, nearly nothing.  You  <i>could</i> single step through the program using the debugger and find out the pieces while you're in the method, but everyone else is out of luck.<div class="spacer">
</div>
There, if that doesn't excite the Scheme folks, then I just don't know what will.  Translation of this technique into C++, Java, or any other braindead-static language is left as a futile exercise for aficionados of those camps.<div class="spacer">
</div>
You could even add a bit of nosiness via the <i>caller()</i> function and make the closure refuse to operate unless called via its own package. This would no doubt satisfy certain fastidious concerns of programming police and related puritans.<div class="spacer">
</div>
If you were wondering when Hubris, the third principle virtue of a programmer, would come into play, here you have it. (More seriously, Hubris is just the pride in craftsmanship that comes from having written a sound bit of well-designed code.)</div>
</div>
<div class="section">
<h1>AUTOLOAD: Proxy Methods</h1> Autoloading is a way to intercept calls to undefined methods.  An autoload routine may choose to create a new function on the fly, either loaded from disk or perhaps just  <i>eval()</i>ed right there.  This define-on-the-fly strategy is why it's called autoloading.<div class="spacer">
</div>
But that's only one possible approach.  Another one is to just have the autoloaded method itself directly provide the requested service.  When used in this way, you may think of autoloaded methods as &quot;proxy&quot; methods.<div class="spacer">
</div>
When Perl tries to call an undefined function in a particular package and that function is not defined, it looks for a function in that same package called AUTOLOAD.  If one exists, it's called with the same arguments as the original function would have had. The fully-qualified name of the function is stored in that package's global variable $AUTOLOAD.  Once called, the function can do anything it would like, including defining a new function by the right name, and then doing a really fancy kind of &quot;goto&quot; right to it, erasing itself from the call stack.<div class="spacer">
</div>
What does this have to do with objects?  After all, we keep talking about functions, not methods.  Well, since a method is just a function with an extra argument and some fancier semantics about where it's found, we can use autoloading for methods, too.  Perl doesn't start looking for an AUTOLOAD method until it has exhausted the recursive hunt up through @ISA, though.  Some programmers have even been known to define a UNIVERSAL::AUTOLOAD method to trap unresolved method calls to any kind of object.<div class="subsection">
<h2>Autoloaded Data Methods</h2> You probably began to get a little suspicious about the duplicated code way back earlier when we first showed you the Person class, and then later the Employee class.  Each method used to access the hash fields looked virtually identical.  This should have tickled that great programming virtue, Impatience, but for the time, we let Laziness win out, and so did nothing.  Proxy methods can cure this.<div class="spacer">
</div>
Instead of writing a new function every time we want a new data field, we'll use the autoload mechanism to generate (actually, mimic) methods on the fly.  To verify that we're accessing a valid member, we will check against an &quot;_permitted&quot; (pronounced &quot;under-permitted&quot;) field, which is a reference to a file-scoped lexical (like a C file static) hash of permitted fields in this record called %fields.  Why the underscore?  For the same reason as the _CENSUS field we once used: as a marker that means &quot;for internal use only&quot;.<div class="spacer">
</div>
Here's what the module initialization code and class constructor will look like when taking this approach:<div class="spacer">
</div>
<br/>
    package Person;<br/>
    use Carp;<br/>
    our $AUTOLOAD;  # it's a package global<br/>
<br/>
    my %fields = (<br/>
        name        =&gt; undef,<br/>
        age         =&gt; undef,<br/>
        peers       =&gt; undef,<br/>
    );<br/>
<br/>
    sub new {<br/>
        my $class = shift;<br/>
        my $self  = {<br/>
            _permitted =&gt; \%fields,<br/>
            %fields,<br/>
        };<br/>
        bless $self, $class;<br/>
        return $self;<br/>
    }<br/>
<div class="spacer">
</div>
If we wanted our record to have default values, we could fill those in where current we have &quot;undef&quot; in the %fields hash.<div class="spacer">
</div>
Notice how we saved a reference to our class data on the object itself? Remember that it's important to access class data through the object itself instead of having any method reference %fields directly, or else you won't have a decent inheritance.<div class="spacer">
</div>
The real magic, though, is going to reside in our proxy method, which will handle all calls to undefined methods for objects of class Person (or subclasses of Person).  It has to be called AUTOLOAD.  Again, it's all caps because it's called for us implicitly by Perl itself, not by a user directly.<div class="spacer">
</div>
<br/>
    sub AUTOLOAD {<br/>
        my $self = shift;<br/>
        my $type = ref($self)<br/>
                    or croak &quot;$self is not an object&quot;;<br/>
<br/>
        my $name = $AUTOLOAD;<br/>
        $name =~ s/.*://;   # strip fully-qualified portion<br/>
<br/>
        unless (exists $self-&gt;{_permitted}-&gt;{$name} ) {<br/>
            croak &quot;Can't access `$name' field in class $type&quot;;<br/>
        }<br/>
<br/>
        if (@_) {<br/>
            return $self-&gt;{$name} = shift;<br/>
        } else {<br/>
            return $self-&gt;{$name};<br/>
        }<br/>
    }<br/>
<div class="spacer">
</div>
Pretty nifty, eh?  All we have to do to add new data fields is modify %fields.  No new functions need be written.<div class="spacer">
</div>
I could have avoided the &quot;_permitted&quot; field entirely, but I wanted to demonstrate how to store a reference to class data on the object so you wouldn't have to access that class data directly from an object method.</div>
<div class="subsection">
<h2>Inherited Autoloaded Data Methods</h2> But what about inheritance?  Can we define our Employee class similarly?  Yes, so long as we're careful enough.<div class="spacer">
</div>
Here's how to be careful:<div class="spacer">
</div>
<br/>
    package Employee;<br/>
    use Person;<br/>
    use strict;<br/>
    our @ISA = qw(Person);<br/>
<br/>
    my %fields = (<br/>
        id          =&gt; undef,<br/>
        salary      =&gt; undef,<br/>
    );<br/>
<br/>
    sub new {<br/>
        my $class = shift;<br/>
        my $self  = $class-&gt;SUPER::new();<br/>
        my($element);<br/>
        foreach $element (keys %fields) {<br/>
            $self-&gt;{_permitted}-&gt;{$element} = $fields{$element};<br/>
        }<br/>
        @{$self}{keys %fields} = values %fields;<br/>
        return $self;<br/>
    }<br/>
<div class="spacer">
</div>
Once we've done this, we don't even need to have an AUTOLOAD function in the Employee package, because we'll grab Person's version of that via inheritance, and it will all work out just fine.</div>
</div>
<div class="section">
<h1>Metaclassical Tools</h1> Even though proxy methods can provide a more convenient approach to making more struct-like classes than tediously coding up data methods as functions, it still leaves a bit to be desired.  For one thing, it means you have to handle bogus calls that you don't mean to trap via your proxy. It also means you have to be quite careful when dealing with inheritance, as detailed above.<div class="spacer">
</div>
Perl programmers have responded to this by creating several different class construction classes.  These metaclasses are classes that create other classes.  A couple worth looking at are Class::Struct and Alias.  These and other related metaclasses can be found in the modules directory on CPAN.<div class="subsection">
<h2>Class::Struct</h2> One of the older ones is Class::Struct.  In fact, its syntax and interface were sketched out long before perl5 even solidified into a real thing.  What it does is provide you a way to &quot;declare&quot; a class as having objects whose fields are of a specific type.  The function that does this is called, not surprisingly enough,  <i>struct()</i>.  Because structures or records are not base types in Perl, each time you want to create a class to provide a record-like data object, you yourself have to define a  <i>new()</i> method, plus separate data-access methods for each of that record's fields.  You'll quickly become bored with this process. The  <i>Class::Struct::struct()</i> function alleviates this tedium.<div class="spacer">
</div>
Here's a simple example of using it:<div class="spacer">
</div>
<br/>
    use Class::Struct qw(struct);<br/>
    use Jobbie;  # user-defined; see below<br/>
<br/>
    struct 'Fred' =&gt; {<br/>
        one        =&gt; '$',<br/>
        many       =&gt; '@',<br/>
        profession =&gt; 'Jobbie',  # does not call Jobbie-&gt;new()<br/>
    };<br/>
<br/>
    $ob = Fred-&gt;new(profession =&gt; Jobbie-&gt;new());<br/>
    $ob-&gt;one(&quot;hmmmm&quot;);<br/>
<br/>
    $ob-&gt;many(0, &quot;here&quot;);<br/>
    $ob-&gt;many(1, &quot;you&quot;);<br/>
    $ob-&gt;many(2, &quot;go&quot;);<br/>
    print &quot;Just set: &quot;, $ob-&gt;many(2), &quot;\n&quot;;<br/>
<br/>
    $ob-&gt;profession-&gt;salary(10_000);<br/>
<div class="spacer">
</div>
You can declare types in the struct to be basic Perl types, or user-defined types (classes).  User types will be initialized by calling that class's  <i>new()</i> method.<div class="spacer">
</div>
Take care that the &quot;Jobbie&quot; object is not created automatically by the &quot;Fred&quot; class's  <i>new()</i> method, so you should specify a &quot;Jobbie&quot; object when you create an instance of &quot;Fred&quot;.<div class="spacer">
</div>
Here's a real-world example of using struct generation.  Let's say you wanted to override Perl's idea of  <i>gethostbyname()</i> and <i>gethostbyaddr()</i> so that they would return objects that acted like C structures.  We don't care about high-falutin' OO gunk.  All we want is for these objects to act like structs in the C sense.<div class="spacer">
</div>
<br/>
    use Socket;<br/>
    use Net::hostent;<br/>
    $h = gethostbyname(&quot;perl.com&quot;);  # object return<br/>
    printf &quot;perl.com's real name is %s, address %s\n&quot;,<br/>
        $h-&gt;name, inet_ntoa($h-&gt;addr);<br/>
<div class="spacer">
</div>
Here's how to do this using the Class::Struct module. The crux is going to be this call:<div class="spacer">
</div>
<br/>
    struct 'Net::hostent' =&gt; [          # note bracket<br/>
        name       =&gt; '$',<br/>
        aliases    =&gt; '@',<br/>
        addrtype   =&gt; '$',<br/>
        'length'   =&gt; '$',<br/>
        addr_list  =&gt; '@',<br/>
     ];<br/>
<div class="spacer">
</div>
Which creates object methods of those names and types. It even creates a  <i>new()</i> method for us.<div class="spacer">
</div>
We could also have implemented our object this way:<div class="spacer">
</div>
<br/>
    struct 'Net::hostent' =&gt; {          # note brace<br/>
        name       =&gt; '$',<br/>
        aliases    =&gt; '@',<br/>
        addrtype   =&gt; '$',<br/>
        'length'   =&gt; '$',<br/>
        addr_list  =&gt; '@',<br/>
     };<br/>
<div class="spacer">
</div>
and then Class::Struct would have used an anonymous hash as the object type, instead of an anonymous array.  The array is faster and smaller, but the hash works out better if you eventually want to do inheritance. Since for this struct-like object we aren't planning on inheritance, this time we'll opt for better speed and size over better flexibility.<div class="spacer">
</div>
Here's the whole implementation:<div class="spacer">
</div>
<br/>
    package Net::hostent;<br/>
    use strict;<br/>
<br/>
    BEGIN {<br/>
        use Exporter   ();<br/>
        our @EXPORT      = qw(gethostbyname gethostbyaddr gethost);<br/>
        our @EXPORT_OK   = qw(<br/>
                               $h_name         @h_aliases<br/>
                               $h_addrtype     $h_length<br/>
                               @h_addr_list    $h_addr<br/>
                           );<br/>
        our %EXPORT_TAGS = ( FIELDS =&gt; [ @EXPORT_OK, @EXPORT ] );<br/>
    }<br/>
    our @EXPORT_OK;<br/>
<br/>
    # Class::Struct forbids use of @ISA<br/>
    sub import { goto &amp;Exporter::import }<br/>
<br/>
    use Class::Struct qw(struct);<br/>
    struct 'Net::hostent' =&gt; [<br/>
       name        =&gt; '$',<br/>
       aliases     =&gt; '@',<br/>
       addrtype    =&gt; '$',<br/>
       'length'    =&gt; '$',<br/>
       addr_list   =&gt; '@',<br/>
    ];<br/>
<br/>
    sub addr { shift-&gt;addr_list-&gt;[0] }<br/>
<br/>
    sub populate (@) {<br/>
        return unless @_;<br/>
        my $hob = new();  # Class::Struct made this!<br/>
        $h_name     =    $hob-&gt;[0]              = $_[0];<br/>
        @h_aliases  = @{ $hob-&gt;[1] } = split ' ', $_[1];<br/>
        $h_addrtype =    $hob-&gt;[2]              = $_[2];<br/>
        $h_length   =    $hob-&gt;[3]              = $_[3];<br/>
        $h_addr     =                             $_[4];<br/>
        @h_addr_list = @{ $hob-&gt;[4] } =         @_[ (4 .. $#_) ];<br/>
        return $hob;<br/>
    }<br/>
<br/>
    sub gethostbyname ($)  { populate(CORE::gethostbyname(shift)) }<br/>
<br/>
    sub gethostbyaddr ($;$) {<br/>
        my ($addr, $addrtype);<br/>
        $addr = shift;<br/>
        require Socket unless @_;<br/>
        $addrtype = @_ ? shift : Socket::AF_INET();<br/>
        populate(CORE::gethostbyaddr($addr, $addrtype))<br/>
    }<br/>
<br/>
    sub gethost($) {<br/>
        if ($_[0] =~ /^\d+(?:\.\d+(?:\.\d+(?:\.\d+)?)?)?$/) {<br/>
           require Socket;<br/>
           &amp;gethostbyaddr(Socket::inet_aton(shift));<br/>
        } else {<br/>
           &amp;gethostbyname;<br/>
        }<br/>
    }<br/>
<br/>
    1;<br/>
<div class="spacer">
</div>
We've snuck in quite a fair bit of other concepts besides just dynamic class creation, like overriding core functions, import/export bits, function prototyping, short-cut function call via &amp;whatever, and function replacement with &quot;goto &amp;whatever&quot;.  These all mostly make sense from the perspective of a traditional module, but as you can see, we can also use them in an object module.<div class="spacer">
</div>
You can look at other object-based, struct-like overrides of core functions in the 5.004 release of Perl in File::stat, Net::hostent, Net::netent, Net::protoent, Net::servent, Time::gmtime, Time::localtime, User::grent, and User::pwent.  These modules have a final component that's all lowercase, by convention reserved for compiler pragmas, because they affect the compilation and change a builtin function. They also have the type names that a C programmer would most expect.</div>
<div class="subsection">
<h2>Data Members as Variables</h2> If you're used to C++ objects, then you're accustomed to being able to get at an object's data members as simple variables from within a method. The Alias module provides for this, as well as a good bit more, such as the possibility of private methods that the object can call but folks outside the class cannot.<div class="spacer">
</div>
Here's an example of creating a Person using the Alias module. When you update these magical instance variables, you automatically update value fields in the hash.  Convenient, eh?<div class="spacer">
</div>
<br/>
    package Person;<br/>
<br/>
    # this is the same as before...<br/>
    sub new {<br/>
         my $class = shift;<br/>
         my $self = {<br/>
            NAME  =&gt; undef,<br/>
            AGE   =&gt; undef,<br/>
            PEERS =&gt; [],<br/>
        };<br/>
        bless($self, $class);<br/>
        return $self;<br/>
    }<br/>
<br/>
    use Alias qw(attr);<br/>
    our ($NAME, $AGE, $PEERS);<br/>
<br/>
    sub name {<br/>
        my $self = attr shift;<br/>
        if (@_) { $NAME = shift; }<br/>
        return    $NAME;<br/>
    }<br/>
<br/>
    sub age {<br/>
        my $self = attr shift;<br/>
        if (@_) { $AGE = shift; }<br/>
        return    $AGE;<br/>
    }<br/>
<br/>
    sub peers {<br/>
        my $self = attr shift;<br/>
        if (@_) { @PEERS = @_; }<br/>
        return    @PEERS;<br/>
    }<br/>
<br/>
    sub exclaim {<br/>
        my $self = attr shift;<br/>
        return sprintf &quot;Hi, I'm %s, age %d, working with %s&quot;,<br/>
            $NAME, $AGE, join(&quot;, &quot;, @PEERS);<br/>
    }<br/>
<br/>
    sub happy_birthday {<br/>
        my $self = attr shift;<br/>
        return ++$AGE;<br/>
    }<br/>
<div class="spacer">
</div>
The need for the &quot;our&quot; declaration is because what Alias does is play with package globals with the same name as the fields.  To use globals while &quot;use strict&quot; is in effect, you have to predeclare them. These package variables are localized to the block enclosing the  <i>attr()</i> call just as if you'd used a  <i>local()</i> on them.  However, that means that they're still considered global variables with temporary values, just as with any other  <i>local()</i>.<div class="spacer">
</div>
It would be nice to combine Alias with something like Class::Struct or Class::MethodMaker.</div>
</div>
<div class="section">
<h1>NOTES</h1><div class="subsection">
<h2>Object Terminology</h2> In the various OO literature, it seems that a lot of different words are used to describe only a few different concepts.  If you're not already an object programmer, then you don't need to worry about all these fancy words.  But if you are, then you might like to know how to get at the same concepts in Perl.<div class="spacer">
</div>
For example, it's common to call an object an <i>instance</i> of a class and to call those objects' methods  <i>instance methods</i>.  Data fields peculiar to each object are often called  <i>instance data</i> or <i>object</i>  <i>attributes</i>, and data fields common to all members of that class are  <i>class data</i>, <i>class attributes</i>, or <i>static data members</i>.<div class="spacer">
</div>
Also, <i>base class</i>, <i>generic class</i>, and <i>superclass</i> all describe the same notion, whereas  <i>derived class</i>, <i>specific class</i>, and  <i>subclass</i> describe the other related one.<div class="spacer">
</div>
C++ programmers have <i>static methods</i> and <i>virtual methods</i>, but Perl only has  <i>class methods</i> and <i>object methods</i>. Actually, Perl only has methods.  Whether a method gets used as a class or object method is by usage only.  You could accidentally call a class method (one expecting a string argument) on an object (one expecting a reference), or vice versa.<div class="spacer">
</div>
From the C++ perspective, all methods in Perl are virtual. This, by the way, is why they are never checked for function prototypes in the argument list as regular builtin and user-defined functions can be.<div class="spacer">
</div>
Because a class is itself something of an object, Perl's classes can be taken as describing both a &quot;class as meta-object&quot; (also called  <i>object</i>  <i>factory</i>) philosophy and the &quot;class as type definition&quot; (<i>declaring</i> behaviour, not  <i>defining</i> mechanism) idea.  C++ supports the latter notion, but not the former.</div>
</div>
<div class="section">
<h1>SEE ALSO</h1> The following manpages will doubtless provide more background for this one: perlmod, perlref, perlobj, perlbot, perltie, and overload.<div class="spacer">
</div>
perlboot is a kinder, gentler introduction to object-oriented programming.<div class="spacer">
</div>
perltooc provides more detail on class data.<div class="spacer">
</div>
Some modules which might prove interesting are Class::Accessor, Class::Class, Class::Contract, Class::Data::Inheritable, Class::MethodMaker and Tie::SecureHash</div>
<div class="section">
<h1>AUTHOR AND COPYRIGHT</h1> Copyright (c) 1997, 1998 Tom Christiansen All rights reserved.<div class="spacer">
</div>
This documentation is free; you can redistribute it and/or modify it under the same terms as Perl itself.<div class="spacer">
</div>
Irrespective of its distribution, all code examples in this file are hereby placed into the public domain.  You are permitted and encouraged to use this code in your own programs for fun or for profit as you see fit.  A simple comment in the code giving credit would be courteous but is not required.</div>
<div class="section">
<h1>COPYRIGHT</h1><div class="subsection">
<h2>Acknowledgments</h2> Thanks to Larry Wall, Roderick Schertler, Gurusamy Sarathy, Dean Roehrich, Raphael Manfredi, Brent Halsey, Greg Bacon, Brad Appleton, and many others for their helpful comments.</div>
</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-09-26</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

