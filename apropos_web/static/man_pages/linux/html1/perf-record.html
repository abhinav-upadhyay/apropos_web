<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
PERF-RECORD(1)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
PERF-RECORD(1)</td>
<td class="head-vol">
perf Manual</td>
<td class="head-rtitle">
PERF-RECORD(1)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> perf-record - Run a command and record its profile into perf.data</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
<i>perf record</i> [-e &lt;EVENT&gt; | --event=EVENT] [-l] [-a] &lt;command&gt;<br/>
<i>perf record</i> [-e &lt;EVENT&gt; | --event=EVENT] [-l] [-a] &#8212; &lt;command&gt; [&lt;options&gt;]<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> This command runs a command and gathers a performance counter profile from it, into perf.data - without displaying anything.<div style="height: 1.00em;">
&#160;</div>
This file can then be inspected later on, using <i>perf report</i>.</div>
<div class="section">
<h1>OPTIONS</h1> &lt;command&gt;...<div style="margin-left: 4.00ex;">
Any command you can specify in a shell.</div>
<div class="spacer">
</div>
-e, --event=<div style="margin-left: 4.00ex;">
Select the PMU event. Selection can be:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
&#8226;a symbolic event name (use  <i>perf list</i> to list all events)</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
&#8226;a raw PMU event (eventsel+umask) in the form of rNNN where NNN is a hexadecimal event descriptor.</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
&#8226;a hardware breakpoint event in the form of  <i>\mem:addr[:access]</i> where addr is the address in memory you want to break in. Access is the memory access type (read, write, execute) it can be passed as follows:  <i>\mem:addr[:[r][w][x]]</i>. If you want to profile read-write accesses in 0x1000, just set  <i>mem:0x1000:rw</i>.</div>
</div>
<div class="spacer">
</div>
--filter=&lt;filter&gt;<div style="margin-left: 4.00ex;">
Event filter.</div>
<div class="spacer">
</div>
-a, --all-cpus<div style="margin-left: 4.00ex;">
System-wide collection from all CPUs.</div>
<div class="spacer">
</div>
-l<div style="margin-left: 4.00ex;">
Scale counter values.</div>
<div class="spacer">
</div>
-p, --pid=<div style="margin-left: 4.00ex;">
Record events on existing process ID.</div>
<div class="spacer">
</div>
-t, --tid=<div style="margin-left: 4.00ex;">
Record events on existing thread ID.</div>
<div class="spacer">
</div>
-r, --realtime=<div style="margin-left: 4.00ex;">
Collect data with this RT SCHED_FIFO priority.</div>
<div class="spacer">
</div>
-D, --no-delay<div style="margin-left: 4.00ex;">
Collect data without buffering.</div>
<div class="spacer">
</div>
-A, --append<div style="margin-left: 4.00ex;">
Append to the output file to do incremental profiling.</div>
<div class="spacer">
</div>
-f, --force<div style="margin-left: 4.00ex;">
Overwrite existing data file. (deprecated)</div>
<div class="spacer">
</div>
-c, --count=<div style="margin-left: 4.00ex;">
Event period to sample.</div>
<div class="spacer">
</div>
-o, --output=<div style="margin-left: 4.00ex;">
Output file name.</div>
<div class="spacer">
</div>
-i, --no-inherit<div style="margin-left: 4.00ex;">
Child tasks do not inherit counters.</div>
<div class="spacer">
</div>
-F, --freq=<div style="margin-left: 4.00ex;">
Profile at this frequency.</div>
<div class="spacer">
</div>
-m, --mmap-pages=<div style="margin-left: 4.00ex;">
Number of mmap data pages.</div>
<div class="spacer">
</div>
-g, --call-graph<div style="margin-left: 4.00ex;">
Do call-graph (stack chain/backtrace) recording.</div>
<div class="spacer">
</div>
-q, --quiet<div style="margin-left: 4.00ex;">
Don&#8217;t print any message, useful for scripting.</div>
<div class="spacer">
</div>
-v, --verbose<div style="margin-left: 4.00ex;">
Be more verbose (show counter open errors, etc).</div>
<div class="spacer">
</div>
-s, --stat<div style="margin-left: 4.00ex;">
Per thread counts.</div>
<div class="spacer">
</div>
-d, --data<div style="margin-left: 4.00ex;">
Sample addresses.</div>
<div class="spacer">
</div>
-T, --timestamp<div style="margin-left: 4.00ex;">
Sample timestamps. Use it with  <i>perf report -D</i> to see the timestamps, for instance.</div>
<div class="spacer">
</div>
-n, --no-samples<div style="margin-left: 4.00ex;">
Don&#8217;t sample.</div>
<div class="spacer">
</div>
-R, --raw-samples<div style="margin-left: 4.00ex;">
Collect raw sample records from all opened counters (default for tracepoint counters).</div>
<div class="spacer">
</div>
-C, --cpu<div style="margin-left: 4.00ex;">
Collect samples only on the list of CPUs provided. Multiple CPUs can be provided as a comma-separated list with no space: 0,1. Ranges of CPUs are specified with -: 0-2. In per-thread mode with inheritance mode on (default), samples are captured only when the thread executes on the designated CPUs. Default is to monitor all CPUs.</div>
<div class="spacer">
</div>
-N, --no-buildid-cache<div style="margin-left: 4.00ex;">
Do not update the builid cache. This saves some overhead in situations where the information in the perf.data file (which includes buildids) is sufficient.</div>
<div class="spacer">
</div>
-G name,..., --cgroup name,...<div style="margin-left: 4.00ex;">
monitor only in the container (cgroup) called &quot;name&quot;. This option is available only in per-cpu mode. The cgroup filesystem must be mounted. All threads belonging to container &quot;name&quot; are monitored when they run on the monitored CPUs. Multiple cgroups can be provided. Each cgroup is applied to the corresponding event, i.e., first cgroup to first event, second cgroup to second event and so on. It is possible to provide an empty cgroup (monitor all the time) using, e.g., -G foo,,bar. Cgroups must have corresponding events, i.e., they always refer to events defined earlier on the command line.</div>
</div>
<div class="section">
<h1>SEE ALSO</h1>  <b>perf-stat</b>(1), <b>perf-list</b>(1)</div>
<table class="foot">
<tr>
<td class="foot-date">
03/10/2016</td>
<td class="foot-os">
perf 3.2.76</td>
</tr>
</table>
</div>
</body>
</html>

