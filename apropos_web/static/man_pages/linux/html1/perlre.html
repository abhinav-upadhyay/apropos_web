<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
PERLRE(1)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
PERLRE(1)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
PERLRE(1)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> perlre - Perl regular expressions</div>
<div class="section">
<h1>DESCRIPTION</h1> This page describes the syntax of regular expressions in Perl.<div class="spacer">
</div>
If you haven't used regular expressions before, a quick-start introduction is available in perlrequick, and a longer tutorial introduction is available in perlretut.<div class="spacer">
</div>
For reference on how regular expressions are used in matching operations, plus various examples of the same, see discussions of &quot;m//&quot;, &quot;s///&quot;, &quot;qr//&quot; and &quot;??&quot; in &quot;Regexp Quote-Like Operators&quot; in perlop.<div class="subsection">
<h2>Modifiers</h2> Matching operations can have various modifiers.  Modifiers that relate to the interpretation of the regular expression inside are listed below.  Modifiers that alter the way a regular expression is used by Perl are detailed in &quot;Regexp Quote-Like Operators&quot; in perlop and &quot;Gory details of parsing quoted constructs&quot; in perlop.<dl>
<dt>
m</dt>
<dd>
Treat string as multiple lines.  That is, change &quot;^&quot; and &quot;$&quot; from matching the start or end of the string to matching the start or end of any line anywhere within the string.</dd>
</dl>
<dl>
<dt>
s</dt>
<dd>
Treat string as single line.  That is, change &quot;.&quot; to match any character whatsoever, even a newline, which normally it would not match.<div style="height: 1.00em;">
&#160;</div>
Used together, as &quot;/ms&quot;, they let the &quot;.&quot; match any character whatsoever, while still allowing &quot;^&quot; and &quot;$&quot; to match, respectively, just after and just before newlines within the string.</dd>
</dl>
<dl>
<dt>
i</dt>
<dd>
Do case-insensitive pattern matching.<div style="height: 1.00em;">
&#160;</div>
If locale matching rules are in effect, the case map is taken from the current locale for code points less than 255, and from Unicode rules for larger code points.  However, matches that would cross the Unicode rules/non-Unicode rules boundary (ords 255/256) will not succeed.  See perllocale.<div style="height: 1.00em;">
&#160;</div>
There are a number of Unicode characters that match multiple characters under &quot;/i&quot;.  For example, &quot;LATIN SMALL LIGATURE FI&quot; should match the sequence &quot;fi&quot;.  Perl is not currently able to do this when the multiple characters are in the pattern and are split between groupings, or when one or more are quantified.  Thus<div style="height: 1.00em;">
&#160;</div>
<br/>
 &quot;\N{LATIN SMALL LIGATURE FI}&quot; =~ /fi/i;          # Matches<br/>
 &quot;\N{LATIN SMALL LIGATURE FI}&quot; =~ /[fi][fi]/i;    # Doesn't match!<br/>
 &quot;\N{LATIN SMALL LIGATURE FI}&quot; =~ /fi*/i;         # Doesn't match!<br/>
<br/>
 # The below doesn't match, and it isn't clear what $1 and $2 would<br/>
 # be even if it did!!<br/>
 &quot;\N{LATIN SMALL LIGATURE FI}&quot; =~ /(f)(i)/i;      # Doesn't match!<br/>
<div style="height: 1.00em;">
&#160;</div>
Perl doesn't match multiple characters in an inverted bracketed character class, which otherwise could be highly confusing.  See &quot;Negation&quot; in perlrecharclass.<div style="height: 1.00em;">
&#160;</div>
Also, Perl matching doesn't fully conform to the current Unicode &quot;/i&quot; recommendations, which ask that the matching be made upon the NFD (Normalization Form Decomposed) of the text.  However, Unicode is in the process of reconsidering and revising their recommendations.</dd>
</dl>
<dl>
<dt>
x</dt>
<dd>
Extend your pattern's legibility by permitting whitespace and comments. Details in &quot;/x&quot;</dd>
</dl>
<dl>
<dt>
p</dt>
<dd>
Preserve the string matched such that ${^PREMATCH}, ${^MATCH}, and ${^POSTMATCH} are available for use after matching.</dd>
</dl>
<dl>
<dt>
g and c</dt>
<dd>
Global matching, and keep the Current position after failed matching. Unlike i, m, s and x, these two flags affect the way the regex is used rather than the regex itself. See &quot;Using regular expressions in Perl&quot; in perlretut for further explanation of the g and c modifiers.</dd>
</dl>
<dl>
<dt>
a, d, l and u</dt>
<dd>
These modifiers, new in 5.14, affect which character-set semantics (Unicode, ASCII, etc.) are used, as described below in &quot;Character set modifiers&quot;.</dd>
</dl>
<div class="spacer">
</div>
These are usually written as &quot;the &quot;/x&quot; modifier&quot;, even though the delimiter in question might not really be a slash.  The modifiers &quot;/imsxadlup&quot; may also be embedded within the regular expression itself using the &quot;(?...)&quot; construct, see &quot;Extended Patterns&quot; below.<div class="spacer">
</div>
The &quot;/x&quot;, &quot;/l&quot;, &quot;/u&quot;, &quot;/a&quot; and &quot;/d&quot; modifiers need a little more explanation.<div class="spacer">
</div>
<i>/x</i><div class="spacer">
</div>
&quot;/x&quot; tells the regular expression parser to ignore most whitespace that is neither backslashed nor within a character class.  You can use this to break up your regular expression into (slightly) more readable parts.  The &quot;#&quot; character is also treated as a metacharacter introducing a comment, just as in ordinary Perl code.  This also means that if you want real whitespace or &quot;#&quot; characters in the pattern (outside a character class, where they are unaffected by &quot;/x&quot;), then you'll either have to escape them (using backslashes or &quot;\Q...\E&quot;) or encode them using octal, hex, or &quot;\N{}&quot; escapes.  Taken together, these features go a long way towards making Perl's regular expressions more readable.  Note that you have to be careful not to include the pattern delimiter in the comment--perl has no way of knowing you did not intend to close the pattern early.  See the C-comment deletion code in perlop.  Also note that anything inside a &quot;\Q...\E&quot; stays unaffected by &quot;/x&quot;.  And note that &quot;/x&quot; doesn't affect space interpretation within a single multi-character construct.  For example in &quot;\x{...}&quot;, regardless of the &quot;/x&quot; modifier, there can be no spaces.  Same for a quantifier such as &quot;{3}&quot; or &quot;{5,}&quot;.  Similarly, &quot;(?:...)&quot; can't have a space between the &quot;?&quot; and &quot;:&quot;, but can between the &quot;(&quot; and &quot;?&quot;.  Within any delimiters for such a construct, allowed spaces are not affected by &quot;/x&quot;, and depend on the construct.  For example, &quot;\x{...}&quot; can't have spaces because hexadecimal numbers don't have spaces in them.  But, Unicode properties can have spaces, so in &quot;\p{...}&quot; there can be spaces that follow the Unicode rules, for which see &quot;Properties accessible through \p{} and \P{}&quot; in perluniprops.<div class="spacer">
</div>
<i>Character set modifiers</i><div class="spacer">
</div>
&quot;/d&quot;, &quot;/u&quot;, &quot;/a&quot;, and &quot;/l&quot;, available starting in 5.14, are called the character set modifiers; they affect the character set semantics used for the regular expression.<div class="spacer">
</div>
At any given time, exactly one of these modifiers is in effect.  Once compiled, the behavior doesn't change regardless of what rules are in effect when the regular expression is executed.  And if a regular expression is interpolated into a larger one, the original's rules continue to apply to it, and only it.<div class="spacer">
</div>
Note that the modifiers affect only pattern matching, and do not extend to any replacement done.  For example,<div class="spacer">
</div>
<br/>
 s/foo/\Ubar/l<br/>
<div class="spacer">
</div>
will uppercase &quot;bar&quot;, but the &quot;/l&quot; does not affect how the &quot;\U&quot; operates.  If &quot;use locale&quot; is in effect, the &quot;\U&quot; will use locale rules; if &quot;use feature 'unicode_strings'&quot; is in effect, it will use Unicode rules, etc.<div class="spacer">
</div>
/l<div class="spacer">
</div>
means to use the current locale's rules (see perllocale) when pattern matching.  For example, &quot;\w&quot; will match the &quot;word&quot; characters of that locale, and &quot;/i&quot; case-insensitive matching will match according to the locale's case folding rules.  The locale used will be the one in effect at the time of execution of the pattern match.  This may not be the same as the compilation-time locale, and can differ from one match to another if there is an intervening call of the  <i>setlocale()</i> function.<div class="spacer">
</div>
Perl only supports single-byte locales.  This means that code points above 255 are treated as Unicode no matter what locale is in effect. Under Unicode rules, there are a few case-insensitive matches that cross the 255/256 boundary.  These are disallowed under &quot;/l&quot;.  For example, 0xFF does not caselessly match the character at 0x178, &quot;LATIN CAPITAL LETTER Y WITH DIAERESIS&quot;, because 0xFF may not be &quot;LATIN SMALL LETTER Y WITH DIAERESIS&quot; in the current locale, and Perl has no way of knowing if that character even exists in the locale, much less what code point it is.<div class="spacer">
</div>
This modifier may be specified to be the default by &quot;use locale&quot;, but see &quot;Which character set modifier is in effect?&quot;.<div class="spacer">
</div>
/u<div class="spacer">
</div>
means to use Unicode rules when pattern matching.  On ASCII platforms, this means that the code points between 128 and 255 take on their Latin-1 (ISO-8859-1) meanings (which are the same as Unicode's), whereas in strict ASCII their meanings are undefined.  Thus the platform effectively becomes a Unicode platform, hence, for example, &quot;\w&quot; will match any of the more than 100_000 word characters in Unicode.<div class="spacer">
</div>
Unlike most locales, which are specific to a language and country pair, Unicode classifies all the characters that are letters  <i>somewhere</i> as &quot;\w&quot;.  For example, your locale might not think that &quot;LATIN SMALL LETTER ETH&quot; is a letter (unless you happen to speak Icelandic), but Unicode does.  Similarly, all the characters that are decimal digits somewhere in the world will match &quot;\d&quot;; this is hundreds, not 10, possible matches.  And some of those digits look like some of the 10 ASCII digits, but mean a different number, so a human could easily think a number is a different quantity than it really is.  For example, &quot;BENGALI DIGIT FOUR&quot; (U+09EA) looks very much like an &quot;ASCII DIGIT EIGHT&quot; (U+0038).  And, &quot;\d+&quot;, may match strings of digits that are a mixture from different writing systems, creating a security issue.  &quot; <i>num()</i>&quot; in Unicode::UCD can be used to sort this out.<div class="spacer">
</div>
Also, case-insensitive matching works on the full set of Unicode characters.  The &quot;KELVIN SIGN&quot;, for example matches the letters &quot;k&quot; and &quot;K&quot;; and &quot;LATIN SMALL LIGATURE FF&quot; matches the sequence &quot;ff&quot;, which, if you're not prepared, might make it look like a hexadecimal constant, presenting another potential security issue.  See &lt;http://unicode.org/reports/tr36&gt; for a detailed discussion of Unicode security issues.<div class="spacer">
</div>
On the EBCDIC platforms that Perl handles, the native character set is equivalent to Latin-1.  Thus this modifier changes behavior only when the &quot;/i&quot; modifier is also specified, and it turns out it affects only two characters, giving them full Unicode semantics: the &quot;MICRO SIGN&quot; will match the Greek capital and small letters &quot;MU&quot;, otherwise not; and the &quot;LATIN CAPITAL LETTER SHARP S&quot; will match any of &quot;SS&quot;, &quot;Ss&quot;, &quot;sS&quot;, and &quot;ss&quot;, otherwise not.<div class="spacer">
</div>
This modifier may be specified to be the default by &quot;use feature 'unicode_strings&quot;, but see &quot;Which character set modifier is in effect?&quot;.<div class="spacer">
</div>
/a<div class="spacer">
</div>
is the same as &quot;/u&quot;, except that &quot;\d&quot;, &quot;\s&quot;, &quot;\w&quot;, and the Posix character classes are restricted to matching in the ASCII range only.  That is, with this modifier, &quot;\d&quot; always means precisely the digits &quot;0&quot; to &quot;9&quot;; &quot;\s&quot; means the five characters &quot;[ \f\n\r\t]&quot;; &quot;\w&quot; means the 63 characters &quot;[A-Za-z0-9_]&quot;; and likewise, all the Posix classes such as &quot;[[:print:]]&quot; match only the appropriate ASCII-range characters.<div class="spacer">
</div>
This modifier is useful for people who only incidentally use Unicode. With it, one can write &quot;\d&quot; with confidence that it will only match ASCII characters, and should the need arise to match beyond ASCII, you can use &quot;\p{Digit}&quot;, or &quot;\p{Word}&quot; for &quot;\w&quot;.  There are similar &quot;\p{...}&quot; constructs that can match white space and Posix classes beyond ASCII.  See &quot;POSIX Character Classes&quot; in perlrecharclass.<div class="spacer">
</div>
As you would expect, this modifier causes, for example, &quot;\D&quot; to mean the same thing as &quot;[^0-9]&quot;; in fact, all non-ASCII characters match &quot;\D&quot;, &quot;\S&quot;, and &quot;\W&quot;.  &quot;\b&quot; still means to match at the boundary between &quot;\w&quot; and &quot;\W&quot;, using the &quot;/a&quot; definitions of them (similarly for &quot;\B&quot;).<div class="spacer">
</div>
Otherwise, &quot;/a&quot; behaves like the &quot;/u&quot; modifier, in that case-insensitive matching uses Unicode semantics; for example, &quot;k&quot; will match the Unicode &quot;\N{KELVIN SIGN}&quot; under &quot;/i&quot; matching, and code points in the Latin1 range, above ASCII will have Unicode rules when it comes to case-insensitive matching.<div class="spacer">
</div>
To forbid ASCII/non-ASCII matches (like &quot;k&quot; with &quot;\N{KELVIN SIGN}&quot;), specify the &quot;a&quot; twice, for example &quot;/aai&quot; or &quot;/aia&quot;<div class="spacer">
</div>
To reiterate, this modifier provides protection for applications that don't wish to be exposed to all of Unicode.  Specifying it twice gives added protection.<div class="spacer">
</div>
This modifier may be specified to be the default by &quot;use re '/a'&quot; or &quot;use re '/aa'&quot;, but see &quot;Which character set modifier is in effect?&quot;.<div class="spacer">
</div>
/d<div class="spacer">
</div>
This modifier means to use the &quot;Default&quot; native rules of the platform except when there is cause to use Unicode rules instead, as follows:<dl>
<dt>
1.</dt>
<dd>
the target string is encoded in UTF-8; or</dd>
</dl>
<dl>
<dt>
2.</dt>
<dd>
the pattern is encoded in UTF-8; or</dd>
</dl>
<dl>
<dt>
3.</dt>
<dd>
the pattern explicitly mentions a code point that is above 255 (say by &quot;\x{100}&quot;); or</dd>
</dl>
<dl>
<dt>
4.</dt>
<dd>
the pattern uses a Unicode name (&quot;\N{...}&quot;);  or</dd>
</dl>
<dl>
<dt>
5.</dt>
<dd>
the pattern uses a Unicode property (&quot;\p{...}&quot;)</dd>
</dl>
<div class="spacer">
</div>
Another mnemonic for this modifier is &quot;Depends&quot;, as the rules actually used depend on various things, and as a result you can get unexpected results.  See &quot;The &quot;Unicode Bug&quot;&quot; in perlunicode.<div class="spacer">
</div>
On ASCII platforms, the native rules are ASCII, and on EBCDIC platforms (at least the ones that Perl handles), they are Latin-1.<div class="spacer">
</div>
Here are some examples of how that works on an ASCII platform:<div class="spacer">
</div>
<br/>
 $str =  &quot;\xDF&quot;;      # $str is not in UTF-8 format.<br/>
 $str =~ /^\w/;       # No match, as $str isn't in UTF-8 format.<br/>
 $str .= &quot;\x{0e0b}&quot;;  # Now $str is in UTF-8 format.<br/>
 $str =~ /^\w/;       # Match! $str is now in UTF-8 format.<br/>
 chop $str;<br/>
 $str =~ /^\w/;       # Still a match! $str remains in UTF-8 format.<br/>
<div class="spacer">
</div>
Which character set modifier is in effect?<div class="spacer">
</div>
Which of these modifiers is in effect at any given point in a regular expression depends on a fairly complex set of interactions.  As explained below in &quot;Extended Patterns&quot; it is possible to explicitly specify modifiers that apply only to portions of a regular expression. The innermost always has priority over any outer ones, and one applying to the whole expression has priority over any of the default settings that are described in the remainder of this section.<div class="spacer">
</div>
The &quot;use re '/foo'&quot; pragma can be used to set default modifiers (including these) for regular expressions compiled within its scope.  This pragma has precedence over the other pragmas listed below that change the defaults.<div class="spacer">
</div>
Otherwise, &quot;use locale&quot; sets the default modifier to &quot;/l&quot;; and &quot;use feature 'unicode_strings&quot; or &quot;use 5.012&quot; (or higher) set the default to &quot;/u&quot; when not in the same scope as either &quot;use locale&quot; or &quot;use bytes&quot;.  Unlike the mechanisms mentioned above, these affect operations besides regular expressions pattern matching, and so give more consistent results with other operators, including using &quot;\U&quot;, &quot;\l&quot;, etc. in substitution replacements.<div class="spacer">
</div>
If none of the above apply, for backwards compatibility reasons, the &quot;/d&quot; modifier is the one in effect by default.  As this can lead to unexpected results, it is best to specify which other rule set should be used.<div class="spacer">
</div>
Character set modifier behavior prior to Perl 5.14<div class="spacer">
</div>
Prior to 5.14, there were no explicit modifiers, but &quot;/l&quot; was implied for regexes compiled within the scope of &quot;use locale&quot;, and &quot;/d&quot; was implied otherwise.  However, interpolating a regex into a larger regex would ignore the original compilation in favor of whatever was in effect at the time of the second compilation.  There were a number of inconsistencies (bugs) with the &quot;/d&quot; modifier, where Unicode rules would be used when inappropriate, and vice versa.  &quot;\p{}&quot; did not imply Unicode rules, and neither did all occurrences of &quot;\N{}&quot;, until 5.12.</div>
<div class="subsection">
<h2>Regular Expressions</h2>  <i>Metacharacters</i><div class="spacer">
</div>
The patterns used in Perl pattern matching evolved from those supplied in the Version 8 regex routines.  (The routines are derived (distantly) from Henry Spencer's freely redistributable reimplementation of the V8 routines.)  See &quot;Version 8 Regular Expressions&quot; for details.<div class="spacer">
</div>
In particular the following metacharacters have their standard <i>egrep</i>-ish meanings:<div class="spacer">
</div>
<br/>
    \        Quote the next metacharacter<br/>
    ^        Match the beginning of the line<br/>
    .        Match any character (except newline)<br/>
    $        Match the end of the line (or before newline at the end)<br/>
    |        Alternation<br/>
    ()       Grouping<br/>
    []       Bracketed Character class<br/>
<div class="spacer">
</div>
By default, the &quot;^&quot; character is guaranteed to match only the beginning of the string, the &quot;$&quot; character only the end (or before the newline at the end), and Perl does certain optimizations with the assumption that the string contains only one line.  Embedded newlines will not be matched by &quot;^&quot; or &quot;$&quot;.  You may, however, wish to treat a string as a multi-line buffer, such that the &quot;^&quot; will match after any newline within the string (except if the newline is the last character in the string), and &quot;$&quot; will match before any newline.  At the cost of a little more overhead, you can do this by using the /m modifier on the pattern match operator.  (Older programs did this by setting $*, but this option was removed in perl 5.9.)<div class="spacer">
</div>
To simplify multi-line substitutions, the &quot;.&quot; character never matches a newline unless you use the &quot;/s&quot; modifier, which in effect tells Perl to pretend the string is a single line--even if it isn't.<div class="spacer">
</div>
<i>Quantifiers</i><div class="spacer">
</div>
The following standard quantifiers are recognized:<div class="spacer">
</div>
<br/>
    *           Match 0 or more times<br/>
    +           Match 1 or more times<br/>
    ?           Match 1 or 0 times<br/>
    {n}         Match exactly n times<br/>
    {n,}        Match at least n times<br/>
    {n,m}       Match at least n but not more than m times<br/>
<div class="spacer">
</div>
(If a curly bracket occurs in any other context and does not form part of a backslashed sequence like &quot;\x{...}&quot;, it is treated as a regular character.  In particular, the lower bound is not optional.)  The &quot;*&quot; quantifier is equivalent to &quot;{0,}&quot;, the &quot;+&quot; quantifier to &quot;{1,}&quot;, and the &quot;?&quot; quantifier to &quot;{0,1}&quot;.  n and m are limited to non-negative integral values less than a preset limit defined when perl is built. This is usually 32766 on the most common platforms.  The actual limit can be seen in the error message generated by code such as this:<div class="spacer">
</div>
<br/>
    $_ **= $_ , / {$_} / for 2 .. 42;<br/>
<div class="spacer">
</div>
By default, a quantified subpattern is &quot;greedy&quot;, that is, it will match as many times as possible (given a particular starting location) while still allowing the rest of the pattern to match.  If you want it to match the minimum number of times possible, follow the quantifier with a &quot;?&quot;.  Note that the meanings don't change, just the &quot;greediness&quot;:<div class="spacer">
</div>
<br/>
    *?        Match 0 or more times, not greedily<br/>
    +?        Match 1 or more times, not greedily<br/>
    ??        Match 0 or 1 time, not greedily<br/>
    {n}?      Match exactly n times, not greedily (redundant)<br/>
    {n,}?     Match at least n times, not greedily<br/>
    {n,m}?    Match at least n but not more than m times, not greedily<br/>
<div class="spacer">
</div>
By default, when a quantified subpattern does not allow the rest of the overall pattern to match, Perl will backtrack. However, this behaviour is sometimes undesirable. Thus Perl provides the &quot;possessive&quot; quantifier form as well.<div class="spacer">
</div>
<br/>
 *+     Match 0 or more times and give nothing back<br/>
 ++     Match 1 or more times and give nothing back<br/>
 ?+     Match 0 or 1 time and give nothing back<br/>
 {n}+   Match exactly n times and give nothing back (redundant)<br/>
 {n,}+  Match at least n times and give nothing back<br/>
 {n,m}+ Match at least n but not more than m times and give nothing back<br/>
<div class="spacer">
</div>
For instance,<div class="spacer">
</div>
<br/>
   'aaaa' =~ /a++a/<br/>
<div class="spacer">
</div>
will never match, as the &quot;a++&quot; will gobble up all the &quot;a&quot;'s in the string and won't leave any for the remaining part of the pattern. This feature can be extremely useful to give perl hints about where it shouldn't backtrack. For instance, the typical &quot;match a double-quoted string&quot; problem can be most efficiently performed when written as:<div class="spacer">
</div>
<br/>
   /&quot;(?:[^&quot;\\]++|\\.)*+&quot;/<br/>
<div class="spacer">
</div>
as we know that if the final quote does not match, backtracking will not help. See the independent subexpression &quot;&quot;(?&gt;pattern)&quot;&quot; for more details; possessive quantifiers are just syntactic sugar for that construct. For instance the above example could also be written as follows:<div class="spacer">
</div>
<br/>
   /&quot;(?&gt;(?:(?&gt;[^&quot;\\]+)|\\.)*)&quot;/<br/>
<div class="spacer">
</div>
<i>Escape sequences</i><div class="spacer">
</div>
Because patterns are processed as double-quoted strings, the following also work:<div class="spacer">
</div>
<br/>
 \t          tab                   (HT, TAB)<br/>
 \n          newline               (LF, NL)<br/>
 \r          return                (CR)<br/>
 \f          form feed             (FF)<br/>
 \a          alarm (bell)          (BEL)<br/>
 \e          escape (think troff)  (ESC)<br/>
 \cK         control char          (example: VT)<br/>
 \x{}, \x00  character whose ordinal is the given hexadecimal number<br/>
 \N{name}    named Unicode character or character sequence<br/>
 \N{U+263D}  Unicode character     (example: FIRST QUARTER MOON)<br/>
 \o{}, \000  character whose ordinal is the given octal number<br/>
 \l          lowercase next char (think vi)<br/>
 \u          uppercase next char (think vi)<br/>
 \L          lowercase till \E (think vi)<br/>
 \U          uppercase till \E (think vi)<br/>
 \Q          quote (disable) pattern metacharacters till \E<br/>
 \E          end either case modification or quoted section, think vi<br/>
<div class="spacer">
</div>
Details are in &quot;Quote and Quote-like Operators&quot; in perlop.<div class="spacer">
</div>
<i>Character Classes and other Special Escapes</i><div class="spacer">
</div>
In addition, Perl defines the following:<div class="spacer">
</div>
<br/>
 Sequence   Note    Description<br/>
  [...]     [1]  Match a character according to the rules of the<br/>
                   bracketed character class defined by the &quot;...&quot;.<br/>
                   Example: [a-z] matches &quot;a&quot; or &quot;b&quot; or &quot;c&quot; ... or &quot;z&quot;<br/>
  [[:...:]] [2]  Match a character according to the rules of the POSIX<br/>
                   character class &quot;...&quot; within the outer bracketed<br/>
                   character class.  Example: [[:upper:]] matches any<br/>
                   uppercase character.<br/>
  \w        [3]  Match a &quot;word&quot; character (alphanumeric plus &quot;_&quot;, plus<br/>
                   other connector punctuation chars plus Unicode<br/>
                   marks)<br/>
  \W        [3]  Match a non-&quot;word&quot; character<br/>
  \s        [3]  Match a whitespace character<br/>
  \S        [3]  Match a non-whitespace character<br/>
  \d        [3]  Match a decimal digit character<br/>
  \D        [3]  Match a non-digit character<br/>
  \pP       [3]  Match P, named property.  Use \p{Prop} for longer names<br/>
  \PP       [3]  Match non-P<br/>
  \X        [4]  Match Unicode &quot;eXtended grapheme cluster&quot;<br/>
  \C             Match a single C-language char (octet) even if that is<br/>
                   part of a larger UTF-8 character.  Thus it breaks up<br/>
                   characters into their UTF-8 bytes, so you may end up<br/>
                   with malformed pieces of UTF-8.  Unsupported in<br/>
                   lookbehind.<br/>
  \1        [5]  Backreference to a specific capture group or buffer.<br/>
                   '1' may actually be any positive integer.<br/>
  \g1       [5]  Backreference to a specific or previous group,<br/>
  \g{-1}    [5]  The number may be negative indicating a relative<br/>
                   previous group and may optionally be wrapped in<br/>
                   curly brackets for safer parsing.<br/>
  \g{name}  [5]  Named backreference<br/>
  \k&lt;name&gt;  [5]  Named backreference<br/>
  \K        [6]  Keep the stuff left of the \K, don't include it in $&amp;<br/>
  \N        [7]  Any character but \n (experimental).  Not affected by<br/>
                   /s modifier<br/>
  \v        [3]  Vertical whitespace<br/>
  \V        [3]  Not vertical whitespace<br/>
  \h        [3]  Horizontal whitespace<br/>
  \H        [3]  Not horizontal whitespace<br/>
  \R        [4]  Linebreak<br/>
<dl>
<dt>
[1]</dt>
<dd>
See &quot;Bracketed Character Classes&quot; in perlrecharclass for details.</dd>
</dl>
<dl>
<dt>
[2]</dt>
<dd>
See &quot;POSIX Character Classes&quot; in perlrecharclass for details.</dd>
</dl>
<dl>
<dt>
[3]</dt>
<dd>
See &quot;Backslash sequences&quot; in perlrecharclass for details.</dd>
</dl>
<dl>
<dt>
[4]</dt>
<dd>
See &quot;Misc&quot; in perlrebackslash for details.</dd>
</dl>
<dl>
<dt>
[5]</dt>
<dd>
See &quot;Capture groups&quot; below for details.</dd>
</dl>
<dl>
<dt>
[6]</dt>
<dd>
See &quot;Extended Patterns&quot; below for details.</dd>
</dl>
<dl>
<dt>
[7]</dt>
<dd>
Note that &quot;\N&quot; has two meanings.  When of the form &quot;\N{NAME}&quot;, it matches the character or character sequence whose name is &quot;NAME&quot;; and similarly when of the form &quot;\N{U+ <i>hex</i>}&quot;, it matches the character whose Unicode code point is  <i>hex</i>.  Otherwise it matches any character but &quot;\n&quot;.</dd>
</dl>
<div class="spacer">
</div>
<i>Assertions</i><div class="spacer">
</div>
Perl defines the following zero-width assertions:<div class="spacer">
</div>
<br/>
    \b  Match a word boundary<br/>
    \B  Match except at a word boundary<br/>
    \A  Match only at beginning of string<br/>
    \Z  Match only at end of string, or before newline at the end<br/>
    \z  Match only at end of string<br/>
    \G  Match only at pos() (e.g. at the end-of-match position<br/>
        of prior m//g)<br/>
<div class="spacer">
</div>
A word boundary (&quot;\b&quot;) is a spot between two characters that has a &quot;\w&quot; on one side of it and a &quot;\W&quot; on the other side of it (in either order), counting the imaginary characters off the beginning and end of the string as matching a &quot;\W&quot;.  (Within character classes &quot;\b&quot; represents backspace rather than a word boundary, just as it normally does in any double-quoted string.) The &quot;\A&quot; and &quot;\Z&quot; are just like &quot;^&quot; and &quot;$&quot;, except that they won't match multiple times when the &quot;/m&quot; modifier is used, while &quot;^&quot; and &quot;$&quot; will match at every internal line boundary.  To match the actual end of the string and not ignore an optional trailing newline, use &quot;\z&quot;.<div class="spacer">
</div>
The &quot;\G&quot; assertion can be used to chain global matches (using &quot;m//g&quot;), as described in &quot;Regexp Quote-Like Operators&quot; in perlop. It is also useful when writing &quot;lex&quot;-like scanners, when you have several patterns that you want to match against consequent substrings of your string; see the previous reference.  The actual location where &quot;\G&quot; will match can also be influenced by using &quot;pos()&quot; as an lvalue: see &quot;pos&quot; in perlfunc. Note that the rule for zero-length matches (see &quot;Repeated Patterns Matching a Zero-length Substring&quot;) is modified somewhat, in that contents to the left of &quot;\G&quot; are not counted when determining the length of the match. Thus the following will not match forever:<div class="spacer">
</div>
<br/>
     my $string = 'ABC';<br/>
     pos($string) = 1;<br/>
     while ($string =~ /(.\G)/g) {<br/>
         print $1;<br/>
     }<br/>
<div class="spacer">
</div>
It will print 'A' and then terminate, as it considers the match to be zero-width, and thus will not match at the same position twice in a row.<div class="spacer">
</div>
It is worth noting that &quot;\G&quot; improperly used can result in an infinite loop. Take care when using patterns that include &quot;\G&quot; in an alternation.<div class="spacer">
</div>
<i>Capture groups</i><div class="spacer">
</div>
The bracketing construct &quot;( ... )&quot; creates capture groups (also referred to as capture buffers). To refer to the current contents of a group later on, within the same pattern, use &quot;\g1&quot; (or &quot;\g{1}&quot;) for the first, &quot;\g2&quot; (or &quot;\g{2}&quot;) for the second, and so on. This is called a  <i>backreference</i>.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
There is no limit to the number of captured substrings that you may use. Groups are numbered with the leftmost open parenthesis being number 1, etc.  If a group did not match, the associated backreference won't match either. (This can happen if the group is optional, or in a different branch of an alternation.) You can omit the &quot;g&quot;, and write &quot;\1&quot;, etc, but there are some issues with this form, described below.<div class="spacer">
</div>
You can also refer to capture groups relatively, by using a negative number, so that &quot;\g-1&quot; and &quot;\g{-1}&quot; both refer to the immediately preceding capture group, and &quot;\g-2&quot; and &quot;\g{-2}&quot; both refer to the group before it.  For example:<div class="spacer">
</div>
<br/>
        /<br/>
         (Y)            # group 1<br/>
         (              # group 2<br/>
            (X)         # group 3<br/>
            \g{-1}      # backref to group 3<br/>
            \g{-3}      # backref to group 1<br/>
         )<br/>
        /x<br/>
<div class="spacer">
</div>
would match the same as &quot;/(Y) ( (X) \g3 \g1 )/x&quot;.  This allows you to interpolate regexes into larger regexes and not have to worry about the capture groups being renumbered.<div class="spacer">
</div>
You can dispense with numbers altogether and create named capture groups. The notation is &quot;(?&lt; <i>name</i>&gt;...)&quot; to declare and &quot;\g{<i>name</i>}&quot; to reference.  (To be compatible with .Net regular expressions, &quot;\g{ <i>name</i>}&quot; may also be written as &quot;\k{ <i>name</i>}&quot;, &quot;\k&lt;<i>name</i>&gt;&quot; or &quot;\k'<i>name</i>'&quot;.)  <i>name</i> must not begin with a number, nor contain hyphens. When different groups within the same pattern have the same name, any reference to that name assumes the leftmost defined group.  Named groups count in absolute and relative numbering, and so can also be referred to by those numbers. (It's possible to do things with named capture groups that would otherwise require &quot;(??{})&quot;.)<div class="spacer">
</div>
Capture group contents are dynamically scoped and available to you outside the pattern until the end of the enclosing block or until the next successful match, whichever comes first.  (See &quot;Compound Statements&quot; in perlsyn.) You can refer to them by absolute number (using &quot;$1&quot; instead of &quot;\g1&quot;, etc); or by name via the &quot;%+&quot; hash, using &quot;$+{ <i>name</i>}&quot;.<div class="spacer">
</div>
Braces are required in referring to named capture groups, but are optional for absolute or relative numbered ones.  Braces are safer when creating a regex by concatenating smaller strings.  For example if you have &quot;qr/$a$b/&quot;, and $a contained &quot;\g1&quot;, and $b contained &quot;37&quot;, you would get &quot;/\g137/&quot; which is probably not what you intended.<div class="spacer">
</div>
The &quot;\g&quot; and &quot;\k&quot; notations were introduced in Perl 5.10.0.  Prior to that there were no named nor relative numbered capture groups.  Absolute numbered groups were referred to using &quot;\1&quot;, &quot;\2&quot;, etc., and this notation is still accepted (and likely always will be).  But it leads to some ambiguities if there are more than 9 capture groups, as &quot;\10&quot; could mean either the tenth capture group, or the character whose ordinal in octal is 010 (a backspace in ASCII).  Perl resolves this ambiguity by interpreting &quot;\10&quot; as a backreference only if at least 10 left parentheses have opened before it.  Likewise &quot;\11&quot; is a backreference only if at least 11 left parentheses have opened before it. And so on.  &quot;\1&quot; through &quot;\9&quot; are always interpreted as backreferences. There are several examples below that illustrate these perils.  You can avoid the ambiguity by always using &quot;\g{}&quot; or &quot;\g&quot; if you mean capturing groups; and for octal constants always using &quot;\o{}&quot;, or for &quot;\077&quot; and below, using 3 digits padded with leading zeros, since a leading zero implies an octal constant.<div class="spacer">
</div>
The &quot;\<i>digit</i>&quot; notation also works in certain circumstances outside the pattern.  See &quot;Warning on \1 Instead of $1&quot; below for details.<div class="spacer">
</div>
Examples:<div class="spacer">
</div>
<br/>
    s/^([^ ]*) *([^ ]*)/$2 $1/;     # swap first two words<br/>
<br/>
    /(.)\g1/                        # find first doubled char<br/>
         and print &quot;'$1' is the first doubled character\n&quot;;<br/>
<br/>
    /(?&lt;char&gt;.)\k&lt;char&gt;/            # ... a different way<br/>
         and print &quot;'$+{char}' is the first doubled character\n&quot;;<br/>
<br/>
    /(?'char'.)\g1/                 # ... mix and match<br/>
         and print &quot;'$1' is the first doubled character\n&quot;;<br/>
<br/>
    if (/Time: (..):(..):(..)/) {   # parse out values<br/>
        $hours = $1;<br/>
        $minutes = $2;<br/>
        $seconds = $3;<br/>
    }<br/>
<br/>
    /(.)(.)(.)(.)(.)(.)(.)(.)(.)\g10/   # \g10 is a backreference<br/>
    /(.)(.)(.)(.)(.)(.)(.)(.)(.)\10/    # \10 is octal<br/>
    /((.)(.)(.)(.)(.)(.)(.)(.)(.))\10/  # \10 is a backreference<br/>
    /((.)(.)(.)(.)(.)(.)(.)(.)(.))\010/ # \010 is octal<br/>
<br/>
    $a = '(.)\1';        # Creates problems when concatenated.<br/>
    $b = '(.)\g{1}';     # Avoids the problems.<br/>
    &quot;aa&quot; =~ /${a}/;      # True<br/>
    &quot;aa&quot; =~ /${b}/;      # True<br/>
    &quot;aa0&quot; =~ /${a}0/;    # False!<br/>
    &quot;aa0&quot; =~ /${b}0/;    # True<br/>
    &quot;aa\x08&quot; =~ /${a}0/;  # True!<br/>
    &quot;aa\x08&quot; =~ /${b}0/;  # False<br/>
<div class="spacer">
</div>
Several special variables also refer back to portions of the previous match.  $+ returns whatever the last bracket match matched. $&amp; returns the entire matched string.  (At one point $0 did also, but now it returns the name of the program.)  &quot;$`&quot; returns everything before the matched string.  &quot;$'&quot; returns everything after the matched string. And $^N contains whatever was matched by the most-recently closed group (submatch). $^N can be used in extended patterns (see below), for example to assign a submatch to a variable.<div class="spacer">
</div>
These special variables, like the &quot;%+&quot; hash and the numbered match variables ($1, $2, $3, etc.) are dynamically scoped until the end of the enclosing block or until the next successful match, whichever comes first.  (See &quot;Compound Statements&quot; in perlsyn.)<div class="spacer">
</div>
<b>NOTE</b>: Failed matches in Perl do not reset the match variables, which makes it easier to write code that tests for a series of more specific cases and remembers the best match.<div class="spacer">
</div>
<b>WARNING</b>: Once Perl sees that you need one of $&amp;, &quot;$`&quot;, or &quot;$'&quot; anywhere in the program, it has to provide them for every pattern match.  This may substantially slow your program.  Perl uses the same mechanism to produce $1, $2, etc, so you also pay a price for each pattern that contains capturing parentheses.  (To avoid this cost while retaining the grouping behaviour, use the extended regular expression &quot;(?: ... )&quot; instead.)  But if you never use $&amp;, &quot;$`&quot; or &quot;$'&quot;, then patterns  <i>without</i> capturing parentheses will not be penalized.  So avoid $&amp;, &quot;$'&quot;, and &quot;$`&quot; if you can, but if you can't (and some algorithms really appreciate them), once you've used them once, use them at will, because you've already paid the price.  As of 5.005, $&amp; is not so costly as the other two.<div class="spacer">
</div>
As a workaround for this problem, Perl 5.10.0 introduces &quot;${^PREMATCH}&quot;, &quot;${^MATCH}&quot; and &quot;${^POSTMATCH}&quot;, which are equivalent to &quot;$`&quot;, $&amp; and &quot;$'&quot;,  <b>except</b> that they are only guaranteed to be defined after a successful match that was executed with the &quot;/p&quot; (preserve) modifier. The use of these variables incurs no global performance penalty, unlike their punctuation char equivalents, however at the trade-off that you have to tell perl when you want to use them.</div>
<div class="subsection">
<h2>Quoting metacharacters</h2> Backslashed metacharacters in Perl are alphanumeric, such as &quot;\b&quot;, &quot;\w&quot;, &quot;\n&quot;.  Unlike some other regular expression languages, there are no backslashed symbols that aren't alphanumeric.  So anything that looks like \\, \(, \), \&lt;, \&gt;, \{, or \} is always interpreted as a literal character, not a metacharacter.  This was once used in a common idiom to disable or quote the special meanings of regular expression metacharacters in a string that you want to use for a pattern. Simply quote all non-&quot;word&quot; characters:<div class="spacer">
</div>
<br/>
    $pattern =~ s/(\W)/\\$1/g;<br/>
<div class="spacer">
</div>
(If &quot;use locale&quot; is set, then this depends on the current locale.) Today it is more common to use the  <i>quotemeta()</i> function or the &quot;\Q&quot; metaquoting escape sequence to disable all metacharacters' special meanings like this:<div class="spacer">
</div>
<br/>
    /$unquoted\Q$quoted\E$unquoted/<br/>
<div class="spacer">
</div>
Beware that if you put literal backslashes (those not inside interpolated variables) between &quot;\Q&quot; and &quot;\E&quot;, double-quotish backslash interpolation may lead to confusing results.  If you  <i>need</i> to use literal backslashes within &quot;\Q...\E&quot;, consult &quot;Gory details of parsing quoted constructs&quot; in perlop.</div>
<div class="subsection">
<h2>Extended Patterns</h2> Perl also defines a consistent extension syntax for features not found in standard tools like  <b>awk</b> and  <b>lex</b>.  The syntax for most of these is a pair of parentheses with a question mark as the first thing within the parentheses.  The character after the question mark indicates the extension.<div class="spacer">
</div>
The stability of these extensions varies widely.  Some have been part of the core language for many years.  Others are experimental and may change without warning or be completely removed.  Check the documentation on an individual feature to verify its current status.<div class="spacer">
</div>
A question mark was chosen for this and for the minimal-matching construct because 1) question marks are rare in older regular expressions, and 2) whenever you see one, you should stop and &quot;question&quot; exactly what is going on.  That's psychology....<dl>
<dt>
&quot;(?#text)&quot;</dt>
<dd>
A comment.  The text is ignored.  If the &quot;/x&quot; modifier enables whitespace formatting, a simple &quot;#&quot; will suffice.  Note that Perl closes the comment as soon as it sees a &quot;)&quot;, so there is no way to put a literal &quot;)&quot; in the comment.</dd>
</dl>
<dl>
<dt>
&quot;(?adlupimsx-imsx)&quot;</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
&quot;(?^alupimsx)&quot;</dt>
<dd>
One or more embedded pattern-match modifiers, to be turned on (or turned off, if preceded by &quot;-&quot;) for the remainder of the pattern or the remainder of the enclosing pattern group (if any).<div style="height: 1.00em;">
&#160;</div>
This is particularly useful for dynamic patterns, such as those read in from a configuration file, taken from an argument, or specified in a table somewhere.  Consider the case where some patterns want to be case-sensitive and some do not:  The case-insensitive ones merely need to include &quot;(?i)&quot; at the front of the pattern.  For example:<div style="height: 1.00em;">
&#160;</div>
<br/>
    $pattern = &quot;foobar&quot;;<br/>
    if ( /$pattern/i ) { }<br/>
<br/>
    # more flexible:<br/>
<br/>
    $pattern = &quot;(?i)foobar&quot;;<br/>
    if ( /$pattern/ ) { }<br/>
<div style="height: 1.00em;">
&#160;</div>
These modifiers are restored at the end of the enclosing group. For example,<div style="height: 1.00em;">
&#160;</div>
<br/>
    ( (?i) blah ) \s+ \g1<br/>
<div style="height: 1.00em;">
&#160;</div>
will match &quot;blah&quot; in any case, some spaces, and an exact (<i>including the case</i>!) repetition of the previous word, assuming the &quot;/x&quot; modifier, and no &quot;/i&quot; modifier outside this group.<div style="height: 1.00em;">
&#160;</div>
These modifiers do not carry over into named subpatterns called in the enclosing group. In other words, a pattern such as &quot;((?i)(&amp;NAME))&quot; does not change the case-sensitivity of the &quot;NAME&quot; pattern.<div style="height: 1.00em;">
&#160;</div>
Any of these modifiers can be set to apply globally to all regular expressions compiled within the scope of a &quot;use re&quot;.  See &quot;'/flags' mode&quot; in re.<div style="height: 1.00em;">
&#160;</div>
Starting in Perl 5.14, a &quot;^&quot; (caret or circumflex accent) immediately after the &quot;?&quot; is a shorthand equivalent to &quot;d-imsx&quot;.  Flags (except &quot;d&quot;) may follow the caret to override it. But a minus sign is not legal with it.<div style="height: 1.00em;">
&#160;</div>
Note that the &quot;a&quot;, &quot;d&quot;, &quot;l&quot;, &quot;p&quot;, and &quot;u&quot; modifiers are special in that they can only be enabled, not disabled, and the &quot;a&quot;, &quot;d&quot;, &quot;l&quot;, and &quot;u&quot; modifiers are mutually exclusive: specifying one de-specifies the others, and a maximum of one (or two &quot;a&quot;'s) may appear in the construct.  Thus, for example, &quot;(?-p)&quot; will warn when compiled under &quot;use warnings&quot;; &quot;(?-d:...)&quot; and &quot;(?dl:...)&quot; are fatal errors.<div style="height: 1.00em;">
&#160;</div>
Note also that the &quot;p&quot; modifier is special in that its presence anywhere in a pattern has a global effect.</dd>
</dl>
<dl>
<dt>
&quot;(?:pattern)&quot;</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
&quot;(?adluimsx-imsx:pattern)&quot;</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
&quot;(?^aluimsx:pattern)&quot;</dt>
<dd>
This is for clustering, not capturing; it groups subexpressions like &quot;()&quot;, but doesn't make backreferences as &quot;()&quot; does.  So<div style="height: 1.00em;">
&#160;</div>
<br/>
    @fields = split(/\b(?:a|b|c)\b/)<br/>
<div style="height: 1.00em;">
&#160;</div>
is like<div style="height: 1.00em;">
&#160;</div>
<br/>
    @fields = split(/\b(a|b|c)\b/)<br/>
<div style="height: 1.00em;">
&#160;</div>
but doesn't spit out extra fields.  It's also cheaper not to capture characters if you don't need to.<div style="height: 1.00em;">
&#160;</div>
Any letters between &quot;?&quot; and &quot;:&quot; act as flags modifiers as with &quot;(?adluimsx-imsx)&quot;.  For example,<div style="height: 1.00em;">
&#160;</div>
<br/>
    /(?s-i:more.*than).*million/i<br/>
<div style="height: 1.00em;">
&#160;</div>
is equivalent to the more verbose<div style="height: 1.00em;">
&#160;</div>
<br/>
    /(?:(?s-i)more.*than).*million/i<br/>
<div style="height: 1.00em;">
&#160;</div>
Starting in Perl 5.14, a &quot;^&quot; (caret or circumflex accent) immediately after the &quot;?&quot; is a shorthand equivalent to &quot;d-imsx&quot;.  Any positive flags (except &quot;d&quot;) may follow the caret, so<div style="height: 1.00em;">
&#160;</div>
<br/>
    (?^x:foo)<br/>
<div style="height: 1.00em;">
&#160;</div>
is equivalent to<div style="height: 1.00em;">
&#160;</div>
<br/>
    (?x-ims:foo)<br/>
<div style="height: 1.00em;">
&#160;</div>
The caret tells Perl that this cluster doesn't inherit the flags of any surrounding pattern, but uses the system defaults (&quot;d-imsx&quot;), modified by any flags specified.<div style="height: 1.00em;">
&#160;</div>
The caret allows for simpler stringification of compiled regular expressions.  These look like<div style="height: 1.00em;">
&#160;</div>
<br/>
    (?^:pattern)<br/>
<div style="height: 1.00em;">
&#160;</div>
with any non-default flags appearing between the caret and the colon. A test that looks at such stringification thus doesn't need to have the system default flags hard-coded in it, just the caret.  If new flags are added to Perl, the meaning of the caret's expansion will change to include the default for those flags, so the test will still work, unchanged.<div style="height: 1.00em;">
&#160;</div>
Specifying a negative flag after the caret is an error, as the flag is redundant.<div style="height: 1.00em;">
&#160;</div>
Mnemonic for &quot;(?^...)&quot;:  A fresh beginning since the usual use of a caret is to match at the beginning.</dd>
</dl>
<dl>
<dt>
&quot;(?|pattern)&quot;</dt>
<dd>
This is the &quot;branch reset&quot; pattern, which has the special property that the capture groups are numbered from the same starting point in each alternation branch. It is available starting from perl 5.10.0.<div style="height: 1.00em;">
&#160;</div>
Capture groups are numbered from left to right, but inside this construct the numbering is restarted for each branch.<div style="height: 1.00em;">
&#160;</div>
The numbering within each branch will be as normal, and any groups following this construct will be numbered as though the construct contained only one branch, that being the one with the most capture groups in it.<div style="height: 1.00em;">
&#160;</div>
This construct is useful when you want to capture one of a number of alternative matches.<div style="height: 1.00em;">
&#160;</div>
Consider the following pattern.  The numbers underneath show in which group the captured content will be stored.<div style="height: 1.00em;">
&#160;</div>
<br/>
    # before  ---------------branch-reset----------- after        <br/>
    / ( a )  (?| x ( y ) z | (p (q) r) | (t) u (v) ) ( z ) /x<br/>
    # 1            2         2  3        2     3     4<br/>
<div style="height: 1.00em;">
&#160;</div>
Be careful when using the branch reset pattern in combination with named captures. Named captures are implemented as being aliases to numbered groups holding the captures, and that interferes with the implementation of the branch reset pattern. If you are using named captures in a branch reset pattern, it's best to use the same names, in the same order, in each of the alternations:<div style="height: 1.00em;">
&#160;</div>
<br/>
   /(?|  (?&lt;a&gt; x ) (?&lt;b&gt; y )<br/>
      |  (?&lt;a&gt; z ) (?&lt;b&gt; w )) /x<br/>
<div style="height: 1.00em;">
&#160;</div>
Not doing so may lead to surprises:<div style="height: 1.00em;">
&#160;</div>
<br/>
  &quot;12&quot; =~ /(?| (?&lt;a&gt; \d+ ) | (?&lt;b&gt; \D+))/x;<br/>
  say $+ {a};   # Prints '12'<br/>
  say $+ {b};   # *Also* prints '12'.<br/>
<div style="height: 1.00em;">
&#160;</div>
The problem here is that both the group named &quot;a&quot; and the group named &quot;b&quot; are aliases for the group belonging to $1.</dd>
</dl>
<dl>
<dt>
Look-Around Assertions</dt>
<dd>
Look-around assertions are zero-width patterns which match a specific pattern without including it in $&amp;. Positive assertions match when their subpattern matches, negative assertions match when their subpattern fails. Look-behind matches text up to the current match position, look-ahead matches text following the current match position.</dd>
</dl>
<div style="margin-left: 10.00ex;">
<dl>
<dt>
&quot;(?=pattern)&quot;</dt>
<dd>
A zero-width positive look-ahead assertion.  For example, &quot;/\w+(?=\t)/&quot; matches a word followed by a tab, without including the tab in $&amp;.</dd>
</dl>
<dl>
<dt>
&quot;(?!pattern)&quot;</dt>
<dd>
A zero-width negative look-ahead assertion.  For example &quot;/foo(?!bar)/&quot; matches any occurrence of &quot;foo&quot; that isn't followed by &quot;bar&quot;.  Note however that look-ahead and look-behind are NOT the same thing.  You cannot use this for look-behind.<div style="height: 1.00em;">
&#160;</div>
If you are looking for a &quot;bar&quot; that isn't preceded by a &quot;foo&quot;, &quot;/(?!foo)bar/&quot; will not do what you want.  That's because the &quot;(?!foo)&quot; is just saying that the next thing cannot be &quot;foo&quot;--and it's not, it's a &quot;bar&quot;, so &quot;foobar&quot; will match.  Use look-behind instead (see below).</dd>
</dl>
<dl>
<dt>
&quot;(?&lt;=pattern)&quot; &quot;\K&quot;</dt>
<dd>
A zero-width positive look-behind assertion.  For example, &quot;/(?&lt;=\t)\w+/&quot; matches a word that follows a tab, without including the tab in $&amp;. Works only for fixed-width look-behind.<div style="height: 1.00em;">
&#160;</div>
There is a special form of this construct, called &quot;\K&quot;, which causes the regex engine to &quot;keep&quot; everything it had matched prior to the &quot;\K&quot; and not include it in $&amp;. This effectively provides variable-length look-behind. The use of &quot;\K&quot; inside of another look-around assertion is allowed, but the behaviour is currently not well defined.<div style="height: 1.00em;">
&#160;</div>
For various reasons &quot;\K&quot; may be significantly more efficient than the equivalent &quot;(?&lt;=...)&quot; construct, and it is especially useful in situations where you want to efficiently remove something following something else in a string. For instance<div style="height: 1.00em;">
&#160;</div>
<br/>
  s/(foo)bar/$1/g;<br/>
<div style="height: 1.00em;">
&#160;</div>
can be rewritten as the much more efficient<div style="height: 1.00em;">
&#160;</div>
<br/>
  s/foo\Kbar//g;<br/>
</dd>
</dl>
<dl>
<dt>
&quot;(?&lt;!pattern)&quot;</dt>
<dd>
A zero-width negative look-behind assertion.  For example &quot;/(?&lt;!bar)foo/&quot; matches any occurrence of &quot;foo&quot; that does not follow &quot;bar&quot;.  Works only for fixed-width look-behind.</dd>
</dl>
</div>
<div style="margin-left: 10.00ex;">
</div>
<dl>
<dt>
&quot;(?'NAME'pattern)&quot;</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
&quot;(?&lt;NAME&gt;pattern)&quot;</dt>
<dd>
A named capture group. Identical in every respect to normal capturing parentheses &quot;()&quot; but for the additional fact that the group can be referred to by name in various regular expression constructs (like &quot;\g{NAME}&quot;) and can be accessed by name after a successful match via &quot;%+&quot; or &quot;%-&quot;. See perlvar for more details on the &quot;%+&quot; and &quot;%-&quot; hashes.<div style="height: 1.00em;">
&#160;</div>
If multiple distinct capture groups have the same name then the $+{NAME} will refer to the leftmost defined group in the match.<div style="height: 1.00em;">
&#160;</div>
The forms &quot;(?'NAME'pattern)&quot; and &quot;(?&lt;NAME&gt;pattern)&quot; are equivalent.<div style="height: 1.00em;">
&#160;</div>
<b>NOTE:</b> While the notation of this construct is the same as the similar function in .NET regexes, the behavior is not. In Perl the groups are numbered sequentially regardless of being named or not. Thus in the pattern<div style="height: 1.00em;">
&#160;</div>
<br/>
  /(x)(?&lt;foo&gt;y)(z)/<br/>
<div style="height: 1.00em;">
&#160;</div>
$+{foo} will be the same as $2, and $3 will contain 'z' instead of the opposite which is what a .NET regex hacker might expect.<div style="height: 1.00em;">
&#160;</div>
Currently NAME is restricted to simple identifiers only. In other words, it must match &quot;/^[_A-Za-z][_A-Za-z0-9]*\z/&quot; or its Unicode extension (see utf8), though it isn't extended by the locale (see perllocale).<div style="height: 1.00em;">
&#160;</div>
<b>NOTE:</b> In order to make things easier for programmers with experience with the Python or PCRE regex engines, the pattern &quot;(?P&lt;NAME&gt;pattern)&quot; may be used instead of &quot;(?&lt;NAME&gt;pattern)&quot;; however this form does not support the use of single quotes as a delimiter for the name.</dd>
</dl>
<dl>
<dt>
&quot;\k&lt;NAME&gt;&quot;</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
&quot;\k'NAME'&quot;</dt>
<dd>
Named backreference. Similar to numeric backreferences, except that the group is designated by name and not number. If multiple groups have the same name then it refers to the leftmost defined group in the current match.<div style="height: 1.00em;">
&#160;</div>
It is an error to refer to a name not defined by a &quot;(?&lt;NAME&gt;)&quot; earlier in the pattern.<div style="height: 1.00em;">
&#160;</div>
Both forms are equivalent.<div style="height: 1.00em;">
&#160;</div>
<b>NOTE:</b> In order to make things easier for programmers with experience with the Python or PCRE regex engines, the pattern &quot;(?P=NAME)&quot; may be used instead of &quot;\k&lt;NAME&gt;&quot;.</dd>
</dl>
<dl>
<dt>
&quot;(?{ code })&quot;</dt>
<dd>
<b>WARNING</b>: This extended regular expression feature is considered experimental, and may be changed without notice. Code executed that has side effects may not perform identically from version to version due to the effect of future optimisations in the regex engine.<div style="height: 1.00em;">
&#160;</div>
This zero-width assertion evaluates any embedded Perl code.  It always succeeds, and its &quot;code&quot; is not interpolated.  Currently, the rules to determine where the &quot;code&quot; ends are somewhat convoluted.<div style="height: 1.00em;">
&#160;</div>
This feature can be used together with the special variable $^N to capture the results of submatches in variables without having to keep track of the number of nested parentheses. For example:<div style="height: 1.00em;">
&#160;</div>
<br/>
  $_ = &quot;The brown fox jumps over the lazy dog&quot;;<br/>
  /the (\S+)(?{ $color = $^N }) (\S+)(?{ $animal = $^N })/i;<br/>
  print &quot;color = $color, animal = $animal\n&quot;;<br/>
<div style="height: 1.00em;">
&#160;</div>
Inside the &quot;(?{...})&quot; block, $_ refers to the string the regular expression is matching against. You can also use &quot;pos()&quot; to know what is the current position of matching within this string.<div style="height: 1.00em;">
&#160;</div>
The &quot;code&quot; is properly scoped in the following sense: If the assertion is backtracked (compare &quot;Backtracking&quot;), all changes introduced after &quot;local&quot;ization are undone, so that<div style="height: 1.00em;">
&#160;</div>
<br/>
  $_ = 'a' x 8;<br/>
  m&lt;<br/>
     (?{ $cnt = 0 })                   # Initialize $cnt.<br/>
     (<br/>
       a<br/>
       (?{<br/>
           local $cnt = $cnt + 1;      # Update $cnt, backtracking-safe.<br/>
       })<br/>
     )*<br/>
     aaaa<br/>
     (?{ $res = $cnt })                # On success copy to<br/>
                                       # non-localized location.<br/>
   &gt;x;<br/>
<div style="height: 1.00em;">
&#160;</div>
will set &quot;$res = 4&quot;.  Note that after the match, $cnt returns to the globally introduced value, because the scopes that restrict &quot;local&quot; operators are unwound.<div style="height: 1.00em;">
&#160;</div>
This assertion may be used as a &quot;(?(condition)yes-pattern|no-pattern)&quot; switch.  If  <i>not</i> used in this way, the result of evaluation of &quot;code&quot; is put into the special variable $^R.  This happens immediately, so $^R can be used from other &quot;(?{ code })&quot; assertions inside the same regular expression.<div style="height: 1.00em;">
&#160;</div>
The assignment to $^R above is properly localized, so the old value of $^R is restored if the assertion is backtracked; compare &quot;Backtracking&quot;.<div style="height: 1.00em;">
&#160;</div>
For reasons of security, this construct is forbidden if the regular expression involves run-time interpolation of variables, unless the perilous &quot;use re 'eval'&quot; pragma has been used (see re), or the variables contain results of the &quot;qr//&quot; operator (see &quot;qr/STRING/msixpodual&quot; in perlop).<div style="height: 1.00em;">
&#160;</div>
This restriction is due to the wide-spread and remarkably convenient custom of using run-time determined strings as patterns.  For example:<div style="height: 1.00em;">
&#160;</div>
<br/>
    $re = &lt;&gt;;<br/>
    chomp $re;<br/>
    $string =~ /$re/;<br/>
<div style="height: 1.00em;">
&#160;</div>
Before Perl knew how to execute interpolated code within a pattern, this operation was completely safe from a security point of view, although it could raise an exception from an illegal pattern.  If you turn on the &quot;use re 'eval'&quot;, though, it is no longer secure, so you should only do so if you are also using taint checking. Better yet, use the carefully constrained evaluation within a Safe compartment.  See perlsec for details about both these mechanisms.<div style="height: 1.00em;">
&#160;</div>
<b>WARNING</b>: Use of lexical (&quot;my&quot;) variables in these blocks is broken. The result is unpredictable and will make perl unstable. The workaround is to use global (&quot;our&quot;) variables.<div style="height: 1.00em;">
&#160;</div>
<b>WARNING</b>: In perl 5.12.x and earlier, the regex engine was not re-entrant, so interpolated code could not safely invoke the regex engine either directly with &quot;m//&quot; or &quot;s///&quot;), or indirectly with functions such as &quot;split&quot;. Invoking the regex engine in these blocks would make perl unstable.</dd>
</dl>
<dl>
<dt>
&quot;(??{ code })&quot;</dt>
<dd>
<b>WARNING</b>: This extended regular expression feature is considered experimental, and may be changed without notice. Code executed that has side effects may not perform identically from version to version due to the effect of future optimisations in the regex engine.<div style="height: 1.00em;">
&#160;</div>
This is a &quot;postponed&quot; regular subexpression.  The &quot;code&quot; is evaluated at run time, at the moment this subexpression may match.  The result of evaluation is considered a regular expression and matched as if it were inserted instead of this construct.  Note that this means that the contents of capture groups defined inside an eval'ed pattern are not available outside of the pattern, and vice versa, there is no way for the inner pattern to refer to a capture group defined outside. Thus,<div style="height: 1.00em;">
&#160;</div>
<br/>
    ('a' x 100)=~/(??{'(.)' x 100})/<br/>
<div style="height: 1.00em;">
&#160;</div>
<b>will</b> match, it will <b>not</b> set $1.<div style="height: 1.00em;">
&#160;</div>
The &quot;code&quot; is not interpolated.  As before, the rules to determine where the &quot;code&quot; ends are currently somewhat convoluted.<div style="height: 1.00em;">
&#160;</div>
The following pattern matches a parenthesized group:<div style="height: 1.00em;">
&#160;</div>
<br/>
  $re = qr{<br/>
             \(<br/>
             (?:<br/>
                (?&gt; [^()]+ )       # Non-parens without backtracking<br/>
              |<br/>
                (??{ $re })        # Group with matching parens<br/>
             )*<br/>
             \)<br/>
          }x;<br/>
<div style="height: 1.00em;">
&#160;</div>
See also &quot;(?PARNO)&quot; for a different, more efficient way to accomplish the same task.<div style="height: 1.00em;">
&#160;</div>
For reasons of security, this construct is forbidden if the regular expression involves run-time interpolation of variables, unless the perilous &quot;use re 'eval'&quot; pragma has been used (see re), or the variables contain results of the &quot;qr//&quot; operator (see &quot;qr/STRING/msixpodual&quot; in perlop).<div style="height: 1.00em;">
&#160;</div>
In perl 5.12.x and earlier, because the regex engine was not re-entrant, delayed code could not safely invoke the regex engine either directly with &quot;m//&quot; or &quot;s///&quot;), or indirectly with functions such as &quot;split&quot;.<div style="height: 1.00em;">
&#160;</div>
Recursing deeper than 50 times without consuming any input string will result in a fatal error.  The maximum depth is compiled into perl, so changing it requires a custom build.</dd>
</dl>
<dl>
<dt>
&quot;(?PARNO)&quot; &quot;(?-PARNO)&quot; &quot;(?+PARNO)&quot; &quot;(?R)&quot; &quot;(?0)&quot;</dt>
<dd>
Similar to &quot;(??{ code })&quot; except it does not involve compiling any code, instead it treats the contents of a capture group as an independent pattern that must match at the current position.  Capture groups contained by the pattern will have the value as determined by the outermost recursion.<div style="height: 1.00em;">
&#160;</div>
PARNO is a sequence of digits (not starting with 0) whose value reflects the paren-number of the capture group to recurse to. &quot;(?R)&quot; recurses to the beginning of the whole pattern. &quot;(?0)&quot; is an alternate syntax for &quot;(?R)&quot;. If PARNO is preceded by a plus or minus sign then it is assumed to be relative, with negative numbers indicating preceding capture groups and positive ones following. Thus &quot;(?-1)&quot; refers to the most recently declared group, and &quot;(?+1)&quot; indicates the next group to be declared. Note that the counting for relative recursion differs from that of relative backreferences, in that with recursion unclosed groups  <b>are</b> included.<div style="height: 1.00em;">
&#160;</div>
The following pattern matches a function <i>foo()</i> which may contain balanced parentheses as the argument.<div style="height: 1.00em;">
&#160;</div>
<br/>
  $re = qr{ (                    # paren group 1 (full function)<br/>
              foo<br/>
              (                  # paren group 2 (parens)<br/>
                \(<br/>
                  (              # paren group 3 (contents of parens)<br/>
                  (?:<br/>
                   (?&gt; [^()]+ )  # Non-parens without backtracking<br/>
                  |<br/>
                   (?2)          # Recurse to start of paren group 2<br/>
                  )*<br/>
                  )<br/>
                \)<br/>
              )<br/>
            )<br/>
          }x;<br/>
<div style="height: 1.00em;">
&#160;</div>
If the pattern was used as follows<div style="height: 1.00em;">
&#160;</div>
<br/>
    'foo(bar(baz)+baz(bop))'=~/$re/<br/>
        and print &quot;\$1 = $1\n&quot;,<br/>
                  &quot;\$2 = $2\n&quot;,<br/>
                  &quot;\$3 = $3\n&quot;;<br/>
<div style="height: 1.00em;">
&#160;</div>
the output produced should be the following:<div style="height: 1.00em;">
&#160;</div>
<br/>
    $1 = foo(bar(baz)+baz(bop))<br/>
    $2 = (bar(baz)+baz(bop))<br/>
    $3 = bar(baz)+baz(bop)<br/>
<div style="height: 1.00em;">
&#160;</div>
If there is no corresponding capture group defined, then it is a fatal error.  Recursing deeper than 50 times without consuming any input string will also result in a fatal error.  The maximum depth is compiled into perl, so changing it requires a custom build.<div style="height: 1.00em;">
&#160;</div>
The following shows how using negative indexing can make it easier to embed recursive patterns inside of a &quot;qr//&quot; construct for later use:<div style="height: 1.00em;">
&#160;</div>
<br/>
    my $parens = qr/(\((?:[^()]++|(?-1))*+\))/;<br/>
    if (/foo $parens \s+ + \s+ bar $parens/x) {<br/>
       # do something here...<br/>
    }<br/>
<div style="height: 1.00em;">
&#160;</div>
<b>Note</b> that this pattern does not behave the same way as the equivalent PCRE or Python construct of the same form. In Perl you can backtrack into a recursed group, in PCRE and Python the recursed into group is treated as atomic. Also, modifiers are resolved at compile time, so constructs like (?i:(?1)) or (?:(?i)(?1)) do not affect how the sub-pattern will be processed.</dd>
</dl>
<dl>
<dt>
&quot;(?&amp;NAME)&quot;</dt>
<dd>
Recurse to a named subpattern. Identical to &quot;(?PARNO)&quot; except that the parenthesis to recurse to is determined by name. If multiple parentheses have the same name, then it recurses to the leftmost.<div style="height: 1.00em;">
&#160;</div>
It is an error to refer to a name that is not declared somewhere in the pattern.<div style="height: 1.00em;">
&#160;</div>
<b>NOTE:</b> In order to make things easier for programmers with experience with the Python or PCRE regex engines the pattern &quot;(?P&gt;NAME)&quot; may be used instead of &quot;(?&amp;NAME)&quot;.</dd>
</dl>
<dl>
<dt>
&quot;(?(condition)yes-pattern|no-pattern)&quot;</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
&quot;(?(condition)yes-pattern)&quot;</dt>
<dd>
Conditional expression. Matches &quot;yes-pattern&quot; if &quot;condition&quot; yields a true value, matches &quot;no-pattern&quot; otherwise. A missing pattern always matches.<div style="height: 1.00em;">
&#160;</div>
&quot;(condition)&quot; should be either an integer in parentheses (which is valid if the corresponding pair of parentheses matched), a look-ahead/look-behind/evaluate zero-width assertion, a name in angle brackets or single quotes (which is valid if a group with the given name matched), or the special symbol (R) (true when evaluated inside of recursion or eval). Additionally the R may be followed by a number, (which will be true when evaluated when recursing inside of the appropriate group), or by &amp;NAME, in which case it will be true only when evaluated during recursion in the named group.<div style="height: 1.00em;">
&#160;</div>
Here's a summary of the possible predicates:</dd>
</dl>
<div style="margin-left: 10.00ex;">
<dl>
<dt>
(1) (2) ...</dt>
<dd>
Checks if the numbered capturing group has matched something.</dd>
</dl>
<dl>
<dt>
(&lt;NAME&gt;) ('NAME')</dt>
<dd>
Checks if a group with the given name has matched something.</dd>
</dl>
<dl>
<dt>
(?=...) (?!...) (?&lt;=...) (?&lt;!...)</dt>
<dd>
Checks whether the pattern matches (or does not match, for the '!' variants).</dd>
</dl>
<dl>
<dt>
(?{ CODE })</dt>
<dd>
Treats the return value of the code block as the condition.</dd>
</dl>
<dl>
<dt>
(R)</dt>
<dd>
Checks if the expression has been evaluated inside of recursion.</dd>
</dl>
<dl>
<dt>
(R1) (R2) ...</dt>
<dd>
Checks if the expression has been evaluated while executing directly inside of the n-th capture group. This check is the regex equivalent of<div style="height: 1.00em;">
&#160;</div>
<br/>
  if ((caller(0))[3] eq 'subname') { ... }<br/>
<div style="height: 1.00em;">
&#160;</div>
In other words, it does not check the full recursion stack.</dd>
</dl>
<dl>
<dt>
(R&amp;NAME)</dt>
<dd>
Similar to &quot;(R1)&quot;, this predicate checks to see if we're executing directly inside of the leftmost group with a given name (this is the same logic used by &quot;(?&amp;NAME)&quot; to disambiguate). It does not check the full stack, but only the name of the innermost active recursion.</dd>
</dl>
<dl>
<dt>
(DEFINE)</dt>
<dd>
In this case, the yes-pattern is never directly executed, and no no-pattern is allowed. Similar in spirit to &quot;(?{0})&quot; but more efficient. See below for details.</dd>
</dl>
</div>
<div style="margin-left: 10.00ex;">
<div style="height: 1.00em;">
&#160;</div>
For example:<div style="height: 1.00em;">
&#160;</div>
<br/>
    m{ ( \( )?<br/>
       [^()]+<br/>
       (?(1) \) )<br/>
     }x<br/>
<div style="height: 1.00em;">
&#160;</div>
matches a chunk of non-parentheses, possibly included in parentheses themselves.<div style="height: 1.00em;">
&#160;</div>
A special form is the &quot;(DEFINE)&quot; predicate, which never executes its yes-pattern directly, and does not allow a no-pattern. This allows one to define subpatterns which will be executed only by the recursion mechanism. This way, you can define a set of regular expression rules that can be bundled into any pattern you choose.<div style="height: 1.00em;">
&#160;</div>
It is recommended that for this usage you put the DEFINE block at the end of the pattern, and that you name any subpatterns defined within it.<div style="height: 1.00em;">
&#160;</div>
Also, it's worth noting that patterns defined this way probably will not be as efficient, as the optimiser is not very clever about handling them.<div style="height: 1.00em;">
&#160;</div>
An example of how this might be used is as follows:<div style="height: 1.00em;">
&#160;</div>
<br/>
  /(?&lt;NAME&gt;(?&amp;NAME_PAT))(?&lt;ADDR&gt;(?&amp;ADDRESS_PAT))<br/>
   (?(DEFINE)<br/>
     (?&lt;NAME_PAT&gt;....)<br/>
     (?&lt;ADRESS_PAT&gt;....)<br/>
   )/x<br/>
<div style="height: 1.00em;">
&#160;</div>
Note that capture groups matched inside of recursion are not accessible after the recursion returns, so the extra layer of capturing groups is necessary. Thus $+{NAME_PAT} would not be defined even though $+{NAME} would be.</div>
<dl>
<dt>
&quot;(?&gt;pattern)&quot;</dt>
<dd>
An &quot;independent&quot; subexpression, one which matches the substring that a  <i>standalone</i> &quot;pattern&quot; would match if anchored at the given position, and it matches  <i>nothing other than this substring</i>.  This construct is useful for optimizations of what would otherwise be &quot;eternal&quot; matches, because it will not backtrack (see &quot;Backtracking&quot;). It may also be useful in places where the &quot;grab all you can, and do not give anything back&quot; semantic is desirable.<div style="height: 1.00em;">
&#160;</div>
For example: &quot;^(?&gt;a*)ab&quot; will never match, since &quot;(?&gt;a*)&quot; (anchored at the beginning of string, as above) will match  <i>all</i> characters &quot;a&quot; at the beginning of string, leaving no &quot;a&quot; for &quot;ab&quot; to match.  In contrast, &quot;a*ab&quot; will match the same as &quot;a+b&quot;, since the match of the subgroup &quot;a*&quot; is influenced by the following group &quot;ab&quot; (see &quot;Backtracking&quot;).  In particular, &quot;a*&quot; inside &quot;a*ab&quot; will match fewer characters than a standalone &quot;a*&quot;, since this makes the tail match.<div style="height: 1.00em;">
&#160;</div>
&quot;(?&gt;pattern)&quot; does not disable backtracking altogether once it has matched. It is still possible to backtrack past the construct, but not into it. So &quot;((?&gt;a*)|(?&gt;b*))ar&quot; will still match &quot;bar&quot;.<div style="height: 1.00em;">
&#160;</div>
An effect similar to &quot;(?&gt;pattern)&quot; may be achieved by writing &quot;(?=(pattern))\g{-1}&quot;.  This matches the same substring as a standalone &quot;a+&quot;, and the following &quot;\g{-1}&quot; eats the matched string; it therefore makes a zero-length assertion into an analogue of &quot;(?&gt;...)&quot;. (The difference between these two constructs is that the second one uses a capturing group, thus shifting ordinals of backreferences in the rest of a regular expression.)<div style="height: 1.00em;">
&#160;</div>
Consider this pattern:<div style="height: 1.00em;">
&#160;</div>
<br/>
    m{ \(<br/>
          (<br/>
            [^()]+           # x+<br/>
          |<br/>
            \( [^()]* \)<br/>
          )+<br/>
       \)<br/>
     }x<br/>
<div style="height: 1.00em;">
&#160;</div>
That will efficiently match a nonempty group with matching parentheses two levels deep or less.  However, if there is no such group, it will take virtually forever on a long string.  That's because there are so many different ways to split a long string into several substrings.  This is what &quot;(.+)+&quot; is doing, and &quot;(.+)+&quot; is similar to a subpattern of the above pattern.  Consider how the pattern above detects no-match on &quot;((()aaaaaaaaaaaaaaaaaa&quot; in several seconds, but that each extra letter doubles this time.  This exponential performance will make it appear that your program has hung.  However, a tiny change to this pattern<div style="height: 1.00em;">
&#160;</div>
<br/>
    m{ \(<br/>
          (<br/>
            (?&gt; [^()]+ )        # change x+ above to (?&gt; x+ )<br/>
          |<br/>
            \( [^()]* \)<br/>
          )+<br/>
       \)<br/>
     }x<br/>
<div style="height: 1.00em;">
&#160;</div>
which uses &quot;(?&gt;...)&quot; matches exactly when the one above does (verifying this yourself would be a productive exercise), but finishes in a fourth the time when used on a similar string with 1000000 &quot;a&quot;s.  Be aware, however, that, when this construct is followed by a quantifier, it currently triggers a warning message under the &quot;use warnings&quot; pragma or  <b>-w</b> switch saying it &quot;matches null string many times in regex&quot;.<div style="height: 1.00em;">
&#160;</div>
On simple groups, such as the pattern &quot;(?&gt; [^()]+ )&quot;, a comparable effect may be achieved by negative look-ahead, as in &quot;[^()]+ (?! [^()] )&quot;. This was only 4 times slower on a string with 1000000 &quot;a&quot;s.<div style="height: 1.00em;">
&#160;</div>
The &quot;grab all you can, and do not give anything back&quot; semantic is desirable in many situations where on the first sight a simple &quot;()*&quot; looks like the correct solution.  Suppose we parse text with comments being delimited by &quot;#&quot; followed by some optional (horizontal) whitespace.  Contrary to its appearance, &quot;#[ \t]*&quot;  <i>is not</i> the correct subexpression to match the comment delimiter, because it may &quot;give up&quot; some whitespace if the remainder of the pattern can be made to match that way.  The correct answer is either one of these:<div style="height: 1.00em;">
&#160;</div>
<br/>
    (?&gt;#[ \t]*)<br/>
    #[ \t]*(?![ \t])<br/>
<div style="height: 1.00em;">
&#160;</div>
For example, to grab non-empty comments into $1, one should use either one of these:<div style="height: 1.00em;">
&#160;</div>
<br/>
    / (?&gt; \# [ \t]* ) (        .+ ) /x;<br/>
    /     \# [ \t]*   ( [^ \t] .* ) /x;<br/>
<div style="height: 1.00em;">
&#160;</div>
Which one you pick depends on which of these expressions better reflects the above specification of comments.<div style="height: 1.00em;">
&#160;</div>
In some literature this construct is called &quot;atomic matching&quot; or &quot;possessive matching&quot;.<div style="height: 1.00em;">
&#160;</div>
Possessive quantifiers are equivalent to putting the item they are applied to inside of one of these constructs. The following equivalences apply:<div style="height: 1.00em;">
&#160;</div>
<br/>
    Quantifier Form     Bracketing Form<br/>
    ---------------     ---------------<br/>
    PAT*+               (?&gt;PAT*)<br/>
    PAT++               (?&gt;PAT+)<br/>
    PAT?+               (?&gt;PAT?)<br/>
    PAT{min,max}+       (?&gt;PAT{min,max})<br/>
</dd>
</dl>
</div>
<div class="subsection">
<h2>Special Backtracking Control Verbs</h2>  <b>WARNING:</b> These patterns are experimental and subject to change or removal in a future version of Perl. Their usage in production code should be noted to avoid problems during upgrades.<div class="spacer">
</div>
These special patterns are generally of the form &quot;(*VERB:ARG)&quot;. Unless otherwise stated the ARG argument is optional; in some cases, it is forbidden.<div class="spacer">
</div>
Any pattern containing a special backtracking verb that allows an argument has the special behaviour that when executed it sets the current package's $REGERROR and $REGMARK variables. When doing so the following rules apply:<div class="spacer">
</div>
On failure, the $REGERROR variable will be set to the ARG value of the verb pattern, if the verb was involved in the failure of the match. If the ARG part of the pattern was omitted, then $REGERROR will be set to the name of the last &quot;(*MARK:NAME)&quot; pattern executed, or to TRUE if there was none. Also, the $REGMARK variable will be set to FALSE.<div class="spacer">
</div>
On a successful match, the $REGERROR variable will be set to FALSE, and the $REGMARK variable will be set to the name of the last &quot;(*MARK:NAME)&quot; pattern executed.  See the explanation for the &quot;(*MARK:NAME)&quot; verb below for more details.<div class="spacer">
</div>
<b>NOTE:</b> $REGERROR and $REGMARK are not magic variables like $1 and most other regex-related variables. They are not local to a scope, nor readonly, but instead are volatile package variables similar to $AUTOLOAD. Use &quot;local&quot; to localize changes to them to a specific scope if necessary.<div class="spacer">
</div>
If a pattern does not contain a special backtracking verb that allows an argument, then $REGERROR and $REGMARK are not touched at all.<dl>
<dt>
Verbs that take an argument</dt>
<dd>
</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
&quot;(*PRUNE)&quot; &quot;(*PRUNE:NAME)&quot;</dt>
<dd>
This zero-width pattern prunes the backtracking tree at the current point when backtracked into on failure. Consider the pattern &quot;A (*PRUNE) B&quot;, where A and B are complex patterns. Until the &quot;(*PRUNE)&quot; verb is reached, A may backtrack as necessary to match. Once it is reached, matching continues in B, which may also backtrack as necessary; however, should B not match, then no further backtracking will take place, and the pattern will fail outright at the current starting position.<div style="height: 1.00em;">
&#160;</div>
The following example counts all the possible matching strings in a pattern (without actually matching any of them).<div style="height: 1.00em;">
&#160;</div>
<br/>
    'aaab' =~ /a+b?(?{print &quot;$&amp;\n&quot;; $count++})(*FAIL)/;<br/>
    print &quot;Count=$count\n&quot;;<br/>
<div style="height: 1.00em;">
&#160;</div>
which produces:<div style="height: 1.00em;">
&#160;</div>
<br/>
    aaab<br/>
    aaa<br/>
    aa<br/>
    a<br/>
    aab<br/>
    aa<br/>
    a<br/>
    ab<br/>
    a<br/>
    Count=9<br/>
<div style="height: 1.00em;">
&#160;</div>
If we add a &quot;(*PRUNE)&quot; before the count like the following<div style="height: 1.00em;">
&#160;</div>
<br/>
    'aaab' =~ /a+b?(*PRUNE)(?{print &quot;$&amp;\n&quot;; $count++})(*FAIL)/;<br/>
    print &quot;Count=$count\n&quot;;<br/>
<div style="height: 1.00em;">
&#160;</div>
we prevent backtracking and find the count of the longest matching string at each matching starting point like so:<div style="height: 1.00em;">
&#160;</div>
<br/>
    aaab<br/>
    aab<br/>
    ab<br/>
    Count=3<br/>
<div style="height: 1.00em;">
&#160;</div>
Any number of &quot;(*PRUNE)&quot; assertions may be used in a pattern.<div style="height: 1.00em;">
&#160;</div>
See also &quot;(?&gt;pattern)&quot; and possessive quantifiers for other ways to control backtracking. In some cases, the use of &quot;(*PRUNE)&quot; can be replaced with a &quot;(?&gt;pattern)&quot; with no functional difference; however, &quot;(*PRUNE)&quot; can be used to handle cases that cannot be expressed using a &quot;(?&gt;pattern)&quot; alone.</dd>
</dl>
<dl>
<dt>
&quot;(*SKIP)&quot; &quot;(*SKIP:NAME)&quot;</dt>
<dd>
This zero-width pattern is similar to &quot;(*PRUNE)&quot;, except that on failure it also signifies that whatever text that was matched leading up to the &quot;(*SKIP)&quot; pattern being executed cannot be part of  <i>any</i> match of this pattern. This effectively means that the regex engine &quot;skips&quot; forward to this position on failure and tries to match again, (assuming that there is sufficient room to match).<div style="height: 1.00em;">
&#160;</div>
The name of the &quot;(*SKIP:NAME)&quot; pattern has special significance. If a &quot;(*MARK:NAME)&quot; was encountered while matching, then it is that position which is used as the &quot;skip point&quot;. If no &quot;(*MARK)&quot; of that name was encountered, then the &quot;(*SKIP)&quot; operator has no effect. When used without a name the &quot;skip point&quot; is where the match point was when executing the (*SKIP) pattern.<div style="height: 1.00em;">
&#160;</div>
Compare the following to the examples in &quot;(*PRUNE)&quot;; note the string is twice as long:<div style="height: 1.00em;">
&#160;</div>
<br/>
    'aaabaaab' =~ /a+b?(*SKIP)(?{print &quot;$&amp;\n&quot;; $count++})(*FAIL)/;<br/>
    print &quot;Count=$count\n&quot;;<br/>
<div style="height: 1.00em;">
&#160;</div>
outputs<div style="height: 1.00em;">
&#160;</div>
<br/>
    aaab<br/>
    aaab<br/>
    Count=2<br/>
<div style="height: 1.00em;">
&#160;</div>
Once the 'aaab' at the start of the string has matched, and the &quot;(*SKIP)&quot; executed, the next starting point will be where the cursor was when the &quot;(*SKIP)&quot; was executed.</dd>
</dl>
<dl>
<dt>
&quot;(*MARK:NAME)&quot; &quot;(*:NAME)&quot; &quot;(*MARK:NAME)&quot; &quot;(*:NAME)&quot;</dt>
<dd>
This zero-width pattern can be used to mark the point reached in a string when a certain part of the pattern has been successfully matched. This mark may be given a name. A later &quot;(*SKIP)&quot; pattern will then skip forward to that point if backtracked into on failure. Any number of &quot;(*MARK)&quot; patterns are allowed, and the NAME portion may be duplicated.<div style="height: 1.00em;">
&#160;</div>
In addition to interacting with the &quot;(*SKIP)&quot; pattern, &quot;(*MARK:NAME)&quot; can be used to &quot;label&quot; a pattern branch, so that after matching, the program can determine which branches of the pattern were involved in the match.<div style="height: 1.00em;">
&#160;</div>
When a match is successful, the $REGMARK variable will be set to the name of the most recently executed &quot;(*MARK:NAME)&quot; that was involved in the match.<div style="height: 1.00em;">
&#160;</div>
This can be used to determine which branch of a pattern was matched without using a separate capture group for each branch, which in turn can result in a performance improvement, as perl cannot optimize &quot;/(?:(x)|(y)|(z))/&quot; as efficiently as something like &quot;/(?:x(*MARK:x)|y(*MARK:y)|z(*MARK:z))/&quot;.<div style="height: 1.00em;">
&#160;</div>
When a match has failed, and unless another verb has been involved in failing the match and has provided its own name to use, the $REGERROR variable will be set to the name of the most recently executed &quot;(*MARK:NAME)&quot;.<div style="height: 1.00em;">
&#160;</div>
See &quot;(*SKIP)&quot; for more details.<div style="height: 1.00em;">
&#160;</div>
As a shortcut &quot;(*MARK:NAME)&quot; can be written &quot;(*:NAME)&quot;.</dd>
</dl>
<dl>
<dt>
&quot;(*THEN)&quot; &quot;(*THEN:NAME)&quot;</dt>
<dd>
This is similar to the &quot;cut group&quot; operator &quot;::&quot; from Perl 6. Like &quot;(*PRUNE)&quot;, this verb always matches, and when backtracked into on failure, it causes the regex engine to try the next alternation in the innermost enclosing group (capturing or otherwise).<div style="height: 1.00em;">
&#160;</div>
Its name comes from the observation that this operation combined with the alternation operator (&quot;|&quot;) can be used to create what is essentially a pattern-based if/then/else block:<div style="height: 1.00em;">
&#160;</div>
<br/>
  ( COND (*THEN) FOO | COND2 (*THEN) BAR | COND3 (*THEN) BAZ )<br/>
<div style="height: 1.00em;">
&#160;</div>
Note that if this operator is used and NOT inside of an alternation then it acts exactly like the &quot;(*PRUNE)&quot; operator.<div style="height: 1.00em;">
&#160;</div>
<br/>
  / A (*PRUNE) B /<br/>
<div style="height: 1.00em;">
&#160;</div>
is the same as<div style="height: 1.00em;">
&#160;</div>
<br/>
  / A (*THEN) B /<br/>
<div style="height: 1.00em;">
&#160;</div>
but<div style="height: 1.00em;">
&#160;</div>
<br/>
  / ( A (*THEN) B | C (*THEN) D ) /<br/>
<div style="height: 1.00em;">
&#160;</div>
is not the same as<div style="height: 1.00em;">
&#160;</div>
<br/>
  / ( A (*PRUNE) B | C (*PRUNE) D ) /<br/>
<div style="height: 1.00em;">
&#160;</div>
as after matching the A but failing on the B the &quot;(*THEN)&quot; verb will backtrack and try C; but the &quot;(*PRUNE)&quot; verb will simply fail.</dd>
</dl>
<dl>
<dt>
&quot;(*COMMIT)&quot;</dt>
<dd>
This is the Perl 6 &quot;commit pattern&quot; &quot;&lt;commit&gt;&quot; or &quot;:::&quot;. It's a zero-width pattern similar to &quot;(*SKIP)&quot;, except that when backtracked into on failure it causes the match to fail outright. No further attempts to find a valid match by advancing the start pointer will occur again. For example,<div style="height: 1.00em;">
&#160;</div>
<br/>
    'aaabaaab' =~ /a+b?(*COMMIT)(?{print &quot;$&amp;\n&quot;; $count++})(*FAIL)/;<br/>
    print &quot;Count=$count\n&quot;;<br/>
<div style="height: 1.00em;">
&#160;</div>
outputs<div style="height: 1.00em;">
&#160;</div>
<br/>
    aaab<br/>
    Count=1<br/>
<div style="height: 1.00em;">
&#160;</div>
In other words, once the &quot;(*COMMIT)&quot; has been entered, and if the pattern does not match, the regex engine will not try any further matching on the rest of the string.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
</div>
<dl>
<dt>
Verbs without an argument</dt>
<dd>
</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
&quot;(*FAIL)&quot; &quot;(*F)&quot;</dt>
<dd>
This pattern matches nothing and always fails. It can be used to force the engine to backtrack. It is equivalent to &quot;(?!)&quot;, but easier to read. In fact, &quot;(?!)&quot; gets optimised into &quot;(*FAIL)&quot; internally.<div style="height: 1.00em;">
&#160;</div>
It is probably useful only when combined with &quot;(?{})&quot; or &quot;(??{})&quot;.</dd>
</dl>
<dl>
<dt>
&quot;(*ACCEPT)&quot;</dt>
<dd>
<b>WARNING:</b> This feature is highly experimental. It is not recommended for production code.<div style="height: 1.00em;">
&#160;</div>
This pattern matches nothing and causes the end of successful matching at the point at which the &quot;(*ACCEPT)&quot; pattern was encountered, regardless of whether there is actually more to match in the string. When inside of a nested pattern, such as recursion, or in a subpattern dynamically generated via &quot;(??{})&quot;, only the innermost pattern is ended immediately.<div style="height: 1.00em;">
&#160;</div>
If the &quot;(*ACCEPT)&quot; is inside of capturing groups then the groups are marked as ended at the point at which the &quot;(*ACCEPT)&quot; was encountered. For instance:<div style="height: 1.00em;">
&#160;</div>
<br/>
  'AB' =~ /(A (A|B(*ACCEPT)|C) D)(E)/x;<br/>
<div style="height: 1.00em;">
&#160;</div>
will match, and $1 will be &quot;AB&quot; and $2 will be &quot;B&quot;, $3 will not be set. If another branch in the inner parentheses was matched, such as in the string 'ACDE', then the &quot;D&quot; and &quot;E&quot; would have to be matched as well.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
</div>
</div>
<div class="subsection">
<h2>Backtracking</h2> NOTE: This section presents an abstract approximation of regular expression behavior.  For a more rigorous (and complicated) view of the rules involved in selecting a match among possible alternatives, see &quot;Combining RE Pieces&quot;.<div class="spacer">
</div>
A fundamental feature of regular expression matching involves the notion called  <i>backtracking</i>, which is currently used (when needed) by all regular non-possessive expression quantifiers, namely &quot;*&quot;, &quot;*?&quot;, &quot;+&quot;, &quot;+?&quot;, &quot;{n,m}&quot;, and &quot;{n,m}?&quot;.  Backtracking is often optimized internally, but the general principle outlined here is valid.<div class="spacer">
</div>
For a regular expression to match, the <i>entire</i> regular expression must match, not just part of it.  So if the beginning of a pattern containing a quantifier succeeds in a way that causes later parts in the pattern to fail, the matching engine backs up and recalculates the beginning part--that's why it's called backtracking.<div class="spacer">
</div>
Here is an example of backtracking:  Let's say you want to find the word following &quot;foo&quot; in the string &quot;Food is on the foo table.&quot;:<div class="spacer">
</div>
<br/>
    $_ = &quot;Food is on the foo table.&quot;;<br/>
    if ( /\b(foo)\s+(\w+)/i ) {<br/>
        print &quot;$2 follows $1.\n&quot;;<br/>
    }<br/>
<div class="spacer">
</div>
When the match runs, the first part of the regular expression (&quot;\b(foo)&quot;) finds a possible match right at the beginning of the string, and loads up $1 with &quot;Foo&quot;.  However, as soon as the matching engine sees that there's no whitespace following the &quot;Foo&quot; that it had saved in $1, it realizes its mistake and starts over again one character after where it had the tentative match.  This time it goes all the way until the next occurrence of &quot;foo&quot;. The complete regular expression matches this time, and you get the expected output of &quot;table follows foo.&quot;<div class="spacer">
</div>
Sometimes minimal matching can help a lot.  Imagine you'd like to match everything between &quot;foo&quot; and &quot;bar&quot;.  Initially, you write something like this:<div class="spacer">
</div>
<br/>
    $_ =  &quot;The food is under the bar in the barn.&quot;;<br/>
    if ( /foo(.*)bar/ ) {<br/>
        print &quot;got &lt;$1&gt;\n&quot;;<br/>
    }<br/>
<div class="spacer">
</div>
Which perhaps unexpectedly yields:<div class="spacer">
</div>
<br/>
  got &lt;d is under the bar in the &gt;<br/>
<div class="spacer">
</div>
That's because &quot;.*&quot; was greedy, so you get everything between the  <i>first</i> &quot;foo&quot; and the <i>last</i> &quot;bar&quot;.  Here it's more effective to use minimal matching to make sure you get the text between a &quot;foo&quot; and the first &quot;bar&quot; thereafter.<div class="spacer">
</div>
<br/>
    if ( /foo(.*?)bar/ ) { print &quot;got &lt;$1&gt;\n&quot; }<br/>
  got &lt;d is under the &gt;<br/>
<div class="spacer">
</div>
Here's another example. Let's say you'd like to match a number at the end of a string, and you also want to keep the preceding part of the match. So you write this:<div class="spacer">
</div>
<br/>
    $_ = &quot;I have 2 numbers: 53147&quot;;<br/>
    if ( /(.*)(\d*)/ ) {                                # Wrong!<br/>
        print &quot;Beginning is &lt;$1&gt;, number is &lt;$2&gt;.\n&quot;;<br/>
    }<br/>
<div class="spacer">
</div>
That won't work at all, because &quot;.*&quot; was greedy and gobbled up the whole string. As &quot;\d*&quot; can match on an empty string the complete regular expression matched successfully.<div class="spacer">
</div>
<br/>
    Beginning is &lt;I have 2 numbers: 53147&gt;, number is &lt;&gt;.<br/>
<div class="spacer">
</div>
Here are some variants, most of which don't work:<div class="spacer">
</div>
<br/>
    $_ = &quot;I have 2 numbers: 53147&quot;;<br/>
    @pats = qw{<br/>
        (.*)(\d*)<br/>
        (.*)(\d+)<br/>
        (.*?)(\d*)<br/>
        (.*?)(\d+)<br/>
        (.*)(\d+)$<br/>
        (.*?)(\d+)$<br/>
        (.*)\b(\d+)$<br/>
        (.*\D)(\d+)$<br/>
    };<br/>
<br/>
    for $pat (@pats) {<br/>
        printf &quot;%-12s &quot;, $pat;<br/>
        if ( /$pat/ ) {<br/>
            print &quot;&lt;$1&gt; &lt;$2&gt;\n&quot;;<br/>
        } else {<br/>
            print &quot;FAIL\n&quot;;<br/>
        }<br/>
    }<br/>
<div class="spacer">
</div>
That will print out:<div class="spacer">
</div>
<br/>
    (.*)(\d*)    &lt;I have 2 numbers: 53147&gt; &lt;&gt;<br/>
    (.*)(\d+)    &lt;I have 2 numbers: 5314&gt; &lt;7&gt;<br/>
    (.*?)(\d*)   &lt;&gt; &lt;&gt;<br/>
    (.*?)(\d+)   &lt;I have &gt; &lt;2&gt;<br/>
    (.*)(\d+)$   &lt;I have 2 numbers: 5314&gt; &lt;7&gt;<br/>
    (.*?)(\d+)$  &lt;I have 2 numbers: &gt; &lt;53147&gt;<br/>
    (.*)\b(\d+)$ &lt;I have 2 numbers: &gt; &lt;53147&gt;<br/>
    (.*\D)(\d+)$ &lt;I have 2 numbers: &gt; &lt;53147&gt;<br/>
<div class="spacer">
</div>
As you see, this can be a bit tricky.  It's important to realize that a regular expression is merely a set of assertions that gives a definition of success.  There may be 0, 1, or several different ways that the definition might succeed against a particular string.  And if there are multiple ways it might succeed, you need to understand backtracking to know which variety of success you will achieve.<div class="spacer">
</div>
When using look-ahead assertions and negations, this can all get even trickier.  Imagine you'd like to find a sequence of non-digits not followed by &quot;123&quot;.  You might try to write that as<div class="spacer">
</div>
<br/>
    $_ = &quot;ABC123&quot;;<br/>
    if ( /^\D*(?!123)/ ) {                # Wrong!<br/>
        print &quot;Yup, no 123 in $_\n&quot;;<br/>
    }<br/>
<div class="spacer">
</div>
But that isn't going to match; at least, not the way you're hoping.  It claims that there is no 123 in the string.  Here's a clearer picture of why that pattern matches, contrary to popular expectations:<div class="spacer">
</div>
<br/>
    $x = 'ABC123';<br/>
    $y = 'ABC445';<br/>
<br/>
    print &quot;1: got $1\n&quot; if $x =~ /^(ABC)(?!123)/;<br/>
    print &quot;2: got $1\n&quot; if $y =~ /^(ABC)(?!123)/;<br/>
<br/>
    print &quot;3: got $1\n&quot; if $x =~ /^(\D*)(?!123)/;<br/>
    print &quot;4: got $1\n&quot; if $y =~ /^(\D*)(?!123)/;<br/>
<div class="spacer">
</div>
This prints<div class="spacer">
</div>
<br/>
    2: got ABC<br/>
    3: got AB<br/>
    4: got ABC<br/>
<div class="spacer">
</div>
You might have expected test 3 to fail because it seems to a more general purpose version of test 1.  The important difference between them is that test 3 contains a quantifier (&quot;\D*&quot;) and so can use backtracking, whereas test 1 will not.  What's happening is that you've asked &quot;Is it true that at the start of $x, following 0 or more non-digits, you have something that's not 123?&quot;  If the pattern matcher had let &quot;\D*&quot; expand to &quot;ABC&quot;, this would have caused the whole pattern to fail.<div class="spacer">
</div>
The search engine will initially match &quot;\D*&quot; with &quot;ABC&quot;.  Then it will try to match &quot;(?!123)&quot; with &quot;123&quot;, which fails.  But because a quantifier (&quot;\D*&quot;) has been used in the regular expression, the search engine can backtrack and retry the match differently in the hope of matching the complete regular expression.<div class="spacer">
</div>
The pattern really, <i>really</i> wants to succeed, so it uses the standard pattern back-off-and-retry and lets &quot;\D*&quot; expand to just &quot;AB&quot; this time.  Now there's indeed something following &quot;AB&quot; that is not &quot;123&quot;.  It's &quot;C123&quot;, which suffices.<div class="spacer">
</div>
We can deal with this by using both an assertion and a negation. We'll say that the first part in $1 must be followed both by a digit and by something that's not &quot;123&quot;.  Remember that the look-aheads are zero-width expressions--they only look, but don't consume any of the string in their match.  So rewriting this way produces what you'd expect; that is, case 5 will fail, but case 6 succeeds:<div class="spacer">
</div>
<br/>
    print &quot;5: got $1\n&quot; if $x =~ /^(\D*)(?=\d)(?!123)/;<br/>
    print &quot;6: got $1\n&quot; if $y =~ /^(\D*)(?=\d)(?!123)/;<br/>
<br/>
    6: got ABC<br/>
<div class="spacer">
</div>
In other words, the two zero-width assertions next to each other work as though they're ANDed together, just as you'd use any built-in assertions:  &quot;/^$/&quot; matches only if you're at the beginning of the line AND the end of the line simultaneously.  The deeper underlying truth is that juxtaposition in regular expressions always means AND, except when you write an explicit OR using the vertical bar.  &quot;/ab/&quot; means match &quot;a&quot; AND (then) match &quot;b&quot;, although the attempted matches are made at different positions because &quot;a&quot; is not a zero-width assertion, but a one-width assertion.<div class="spacer">
</div>
<b>WARNING</b>: Particularly complicated regular expressions can take exponential time to solve because of the immense number of possible ways they can use backtracking to try for a match.  For example, without internal optimizations done by the regular expression engine, this will take a painfully long time to run:<div class="spacer">
</div>
<br/>
    'aaaaaaaaaaaa' =~ /((a{0,5}){0,5})*[c]/<br/>
<div class="spacer">
</div>
And if you used &quot;*&quot;'s in the internal groups instead of limiting them to 0 through 5 matches, then it would take forever--or until you ran out of stack space.  Moreover, these internal optimizations are not always applicable.  For example, if you put &quot;{0,5}&quot; instead of &quot;*&quot; on the external group, no current optimization is applicable, and the match takes a long time to finish.<div class="spacer">
</div>
A powerful tool for optimizing such beasts is what is known as an &quot;independent group&quot;, which does not backtrack (see &quot;&quot;(?&gt;pattern)&quot;&quot;).  Note also that zero-length look-ahead/look-behind assertions will not backtrack to make the tail match, since they are in &quot;logical&quot; context: only whether they match is considered relevant.  For an example where side-effects of look-ahead  <i>might</i> have influenced the following match, see &quot;&quot;(?&gt;pattern)&quot;&quot;.</div>
<div class="subsection">
<h2>Version 8 Regular Expressions</h2> In case you're not familiar with the &quot;regular&quot; Version 8 regex routines, here are the pattern-matching rules not described above.<div class="spacer">
</div>
Any single character matches itself, unless it is a <i>metacharacter</i> with a special meaning described here or above.  You can cause characters that normally function as metacharacters to be interpreted literally by prefixing them with a &quot;\&quot; (e.g., &quot;\.&quot; matches a &quot;.&quot;, not any character; &quot;\\&quot; matches a &quot;\&quot;). This escape mechanism is also required for the character used as the pattern delimiter.<div class="spacer">
</div>
A series of characters matches that series of characters in the target string, so the pattern &quot;blurfl&quot; would match &quot;blurfl&quot; in the target string.<div class="spacer">
</div>
You can specify a character class, by enclosing a list of characters in &quot;[]&quot;, which will match any character from the list.  If the first character after the &quot;[&quot; is &quot;^&quot;, the class matches any character not in the list.  Within a list, the &quot;-&quot; character specifies a range, so that &quot;a-z&quot; represents all characters between &quot;a&quot; and &quot;z&quot;, inclusive.  If you want either &quot;-&quot; or &quot;]&quot; itself to be a member of a class, put it at the start of the list (possibly after a &quot;^&quot;), or escape it with a backslash.  &quot;-&quot; is also taken literally when it is at the end of the list, just before the closing &quot;]&quot;.  (The following all specify the same class of three characters: &quot;[-az]&quot;, &quot;[az-]&quot;, and &quot;[a\-z]&quot;.  All are different from &quot;[a-z]&quot;, which specifies a class containing twenty-six characters, even on EBCDIC-based character sets.)  Also, if you try to use the character classes &quot;\w&quot;, &quot;\W&quot;, &quot;\s&quot;, &quot;\S&quot;, &quot;\d&quot;, or &quot;\D&quot; as endpoints of a range, the &quot;-&quot; is understood literally.<div class="spacer">
</div>
Note also that the whole range idea is rather unportable between character sets--and even within character sets they may cause results you probably didn't expect.  A sound principle is to use only ranges that begin from and end at either alphabetics of equal case ([a-e], [A-E]), or digits ([0-9]).  Anything else is unsafe.  If in doubt, spell out the character sets in full.<div class="spacer">
</div>
Characters may be specified using a metacharacter syntax much like that used in C: &quot;\n&quot; matches a newline, &quot;\t&quot; a tab, &quot;\r&quot; a carriage return, &quot;\f&quot; a form feed, etc.  More generally, \ <i>nnn</i>, where <i>nnn</i> is a string of three octal digits, matches the character whose coded character set value is  <i>nnn</i>.  Similarly, \x<i>nn</i>, where <i>nn</i> are hexadecimal digits, matches the character whose ordinal is  <i>nn</i>. The expression \c<i>x</i> matches the character control- <i>x</i>.  Finally, the &quot;.&quot; metacharacter matches any character except &quot;\n&quot; (unless you use &quot;/s&quot;).<div class="spacer">
</div>
You can specify a series of alternatives for a pattern using &quot;|&quot; to separate them, so that &quot;fee|fie|foe&quot; will match any of &quot;fee&quot;, &quot;fie&quot;, or &quot;foe&quot; in the target string (as would &quot;f(e|i|o)e&quot;).  The first alternative includes everything from the last pattern delimiter (&quot;(&quot;, &quot;(?:&quot;, etc. or the beginning of the pattern) up to the first &quot;|&quot;, and the last alternative contains everything from the last &quot;|&quot; to the next closing pattern delimiter.  That's why it's common practice to include alternatives in parentheses: to minimize confusion about where they start and end.<div class="spacer">
</div>
Alternatives are tried from left to right, so the first alternative found for which the entire expression matches, is the one that is chosen. This means that alternatives are not necessarily greedy. For example: when matching &quot;foo|foot&quot; against &quot;barefoot&quot;, only the &quot;foo&quot; part will match, as that is the first alternative tried, and it successfully matches the target string. (This might not seem important, but it is important when you are capturing matched text using parentheses.)<div class="spacer">
</div>
Also remember that &quot;|&quot; is interpreted as a literal within square brackets, so if you write &quot;[fee|fie|foe]&quot; you're really only matching &quot;[feio|]&quot;.<div class="spacer">
</div>
Within a pattern, you may designate subpatterns for later reference by enclosing them in parentheses, and you may refer back to the  <i>n</i>th subpattern later in the pattern using the metacharacter \ <i>n</i> or \g<i>n</i>.  Subpatterns are numbered based on the left to right order of their opening parenthesis.  A backreference matches whatever actually matched the subpattern in the string being examined, not the rules for that subpattern.  Therefore, &quot;(0|0x)\d*\s\g1\d*&quot; will match &quot;0x1234 0x4321&quot;, but not &quot;0x1234 01234&quot;, because subpattern 1 matched &quot;0x&quot;, even though the rule &quot;0|0x&quot; could potentially match the leading 0 in the second number.</div>
<div class="subsection">
<h2>Warning on \1 Instead of $1</h2> Some people get too used to writing things like:<div class="spacer">
</div>
<br/>
    $pattern =~ s/(\W)/\\\1/g;<br/>
<div class="spacer">
</div>
This is grandfathered (for \1 to \9) for the RHS of a substitute to avoid shocking the  <b>sed</b> addicts, but it's a dirty habit to get into.  That's because in PerlThink, the righthand side of an &quot;s///&quot; is a double-quoted string.  &quot;\1&quot; in the usual double-quoted string means a control-A.  The customary Unix meaning of &quot;\1&quot; is kludged in for &quot;s///&quot;.  However, if you get into the habit of doing that, you get yourself into trouble if you then add an &quot;/e&quot; modifier.<div class="spacer">
</div>
<br/>
    s/(\d+)/ \1 + 1 /eg;            # causes warning under -w<br/>
<div class="spacer">
</div>
Or if you try to do<div class="spacer">
</div>
<br/>
    s/(\d+)/\1000/;<br/>
<div class="spacer">
</div>
You can't disambiguate that by saying &quot;\{1}000&quot;, whereas you can fix it with &quot;${1}000&quot;.  The operation of interpolation should not be confused with the operation of matching a backreference.  Certainly they mean two different things on the  <i>left</i> side of the &quot;s///&quot;.</div>
<div class="subsection">
<h2>Repeated Patterns Matching a Zero-length Substring</h2>  <b>WARNING</b>: Difficult material (and prose) ahead.  This section needs a rewrite.<div class="spacer">
</div>
Regular expressions provide a terse and powerful programming language.  As with most other power tools, power comes together with the ability to wreak havoc.<div class="spacer">
</div>
A common abuse of this power stems from the ability to make infinite loops using regular expressions, with something as innocuous as:<div class="spacer">
</div>
<br/>
    'foo' =~ m{ ( o? )* }x;<br/>
<div class="spacer">
</div>
The &quot;o?&quot; matches at the beginning of 'foo', and since the position in the string is not moved by the match, &quot;o?&quot; would match again and again because of the &quot;*&quot; quantifier.  Another common way to create a similar cycle is with the looping modifier &quot;//g&quot;:<div class="spacer">
</div>
<br/>
    @matches = ( 'foo' =~ m{ o? }xg );<br/>
<div class="spacer">
</div>
or<div class="spacer">
</div>
<br/>
    print &quot;match: &lt;$&amp;&gt;\n&quot; while 'foo' =~ m{ o? }xg;<br/>
<div class="spacer">
</div>
or the loop implied by <i>split()</i>.<div class="spacer">
</div>
However, long experience has shown that many programming tasks may be significantly simplified by using repeated subexpressions that may match zero-length substrings.  Here's a simple example being:<div class="spacer">
</div>
<br/>
    @chars = split //, $string;                  # // is not magic in split<br/>
    ($whitewashed = $string) =~ s/()/ /g; # parens avoid magic s// /<br/>
<div class="spacer">
</div>
Thus Perl allows such constructs, by <i>forcefully breaking</i>  <i>the infinite loop</i>.  The rules for this are different for lower-level loops given by the greedy quantifiers &quot;*+{}&quot;, and for higher-level ones like the &quot;/g&quot; modifier or  <i>split()</i> operator.<div class="spacer">
</div>
The lower-level loops are <i>interrupted</i> (that is, the loop is broken) when Perl detects that a repeated expression matched a zero-length substring.   Thus<div class="spacer">
</div>
<br/>
   m{ (?: NON_ZERO_LENGTH | ZERO_LENGTH )* }x;<br/>
<div class="spacer">
</div>
is made equivalent to<div class="spacer">
</div>
<br/>
   m{ (?: NON_ZERO_LENGTH )* (?: ZERO_LENGTH )? }x;<br/>
<div class="spacer">
</div>
For example, this program<div class="spacer">
</div>
<br/>
   #!perl -l<br/>
   &quot;aaaaab&quot; =~ /<br/>
     (?:<br/>
        a                 # non-zero<br/>
        |                 # or<br/>
       (?{print &quot;hello&quot;}) # print hello whenever this<br/>
                          #    branch is tried<br/>
       (?=(b))            # zero-width assertion<br/>
     )*  # any number of times<br/>
    /x;<br/>
   print $&amp;;<br/>
   print $1;<br/>
<div class="spacer">
</div>
prints<div class="spacer">
</div>
<br/>
   hello<br/>
   aaaaa<br/>
   b<br/>
<div class="spacer">
</div>
Notice that &quot;hello&quot; is only printed once, as when Perl sees that the sixth iteration of the outermost &quot;(?:)*&quot; matches a zero-length string, it stops the &quot;*&quot;.<div class="spacer">
</div>
The higher-level loops preserve an additional state between iterations: whether the last match was zero-length.  To break the loop, the following match after a zero-length match is prohibited to have a length of zero. This prohibition interacts with backtracking (see &quot;Backtracking&quot;), and so the  <i>second best</i> match is chosen if the <i>best</i> match is of zero length.<div class="spacer">
</div>
For example:<div class="spacer">
</div>
<br/>
    $_ = 'bar';<br/>
    s/\w??/&lt;$&amp;&gt;/g;<br/>
<div class="spacer">
</div>
results in &quot;&lt;&gt;&lt;b&gt;&lt;&gt;&lt;a&gt;&lt;&gt;&lt;r&gt;&lt;&gt;&quot;.  At each position of the string the best match given by non-greedy &quot;??&quot; is the zero-length match, and the  <i>second</i>  <i>best</i> match is what is matched by &quot;\w&quot;.  Thus zero-length matches alternate with one-character-long matches.<div class="spacer">
</div>
Similarly, for repeated &quot;m/()/g&quot; the second-best match is the match at the position one notch further in the string.<div class="spacer">
</div>
The additional state of being <i>matched with zero-length</i> is associated with the matched string, and is reset by each assignment to  <i>pos()</i>. Zero-length matches at the end of the previous match are ignored during &quot;split&quot;.</div>
<div class="subsection">
<h2>Combining RE Pieces</h2> Each of the elementary pieces of regular expressions which were described before (such as &quot;ab&quot; or &quot;\Z&quot;) could match at most one substring at the given position of the input string.  However, in a typical regular expression these elementary pieces are combined into more complicated patterns using combining operators &quot;ST&quot;, &quot;S|T&quot;, &quot;S*&quot; etc. (in these examples &quot;S&quot; and &quot;T&quot; are regular subexpressions).<div class="spacer">
</div>
Such combinations can include alternatives, leading to a problem of choice: if we match a regular expression &quot;a|ab&quot; against &quot;abc&quot;, will it match substring &quot;a&quot; or &quot;ab&quot;?  One way to describe which substring is actually matched is the concept of backtracking (see &quot;Backtracking&quot;). However, this description is too low-level and makes you think in terms of a particular implementation.<div class="spacer">
</div>
Another description starts with notions of &quot;better&quot;/&quot;worse&quot;.  All the substrings which may be matched by the given regular expression can be sorted from the &quot;best&quot; match to the &quot;worst&quot; match, and it is the &quot;best&quot; match which is chosen.  This substitutes the question of &quot;what is chosen?&quot; by the question of &quot;which matches are better, and which are worse?&quot;.<div class="spacer">
</div>
Again, for elementary pieces there is no such question, since at most one match at a given position is possible.  This section describes the notion of better/worse for combining operators.  In the description below &quot;S&quot; and &quot;T&quot; are regular subexpressions.<dl>
<dt>
&quot;ST&quot;</dt>
<dd>
Consider two possible matches, &quot;AB&quot; and &quot;A'B'&quot;, &quot;A&quot; and &quot;A'&quot; are substrings which can be matched by &quot;S&quot;, &quot;B&quot; and &quot;B'&quot; are substrings which can be matched by &quot;T&quot;.<div style="height: 1.00em;">
&#160;</div>
If &quot;A&quot; is a better match for &quot;S&quot; than &quot;A'&quot;, &quot;AB&quot; is a better match than &quot;A'B'&quot;.<div style="height: 1.00em;">
&#160;</div>
If &quot;A&quot; and &quot;A'&quot; coincide: &quot;AB&quot; is a better match than &quot;AB'&quot; if &quot;B&quot; is a better match for &quot;T&quot; than &quot;B'&quot;.</dd>
</dl>
<dl>
<dt>
&quot;S|T&quot;</dt>
<dd>
When &quot;S&quot; can match, it is a better match than when only &quot;T&quot; can match.<div style="height: 1.00em;">
&#160;</div>
Ordering of two matches for &quot;S&quot; is the same as for &quot;S&quot;.  Similar for two matches for &quot;T&quot;.</dd>
</dl>
<dl>
<dt>
&quot;S{REPEAT_COUNT}&quot;</dt>
<dd>
Matches as &quot;SSS...S&quot; (repeated as many times as necessary).</dd>
</dl>
<dl>
<dt>
&quot;S{min,max}&quot;</dt>
<dd>
Matches as &quot;S{max}|S{max-1}|...|S{min+1}|S{min}&quot;.</dd>
</dl>
<dl>
<dt>
&quot;S{min,max}?&quot;</dt>
<dd>
Matches as &quot;S{min}|S{min+1}|...|S{max-1}|S{max}&quot;.</dd>
</dl>
<dl>
<dt>
&quot;S?&quot;, &quot;S*&quot;, &quot;S+&quot;</dt>
<dd>
Same as &quot;S{0,1}&quot;, &quot;S{0,BIG_NUMBER}&quot;, &quot;S{1,BIG_NUMBER}&quot; respectively.</dd>
</dl>
<dl>
<dt>
&quot;S??&quot;, &quot;S*?&quot;, &quot;S+?&quot;</dt>
<dd>
Same as &quot;S{0,1}?&quot;, &quot;S{0,BIG_NUMBER}?&quot;, &quot;S{1,BIG_NUMBER}?&quot; respectively.</dd>
</dl>
<dl>
<dt>
&quot;(?&gt;S)&quot;</dt>
<dd>
Matches the best match for &quot;S&quot; and only that.</dd>
</dl>
<dl>
<dt>
&quot;(?=S)&quot;, &quot;(?&lt;=S)&quot;</dt>
<dd>
Only the best match for &quot;S&quot; is considered.  (This is important only if &quot;S&quot; has capturing parentheses, and backreferences are used somewhere else in the whole regular expression.)</dd>
</dl>
<dl>
<dt>
&quot;(?!S)&quot;, &quot;(?&lt;!S)&quot;</dt>
<dd>
For this grouping operator there is no need to describe the ordering, since only whether or not &quot;S&quot; can match is important.</dd>
</dl>
<dl>
<dt>
&quot;(??{ EXPR })&quot;, &quot;(?PARNO)&quot;</dt>
<dd>
The ordering is the same as for the regular expression which is the result of EXPR, or the pattern contained by capture group PARNO.</dd>
</dl>
<dl>
<dt>
&quot;(?(condition)yes-pattern|no-pattern)&quot;</dt>
<dd>
Recall that which of &quot;yes-pattern&quot; or &quot;no-pattern&quot; actually matches is already determined.  The ordering of the matches is the same as for the chosen subexpression.</dd>
</dl>
<div class="spacer">
</div>
The above recipes describe the ordering of matches <i>at a given position</i>. One more rule is needed to understand how a match is determined for the whole regular expression: a match at an earlier position is always better than a match at a later position.</div>
<div class="subsection">
<h2>Creating Custom RE Engines</h2> As of Perl 5.10.0, one can create custom regular expression engines.  This is not for the faint of heart, as they have to plug in at the C level.  See perlreapi for more details.<div class="spacer">
</div>
As an alternative, overloaded constants (see overload) provide a simple way to extend the functionality of the RE engine, by substituting one pattern for another.<div class="spacer">
</div>
Suppose that we want to enable a new RE escape-sequence &quot;\Y|&quot; which matches at a boundary between whitespace characters and non-whitespace characters.  Note that &quot;(?=\S)(?&lt;!\S)|(?!\S)(?&lt;=\S)&quot; matches exactly at these positions, so we want to have each &quot;\Y|&quot; in the place of the more complicated version.  We can create a module &quot;customre&quot; to do this:<div class="spacer">
</div>
<br/>
    package customre;<br/>
    use overload;<br/>
<br/>
    sub import {<br/>
      shift;<br/>
      die &quot;No argument to customre::import allowed&quot; if @_;<br/>
      overload::constant 'qr' =&gt; \&amp;convert;<br/>
    }<br/>
<br/>
    sub invalid { die &quot;/$_[0]/: invalid escape '\\$_[1]'&quot;}<br/>
<br/>
    # We must also take care of not escaping the legitimate \\Y|<br/>
    # sequence, hence the presence of '\\' in the conversion rules.<br/>
    my %rules = ( '\\' =&gt; '\\\\',<br/>
                  'Y|' =&gt; qr/(?=\S)(?&lt;!\S)|(?!\S)(?&lt;=\S)/ );<br/>
    sub convert {<br/>
      my $re = shift;<br/>
      $re =~ s{<br/>
                \\ ( \\ | Y . )<br/>
              }<br/>
              { $rules{$1} or invalid($re,$1) }sgex;<br/>
      return $re;<br/>
    }<br/>
<div class="spacer">
</div>
Now &quot;use customre&quot; enables the new escape in constant regular expressions, i.e., those without any runtime variable interpolations. As documented in overload, this conversion will work only over literal parts of regular expressions.  For &quot;\Y|$re\Y|&quot; the variable part of this regular expression needs to be converted explicitly (but only if the special meaning of &quot;\Y|&quot; should be enabled inside $re):<div class="spacer">
</div>
<br/>
    use customre;<br/>
    $re = &lt;&gt;;<br/>
    chomp $re;<br/>
    $re = customre::convert $re;<br/>
    /\Y|$re\Y|/;<br/>
</div>
<div class="subsection">
<h2>PCRE/Python Support</h2> As of Perl 5.10.0, Perl supports several Python/PCRE-specific extensions to the regex syntax. While Perl programmers are encouraged to use the Perl-specific syntax, the following are also accepted:<dl>
<dt>
&quot;(?P&lt;NAME&gt;pattern)&quot;</dt>
<dd>
Define a named capture group. Equivalent to &quot;(?&lt;NAME&gt;pattern)&quot;.</dd>
</dl>
<dl>
<dt>
&quot;(?P=NAME)&quot;</dt>
<dd>
Backreference to a named capture group. Equivalent to &quot;\g{NAME}&quot;.</dd>
</dl>
<dl>
<dt>
&quot;(?P&gt;NAME)&quot;</dt>
<dd>
Subroutine call to a named capture group. Equivalent to &quot;(?&amp;NAME)&quot;.</dd>
</dl>
</div>
</div>
<div class="section">
<h1>BUGS</h1> Many regular expression constructs don't work on EBCDIC platforms.<div class="spacer">
</div>
There are a number of issues with regard to case-insensitive matching in Unicode rules.  See &quot;i&quot; under &quot;Modifiers&quot; above.<div class="spacer">
</div>
This document varies from difficult to understand to completely and utterly opaque.  The wandering prose riddled with jargon is hard to fathom in several places.<div class="spacer">
</div>
This document needs a rewrite that separates the tutorial content from the reference content.</div>
<div class="section">
<h1>SEE ALSO</h1> perlrequick.<div class="spacer">
</div>
perlretut.<div class="spacer">
</div>
&quot;Regexp Quote-Like Operators&quot; in perlop.<div class="spacer">
</div>
&quot;Gory details of parsing quoted constructs&quot; in perlop.<div class="spacer">
</div>
perlfaq6.<div class="spacer">
</div>
&quot;pos&quot; in perlfunc.<div class="spacer">
</div>
perllocale.<div class="spacer">
</div>
perlebcdic.<div class="spacer">
</div>
<i>Mastering Regular Expressions</i> by Jeffrey Friedl, published by O'Reilly and Associates.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-09-26</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

