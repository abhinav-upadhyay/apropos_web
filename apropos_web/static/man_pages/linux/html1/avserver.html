<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
AVSERVER(1)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
AVSERVER(1)</td>
<td class="head-vol">
 </td>
<td class="head-rtitle">
AVSERVER(1)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> avserver - avserver video server</div>
<div class="section">
<h1>SYNOPSIS</h1> avserver [options]</div>
<div class="section">
<h1>DESCRIPTION</h1> WARNING: avserver is unmaintained, largely broken and in need of a complete rewrite. It probably won't work for you. Use at your own risk.<div class="spacer">
</div>
avserver is a streaming server for both audio and video. It supports several live feeds, streaming from files and time shifting on live feeds (you can seek to positions in the past on each live feed, provided you specify a big enough feed storage in avserver.conf).<div class="spacer">
</div>
avserver runs in daemon mode by default; that is, it puts itself in the background and detaches from its TTY, unless it is launched in debug mode or a NoDaemon option is specified in the configuration file.<div class="spacer">
</div>
This documentation covers only the streaming aspects of avserver / avconv. All questions about parameters for avconv, codec questions, etc. are not covered here. Read  <i>avconv.html</i> for more information.<div class="subsection">
<h2>How does it work?</h2> avserver receives prerecorded files or FFM streams from some avconv instance as input, then streams them over RTP/RTSP/HTTP.<div class="spacer">
</div>
An avserver instance will listen on some port as specified in the configuration file. You can launch one or more instances of avconv and send one or more FFM streams to the port where avserver is expecting to receive them. Alternately, you can make avserver launch such avconv instances at startup.<div class="spacer">
</div>
Input streams are called feeds, and each one is specified by a &lt;Feed&gt; section in the configuration file.<div class="spacer">
</div>
For each feed you can have different output streams in various formats, each one specified by a &lt;Stream&gt; section in the configuration file.</div>
<div class="subsection">
<h2>Status stream</h2> avserver supports an HTTP interface which exposes the current status of the server.<div class="spacer">
</div>
Simply point your browser to the address of the special status stream specified in the configuration file.<div class="spacer">
</div>
For example if you have:<div class="spacer">
</div>
<br/>
        &lt;Stream status.html&gt;<br/>
        Format status<br/>
        <br/>
        # Only allow local people to get the status<br/>
        ACL allow localhost<br/>
        ACL allow 192.168.0.0 192.168.255.255<br/>
        &lt;/Stream&gt;<br/>
<div class="spacer">
</div>
then the server will post a page with the status information when the special stream  <i>status.html</i> is requested.</div>
<div class="subsection">
<h2>What can this do?</h2> When properly configured and running, you can capture video and audio in real time from a suitable capture card, and stream it out over the Internet to either Windows Media Player or RealAudio player (with some restrictions).<div class="spacer">
</div>
It can also stream from files, though that is currently broken. Very often, a web server can be used to serve up the files just as well.<div class="spacer">
</div>
It can stream prerecorded video from .ffm files, though it is somewhat tricky to make it work correctly.</div>
<div class="subsection">
<h2>What do I need?</h2> I use Linux on a 900 MHz Duron with a cheapo Bt848 based TV capture card. I'm using stock Linux 2.4.17 with the stock drivers. [Actually that isn't true, I needed some special drivers for my motherboard-based sound card.]<div class="spacer">
</div>
I understand that FreeBSD systems work just fine as well.</div>
<div class="subsection">
<h2>How do I make it work?</h2> First, build the kit. It *really* helps to have installed LAME first. Then when you run the avserver ./configure, make sure that you have the &quot;--enable-libmp3lame&quot; flag turned on.<div class="spacer">
</div>
LAME is important as it allows for streaming audio to Windows Media Player. Don't ask why the other audio types do not work.<div class="spacer">
</div>
As a simple test, just run the following two command lines where INPUTFILE is some file which you can decode with avconv:<div class="spacer">
</div>
<br/>
        ./avserver -f doc/avserver.conf &amp;<br/>
        ./avconv -i INPUTFILE http://localhost:8090/feed1.ffm<br/>
<div class="spacer">
</div>
At this point you should be able to go to your Windows machine and fire up Windows Media Player (WMP). Go to Open URL and enter<div class="spacer">
</div>
<br/>
            http://&lt;linuxbox&gt;:8090/test.asf<br/>
<div class="spacer">
</div>
You should (after a short delay) see video and hear audio.<div class="spacer">
</div>
WARNING: trying to stream test1.mpg doesn't work with WMP as it tries to transfer the entire file before starting to play. The same is true of AVI files.</div>
<div class="subsection">
<h2>What happens next?</h2> You should edit the avserver.conf file to suit your needs (in terms of frame rates etc). Then install avserver and avconv, write a script to start them up, and off you go.</div>
<div class="subsection">
<h2>Troubleshooting</h2>  <i>I don't hear any audio, but video is fine.</i><div class="spacer">
</div>
Maybe you didn't install LAME, or got your ./configure statement wrong. Check the avconv output to see if a line referring to MP3 is present. If not, then your configuration was incorrect. If it is, then maybe your wiring is not set up correctly. Maybe the sound card is not getting data from the right input source. Maybe you have a really awful audio interface (like I do) that only captures in stereo and also requires that one channel be flipped. If you are one of these people, then export 'AUDIO_FLIP_LEFT=1' before starting avconv.<div class="spacer">
</div>
<i>The audio and video lose sync after a while.</i><div class="spacer">
</div>
Yes, they do.<div class="spacer">
</div>
<i>After a long while, the video update rate goes way down in WMP.</i><div class="spacer">
</div>
Yes, it does. Who knows why?<div class="spacer">
</div>
<i>WMP 6.4 behaves differently to WMP 7.</i><div class="spacer">
</div>
Yes, it does. Any thoughts on this would be gratefully received. These differences extend to embedding WMP into a web page. [There are two object IDs that you can use: The old one, which does not play well, and the new one, which does (both tested on the same system). However, I suspect that the new one is not available unless you have installed WMP 7].</div>
<div class="subsection">
<h2>What else can it do?</h2> You can replay video from .ffm files that was recorded earlier. However, there are a number of caveats, including the fact that the avserver parameters must match the original parameters used to record the file. If they do not, then avserver deletes the file before recording into it. (Now that I write this, it seems broken).<div class="spacer">
</div>
You can fiddle with many of the codec choices and encoding parameters, and there are a bunch more parameters that you cannot control. Post a message to the mailing list if there are some 'must have' parameters. Look in avserver.conf for a list of the currently available controls.<div class="spacer">
</div>
It will automatically generate the ASX or RAM files that are often used in browsers. These files are actually redirections to the underlying ASF or RM file. The reason for this is that the browser often fetches the entire file before starting up the external viewer. The redirection files are very small and can be transferred quickly. [The stream itself is often 'infinite' and thus the browser tries to download it and never finishes.]</div>
<div class="subsection">
<h2>Tips</h2> * When you connect to a live stream, most players (WMP, RA, etc) want to buffer a certain number of seconds of material so that they can display the signal continuously. However, avserver (by default) starts sending data in realtime. This means that there is a pause of a few seconds while the buffering is being done by the player. The good news is that this can be cured by adding a '?buffer=5' to the end of the URL. This means that the stream should start 5 seconds in the past -- and so the first 5 seconds of the stream are sent as fast as the network will allow. It will then slow down to real time. This noticeably improves the startup experience.<div class="spacer">
</div>
You can also add a 'Preroll 15' statement into the avserver.conf that will add the 15 second prebuffering on all requests that do not otherwise specify a time. In addition, avserver will skip frames until a key_frame is found. This further reduces the startup delay by not transferring data that will be discarded.<div class="spacer">
</div>
* You may want to adjust the MaxBandwidth in the avserver.conf to limit the amount of bandwidth consumed by live streams.</div>
<div class="subsection">
<h2>Why does the ?buffer / Preroll stop working after a time?</h2> It turns out that (on my machine at least) the number of frames successfully grabbed is marginally less than the number that ought to be grabbed. This means that the timestamp in the encoded data stream gets behind realtime. This means that if you say 'Preroll 10', then when the stream gets 10 or more seconds behind, there is no Preroll left.<div class="spacer">
</div>
Fixing this requires a change in the internals of how timestamps are handled.</div>
<div class="subsection">
<h2>Does the &quot;?date=&quot; stuff work.</h2> Yes (subject to the limitation outlined above). Also note that whenever you start avserver, it deletes the ffm file (if any parameters have changed), thus wiping out what you had recorded before.<div class="spacer">
</div>
The format of the &quot;?date=xxxxxx&quot; is fairly flexible. You should use one of the following formats (the 'T' is literal):<div class="spacer">
</div>
<br/>
        * YYYY-MM-DDTHH:MM:SS     (localtime)<br/>
        * YYYY-MM-DDTHH:MM:SSZ    (UTC)<br/>
<div class="spacer">
</div>
You can omit the YYYY-MM-DD, and then it refers to the current day. However note that  <b>?date=16:00:00</b> refers to 16:00 on the current day -- this may be in the future and so is unlikely to be useful.<div class="spacer">
</div>
You use this by adding the ?date= to the end of the URL for the stream. For example:    <b>http://localhost:8080/test.asf?date=2002-07-26T23:05:00</b>.</div>
</div>
<div class="section">
<h1>OPTIONS</h1> All the numerical options, if not specified otherwise, accept in input a string representing a number, which may contain one of the International System number postfixes, for example 'K', 'M', 'G'. If 'i' is appended after the postfix, powers of 2 are used instead of powers of 10. The 'B' postfix multiplies the value for 8, and can be appended after another postfix or used alone. This allows using for example 'KB', 'MiB', 'G' and 'B' as postfix.<div class="spacer">
</div>
Options which do not take arguments are boolean options, and set the corresponding value to true. They can be set to false by prefixing with &quot;no&quot; the option name, for example using &quot;-nofoo&quot; in the command line will set to false the boolean option with name &quot;foo&quot;.<div class="subsection">
<h2>Stream specifiers</h2> Some options are applied per-stream, e.g. bitrate or codec. Stream specifiers are used to precisely specify which stream(s) does a given option belong to.<div class="spacer">
</div>
A stream specifier is a string generally appended to the option name and separated from it by a colon. E.g. &quot;-codec:a:1 ac3&quot; option contains &quot;a:1&quot; stream specifer, which matches the second audio stream. Therefore it would select the ac3 codec for the second audio stream.<div class="spacer">
</div>
A stream specifier can match several stream, the option is then applied to all of them. E.g. the stream specifier in &quot;-b:a 128k&quot; matches all audio streams.<div class="spacer">
</div>
An empty stream specifier matches all streams, for example &quot;-codec copy&quot; or &quot;-codec: copy&quot; would copy all the streams without reencoding.<div class="spacer">
</div>
Possible forms of stream specifiers are:<dl>
<dt>
<i>stream_index</i></dt>
<dd>
Matches the stream with this index. E.g. &quot;-threads:1 4&quot; would set the thread count for the second stream to 4.</dd>
</dl>
<dl>
<dt>
<i>stream_type</i><b>[:</b><i>stream_index</i><b>]</b></dt>
<dd>
<i>stream_type</i> is one of: 'v' for video, 'a' for audio, 's' for subtitle, 'd' for data and 't' for attachments. If  <i>stream_index</i> is given, then matches stream number  <i>stream_index</i> of this type. Otherwise matches all streams of this type.</dd>
</dl>
<dl>
<dt>
<b>p:</b><i>program_id</i><b>[:</b><i>stream_index</i><b>]</b></dt>
<dd>
If <i>stream_index</i> is given, then matches stream number <i>stream_index</i> in program with id  <i>program_id</i>. Otherwise matches all streams in this program.</dd>
</dl>
</div>
<div class="subsection">
<h2>Generic options</h2> These options are shared amongst the av* tools.<dl>
<dt>
<b>-L</b></dt>
<dd>
Show license.</dd>
</dl>
<dl>
<dt>
<b>-h, -?, -help, --help</b></dt>
<dd>
Show help.</dd>
</dl>
<dl>
<dt>
<b>-version</b></dt>
<dd>
Show version.</dd>
</dl>
<dl>
<dt>
<b>-formats</b></dt>
<dd>
Show available formats.<div style="height: 1.00em;">
&#160;</div>
The fields preceding the format names have the following meanings:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
<b>D</b></dt>
<dd>
Decoding available</dd>
</dl>
<dl>
<dt>
<b>E</b></dt>
<dd>
Encoding available</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
</div>
<dl>
<dt>
<b>-codecs</b></dt>
<dd>
Show available codecs.<div style="height: 1.00em;">
&#160;</div>
The fields preceding the codec names have the following meanings:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
<b>D</b></dt>
<dd>
Decoding available</dd>
</dl>
<dl>
<dt>
<b>E</b></dt>
<dd>
Encoding available</dd>
</dl>
<dl>
<dt>
<b>V/A/S</b></dt>
<dd>
Video/audio/subtitle codec</dd>
</dl>
<dl>
<dt>
<b>S</b></dt>
<dd>
Codec supports slices</dd>
</dl>
<dl>
<dt>
<b>D</b></dt>
<dd>
Codec supports direct rendering</dd>
</dl>
<dl>
<dt>
<b>T</b></dt>
<dd>
Codec can handle input truncated at random locations instead of only at frame boundaries</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
</div>
<dl>
<dt>
<b>-bsfs</b></dt>
<dd>
Show available bitstream filters.</dd>
</dl>
<dl>
<dt>
<b>-protocols</b></dt>
<dd>
Show available protocols.</dd>
</dl>
<dl>
<dt>
<b>-filters</b></dt>
<dd>
Show available libavfilter filters.</dd>
</dl>
<dl>
<dt>
<b>-pix_fmts</b></dt>
<dd>
Show available pixel formats.</dd>
</dl>
<dl>
<dt>
<b>-sample_fmts</b></dt>
<dd>
Show available sample formats.</dd>
</dl>
<dl>
<dt>
<b>-loglevel</b> <i>loglevel</i> <b>| -v</b> <i>loglevel</i></dt>
<dd>
Set the logging level used by the library.  <i>loglevel</i> is a number or a string containing one of the following values:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
<b>quiet</b></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<b>panic</b></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<b>fatal</b></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<b>error</b></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<b>warning</b></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<b>info</b></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<b>verbose</b></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<b>debug</b></dt>
<dd>
</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">
&#160;</div>
By default the program logs to stderr, if coloring is supported by the terminal, colors are used to mark errors and warnings. Log coloring can be disabled setting the environment variable  <b>AV_LOG_FORCE_NOCOLOR</b> or <b>NO_COLOR</b>, or can be forced setting the environment variable  <b>AV_LOG_FORCE_COLOR</b>. The use of the environment variable  <b>NO_COLOR</b> is deprecated and will be dropped in a following Libav version.</div>
</div>
<div class="subsection">
<h2>AVOptions</h2> These options are provided directly by the libavformat, libavdevice and libavcodec libraries. To see the list of available AVOptions, use the  <b>-help</b> option. They are separated into two categories:<dl>
<dt>
<b>generic</b></dt>
<dd>
These options can be set for any container, codec or device. Generic options are listed under AVFormatContext options for containers/devices and under AVCodecContext options for codecs.</dd>
</dl>
<dl>
<dt>
<b>private</b></dt>
<dd>
These options are specific to the given container, device or codec. Private options are listed under their corresponding containers/devices/codecs.</dd>
</dl>
<div class="spacer">
</div>
For example to write an ID3v2.3 header instead of a default ID3v2.4 to an MP3 file, use the  <b>id3v2_version</b> private option of the MP3 muxer:<div class="spacer">
</div>
<br/>
        avconv -i input.flac -id3v2_version 3 out.mp3<br/>
<div class="spacer">
</div>
All codec AVOptions are obviously per-stream, so the chapter on stream specifiers applies to them<div class="spacer">
</div>
Note <b>-nooption</b> syntax cannot be used for boolean AVOptions, use  <b>-option 0</b>/<b>-option 1</b>.<div class="spacer">
</div>
Note2 old undocumented way of specifying per-stream AVOptions by prepending v/a/s to the options name is now obsolete and will be removed soon.</div>
<div class="subsection">
<h2>Main options</h2><dl>
<dt>
<b>-f</b> <i>configfile</i></dt>
<dd>
Use <i>configfile</i> instead of <i>/etc/avserver.conf</i>.</dd>
</dl>
<dl>
<dt>
<b>-n</b></dt>
<dd>
Enable no-launch mode. This option disables all the Launch directives within the various &lt;Stream&gt; sections. Since avserver will not launch any avconv instances, you will have to launch them manually.</dd>
</dl>
<dl>
<dt>
<b>-d</b></dt>
<dd>
Enable debug mode. This option increases log verbosity, directs log messages to stdout and causes avserver to run in the foreground rather than as a daemon.</dd>
</dl>
</div>
</div>
<div class="section">
<h1>SEE ALSO</h1>  <i>avconv</i>(1), <i>avplay</i>(1), <i>avprobe</i>(1), the <i>avserver.conf</i> example and the Libav HTML documentation</div>
<div class="section">
<h1>AUTHORS</h1> The Libav developers</div>
<table class="foot">
<tr>
<td class="foot-date">
2016-04-01</td>
<td class="foot-os">
 </td>
</tr>
</table>
</div>
</body>
</html>

