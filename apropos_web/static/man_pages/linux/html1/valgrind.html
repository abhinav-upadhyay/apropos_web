<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
VALGRIND(1)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
VALGRIND(1)</td>
<td class="head-vol">
Release 3.7.0</td>
<td class="head-rtitle">
VALGRIND(1)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> valgrind - a suite of tools for debugging and profiling programs</div>
<div class="section">
<h1>SYNOPSIS</h1><div style="margin-left: 9.00ex;text-indent: -9.00ex;" class="spacer">
<b>valgrind</b> [<i>valgrind-options</i>] [<b>your-program</b>] [<i>your-program-options</i>]</div>
</div>
<div class="section">
<h1>DESCRIPTION</h1>  <b>Valgrind</b> is a flexible program for debugging and profiling Linux executables. It consists of a core, which provides a synthetic CPU in software, and a series of debugging and profiling tools. The architecture is modular, so that new tools can be created easily and without disturbing the existing structure.<div class="spacer">
</div>
Some of the options described below work with all Valgrind tools, and some only work with a few or one. The section MEMCHECK OPTIONS and those below it describe tool-specific options.<div class="spacer">
</div>
This manual page covers only basic usage and options. For more comprehensive information, please see the HTML documentation on your system: $INSTALL/share/doc/valgrind/html/index.html, or online: http://www.valgrind.org/docs/manual/index.html.</div>
<div class="section">
<h1>TOOL SELECTION OPTIONS</h1> The single most important option.<div class="spacer">
</div>
<b>--tool=&lt;toolname&gt; [default: memcheck] </b><div style="margin-left: 4.00ex;">
Run the Valgrind tool called  <i>toolname</i>, e.g. Memcheck, Cachegrind, etc.</div>
</div>
<div class="section">
<h1>BASIC OPTIONS</h1> These options work with all tools.<div class="spacer">
</div>
<b>-h --help</b><div style="margin-left: 4.00ex;">
Show help for all options, both for the core and for the selected tool. If the option is repeated it is equivalent to giving  <b>--help-debug</b>.</div>
<div class="spacer">
</div>
<b>--help-debug</b><div style="margin-left: 4.00ex;">
Same as  <b>--help</b>, but also lists debugging options which usually are only of use to Valgrind's developers.</div>
<div class="spacer">
</div>
<b>--version</b><div style="margin-left: 4.00ex;">
Show the version number of the Valgrind core. Tools can have their own version numbers. There is a scheme in place to ensure that tools only execute when the core version is one they are known to work with. This was done to minimise the chances of strange problems arising from tool-vs-core version incompatibilities.</div>
<div class="spacer">
</div>
<b>-q</b>, <b>--quiet</b><div style="margin-left: 4.00ex;">
Run silently, and only print error messages. Useful if you are running regression tests or have some other automated test machinery.</div>
<div class="spacer">
</div>
<b>-v</b>, <b>--verbose</b><div style="margin-left: 4.00ex;">
Be more verbose. Gives extra information on various aspects of your program, such as: the shared objects loaded, the suppressions used, the progress of the instrumentation and execution engines, and warnings about unusual behaviour. Repeating the option increases the verbosity level.</div>
<div class="spacer">
</div>
<b>--trace-children=&lt;yes|no&gt; [default: no] </b><div style="margin-left: 4.00ex;">
When enabled, Valgrind will trace into sub-processes initiated via the  <i>exec</i> system call. This is necessary for multi-process programs.<div style="height: 1.00em;">
&#160;</div>
Note that Valgrind does trace into the child of a  <i>fork</i> (it would be difficult not to, since  <i>fork</i> makes an identical copy of a process), so this option is arguably badly named. However, most children of  <i>fork</i> calls immediately call  <i>exec</i> anyway.</div>
<div class="spacer">
</div>
<b>--trace-children-skip=patt1,patt2,... </b><div style="margin-left: 4.00ex;">
This option only has an effect when  <b>--trace-children=yes</b> is specified. It allows for some children to be skipped. The option takes a comma separated list of patterns for the names of child executables that Valgrind should not trace into. Patterns may include the metacharacters ? and *, which have the usual meaning.<div style="height: 1.00em;">
&#160;</div>
This can be useful for pruning uninteresting branches from a tree of processes being run on Valgrind. But you should be careful when using it. When Valgrind skips tracing into an executable, it doesn't just skip tracing that executable, it also skips tracing any of that executable's child processes. In other words, the flag doesn't merely cause tracing to stop at the specified executables -- it skips tracing of entire process subtrees rooted at any of the specified executables.</div>
<div class="spacer">
</div>
<b>--trace-children-skip-by-arg=patt1,patt2,... </b><div style="margin-left: 4.00ex;">
This is the same as  <b>--trace-children-skip</b>, with one difference: the decision as to whether to trace into a child process is made by examining the arguments to the child process, rather than the name of its executable.</div>
<div class="spacer">
</div>
<b>--child-silent-after-fork=&lt;yes|no&gt; [default: no] </b><div style="margin-left: 4.00ex;">
When enabled, Valgrind will not show any debugging or logging output for the child process resulting from a  <i>fork</i> call. This can make the output less confusing (although more misleading) when dealing with processes that create children. It is particularly useful in conjunction with  <i>--trace-children=</i>. Use of this option is also strongly recommended if you are requesting XML output (<i>--xml=yes</i>), since otherwise the XML from child and parent may become mixed up, which usually makes it useless.</div>
<div class="spacer">
</div>
<b>--vgdb=&lt;no|yes|full&gt; [default: yes] </b><div style="margin-left: 4.00ex;">
Valgrind will provide &quot;gdbserver&quot; functionality when  <b>--vgdb=yes</b> or  <b>--vgdb=full</b> is specified. This allows an external GNU GDB debugger to control and debug your program when it runs on Valgrind. See ??? for a detailed description.<div style="height: 1.00em;">
&#160;</div>
If the embedded gdbserver is enabled but no gdb is currently being used, the ??? command line utility can send &quot;monitor commands&quot; to Valgrind from a shell. The Valgrind core provides a set of ???. A tool can optionally provide tool specific monitor commands, which are documented in the tool specific chapter.<div style="height: 1.00em;">
&#160;</div>
<b>--vgdb=full</b> incurs significant performance overheads.</div>
<div class="spacer">
</div>
<b>--vgdb-error=&lt;number&gt; [default: 999999999] </b><div style="margin-left: 4.00ex;">
Use this option when the Valgrind gdbserver is enabled with  <b>--vgdb=yes</b> or  <b>--vgdb=full</b>. Tools that report errors will wait for &quot;number&quot; errors to be reported before freezing the program and waiting for you to connect with GDB. It follows that a value of zero will cause the gdbserver to be started before your program is executed. This is typically used to insert GDB breakpoints before execution, and also works with tools that do not report errors, such as Massif.</div>
<div class="spacer">
</div>
<b>--track-fds=&lt;yes|no&gt; [default: no] </b><div style="margin-left: 4.00ex;">
When enabled, Valgrind will print out a list of open file descriptors on exit. Along with each file descriptor is printed a stack backtrace of where the file was opened and any details relating to the file descriptor such as the file name or socket details.</div>
<div class="spacer">
</div>
<b>--time-stamp=&lt;yes|no&gt; [default: no] </b><div style="margin-left: 4.00ex;">
When enabled, each message is preceded with an indication of the elapsed wallclock time since startup, expressed as days, hours, minutes, seconds and milliseconds.</div>
<div class="spacer">
</div>
<b>--log-fd=&lt;number&gt; [default: 2, stderr] </b><div style="margin-left: 4.00ex;">
Specifies that Valgrind should send all of its messages to the specified file descriptor. The default, 2, is the standard error channel (stderr). Note that this may interfere with the client's own use of stderr, as Valgrind's output will be interleaved with any output that the client sends to stderr.</div>
<div class="spacer">
</div>
<b>--log-file=&lt;filename&gt; </b><div style="margin-left: 4.00ex;">
Specifies that Valgrind should send all of its messages to the specified file. If the file name is empty, it causes an abort. There are three special format specifiers that can be used in the file name.<div style="height: 1.00em;">
&#160;</div>
<b>%p</b> is replaced with the current process ID. This is very useful for program that invoke multiple processes. WARNING: If you use  <b>--trace-children=yes</b> and your program invokes multiple processes OR your program forks without calling exec afterwards, and you don't use this specifier (or the  <b>%q</b> specifier below), the Valgrind output from all those processes will go into one file, possibly jumbled up, and possibly incomplete.<div style="height: 1.00em;">
&#160;</div>
<b>%q{FOO}</b> is replaced with the contents of the environment variable  <i>FOO</i>. If the  <b>{FOO}</b> part is malformed, it causes an abort. This specifier is rarely needed, but very useful in certain circumstances (eg. when running MPI programs). The idea is that you specify a variable which will be set differently for each process in the job, for example BPROC_RANK or whatever is applicable in your MPI setup. If the named environment variable is not set, it causes an abort. Note that in some shells, the  <b>{</b> and  <b>}</b> characters may need to be escaped with a backslash.<div style="height: 1.00em;">
&#160;</div>
<b>%%</b> is replaced with  <b>%</b>.<div style="height: 1.00em;">
&#160;</div>
If an  <b>%</b> is followed by any other character, it causes an abort.</div>
<div class="spacer">
</div>
<b>--log-socket=&lt;ip-address:port-number&gt; </b><div style="margin-left: 4.00ex;">
Specifies that Valgrind should send all of its messages to the specified port at the specified IP address. The port may be omitted, in which case port 1500 is used. If a connection cannot be made to the specified socket, Valgrind falls back to writing output to the standard error (stderr). This option is intended to be used in conjunction with the valgrind-listener program. For further details, see the commentary in the manual.</div>
</div>
<div class="section">
<h1>ERROR-RELATED OPTIONS</h1> These options are used by all tools that can report errors, e.g. Memcheck, but not Cachegrind.<div class="spacer">
</div>
<b>--xml=&lt;yes|no&gt; [default: no] </b><div style="margin-left: 4.00ex;">
When enabled, the important parts of the output (e.g. tool error messages) will be in XML format rather than plain text. Furthermore, the XML output will be sent to a different output channel than the plain text output. Therefore, you also must use one of  <b>--xml-fd</b>,  <b>--xml-file</b> or  <b>--xml-socket</b> to specify where the XML is to be sent.<div style="height: 1.00em;">
&#160;</div>
Less important messages will still be printed in plain text, but because the XML output and plain text output are sent to different output channels (the destination of the plain text output is still controlled by  <b>--log-fd</b>,  <b>--log-file</b> and  <b>--log-socket</b>) this should not cause problems.<div style="height: 1.00em;">
&#160;</div>
This option is aimed at making life easier for tools that consume Valgrind's output as input, such as GUI front ends. Currently this option works with Memcheck, Helgrind, DRD and SGcheck. The output format is specified in the file docs/internals/xml-output-protocol4.txt in the source tree for Valgrind 3.5.0 or later.<div style="height: 1.00em;">
&#160;</div>
The recommended options for a GUI to pass, when requesting XML output, are:  <b>--xml=yes</b> to enable XML output,  <b>--xml-file</b> to send the XML output to a (presumably GUI-selected) file,  <b>--log-file</b> to send the plain text output to a second GUI-selected file,  <b>--child-silent-after-fork=yes</b>, and  <b>-q</b> to restrict the plain text output to critical error messages created by Valgrind itself. For example, failure to read a specified suppressions file counts as a critical error message. In this way, for a successful run the text output file will be empty. But if it isn't empty, then it will contain important information which the GUI user should be made aware of.</div>
<div class="spacer">
</div>
<b>--xml-fd=&lt;number&gt; [default: -1, disabled] </b><div style="margin-left: 4.00ex;">
Specifies that Valgrind should send its XML output to the specified file descriptor. It must be used in conjunction with  <b>--xml=yes</b>.</div>
<div class="spacer">
</div>
<b>--xml-file=&lt;filename&gt; </b><div style="margin-left: 4.00ex;">
Specifies that Valgrind should send its XML output to the specified file. It must be used in conjunction with  <b>--xml=yes</b>. Any  <b>%p</b> or  <b>%q</b> sequences appearing in the filename are expanded in exactly the same way as they are for  <b>--log-file</b>. See the description of  <b>--log-file</b> for details.</div>
<div class="spacer">
</div>
<b>--xml-socket=&lt;ip-address:port-number&gt; </b><div style="margin-left: 4.00ex;">
Specifies that Valgrind should send its XML output the specified port at the specified IP address. It must be used in conjunction with  <b>--xml=yes</b>. The form of the argument is the same as that used by  <b>--log-socket</b>. See the description of  <b>--log-socket</b> for further details.</div>
<div class="spacer">
</div>
<b>--xml-user-comment=&lt;string&gt; </b><div style="margin-left: 4.00ex;">
Embeds an extra user comment string at the start of the XML output. Only works when  <b>--xml=yes</b> is specified; ignored otherwise.</div>
<div class="spacer">
</div>
<b>--demangle=&lt;yes|no&gt; [default: yes] </b><div style="margin-left: 4.00ex;">
Enable/disable automatic demangling (decoding) of C++ names. Enabled by default. When enabled, Valgrind will attempt to translate encoded C++ names back to something approaching the original. The demangler handles symbols mangled by g++ versions 2.X, 3.X and 4.X.<div style="height: 1.00em;">
&#160;</div>
An important fact about demangling is that function names mentioned in suppressions files should be in their mangled form. Valgrind does not demangle function names when searching for applicable suppressions, because to do otherwise would make suppression file contents dependent on the state of Valgrind's demangling machinery, and also slow down suppression matching.</div>
<div class="spacer">
</div>
<b>--num-callers=&lt;number&gt; [default: 12] </b><div style="margin-left: 4.00ex;">
Specifies the maximum number of entries shown in stack traces that identify program locations. Note that errors are commoned up using only the top four function locations (the place in the current function, and that of its three immediate callers). So this doesn't affect the total number of errors reported.<div style="height: 1.00em;">
&#160;</div>
The maximum value for this is 50. Note that higher settings will make Valgrind run a bit more slowly and take a bit more memory, but can be useful when working with programs with deeply-nested call chains.</div>
<div class="spacer">
</div>
<b>--error-limit=&lt;yes|no&gt; [default: yes] </b><div style="margin-left: 4.00ex;">
When enabled, Valgrind stops reporting errors after 10,000,000 in total, or 1,000 different ones, have been seen. This is to stop the error tracking machinery from becoming a huge performance overhead in programs with many errors.</div>
<div class="spacer">
</div>
<b>--error-exitcode=&lt;number&gt; [default: 0] </b><div style="margin-left: 4.00ex;">
Specifies an alternative exit code to return if Valgrind reported any errors in the run. When set to the default value (zero), the return value from Valgrind will always be the return value of the process being simulated. When set to a nonzero value, that value is returned instead, if Valgrind detects any errors. This is useful for using Valgrind as part of an automated test suite, since it makes it easy to detect test cases for which Valgrind has reported errors, just by inspecting return codes.</div>
<div class="spacer">
</div>
<b>--show-below-main=&lt;yes|no&gt; [default: no] </b><div style="margin-left: 4.00ex;">
By default, stack traces for errors do not show any functions that appear beneath  <b>main</b> because most of the time it's uninteresting C library stuff and/or gobbledygook. Alternatively, if  <b>main</b> is not present in the stack trace, stack traces will not show any functions below  <b>main</b>-like functions such as glibc's  <b>__libc_start_main</b>. Furthermore, if  <b>main</b>-like functions are present in the trace, they are normalised as  <b>(below main)</b>, in order to make the output more deterministic.<div style="height: 1.00em;">
&#160;</div>
If this option is enabled, all stack trace entries will be shown and  <b>main</b>-like functions will not be normalised.</div>
<div class="spacer">
</div>
<b>--fullpath-after=&lt;string&gt; [default: don't show source paths] </b><div style="margin-left: 4.00ex;">
By default Valgrind only shows the filenames in stack traces, but not full paths to source files. When using Valgrind in large projects where the sources reside in multiple different directories, this can be inconvenient.  <b>--fullpath-after</b> provides a flexible solution to this problem. When this option is present, the path to each source file is shown, with the following all-important caveat: if  <b>string</b> is found in the path, then the path up to and including  <b>string</b> is omitted, else the path is shown unmodified. Note that  <b>string</b> is not required to be a prefix of the path.<div style="height: 1.00em;">
&#160;</div>
For example, consider a file named /home/janedoe/blah/src/foo/bar/xyzzy.c. Specifying  <b>--fullpath-after=/home/janedoe/blah/src/</b> will cause Valgrind to show the name as foo/bar/xyzzy.c.<div style="height: 1.00em;">
&#160;</div>
Because the string is not required to be a prefix,  <b>--fullpath-after=src/</b> will produce the same output. This is useful when the path contains arbitrary machine-generated characters. For example, the path /my/build/dir/C32A1B47/blah/src/foo/xyzzy can be pruned to foo/xyzzy using  <b>--fullpath-after=/blah/src/</b>.<div style="height: 1.00em;">
&#160;</div>
If you simply want to see the full path, just specify an empty string:  <b>--fullpath-after=</b>. This isn't a special case, merely a logical consequence of the above rules.<div style="height: 1.00em;">
&#160;</div>
Finally, you can use  <b>--fullpath-after</b> multiple times. Any appearance of it causes Valgrind to switch to producing full paths and applying the above filtering rule. Each produced path is compared against all the  <b>--fullpath-after</b>-specified strings, in the order specified. The first string to match causes the path to be truncated as described above. If none match, the full path is shown. This facilitates chopping off prefixes when the sources are drawn from a number of unrelated directories.</div>
<div class="spacer">
</div>
<b>--suppressions=&lt;filename&gt; [default: $PREFIX/lib/valgrind/default.supp] </b><div style="margin-left: 4.00ex;">
Specifies an extra file from which to read descriptions of errors to suppress. You may use up to 100 extra suppression files.</div>
<div class="spacer">
</div>
<b>--gen-suppressions=&lt;yes|no|all&gt; [default: no] </b><div style="margin-left: 4.00ex;">
When set to  <i>yes</i>, Valgrind will pause after every error shown and print the line:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
    ---- Print suppression ? --- [Return/N/n/Y/y/C/c] ----<br/>
</div>
<div style="height: 1.00em;">
&#160;</div>
The prompt's behaviour is the same as for the  <b>--db-attach</b> option (see below).<div style="height: 1.00em;">
&#160;</div>
If you choose to, Valgrind will print out a suppression for this error. You can then cut and paste it into a suppression file if you don't want to hear about the error in the future.<div style="height: 1.00em;">
&#160;</div>
When set to  <i>all</i>, Valgrind will print a suppression for every reported error, without querying the user.<div style="height: 1.00em;">
&#160;</div>
This option is particularly useful with C++ programs, as it prints out the suppressions with mangled names, as required.<div style="height: 1.00em;">
&#160;</div>
Note that the suppressions printed are as specific as possible. You may want to common up similar ones, by adding wildcards to function names, and by using frame-level wildcards. The wildcarding facilities are powerful yet flexible, and with a bit of careful editing, you may be able to suppress a whole family of related errors with only a few suppressions.<div style="height: 1.00em;">
&#160;</div>
Sometimes two different errors are suppressed by the same suppression, in which case Valgrind will output the suppression more than once, but you only need to have one copy in your suppression file (but having more than one won't cause problems). Also, the suppression name is given as &lt;insert a suppression name here&gt;; the name doesn't really matter, it's only used with the  <b>-v</b> option which prints out all used suppression records.</div>
<div class="spacer">
</div>
<b>--db-attach=&lt;yes|no&gt; [default: no] </b><div style="margin-left: 4.00ex;">
When enabled, Valgrind will pause after every error shown and print the line:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
    ---- Attach to debugger ? --- [Return/N/n/Y/y/C/c] ----<br/>
</div>
<div style="height: 1.00em;">
&#160;</div>
Pressing  <i>Ret</i>, or  <i>N Ret</i> or  <i>n Ret</i>, causes Valgrind not to start a debugger for this error.<div style="height: 1.00em;">
&#160;</div>
Pressing  <i>Y Ret</i> or  <i>y Ret</i> causes Valgrind to start a debugger for the program at this point. When you have finished with the debugger, quit from it, and the program will continue. Trying to continue from inside the debugger doesn't work.<div style="height: 1.00em;">
&#160;</div>
Note: if you use GDB, more powerful debugging support is provided by the  <b>--vgdb=</b>  <i>yes</i> or  <i>full</i> value. This activates Valgrind's internal gdbserver, which provides more-or-less full GDB-style control of the application: insertion of breakpoints, continuing from inside GDB, inferior function calls, and much more.<div style="height: 1.00em;">
&#160;</div>
<i>C Ret</i> or  <i>c Ret</i> causes Valgrind not to start a debugger, and not to ask again.</div>
<div class="spacer">
</div>
<b>--db-command=&lt;command&gt; [default: gdb -nw %f %p] </b><div style="margin-left: 4.00ex;">
Specify the debugger to use with the  <b>--db-attach</b> command. The default debugger is GDB. This option is a template that is expanded by Valgrind at runtime. %f is replaced with the executable's file name and %p is replaced by the process ID of the executable.<div style="height: 1.00em;">
&#160;</div>
This specifies how Valgrind will invoke the debugger. By default it will use whatever GDB is detected at build time, which is usually /usr/bin/gdb. Using this command, you can specify some alternative command to invoke the debugger you want to use.<div style="height: 1.00em;">
&#160;</div>
The command string given can include one or instances of the %p and %f expansions. Each instance of %p expands to the PID of the process to be debugged and each instance of %f expands to the path to the executable for the process to be debugged.<div style="height: 1.00em;">
&#160;</div>
Since &lt;command&gt; is likely to contain spaces, you will need to put this entire option in quotes to ensure it is correctly handled by the shell.</div>
<div class="spacer">
</div>
<b>--input-fd=&lt;number&gt; [default: 0, stdin] </b><div style="margin-left: 4.00ex;">
When using  <b>--db-attach=yes</b> or  <b>--gen-suppressions=yes</b>, Valgrind will stop so as to read keyboard input from you when each error occurs. By default it reads from the standard input (stdin), which is problematic for programs which close stdin. This option allows you to specify an alternative file descriptor from which to read input.</div>
<div class="spacer">
</div>
<b>--dsymutil=no|yes [no] </b><div style="margin-left: 4.00ex;">
This option is only relevant when running Valgrind on Mac OS X.<div style="height: 1.00em;">
&#160;</div>
Mac OS X uses a deferred debug information (debuginfo) linking scheme. When object files containing debuginfo are linked into a .dylib or an executable, the debuginfo is not copied into the final file. Instead, the debuginfo must be linked manually by running dsymutil, a system-provided utility, on the executable or .dylib. The resulting combined debuginfo is placed in a directory alongside the executable or .dylib, but with the extension .dSYM.<div style="height: 1.00em;">
&#160;</div>
With  <b>--dsymutil=no</b>, Valgrind will detect cases where the .dSYM directory is either missing, or is present but does not appear to match the associated executable or .dylib, most likely because it is out of date. In these cases, Valgrind will print a warning message but take no further action.<div style="height: 1.00em;">
&#160;</div>
With  <b>--dsymutil=yes</b>, Valgrind will, in such cases, automatically run dsymutil as necessary to bring the debuginfo up to date. For all practical purposes, if you always use  <b>--dsymutil=yes</b>, then there is never any need to run dsymutil manually or as part of your applications's build system, since Valgrind will run it as necessary.<div style="height: 1.00em;">
&#160;</div>
Valgrind will not attempt to run dsymutil on any executable or library in /usr/, /bin/, /sbin/, /opt/, /sw/, /System/, /Library/ or /Applications/ since dsymutil will always fail in such situations. It fails both because the debuginfo for such pre-installed system components is not available anywhere, and also because it would require write privileges in those directories.<div style="height: 1.00em;">
&#160;</div>
Be careful when using  <b>--dsymutil=yes</b>, since it will cause pre-existing .dSYM directories to be silently deleted and re-created. Also note that dsymutil is quite slow, sometimes excessively so.</div>
<div class="spacer">
</div>
<b>--max-stackframe=&lt;number&gt; [default: 2000000] </b><div style="margin-left: 4.00ex;">
The maximum size of a stack frame. If the stack pointer moves by more than this amount then Valgrind will assume that the program is switching to a different stack.<div style="height: 1.00em;">
&#160;</div>
You may need to use this option if your program has large stack-allocated arrays. Valgrind keeps track of your program's stack pointer. If it changes by more than the threshold amount, Valgrind assumes your program is switching to a different stack, and Memcheck behaves differently than it would for a stack pointer change smaller than the threshold. Usually this heuristic works well. However, if your program allocates large structures on the stack, this heuristic will be fooled, and Memcheck will subsequently report large numbers of invalid stack accesses. This option allows you to change the threshold to a different value.<div style="height: 1.00em;">
&#160;</div>
You should only consider use of this option if Valgrind's debug output directs you to do so. In that case it will tell you the new threshold you should specify.<div style="height: 1.00em;">
&#160;</div>
In general, allocating large structures on the stack is a bad idea, because you can easily run out of stack space, especially on systems with limited memory or which expect to support large numbers of threads each with a small stack, and also because the error checking performed by Memcheck is more effective for heap-allocated data than for stack-allocated data. If you have to use this option, you may wish to consider rewriting your code to allocate on the heap rather than on the stack.</div>
<div class="spacer">
</div>
<b>--main-stacksize=&lt;number&gt; [default: use current 'ulimit' value] </b><div style="margin-left: 4.00ex;">
Specifies the size of the main thread's stack.<div style="height: 1.00em;">
&#160;</div>
To simplify its memory management, Valgrind reserves all required space for the main thread's stack at startup. That means it needs to know the required stack size at startup.<div style="height: 1.00em;">
&#160;</div>
By default, Valgrind uses the current &quot;ulimit&quot; value for the stack size, or 16 MB, whichever is lower. In many cases this gives a stack size in the range 8 to 16 MB, which almost never overflows for most applications.<div style="height: 1.00em;">
&#160;</div>
If you need a larger total stack size, use  <b>--main-stacksize</b> to specify it. Only set it as high as you need, since reserving far more space than you need (that is, hundreds of megabytes more than you need) constrains Valgrind's memory allocators and may reduce the total amount of memory that Valgrind can use. This is only really of significance on 32-bit machines.<div style="height: 1.00em;">
&#160;</div>
On Linux, you may request a stack of size up to 2GB. Valgrind will stop with a diagnostic message if the stack cannot be allocated.<div style="height: 1.00em;">
&#160;</div>
<b>--main-stacksize</b> only affects the stack size for the program's initial thread. It has no bearing on the size of thread stacks, as Valgrind does not allocate those.<div style="height: 1.00em;">
&#160;</div>
You may need to use both  <b>--main-stacksize</b> and  <b>--max-stackframe</b> together. It is important to understand that  <b>--main-stacksize</b> sets the maximum total stack size, whilst  <b>--max-stackframe</b> specifies the largest size of any one stack frame. You will have to work out the  <b>--main-stacksize</b> value for yourself (usually, if your applications segfaults). But Valgrind will tell you the needed  <b>--max-stackframe</b> size, if necessary.<div style="height: 1.00em;">
&#160;</div>
As discussed further in the description of  <b>--max-stackframe</b>, a requirement for a large stack is a sign of potential portability problems. You are best advised to place all large data in heap-allocated memory.</div>
</div>
<div class="section">
<h1>MALLOC()-RELATED OPTIONS</h1> For tools that use their own version of malloc (e.g. Memcheck and Massif), the following options apply.<div class="spacer">
</div>
<b>--alignment=&lt;number&gt; [default: 8 or 16, depending on the platform] </b><div style="margin-left: 4.00ex;">
By default Valgrind's  <b>malloc</b>,  <b>realloc</b>, etc, return a block whose starting address is 8-byte aligned or 16-byte aligned (the value depends on the platform and matches the platform default). This option allows you to specify a different alignment. The supplied value must be greater than or equal to the default, less than or equal to 4096, and must be a power of two.</div>
</div>
<div class="section">
<h1>UNCOMMON OPTIONS</h1> These options apply to all tools, as they affect certain obscure workings of the Valgrind core. Most people won't need to use these.<div class="spacer">
</div>
<b>--smc-check=&lt;none|stack|all|all-non-file&gt; [default: stack] </b><div style="margin-left: 4.00ex;">
This option controls Valgrind's detection of self-modifying code. If no checking is done, if a program executes some code, then overwrites it with new code, and executes the new code, Valgrind will continue to execute the translations it made for the old code. This will likely lead to incorrect behaviour and/or crashes.<div style="height: 1.00em;">
&#160;</div>
Valgrind has four levels of self-modifying code detection: no detection, detect self-modifying code on the stack (which is used by GCC to implement nested functions), detect self-modifying code everywhere, and detect self-modifying code everywhere except in file-backed mappings. Note that the default option will catch the vast majority of cases. The main case it will not catch is programs such as JIT compilers that dynamically generate code  <i>and</i> subsequently overwrite part or all of it. Running with  <i>all</i> will slow Valgrind down noticeably. Running with  <i>none</i> will rarely speed things up, since very little code gets put on the stack for most programs. The  <b>VALGRIND_DISCARD_TRANSLATIONS</b> client request is an alternative to  <b>--smc-check=all</b> that requires more programmer effort but allows Valgrind to run your program faster, by telling it precisely when translations need to be re-made.<div style="height: 1.00em;">
&#160;</div>
<b>--smc-check=all-non-file</b> provides a cheaper but more limited version of  <b>--smc-check=all</b>. It adds checks to any translations that do not originate from file-backed memory mappings. Typical applications that generate code, for example JITs in web browsers, generate code into anonymous mmaped areas, whereas the &quot;fixed&quot; code of the browser always lives in file-backed mappings.  <b>--smc-check=all-non-file</b> takes advantage of this observation, limiting the overhead of checking to code which is likely to be JIT generated.<div style="height: 1.00em;">
&#160;</div>
Some architectures (including ppc32, ppc64 and ARM) require programs which create code at runtime to flush the instruction cache in between code generation and first use. Valgrind observes and honours such instructions. Hence, on ppc32/Linux, ppc64/Linux and ARM/Linux, Valgrind always provides complete, transparent support for self-modifying code. It is only on platforms such as x86/Linux, AMD64/Linux, x86/Darwin and AMD64/Darwin that you need to use this option.</div>
<div class="spacer">
</div>
<b>--read-var-info=&lt;yes|no&gt; [default: no] </b><div style="margin-left: 4.00ex;">
When enabled, Valgrind will read information about variable types and locations from DWARF3 debug info. This slows Valgrind down and makes it use more memory, but for the tools that can take advantage of it (Memcheck, Helgrind, DRD) it can result in more precise error messages. For example, here are some standard errors issued by Memcheck:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
==15516== Uninitialised byte(s) found during client check request<br/>
==15516==    at 0x400633: croak (varinfo1.c:28)<br/>
==15516==    by 0x4006B2: main (varinfo1.c:55)<br/>
==15516==  Address 0x60103b is 7 bytes inside data symbol &quot;global_i2&quot;<br/>
==15516== <br/>
==15516== Uninitialised byte(s) found during client check request<br/>
==15516==    at 0x400633: croak (varinfo1.c:28)<br/>
==15516==    by 0x4006BC: main (varinfo1.c:56)<br/>
==15516==  Address 0x7fefffefc is on thread 1's stack<br/>
</div>
<div style="height: 1.00em;">
&#160;</div>
And here are the same errors with  <b>--read-var-info=yes</b>:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
==15522== Uninitialised byte(s) found during client check request<br/>
==15522==    at 0x400633: croak (varinfo1.c:28)<br/>
==15522==    by 0x4006B2: main (varinfo1.c:55)<br/>
==15522==  Location 0x60103b is 0 bytes inside global_i2[7],<br/>
==15522==  a global variable declared at varinfo1.c:41<br/>
==15522== <br/>
==15522== Uninitialised byte(s) found during client check request<br/>
==15522==    at 0x400633: croak (varinfo1.c:28)<br/>
==15522==    by 0x4006BC: main (varinfo1.c:56)<br/>
==15522==  Location 0x7fefffefc is 0 bytes inside local var &quot;local&quot;<br/>
==15522==  declared at varinfo1.c:46, in frame #1 of thread 1<br/>
</div>
</div>
<div class="spacer">
</div>
<b>--vgdb-poll=&lt;number&gt; [default: 5000] </b><div style="margin-left: 4.00ex;">
As part of its main loop, the Valgrind scheduler will poll to check if some activity (such as an external command or some input from a gdb) has to be handled by gdbserver. This activity poll will be done after having run the given number of basic blocks (or slightly more than the given number of basic blocks). This poll is quite cheap so the default value is set relatively low. You might further decrease this value if vgdb cannot use ptrace system call to interrupt Valgrind if all threads are (most of the time) blocked in a system call.</div>
<div class="spacer">
</div>
<b>--vgdb-shadow-registers=no|yes [default: no] </b><div style="margin-left: 4.00ex;">
When activated, gdbserver will expose the Valgrind shadow registers to GDB. With this, the value of the Valgrind shadow registers can be examined or changed using GDB. Exposing shadow registers only works with GDB version 7.1 or later.</div>
<div class="spacer">
</div>
<b>--vgdb-prefix=&lt;prefix&gt; [default: /tmp/vgdb-pipe] </b><div style="margin-left: 4.00ex;">
To communicate with gdb/vgdb, the Valgrind gdbserver creates 3 files (2 named FIFOs and a mmap shared memory file). The prefix option controls the directory and prefix for the creation of these files.</div>
<div class="spacer">
</div>
<b>--run-libc-freeres=&lt;yes|no&gt; [default: yes] </b><div style="margin-left: 4.00ex;">
This option is only relevant when running Valgrind on Linux.<div style="height: 1.00em;">
&#160;</div>
The GNU C library (<b>libc.so</b>), which is used by all programs, may allocate memory for its own uses. Usually it doesn't bother to free that memory when the program ends&#8212;there would be no point, since the Linux kernel reclaims all process resources when a process exits anyway, so it would just slow things down.<div style="height: 1.00em;">
&#160;</div>
The glibc authors realised that this behaviour causes leak checkers, such as Valgrind, to falsely report leaks in glibc, when a leak check is done at exit. In order to avoid this, they provided a routine called  <b>__libc_freeres</b> specifically to make glibc release all memory it has allocated. Memcheck therefore tries to run  <b>__libc_freeres</b> at exit.<div style="height: 1.00em;">
&#160;</div>
Unfortunately, in some very old versions of glibc,  <b>__libc_freeres</b> is sufficiently buggy to cause segmentation faults. This was particularly noticeable on Red Hat 7.1. So this option is provided in order to inhibit the run of  <b>__libc_freeres</b>. If your program seems to run fine on Valgrind, but segfaults at exit, you may find that  <b>--run-libc-freeres=no</b> fixes that, although at the cost of possibly falsely reporting space leaks in libc.so.</div>
<div class="spacer">
</div>
<b>--sim-hints=hint1,hint2,... </b><div style="margin-left: 4.00ex;">
Pass miscellaneous hints to Valgrind which slightly modify the simulated behaviour in nonstandard or dangerous ways, possibly to help the simulation of strange features. By default no hints are enabled. Use with caution! Currently known hints are:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
&#8226;<b>lax-ioctls: </b> Be very lax about ioctl handling; the only assumption is that the size is correct. Doesn't require the full buffer to be initialized when writing. Without this, using some device drivers with a large number of strange ioctl commands becomes very tiresome.</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
&#8226;<b>enable-inner: </b> Enable some special magic needed when the program being run is itself Valgrind.</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
&#8226;<b>fuse-compatible: </b> Enable special handling for certain system calls that may block in a FUSE file-system. This may be necessary when running Valgrind on a multi-threaded program that uses one thread to manage a FUSE file-system and another thread to access that file-system.</div>
</div>
<div class="spacer">
</div>
<b>--kernel-variant=variant1,variant2,...</b><div style="margin-left: 4.00ex;">
Handle system calls and ioctls arising from minor variants of the default kernel for this platform. This is useful for running on hacked kernels or with kernel modules which support nonstandard ioctls, for example. Use with caution. If you don't understand what this option does then you almost certainly don't need it. Currently known variants are:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
&#8226;<b>bproc: </b> Support the  <b>sys_broc</b> system call on x86. This is for running on BProc, which is a minor variant of standard Linux which is sometimes used for building clusters.</div>
</div>
<div class="spacer">
</div>
<b>--show-emwarns=&lt;yes|no&gt; [default: no] </b><div style="margin-left: 4.00ex;">
When enabled, Valgrind will emit warnings about its CPU emulation in certain cases. These are usually not interesting.</div>
<div class="spacer">
</div>
<b>--require-text-symbol=:sonamepatt:fnnamepatt</b><div style="margin-left: 4.00ex;">
When a shared object whose soname matches  <i>sonamepatt</i> is loaded into the process, examine all the text symbols it exports. If none of those match  <i>fnnamepatt</i>, print an error message and abandon the run. This makes it possible to ensure that the run does not continue unless a given shared object contains a particular function name.<div style="height: 1.00em;">
&#160;</div>
Both  <i>sonamepatt</i> and  <i>fnnamepatt</i> can be written using the usual  <i>?</i> and  <i>*</i> wildcards. For example:  <i>&quot;:*libc.so*:foo?bar&quot;</i>. You may use characters other than a colon to separate the two patterns. It is only important that the first character and the separator character are the same. For example, the above example could also be written  <i>&quot;Q*libc.so*Qfoo?bar&quot;</i>. Multiple  <i> --require-text-symbol</i> flags are allowed, in which case shared objects that are loaded into the process will be checked against all of them.<div style="height: 1.00em;">
&#160;</div>
The purpose of this is to support reliable usage of marked-up libraries. For example, suppose we have a version of GCC's  <i>libgomp.so</i> which has been marked up with annotations to support Helgrind. It is only too easy and confusing to load the wrong, un-annotated  <i>libgomp.so</i> into the application. So the idea is: add a text symbol in the marked-up library, for example  <i>annotated_for_helgrind_3_6</i>, and then give the flag  <i>--require-text-symbol=:*libgomp*so*:annotated_for_helgrind_3_6</i> so that when  <i>libgomp.so</i> is loaded, Valgrind scans its symbol table, and if the symbol isn't present the run is aborted, rather than continuing silently with the un-marked-up library. Note that you should put the entire flag in quotes to stop shells expanding up the  <i>*</i> and  <i>?</i> wildcards.</div>
</div>
<div class="section">
<h1>DEBUGGING VALGRIND OPTIONS</h1> There are also some options for debugging Valgrind itself. You shouldn't need to use them in the normal run of things. If you wish to see the list, use the  <b>--help-debug</b> option.</div>
<div class="section">
<h1>MEMCHECK OPTIONS</h1>  <b>--leak-check=&lt;no|summary|yes|full&gt; [default: summary] </b><div style="margin-left: 4.00ex;">
When enabled, search for memory leaks when the client program finishes. If set to  <i>summary</i>, it says how many leaks occurred. If set to  <i>full</i> or  <i>yes</i>, it also gives details of each individual leak.</div>
<div class="spacer">
</div>
<b>--show-possibly-lost=&lt;yes|no&gt; [default: yes] </b><div style="margin-left: 4.00ex;">
When disabled, the memory leak detector will not show &quot;possibly lost&quot; blocks.</div>
<div class="spacer">
</div>
<b>--leak-resolution=&lt;low|med|high&gt; [default: high] </b><div style="margin-left: 4.00ex;">
When doing leak checking, determines how willing Memcheck is to consider different backtraces to be the same for the purposes of merging multiple leaks into a single leak report. When set to  <i>low</i>, only the first two entries need match. When  <i>med</i>, four entries have to match. When  <i>high</i>, all entries need to match.<div style="height: 1.00em;">
&#160;</div>
For hardcore leak debugging, you probably want to use  <b>--leak-resolution=high</b> together with  <b>--num-callers=40</b> or some such large number.<div style="height: 1.00em;">
&#160;</div>
Note that the  <b>--leak-resolution</b> setting does not affect Memcheck's ability to find leaks. It only changes how the results are presented.</div>
<div class="spacer">
</div>
<b>--show-reachable=&lt;yes|no&gt; [default: no] </b><div style="margin-left: 4.00ex;">
When disabled, the memory leak detector only shows &quot;definitely lost&quot; and &quot;possibly lost&quot; blocks. When enabled, the leak detector also shows &quot;reachable&quot; and &quot;indirectly lost&quot; blocks. (In other words, it shows all blocks, except suppressed ones, so  <b>--show-all</b> would be a better name for it.)</div>
<div class="spacer">
</div>
<b>--undef-value-errors=&lt;yes|no&gt; [default: yes] </b><div style="margin-left: 4.00ex;">
Controls whether Memcheck reports uses of undefined value errors. Set this to  <i>no</i> if you don't want to see undefined value errors. It also has the side effect of speeding up Memcheck somewhat.</div>
<div class="spacer">
</div>
<b>--track-origins=&lt;yes|no&gt; [default: no] </b><div style="margin-left: 4.00ex;">
Controls whether Memcheck tracks the origin of uninitialised values. By default, it does not, which means that although it can tell you that an uninitialised value is being used in a dangerous way, it cannot tell you where the uninitialised value came from. This often makes it difficult to track down the root problem.<div style="height: 1.00em;">
&#160;</div>
When set to  <i>yes</i>, Memcheck keeps track of the origins of all uninitialised values. Then, when an uninitialised value error is reported, Memcheck will try to show the origin of the value. An origin can be one of the following four places: a heap block, a stack allocation, a client request, or miscellaneous other sources (eg, a call to  <i>brk</i>).<div style="height: 1.00em;">
&#160;</div>
For uninitialised values originating from a heap block, Memcheck shows where the block was allocated. For uninitialised values originating from a stack allocation, Memcheck can tell you which function allocated the value, but no more than that -- typically it shows you the source location of the opening brace of the function. So you should carefully check that all of the function's local variables are initialised properly.<div style="height: 1.00em;">
&#160;</div>
Performance overhead: origin tracking is expensive. It halves Memcheck's speed and increases memory use by a minimum of 100MB, and possibly more. Nevertheless it can drastically reduce the effort required to identify the root cause of uninitialised value errors, and so is often a programmer productivity win, despite running more slowly.<div style="height: 1.00em;">
&#160;</div>
Accuracy: Memcheck tracks origins quite accurately. To avoid very large space and time overheads, some approximations are made. It is possible, although unlikely, that Memcheck will report an incorrect origin, or not be able to identify any origin.<div style="height: 1.00em;">
&#160;</div>
Note that the combination  <b>--track-origins=yes</b> and  <b>--undef-value-errors=no</b> is nonsensical. Memcheck checks for and rejects this combination at startup.</div>
<div class="spacer">
</div>
<b>--partial-loads-ok=&lt;yes|no&gt; [default: no] </b><div style="margin-left: 4.00ex;">
Controls how Memcheck handles word-sized, word-aligned loads from addresses for which some bytes are addressable and others are not. When  <i>yes</i>, such loads do not produce an address error. Instead, loaded bytes originating from illegal addresses are marked as uninitialised, and those corresponding to legal addresses are handled in the normal way.<div style="height: 1.00em;">
&#160;</div>
When  <i>no</i>, loads from partially invalid addresses are treated the same as loads from completely invalid addresses: an illegal-address error is issued, and the resulting bytes are marked as initialised.<div style="height: 1.00em;">
&#160;</div>
Note that code that behaves in this way is in violation of the the ISO C/C++ standards, and should be considered broken. If at all possible, such code should be fixed. This option should be used only as a last resort.</div>
<div class="spacer">
</div>
<b>--freelist-vol=&lt;number&gt; [default: 20000000] </b><div style="margin-left: 4.00ex;">
When the client program releases memory using  <b>free</b> (in C) or delete (C++), that memory is not immediately made available for re-allocation. Instead, it is marked inaccessible and placed in a queue of freed blocks. The purpose is to defer as long as possible the point at which freed-up memory comes back into circulation. This increases the chance that Memcheck will be able to detect invalid accesses to blocks for some significant period of time after they have been freed.<div style="height: 1.00em;">
&#160;</div>
This option specifies the maximum total size, in bytes, of the blocks in the queue. The default value is twenty million bytes. Increasing this increases the total amount of memory used by Memcheck but may detect invalid uses of freed blocks which would otherwise go undetected.</div>
<div class="spacer">
</div>
<b>--freelist-big-blocks=&lt;number&gt; [default: 1000000] </b><div style="margin-left: 4.00ex;">
When making blocks from the queue of freed blocks available for re-allocation, Memcheck will in priority re-circulate the blocks with a size greater or equal to  <b>--freelist-big-blocks</b>. This ensures that freeing big blocks (in particular freeing blocks bigger than  <b>--freelist-vol</b>) does not immediately lead to a re-circulation of all (or a lot of) the small blocks in the free list. In other words, this option increases the likelihood to discover dangling pointers for the &quot;small&quot; blocks, even when big blocks are freed.<div style="height: 1.00em;">
&#160;</div>
Setting a value of 0 means that all the blocks are re-circulated in a FIFO order.</div>
<div class="spacer">
</div>
<b>--workaround-gcc296-bugs=&lt;yes|no&gt; [default: no] </b><div style="margin-left: 4.00ex;">
When enabled, assume that reads and writes some small distance below the stack pointer are due to bugs in GCC 2.96, and does not report them. The &quot;small distance&quot; is 256 bytes by default. Note that GCC 2.96 is the default compiler on some ancient Linux distributions (RedHat 7.X) and so you may need to use this option. Do not use it if you do not have to, as it can cause real errors to be overlooked. A better alternative is to use a more recent GCC in which this bug is fixed.<div style="height: 1.00em;">
&#160;</div>
You may also need to use this option when working with GCC 3.X or 4.X on 32-bit PowerPC Linux. This is because GCC generates code which occasionally accesses below the stack pointer, particularly for floating-point to/from integer conversions. This is in violation of the 32-bit PowerPC ELF specification, which makes no provision for locations below the stack pointer to be accessible.</div>
<div class="spacer">
</div>
<b>--ignore-ranges=0xPP-0xQQ[,0xRR-0xSS] </b><div style="margin-left: 4.00ex;">
Any ranges listed in this option (and multiple ranges can be specified, separated by commas) will be ignored by Memcheck's addressability checking.</div>
<div class="spacer">
</div>
<b>--malloc-fill=&lt;hexnumber&gt; </b><div style="margin-left: 4.00ex;">
Fills blocks allocated by malloc, new, etc, but not by calloc, with the specified byte. This can be useful when trying to shake out obscure memory corruption problems. The allocated area is still regarded by Memcheck as undefined -- this option only affects its contents.</div>
<div class="spacer">
</div>
<b>--free-fill=&lt;hexnumber&gt; </b><div style="margin-left: 4.00ex;">
Fills blocks freed by free, delete, etc, with the specified byte value. This can be useful when trying to shake out obscure memory corruption problems. The freed area is still regarded by Memcheck as not valid for access -- this option only affects its contents.</div>
</div>
<div class="section">
<h1>CACHEGRIND OPTIONS</h1>  <b>--I1=&lt;size&gt;,&lt;associativity&gt;,&lt;line size&gt; </b><div style="margin-left: 4.00ex;">
Specify the size, associativity and line size of the level 1 instruction cache.</div>
<div class="spacer">
</div>
<b>--D1=&lt;size&gt;,&lt;associativity&gt;,&lt;line size&gt; </b><div style="margin-left: 4.00ex;">
Specify the size, associativity and line size of the level 1 data cache.</div>
<div class="spacer">
</div>
<b>--LL=&lt;size&gt;,&lt;associativity&gt;,&lt;line size&gt; </b><div style="margin-left: 4.00ex;">
Specify the size, associativity and line size of the last-level cache.</div>
<div class="spacer">
</div>
<b>--cache-sim=no|yes [yes] </b><div style="margin-left: 4.00ex;">
Enables or disables collection of cache access and miss counts.</div>
<div class="spacer">
</div>
<b>--branch-sim=no|yes [no] </b><div style="margin-left: 4.00ex;">
Enables or disables collection of branch instruction and misprediction counts. By default this is disabled as it slows Cachegrind down by approximately 25%. Note that you cannot specify  <b>--cache-sim=no</b> and  <b>--branch-sim=no</b> together, as that would leave Cachegrind with no information to collect.</div>
<div class="spacer">
</div>
<b>--cachegrind-out-file=&lt;file&gt; </b><div style="margin-left: 4.00ex;">
Write the profile data to file rather than to the default output file, cachegrind.out.&lt;pid&gt;. The  <b>%p</b> and  <b>%q</b> format specifiers can be used to embed the process ID and/or the contents of an environment variable in the name, as is the case for the core option  <b>--log-file</b>.</div>
</div>
<div class="section">
<h1>CALLGRIND OPTIONS</h1>  <b>--callgrind-out-file=&lt;file&gt; </b><div style="margin-left: 4.00ex;">
Write the profile data to file rather than to the default output file, callgrind.out.&lt;pid&gt;. The  <b>%p</b> and  <b>%q</b> format specifiers can be used to embed the process ID and/or the contents of an environment variable in the name, as is the case for the core option  <b>--log-file</b>. When multiple dumps are made, the file name is modified further; see below.</div>
<div class="spacer">
</div>
<b>--dump-line=&lt;no|yes&gt; [default: yes] </b><div style="margin-left: 4.00ex;">
This specifies that event counting should be performed at source line granularity. This allows source annotation for sources which are compiled with debug information (<b>-g</b>).</div>
<div class="spacer">
</div>
<b>--dump-instr=&lt;no|yes&gt; [default: no] </b><div style="margin-left: 4.00ex;">
This specifies that event counting should be performed at per-instruction granularity. This allows for assembly code annotation. Currently the results can only be displayed by KCachegrind.</div>
<div class="spacer">
</div>
<b>--compress-strings=&lt;no|yes&gt; [default: yes] </b><div style="margin-left: 4.00ex;">
This option influences the output format of the profile data. It specifies whether strings (file and function names) should be identified by numbers. This shrinks the file, but makes it more difficult for humans to read (which is not recommended in any case).</div>
<div class="spacer">
</div>
<b>--compress-pos=&lt;no|yes&gt; [default: yes] </b><div style="margin-left: 4.00ex;">
This option influences the output format of the profile data. It specifies whether numerical positions are always specified as absolute values or are allowed to be relative to previous numbers. This shrinks the file size.</div>
<div class="spacer">
</div>
<b>--combine-dumps=&lt;no|yes&gt; [default: no] </b><div style="margin-left: 4.00ex;">
When enabled, when multiple profile data parts are to be generated these parts are appended to the same output file. Not recommended.</div>
<div class="spacer">
</div>
<b>--dump-every-bb=&lt;count&gt; [default: 0, never] </b><div style="margin-left: 4.00ex;">
Dump profile data every  <b>count</b> basic blocks. Whether a dump is needed is only checked when Valgrind's internal scheduler is run. Therefore, the minimum setting useful is about 100000. The count is a 64-bit value to make long dump periods possible.</div>
<div class="spacer">
</div>
<b>--dump-before=&lt;function&gt; </b><div style="margin-left: 4.00ex;">
Dump when entering  <b>function</b>.</div>
<div class="spacer">
</div>
<b>--zero-before=&lt;function&gt; </b><div style="margin-left: 4.00ex;">
Zero all costs when entering  <b>function</b>.</div>
<div class="spacer">
</div>
<b>--dump-after=&lt;function&gt; </b><div style="margin-left: 4.00ex;">
Dump when leaving  <b>function</b>.</div>
<div class="spacer">
</div>
<b>--instr-atstart=&lt;yes|no&gt; [default: yes] </b><div style="margin-left: 4.00ex;">
Specify if you want Callgrind to start simulation and profiling from the beginning of the program. When set to no, Callgrind will not be able to collect any information, including calls, but it will have at most a slowdown of around 4, which is the minimum Valgrind overhead. Instrumentation can be interactively enabled via callgrind_control -i on.<div style="height: 1.00em;">
&#160;</div>
Note that the resulting call graph will most probably not contain  <b>main</b>, but will contain all the functions executed after instrumentation was enabled. Instrumentation can also programatically enabled/disabled. See the Callgrind include file callgrind.h for the macro you have to use in your source code.<div style="height: 1.00em;">
&#160;</div>
For cache simulation, results will be less accurate when switching on instrumentation later in the program run, as the simulator starts with an empty cache at that moment. Switch on event collection later to cope with this error.</div>
<div class="spacer">
</div>
<b>--collect-atstart=&lt;yes|no&gt; [default: yes] </b><div style="margin-left: 4.00ex;">
Specify whether event collection is enabled at beginning of the profile run.<div style="height: 1.00em;">
&#160;</div>
To only look at parts of your program, you have two possibilities:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
 1.Zero event counters before entering the program part you want to profile, and dump the event counters to a file after leaving that program part.</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
 2.Switch on/off collection state as needed to only see event counters happening while inside of the program part you want to profile.</div>
<div style="height: 1.00em;">
&#160;</div>
The second option can be used if the program part you want to profile is called many times. Option 1, i.e. creating a lot of dumps is not practical here.<div style="height: 1.00em;">
&#160;</div>
Collection state can be toggled at entry and exit of a given function with the option  <b>--toggle-collect</b>. If you use this option, collection state should be disabled at the beginning. Note that the specification of  <b>--toggle-collect</b> implicitly sets  <b>--collect-state=no</b>.<div style="height: 1.00em;">
&#160;</div>
Collection state can be toggled also by inserting the client request CALLGRIND_TOGGLE_COLLECT ; at the needed code positions.</div>
<div class="spacer">
</div>
<b>--toggle-collect=&lt;function&gt; </b><div style="margin-left: 4.00ex;">
Toggle collection on entry/exit of  <b>function</b>.</div>
<div class="spacer">
</div>
<b>--collect-jumps=&lt;no|yes&gt; [default: no] </b><div style="margin-left: 4.00ex;">
This specifies whether information for (conditional) jumps should be collected. As above, callgrind_annotate currently is not able to show you the data. You have to use KCachegrind to get jump arrows in the annotated code.</div>
<div class="spacer">
</div>
<b>--collect-systime=&lt;no|yes&gt; [default: no] </b><div style="margin-left: 4.00ex;">
This specifies whether information for system call times should be collected.</div>
<div class="spacer">
</div>
<b>--collect-bus=&lt;no|yes&gt; [default: no] </b><div style="margin-left: 4.00ex;">
This specifies whether the number of global bus events executed should be collected. The event type &quot;Ge&quot; is used for these events.</div>
<div class="spacer">
</div>
<b>--cache-sim=&lt;yes|no&gt; [default: no] </b><div style="margin-left: 4.00ex;">
Specify if you want to do full cache simulation. By default, only instruction read accesses will be counted (&quot;Ir&quot;). With cache simulation, further event counters are enabled: Cache misses on instruction reads (&quot;I1mr&quot;/&quot;ILmr&quot;), data read accesses (&quot;Dr&quot;) and related cache misses (&quot;D1mr&quot;/&quot;DLmr&quot;), data write accesses (&quot;Dw&quot;) and related cache misses (&quot;D1mw&quot;/&quot;DLmw&quot;). For more information, see ???.</div>
<div class="spacer">
</div>
<b>--branch-sim=&lt;yes|no&gt; [default: no] </b><div style="margin-left: 4.00ex;">
Specify if you want to do branch prediction simulation. Further event counters are enabled: Number of executed conditional branches and related predictor misses (&quot;Bc&quot;/&quot;Bcm&quot;), executed indirect jumps and related misses of the jump address predictor (&quot;Bi&quot;/&quot;Bim&quot;).</div>
</div>
<div class="section">
<h1>HELGRIND OPTIONS</h1>  <b>--free-is-write=no|yes [default: no] </b><div style="margin-left: 4.00ex;">
When enabled (not the default), Helgrind treats freeing of heap memory as if the memory was written immediately before the free. This exposes races where memory is referenced by one thread, and freed by another, but there is no observable synchronisation event to ensure that the reference happens before the free.<div style="height: 1.00em;">
&#160;</div>
This functionality is new in Valgrind 3.7.0, and is regarded as experimental. It is not enabled by default because its interaction with custom memory allocators is not well understood at present. User feedback is welcomed.</div>
<div class="spacer">
</div>
<b>--track-lockorders=no|yes [default: yes] </b><div style="margin-left: 4.00ex;">
When enabled (the default), Helgrind performs lock order consistency checking. For some buggy programs, the large number of lock order errors reported can become annoying, particularly if you're only interested in race errors. You may therefore find it helpful to disable lock order checking.</div>
<div class="spacer">
</div>
<b>--history-level=none|approx|full [default: full] </b><div style="margin-left: 4.00ex;">
<b>--history-level=full</b> (the default) causes Helgrind collects enough information about &quot;old&quot; accesses that it can produce two stack traces in a race report -- both the stack trace for the current access, and the trace for the older, conflicting access.<div style="height: 1.00em;">
&#160;</div>
Collecting such information is expensive in both speed and memory, particularly for programs that do many inter-thread synchronisation events (locks, unlocks, etc). Without such information, it is more difficult to track down the root causes of races. Nonetheless, you may not need it in situations where you just want to check for the presence or absence of races, for example, when doing regression testing of a previously race-free program.<div style="height: 1.00em;">
&#160;</div>
<b>--history-level=none</b> is the opposite extreme. It causes Helgrind not to collect any information about previous accesses. This can be dramatically faster than  <b>--history-level=full</b>.<div style="height: 1.00em;">
&#160;</div>
<b>--history-level=approx</b> provides a compromise between these two extremes. It causes Helgrind to show a full trace for the later access, and approximate information regarding the earlier access. This approximate information consists of two stacks, and the earlier access is guaranteed to have occurred somewhere between program points denoted by the two stacks. This is not as useful as showing the exact stack for the previous access (as  <b>--history-level=full</b> does), but it is better than nothing, and it is almost as fast as  <b>--history-level=none</b>.</div>
<div class="spacer">
</div>
<b>--conflict-cache-size=N [default: 1000000] </b><div style="margin-left: 4.00ex;">
This flag only has any effect at  <b>--history-level=full</b>.<div style="height: 1.00em;">
&#160;</div>
Information about &quot;old&quot; conflicting accesses is stored in a cache of limited size, with LRU-style management. This is necessary because it isn't practical to store a stack trace for every single memory access made by the program. Historical information on not recently accessed locations is periodically discarded, to free up space in the cache.<div style="height: 1.00em;">
&#160;</div>
This option controls the size of the cache, in terms of the number of different memory addresses for which conflicting access information is stored. If you find that Helgrind is showing race errors with only one stack instead of the expected two stacks, try increasing this value.<div style="height: 1.00em;">
&#160;</div>
The minimum value is 10,000 and the maximum is 30,000,000 (thirty times the default value). Increasing the value by 1 increases Helgrind's memory requirement by very roughly 100 bytes, so the maximum value will easily eat up three extra gigabytes or so of memory.</div>
<div class="spacer">
</div>
<b>--check-stack-refs=no|yes [default: yes] </b><div style="margin-left: 4.00ex;">
By default Helgrind checks all data memory accesses made by your program. This flag enables you to skip checking for accesses to thread stacks (local variables). This can improve performance, but comes at the cost of missing races on stack-allocated data.</div>
</div>
<div class="section">
<h1>DRD OPTIONS</h1>  <b>--check-stack-var=&lt;yes|no&gt; [default: no]</b><div style="margin-left: 4.00ex;">
Controls whether DRD detects data races on stack variables. Verifying stack variables is disabled by default because most programs do not share stack variables over threads.</div>
<div class="spacer">
</div>
<b>--exclusive-threshold=&lt;n&gt; [default: off]</b><div style="margin-left: 4.00ex;">
Print an error message if any mutex or writer lock has been held longer than the time specified in milliseconds. This option enables the detection of lock contention.</div>
<div class="spacer">
</div>
<b>--join-list-vol=&lt;n&gt; [default: 10]</b><div style="margin-left: 4.00ex;">
Data races that occur between a statement at the end of one thread and another thread can be missed if memory access information is discarded immediately after a thread has been joined. This option allows to specify for how many joined threads memory access information should be retained.</div>
<div class="spacer">
</div>
<b> --first-race-only=&lt;yes|no&gt; [default: no] </b><div style="margin-left: 4.00ex;">
Whether to report only the first data race that has been detected on a memory location or all data races that have been detected on a memory location.</div>
<div class="spacer">
</div>
<b> --free-is-write=&lt;yes|no&gt; [default: no] </b><div style="margin-left: 4.00ex;">
Whether to report races between accessing memory and freeing memory. Enabling this option may cause DRD to run slightly slower. Notes:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
&#8226;Don't enable this option when using custom memory allocators that use the VG_USERREQ__MALLOCLIKE_BLOCK and VG_USERREQ__FREELIKE_BLOCK because that would result in false positives.</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
&#8226;Don't enable this option when using reference-counted objects because that will result in false positives, even when that code has been annotated properly with ANNOTATE_HAPPENS_BEFORE and ANNOTATE_HAPPENS_AFTER. See e.g. the output of the following command for an example: valgrind --tool=drd --free-is-write=yes drd/tests/annotate_smart_pointer.</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="spacer">
</div>
<b> --report-signal-unlocked=&lt;yes|no&gt; [default: yes] </b><div style="margin-left: 4.00ex;">
Whether to report calls to  <b>pthread_cond_signal</b> and  <b>pthread_cond_broadcast</b> where the mutex associated with the signal through  <b>pthread_cond_wait</b> or  <b>pthread_cond_timed_wait</b>is not locked at the time the signal is sent. Sending a signal without holding a lock on the associated mutex is a common programming error which can cause subtle race conditions and unpredictable behavior. There exist some uncommon synchronization patterns however where it is safe to send a signal without holding a lock on the associated mutex.</div>
<div class="spacer">
</div>
<b>--segment-merging=&lt;yes|no&gt; [default: yes]</b><div style="margin-left: 4.00ex;">
Controls segment merging. Segment merging is an algorithm to limit memory usage of the data race detection algorithm. Disabling segment merging may improve the accuracy of the so-called 'other segments' displayed in race reports but can also trigger an out of memory error.</div>
<div class="spacer">
</div>
<b>--segment-merging-interval=&lt;n&gt; [default: 10]</b><div style="margin-left: 4.00ex;">
Perform segment merging only after the specified number of new segments have been created. This is an advanced configuration option that allows to choose whether to minimize DRD's memory usage by choosing a low value or to let DRD run faster by choosing a slightly higher value. The optimal value for this parameter depends on the program being analyzed. The default value works well for most programs.</div>
<div class="spacer">
</div>
<b>--shared-threshold=&lt;n&gt; [default: off]</b><div style="margin-left: 4.00ex;">
Print an error message if a reader lock has been held longer than the specified time (in milliseconds). This option enables the detection of lock contention.</div>
<div class="spacer">
</div>
<b>--show-confl-seg=&lt;yes|no&gt; [default: yes]</b><div style="margin-left: 4.00ex;">
Show conflicting segments in race reports. Since this information can help to find the cause of a data race, this option is enabled by default. Disabling this option makes the output of DRD more compact.</div>
<div class="spacer">
</div>
<b>--show-stack-usage=&lt;yes|no&gt; [default: no]</b><div style="margin-left: 4.00ex;">
Print stack usage at thread exit time. When a program creates a large number of threads it becomes important to limit the amount of virtual memory allocated for thread stacks. This option makes it possible to observe how much stack memory has been used by each thread of the the client program. Note: the DRD tool itself allocates some temporary data on the client thread stack. The space necessary for this temporary data must be allocated by the client program when it allocates stack memory, but is not included in stack usage reported by DRD.</div>
<div class="spacer">
</div>
<b>--trace-addr=&lt;address&gt; [default: none]</b><div style="margin-left: 4.00ex;">
Trace all load and store activity for the specified address. This option may be specified more than once.</div>
<div class="spacer">
</div>
<b>--trace-alloc=&lt;yes|no&gt; [default: no]</b><div style="margin-left: 4.00ex;">
Trace all memory allocations and deallocations. May produce a huge amount of output.</div>
<div class="spacer">
</div>
<b>--trace-barrier=&lt;yes|no&gt; [default: no]</b><div style="margin-left: 4.00ex;">
Trace all barrier activity.</div>
<div class="spacer">
</div>
<b>--trace-cond=&lt;yes|no&gt; [default: no]</b><div style="margin-left: 4.00ex;">
Trace all condition variable activity.</div>
<div class="spacer">
</div>
<b>--trace-fork-join=&lt;yes|no&gt; [default: no]</b><div style="margin-left: 4.00ex;">
Trace all thread creation and all thread termination events.</div>
<div class="spacer">
</div>
<b>--trace-hb=&lt;yes|no&gt; [default: no]</b><div style="margin-left: 4.00ex;">
Trace execution of the ANNOTATE_HAPPENS_BEFORE(), ANNOTATE_HAPPENS_AFTER() and ANNOTATE_HAPPENS_DONE() client requests.</div>
<div class="spacer">
</div>
<b>--trace-mutex=&lt;yes|no&gt; [default: no]</b><div style="margin-left: 4.00ex;">
Trace all mutex activity.</div>
<div class="spacer">
</div>
<b>--trace-rwlock=&lt;yes|no&gt; [default: no]</b><div style="margin-left: 4.00ex;">
Trace all reader-writer lock activity.</div>
<div class="spacer">
</div>
<b>--trace-semaphore=&lt;yes|no&gt; [default: no]</b><div style="margin-left: 4.00ex;">
Trace all semaphore activity.</div>
</div>
<div class="section">
<h1>MASSIF OPTIONS</h1>  <b>--heap=&lt;yes|no&gt; [default: yes] </b><div style="margin-left: 4.00ex;">
Specifies whether heap profiling should be done.</div>
<div class="spacer">
</div>
<b>--heap-admin=&lt;size&gt; [default: 8] </b><div style="margin-left: 4.00ex;">
If heap profiling is enabled, gives the number of administrative bytes per block to use. This should be an estimate of the average, since it may vary. For example, the allocator used by glibc on Linux requires somewhere between 4 to 15 bytes per block, depending on various factors. That allocator also requires admin space for freed blocks, but Massif cannot account for this.</div>
<div class="spacer">
</div>
<b>--stacks=&lt;yes|no&gt; [default: no] </b><div style="margin-left: 4.00ex;">
Specifies whether stack profiling should be done. This option slows Massif down greatly, and so is off by default. Note that Massif assumes that the main stack has size zero at start-up. This is not true, but doing otherwise accurately is difficult. Furthermore, starting at zero better indicates the size of the part of the main stack that a user program actually has control over.</div>
<div class="spacer">
</div>
<b>--pages-as-heap=&lt;yes|no&gt; [default: no] </b><div style="margin-left: 4.00ex;">
Tells Massif to profile memory at the page level rather than at the malloc'd block level. See above for details.</div>
<div class="spacer">
</div>
<b>--depth=&lt;number&gt; [default: 30] </b><div style="margin-left: 4.00ex;">
Maximum depth of the allocation trees recorded for detailed snapshots. Increasing it will make Massif run somewhat more slowly, use more memory, and produce bigger output files.</div>
<div class="spacer">
</div>
<b>--alloc-fn=&lt;name&gt; </b><div style="margin-left: 4.00ex;">
Functions specified with this option will be treated as though they were a heap allocation function such as  <b>malloc</b>. This is useful for functions that are wrappers to  <b>malloc</b> or  <b>new</b>, which can fill up the allocation trees with uninteresting information. This option can be specified multiple times on the command line, to name multiple functions.<div style="height: 1.00em;">
&#160;</div>
Note that the named function will only be treated this way if it is the top entry in a stack trace, or just below another function treated this way. For example, if you have a function  <b>malloc1</b> that wraps  <b>malloc</b>, and  <b>malloc2</b> that wraps  <b>malloc1</b>, just specifying  <b>--alloc-fn=malloc2</b> will have no effect. You need to specify  <b>--alloc-fn=malloc1</b> as well. This is a little inconvenient, but the reason is that checking for allocation functions is slow, and it saves a lot of time if Massif can stop looking through the stack trace entries as soon as it finds one that doesn't match rather than having to continue through all the entries.<div style="height: 1.00em;">
&#160;</div>
Note that C++ names are demangled. Note also that overloaded C++ names must be written in full. Single quotes may be necessary to prevent the shell from breaking them up. For example:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
<br/>
--alloc-fn='operator new(unsigned, std::nothrow_t const&amp;)'<br/>
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="spacer">
</div>
<b>--ignore-fn=&lt;name&gt; </b><div style="margin-left: 4.00ex;">
Any direct heap allocation (i.e. a call to  <b>malloc</b>,  <b>new</b>, etc, or a call to a function named by an  <b>--alloc-fn</b> option) that occurs in a function specified by this option will be ignored. This is mostly useful for testing purposes. This option can be specified multiple times on the command line, to name multiple functions.<div style="height: 1.00em;">
&#160;</div>
Any  <b>realloc</b> of an ignored block will also be ignored, even if the  <b>realloc</b> call does not occur in an ignored function. This avoids the possibility of negative heap sizes if ignored blocks are shrunk with  <b>realloc</b>.<div style="height: 1.00em;">
&#160;</div>
The rules for writing C++ function names are the same as for  <b>--alloc-fn</b> above.</div>
<div class="spacer">
</div>
<b>--threshold=&lt;m.n&gt; [default: 1.0] </b><div style="margin-left: 4.00ex;">
The significance threshold for heap allocations, as a percentage of total memory size. Allocation tree entries that account for less than this will be aggregated. Note that this should be specified in tandem with ms_print's option of the same name.</div>
<div class="spacer">
</div>
<b>--peak-inaccuracy=&lt;m.n&gt; [default: 1.0] </b><div style="margin-left: 4.00ex;">
Massif does not necessarily record the actual global memory allocation peak; by default it records a peak only when the global memory allocation size exceeds the previous peak by at least 1.0%. This is because there can be many local allocation peaks along the way, and doing a detailed snapshot for every one would be expensive and wasteful, as all but one of them will be later discarded. This inaccuracy can be changed (even to 0.0%) via this option, but Massif will run drastically slower as the number approaches zero.</div>
<div class="spacer">
</div>
<b>--time-unit=&lt;i|ms|B&gt; [default: i] </b><div style="margin-left: 4.00ex;">
The time unit used for the profiling. There are three possibilities: instructions executed (i), which is good for most cases; real (wallclock) time (ms, i.e. milliseconds), which is sometimes useful; and bytes allocated/deallocated on the heap and/or stack (B), which is useful for very short-run programs, and for testing purposes, because it is the most reproducible across different machines.</div>
<div class="spacer">
</div>
<b>--detailed-freq=&lt;n&gt; [default: 10] </b><div style="margin-left: 4.00ex;">
Frequency of detailed snapshots. With  <b>--detailed-freq=1</b>, every snapshot is detailed.</div>
<div class="spacer">
</div>
<b>--max-snapshots=&lt;n&gt; [default: 100] </b><div style="margin-left: 4.00ex;">
The maximum number of snapshots recorded. If set to N, for all programs except very short-running ones, the final number of snapshots will be between N/2 and N.</div>
<div class="spacer">
</div>
<b>--massif-out-file=&lt;file&gt; [default: massif.out.%p] </b><div style="margin-left: 4.00ex;">
Write the profile data to file rather than to the default output file, massif.out.&lt;pid&gt;. The  <b>%p</b> and  <b>%q</b> format specifiers can be used to embed the process ID and/or the contents of an environment variable in the name, as is the case for the core option  <b>--log-file</b>.</div>
</div>
<div class="section">
<h1>SGCHECK OPTIONS</h1> &lt;xi:include&gt;&lt;/xi:include&gt;.SH &quot;BBV OPTIONS&quot;<div class="spacer">
</div>
<b>--bb-out-file=&lt;name&gt; [default: bb.out.%p] </b><div style="margin-left: 4.00ex;">
This option selects the name of the basic block vector file. The  <b>%p</b> and  <b>%q</b> format specifiers can be used to embed the process ID and/or the contents of an environment variable in the name, as is the case for the core option  <b>--log-file</b>.</div>
<div class="spacer">
</div>
<b>--pc-out-file=&lt;name&gt; [default: pc.out.%p] </b><div style="margin-left: 4.00ex;">
This option selects the name of the PC file. This file holds program counter addresses and function name info for the various basic blocks. This can be used in conjunction with the basic block vector file to fast-forward via function names instead of just instruction counts. The  <b>%p</b> and  <b>%q</b> format specifiers can be used to embed the process ID and/or the contents of an environment variable in the name, as is the case for the core option  <b>--log-file</b>.</div>
<div class="spacer">
</div>
<b>--interval-size=&lt;number&gt; [default: 100000000] </b><div style="margin-left: 4.00ex;">
This option selects the size of the interval to use. The default is 100 million instructions, which is a commonly used value. Other sizes can be used; smaller intervals can help programs with finer-grained phases. However smaller interval size can lead to accuracy issues due to warm-up effects (When fast-forwarding the various architectural features will be un-initialized, and it will take some number of instructions before they &quot;warm up&quot; to the state a full simulation would be at without the fast-forwarding. Large interval sizes tend to mitigate this.)</div>
<div class="spacer">
</div>
<b>--instr-count-only [default: no] </b><div style="margin-left: 4.00ex;">
This option tells the tool to only display instruction count totals, and to not generate the actual basic block vector file. This is useful for debugging, and for gathering instruction count info without generating the large basic block vector files.</div>
</div>
<div class="section">
<h1>LACKEY OPTIONS</h1>  <b>--basic-counts=&lt;no|yes&gt; [default: yes] </b><div style="margin-left: 4.00ex;">
When enabled, Lackey prints the following statistics and information about the execution of the client program:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
 1.The number of calls to the function specified by the  <b>--fnname</b> option (the default is main). If the program has had its symbols stripped, the count will always be zero.</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
 2.The number of conditional branches encountered and the number and proportion of those taken.</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
 3.The number of superblocks entered and completed by the program. Note that due to optimisations done by the JIT, this is not at all an accurate value.</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
 4.The number of guest (x86, amd64, ppc, etc.) instructions and IR statements executed. IR is Valgrind's RISC-like intermediate representation via which all instrumentation is done.</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
 5.Ratios between some of these counts.</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
 6.The exit code of the client program.</div>
</div>
<div class="spacer">
</div>
<b>--detailed-counts=&lt;no|yes&gt; [default: no] </b><div style="margin-left: 4.00ex;">
When enabled, Lackey prints a table containing counts of loads, stores and ALU operations, differentiated by their IR types. The IR types are identified by their IR name (&quot;I1&quot;, &quot;I8&quot;, ... &quot;I128&quot;, &quot;F32&quot;, &quot;F64&quot;, and &quot;V128&quot;).</div>
<div class="spacer">
</div>
<b>--trace-mem=&lt;no|yes&gt; [default: no] </b><div style="margin-left: 4.00ex;">
When enabled, Lackey prints the size and address of almost every memory access made by the program. See the comments at the top of the file lackey/lk_main.c for details about the output format, how it works, and inaccuracies in the address trace. Note that this option produces immense amounts of output.</div>
<div class="spacer">
</div>
<b>--trace-superblocks=&lt;no|yes&gt; [default: no] </b><div style="margin-left: 4.00ex;">
When enabled, Lackey prints out the address of every superblock (a single entry, multiple exit, linear chunk of code) executed by the program. This is primarily of interest to Valgrind developers. See the comments at the top of the file lackey/lk_main.c for details about the output format. Note that this option produces large amounts of output.</div>
<div class="spacer">
</div>
<b>--fnname=&lt;name&gt; [default: main] </b><div style="margin-left: 4.00ex;">
Changes the function for which calls are counted when  <b>--basic-counts=yes</b> is specified.</div>
</div>
<div class="section">
<h1>SEE ALSO</h1> cg_annotate(1), callgrind_annotate(1), callgrind_control(1), ms_print(1), $INSTALL/share/doc/valgrind/html/index.html or http://www.valgrind.org/docs/manual/index.html.</div>
<div class="section">
<h1>AUTHOR</h1> The Valgrind developers.<div class="spacer">
</div>
This manpage was written by Andres Roldan &lt;aroldan@debian.org&gt; and the Valgrind developers.</div>
<table class="foot">
<tr>
<td class="foot-date">
11/05/2011</td>
<td class="foot-os">
Release 3.7.0</td>
</tr>
</table>
</div>
</body>
</html>

