<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
EXEC(3P)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
EXEC(3P)</td>
<td class="head-vol">
POSIX Programmer's Manual</td>
<td class="head-rtitle">
EXEC(3P)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>PROLOG</h1> This manual page is part of the POSIX Programmer's Manual. The Linux implementation of this interface may differ (consult the corresponding Linux manual page for details of Linux behavior), or the interface may not be implemented on Linux.</div>
<div class="section">
<h1>NAME</h1> environ, execl, execv, execle, execve, execlp, execvp - execute a file</div>
<div class="section">
<h1>SYNOPSIS</h1>  <b>#include &lt;unistd.h&gt;</b><div style="height: 0.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
extern char **environ;<div style="height: 0.00em;">
&#160;</div>
int execl(const char *<b></b><i>path</i><b></b><b>, const char *</b><b></b><i>arg0</i><b></b><b>,</b>  <b>... /*, (char *)0 */);</b><div style="height: 0.00em;">
&#160;</div>
int execv(const char *<b></b><i>path</i><b></b><b>, char *const</b><b> </b><i>argv</i><b></b><b>[]);</b><div style="height: 0.00em;">
&#160;</div>
int execle(const char *<b></b><i>path</i><b></b><b>, const char *</b><b></b><i>arg0</i><b></b><b>,</b>  <b>... /*,</b><div style="height: 0.00em;">
&#160;</div>
&#160;&#160;&#160;&#160;&#160;&#160; (char *)0, char *const<b> </b><i>envp</i><b></b><b>[]*/);</b><div style="height: 0.00em;">
&#160;</div>
int execve(const char *<b></b><i>path</i><b></b><b>, char *const</b><b> </b><i>argv</i><b></b><b>[],</b>  <b>char *const</b><b> </b><i>envp</i><b></b><b>[]);</b><div style="height: 0.00em;">
&#160;</div>
int execlp(const char *<b></b><i>file</i><b></b><b>, const char *</b><b></b><i>arg0</i><b></b><b>,</b>  <b>... /*, (char *)0 */);</b><div style="height: 0.00em;">
&#160;</div>
int execvp(const char *<b></b><i>file</i><b></b><b>, char *const</b><b> </b><i>argv</i><b></b><b>[]);</b><div style="height: 0.00em;">
&#160;</div>
<b></b></div>
<div class="section">
<h1>DESCRIPTION</h1> The  <i>exec</i> family of functions shall replace the current process image with a new process image. The new image shall be constructed from a regular, executable file called the  <i>new process</i>  <i>image file</i>. There shall be no return from a successful  <i>exec</i>, because the calling process image is overlaid by the new process image.<div class="spacer">
</div>
When a C-language program is executed as a result of this call, it shall be entered as a C-language function call as follows:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>int main (</b><i>int argc, char *argv</i><b>[]);</b><br/>
<b></b><br/>
</div>
<div class="spacer">
</div>
where <i>argc</i> is the argument count and <i>argv</i> is an array of character pointers to the arguments themselves. In addition, the following variable:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>extern char **environ;</b><br/>
<b></b><br/>
</div>
<div class="spacer">
</div>
is initialized as a pointer to an array of character pointers to the environment strings. The  <i>argv</i> and <i>environ</i> arrays are each terminated by a null pointer. The null pointer terminating the  <i>argv</i> array is not counted in <i>argc</i>.<div class="spacer">
</div>
Conforming multi-threaded applications shall not use the <i>environ</i> variable to access or modify any environment variable while any other thread is concurrently modifying any environment variable. A call to any function dependent on any environment variable shall be considered a use of the  <i>environ</i> variable to access that environment variable.<div class="spacer">
</div>
The arguments specified by a program with one of the <i>exec</i> functions shall be passed on to the new process image in the corresponding  <i>main</i>() arguments.<div class="spacer">
</div>
The argument <i>path</i> points to a pathname that identifies the new process image file.<div class="spacer">
</div>
The argument <i>file</i> is used to construct a pathname that identifies the new process image file. If the  <i>file</i> argument contains a slash character, the  <i>file</i> argument shall be used as the pathname for this file. Otherwise, the path prefix for this file is obtained by a search of the directories passed as the environment variable  <i>PATH</i> (see the Base Definitions volume of IEEE&#160;Std&#160;1003.1-2001, Chapter 8, Environment Variables). If this environment variable is not present, the results of the search are implementation-defined.<div class="spacer">
</div>
There are two distinct ways in which the contents of the process image file may cause the execution to fail, distinguished by the setting of  <i>errno</i> to either [ENOEXEC] or [EINVAL] (see the ERRORS section). In the cases where the other members of the  <i>exec</i> family of functions would fail and set <i>errno</i> to [ENOEXEC], the  <i>execlp</i>() and <i>execvp</i>() functions shall execute a command interpreter and the environment of the executed command shall be as if the process invoked the  <i>sh</i> utility using  <i>execl</i>() as follows:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>execl(&lt;shell path&gt;, arg0, file, arg1, ..., (char *)0);</b><br/>
<b></b><br/>
</div>
<div class="spacer">
</div>
where &lt;<i>shell&#160;path</i>&gt; is an unspecified pathname for the <i>sh</i> utility,  <i>file</i> is the process image file, and for <i>execvp</i>(), where  <i>arg</i>0, <i>arg</i>1, and so on correspond to the values passed to  <i>execvp</i>() in <i>argv</i>[0], <i>argv</i>[1], and so on.<div class="spacer">
</div>
The arguments represented by <i>arg0</i>,... are pointers to null-terminated character strings. These strings shall constitute the argument list available to the new process image. The list is terminated by a null pointer. The argument  <i>arg0</i> should point to a filename that is associated with the process being started by one of the  <i>exec</i> functions.<div class="spacer">
</div>
The argument <i>argv</i> is an array of character pointers to null-terminated strings. The application shall ensure that the last member of this array is a null pointer. These strings shall constitute the argument list available to the new process image. The value in  <i>argv</i>[0] should point to a filename that is associated with the process being started by one of the  <i>exec</i> functions.<div class="spacer">
</div>
The argument <i>envp</i> is an array of character pointers to null-terminated strings. These strings shall constitute the environment for the new process image. The  <i>envp</i> array is terminated by a null pointer.<div class="spacer">
</div>
For those forms not containing an <i>envp</i> pointer ( <i>execl</i>(),  <i>execv</i>(), <i>execlp</i>(), and <i>execvp</i>()), the environment for the new process image shall be taken from the external variable  <i>environ</i> in the calling process.<div class="spacer">
</div>
The number of bytes available for the new process' combined argument and environment lists is {ARG_MAX}. It is implementation-defined whether null terminators, pointers, and/or any alignment bytes are included in this total.<div class="spacer">
</div>
File descriptors open in the calling process image shall remain open in the new process image, except for those whose close-on-  <i>exec</i> flag FD_CLOEXEC is set. For those file descriptors that remain open, all attributes of the open file description remain unchanged. For any file descriptor that is closed for this reason, file locks are removed as a result of the close as described in  <i>close</i>(). Locks that are not removed by closing of file descriptors remain unchanged.<div class="spacer">
</div>
If file descriptors 0, 1, and 2 would otherwise be closed after a successful call to one of the  <i>exec</i> family of functions, and the new process image file has the set-user-ID or set-group-ID file mode bits set,  and the ST_NOSUID bit is not set for the file system containing the new process image file,  implementations may open an unspecified file for each of these file descriptors in the new process image.<div class="spacer">
</div>
Directory streams open in the calling process image shall be closed in the new process image.<div class="spacer">
</div>
The state of the floating-point environment in the new process image shall be set to the default.<div class="spacer">
</div>
The state of conversion descriptors and message catalog descriptors in the new process image is undefined. For the new process image, the equivalent of:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>setlocale(LC_ALL, &quot;C&quot;)</b><br/>
<b></b><br/>
</div>
<div class="spacer">
</div>
shall be executed at start-up.<div class="spacer">
</div>
Signals set to the default action (SIG_DFL) in the calling process image shall be set to the default action in the new process image. Except for SIGCHLD, signals set to be ignored (SIG_IGN) by the calling process image shall be set to be ignored by the new process image. Signals set to be caught by the calling process image shall be set to the default action in the new process image (see  <i>&lt;signal.h&gt;</i>). If the SIGCHLD signal is set to be ignored by the calling process image, it is unspecified whether the SIGCHLD signal is set to be ignored or to the default action in the new process image. &#160;After a successful call to any of the  <i>exec</i> functions, alternate signal stacks are not preserved and the SA_ONSTACK flag shall be cleared for all signals.<div class="spacer">
</div>
After a successful call to any of the <i>exec</i> functions, any functions previously registered by  <i>atexit</i>() are no longer registered.<div class="spacer">
</div>
If the ST_NOSUID bit is set for the file system containing the new process image file, then the effective user ID, effective group ID, saved set-user-ID, and saved set-group-ID are unchanged in the new process image. Otherwise,  if the set-user-ID mode bit of the new process image file is set, the effective user ID of the new process image shall be set to the user ID of the new process image file. Similarly, if the set-group-ID mode bit of the new process image file is set, the effective group ID of the new process image shall be set to the group ID of the new process image file. The real user ID, real group ID, and supplementary group IDs of the new process image shall remain the same as those of the calling process image. The effective user ID and effective group ID of the new process image shall be saved (as the saved set-user-ID and the saved set-group-ID) for use by  <i>setuid</i>().<div class="spacer">
</div>
Any shared memory segments attached to the calling process image shall not be attached to the new process image.<div class="spacer">
</div>
Any named semaphores open in the calling process shall be closed as if by appropriate calls to  <i>sem_close</i>().<div class="spacer">
</div>
Any blocks of typed memory that were mapped in the calling process are unmapped, as if  <i>munmap</i>() was implicitly called to unmap them.<div class="spacer">
</div>
Memory locks established by the calling process via calls to <i>mlockall</i>() or  <i>mlock</i>() shall be removed. If locked pages in the address space of the calling process are also mapped into the address spaces of other processes and are locked by those processes, the locks established by the other processes shall be unaffected by the call by this process to the  <i>exec</i> function. If the  <i>exec</i> function fails, the effect on memory locks is unspecified.<div class="spacer">
</div>
Memory mappings created in the process are unmapped before the address space is rebuilt for the new process image.<div class="spacer">
</div>
For the SCHED_FIFO and SCHED_RR scheduling policies, the policy and priority settings shall not be changed by a call to an  <i>exec</i> function. For other scheduling policies, the policy and priority settings on  <i>exec</i> are implementation-defined.<div class="spacer">
</div>
Per-process timers created by the calling process shall be deleted before replacing the current process image with the new process image.<div class="spacer">
</div>
All open message queue descriptors in the calling process shall be closed, as described in  <i>mq_close</i>().<div class="spacer">
</div>
Any outstanding asynchronous I/O operations may be canceled. Those asynchronous I/O operations that are not canceled shall complete as if the  <i>exec</i> function had not yet occurred, but any associated signal notifications shall be suppressed. It is unspecified whether the  <i>exec</i> function itself blocks awaiting such I/O completion. In no event, however, shall the new process image created by the  <i>exec</i> function be affected by the presence of outstanding asynchronous I/O operations at the time the  <i>exec</i> function is called. Whether any I/O is canceled, and which I/O may be canceled upon  <i>exec</i>, is implementation-defined.<div class="spacer">
</div>
The new process image shall inherit the CPU-time clock of the calling process image. This inheritance means that the process CPU-time clock of the process being  <i>exec</i>-ed shall not be reinitialized or altered as a result of the  <i>exec</i> function other than to reflect the time spent by the process executing the  <i>exec</i> function itself.<div class="spacer">
</div>
The initial value of the CPU-time clock of the initial thread of the new process image shall be set to zero.<div class="spacer">
</div>
If the calling process is being traced, the new process image shall continue to be traced into the same trace stream as the original process image, but the new process image shall not inherit the mapping of trace event names to trace event type identifiers that was defined by calls to the  <i>posix_trace_eventid_open</i>() or the  <i>posix_trace_trid_eventid_open</i>() functions in the calling process image.<div class="spacer">
</div>
If the calling process is a trace controller process, any trace streams that were created by the calling process shall be shut down as described in the  <i>posix_trace_shutdown</i>() function.<div class="spacer">
</div>
The new process shall inherit at least the following attributes from the calling process image:<dl>
<dt>
 *</dt>
<dd>
Nice value (see <i>nice</i>())</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
<i>semadj</i> values (see <i>semop</i>())</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
Process ID</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
Parent process ID</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
Process group ID</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
Session membership</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
Real user ID</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
Real group ID</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
Supplementary group IDs</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
Time left until an alarm clock signal (see <i>alarm</i>())</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
Current working directory</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
Root directory</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
File mode creation mask (see <i>umask</i>())</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
File size limit (see <i>ulimit</i>())</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
Process signal mask (see <i>sigprocmask</i>())</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
Pending signal (see <i>sigpending</i>())</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
<i>tms_utime</i>, <i>tms_stime</i>, <i>tms_cutime</i>, and <i>tms_cstime</i> (see  <i>times</i>())</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
Resource limits</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
Controlling terminal</dd>
</dl>
<dl>
<dt>
 *</dt>
<dd>
Interval timers</dd>
</dl>
<div class="spacer">
</div>
All other process attributes defined in this volume of IEEE&#160;Std&#160;1003.1-2001 shall be the same in the new and old process images. The inheritance of process attributes not defined by this volume of IEEE&#160;Std&#160;1003.1-2001 is implementation-defined.<div class="spacer">
</div>
A call to any <i>exec</i> function from a process with more than one thread shall result in all threads being terminated and the new executable image being loaded and executed. No destructor functions shall be called.<div class="spacer">
</div>
Upon successful completion, the <i>exec</i> functions shall mark for update the  <i>st_atime</i> field of the file. If an  <i>exec</i> function failed but was able to locate the process image file, whether the  <i>st_atime</i> field is marked for update is unspecified. Should the  <i>exec</i> function succeed, the process image file shall be considered to have been opened with  <i>open</i>(). The corresponding  <i>close</i>() shall be considered to occur at a time after this open, but before process termination or successful completion of a subsequent call to one of the  <i>exec</i> functions, <i>posix_spawn</i>(), or <i>posix_spawnp</i>(). The  <i>argv</i>[] and <i>envp</i>[] arrays of pointers and the strings to which those arrays point shall not be modified by a call to one of the  <i>exec</i> functions, except as a consequence of replacing the process image.<div class="spacer">
</div>
The saved resource limits in the new process image are set to be a copy of the process' corresponding hard and soft limits.</div>
<div class="section">
<h1>RETURN VALUE</h1> If one of the  <i>exec</i> functions returns to the calling process image, an error has occurred; the return value shall be -1, and  <i>errno</i> shall be set to indicate the error.</div>
<div class="section">
<h1>ERRORS</h1> The  <i>exec</i> functions shall fail if:<dl>
<dt>
<b>E2BIG</b></dt>
<dd>
The number of bytes used by the new process image's argument list and environment list is greater than the system-imposed limit of {ARG_MAX} bytes.</dd>
</dl>
<dl>
<dt>
<b>EACCES</b></dt>
<dd>
Search permission is denied for a directory listed in the new process image file's path prefix, or the new process image file denies execution permission, or the new process image file is not a regular file and the implementation does not support execution of files of its type.</dd>
</dl>
<dl>
<dt>
<b>EINVAL</b></dt>
<dd>
The new process image file has the appropriate permission and has a recognized executable binary format, but the system does not support execution of a file with this format.</dd>
</dl>
<dl>
<dt>
<b>ELOOP</b></dt>
<dd>
A loop exists in symbolic links encountered during resolution of the  <i>path</i> or <i>file</i> argument.</dd>
</dl>
<dl>
<dt>
<b>ENAMETOOLONG</b></dt>
<dd>
The length of the <i>path</i> or <i>file</i> arguments exceeds {PATH_MAX} or a pathname component is longer than {NAME_MAX}.</dd>
</dl>
<dl>
<dt>
<b>ENOENT</b></dt>
<dd>
A component of <i>path</i> or <i>file</i> does not name an existing file or  <i>path</i> or <i>file</i> is an empty string.</dd>
</dl>
<dl>
<dt>
<b>ENOTDIR</b></dt>
<dd>
A component of the new process image file's path prefix is not a directory.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<div class="spacer">
</div>
The <i>exec</i> functions, except for <i>execlp</i>() and <i>execvp</i>(), shall fail if:<dl>
<dt>
<b>ENOEXEC</b></dt>
<dd>
The new process image file has the appropriate access permission but has an unrecognized format.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<div class="spacer">
</div>
The <i>exec</i> functions may fail if:<dl>
<dt>
<b>ELOOP</b></dt>
<dd>
More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the  <i>path</i> or <i>file</i> argument.</dd>
</dl>
<dl>
<dt>
<b>ENAMETOOLONG</b></dt>
<dd>
As a result of encountering a symbolic link in resolution of the <i>path</i> argument, the length of the substituted pathname string exceeded {PATH_MAX}.</dd>
</dl>
<dl>
<dt>
<b>ENOMEM</b></dt>
<dd>
The new process image requires more memory than is allowed by the hardware or system-imposed memory management constraints.</dd>
</dl>
<dl>
<dt>
<b>ETXTBSY</b></dt>
<dd>
The new process image file is a pure procedure (shared text) file that is currently open for writing by some process.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<div class="spacer">
</div>
<i>The following sections are informative.</i></div>
<div class="section">
<h1>EXAMPLES</h1><div class="subsection">
<h2>Using execl()</h2> The following example executes the  <i>ls</i> command, specifying the pathname of the executable (  <b>/bin/ls</b>) and using arguments supplied directly to the command to produce single-column output.<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>#include &lt;unistd.h&gt;</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
int ret;<br/>
...<br/>
ret = execl (&quot;/bin/ls&quot;, &quot;ls&quot;, &quot;-1&quot;, (char *)0);<br/>
<b></b><br/>
</div>
</div>
<div class="subsection">
<h2>Using execle()</h2> The following example is similar to Using execl() . In addition, it specifies the environment for the new process image using the  <i>env</i> argument.<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>#include &lt;unistd.h&gt;</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
int ret;<br/>
char *env[] = { &quot;HOME=/usr/home&quot;, &quot;LOGNAME=home&quot;, (char *)0 };<br/>
...<br/>
ret = execle (&quot;/bin/ls&quot;, &quot;ls&quot;, &quot;-l&quot;, (char *)0, env);<br/>
<b></b><br/>
</div>
</div>
<div class="subsection">
<h2>Using execlp()</h2> The following example searches for the location of the  <i>ls</i> command among the directories specified by the  <i>PATH</i> environment variable.<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>#include &lt;unistd.h&gt;</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
int ret;<br/>
...<br/>
ret = execlp (&quot;ls&quot;, &quot;ls&quot;, &quot;-l&quot;, (char *)0);<br/>
<b></b><br/>
</div>
</div>
<div class="subsection">
<h2>Using execv()</h2> The following example passes arguments to the  <i>ls</i> command in the  <i>cmd</i> array.<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>#include &lt;unistd.h&gt;</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
int ret;<br/>
char *cmd[] = { &quot;ls&quot;, &quot;-l&quot;, (char *)0 };<br/>
...<br/>
ret = execv (&quot;/bin/ls&quot;, cmd);<br/>
<b></b><br/>
</div>
</div>
<div class="subsection">
<h2>Using execve()</h2> The following example passes arguments to the  <i>ls</i> command in the  <i>cmd</i> array, and specifies the environment for the new process image using the  <i>env</i> argument.<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>#include &lt;unistd.h&gt;</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
int ret;<br/>
char *cmd[] = { &quot;ls&quot;, &quot;-l&quot;, (char *)0 };<br/>
char *env[] = { &quot;HOME=/usr/home&quot;, &quot;LOGNAME=home&quot;, (char *)0 };<br/>
...<br/>
ret = execve (&quot;/bin/ls&quot;, cmd, env);<br/>
<b></b><br/>
</div>
</div>
<div class="subsection">
<h2>Using execvp()</h2> The following example searches for the location of the  <i>ls</i> command among the directories specified by the  <i>PATH</i> environment variable, and passes arguments to the  <i>ls</i> command in the <i>cmd</i> array.<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>#include &lt;unistd.h&gt;</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
int ret;<br/>
char *cmd[] = { &quot;ls&quot;, &quot;-l&quot;, (char *)0 };<br/>
...<br/>
ret = execvp (&quot;ls&quot;, cmd);<br/>
<b></b><br/>
</div>
</div>
</div>
<div class="section">
<h1>APPLICATION USAGE</h1> As the state of conversion descriptors and message catalog descriptors in the new process image is undefined, conforming applications should not rely on their use and should close them prior to calling one of the  <i>exec</i> functions.<div class="spacer">
</div>
Applications that require other than the default POSIX locale should call  <i>setlocale</i>() with the appropriate parameters to establish the locale of the new process.<div class="spacer">
</div>
The <i>environ</i> array should not be accessed directly by the application.<div class="spacer">
</div>
Applications should not depend on file descriptors 0, 1, and 2 being closed after an  <i>exec</i>. A future version may allow these file descriptors to be automatically opened for any process.</div>
<div class="section">
<h1>RATIONALE</h1> Early proposals required that the value of  <i>argc</i> passed to <i>main</i>() be &quot;one or greater&quot;. This was driven by the same requirement in drafts of the ISO&#160;C standard. In fact, historical implementations have passed a value of zero when no arguments are supplied to the caller of the  <i>exec</i> functions. This requirement was removed from the ISO&#160;C standard and subsequently removed from this volume of IEEE&#160;Std&#160;1003.1-2001 as well. The wording, in particular the use of the word  <i>should</i>, requires a Strictly Conforming POSIX Application to pass at least one argument to the  <i>exec</i> function, thus guaranteeing that  <i>argc</i> be one or greater when invoked by such an application. In fact, this is good practice, since many existing applications reference  <i>argv</i>[0] without first checking the value of  <i>argc</i>.<div class="spacer">
</div>
The requirement on a Strictly Conforming POSIX Application also states that the value passed as the first argument be a filename associated with the process being started. Although some existing applications pass a pathname rather than a filename in some circumstances, a filename is more generally useful, since the common usage of  <i>argv</i>[0] is in printing diagnostics. In some cases the filename passed is not the actual filename of the file; for example, many implementations of the  <i>login</i> utility use a convention of prefixing a hyphen (  <b>'-'</b> ) to the actual filename, which indicates to the command interpreter being invoked that it is a &quot;login shell&quot;.<div class="spacer">
</div>
Historically there have been two ways that implementations can <i>exec</i> shell scripts.<div class="spacer">
</div>
One common historical implementation is that the <i>execl</i>(), <i>execv</i>(),  <i>execle</i>(), and <i>execve</i>() functions return an [ENOEXEC] error for any file not recognizable as executable, including a shell script. When the  <i>execlp</i>() and  <i>execvp</i>() functions encounter such a file, they assume the file to be a shell script and invoke a known command interpreter to interpret such files. This is now required by IEEE&#160;Std&#160;1003.1-2001. These implementations of  <i>execvp</i>() and  <i>execlp</i>() only give the [ENOEXEC] error in the rare case of a problem with the command interpreter's executable file. Because of these implementations, the [ENOEXEC] error is not mentioned for  <i>execlp</i>() or <i>execvp</i>(), although implementations can still give it.<div class="spacer">
</div>
Another way that some historical implementations handle shell scripts is by recognizing the first two bytes of the file as the character string  <b>&quot;#!&quot;</b> and using the remainder of the first line of the file as the name of the command interpreter to execute.<div class="spacer">
</div>
One potential source of confusion noted by the standard developers is over how the contents of a process image file affect the behavior of the  <i>exec</i> family of functions. The following is a description of the actions taken:<dl>
<dt>
 1.</dt>
<dd>
If the process image file is a valid executable (in a format that is executable and valid and having appropriate permission) for this system, then the system executes the file.</dd>
</dl>
<dl>
<dt>
 2.</dt>
<dd>
If the process image file has appropriate permission and is in a format that is executable but not valid for this system (such as a recognized binary for another architecture), then this is an error and  <i>errno</i> is set to [EINVAL] (see later RATIONALE on [EINVAL]).</dd>
</dl>
<dl>
<dt>
 3.</dt>
<dd>
If the process image file has appropriate permission but is not otherwise recognized:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl>
<dt>
 a.</dt>
<dd>
If this is a call to <i>execlp</i>() or <i>execvp</i>(), then they invoke a command interpreter assuming that the process image file is a shell script.</dd>
</dl>
<dl>
<dt>
 b.</dt>
<dd>
If this is not a call to <i>execlp</i>() or <i>execvp</i>(), then an error occurs and  <i>errno</i> is set to [ENOEXEC].</dd>
</dl>
</div>
<div class="spacer">
</div>
Applications that do not require to access their arguments may use the form:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>main(void)</b><br/>
<b></b><br/>
</div>
as specified in the ISO&#160;C standard. However, the implementation will always provide the two arguments  <i>argc</i> and  <i>argv</i>, even if they are not used.<div class="spacer">
</div>
Some implementations provide a third argument to <i>main</i>() called  <i>envp</i>. This is defined as a pointer to the environment. The ISO&#160;C standard specifies invoking  <i>main</i>() with two arguments, so implementations must support applications written this way. Since this volume of IEEE&#160;Std&#160;1003.1-2001 defines the global variable  <i>environ</i>, which is also provided by historical implementations and can be used anywhere that  <i>envp</i> could be used, there is no functional need for the  <i>envp</i> argument. Applications should use the  <i>getenv</i>() function rather than accessing the environment directly via either  <i>envp</i> or <i>environ</i>. Implementations are required to support the two-argument calling sequence, but this does not prohibit an implementation from supporting  <i>envp</i> as an optional third argument.<div class="spacer">
</div>
This volume of IEEE&#160;Std&#160;1003.1-2001 specifies that signals set to SIG_IGN remain set to SIG_IGN, and that the process signal mask be unchanged across an  <i>exec</i>. This is consistent with historical implementations, and it permits some useful functionality, such as the  <i>nohup</i> command. However, it should be noted that many existing applications wrongly assume that they start with certain signals set to the default action and/or unblocked. In particular, applications written with a simpler signal model that does not include blocking of signals, such as the one in the ISO&#160;C standard, may not behave properly if invoked with some signals blocked. Therefore, it is best not to block or ignore signals across  <i>exec</i>s without explicit reason to do so, and especially not to block signals across  <i>exec</i>s of arbitrary (not closely co-operating) programs.<div class="spacer">
</div>
The <i>exec</i> functions always save the value of the effective user ID and effective group ID of the process at the completion of the  <i>exec</i>, whether or not the set-user-ID or the set-group-ID bit of the process image file is set.<div class="spacer">
</div>
The statement about <i>argv</i>[] and <i>envp</i>[] being constants is included to make explicit to future writers of language bindings that these objects are completely constant. Due to a limitation of the ISO&#160;C standard, it is not possible to state that idea in standard C. Specifying two levels of  <i>const</i>- <i>qualification</i> for the  <i>argv</i>[] and <i>envp</i>[] parameters for the  <i>exec</i> functions may seem to be the natural choice, given that these functions do not modify either the array of pointers or the characters to which the function points, but this would disallow existing correct code. Instead, only the array of pointers is noted as constant. The table of assignment compatibility for  <i>dst</i>= <i>src</i> derived from the ISO&#160;C standard summarizes the compatibility:<table class="tbl">
<col style="width: 25.00ex;"/>
<col style="width: 14.00ex;"/>
<col style="width: 20.00ex;"/>
<col style="width: 19.00ex;"/>
<col style="width: 25.00ex;"/>
<tbody>
<tr>
<td>
<i>dst</i>:</td>
<td>
<b>char *[]</b></td>
<td>
<b>const char *[]</b></td>
<td>
<b>char *const[]</b></td>
<td>
<b>const char *const[]</b></td>
</tr>
<tr>
<td>
<b></b><i>src</i><b>:</b><i></i></td>
<td>
<i>&#160;</i></td>
<td>
<i>&#160;</i></td>
<td>
<i>&#160;</i></td>
<td>
<i>&#160;</i></td>
</tr>
<tr>
<td>
<i></i><b>char *[]</b><i></i></td>
<td>
<i>VALID</i></td>
<td>
<i>-</i></td>
<td>
<i>VALID</i></td>
<td>
<i>-</i></td>
</tr>
<tr>
<td>
<i></i><b>const char *[]</b><i></i></td>
<td>
<i>-</i></td>
<td>
<i>VALID</i></td>
<td>
<i>-</i></td>
<td>
<i>VALID</i></td>
</tr>
<tr>
<td>
<i></i><b>char * const []</b><i></i></td>
<td>
<i>-</i></td>
<td>
<i>-</i></td>
<td>
<i>VALID</i></td>
<td>
<i>-</i></td>
</tr>
<tr>
<td>
<i></i><b>const char *const[]</b><i></i></td>
<td>
<i>-</i></td>
<td>
<i>-</i></td>
<td>
<i>-</i></td>
<td>
<i>VALID</i></td>
</tr>
</tbody>
</table>
<div class="spacer">
</div>
Since all existing code has a source type matching the first row, the column that gives the most valid combinations is the third column. The only other possibility is the fourth column, but using it would require a cast on the  <i>argv</i> or <i>envp</i> arguments. It is unfortunate that the fourth column cannot be used, because the declaration a non-expert would naturally use would be that in the second row.<div class="spacer">
</div>
The ISO&#160;C standard and this volume of IEEE&#160;Std&#160;1003.1-2001 do not conflict on the use of  <i>environ</i>, but some historical implementations of  <i>environ</i> may cause a conflict. As long as  <i>environ</i> is treated in the same way as an entry point (for example,  <i>fork</i>()), it conforms to both standards. A library can contain  <i>fork</i>(), but if there is a user-provided  <i>fork</i>(), that <i>fork</i>() is given precedence and no problem ensues. The situation is similar for  <i>environ</i>: the definition in this volume of IEEE&#160;Std&#160;1003.1-2001 is to be used if there is no user-provided  <i>environ</i> to take precedence. At least three implementations are known to exist that solve this problem.<dl>
<dt>
<b>E2BIG</b></dt>
<dd>
The limit {ARG_MAX} applies not just to the size of the argument list, but to the sum of that and the size of the environment list.</dd>
</dl>
<dl>
<dt>
<b>EFAULT</b></dt>
<dd>
Some historical systems return [EFAULT] rather than [ENOEXEC] when the new process image file is corrupted. They are non-conforming.</dd>
</dl>
<dl>
<dt>
<b>EINVAL</b></dt>
<dd>
This error condition was added to IEEE&#160;Std&#160;1003.1-2001 to allow an implementation to detect executable files generated for different architectures, and indicate this situation to the application. Historical implementations of shells,  <i>execvp</i>(), and <i>execlp</i>() that encounter an [ENOEXEC] error will execute a shell on the assumption that the file is a shell script. This will not produce the desired effect when the file is a valid executable for a different architecture. An implementation may now choose to avoid this problem by returning [EINVAL] when a valid executable for a different architecture is encountered. Some historical implementations return [EINVAL] to indicate that the  <i>path</i> argument contains a character with the high order bit set. The standard developers chose to deviate from historical practice for the following reasons:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl>
<dt>
 1.</dt>
<dd>
The new utilization of [EINVAL] will provide some measure of utility to the user community.</dd>
</dl>
<dl>
<dt>
 2.</dt>
<dd>
Historical use of [EINVAL] is not acceptable in an internationalized operating environment.</dd>
</dl>
</div>
<dl>
<dt>
<b>ENAMETOOLONG</b></dt>
<dd>
Since the file pathname may be constructed by taking elements in the  <i>PATH</i> variable and putting them together with the filename, the [ENAMETOOLONG] error condition could also be reached this way.</dd>
</dl>
<dl>
<dt>
<b>ETXTBSY</b></dt>
<dd>
System V returns this error when the executable file is currently open for writing by some process. This volume of IEEE&#160;Std&#160;1003.1-2001 neither requires nor prohibits this behavior.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<div class="spacer">
</div>
Other systems (such as System V) may return [EINTR] from <i>exec</i>. This is not addressed by this volume of IEEE&#160;Std&#160;1003.1-2001, but implementations may have a window between the call to  <i>exec</i> and the time that a signal could cause one of the  <i>exec</i> calls to return with [EINTR].<div class="spacer">
</div>
An explicit statement regarding the floating-point environment (as defined in the  <i>&lt;fenv.h&gt;</i> header) was added to make it clear that the floating-point environment is set to its default when a call to one of the  <i>exec</i> functions succeeds. The requirements for inheritance or setting to the default for other process and thread start-up functions is covered by more generic statements in their descriptions and can be summarized as follows:<dl>
<dt>
<i>posix_spawn</i>()</dt>
<dd>
Set to default.</dd>
</dl>
<dl>
<dt>
<i>fork</i>()</dt>
<dd>
Inherit.</dd>
</dl>
<dl>
<dt>
<i>pthread_create</i>()</dt>
<dd>
Inherit.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
</div>
<div class="section">
<h1>FUTURE DIRECTIONS</h1> None.</div>
<div class="section">
<h1>SEE ALSO</h1>  <i>alarm</i>(), <i>atexit</i>(), <i>chmod</i>(),  <i>close</i>(), <i>exit</i>(), <i>fcntl</i>(), <i>fork</i>(), <i>fstatvfs</i>(),  <i>getenv</i>(), <i>getitimer</i>(), <i>getrlimit</i>(), <i>mmap</i>(),  <i>nice</i>(), <i>posix_spawn</i>(), <i>posix_trace_eventid_open</i>(),  <i>posix_trace_shutdown</i>(), <i>posix_trace_trid_eventid_open</i>(),  <i>putenv</i>(), <i>semop</i>(), <i>setlocale</i>(), <i>shmat</i>() ,  <i>sigaction</i>(), <i>sigaltstack</i>(), <i>sigpending</i>(), <i>sigprocmask</i>(),  <i>system</i>(), <i>times</i>(), <i>ulimit</i>(), <i>umask</i>(), the Base Definitions volume of IEEE&#160;Std&#160;1003.1-2001, Chapter 11, General Terminal Interface,  <i>&lt;unistd.h&gt;</i></div>
<div class="section">
<h1>COPYRIGHT</h1> Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1, 2003 Edition, Standard for Information Technology -- Portable Operating System Interface (POSIX), The Open Group Base Specifications Issue 6, Copyright (C) 2001-2003 by the Institute of Electrical and Electronics Engineers, Inc and The Open Group. In the event of any discrepancy between this version and the original IEEE and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document. The original Standard can be obtained online at http://www.opengroup.org/unix/online.html .</div>
<table class="foot">
<tr>
<td class="foot-date">
2003</td>
<td class="foot-os">
IEEE/The Open Group</td>
</tr>
</table>
</div>
</body>
</html>

