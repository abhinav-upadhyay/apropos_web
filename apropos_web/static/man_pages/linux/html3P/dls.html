<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
DLSYM(3P)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
DLSYM(3P)</td>
<td class="head-vol">
POSIX Programmer's Manual</td>
<td class="head-rtitle">
DLSYM(3P)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>PROLOG</h1> This manual page is part of the POSIX Programmer's Manual. The Linux implementation of this interface may differ (consult the corresponding Linux manual page for details of Linux behavior), or the interface may not be implemented on Linux.</div>
<div class="section">
<h1>NAME</h1> dlsym - obtain the address of a symbol from a dlopen object</div>
<div class="section">
<h1>SYNOPSIS</h1>  <b>#include &lt;dlfcn.h&gt;</b><div style="height: 0.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
void *dlsym(void *restrict<b> </b><i>handle</i><b></b><b>, const char *restrict</b><b></b>  <b></b><i>name</i><b></b><b>); </b><b></b>  <b></b><b></b><div style="height: 0.00em;">
&#160;</div>
<b></b></div>
<div class="section">
<h1>DESCRIPTION</h1> The  <i>dlsym</i>() function shall obtain the address of a symbol defined within an object made accessible through a  <i>dlopen</i>() call. The  <i>handle</i> argument is the value returned from a call to <i>dlopen</i>() (and which has not since been released via a call to  <i>dlclose</i>()), and  <i>name</i> is the symbol's name as a character string.<div class="spacer">
</div>
The <i>dlsym</i>() function shall search for the named symbol in all objects loaded automatically as a result of loading the object referenced by  <i>handle</i> (see <i>dlopen</i>()). Load ordering is used in  <i>dlsym</i>() operations upon the global symbol object. The symbol resolution algorithm used shall be dependency order as described in  <i>dlopen</i>().<div class="spacer">
</div>
The RTLD_DEFAULT and RTLD_NEXT flags are reserved for future use.</div>
<div class="section">
<h1>RETURN VALUE</h1> If  <i>handle</i> does not refer to a valid object opened by <i>dlopen</i>(), or if the named symbol cannot be found within any of the objects associated with  <i>handle</i>, <i>dlsym</i>() shall return NULL. More detailed diagnostic information shall be available through  <i>dlerror</i>() .</div>
<div class="section">
<h1>ERRORS</h1> No errors are defined.<div class="spacer">
</div>
<i>The following sections are informative.</i></div>
<div class="section">
<h1>EXAMPLES</h1> The following example shows how  <i>dlopen</i>() and <i>dlsym</i>() can be used to access either function or data objects. For simplicity, error checking has been omitted.<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>void    *handle;</b><br/>
<b>int     *iptr, (*fptr)(int);</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
/* open the needed object */<br/>
handle = dlopen(&quot;/usr/home/me/libfoo.so&quot;, RTLD_LOCAL | RTLD_LAZY);<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
/* find the address of function and data objects */<br/>
*(void **)(&amp;fptr) = dlsym(handle, &quot;my_function&quot;);<br/>
iptr = (int *)dlsym(handle, &quot;my_object&quot;);<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<br/>
/* invoke function, passing value of integer as a parameter */<br/>
(*fptr)(*iptr);<br/>
<b></b><br/>
</div>
</div>
<div class="section">
<h1>APPLICATION USAGE</h1> Special purpose values for  <i>handle</i> are reserved for future use. These values and their meanings are:<dl>
<dt>
RTLD_DEFAULT</dt>
<dd>
The symbol lookup happens in the normal global scope; that is, a search for a symbol using this handle would find the same definition as a direct use of this symbol in the program code.</dd>
</dl>
<dl>
<dt>
RTLD_NEXT</dt>
<dd>
Specifies the next object after this one that defines <i>name</i>.  <i>This one</i> refers to the object containing the invocation of  <i>dlsym</i>(). The <i>next</i> object is the one found upon the application of a load order symbol resolution algorithm (see  <i>dlopen</i>()). The next object is either one of global scope (because it was introduced as part of the original process image or because it was added with a  <i>dlopen</i>() operation including the RTLD_GLOBAL flag), or is an object that was included in the same  <i>dlopen</i>() operation that loaded this one.</dd>
</dl>
<div class="spacer">
</div>
The RTLD_NEXT flag is useful to navigate an intentionally created hierarchy of multiply-defined symbols created through  <i>interposition</i>. For example, if a program wished to create an implementation of  <i>malloc</i>() that embedded some statistics gathering about memory allocations, such an implementation could use the real  <i>malloc</i>() definition to perform the memory allocation-and itself only embed the necessary logic to implement the statistics gathering function.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>RATIONALE</h1> The ISO&#160;C standard does not require that pointers to functions can be cast back and forth to pointers to data. Indeed, the ISO&#160;C standard does not require that an object of type  <b>void *</b> can hold a pointer to a function. Implementations supporting the XSI extension, however, do require that an object of type  <b>void *</b> can hold a pointer to a function. The result of converting a pointer to a function into a pointer to another data type (except  <b>void *</b>) is still undefined, however. Note that compilers conforming to the ISO&#160;C standard are required to generate a warning if a conversion from a  <b>void *</b> pointer to a function pointer is attempted as in:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<div class="spacer">
</div>
<br/>
<b>fptr = (int (*)(int))dlsym(handle, &quot;my_function&quot;);</b><br/>
<b></b><br/>
</div>
<div class="spacer">
</div>
Due to the problem noted here, a future version may either add a new function to return function pointers, or the current interface may be deprecated in favor of two new functions: one that returns data pointers and the other that returns function pointers.</div>
<div class="section">
<h1>FUTURE DIRECTIONS</h1> None.</div>
<div class="section">
<h1>SEE ALSO</h1>  <i>dlclose</i>(), <i>dlerror</i>(), <i>dlopen</i>(), the Base Definitions volume of IEEE&#160;Std&#160;1003.1-2001,  <i>&lt;dlfcn.h&gt;</i></div>
<div class="section">
<h1>COPYRIGHT</h1> Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1, 2003 Edition, Standard for Information Technology -- Portable Operating System Interface (POSIX), The Open Group Base Specifications Issue 6, Copyright (C) 2001-2003 by the Institute of Electrical and Electronics Engineers, Inc and The Open Group. In the event of any discrepancy between this version and the original IEEE and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document. The original Standard can be obtained online at http://www.opengroup.org/unix/online.html .</div>
<table class="foot">
<tr>
<td class="foot-date">
2003</td>
<td class="foot-os">
IEEE/The Open Group</td>
</tr>
</table>
</div>
</body>
</html>

