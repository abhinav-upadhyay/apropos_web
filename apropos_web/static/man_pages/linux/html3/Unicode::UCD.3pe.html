<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Unicode::UCD(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Unicode::UCD(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
Unicode::UCD(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Unicode::UCD - Unicode character database</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
    use Unicode::UCD 'charinfo';<br/>
    my $charinfo   = charinfo($codepoint);<br/>
<br/>
    use Unicode::UCD 'casefold';<br/>
    my $casefold = casefold(0xFB00);<br/>
<br/>
    use Unicode::UCD 'casespec';<br/>
    my $casespec = casespec(0xFB00);<br/>
<br/>
    use Unicode::UCD 'charblock';<br/>
    my $charblock  = charblock($codepoint);<br/>
<br/>
    use Unicode::UCD 'charscript';<br/>
    my $charscript = charscript($codepoint);<br/>
<br/>
    use Unicode::UCD 'charblocks';<br/>
    my $charblocks = charblocks();<br/>
<br/>
    use Unicode::UCD 'charscripts';<br/>
    my $charscripts = charscripts();<br/>
<br/>
    use Unicode::UCD qw(charscript charinrange);<br/>
    my $range = charscript($script);<br/>
    print &quot;looks like $script\n&quot; if charinrange($range, $codepoint);<br/>
<br/>
    use Unicode::UCD qw(general_categories bidi_types);<br/>
    my $categories = general_categories();<br/>
    my $types = bidi_types();<br/>
<br/>
    use Unicode::UCD 'compexcl';<br/>
    my $compexcl = compexcl($codepoint);<br/>
<br/>
    use Unicode::UCD 'namedseq';<br/>
    my $namedseq = namedseq($named_sequence_name);<br/>
<br/>
    my $unicode_version = Unicode::UCD::UnicodeVersion();<br/>
<br/>
    my $convert_to_numeric =<br/>
                Unicode::UCD::num(&quot;\N{RUMI DIGIT ONE}\N{RUMI DIGIT TWO}&quot;);<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> The Unicode::UCD module offers a series of functions that provide a simple interface to the Unicode Character Database.<div class="subsection">
<h2>code point argument</h2> Some of the functions are called with a  <i>code point argument</i>, which is either a decimal or a hexadecimal scalar designating a Unicode code point, or &quot;U+&quot; followed by hexadecimals designating a Unicode code point.  In other words, if you want a code point to be interpreted as a hexadecimal number, you must prefix it with either &quot;0x&quot; or &quot;U+&quot;, because a string like e.g. 123 will be interpreted as a decimal code point.  Note that the largest code point in Unicode is U+10FFFF.</div>
<div class="subsection">
<h2><b></b><b><i>charinfo()</i></b><b></b></h2><br/>
    use Unicode::UCD 'charinfo';<br/>
<br/>
    my $charinfo = charinfo(0x41);<br/>
<div class="spacer">
</div>
This returns information about the input &quot;code point argument&quot; as a reference to a hash of fields as defined by the Unicode standard.  If the &quot;code point argument&quot; is not assigned in the standard (i.e., has the general category &quot;Cn&quot; meaning &quot;Unassigned&quot;) or is a non-character (meaning it is guaranteed to never be assigned in the standard),  <b>undef</b> is returned.<div class="spacer">
</div>
Fields that aren't applicable to the particular code point argument exist in the returned hash, and are empty.<div class="spacer">
</div>
The keys in the hash with the meanings of their values are:<dl>
<dt>
<b>code</b></dt>
<dd>
the input &quot;code point argument&quot; expressed in hexadecimal, with leading zeros added if necessary to make it contain at least four hexdigits</dd>
</dl>
<dl>
<dt>
<b>name</b></dt>
<dd>
name of <i>code</i>, all IN UPPER CASE. Some control-type code points do not have names. This field will be empty for &quot;Surrogate&quot; and &quot;Private Use&quot; code points, and for the others without a name, it will contain a description enclosed in angle brackets, like &quot;&lt;control&gt;&quot;.</dd>
</dl>
<dl>
<dt>
<b>category</b></dt>
<dd>
The short name of the general category of <i>code</i>. This will match one of the keys in the hash returned by &quot; <i>general_categories()</i>&quot;.</dd>
</dl>
<dl>
<dt>
<b>combining</b></dt>
<dd>
the combining class number for <i>code</i> used in the Canonical Ordering Algorithm. For Unicode 5.1, this is described in Section 3.11 &quot;Canonical Ordering Behavior&quot; available at &lt;http://www.unicode.org/versions/Unicode5.1.0/&gt;</dd>
</dl>
<dl>
<dt>
<b>bidi</b></dt>
<dd>
bidirectional type of <i>code</i>. This will match one of the keys in the hash returned by &quot; <i>bidi_types()</i>&quot;.</dd>
</dl>
<dl>
<dt>
<b>decomposition</b></dt>
<dd>
is empty if <i>code</i> has no decomposition; or is one or more codes (separated by spaces) that taken in order represent a decomposition for  <i>code</i>.  Each has at least four hexdigits. The codes may be preceded by a word enclosed in angle brackets then a space, like &quot;&lt;compat&gt; &quot;, giving the type of decomposition<div style="height: 1.00em;">
&#160;</div>
This decomposition may be an intermediate one whose components are also decomposable.  Use Unicode::Normalize to get the final decomposition.</dd>
</dl>
<dl>
<dt>
<b>decimal</b></dt>
<dd>
if <i>code</i> is a decimal digit this is its integer numeric value</dd>
</dl>
<dl>
<dt>
<b>digit</b></dt>
<dd>
if <i>code</i> represents some other digit-like number, this is its integer numeric value</dd>
</dl>
<dl>
<dt>
<b>numeric</b></dt>
<dd>
if <i>code</i> represents a whole or rational number, this is its numeric value. Rational values are expressed as a string like &quot;1/4&quot;.</dd>
</dl>
<dl>
<dt>
<b>mirrored</b></dt>
<dd>
&quot;Y&quot; or &quot;N&quot; designating if <i>code</i> is mirrored in bidirectional text</dd>
</dl>
<dl>
<dt>
<b>unicode10</b></dt>
<dd>
name of <i>code</i> in the Unicode 1.0 standard if one existed for this code point and is different from the current name</dd>
</dl>
<dl>
<dt>
<b>comment</b></dt>
<dd>
As of Unicode 6.0, this is always empty.</dd>
</dl>
<dl>
<dt>
<b>upper</b></dt>
<dd>
is empty if there is no single code point uppercase mapping for <i>code</i> (its uppercase mapping is itself); otherwise it is that mapping expressed as at least four hexdigits. (&quot; <i>casespec()</i>&quot; should be used in addition to <b></b><b><i>charinfo()</i></b><b></b> for case mappings when the calling program can cope with multiple code point mappings.)</dd>
</dl>
<dl>
<dt>
<b>lower</b></dt>
<dd>
is empty if there is no single code point lowercase mapping for <i>code</i> (its lowercase mapping is itself); otherwise it is that mapping expressed as at least four hexdigits. (&quot; <i>casespec()</i>&quot; should be used in addition to <b></b><b><i>charinfo()</i></b><b></b> for case mappings when the calling program can cope with multiple code point mappings.)</dd>
</dl>
<dl>
<dt>
<b>title</b></dt>
<dd>
is empty if there is no single code point titlecase mapping for <i>code</i> (its titlecase mapping is itself); otherwise it is that mapping expressed as at least four hexdigits. (&quot; <i>casespec()</i>&quot; should be used in addition to <b></b><b><i>charinfo()</i></b><b></b> for case mappings when the calling program can cope with multiple code point mappings.)</dd>
</dl>
<dl>
<dt>
<b>block</b></dt>
<dd>
block <i>code</i> belongs to (used in &quot;\p{Blk=...}&quot;). See &quot;Blocks versus Scripts&quot;.</dd>
</dl>
<dl>
<dt>
<b>script</b></dt>
<dd>
script <i>code</i> belongs to. See &quot;Blocks versus Scripts&quot;.</dd>
</dl>
<div class="spacer">
</div>
Note that you cannot do (de)composition and casing based solely on the  <i>decomposition</i>, <i>combining</i>, <i>lower</i>, <i>upper</i>, and <i>title</i> fields; you will need also the &quot; <i>compexcl()</i>&quot;, and &quot;<i>casespec()</i>&quot; functions.</div>
<div class="subsection">
<h2><b></b><b><i>charblock()</i></b><b></b></h2><br/>
    use Unicode::UCD 'charblock';<br/>
<br/>
    my $charblock = charblock(0x41);<br/>
    my $charblock = charblock(1234);<br/>
    my $charblock = charblock(0x263a);<br/>
    my $charblock = charblock(&quot;U+263a&quot;);<br/>
<br/>
    my $range     = charblock('Armenian');<br/>
<div class="spacer">
</div>
With a &quot;code point argument&quot; <i>charblock()</i> returns the <i>block</i> the code point belongs to, e.g.  &quot;Basic Latin&quot;. If the code point is unassigned, this returns the block it would belong to if it were assigned (which it may in future versions of the Unicode Standard).<div class="spacer">
</div>
See also &quot;Blocks versus Scripts&quot;.<div class="spacer">
</div>
If supplied with an argument that can't be a code point, <i>charblock()</i> tries to do the opposite and interpret the argument as a code point block. The return value is a  <i>range</i>: an anonymous list of lists that contain  <i>start-of-range</i>, <i>end-of-range</i> code point pairs. You can test whether a code point is in a range using the &quot; <i>charinrange()</i>&quot; function. If the argument is not a known code point block,  <b>undef</b> is returned.</div>
<div class="subsection">
<h2><b></b><b><i>charscript()</i></b><b></b></h2><br/>
    use Unicode::UCD 'charscript';<br/>
<br/>
    my $charscript = charscript(0x41);<br/>
    my $charscript = charscript(1234);<br/>
    my $charscript = charscript(&quot;U+263a&quot;);<br/>
<br/>
    my $range      = charscript('Thai');<br/>
<div class="spacer">
</div>
With a &quot;code point argument&quot; <i>charscript()</i> returns the <i>script</i> the code point belongs to, e.g.  &quot;Latin&quot;, &quot;Greek&quot;, &quot;Han&quot;. If the code point is unassigned, it returns  <b>undef</b><div class="spacer">
</div>
If supplied with an argument that can't be a code point, <i>charscript()</i> tries to do the opposite and interpret the argument as a code point script. The return value is a  <i>range</i>: an anonymous list of lists that contain  <i>start-of-range</i>, <i>end-of-range</i> code point pairs. You can test whether a code point is in a range using the &quot; <i>charinrange()</i>&quot; function. If the argument is not a known code point script,  <b>undef</b> is returned.<div class="spacer">
</div>
See also &quot;Blocks versus Scripts&quot;.</div>
<div class="subsection">
<h2><b></b><b><i>charblocks()</i></b><b></b></h2><br/>
    use Unicode::UCD 'charblocks';<br/>
<br/>
    my $charblocks = charblocks();<br/>
<div class="spacer">
</div>
<i>charblocks()</i> returns a reference to a hash with the known block names as the keys, and the code point ranges (see &quot; <i>charblock()</i>&quot;) as the values.<div class="spacer">
</div>
See also &quot;Blocks versus Scripts&quot;.</div>
<div class="subsection">
<h2><b></b><b><i>charscripts()</i></b><b></b></h2><br/>
    use Unicode::UCD 'charscripts';<br/>
<br/>
    my $charscripts = charscripts();<br/>
<div class="spacer">
</div>
<i>charscripts()</i> returns a reference to a hash with the known script names as the keys, and the code point ranges (see &quot; <i>charscript()</i>&quot;) as the values.<div class="spacer">
</div>
See also &quot;Blocks versus Scripts&quot;.</div>
<div class="subsection">
<h2><b></b><b><i>charinrange()</i></b><b></b></h2> In addition to using the &quot;\p{Blk=...}&quot; and &quot;\P{Blk=...}&quot; constructs, you can also test whether a code point is in the  <i>range</i> as returned by &quot; <i>charblock()</i>&quot; and &quot;<i>charscript()</i>&quot; or as the values of the hash returned by &quot; <i>charblocks()</i>&quot; and &quot;<i>charscripts()</i>&quot; by using <i>charinrange()</i>:<div class="spacer">
</div>
<br/>
    use Unicode::UCD qw(charscript charinrange);<br/>
<br/>
    $range = charscript('Hiragana');<br/>
    print &quot;looks like hiragana\n&quot; if charinrange($range, $codepoint);<br/>
</div>
<div class="subsection">
<h2><b></b><b><i>general_categories()</i></b><b></b></h2><br/>
    use Unicode::UCD 'general_categories';<br/>
<br/>
    my $categories = general_categories();<br/>
<div class="spacer">
</div>
This returns a reference to a hash which has short general category names (such as &quot;Lu&quot;, &quot;Nd&quot;, &quot;Zs&quot;, &quot;S&quot;) as keys and long names (such as &quot;UppercaseLetter&quot;, &quot;DecimalNumber&quot;, &quot;SpaceSeparator&quot;, &quot;Symbol&quot;) as values.  The hash is reversible in case you need to go from the long names to the short names.  The general category is the one returned from &quot; <i>charinfo()</i>&quot; under the &quot;category&quot; key.</div>
<div class="subsection">
<h2><b></b><b><i>bidi_types()</i></b><b></b></h2><br/>
    use Unicode::UCD 'bidi_types';<br/>
<br/>
    my $categories = bidi_types();<br/>
<div class="spacer">
</div>
This returns a reference to a hash which has the short bidi (bidirectional) type names (such as &quot;L&quot;, &quot;R&quot;) as keys and long names (such as &quot;Left-to-Right&quot;, &quot;Right-to-Left&quot;) as values.  The hash is reversible in case you need to go from the long names to the short names.  The bidi type is the one returned from &quot; <i>charinfo()</i>&quot; under the &quot;bidi&quot; key.  For the exact meaning of the various bidi classes the Unicode TR9 is recommended reading: &lt;http://www.unicode.org/reports/tr9/&gt; (as of Unicode 5.0.0)</div>
<div class="subsection">
<h2><b></b><b><i>compexcl()</i></b><b></b></h2><br/>
    use Unicode::UCD 'compexcl';<br/>
<br/>
    my $compexcl = compexcl(0x09dc);<br/>
<div class="spacer">
</div>
This routine is included for backwards compatibility, but as of Perl 5.12, for most purposes it is probably more convenient to use one of the following instead:<div class="spacer">
</div>
<br/>
    my $compexcl = chr(0x09dc) =~ /\p{Comp_Ex};<br/>
    my $compexcl = chr(0x09dc) =~ /\p{Full_Composition_Exclusion};<br/>
<div class="spacer">
</div>
or even<div class="spacer">
</div>
<br/>
    my $compexcl = chr(0x09dc) =~ /\p{CE};<br/>
    my $compexcl = chr(0x09dc) =~ /\p{Composition_Exclusion};<br/>
<div class="spacer">
</div>
The first two forms return <b>true</b> if the &quot;code point argument&quot; should not be produced by composition normalization.  The final two forms additionally require that this fact not otherwise be determinable from the Unicode data base for them to return  <b>true</b>.<div class="spacer">
</div>
This routine behaves identically to the final two forms.  That is, it does not return  <b>true</b> if the code point has a decomposition consisting of another single code point, nor if its decomposition starts with a code point whose combining class is non-zero.  Code points that meet either of these conditions should also not be produced by composition normalization, which is probably why you should use the &quot;Full_Composition_Exclusion&quot; property instead, as shown above.<div class="spacer">
</div>
The routine returns <b>false</b> otherwise.</div>
<div class="subsection">
<h2><b></b><b><i>casefold()</i></b><b></b></h2><br/>
    use Unicode::UCD 'casefold';<br/>
<br/>
    my $casefold = casefold(0xDF);<br/>
    if (defined $casefold) {<br/>
        my @full_fold_hex = split / /, $casefold-&gt;{'full'};<br/>
        my $full_fold_string =<br/>
                    join &quot;&quot;, map {chr(hex($_))} @full_fold_hex;<br/>
        my @turkic_fold_hex =<br/>
                        split / /, ($casefold-&gt;{'turkic'} ne &quot;&quot;)<br/>
                                        ? $casefold-&gt;{'turkic'}<br/>
                                        : $casefold-&gt;{'full'};<br/>
        my $turkic_fold_string =<br/>
                        join &quot;&quot;, map {chr(hex($_))} @turkic_fold_hex;<br/>
    }<br/>
    if (defined $casefold &amp;&amp; $casefold-&gt;{'simple'} ne &quot;&quot;) {<br/>
        my $simple_fold_hex = $casefold-&gt;{'simple'};<br/>
        my $simple_fold_string = chr(hex($simple_fold_hex));<br/>
    }<br/>
<div class="spacer">
</div>
This returns the (almost) locale-independent case folding of the character specified by the &quot;code point argument&quot;.<div class="spacer">
</div>
If there is no case folding for that code point, <b>undef</b> is returned.<div class="spacer">
</div>
If there is a case folding for that code point, a reference to a hash with the following fields is returned:<dl>
<dt>
<b>code</b></dt>
<dd>
the input &quot;code point argument&quot; expressed in hexadecimal, with leading zeros added if necessary to make it contain at least four hexdigits</dd>
</dl>
<dl>
<dt>
<b>full</b></dt>
<dd>
one or more codes (separated by spaces) that taken in order give the code points for the case folding for  <i>code</i>. Each has at least four hexdigits.</dd>
</dl>
<dl>
<dt>
<b>simple</b></dt>
<dd>
is empty, or is exactly one code with at least four hexdigits which can be used as an alternative case folding when the calling program cannot cope with the fold being a sequence of multiple code points.  If  <i>full</i> is just one code point, then  <i>simple</i> equals <i>full</i>.  If there is no single code point folding defined for  <i>code</i>, then <i>simple</i> is the empty string.  Otherwise, it is an inferior, but still better-than-nothing alternative folding to  <i>full</i>.</dd>
</dl>
<dl>
<dt>
<b>mapping</b></dt>
<dd>
is the same as <i>simple</i> if <i>simple</i> is not empty, and it is the same as <i>full</i> otherwise.  It can be considered to be the simplest possible folding for  <i>code</i>.  It is defined primarily for backwards compatibility.</dd>
</dl>
<dl>
<dt>
<b>status</b></dt>
<dd>
is &quot;C&quot; (for &quot;common&quot;) if the best possible fold is a single code point ( <i>simple</i> equals <i>full</i> equals <i>mapping</i>).  It is &quot;S&quot; if there are distinct folds,  <i>simple</i> and <i>full</i> (<i>mapping</i> equals <i>simple</i>).  And it is &quot;F&quot; if there only a  <i>full</i> fold (<i>mapping</i> equals <i>full</i>; <i>simple</i> is empty).  Note that this describes the contents of  <i>mapping</i>.  It is defined primarily for backwards compatibility.<div style="height: 1.00em;">
&#160;</div>
On versions 3.1 and earlier of Unicode, <i>status</i> can also be &quot;I&quot; which is the same as &quot;C&quot; but is a special case for dotted uppercase I and dotless lowercase i:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
<b>*</b></dt>
<dd>
If you use this &quot;I&quot; mapping, the result is case-insensitive, but dotless and dotted I's are not distinguished</dd>
</dl>
<dl>
<dt>
<b>*</b></dt>
<dd>
If you exclude this &quot;I&quot; mapping, the result is not fully case-insensitive, but dotless and dotted I's are distinguished</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
</div>
<dl>
<dt>
<b>turkic</b></dt>
<dd>
contains any special folding for Turkic languages.  For versions of Unicode starting with 3.2, this field is empty unless  <i>code</i> has a different folding in Turkic languages, in which case it is one or more codes (separated by spaces) that taken in order give the code points for the case folding for  <i>code</i> in those languages. Each code has at least four hexdigits. Note that this folding does not maintain canonical equivalence without additional processing.<div style="height: 1.00em;">
&#160;</div>
For versions of Unicode 3.1 and earlier, this field is empty unless there is a special folding for Turkic languages, in which case  <i>status</i> is &quot;I&quot;, and  <i>mapping</i>, <i>full</i>, <i>simple</i>, and <i>turkic</i> are all equal.</dd>
</dl>
<div class="spacer">
</div>
Programs that want complete generality and the best folding results should use the folding contained in the  <i>full</i> field.  But note that the fold for some code points will be a sequence of multiple code points.<div class="spacer">
</div>
Programs that can't cope with the fold mapping being multiple code points can use the folding contained in the  <i>simple</i> field, with the loss of some generality.  In Unicode 5.1, about 7% of the defined foldings have no single code point folding.<div class="spacer">
</div>
The <i>mapping</i> and <i>status</i> fields are provided for backwards compatibility for existing programs.  They contain the same values as in previous versions of this function.<div class="spacer">
</div>
Locale is not completely independent.  The <i>turkic</i> field contains results to use when the locale is a Turkic language.<div class="spacer">
</div>
For more information about case mappings see &lt;http://www.unicode.org/unicode/reports/tr21&gt;</div>
<div class="subsection">
<h2><b></b><b><i>casespec()</i></b><b></b></h2><br/>
    use Unicode::UCD 'casespec';<br/>
<br/>
    my $casespec = casespec(0xFB00);<br/>
<div class="spacer">
</div>
This returns the potentially locale-dependent case mappings of the &quot;code point argument&quot;.  The mappings may be longer than a single code point (which the basic Unicode case mappings as returned by &quot; <i>charinfo()</i>&quot; never are).<div class="spacer">
</div>
If there are no case mappings for the &quot;code point argument&quot;, or if all three possible mappings ( <i>lower</i>, <i>title</i> and <i>upper</i>) result in single code points and are locale independent and unconditional,  <b>undef</b> is returned (which means that the case mappings, if any, for the code point are those returned by &quot; <i>charinfo()</i>&quot;).<div class="spacer">
</div>
Otherwise, a reference to a hash giving the mappings (or a reference to a hash of such hashes, explained below) is returned with the following keys and their meanings:<div class="spacer">
</div>
The keys in the bottom layer hash with the meanings of their values are:<dl>
<dt>
<b>code</b></dt>
<dd>
the input &quot;code point argument&quot; expressed in hexadecimal, with leading zeros added if necessary to make it contain at least four hexdigits</dd>
</dl>
<dl>
<dt>
<b>lower</b></dt>
<dd>
one or more codes (separated by spaces) that taken in order give the code points for the lower case of  <i>code</i>. Each has at least four hexdigits.</dd>
</dl>
<dl>
<dt>
<b>title</b></dt>
<dd>
one or more codes (separated by spaces) that taken in order give the code points for the title case of  <i>code</i>. Each has at least four hexdigits.</dd>
</dl>
<dl>
<dt>
<b>upper</b></dt>
<dd>
one or more codes (separated by spaces) that taken in order give the code points for the upper case of  <i>code</i>. Each has at least four hexdigits.</dd>
</dl>
<dl>
<dt>
<b>condition</b></dt>
<dd>
the conditions for the mappings to be valid. If  <b>undef</b>, the mappings are always valid. When defined, this field is a list of conditions, all of which must be true for the mappings to be valid. The list consists of one or more  <i>locales</i> (see below) and/or  <i>contexts</i> (explained in the next paragraph), separated by spaces. (Other than as used to separate elements, spaces are to be ignored.) Case distinctions in the condition list are not significant. Conditions preceded by &quot;NON_&quot; represent the negation of the condition.<div style="height: 1.00em;">
&#160;</div>
A <i>context</i> is one of those defined in the Unicode standard. For Unicode 5.1, they are defined in Section 3.13 &quot;Default Case Operations&quot; available at &lt;http://www.unicode.org/versions/Unicode5.1.0/&gt;. These are for context-sensitive casing.</dd>
</dl>
<div class="spacer">
</div>
The hash described above is returned for locale-independent casing, where at least one of the mappings has length longer than one.  If  <b>undef</b> is returned, the code point may have mappings, but if so, all are length one, and are returned by &quot; <i>charinfo()</i>&quot;. Note that when this function does return a value, it will be for the complete set of mappings for a code point, even those whose length is one.<div class="spacer">
</div>
If there are additional casing rules that apply only in certain locales, an additional key for each will be defined in the returned hash.  Each such key will be its locale name, defined as a 2-letter ISO 3166 country code, possibly followed by a &quot;_&quot; and a 2-letter ISO language code (possibly followed by a &quot;_&quot; and a variant code).  You can find the lists of all possible locales, see Locale::Country and Locale::Language. (In Unicode 6.0, the only locales returned by this function are &quot;lt&quot;, &quot;tr&quot;, and &quot;az&quot;.)<div class="spacer">
</div>
Each locale key is a reference to a hash that has the form above, and gives the casing rules for that particular locale, which take precedence over the locale-independent ones when in that locale.<div class="spacer">
</div>
If the only casing for a code point is locale-dependent, then the returned hash will not have any of the base keys, like &quot;code&quot;, &quot;upper&quot;, etc., but will contain only locale keys.<div class="spacer">
</div>
For more information about case mappings see &lt;http://www.unicode.org/unicode/reports/tr21/&gt;</div>
<div class="subsection">
<h2><b></b><b><i>namedseq()</i></b><b></b></h2><br/>
    use Unicode::UCD 'namedseq';<br/>
<br/>
    my $namedseq = namedseq(&quot;KATAKANA LETTER AINU P&quot;);<br/>
    my @namedseq = namedseq(&quot;KATAKANA LETTER AINU P&quot;);<br/>
    my %namedseq = namedseq();<br/>
<div class="spacer">
</div>
If used with a single argument in a scalar context, returns the string consisting of the code points of the named sequence, or  <b>undef</b> if no named sequence by that name exists.  If used with a single argument in a list context, it returns the list of the ordinals of the code points.  If used with no arguments in a list context, returns a hash with the names of the named sequences as the keys and the named sequences as strings as the values.  Otherwise, it returns  <b>undef</b> or an empty list depending on the context.<div class="spacer">
</div>
This function only operates on officially approved (not provisional) named sequences.<div class="spacer">
</div>
Note that as of Perl 5.14, &quot;\N{KATAKANA LETTER AINU P}&quot; will insert the named sequence into double-quoted strings, and &quot;charnames::string_vianame(&quot;KATAKANA LETTER AINU P&quot;)&quot; will return the same string this function does, but will also operate on character names that aren't named sequences, without you having to know which are which.  See charnames.</div>
<div class="subsection">
<h2>num</h2> &quot;num&quot; returns the numeric value of the input Unicode string; or &quot;undef&quot; if it doesn't think the entire string has a completely valid, safe numeric value.<div class="spacer">
</div>
If the string is just one character in length, the Unicode numeric value is returned if it has one, or &quot;undef&quot; otherwise.  Note that this need not be a whole number.  &quot;num(&quot;\N{TIBETAN DIGIT HALF ZERO}&quot;)&quot;, for example returns -0.5.<div class="spacer">
</div>
If the string is more than one character, &quot;undef&quot; is returned unless all its characters are decimal digits (that is they would match &quot;\d+&quot;), from the same script.  For example if you have an ASCII '0' and a Bengali '3', mixed together, they aren't considered a valid number, and &quot;undef&quot; is returned.  A further restriction is that the digits all have to be of the same form.  A half-width digit mixed with a full-width one will return &quot;undef&quot;.  The Arabic script has two sets of digits;  &quot;num&quot; will return &quot;undef&quot; unless all the digits in the string come from the same set.<div class="spacer">
</div>
&quot;num&quot; errs on the side of safety, and there may be valid strings of decimal digits that it doesn't recognize.  Note that Unicode defines a number of &quot;digit&quot; characters that aren't &quot;decimal digit&quot; characters. &quot;Decimal digits&quot; have the property that they have a positional value, i.e., there is a units position, a 10's position, a 100's, etc, AND they are arranged in Unicode in blocks of 10 contiguous code points.  The Chinese digits, for example, are not in such a contiguous block, and so Unicode doesn't view them as decimal digits, but merely digits, and so &quot;\d&quot; will not match them.  A single-character string containing one of these digits will have its decimal value returned by &quot;num&quot;, but any longer string containing only these digits will return &quot;undef&quot;.<div class="spacer">
</div>
Strings of multiple sub- and superscripts are not recognized as numbers.  You can use either of the compatibility decompositions in Unicode::Normalize to change these into digits, and then call &quot;num&quot; on the result.</div>
<div class="subsection">
<h2>Unicode::UCD::UnicodeVersion</h2> This returns the version of the Unicode Character Database, in other words, the version of the Unicode standard the database implements.  The version is a string of numbers delimited by dots ('.').</div>
<div class="subsection">
<h2><b>Blocks versus Scripts</b></h2> The difference between a block and a script is that scripts are closer to the linguistic notion of a set of code points required to present languages, while block is more of an artifact of the Unicode code point numbering and separation into blocks of (mostly) 256 code points.<div class="spacer">
</div>
For example the Latin <b>script</b> is spread over several <b>blocks</b>, such as &quot;Basic Latin&quot;, &quot;Latin 1 Supplement&quot;, &quot;Latin Extended-A&quot;, and &quot;Latin Extended-B&quot;.  On the other hand, the Latin script does not contain all the characters of the &quot;Basic Latin&quot; block (also known as ASCII): it includes only the letters, and not, for example, the digits or the punctuation.<div class="spacer">
</div>
For blocks see &lt;http://www.unicode.org/Public/UNIDATA/Blocks.txt&gt;<div class="spacer">
</div>
For scripts see UTR #24: &lt;http://www.unicode.org/unicode/reports/tr24/&gt;</div>
<div class="subsection">
<h2><b>Matching Scripts and Blocks</b></h2> Scripts are matched with the regular-expression construct &quot;\p{...}&quot; (e.g. &quot;\p{Tibetan}&quot; matches characters of the Tibetan script), while &quot;\p{Blk=...}&quot; is used for blocks (e.g. &quot;\p{Blk=Tibetan}&quot; matches any of the 256 code points in the Tibetan block).</div>
<div class="subsection">
<h2>Implementation Note</h2> The first use of  <i>charinfo()</i> opens a read-only filehandle to the Unicode Character Database (the database is included in the Perl distribution). The filehandle is then kept open for further queries.  In other words, if you are wondering where one of your filehandles went, that's where.</div>
</div>
<div class="section">
<h1>BUGS</h1> Does not yet support EBCDIC platforms.</div>
<div class="section">
<h1>AUTHOR</h1> Jarkko Hietaniemi</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-09-26</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

