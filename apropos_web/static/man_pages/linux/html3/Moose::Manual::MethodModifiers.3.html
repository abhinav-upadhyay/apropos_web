<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Moose::Manual::MethodModifiers(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Moose::Manual::MethodModifiers(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
Moose::Manual::MethodModifiers(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Moose::Manual::MethodModifiers - Moose's method modifiers</div>
<div class="section">
<h1>VERSION</h1> version 2.0401</div>
<div class="section">
<h1>WHAT IS A METHOD MODIFIER?</h1> Moose provides a feature called &quot;method modifiers&quot;. You can also think of these as &quot;hooks&quot; or &quot;advice&quot;.<div class="spacer">
</div>
It's probably easiest to understand this feature with a few examples:<div class="spacer">
</div>
<br/>
  package Example;<br/>
<br/>
  use Moose;<br/>
<br/>
  sub foo {<br/>
      print &quot;    foo\n&quot;;<br/>
  }<br/>
<br/>
  before 'foo' =&gt; sub { print &quot;about to call foo\n&quot;; };<br/>
  after 'foo'  =&gt; sub { print &quot;just called foo\n&quot;; };<br/>
<br/>
  around 'foo' =&gt; sub {<br/>
      my $orig = shift;<br/>
      my $self = shift;<br/>
<br/>
      print &quot;  I'm around foo\n&quot;;<br/>
<br/>
      $self-&gt;$orig(@_);<br/>
<br/>
      print &quot;  I'm still around foo\n&quot;;<br/>
  };<br/>
<div class="spacer">
</div>
Now if I call &quot;Example-&gt;new-&gt;foo&quot; I'll get the following output:<div class="spacer">
</div>
<br/>
  about to call foo<br/>
    I'm around foo<br/>
      foo<br/>
    I'm still around foo<br/>
  just called foo<br/>
<div class="spacer">
</div>
You probably could have figured that out from the names &quot;before&quot;, &quot;after&quot;, and &quot;around&quot;.<div class="spacer">
</div>
Also, as you can see, the before modifiers come before around modifiers, and after modifiers come last.<div class="spacer">
</div>
When there are multiple modifiers of the same type, the before and around modifiers run from the last added to the first, and after modifiers run from first added to last:<div class="spacer">
</div>
<br/>
   before 2<br/>
    before 1<br/>
     around 2<br/>
      around 1<br/>
       primary<br/>
      around 1<br/>
     around 2<br/>
    after 1<br/>
   after 2<br/>
</div>
<div class="section">
<h1>WHY USE THEM?</h1> Method modifiers have many uses. They are often used in roles to alter the behavior of methods in the classes that consume the role. See Moose::Manual::Roles for more information about roles.<div class="spacer">
</div>
Since modifiers are mostly useful in roles, some of the examples below are a bit artificial. They're intended to give you an idea of how modifiers work, but may not be the most natural usage.</div>
<div class="section">
<h1>BEFORE, AFTER, AND AROUND</h1> Method modifiers can be used to add behavior to methods without modifying the definition of those methods.<div class="subsection">
<h2>BEFORE and AFTER modifiers</h2> Method modifiers can be used to add behavior to a method that Moose generates for you, such as an attribute accessor:<div class="spacer">
</div>
<br/>
  has 'size' =&gt; ( is =&gt; 'rw' );<br/>
<br/>
  before 'size' =&gt; sub {<br/>
      my $self = shift;<br/>
<br/>
      if (@_) {<br/>
          Carp::cluck('Someone is setting size');<br/>
      }<br/>
  };<br/>
<div class="spacer">
</div>
Another use for the before modifier would be to do some sort of prechecking on a method call. For example:<div class="spacer">
</div>
<br/>
  before 'size' =&gt; sub {<br/>
      my $self = shift;<br/>
<br/>
      die 'Cannot set size while the person is growing'<br/>
          if @_ &amp;&amp; $self-&gt;is_growing;<br/>
  };<br/>
<div class="spacer">
</div>
This lets us implement logical checks that don't make sense as type constraints. In particular, they're useful for defining logical rules about an object's state changes.<div class="spacer">
</div>
Similarly, an after modifier could be used for logging an action that was taken.<div class="spacer">
</div>
Note that the return values of both before and after modifiers are ignored.</div>
<div class="subsection">
<h2>AROUND modifiers</h2> An around modifier is more powerful than either a before or after modifier. It can modify the arguments being passed to the original method, and you can even decide to simply not call the original method at all. You can also modify the return value with an around modifier.<div class="spacer">
</div>
An around modifier receives the original method as its first argument,  <i>then</i> the object, and finally any arguments passed to the method.<div class="spacer">
</div>
<br/>
  around 'size' =&gt; sub {<br/>
      my $orig = shift;<br/>
      my $self = shift;<br/>
<br/>
      return $self-&gt;$orig()<br/>
          unless @_;<br/>
<br/>
      my $size = shift;<br/>
      $size = $size / 2<br/>
          if $self-&gt;likes_small_things();<br/>
<br/>
      return $self-&gt;$orig($size);<br/>
  };<br/>
</div>
<div class="subsection">
<h2>Wrapping multiple methods at once</h2> &quot;before&quot;, &quot;after&quot;, and &quot;around&quot; can also modify multiple methods at once. The simplest example of this is passing them as a list:<div class="spacer">
</div>
<br/>
  before [qw(foo bar baz)] =&gt; sub {<br/>
      warn &quot;something is being called!&quot;;<br/>
  };<br/>
<div class="spacer">
</div>
This will add a &quot;before&quot; modifier to each of the &quot;foo&quot;, &quot;bar&quot;, and &quot;baz&quot; methods in the current class, just as though a separate call to &quot;before&quot; was made for each of them. The list can be passed either as a bare list, or as an arrayref. Note that the name of the function being modified isn't passed in in any way; this syntax is only intended for cases where the function being modified doesn't actually matter. If the function name does matter, use something like this:<div class="spacer">
</div>
<br/>
  for my $func (qw(foo bar baz)) {<br/>
      before $func =&gt; sub {<br/>
          warn &quot;$func was called!&quot;;<br/>
      };<br/>
  }<br/>
</div>
<div class="subsection">
<h2>Using regular expressions to select methods to wrap</h2> In addition, you can specify a regular expression to indicate the methods to wrap, like so:<div class="spacer">
</div>
<br/>
  after qr/^command_/ =&gt; sub {<br/>
      warn &quot;got a command&quot;;<br/>
  };<br/>
<div class="spacer">
</div>
This will match the regular expression against each method name returned by &quot;get_method_list&quot; in Class::MOP::Class, and add a modifier to each one that matches. The same caveats apply as above.<div class="spacer">
</div>
Using regular expressions to determine methods to wrap is quite a bit more powerful than the previous alternatives, but it's also quite a bit more dangerous.  Bear in mind that if your regular expression matches certain Perl and Moose reserved method names with a special meaning to Moose or Perl, such as &quot;meta&quot;, &quot;new&quot;, &quot;BUILD&quot;, &quot;DESTROY&quot;, &quot;AUTOLOAD&quot;, etc, this could cause unintended (and hard to debug) problems and is best avoided.</div>
</div>
<div class="section">
<h1>INNER AND AUGMENT</h1> Augment and inner are two halves of the same feature. The augment modifier provides a sort of inverted subclassing. You provide part of the implementation in a superclass, and then document that subclasses are expected to provide the rest.<div class="spacer">
</div>
The superclass calls &quot;inner()&quot;, which then calls the &quot;augment&quot; modifier in the subclass:<div class="spacer">
</div>
<br/>
  package Document;<br/>
<br/>
  use Moose;<br/>
<br/>
  sub as_xml {<br/>
      my $self = shift;<br/>
<br/>
      my $xml = &quot;&lt;document&gt;\n&quot;;<br/>
      $xml .= inner();<br/>
      $xml .= &quot;&lt;/document&gt;\n&quot;;<br/>
<br/>
      return $xml;<br/>
  }<br/>
<div class="spacer">
</div>
Using &quot;inner()&quot; in this method makes it possible for one or more subclasses to then augment this method with their own specific implementation:<div class="spacer">
</div>
<br/>
  package Report;<br/>
<br/>
  use Moose;<br/>
<br/>
  extends 'Document';<br/>
<br/>
  augment 'as_xml' =&gt; sub {<br/>
      my $self = shift;<br/>
<br/>
      my $xml = &quot;  &lt;report&gt;\n&quot;;<br/>
      $xml .= inner();<br/>
      $xml .= &quot;  &lt;/report&gt;\n&quot;;<br/>
<br/>
      return $xml;<br/>
  };<br/>
<div class="spacer">
</div>
When we call &quot;as_xml&quot; on a Report object, we get something like this:<div class="spacer">
</div>
<br/>
  &lt;document&gt;<br/>
    &lt;report&gt;<br/>
    &lt;/report&gt;<br/>
  &lt;/document&gt;<br/>
<div class="spacer">
</div>
But we also called &quot;inner()&quot; in &quot;Report&quot;, so we can continue subclassing and adding more content inside the document:<div class="spacer">
</div>
<br/>
  package Report::IncomeAndExpenses;<br/>
<br/>
  use Moose;<br/>
<br/>
  extends 'Report';<br/>
<br/>
  augment 'as_xml' =&gt; sub {<br/>
      my $self = shift;<br/>
<br/>
      my $xml = '    &lt;income&gt;' . $self-&gt;income . '&lt;/income&gt;';<br/>
      $xml .= &quot;\n&quot;;<br/>
      $xml .= '    &lt;expenses&gt;' . $self-&gt;expenses . '&lt;/expenses&gt;';<br/>
      $xml .= &quot;\n&quot;;<br/>
<br/>
      $xml .= inner() || q{};<br/>
<br/>
      return $xml;<br/>
  };<br/>
<div class="spacer">
</div>
Now our report has some content:<div class="spacer">
</div>
<br/>
  &lt;document&gt;<br/>
    &lt;report&gt;<br/>
      &lt;income&gt;$10&lt;/income&gt;<br/>
      &lt;expenses&gt;$8&lt;/expenses&gt;<br/>
    &lt;/report&gt;<br/>
  &lt;/document&gt;<br/>
<div class="spacer">
</div>
What makes this combination of &quot;augment&quot; and &quot;inner()&quot; special is that it allows us to have methods which are called from parent (least specific) to child (most specific). This inverts the normal inheritance pattern.<div class="spacer">
</div>
Note that in &quot;Report::IncomeAndExpenses&quot; we call &quot;inner()&quot; again. If the object is an instance of &quot;Report::IncomeAndExpenses&quot; then this call is a no-op, and just returns false. It's a good idea to always call &quot;inner()&quot; to allow for future subclassing.</div>
<div class="section">
<h1>OVERRIDE AND SUPER</h1> Finally, Moose provides some simple sugar for Perl's built-in method overriding scheme. If you want to override a method from a parent class, you can do this with &quot;override&quot;:<div class="spacer">
</div>
<br/>
  package Employee;<br/>
<br/>
  use Moose;<br/>
<br/>
  extends 'Person';<br/>
<br/>
  has 'job_title' =&gt; ( is =&gt; 'rw' );<br/>
<br/>
  override 'display_name' =&gt; sub {<br/>
      my $self = shift;<br/>
<br/>
      return super() . q{, } . $self-&gt;title();<br/>
  };<br/>
<div class="spacer">
</div>
The call to &quot;super()&quot; is almost the same as calling &quot;$self-&gt;SUPER::display_name&quot;. The difference is that the arguments passed to the superclass's method will always be the same as the ones passed to the method modifier, and cannot be changed.<div class="spacer">
</div>
All arguments passed to &quot;super()&quot; are ignored, as are any changes made to @_ before &quot;super()&quot; is called.</div>
<div class="section">
<h1>SEMI-COLONS</h1> Because all of these method modifiers are implemented as Perl functions, you must always end the modifier declaration with a semi-colon:<div class="spacer">
</div>
<br/>
  after 'foo' =&gt; sub { };<br/>
</div>
<div class="section">
<h1>CAVEATS</h1> These method modification features do not work well with multiple inheritance, due to how method resolution is performed in Perl. Experiment with a test program to ensure your class hierarchy works as expected, or more preferably, don't use multiple inheritance (roles can help with this)!</div>
<div class="section">
<h1>AUTHOR</h1> Moose is maintained by the Moose Cabal, along with the help of many contributors. See &quot;CABAL&quot; in Moose and &quot;CONTRIBUTORS&quot; in Moose for details.</div>
<div class="section">
<h1>COPYRIGHT AND LICENSE</h1> This software is copyright (c) 2011 by Infinity Interactive, Inc..<div class="spacer">
</div>
This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5 programming language system itself.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-11-17</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

