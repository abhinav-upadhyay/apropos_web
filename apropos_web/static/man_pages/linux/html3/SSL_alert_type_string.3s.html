<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
SSL_alert_type_string(3SSL)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
SSL_alert_type_string(3SSL)</td>
<td class="head-vol">
OpenSSL</td>
<td class="head-rtitle">
SSL_alert_type_string(3SSL)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> SSL_alert_type_string, SSL_alert_type_string_long, SSL_alert_desc_string, SSL_alert_desc_string_long - get textual description of alert information</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
 #include &lt;openssl/ssl.h&gt;<br/>
<br/>
 const char *SSL_alert_type_string(int value);<br/>
 const char *SSL_alert_type_string_long(int value);<br/>
<br/>
 const char *SSL_alert_desc_string(int value);<br/>
 const char *SSL_alert_desc_string_long(int value);<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1>  <i>SSL_alert_type_string()</i> returns a one letter string indicating the type of the alert specified by  <b>value</b>.<div class="spacer">
</div>
<i>SSL_alert_type_string_long()</i> returns a string indicating the type of the alert specified by  <b>value</b>.<div class="spacer">
</div>
<i>SSL_alert_desc_string()</i> returns a two letter string as a short form describing the reason of the alert specified by  <b>value</b>.<div class="spacer">
</div>
<i>SSL_alert_desc_string_long()</i> returns a string describing the reason of the alert specified by  <b>value</b>.</div>
<div class="section">
<h1>NOTES</h1> When one side of an SSL/TLS communication wants to inform the peer about a special situation, it sends an alert. The alert is sent as a special message and does not influence the normal data stream (unless its contents results in the communication being canceled).<div class="spacer">
</div>
A warning alert is sent, when a non-fatal error condition occurs. The &quot;close notify&quot; alert is sent as a warning alert. Other examples for non-fatal errors are certificate errors (&quot;certificate expired&quot;, &quot;unsupported certificate&quot;), for which a warning alert may be sent. (The sending party may however decide to send a fatal error.) The receiving side may cancel the connection on reception of a warning alert on it discretion.<div class="spacer">
</div>
Several alert messages must be sent as fatal alert messages as specified by the TLS RFC. A fatal alert always leads to a connection abort.</div>
<div class="section">
<h1>RETURN VALUES</h1> The following strings can occur for  <i>SSL_alert_type_string()</i> or  <i>SSL_alert_type_string_long()</i>:<dl>
<dt>
&quot;W&quot;/&quot;warning&quot;</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
&quot;F&quot;/&quot;fatal&quot;</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
&quot;U&quot;/&quot;unknown&quot;</dt>
<dd>
This indicates that no support is available for this alert type. Probably  <b>value</b> does not contain a correct alert message.</dd>
</dl>
<div class="spacer">
</div>
The following strings can occur for <i>SSL_alert_desc_string()</i> or  <i>SSL_alert_desc_string_long()</i>:<dl>
<dt>
&quot;CN&quot;/&quot;close notify&quot;</dt>
<dd>
The connection shall be closed. This is a warning alert.</dd>
</dl>
<dl>
<dt>
&quot;UM&quot;/&quot;unexpected message&quot;</dt>
<dd>
An inappropriate message was received. This alert is always fatal and should never be observed in communication between proper implementations.</dd>
</dl>
<dl>
<dt>
&quot;BM&quot;/&quot;bad record mac&quot;</dt>
<dd>
This alert is returned if a record is received with an incorrect MAC. This message is always fatal.</dd>
</dl>
<dl>
<dt>
&quot;DF&quot;/&quot;decompression failure&quot;</dt>
<dd>
The decompression function received improper input (e.g. data that would expand to excessive length). This message is always fatal.</dd>
</dl>
<dl>
<dt>
&quot;HF&quot;/&quot;handshake failure&quot;</dt>
<dd>
Reception of a handshake_failure alert message indicates that the sender was unable to negotiate an acceptable set of security parameters given the options available. This is a fatal error.</dd>
</dl>
<dl>
<dt>
&quot;NC&quot;/&quot;no certificate&quot;</dt>
<dd>
A client, that was asked to send a certificate, does not send a certificate (SSLv3 only).</dd>
</dl>
<dl>
<dt>
&quot;BC&quot;/&quot;bad certificate&quot;</dt>
<dd>
A certificate was corrupt, contained signatures that did not verify correctly, etc</dd>
</dl>
<dl>
<dt>
&quot;UC&quot;/&quot;unsupported certificate&quot;</dt>
<dd>
A certificate was of an unsupported type.</dd>
</dl>
<dl>
<dt>
&quot;CR&quot;/&quot;certificate revoked&quot;</dt>
<dd>
A certificate was revoked by its signer.</dd>
</dl>
<dl>
<dt>
&quot;CE&quot;/&quot;certificate expired&quot;</dt>
<dd>
A certificate has expired or is not currently valid.</dd>
</dl>
<dl>
<dt>
&quot;CU&quot;/&quot;certificate unknown&quot;</dt>
<dd>
Some other (unspecified) issue arose in processing the certificate, rendering it unacceptable.</dd>
</dl>
<dl>
<dt>
&quot;IP&quot;/&quot;illegal parameter&quot;</dt>
<dd>
A field in the handshake was out of range or inconsistent with other fields. This is always fatal.</dd>
</dl>
<dl>
<dt>
&quot;DC&quot;/&quot;decryption failed&quot;</dt>
<dd>
A TLSCiphertext decrypted in an invalid way: either it wasn't an even multiple of the block length or its padding values, when checked, weren't correct. This message is always fatal.</dd>
</dl>
<dl>
<dt>
&quot;RO&quot;/&quot;record overflow&quot;</dt>
<dd>
A TLSCiphertext record was received which had a length more than 2^14+2048 bytes, or a record decrypted to a TLSCompressed record with more than 2^14+1024 bytes. This message is always fatal.</dd>
</dl>
<dl>
<dt>
&quot;CA&quot;/&quot;unknown CA&quot;</dt>
<dd>
A valid certificate chain or partial chain was received, but the certificate was not accepted because the CA certificate could not be located or couldn't be matched with a known, trusted CA.  This message is always fatal.</dd>
</dl>
<dl>
<dt>
&quot;AD&quot;/&quot;access denied&quot;</dt>
<dd>
A valid certificate was received, but when access control was applied, the sender decided not to proceed with negotiation. This message is always fatal.</dd>
</dl>
<dl>
<dt>
&quot;DE&quot;/&quot;decode error&quot;</dt>
<dd>
A message could not be decoded because some field was out of the specified range or the length of the message was incorrect. This message is always fatal.</dd>
</dl>
<dl>
<dt>
&quot;CY&quot;/&quot;decrypt error&quot;</dt>
<dd>
A handshake cryptographic operation failed, including being unable to correctly verify a signature, decrypt a key exchange, or validate a finished message.</dd>
</dl>
<dl>
<dt>
&quot;ER&quot;/&quot;export restriction&quot;</dt>
<dd>
A negotiation not in compliance with export restrictions was detected; for example, attempting to transfer a 1024 bit ephemeral RSA key for the RSA_EXPORT handshake method. This message is always fatal.</dd>
</dl>
<dl>
<dt>
&quot;PV&quot;/&quot;protocol version&quot;</dt>
<dd>
The protocol version the client has attempted to negotiate is recognized, but not supported. (For example, old protocol versions might be avoided for security reasons). This message is always fatal.</dd>
</dl>
<dl>
<dt>
&quot;IS&quot;/&quot;insufficient security&quot;</dt>
<dd>
Returned instead of handshake_failure when a negotiation has failed specifically because the server requires ciphers more secure than those supported by the client. This message is always fatal.</dd>
</dl>
<dl>
<dt>
&quot;IE&quot;/&quot;internal error&quot;</dt>
<dd>
An internal error unrelated to the peer or the correctness of the protocol makes it impossible to continue (such as a memory allocation failure). This message is always fatal.</dd>
</dl>
<dl>
<dt>
&quot;US&quot;/&quot;user canceled&quot;</dt>
<dd>
This handshake is being canceled for some reason unrelated to a protocol failure. If the user cancels an operation after the handshake is complete, just closing the connection by sending a close_notify is more appropriate. This alert should be followed by a close_notify. This message is generally a warning.</dd>
</dl>
<dl>
<dt>
&quot;NR&quot;/&quot;no renegotiation&quot;</dt>
<dd>
Sent by the client in response to a hello request or by the server in response to a client hello after initial handshaking. Either of these would normally lead to renegotiation; when that is not appropriate, the recipient should respond with this alert; at that point, the original requester can decide whether to proceed with the connection. One case where this would be appropriate would be where a server has spawned a process to satisfy a request; the process might receive security parameters (key length, authentication, etc.) at startup and it might be difficult to communicate changes to these parameters after that point. This message is always a warning.</dd>
</dl>
<dl>
<dt>
&quot;UP&quot;/&quot;unknown PSK identity&quot;</dt>
<dd>
Sent by the server to indicate that it does not recognize a PSK identity or an SRP identity.</dd>
</dl>
<dl>
<dt>
&quot;UK&quot;/&quot;unknown&quot;</dt>
<dd>
This indicates that no description is available for this alert type. Probably  <b>value</b> does not contain a correct alert message.</dd>
</dl>
</div>
<div class="section">
<h1>SEE ALSO</h1>  <i>ssl</i>(3), <i>SSL_CTX_set_info_callback</i>(3)</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-11-13</td>
<td class="foot-os">
1.0.1</td>
</tr>
</table>
</div>
</body>
</html>

