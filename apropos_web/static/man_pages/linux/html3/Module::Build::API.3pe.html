<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Module::Build::API(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Module::Build::API(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
Module::Build::API(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Module::Build::API - API Reference for Module Authors</div>
<div class="section">
<h1>DESCRIPTION</h1> I list here some of the most important methods in &quot;Module::Build&quot;. Normally you won't need to deal with these methods unless you want to subclass &quot;Module::Build&quot;.  But since one of the reasons I created this module in the first place was so that subclassing is possible (and easy), I will certainly write more docs as the interface stabilizes.<div class="subsection">
<h2>CONSTRUCTORS</h2><dl>
<dt>
<i>current()</i></dt>
<dd>
[version 0.20]<div style="height: 1.00em;">
&#160;</div>
This method returns a reasonable facsimile of the currently-executing &quot;Module::Build&quot; object representing the current build.  You can use this object to query its &quot; <i>notes()</i>&quot; method, inquire about installed modules, and so on.  This is a great way to share information between different parts of your build process.  For instance, you can ask the user a question during &quot;perl Build.PL&quot;, then use their answer during a regression test:<div style="height: 1.00em;">
&#160;</div>
<br/>
  # In Build.PL:<br/>
  my $color = $build-&gt;prompt(&quot;What is your favorite color?&quot;);<br/>
  $build-&gt;notes(color =&gt; $color);<br/>
<br/>
  # In t/colortest.t:<br/>
  use Module::Build;<br/>
  my $build = Module::Build-&gt;current;<br/>
  my $color = $build-&gt;notes('color');<br/>
  ...<br/>
<div style="height: 1.00em;">
&#160;</div>
The way the &quot;current()&quot; method is currently implemented, there may be slight differences between the $build object in Build.PL and the one in &quot;t/colortest.t&quot;.  It is our goal to minimize these differences in future releases of Module::Build, so please report any anomalies you find.<div style="height: 1.00em;">
&#160;</div>
One important caveat: in its current implementation, &quot;current()&quot; will  <b>NOT</b> work correctly if you have changed out of the directory that &quot;Module::Build&quot; was invoked from.</dd>
</dl>
<dl>
<dt>
<i>new()</i></dt>
<dd>
[version 0.03]<div style="height: 1.00em;">
&#160;</div>
Creates a new Module::Build object.  Arguments to the <i>new()</i> method are listed below.  Most arguments are optional, but you must provide either the &quot;module_name&quot; argument, or &quot;dist_name&quot; and one of &quot;dist_version&quot; or &quot;dist_version_from&quot;.  In other words, you must provide enough information to determine both a distribution name and version.</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
add_to_cleanup</dt>
<dd>
[version 0.19]<div style="height: 1.00em;">
&#160;</div>
An array reference of files to be cleaned up when the &quot;clean&quot; action is performed. See also the  <i>add_to_cleanup()</i> method.</dd>
</dl>
<dl>
<dt>
auto_configure_requires</dt>
<dd>
[version 0.34]<div style="height: 1.00em;">
&#160;</div>
This parameter determines whether Module::Build will add itself automatically to configure_requires (and build_requires) if Module::Build is not already there.  The required version will be the last 'major' release, as defined by the decimal version truncated to two decimal places (e.g. 0.34, instead of 0.3402).  The default value is true.</dd>
</dl>
<dl>
<dt>
auto_features</dt>
<dd>
[version 0.26]<div style="height: 1.00em;">
&#160;</div>
This parameter supports the setting of features (see &quot;feature($name)&quot;) automatically based on a set of prerequisites.  For instance, for a module that could optionally use either MySQL or PostgreSQL databases, you might use &quot;auto_features&quot; like this:<div style="height: 1.00em;">
&#160;</div>
<br/>
  my $build = Module::Build-&gt;new<br/>
    (<br/>
     ...other stuff here...<br/>
     auto_features =&gt; {<br/>
       pg_support    =&gt; {<br/>
                         description =&gt; &quot;Interface with Postgres databases&quot;,<br/>
                         requires    =&gt; { 'DBD::Pg' =&gt; 23.3,<br/>
                                          'DateTime::Format::Pg' =&gt; 0 },<br/>
                        },<br/>
       mysql_support =&gt; {<br/>
                         description =&gt; &quot;Interface with MySQL databases&quot;,<br/>
                         requires    =&gt; { 'DBD::mysql' =&gt; 17.9,<br/>
                                          'DateTime::Format::MySQL' =&gt; 0 },<br/>
                        },<br/>
     }<br/>
    );<br/>
<div style="height: 1.00em;">
&#160;</div>
For each feature named, the required prerequisites will be checked, and if there are no failures, the feature will be enabled (set to 1). Otherwise the failures will be displayed to the user and the feature will be disabled (set to 0).<div style="height: 1.00em;">
&#160;</div>
See the documentation for &quot;requires&quot; for the details of how requirements can be specified.</dd>
</dl>
<dl>
<dt>
autosplit</dt>
<dd>
[version 0.04]<div style="height: 1.00em;">
&#160;</div>
An optional &quot;autosplit&quot; argument specifies a file which should be run through the  <i>AutoSplit::autosplit()</i> function. If multiple files should be split, the argument may be given as an array of the files to split.<div style="height: 1.00em;">
&#160;</div>
In general I don't consider autosplitting a great idea, because it's not always clear that autosplitting achieves its intended performance benefits.  It may even harm performance in environments like mod_perl, where as much as possible of a module's code should be loaded during startup.</dd>
</dl>
<dl>
<dt>
build_class</dt>
<dd>
[version 0.28]<div style="height: 1.00em;">
&#160;</div>
The Module::Build class or subclass to use in the build script. Defaults to &quot;Module::Build&quot; or the class name passed to or created by a call to &quot; <i>subclass()</i>&quot;.  This property is useful if you're writing a custom Module::Build subclass and have a bootstrapping problem--that is, your subclass requires modules that may not be installed when &quot;perl Build.PL&quot; is executed, but you've listed in &quot;build_requires&quot; so that they should be available when &quot;./Build&quot; is executed.</dd>
</dl>
<dl>
<dt>
build_requires</dt>
<dd>
[version 0.07]<div style="height: 1.00em;">
&#160;</div>
Modules listed in this section are necessary to build and install the given module, but are not necessary for regular usage of it.  This is actually an important distinction - it allows for tighter control over the body of installed modules, and facilitates correct dependency checking on binary/packaged distributions of the module.<div style="height: 1.00em;">
&#160;</div>
See the documentation for &quot;PREREQUISITES&quot; in Module::Build::Authoring for the details of how requirements can be specified.</dd>
</dl>
<dl>
<dt>
create_packlist</dt>
<dd>
[version 0.28]<div style="height: 1.00em;">
&#160;</div>
If true, this parameter tells Module::Build to create a <i>.packlist</i> file during the &quot;install&quot; action, just like &quot;ExtUtils::MakeMaker&quot; does. The file is created in a subdirectory of the &quot;arch&quot; installation location.  It is used by some other tools (CPAN, CPANPLUS, etc.) for determining what files are part of an install.<div style="height: 1.00em;">
&#160;</div>
The default value is true.  This parameter was introduced in Module::Build version 0.2609; previously no packlists were ever created by Module::Build.</dd>
</dl>
<dl>
<dt>
c_source</dt>
<dd>
[version 0.04]<div style="height: 1.00em;">
&#160;</div>
An optional &quot;c_source&quot; argument specifies a directory which contains C source files that the rest of the build may depend on.  Any &quot;.c&quot; files in the directory will be compiled to object files.  The directory will be added to the search path during the compilation and linking phases of any C or XS files.<div style="height: 1.00em;">
&#160;</div>
[version 0.3604]<div style="height: 1.00em;">
&#160;</div>
A list of directories can be supplied using an anonymous array reference of strings.</dd>
</dl>
<dl>
<dt>
conflicts</dt>
<dd>
[version 0.07]<div style="height: 1.00em;">
&#160;</div>
Modules listed in this section conflict in some serious way with the given module.  &quot;Module::Build&quot; (or some higher-level tool) will refuse to install the given module if the given module/version is also installed.<div style="height: 1.00em;">
&#160;</div>
See the documentation for &quot;PREREQUISITES&quot; in Module::Build::Authoring for the details of how requirements can be specified.</dd>
</dl>
<dl>
<dt>
create_license</dt>
<dd>
[version 0.31]<div style="height: 1.00em;">
&#160;</div>
This parameter tells Module::Build to automatically create a  <i>LICENSE</i> file at the top level of your distribution, containing the full text of the author's chosen license.  This requires &quot;Software::License&quot; on the author's machine, and further requires that the &quot;license&quot; parameter specifies a license that it knows about.</dd>
</dl>
<dl>
<dt>
create_makefile_pl</dt>
<dd>
[version 0.19]<div style="height: 1.00em;">
&#160;</div>
This parameter lets you use &quot;Module::Build::Compat&quot; during the &quot;distdir&quot; (or &quot;dist&quot;) action to automatically create a Makefile.PL for compatibility with &quot;ExtUtils::MakeMaker&quot;.  The parameter's value should be one of the styles named in the Module::Build::Compat documentation.</dd>
</dl>
<dl>
<dt>
create_readme</dt>
<dd>
[version 0.22]<div style="height: 1.00em;">
&#160;</div>
This parameter tells Module::Build to automatically create a <i>README</i> file at the top level of your distribution.  Currently it will simply use &quot;Pod::Text&quot; (or &quot;Pod::Readme&quot; if it's installed) on the file indicated by &quot;dist_version_from&quot; and put the result in the  <i>README</i> file.  This is by no means the only recommended style for writing a  <i>README</i>, but it seems to be one common one used on the CPAN.<div style="height: 1.00em;">
&#160;</div>
If you generate a <i>README</i> in this way, it's probably a good idea to create a separate  <i>INSTALL</i> file if that information isn't in the generated  <i>README</i>.</dd>
</dl>
<dl>
<dt>
dist_abstract</dt>
<dd>
[version 0.20]<div style="height: 1.00em;">
&#160;</div>
This should be a short description of the distribution.  This is used when generating metadata for  <i>META.yml</i> and PPD files.  If it is not given then &quot;Module::Build&quot; looks in the POD of the module from which it gets the distribution's version.  If it finds a POD section marked &quot;=head1 NAME&quot;, then it looks for the first line matching &quot;\s+-\s+(.+)&quot;, and uses the captured text as the abstract.</dd>
</dl>
<dl>
<dt>
dist_author</dt>
<dd>
[version 0.20]<div style="height: 1.00em;">
&#160;</div>
This should be something like &quot;John Doe &lt;jdoe@example.com&gt;&quot;, or if there are multiple authors, an anonymous array of strings may be specified.  This is used when generating metadata for  <i>META.yml</i> and PPD files.  If this is not specified, then &quot;Module::Build&quot; looks at the module from which it gets the distribution's version.  If it finds a POD section marked &quot;=head1 AUTHOR&quot;, then it uses the contents of this section.</dd>
</dl>
<dl>
<dt>
dist_name</dt>
<dd>
[version 0.11]<div style="height: 1.00em;">
&#160;</div>
Specifies the name for this distribution.  Most authors won't need to set this directly, they can use &quot;module_name&quot; to set &quot;dist_name&quot; to a reasonable default.  However, some agglomerative distributions like &quot;libwww-perl&quot; or &quot;bioperl&quot; have names that don't correspond directly to a module name, so &quot;dist_name&quot; can be set independently.</dd>
</dl>
<dl>
<dt>
dist_suffix</dt>
<dd>
[version 0.37]<div style="height: 1.00em;">
&#160;</div>
Specifies an optional suffix to include after the version number in the distribution directory (and tarball) name.  The only suffix currently recognized by PAUSE is 'TRIAL', which indicates that the distribution should not be indexed.  For example:<div style="height: 1.00em;">
&#160;</div>
<br/>
  Foo-Bar-1.23-TRIAL.tar.gz<br/>
<div style="height: 1.00em;">
&#160;</div>
This will automatically do the &quot;right thing&quot; depending on &quot;dist_version&quot; and &quot;release_status&quot;.  When &quot;dist_version&quot; does not have an underscore and &quot;release_status&quot; is not 'stable', then &quot;dist_suffix&quot; will default to 'TRIAL'. Otherwise it will default to the empty string, disabling the suffix.<div style="height: 1.00em;">
&#160;</div>
In general, authors should only set this if they <b>must</b> override the default behavior for some particular purpose.</dd>
</dl>
<dl>
<dt>
dist_version</dt>
<dd>
[version 0.11]<div style="height: 1.00em;">
&#160;</div>
Specifies a version number for the distribution.  See &quot;module_name&quot; or &quot;dist_version_from&quot; for ways to have this set automatically from a $VERSION variable in a module.  One way or another, a version number needs to be set.</dd>
</dl>
<dl>
<dt>
dist_version_from</dt>
<dd>
[version 0.11]<div style="height: 1.00em;">
&#160;</div>
Specifies a file to look for the distribution version in.  Most authors won't need to set this directly, they can use &quot;module_name&quot; to set it to a reasonable default.<div style="height: 1.00em;">
&#160;</div>
The version is extracted from the specified file according to the same rules as ExtUtils::MakeMaker and &quot;CPAN.pm&quot;.  It involves finding the first line that matches the regular expression<div style="height: 1.00em;">
&#160;</div>
<br/>
   /([\$*])(([\w\:\']*)\bVERSION)\b.*\=/<br/>
<div style="height: 1.00em;">
&#160;</div>
<i>eval()</i>-ing that line, then checking the value of the $VERSION variable.  Quite ugly, really, but all the modules on CPAN depend on this process, so there's no real opportunity to change to something better.<div style="height: 1.00em;">
&#160;</div>
If the target file of &quot;dist_version_from&quot; contains more than one package declaration, the version returned will be the one matching the configured &quot;module_name&quot;.</dd>
</dl>
<dl>
<dt>
dynamic_config</dt>
<dd>
[version 0.07]<div style="height: 1.00em;">
&#160;</div>
A boolean flag indicating whether the <i>Build.PL</i> file must be executed, or whether this module can be built, tested and installed solely from consulting its metadata file.  The main reason to set this to a true value is that your module performs some dynamic configuration as part of its build/install process.  If the flag is omitted, the  <i>META.yml</i> spec says that installation tools should treat it as 1 (true), because this is a safer way to behave.<div style="height: 1.00em;">
&#160;</div>
Currently &quot;Module::Build&quot; doesn't actually do anything with this flag - it's up to higher-level tools like &quot;CPAN.pm&quot; to do something useful with it.  It can potentially bring lots of security, packaging, and convenience improvements.</dd>
</dl>
<dl>
<dt>
extra_compiler_flags</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
extra_linker_flags</dt>
<dd>
[version 0.19]<div style="height: 1.00em;">
&#160;</div>
These parameters can contain array references (or strings, in which case they will be split into arrays) to pass through to the compiler and linker phases when compiling/linking C code.  For example, to tell the compiler that your code is C++, you might do:<div style="height: 1.00em;">
&#160;</div>
<br/>
  my $build = Module::Build-&gt;new<br/>
    (<br/>
     module_name          =&gt; 'Foo::Bar',<br/>
     extra_compiler_flags =&gt; ['-x', 'c++'],<br/>
    );<br/>
<div style="height: 1.00em;">
&#160;</div>
To link your XS code against glib you might write something like:<div style="height: 1.00em;">
&#160;</div>
<br/>
  my $build = Module::Build-&gt;new<br/>
    (<br/>
     module_name          =&gt; 'Foo::Bar',<br/>
     dynamic_config       =&gt; 1,<br/>
     extra_compiler_flags =&gt; scalar `glib-config --cflags`,<br/>
     extra_linker_flags   =&gt; scalar `glib-config --libs`,<br/>
    );<br/>
</dd>
</dl>
<dl>
<dt>
get_options</dt>
<dd>
[version 0.26]<div style="height: 1.00em;">
&#160;</div>
You can pass arbitrary command line options to <i>Build.PL</i> or  <i>Build</i>, and they will be stored in the Module::Build object and can be accessed via the &quot; <i>args()</i>&quot; method.  However, sometimes you want more flexibility out of your argument processing than this allows.  In such cases, use the &quot;get_options&quot; parameter to pass in a hash reference of argument specifications, and the list of arguments to  <i>Build.PL</i> or <i>Build</i> will be processed according to those specifications before they're passed on to &quot;Module::Build&quot;'s own argument processing.<div style="height: 1.00em;">
&#160;</div>
The supported option specification hash keys are:<div style="margin-left: 4.00ex;">
<dl>
<dt>
type</dt>
<dd>
The type of option.  The types are those supported by Getopt::Long; consult its documentation for a complete list.  Typical types are &quot;=s&quot; for strings, &quot;+&quot; for additive options, and &quot;!&quot; for negatable options.  If the type is not specified, it will be considered a boolean, i.e. no argument is taken and a value of 1 will be assigned when the option is encountered.</dd>
</dl>
<dl>
<dt>
store</dt>
<dd>
A reference to a scalar in which to store the value passed to the option. If not specified, the value will be stored under the option name in the hash returned by the &quot;args()&quot; method.</dd>
</dl>
<dl>
<dt>
default</dt>
<dd>
A default value for the option.  If no default value is specified and no option is passed, then the option key will not exist in the hash returned by &quot;args()&quot;.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">
&#160;</div>
You can combine references to your own variables or subroutines with unreferenced specifications, for which the result will also be stored in the hash returned by &quot;args()&quot;.  For example:<div style="height: 1.00em;">
&#160;</div>
<br/>
  my $loud = 0;<br/>
  my $build = Module::Build-&gt;new<br/>
    (<br/>
     module_name =&gt; 'Foo::Bar',<br/>
     get_options =&gt; {<br/>
                     Loud =&gt;     { store =&gt; \$loud },<br/>
                     Dbd  =&gt;     { type  =&gt; '=s'   },<br/>
                     Quantity =&gt; { type  =&gt; '+'    },<br/>
                    }<br/>
    );<br/>
<br/>
  print STDERR &quot;HEY, ARE YOU LISTENING??\n&quot; if $loud;<br/>
  print &quot;We'll use the &quot;, $build-&gt;args('Dbd'), &quot; DBI driver\n&quot;;<br/>
  print &quot;Are you sure you want that many?\n&quot;<br/>
    if $build-&gt;args('Quantity') &gt; 2;<br/>
<div style="height: 1.00em;">
&#160;</div>
The arguments for such a specification can be called like so:<div style="height: 1.00em;">
&#160;</div>
<br/>
  perl Build.PL --Loud --Dbd=DBD::pg --Quantity --Quantity --Quantity<br/>
<div style="height: 1.00em;">
&#160;</div>
<b>WARNING:</b> Any option specifications that conflict with Module::Build's own options (defined by its properties) will throw an exception.  Use capitalized option names to avoid unintended conflicts with future Module::Build options.<div style="height: 1.00em;">
&#160;</div>
Consult the Getopt::Long documentation for details on its usage.</div>
</dd>
</dl>
<dl>
<dt>
include_dirs</dt>
<dd>
[version 0.24]<div style="height: 1.00em;">
&#160;</div>
Specifies any additional directories in which to search for C header files.  May be given as a string indicating a single directory, or as a list reference indicating multiple directories.</dd>
</dl>
<dl>
<dt>
install_path</dt>
<dd>
[version 0.19]<div style="height: 1.00em;">
&#160;</div>
You can set paths for individual installable elements by using the &quot;install_path&quot; parameter:<div style="height: 1.00em;">
&#160;</div>
<br/>
  my $build = Module::Build-&gt;new<br/>
    (<br/>
     ...other stuff here...<br/>
     install_path =&gt; {<br/>
                      lib  =&gt; '/foo/lib',<br/>
                      arch =&gt; '/foo/lib/arch',<br/>
                     }<br/>
    );<br/>
</dd>
</dl>
<dl>
<dt>
installdirs</dt>
<dd>
[version 0.19]<div style="height: 1.00em;">
&#160;</div>
Determines where files are installed within the normal perl hierarchy as determined by  <i>Config.pm</i>.  Valid values are: &quot;core&quot;, &quot;site&quot;, &quot;vendor&quot;.  The default is &quot;site&quot;.  See &quot;INSTALL PATHS&quot; in Module::Build</dd>
</dl>
<dl>
<dt>
license</dt>
<dd>
[version 0.07]<div style="height: 1.00em;">
&#160;</div>
Specifies the licensing terms of your distribution.<div style="height: 1.00em;">
&#160;</div>
As of Module::Build version 0.36_14, you may use a Software::License subclass name (e.g. 'Apache_2_0') instead of one of the keys below.<div style="height: 1.00em;">
&#160;</div>
The legacy list of valid license values include:<div style="margin-left: 4.00ex;">
<dl>
<dt>
apache</dt>
<dd>
The distribution is licensed under the Apache License, Version 2.0 (http://apache.org/licenses/LICENSE-2.0 &lt;http://apache.org/licenses/LICENSE-2.0&gt;).</dd>
</dl>
<dl>
<dt>
apache_1_1</dt>
<dd>
The distribution is licensed under the Apache Software License, Version 1.1 (http://apache.org/licenses/LICENSE-1.1 &lt;http://apache.org/licenses/LICENSE-1.1&gt;).</dd>
</dl>
<dl>
<dt>
artistic</dt>
<dd>
The distribution is licensed under the Artistic License, as specified by the  <i>Artistic</i> file in the standard Perl distribution.</dd>
</dl>
<dl>
<dt>
artistic_2</dt>
<dd>
The distribution is licensed under the Artistic 2.0 License (http://opensource.org/licenses/artistic-license-2.0.php &lt;http://opensource.org/licenses/artistic-license-2.0.php&gt;.)</dd>
</dl>
<dl>
<dt>
bsd</dt>
<dd>
The distribution is licensed under the BSD License (http://www.opensource.org/licenses/bsd-license.php &lt;http://www.opensource.org/licenses/bsd-license.php&gt;).</dd>
</dl>
<dl>
<dt>
gpl</dt>
<dd>
The distribution is licensed under the terms of the GNU General Public License (http://www.opensource.org/licenses/gpl-license.php &lt;http://www.opensource.org/licenses/gpl-license.php&gt;).</dd>
</dl>
<dl>
<dt>
lgpl</dt>
<dd>
The distribution is licensed under the terms of the GNU Lesser General Public License (http://www.opensource.org/licenses/lgpl-license.php &lt;http://www.opensource.org/licenses/lgpl-license.php&gt;).</dd>
</dl>
<dl>
<dt>
mit</dt>
<dd>
The distribution is licensed under the MIT License (http://opensource.org/licenses/mit-license.php &lt;http://opensource.org/licenses/mit-license.php&gt;).</dd>
</dl>
<dl>
<dt>
mozilla</dt>
<dd>
The distribution is licensed under the Mozilla Public License.  (&lt;http://opensource.org/licenses/mozilla1.0.php&gt; or &lt;http://opensource.org/licenses/mozilla1.1.php&gt;)</dd>
</dl>
<dl>
<dt>
open_source</dt>
<dd>
The distribution is licensed under some other Open Source Initiative-approved license listed at &lt;http://www.opensource.org/licenses/&gt;.</dd>
</dl>
<dl>
<dt>
perl</dt>
<dd>
The distribution may be copied and redistributed under the same terms as Perl itself (this is by far the most common licensing option for modules on CPAN).  This is a dual license, in which the user may choose between either the GPL or the Artistic license.</dd>
</dl>
<dl>
<dt>
restrictive</dt>
<dd>
The distribution may not be redistributed without special permission from the author and/or copyright holder.</dd>
</dl>
<dl>
<dt>
unrestricted</dt>
<dd>
The distribution is licensed under a license that is <b>not</b> approved by www.opensource.org but that allows distribution without restrictions.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">
&#160;</div>
Note that you must still include the terms of your license in your code and documentation - this field only sets the information that is included in distribution metadata to let automated tools figure out your licensing restrictions.  Humans still need something to read.  If you choose to provide this field, you should make sure that you keep it in sync with your written documentation if you ever change your licensing terms.<div style="height: 1.00em;">
&#160;</div>
You may also use a license type of &quot;unknown&quot; if you don't wish to specify your terms in the metadata.<div style="height: 1.00em;">
&#160;</div>
Also see the &quot;create_license&quot; parameter.</div>
</dd>
</dl>
<dl>
<dt>
meta_add</dt>
<dd>
[version 0.28]<div style="height: 1.00em;">
&#160;</div>
A hash of key/value pairs that should be added to the <i>META.yml</i> file during the &quot;distmeta&quot; action.  Any existing entries with the same names will be overridden.<div style="height: 1.00em;">
&#160;</div>
See the &quot;MODULE METADATA&quot; section for details.</dd>
</dl>
<dl>
<dt>
meta_merge</dt>
<dd>
[version 0.28]<div style="height: 1.00em;">
&#160;</div>
A hash of key/value pairs that should be merged into the <i>META.yml</i> file during the &quot;distmeta&quot; action.  Any existing entries with the same names will be overridden.<div style="height: 1.00em;">
&#160;</div>
The only difference between &quot;meta_add&quot; and &quot;meta_merge&quot; is their behavior on hash-valued and array-valued entries: &quot;meta_add&quot; will completely blow away the existing hash or array value, but &quot;meta_merge&quot; will merge the supplied data into the existing hash or array value.<div style="height: 1.00em;">
&#160;</div>
See the &quot;MODULE METADATA&quot; section for details.</dd>
</dl>
<dl>
<dt>
module_name</dt>
<dd>
[version 0.03]<div style="height: 1.00em;">
&#160;</div>
The &quot;module_name&quot; is a shortcut for setting default values of &quot;dist_name&quot; and &quot;dist_version_from&quot;, reflecting the fact that the majority of CPAN distributions are centered around one &quot;main&quot; module. For instance, if you set &quot;module_name&quot; to &quot;Foo::Bar&quot;, then &quot;dist_name&quot; will default to &quot;Foo-Bar&quot; and &quot;dist_version_from&quot; will default to &quot;lib/Foo/Bar.pm&quot;.  &quot;dist_version_from&quot; will in turn be used to set &quot;dist_version&quot;.<div style="height: 1.00em;">
&#160;</div>
Setting &quot;module_name&quot; won't override a &quot;dist_*&quot; parameter you specify explicitly.</dd>
</dl>
<dl>
<dt>
needs_compiler</dt>
<dd>
[version 0.36]<div style="height: 1.00em;">
&#160;</div>
The &quot;needs_compiler&quot; parameter indicates whether a compiler is required to build the distsribution.  The default is false, unless XS files are found or the &quot;c_source&quot; parameter is set, in which case it is true.  If true, ExtUtils::CBuilder is automatically added to &quot;build_requires&quot; if needed.<div style="height: 1.00em;">
&#160;</div>
For a distribution where a compiler is <i>optional</i>, e.g. a dual XS/pure-Perl distribution, &quot;needs_compiler&quot; should explicitly be set to a false value.</dd>
</dl>
<dl>
<dt>
PL_files</dt>
<dd>
[version 0.06]<div style="height: 1.00em;">
&#160;</div>
An optional parameter specifying a set of &quot;.PL&quot; files in your distribution.  These will be run as Perl scripts prior to processing the rest of the files in your distribution with the name of the file they're generating as an argument.  They are usually used as templates for creating other files dynamically, so that a file like &quot;lib/Foo/Bar.pm.PL&quot; might create the file &quot;lib/Foo/Bar.pm&quot;.<div style="height: 1.00em;">
&#160;</div>
The files are specified with the &quot;.PL&quot; files as hash keys, and the file(s) they generate as hash values, like so:<div style="height: 1.00em;">
&#160;</div>
<br/>
  my $build = Module::Build-&gt;new<br/>
    (<br/>
     module_name =&gt; 'Foo::Bar',<br/>
     ...<br/>
     PL_files =&gt; { 'lib/Foo/Bar.pm.PL' =&gt; 'lib/Foo/Bar.pm' },<br/>
    );<br/>
<div style="height: 1.00em;">
&#160;</div>
Note that the path specifications are <i>always</i> given in Unix-like format, not in the style of the local system.<div style="height: 1.00em;">
&#160;</div>
If your &quot;.PL&quot; scripts don't create any files, or if they create files with unexpected names, or even if they create multiple files, you can indicate that so that Module::Build can properly handle these created files:<div style="height: 1.00em;">
&#160;</div>
<br/>
  PL_files =&gt; {<br/>
               'lib/Foo/Bar.pm.PL' =&gt; 'lib/Foo/Bar.pm',<br/>
               'lib/something.PL'  =&gt; ['/lib/something', '/lib/else'],<br/>
               'lib/funny.PL'      =&gt; [],<br/>
              }<br/>
<div style="height: 1.00em;">
&#160;</div>
Here's an example of a simple PL file.<div style="height: 1.00em;">
&#160;</div>
<br/>
    my $output_file = shift;<br/>
    open my $fh, &quot;&gt;&quot;, $output_file or die &quot;Can't open $output_file: $!&quot;;<br/>
<br/>
    print $fh &lt;&lt;'END';<br/>
    #!/usr/bin/perl<br/>
<br/>
    print &quot;Hello, world!\n&quot;;<br/>
    END<br/>
<div style="height: 1.00em;">
&#160;</div>
PL files are not installed by default, so its safe to put them in  <i>lib/</i> and <i>bin/</i>.</dd>
</dl>
<dl>
<dt>
pm_files</dt>
<dd>
[version 0.19]<div style="height: 1.00em;">
&#160;</div>
An optional parameter specifying the set of &quot;.pm&quot; files in this distribution, specified as a hash reference whose keys are the files' locations in the distributions, and whose values are their logical locations based on their package name, i.e. where they would be found in a &quot;normal&quot; Module::Build-style distribution.  This parameter is mainly intended to support alternative layouts of files.<div style="height: 1.00em;">
&#160;</div>
For instance, if you have an old-style &quot;MakeMaker&quot; distribution for a module called &quot;Foo::Bar&quot; and a  <i>Bar.pm</i> file at the top level of the distribution, you could specify your layout in your &quot;Build.PL&quot; like this:<div style="height: 1.00em;">
&#160;</div>
<br/>
  my $build = Module::Build-&gt;new<br/>
    (<br/>
     module_name =&gt; 'Foo::Bar',<br/>
     ...<br/>
     pm_files =&gt; { 'Bar.pm' =&gt; 'lib/Foo/Bar.pm' },<br/>
    );<br/>
<div style="height: 1.00em;">
&#160;</div>
Note that the values should include &quot;lib/&quot;, because this is where they would be found in a &quot;normal&quot; Module::Build-style distribution.<div style="height: 1.00em;">
&#160;</div>
Note also that the path specifications are <i>always</i> given in Unix-like format, not in the style of the local system.</dd>
</dl>
<dl>
<dt>
pod_files</dt>
<dd>
[version 0.19]<div style="height: 1.00em;">
&#160;</div>
Just like &quot;pm_files&quot;, but used for specifying the set of &quot;.pod&quot; files in your distribution.</dd>
</dl>
<dl>
<dt>
recommends</dt>
<dd>
[version 0.08]<div style="height: 1.00em;">
&#160;</div>
This is just like the &quot;requires&quot; argument, except that modules listed in this section aren't essential, just a good idea.  We'll just print a friendly warning if one of these modules aren't found, but we'll continue running.<div style="height: 1.00em;">
&#160;</div>
If a module is recommended but not required, all tests should still pass if the module isn't installed.  This may mean that some tests may be skipped if recommended dependencies aren't present.<div style="height: 1.00em;">
&#160;</div>
Automated tools like CPAN.pm should inform the user when recommended modules aren't installed, and it should offer to install them if it wants to be helpful.<div style="height: 1.00em;">
&#160;</div>
See the documentation for &quot;PREREQUISITES&quot; in Module::Build::Authoring for the details of how requirements can be specified.</dd>
</dl>
<dl>
<dt>
recursive_test_files</dt>
<dd>
[version 0.28]<div style="height: 1.00em;">
&#160;</div>
Normally, &quot;Module::Build&quot; does not search subdirectories when looking for tests to run. When this options is set it will search recursively in all subdirectories of the standard 't' test directory.</dd>
</dl>
<dl>
<dt>
release_status</dt>
<dd>
[version 0.37]<div style="height: 1.00em;">
&#160;</div>
The CPAN Meta Spec version 2 adds &quot;release_status&quot; to allow authors to specify how a distribution should be indexed.  Consistent with the spec, this parameter can only have one three values: 'stable', 'testing' or 'unstable'.<div style="height: 1.00em;">
&#160;</div>
Unless explicitly set by the author, &quot;release_status&quot; will default to 'stable' unless &quot;dist_version&quot; contains an underscore, in which case it will default to 'testing'.<div style="height: 1.00em;">
&#160;</div>
It is an error to specify a &quot;release_status&quot; of 'stable' when &quot;dist_version&quot; contains an underscore character.</dd>
</dl>
<dl>
<dt>
requires</dt>
<dd>
[version 0.07]<div style="height: 1.00em;">
&#160;</div>
An optional &quot;requires&quot; argument specifies any module prerequisites that the current module depends on.<div style="height: 1.00em;">
&#160;</div>
One note: currently &quot;Module::Build&quot; doesn't actually <i>require</i> the user to have dependencies installed, it just strongly urges.  In the future we may require it.  There's also a &quot;recommends&quot; section for things that aren't absolutely required.<div style="height: 1.00em;">
&#160;</div>
Automated tools like CPAN.pm should refuse to install a module if one of its dependencies isn't satisfied, unless a &quot;force&quot; command is given by the user.  If the tools are helpful, they should also offer to install the dependencies.<div style="height: 1.00em;">
&#160;</div>
A synonym for &quot;requires&quot; is &quot;prereq&quot;, to help succour people transitioning from &quot;ExtUtils::MakeMaker&quot;.  The &quot;requires&quot; term is preferred, but the &quot;prereq&quot; term will remain valid in future distributions.<div style="height: 1.00em;">
&#160;</div>
See the documentation for &quot;PREREQUISITES&quot; in Module::Build::Authoring for the details of how requirements can be specified.</dd>
</dl>
<dl>
<dt>
script_files</dt>
<dd>
[version 0.18]<div style="height: 1.00em;">
&#160;</div>
An optional parameter specifying a set of files that should be installed as executable Perl scripts when the module is installed. May be given as an array reference of the files, as a hash reference whose keys are the files (and whose values will currently be ignored), as a string giving the name of a directory in which to find scripts, or as a string giving the name of a single script file.<div style="height: 1.00em;">
&#160;</div>
The default is to install any scripts found in a <i>bin</i> directory at the top level of the distribution, minus any keys of PL_files.<div style="height: 1.00em;">
&#160;</div>
For backward compatibility, you may use the parameter &quot;scripts&quot; instead of &quot;script_files&quot;.  Please consider this usage deprecated, though it will continue to exist for several version releases.</dd>
</dl>
<dl>
<dt>
share_dir</dt>
<dd>
[version 0.36]<div style="height: 1.00em;">
&#160;</div>
An optional parameter specifying directories of static data files to be installed as read-only files for use with File::ShareDir.  The &quot;share_dir&quot; property supports both distribution-level and module-level share files.<div style="height: 1.00em;">
&#160;</div>
The simplest use of &quot;share_dir&quot; is to set it to a directory name or an arrayref of directory names containing files to be installed in the distribution-level share directory.<div style="height: 1.00em;">
&#160;</div>
<br/>
  share_dir =&gt; 'share'<br/>
<div style="height: 1.00em;">
&#160;</div>
Alternatively, if &quot;share_dir&quot; is a hashref, it may have &quot;dist&quot; or &quot;module&quot; keys providing full flexibility in defining how share directories should be installed.<div style="height: 1.00em;">
&#160;</div>
<br/>
  share_dir =&gt; {<br/>
    dist =&gt; [ 'examples', 'more_examples' ],<br/>
    module =&gt; {<br/>
      Foo::Templates =&gt; ['share/html', 'share/text'],<br/>
      Foo::Config    =&gt; 'share/config',<br/>
    }<br/>
  }<br/>
<div style="height: 1.00em;">
&#160;</div>
If &quot;share_dir&quot; is set, then File::ShareDir will automatically be added to the &quot;requires&quot; hash.</dd>
</dl>
<dl>
<dt>
sign</dt>
<dd>
[version 0.16]<div style="height: 1.00em;">
&#160;</div>
If a true value is specified for this parameter, Module::Signature will be used (via the 'distsign' action) to create a SIGNATURE file for your distribution during the 'distdir' action, and to add the SIGNATURE file to the MANIFEST (therefore, don't add it yourself).<div style="height: 1.00em;">
&#160;</div>
The default value is false.  In the future, the default may change to true if you have &quot;Module::Signature&quot; installed on your system.</dd>
</dl>
<dl>
<dt>
test_files</dt>
<dd>
[version 0.23]<div style="height: 1.00em;">
&#160;</div>
An optional parameter specifying a set of files that should be used as &quot;Test::Harness&quot;-style regression tests to be run during the &quot;test&quot; action.  May be given as an array reference of the files, or as a hash reference whose keys are the files (and whose values will currently be ignored).  If the argument is given as a single string (not in an array reference), that string will be treated as a &quot;glob()&quot; pattern specifying the files to use.<div style="height: 1.00em;">
&#160;</div>
The default is to look for a <i>test.pl</i> script in the top-level directory of the distribution, and any files matching the glob pattern &quot;*.t&quot; in the  <i>t/</i> subdirectory.  If the &quot;recursive_test_files&quot; property is true, then the &quot;t/&quot; directory will be scanned recursively for &quot;*.t&quot; files.</dd>
</dl>
<dl>
<dt>
use_tap_harness</dt>
<dd>
[version 0.2808_03]<div style="height: 1.00em;">
&#160;</div>
An optional parameter indicating whether or not to use TAP::Harness for testing rather than Test::Harness. Defaults to false. If set to true, you must therefore be sure to add TAP::Harness as a requirement for your module in &quot;build_requires&quot;. Implicitly set to a true value if &quot;tap_harness_args&quot; is specified.</dd>
</dl>
<dl>
<dt>
tap_harness_args</dt>
<dd>
[version 0.2808_03]<div style="height: 1.00em;">
&#160;</div>
An optional parameter specifying parameters to be passed to TAP::Harness when running tests. Must be given as a hash reference of parameters; see the TAP::Harness documentation for details. Note that specifying this parameter will implicitly set &quot;use_tap_harness&quot; to a true value. You must therefore be sure to add TAP::Harness as a requirement for your module in &quot;build_requires&quot;.</dd>
</dl>
<dl>
<dt>
xs_files</dt>
<dd>
[version 0.19]<div style="height: 1.00em;">
&#160;</div>
Just like &quot;pm_files&quot;, but used for specifying the set of &quot;.xs&quot; files in your distribution.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
</div>
<dl>
<dt>
new_from_context(%args)</dt>
<dd>
[version 0.28]<div style="height: 1.00em;">
&#160;</div>
When called from a directory containing a <i>Build.PL</i> script (in other words, the base directory of a distribution), this method will run the  <i>Build.PL</i> and call &quot;resume()&quot; to return the resulting &quot;Module::Build&quot; object to the caller. Any key-value arguments given to &quot;new_from_context()&quot; are essentially like command line arguments given to the  <i>Build.PL</i> script, so for example you could pass &quot;verbose =&gt; 1&quot; to this method to turn on verbosity.</dd>
</dl>
<dl>
<dt>
<i>resume()</i></dt>
<dd>
[version 0.03]<div style="height: 1.00em;">
&#160;</div>
You'll probably never call this method directly, it's only called from the auto-generated &quot;Build&quot; script (and the &quot;new_from_context&quot; method).  The &quot;new()&quot; method is only called once, when the user runs &quot;perl Build.PL&quot;. Thereafter, when the user runs &quot;Build test&quot; or another action, the &quot;Module::Build&quot; object is created using the &quot;resume()&quot; method to re-instantiate with the settings given earlier to &quot;new()&quot;.</dd>
</dl>
<dl>
<dt>
<i>subclass()</i></dt>
<dd>
[version 0.06]<div style="height: 1.00em;">
&#160;</div>
This creates a new &quot;Module::Build&quot; subclass on the fly, as described in the &quot;SUBCLASSING&quot; in Module::Build::Authoring section.  The caller must provide either a &quot;class&quot; or &quot;code&quot; parameter, or both.  The &quot;class&quot; parameter indicates the name to use for the new subclass, and defaults to &quot;MyModuleBuilder&quot;.  The &quot;code&quot; parameter specifies Perl code to use as the body of the subclass.</dd>
</dl>
<dl>
<dt>
add_property</dt>
<dd>
[version 0.31]<div style="height: 1.00em;">
&#160;</div>
<br/>
  package 'My::Build';<br/>
  use base 'Module::Build';<br/>
  __PACKAGE__-&gt;add_property( 'pedantic' );<br/>
  __PACKAGE__-&gt;add_property( answer =&gt; 42 );<br/>
  __PACKAGE__-&gt;add_property(<br/>
     'epoch',<br/>
      default =&gt; sub { time },<br/>
      check   =&gt; sub {<br/>
          return 1 if /^\d+$/;<br/>
          shift-&gt;property_error( &quot;'$_' is not an epoch time&quot; );<br/>
          return 0;<br/>
      },<br/>
  );<br/>
<div style="height: 1.00em;">
&#160;</div>
Adds a property to a Module::Build class. Properties are those attributes of a Module::Build object which can be passed to the constructor and which have accessors to get and set them. All of the core properties, such as &quot;module_name&quot; and &quot;license&quot;, are defined using this class method.<div style="height: 1.00em;">
&#160;</div>
The first argument to &quot;add_property()&quot; is always the name of the property. The second argument can be either a default value for the property, or a list of key/value pairs. The supported keys are:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
&quot;default&quot;</dt>
<dd>
The default value. May optionally be specified as a code reference, in which case the return value from the execution of the code reference will be used. If you need the default to be a code reference, just use a code reference to return it, e.g.:<div style="height: 1.00em;">
&#160;</div>
<br/>
      default =&gt; sub { sub { ... } },<br/>
</dd>
</dl>
<dl>
<dt>
&quot;check&quot;</dt>
<dd>
A code reference that checks that a value specified for the property is valid. During the execution of the code reference, the new value will be included in the $_ variable. If the value is correct, the &quot;check&quot; code reference should return true. If the value is not correct, it sends an error message to &quot;property_error()&quot; and returns false.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">
&#160;</div>
When this method is called, a new property will be installed in the Module::Build class, and an accessor will be built to allow the property to be get or set on the build object.<div style="height: 1.00em;">
&#160;</div>
<br/>
  print $build-&gt;pedantic, $/;<br/>
  $build-&gt;pedantic(0);<br/>
<div style="height: 1.00em;">
&#160;</div>
If the default value is a hash reference, this generates a special-case accessor method, wherein individual key/value pairs may be set or fetched:<div style="height: 1.00em;">
&#160;</div>
<br/>
  print &quot;stuff{foo} is: &quot;, $build-&gt;stuff( 'foo' ), $/;<br/>
  $build-&gt;stuff( foo =&gt; 'bar' );<br/>
  print $build-&gt;stuff( 'foo' ), $/; # Outputs &quot;bar&quot;<br/>
<div style="height: 1.00em;">
&#160;</div>
Of course, you can still set the entire hash reference at once, as well:<div style="height: 1.00em;">
&#160;</div>
<br/>
  $build-&gt;stuff( { foo =&gt; 'bar', baz =&gt; 'yo' } );<br/>
<div style="height: 1.00em;">
&#160;</div>
In either case, if a &quot;check&quot; has been specified for the property, it will be applied to the entire hash. So the check code reference should look something like:<div style="height: 1.00em;">
&#160;</div>
<br/>
      check =&gt; sub {<br/>
            return 1 if defined $_ &amp;&amp; exists $_-&gt;{foo};<br/>
            shift-&gt;property_error(qq{Property &quot;stuff&quot; needs &quot;foo&quot;});<br/>
            return 0;<br/>
      },<br/>
</div>
<dl>
<dt>
property_error</dt>
<dd>
[version 0.31]</dd>
</dl>
</div>
<div class="subsection">
<h2>METHODS</h2><dl>
<dt>
add_build_element($type)</dt>
<dd>
[version 0.26]<div style="height: 1.00em;">
&#160;</div>
Adds a new type of entry to the build process.  Accepts a single string specifying its type-name.  There must also be a method defined to process things of that type, e.g. if you add a build element called 'foo', then you must also define a method called &quot;process_foo_files()&quot;.<div style="height: 1.00em;">
&#160;</div>
See also &quot;Adding new file types to the build process&quot; in Module::Build::Cookbook.</dd>
</dl>
<dl>
<dt>
add_to_cleanup(@files)</dt>
<dd>
[version 0.03]<div style="height: 1.00em;">
&#160;</div>
You may call &quot;$self-&gt;add_to_cleanup(@patterns)&quot; to tell &quot;Module::Build&quot; that certain files should be removed when the user performs the &quot;Build clean&quot; action.  The arguments to the method are patterns suitable for passing to Perl's &quot;glob()&quot; function, specified in either Unix format or the current machine's native format.  It's usually convenient to use Unix format when you hard-code the filenames (e.g. in  <i>Build.PL</i>) and the native format when the names are programmatically generated (e.g. in a testing script).<div style="height: 1.00em;">
&#160;</div>
I decided to provide a dynamic method of the $build object, rather than just use a static list of files named in the  <i>Build.PL</i>, because these static lists can get difficult to manage.  I usually prefer to keep the responsibility for registering temporary files close to the code that creates them.</dd>
</dl>
<dl>
<dt>
<i>args()</i></dt>
<dd>
[version 0.26]<div style="height: 1.00em;">
&#160;</div>
<br/>
  my $args_href = $build-&gt;args;<br/>
  my %args = $build-&gt;args;<br/>
  my $arg_value = $build-&gt;args($key);<br/>
  $build-&gt;args($key, $value);<br/>
<div style="height: 1.00em;">
&#160;</div>
This method is the preferred interface for retrieving the arguments passed via command line options to  <i>Build.PL</i> or <i>Build</i>, minus the Module-Build specific options.<div style="height: 1.00em;">
&#160;</div>
When called in in a scalar context with no arguments, this method returns a reference to the hash storing all of the arguments; in an array context, it returns the hash itself.  When passed a single argument, it returns the value stored in the args hash for that option key.  When called with two arguments, the second argument is assigned to the args hash under the key passed as the first argument.</dd>
</dl>
<dl>
<dt>
autosplit_file($from, $to)</dt>
<dd>
[version 0.28]<div style="height: 1.00em;">
&#160;</div>
Invokes the AutoSplit module on the $from file, sending the output to the &quot;lib/auto&quot; directory inside $to.  $to is typically the &quot;blib/&quot; directory.</dd>
</dl>
<dl>
<dt>
<i>base_dir()</i></dt>
<dd>
[version 0.14]<div style="height: 1.00em;">
&#160;</div>
Returns a string containing the root-level directory of this build, i.e. where the &quot;Build.PL&quot; script and the &quot;lib&quot; directory can be found.  This is usually the same as the current working directory, because the &quot;Build&quot; script will &quot;chdir()&quot; into this directory as soon as it begins execution.</dd>
</dl>
<dl>
<dt>
<i>build_requires()</i></dt>
<dd>
[version 0.21]<div style="height: 1.00em;">
&#160;</div>
Returns a hash reference indicating the &quot;build_requires&quot; prerequisites that were passed to the &quot;new()&quot; method.</dd>
</dl>
<dl>
<dt>
can_action( $action )</dt>
<dd>
Returns a reference to the method that defines $action, or false otherwise. This is handy for actions defined (or maybe not!) in subclasses.<div style="height: 1.00em;">
&#160;</div>
[version 0.32_xx]</dd>
</dl>
<dl>
<dt>
<i>cbuilder()</i></dt>
<dd>
[version 0.2809]<div style="height: 1.00em;">
&#160;</div>
Returns the internal ExtUtils::CBuilder object that can be used for compiling &amp; linking C code.  If no such object is available (e.g. if the system has no compiler installed) an exception will be thrown.</dd>
</dl>
<dl>
<dt>
check_installed_status($module, $version)</dt>
<dd>
[version 0.11]<div style="height: 1.00em;">
&#160;</div>
This method returns a hash reference indicating whether a version dependency on a certain module is satisfied.  The $module argument is given as a string like &quot;Data::Dumper&quot; or &quot;perl&quot;, and the $version argument can take any of the forms described in &quot;requires&quot; above.  This allows very fine-grained version checking.<div style="height: 1.00em;">
&#160;</div>
The returned hash reference has the following structure:<div style="height: 1.00em;">
&#160;</div>
<br/>
  {<br/>
   ok =&gt; $whether_the_dependency_is_satisfied,<br/>
   have =&gt; $version_already_installed,<br/>
   need =&gt; $version_requested, # Same as incoming $version argument<br/>
   message =&gt; $informative_error_message,<br/>
  }<br/>
<div style="height: 1.00em;">
&#160;</div>
If no version of $module is currently installed, the &quot;have&quot; value will be the string &quot;&lt;none&gt;&quot;.  Otherwise the &quot;have&quot; value will simply be the version of the installed module.  Note that this means that if $module is installed but doesn't define a version number, the &quot;have&quot; value will be &quot;undef&quot; - this is why we don't use &quot;undef&quot; for the case when $module isn't installed at all.<div style="height: 1.00em;">
&#160;</div>
This method may be called either as an object method (&quot;$build-&gt;check_installed_status($module, $version)&quot;) or as a class method (&quot;Module::Build-&gt;check_installed_status($module, $version)&quot;).</dd>
</dl>
<dl>
<dt>
check_installed_version($module, $version)</dt>
<dd>
[version 0.05]<div style="height: 1.00em;">
&#160;</div>
Like <i>check_installed_status()</i>, but simply returns true or false depending on whether module $module satisfies the dependency $version.<div style="height: 1.00em;">
&#160;</div>
If the check succeeds, the return value is the actual version of $module installed on the system.  This allows you to do the following:<div style="height: 1.00em;">
&#160;</div>
<br/>
  my $installed = $build-&gt;check_installed_version('DBI', '1.15');<br/>
  if ($installed) {<br/>
    print &quot;Congratulations, version $installed of DBI is installed.\n&quot;;<br/>
  } else {<br/>
    die &quot;Sorry, you must install DBI.\n&quot;;<br/>
  }<br/>
<div style="height: 1.00em;">
&#160;</div>
If the check fails, we return false and set $@ to an informative error message.<div style="height: 1.00em;">
&#160;</div>
If $version is any non-true value (notably zero) and any version of $module is installed, we return true.  In this case, if $module doesn't define a version, or if its version is zero, we return the special value &quot;0 but true&quot;, which is numerically zero, but logically true.<div style="height: 1.00em;">
&#160;</div>
In general you might prefer to use &quot;check_installed_status&quot; if you need detailed information, or this method if you just need a yes/no answer.</dd>
</dl>
<dl>
<dt>
compare_versions($v1, $op, $v2)</dt>
<dd>
[version 0.28]<div style="height: 1.00em;">
&#160;</div>
Compares two module versions $v1 and $v2 using the operator $op, which should be one of Perl's numeric operators like &quot;!=&quot; or &quot;&gt;=&quot; or the like.  We do at least a halfway-decent job of handling versions that aren't strictly numeric, like &quot;0.27_02&quot;, but exotic stuff will likely cause problems.<div style="height: 1.00em;">
&#160;</div>
In the future, the guts of this method might be replaced with a call out to &quot;version.pm&quot;.</dd>
</dl>
<dl>
<dt>
config($key)</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
config($key, $value)</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>config()</i> [deprecated]</dt>
<dd>
[version 0.22]<div style="height: 1.00em;">
&#160;</div>
With a single argument $key, returns the value associated with that key in the &quot;Config.pm&quot; hash, including any changes the author or user has specified.<div style="height: 1.00em;">
&#160;</div>
With $key and $value arguments, sets the value for future callers of &quot;config($key)&quot;.<div style="height: 1.00em;">
&#160;</div>
With no arguments, returns a hash reference containing all such key-value pairs.  This usage is deprecated, though, because it's a resource hog and violates encapsulation.</dd>
</dl>
<dl>
<dt>
config_data($name)</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
config_data($name =&gt; $value)</dt>
<dd>
[version 0.26]<div style="height: 1.00em;">
&#160;</div>
With a single argument, returns the value of the configuration variable $name.  With two arguments, sets the given configuration variable to the given value.  The value may be any Perl scalar that's serializable with &quot;Data::Dumper&quot;.  For instance, if you write a module that can use a MySQL or PostgreSQL back-end, you might create configuration variables called &quot;mysql_connect&quot; and &quot;postgres_connect&quot;, and set each to an array of connection parameters for &quot;DBI-&gt;connect()&quot;.<div style="height: 1.00em;">
&#160;</div>
Configuration values set in this way using the Module::Build object will be available for querying during the build/test process and after installation via the generated &quot;...::ConfigData&quot; module, as &quot;...::ConfigData-&gt;config($name)&quot;.<div style="height: 1.00em;">
&#160;</div>
The <i>feature()</i> and &quot;config_data()&quot; methods represent Module::Build's main support for configuration of installed modules. See also &quot;SAVING CONFIGURATION INFORMATION&quot; in Module::Build::Authoring.</dd>
</dl>
<dl>
<dt>
<i>conflicts()</i></dt>
<dd>
[version 0.21]<div style="height: 1.00em;">
&#160;</div>
Returns a hash reference indicating the &quot;conflicts&quot; prerequisites that were passed to the &quot;new()&quot; method.</dd>
</dl>
<dl>
<dt>
contains_pod($file) [deprecated]</dt>
<dd>
[version 0.20]<div style="height: 1.00em;">
&#160;</div>
[Deprecated] Please see Module::Build::ModuleInfo instead.<div style="height: 1.00em;">
&#160;</div>
Returns true if the given file appears to contain POD documentation. Currently this checks whether the file has a line beginning with '=pod', '=head', or '=item', but the exact semantics may change in the future.</dd>
</dl>
<dl>
<dt>
copy_if_modified(%parameters)</dt>
<dd>
[version 0.19]<div style="height: 1.00em;">
&#160;</div>
Takes the file in the &quot;from&quot; parameter and copies it to the file in the &quot;to&quot; parameter, or the directory in the &quot;to_dir&quot; parameter, if the file has changed since it was last copied (or if it doesn't exist in the new location).  By default the entire directory structure of &quot;from&quot; will be copied into &quot;to_dir&quot;; an optional &quot;flatten&quot; parameter will copy into &quot;to_dir&quot; without doing so.<div style="height: 1.00em;">
&#160;</div>
Returns the path to the destination file, or &quot;undef&quot; if nothing needed to be copied.<div style="height: 1.00em;">
&#160;</div>
Any directories that need to be created in order to perform the copying will be automatically created.<div style="height: 1.00em;">
&#160;</div>
The destination file is set to read-only. If the source file has the executable bit set, then the destination file will be made executable.</dd>
</dl>
<dl>
<dt>
<i>create_build_script()</i></dt>
<dd>
[version 0.05]<div style="height: 1.00em;">
&#160;</div>
Creates an executable script called &quot;Build&quot; in the current directory that will be used to execute further user actions.  This script is roughly analogous (in function, not in form) to the Makefile created by &quot;ExtUtils::MakeMaker&quot;.  This method also creates some temporary data in a directory called &quot;_build/&quot;.  Both of these will be removed when the &quot;realclean&quot; action is performed.<div style="height: 1.00em;">
&#160;</div>
Among the files created in &quot;_build/&quot; is a <i>_build/prereqs</i> file containing the set of prerequisites for this distribution, as a hash of hashes.  This file may be &quot;eval()&quot;-ed to obtain the authoritative set of prerequisites, which might be different from the contents of  <i>META.yml</i> (because <i>Build.PL</i> might have set them dynamically). But fancy developers take heed: do not put any fancy custom runtime code in the  <i>_build/prereqs</i> file, leave it as a static declaration containing only strings and numbers.  Similarly, do not alter the structure of the internal &quot;$self-&gt;{properties}{requires}&quot; (etc.) data members, because that's where this data comes from.</dd>
</dl>
<dl>
<dt>
<i>current_action()</i></dt>
<dd>
[version 0.28]<div style="height: 1.00em;">
&#160;</div>
Returns the name of the currently-running action, such as &quot;build&quot; or &quot;test&quot;.  This action is not necessarily the action that was originally invoked by the user.  For example, if the user invoked the &quot;test&quot; action,  <i>current_action()</i> would initially return &quot;test&quot;.  However, action &quot;test&quot; depends on action &quot;code&quot;, so  <i>current_action()</i> will return &quot;code&quot; while that dependency is being executed.  Once that action has completed,  <i>current_action()</i> will again return &quot;test&quot;.<div style="height: 1.00em;">
&#160;</div>
If you need to know the name of the original action invoked by the user, see &quot; <i>invoked_action()</i>&quot; below.</dd>
</dl>
<dl>
<dt>
depends_on(@actions)</dt>
<dd>
[version 0.28]<div style="height: 1.00em;">
&#160;</div>
Invokes the named action or list of actions in sequence.  Using this method is preferred to calling the action explicitly because it performs some internal record-keeping, and it ensures that the same action is not invoked multiple times (note: in future versions of Module::Build it's conceivable that this run-only-once mechanism will be changed to something more intelligent).<div style="height: 1.00em;">
&#160;</div>
Note that the name of this method is something of a misnomer; it should really be called something like &quot;invoke_actions_unless_already_invoked()&quot; or something, but for better or worse (perhaps better!) we were still thinking in &quot;make&quot;-like dependency terms when we created this method.<div style="height: 1.00em;">
&#160;</div>
See also <i>dispatch()</i>.  The main distinction between the two is that &quot;depends_on()&quot; is meant to call an action from inside another action, whereas &quot;dispatch()&quot; is meant to set the very top action in motion.</dd>
</dl>
<dl>
<dt>
dir_contains($first_dir, $second_dir)</dt>
<dd>
[version 0.28]<div style="height: 1.00em;">
&#160;</div>
Returns true if the first directory logically contains the second directory.  This is just a convenience function because &quot;File::Spec&quot; doesn't really provide an easy way to figure this out (but &quot;Path::Class&quot; does...).</dd>
</dl>
<dl>
<dt>
dispatch($action, %args)</dt>
<dd>
[version 0.03]<div style="height: 1.00em;">
&#160;</div>
Invokes the build action $action.  Optionally, a list of options and their values can be passed in.  This is equivalent to invoking an action at the command line, passing in a list of options.<div style="height: 1.00em;">
&#160;</div>
Custom options that have not been registered must be passed in as a hash reference in a key named &quot;args&quot;:<div style="height: 1.00em;">
&#160;</div>
<br/>
  $build-&gt;dispatch('foo', verbose =&gt; 1, args =&gt; { my_option =&gt; 'value' });<br/>
<div style="height: 1.00em;">
&#160;</div>
This method is intended to be used to programmatically invoke build actions, e.g. by applications controlling Module::Build-based builds rather than by subclasses.<div style="height: 1.00em;">
&#160;</div>
See also <i>depends_on()</i>.  The main distinction between the two is that &quot;depends_on()&quot; is meant to call an action from inside another action, whereas &quot;dispatch()&quot; is meant to set the very top action in motion.</dd>
</dl>
<dl>
<dt>
<i>dist_dir()</i></dt>
<dd>
[version 0.28]<div style="height: 1.00em;">
&#160;</div>
Returns the name of the directory that will be created during the &quot;dist&quot; action.  The name is derived from the &quot;dist_name&quot; and &quot;dist_version&quot; properties.</dd>
</dl>
<dl>
<dt>
<i>dist_name()</i></dt>
<dd>
[version 0.21]<div style="height: 1.00em;">
&#160;</div>
Returns the name of the current distribution, as passed to the &quot;new()&quot; method in a &quot;dist_name&quot; or modified &quot;module_name&quot; parameter.</dd>
</dl>
<dl>
<dt>
<i>dist_version()</i></dt>
<dd>
[version 0.21]<div style="height: 1.00em;">
&#160;</div>
Returns the version of the current distribution, as determined by the &quot;new()&quot; method from a &quot;dist_version&quot;, &quot;dist_version_from&quot;, or &quot;module_name&quot; parameter.</dd>
</dl>
<dl>
<dt>
do_system($cmd, @args)</dt>
<dd>
[version 0.21]<div style="height: 1.00em;">
&#160;</div>
This is a fairly simple wrapper around Perl's &quot;system()&quot; built-in command.  Given a command and an array of optional arguments, this method will print the command to &quot;STDOUT&quot;, and then execute it using Perl's &quot;system()&quot;.  It returns true or false to indicate success or failure (the opposite of how &quot;system()&quot; works, but more intuitive).<div style="height: 1.00em;">
&#160;</div>
Note that if you supply a single argument to &quot;do_system()&quot;, it will/may be processed by the system's shell, and any special characters will do their special things.  If you supply multiple arguments, no shell will get involved and the command will be executed directly.</dd>
</dl>
<dl>
<dt>
feature($name)</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
feature($name =&gt; $value)</dt>
<dd>
[version 0.26]<div style="height: 1.00em;">
&#160;</div>
With a single argument, returns true if the given feature is set. With two arguments, sets the given feature to the given boolean value. In this context, a &quot;feature&quot; is any optional functionality of an installed module.  For instance, if you write a module that could optionally support a MySQL or PostgreSQL backend, you might create features called &quot;mysql_support&quot; and &quot;postgres_support&quot;, and set them to true/false depending on whether the user has the proper databases installed and configured.<div style="height: 1.00em;">
&#160;</div>
Features set in this way using the Module::Build object will be available for querying during the build/test process and after installation via the generated &quot;...::ConfigData&quot; module, as &quot;...::ConfigData-&gt;feature($name)&quot;.<div style="height: 1.00em;">
&#160;</div>
The &quot;feature()&quot; and &quot;config_data()&quot; methods represent Module::Build's main support for configuration of installed modules. See also &quot;SAVING CONFIGURATION INFORMATION&quot; in Module::Build::Authoring.</dd>
</dl>
<dl>
<dt>
fix_shebang_line(@files)</dt>
<dd>
[version 0.??]<div style="height: 1.00em;">
&#160;</div>
Modify any &quot;shebang&quot; line in the specified files to use the path to the perl executable being used for the current build.  Files are modified in-place.  The existing shebang line must have a command that contains &quot;&quot;perl&quot;&quot;; arguments to the command do not count.  In particular, this means that the use of &quot;#!/usr/bin/env perl&quot; will not be changed.<div style="height: 1.00em;">
&#160;</div>
For an explanation of shebang lines, see &lt;http://en.wikipedia.org/wiki/Shebang_%28Unix%29&gt;.</dd>
</dl>
<dl>
<dt>
<i>have_c_compiler()</i></dt>
<dd>
[version 0.21]<div style="height: 1.00em;">
&#160;</div>
Returns true if the current system seems to have a working C compiler. We currently determine this by attempting to compile a simple C source file and reporting whether the attempt was successful.</dd>
</dl>
<dl>
<dt>
<i>install_base_relpaths()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
install_base_relpaths($type)</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
install_base_relpaths($type =&gt; $path)</dt>
<dd>
[version 0.28]<div style="height: 1.00em;">
&#160;</div>
Set or retrieve the relative paths that are appended to &quot;install_base&quot; for any installable element. This is useful if you want to set the relative install path for custom build elements.<div style="height: 1.00em;">
&#160;</div>
With no argument, it returns a reference to a hash containing all elements and their respective values. This hash should not be modified directly; use the multiple argument below form to change values.<div style="height: 1.00em;">
&#160;</div>
The single argument form returns the value associated with the element $type.<div style="height: 1.00em;">
&#160;</div>
The multiple argument form allows you to set the paths for element types. $value must be a relative path using Unix-like paths.  (A series of directories separated by slashes, e.g. &quot;foo/bar&quot;.)  The return value is a localized path based on $value.<div style="height: 1.00em;">
&#160;</div>
Assigning the value &quot;undef&quot; to an element causes it to be removed.</dd>
</dl>
<dl>
<dt>
install_destination($type)</dt>
<dd>
[version 0.28]<div style="height: 1.00em;">
&#160;</div>
Returns the directory in which items of type $type (e.g. &quot;lib&quot;, &quot;arch&quot;, &quot;bin&quot;, or anything else returned by the &quot; <i>install_types()</i>&quot; method) will be installed during the &quot;install&quot; action.  Any settings for &quot;install_path&quot;, &quot;install_base&quot;, and &quot;prefix&quot; are taken into account when determining the return value.</dd>
</dl>
<dl>
<dt>
<i>install_path()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
install_path($type)</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
install_path($type =&gt; $path)</dt>
<dd>
[version 0.28]<div style="height: 1.00em;">
&#160;</div>
Set or retrieve paths for specific installable elements. This is useful when you want to examine any explicit install paths specified by the user on the command line, or if you want to set the install path for a specific installable element based on another attribute like &quot;install_base()&quot;.<div style="height: 1.00em;">
&#160;</div>
With no argument, it returns a reference to a hash containing all elements and their respective values. This hash should not be modified directly; use the multiple argument below form to change values.<div style="height: 1.00em;">
&#160;</div>
The single argument form returns the value associated with the element $type.<div style="height: 1.00em;">
&#160;</div>
The multiple argument form allows you to set the paths for element types. The supplied $path should be an absolute path to install elements of $type.  The return value is $path.<div style="height: 1.00em;">
&#160;</div>
Assigning the value &quot;undef&quot; to an element causes it to be removed.</dd>
</dl>
<dl>
<dt>
<i>install_types()</i></dt>
<dd>
[version 0.28]<div style="height: 1.00em;">
&#160;</div>
Returns a list of installable types that this build knows about. These types each correspond to the name of a directory in  <i>blib/</i>, and the list usually includes items such as &quot;lib&quot;, &quot;arch&quot;, &quot;bin&quot;, &quot;script&quot;, &quot;libdoc&quot;, &quot;bindoc&quot;, and if HTML documentation is to be built, &quot;libhtml&quot; and &quot;binhtml&quot;.  Other user-defined types may also exist.</dd>
</dl>
<dl>
<dt>
<i>invoked_action()</i></dt>
<dd>
[version 0.28]<div style="height: 1.00em;">
&#160;</div>
This is the name of the original action invoked by the user.  This value is set when the user invokes  <i>Build.PL</i>, the <i>Build</i> script, or programmatically through the  <i>dispatch()</i> method.  It does not change as sub-actions are executed as dependencies are evaluated.<div style="height: 1.00em;">
&#160;</div>
To get the name of the currently executing dependency, see &quot; <i>current_action()</i>&quot; above.</dd>
</dl>
<dl>
<dt>
<i>notes()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
notes($key)</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
notes($key =&gt; $value)</dt>
<dd>
[version 0.20]<div style="height: 1.00em;">
&#160;</div>
The &quot;notes()&quot; value allows you to store your own persistent information about the build, and to share that information among different entities involved in the build.  See the example in the &quot;current()&quot; method.<div style="height: 1.00em;">
&#160;</div>
The &quot;notes()&quot; method is essentially a glorified hash access.  With no arguments, &quot;notes()&quot; returns the entire hash of notes.  With one argument, &quot;notes($key)&quot; returns the value associated with the given key.  With two arguments, &quot;notes($key, $value)&quot; sets the value associated with the given key to $value and returns the new value.<div style="height: 1.00em;">
&#160;</div>
The lifetime of the &quot;notes&quot; data is for &quot;a build&quot; - that is, the &quot;notes&quot; hash is created when &quot;perl Build.PL&quot; is run (or when the &quot;new()&quot; method is run, if the Module::Build Perl API is being used instead of called from a shell), and lasts until &quot;perl Build.PL&quot; is run again or the &quot;clean&quot; action is run.</dd>
</dl>
<dl>
<dt>
<i>orig_dir()</i></dt>
<dd>
[version 0.28]<div style="height: 1.00em;">
&#160;</div>
Returns a string containing the working directory that was in effect before the  <i>Build</i> script <i>chdir()</i>-ed into the &quot;base_dir&quot;.  This might be useful for writing wrapper tools that might need to  <i>chdir()</i> back out.</dd>
</dl>
<dl>
<dt>
<i>os_type()</i></dt>
<dd>
[version 0.04]<div style="height: 1.00em;">
&#160;</div>
If you're subclassing Module::Build and some code needs to alter its behavior based on the current platform, you may only need to know whether you're running on Windows, Unix, MacOS, VMS, etc., and not the fine-grained value of Perl's $^O variable.  The &quot;os_type()&quot; method will return a string like &quot;Windows&quot;, &quot;Unix&quot;, &quot;MacOS&quot;, &quot;VMS&quot;, or whatever is appropriate.  If you're running on an unknown platform, it will return &quot;undef&quot; - there shouldn't be many unknown platforms though.</dd>
</dl>
<dl>
<dt>
<i>is_vmsish()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>is_windowsish()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>is_unixish()</i></dt>
<dd>
Convenience functions that return a boolean value indicating whether this platform behaves respectively like VMS, Windows, or Unix.  For arbitrary reasons other platforms don't get their own such functions, at least not yet.</dd>
</dl>
<dl>
<dt>
<i>prefix_relpaths()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
prefix_relpaths($installdirs)</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
prefix_relpaths($installdirs, $type)</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
prefix_relpaths($installdirs, $type =&gt; $path)</dt>
<dd>
[version 0.28]<div style="height: 1.00em;">
&#160;</div>
Set or retrieve the relative paths that are appended to &quot;prefix&quot; for any installable element.  This is useful if you want to set the relative install path for custom build elements.<div style="height: 1.00em;">
&#160;</div>
With no argument, it returns a reference to a hash containing all elements and their respective values as defined by the current &quot;installdirs&quot; setting.<div style="height: 1.00em;">
&#160;</div>
With a single argument, it returns a reference to a hash containing all elements and their respective values as defined by $installdirs.<div style="height: 1.00em;">
&#160;</div>
The hash returned by the above calls should not be modified directly; use the three-argument below form to change values.<div style="height: 1.00em;">
&#160;</div>
The two argument form returns the value associated with the element $type.<div style="height: 1.00em;">
&#160;</div>
The multiple argument form allows you to set the paths for element types. $value must be a relative path using Unix-like paths.  (A series of directories separated by slashes, e.g. &quot;foo/bar&quot;.)  The return value is a localized path based on $value.<div style="height: 1.00em;">
&#160;</div>
Assigning the value &quot;undef&quot; to an element causes it to be removed.</dd>
</dl>
<dl>
<dt>
<i>get_metadata()</i></dt>
<dd>
[version 0.36]<div style="height: 1.00em;">
&#160;</div>
This method returns a hash reference of metadata that can be used to create a YAML datastream. It is provided for authors to override or customize the fields of  <i>META.yml</i>.   E.g.<div style="height: 1.00em;">
&#160;</div>
<br/>
  package My::Builder;<br/>
  use base 'Module::Build';<br/>
<br/>
  sub get_metadata {<br/>
    my $self, @args = @_;<br/>
    my $data = $self-&gt;SUPER::get_metadata(@args);<br/>
    $data-&gt;{custom_field} = 'foo';<br/>
    return $data;<br/>
  }<br/>
<div style="height: 1.00em;">
&#160;</div>
Valid arguments include:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;fatal&quot; -- indicates whether missing required metadata fields should be a fatal error or not.  For META creation, it generally should, but for MYMETA creation for end-users, it should not be fatal.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;auto&quot; -- indicates whether any necessary configure_requires should be automatically added.  This is used in META creation.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">
&#160;</div>
This method is a wrapper around the old prepare_metadata API now that we no longer use YAML::Node to hold metadata.</div>
<dl>
<dt>
<i>prepare_metadata()</i> [deprecated]</dt>
<dd>
[version 0.36]<div style="height: 1.00em;">
&#160;</div>
[Deprecated] As of 0.36, authors should use &quot;get_metadata&quot; instead.  This method is preserved for backwards compatibility only.<div style="height: 1.00em;">
&#160;</div>
It takes three positional arguments: a hashref (to which metadata will be added), an optional arrayref (to which metadata keys will be added in order if the arrayref exists), and a hashref of arguments (as provided to get_metadata). The latter argument is new as of 0.36.  Earlier versions are always fatal on errors.<div style="height: 1.00em;">
&#160;</div>
Prior to version 0.36, this method took a YAML::Node as an argument to hold assembled metadata.</dd>
</dl>
<dl>
<dt>
<i>prereq_failures()</i></dt>
<dd>
[version 0.11]<div style="height: 1.00em;">
&#160;</div>
Returns a data structure containing information about any failed prerequisites (of any of the types described above), or &quot;undef&quot; if all prerequisites are met.<div style="height: 1.00em;">
&#160;</div>
The data structure returned is a hash reference.  The top level keys are the type of prerequisite failed, one of &quot;requires&quot;, &quot;build_requires&quot;, &quot;conflicts&quot;, or &quot;recommends&quot;.  The associated values are hash references whose keys are the names of required (or conflicting) modules.  The associated values of those are hash references indicating some information about the failure.  For example:<div style="height: 1.00em;">
&#160;</div>
<br/>
  {<br/>
   have =&gt; '0.42',<br/>
   need =&gt; '0.59',<br/>
   message =&gt; 'Version 0.42 is installed, but we need version 0.59',<br/>
  }<br/>
<div style="height: 1.00em;">
&#160;</div>
or<div style="height: 1.00em;">
&#160;</div>
<br/>
  {<br/>
   have =&gt; '&lt;none&gt;',<br/>
   need =&gt; '0.59',<br/>
   message =&gt; 'Prerequisite Foo isn't installed',<br/>
  }<br/>
<div style="height: 1.00em;">
&#160;</div>
This hash has the same structure as the hash returned by the &quot;check_installed_status()&quot; method, except that in the case of &quot;conflicts&quot; dependencies we change the &quot;need&quot; key to &quot;conflicts&quot; and construct a proper message.<div style="height: 1.00em;">
&#160;</div>
Examples:<div style="height: 1.00em;">
&#160;</div>
<br/>
  # Check a required dependency on Foo::Bar<br/>
  if ( $build-&gt;prereq_failures-&gt;{requires}{Foo::Bar} ) { ...<br/>
<br/>
  # Check whether there were any failures<br/>
  if ( $build-&gt;prereq_failures ) { ...<br/>
<br/>
  # Show messages for all failures<br/>
  my $failures = $build-&gt;prereq_failures;<br/>
  while (my ($type, $list) = each %$failures) {<br/>
    while (my ($name, $hash) = each %$list) {<br/>
      print &quot;Failure for $name: $hash-&gt;{message}\n&quot;;<br/>
    }<br/>
  }<br/>
</dd>
</dl>
<dl>
<dt>
<i>prereq_data()</i></dt>
<dd>
[version 0.32]<div style="height: 1.00em;">
&#160;</div>
Returns a reference to a hash describing all prerequisites.  The keys of the hash will be the various prerequisite types ('requires', 'build_requires', 'configure_requires', 'recommends', or 'conflicts') and the values will be references to hashes of module names and version numbers.  Only prerequisites types that are defined will be included.  The &quot;prereq_data&quot; action is just a thin wrapper around the &quot;prereq_data()&quot; method and dumps the hash as a string that can be loaded using &quot;eval()&quot;.</dd>
</dl>
<dl>
<dt>
<i>prereq_report()</i></dt>
<dd>
[version 0.28]<div style="height: 1.00em;">
&#160;</div>
Returns a human-readable (table-form) string showing all prerequisites, the versions required, and the versions actually installed.  This can be useful for reviewing the configuration of your system prior to a build, or when compiling data to send for a bug report.  The &quot;prereq_report&quot; action is just a thin wrapper around the &quot;prereq_report()&quot; method.</dd>
</dl>
<dl>
<dt>
prompt($message, $default)</dt>
<dd>
[version 0.12]<div style="height: 1.00em;">
&#160;</div>
Asks the user a question and returns their response as a string.  The first argument specifies the message to display to the user (for example, &quot;Where do you keep your money?&quot;).  The second argument, which is optional, specifies a default answer (for example, &quot;wallet&quot;).  The user will be asked the question once.<div style="height: 1.00em;">
&#160;</div>
If &quot;prompt()&quot; detects that it is not running interactively and there is nothing on STDIN or if the PERL_MM_USE_DEFAULT environment variable is set to true, the $default will be used without prompting.<div style="height: 1.00em;">
&#160;</div>
To prevent automated processes from blocking, the user must either set PERL_MM_USE_DEFAULT or attach something to STDIN (this can be a pipe/file containing a scripted set of answers or /dev/null.)<div style="height: 1.00em;">
&#160;</div>
If no $default is provided an empty string will be used instead.  In non-interactive mode, the absence of $default is an error (though explicitly passing &quot;undef()&quot; as the default is valid as of 0.27.)<div style="height: 1.00em;">
&#160;</div>
This method may be called as a class or object method.</dd>
</dl>
<dl>
<dt>
<i>recommends()</i></dt>
<dd>
[version 0.21]<div style="height: 1.00em;">
&#160;</div>
Returns a hash reference indicating the &quot;recommends&quot; prerequisites that were passed to the &quot;new()&quot; method.</dd>
</dl>
<dl>
<dt>
<i>requires()</i></dt>
<dd>
[version 0.21]<div style="height: 1.00em;">
&#160;</div>
Returns a hash reference indicating the &quot;requires&quot; prerequisites that were passed to the &quot;new()&quot; method.</dd>
</dl>
<dl>
<dt>
rscan_dir($dir, $pattern)</dt>
<dd>
[version 0.28]<div style="height: 1.00em;">
&#160;</div>
Uses &quot;File::Find&quot; to traverse the directory $dir, returning a reference to an array of entries matching $pattern.  $pattern may either be a regular expression (using &quot;qr//&quot; or just a plain string), or a reference to a subroutine that will return true for wanted entries.  If $pattern is not given, all entries will be returned.<div style="height: 1.00em;">
&#160;</div>
Examples:<div style="height: 1.00em;">
&#160;</div>
<br/>
 # All the *.pm files in lib/<br/>
 $m-&gt;rscan_dir('lib', qr/\.pm$/)<br/>
<br/>
 # All the files in blib/ that aren't *.html files<br/>
 $m-&gt;rscan_dir('blib', sub {-f $_ and not /\.html$/});<br/>
<br/>
 # All the files in t/<br/>
 $m-&gt;rscan_dir('t');<br/>
</dd>
</dl>
<dl>
<dt>
<i>runtime_params()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
runtime_params($key)</dt>
<dd>
[version 0.28]<div style="height: 1.00em;">
&#160;</div>
The &quot;runtime_params()&quot; method stores the values passed on the command line for valid properties (that is, any command line options for which &quot;valid_property()&quot; returns a true value).  The value on the command line may override the default value for a property, as well as any value specified in a call to &quot;new()&quot;.  This allows you to programmatically tell if &quot;perl Build.PL&quot; or any execution of &quot;./Build&quot; had command line options specified that override valid properties.<div style="height: 1.00em;">
&#160;</div>
The &quot;runtime_params()&quot; method is essentially a glorified read-only hash.  With no arguments, &quot;runtime_params()&quot; returns the entire hash of properties specified on the command line.  With one argument, &quot;runtime_params($key)&quot; returns the value associated with the given key.<div style="height: 1.00em;">
&#160;</div>
The lifetime of the &quot;runtime_params&quot; data is for &quot;a build&quot; - that is, the &quot;runtime_params&quot; hash is created when &quot;perl Build.PL&quot; is run (or when the &quot;new()&quot; method is called, if the Module::Build Perl API is being used instead of called from a shell), and lasts until &quot;perl Build.PL&quot; is run again or the &quot;clean&quot; action is run.</dd>
</dl>
<dl>
<dt>
<i>script_files()</i></dt>
<dd>
[version 0.18]<div style="height: 1.00em;">
&#160;</div>
Returns a hash reference whose keys are the perl script files to be installed, if any.  This corresponds to the &quot;script_files&quot; parameter to the &quot;new()&quot; method.  With an optional argument, this parameter may be set dynamically.<div style="height: 1.00em;">
&#160;</div>
For backward compatibility, the &quot;scripts()&quot; method does exactly the same thing as &quot;script_files()&quot;.  &quot;scripts()&quot; is deprecated, but it will stay around for several versions to give people time to transition.</dd>
</dl>
<dl>
<dt>
up_to_date($source_file, $derived_file)</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
up_to_date(\@source_files, \@derived_files)</dt>
<dd>
[version 0.20]<div style="height: 1.00em;">
&#160;</div>
This method can be used to compare a set of source files to a set of derived files.  If any of the source files are newer than any of the derived files, it returns false.  Additionally, if any of the derived files do not exist, it returns false.  Otherwise it returns true.<div style="height: 1.00em;">
&#160;</div>
The arguments may be either a scalar or an array reference of file names.</dd>
</dl>
<dl>
<dt>
y_n($message, $default)</dt>
<dd>
[version 0.12]<div style="height: 1.00em;">
&#160;</div>
Asks the user a yes/no question using &quot;prompt()&quot; and returns true or false accordingly.  The user will be asked the question repeatedly until they give an answer that looks like &quot;yes&quot; or &quot;no&quot;.<div style="height: 1.00em;">
&#160;</div>
The first argument specifies the message to display to the user (for example, &quot;Shall I invest your money for you?&quot;), and the second argument specifies the default answer (for example, &quot;y&quot;).<div style="height: 1.00em;">
&#160;</div>
Note that the default is specified as a string like &quot;y&quot; or &quot;n&quot;, and the return value is a Perl boolean value like 1 or 0.  I thought about this for a while and this seemed like the most useful way to do it.<div style="height: 1.00em;">
&#160;</div>
This method may be called as a class or object method.</dd>
</dl>
</div>
<div class="subsection">
<h2>Autogenerated Accessors</h2> In addition to the aforementioned methods, there are also some get/set accessor methods for the following properties:<dl>
<dt>
<i>PL_files()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>allow_mb_mismatch()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>auto_configure_requires()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>autosplit()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>base_dir()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>bindoc_dirs()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>blib()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>build_bat()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>build_class()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>build_elements()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>build_requires()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>build_script()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>bundle_inc()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>bundle_inc_preload()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>c_source()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>config_dir()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>configure_requires()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>conflicts()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>cpan_client()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>create_license()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>create_makefile_pl()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>create_packlist()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>create_readme()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>debug()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>debugger()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>destdir()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>dynamic_config()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>get_options()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>html_css()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>include_dirs()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>install_base()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>installdirs()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>libdoc_dirs()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>license()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>magic_number()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>mb_version()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>meta_add()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>meta_merge()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>metafile()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>metafile2()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>module_name()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>mymetafile()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>mymetafile2()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>needs_compiler()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>orig_dir()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>perl()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>pm_files()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>pod_files()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>pollute()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>prefix()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>prereq_action_types()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>program_name()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>quiet()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>recommends()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>recurse_into()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>recursive_test_files()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>requires()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>scripts()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>sign()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>tap_harness_args()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>test_file_exts()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>use_rcfile()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>use_tap_harness()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>verbose()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>xs_files()</i></dt>
<dd>
</dd>
</dl>
</div>
</div>
<div class="section">
<h1>MODULE METADATA</h1> If you would like to add other useful metadata, &quot;Module::Build&quot; supports this with the &quot;meta_add&quot; and &quot;meta_merge&quot; arguments to &quot; <i>new()</i>&quot;. The authoritative list of supported metadata can be found at CPAN::META::Spec but for convenience - here are a few of the more useful ones:<dl>
<dt>
keywords</dt>
<dd>
For describing the distribution using keyword (or &quot;tags&quot;) in order to make CPAN.org indexing and search more efficient and useful.</dd>
</dl>
<dl>
<dt>
resources</dt>
<dd>
A list of additional resources available for users of the distribution. This can include links to a homepage on the web, a bug tracker, the repository location, and even a subscription page for the distribution mailing list.</dd>
</dl>
</div>
<div class="section">
<h1>AUTHOR</h1> Ken Williams &lt;kwilliams@cpan.org&gt;</div>
<div class="section">
<h1>COPYRIGHT</h1> Copyright (c) 2001-2006 Ken Williams.  All rights reserved.<div class="spacer">
</div>
This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</div>
<div class="section">
<h1>SEE ALSO</h1>  <i>perl</i>(1), Module::Build(3), Module::Build::Authoring(3), Module::Build::Cookbook(3), ExtUtils::MakeMaker(3)<div class="spacer">
</div>
<i>META.yml</i> Specification: CPAN::META::Spec</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-09-19</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

