<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
COLOR(3TIFF)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
COLOR(3TIFF)</td>
<td class="head-vol">
</td>
<td class="head-rtitle">
COLOR(3TIFF)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> TIFFYCbCrToRGBInit, TIFFYCbCrtoRGB, TIFFCIELabToRGBInit, TIFFCIELabToXYZ, TIFFXYZToRGB - color conversion routines.</div>
<div class="section">
<h1>SYNOPSIS</h1> <b>#include &lt;tiffio.h&gt;</b><div style="height: 1.00em;">
&#160;</div>
<b>int TIFFYCbCrToRGBInit(TIFFYCbCrToRGB *</b><i>ycbcr</i><b>, float *</b><i>luma</i><b>, float *</b><i>refBlackWhite&quot;</i><b>);&quot;</b><div style="height: 0.00em;">
&#160;</div>
<b>void TIFFYCbCrtoRGB(TIFFYCbCrToRGB *</b><i>ycbcr</i><b>, uint32 </b><i>Y</i><b>, int32 </b><i>Cb</i><b>, int32 </b><i>Cr</i><b>, uint32 *</b><i>R</i><b>, uint32 *</b><i>G</i><b>, uint32 *</b><i>B</i><b> );</b><div style="height: 1.00em;">
&#160;</div>
<b>int TIFFCIELabToRGBInit(TIFFCIELabToRGB *</b><i>cielab</i><b>, TIFFDisplay *</b><i>display</i><b>, float *</b><i>refWhite</i><b>);</b><div style="height: 0.00em;">
&#160;</div>
<b>void TIFFCIELabToXYZ(TIFFCIELabToRGB *</b><i>cielab</i><b>, uint32 </b><i>L</i><b>, int32 </b><i>a</i><b>, int32 </b><i>b</i><b>, float *</b><i>X</i><b>, float *</b><i>Y</i><b>, float *</b><i>Z</i><b>);</b><div style="height: 0.00em;">
&#160;</div>
<b>void TIFFXYZToRGB(TIFFCIELabToRGB *</b><i>cielab</i><b>, float </b><i>X</i><b>, float </b><i>Y</i><b>, float </b><i>Z&quot;</i><b>,</b><i>uint32</i><b>*&quot;</b><i>R</i><b>, uint32 *</b><i>G</i><b>, uint32 *</b><i>B</i><b>);</b></div>
<div class="section">
<h1>DESCRIPTION</h1> TIFF supports several color spaces for images stored in that format. There is usually a problem of application to handle the data properly and convert between different colorspaces for displaying and printing purposes. To simplify this task libtiff implements several color conversion routines itself. In particular, these routines used in <b>TIFFRGBAImage(3TIFF)</b> interface.<div class="spacer">
</div>
<b>TIFFYCbCrToRGBInit()</b> used to initialize <i>YCbCr</i> to <i>RGB</i> conversion state. Allocating and freeing of the <i>ycbcr</i> structure belongs to programmer. <i>TIFFYCbCrToRGB</i> defined in <b>tiffio.h</b> as<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef struct {                /* YCbCr-&gt;RGB support */<br/>
        TIFFRGBValue* clamptab; /* range clamping table */<br/>
        int*	      Cr_r_tab;<br/>
        int*	      Cb_b_tab;<br/>
        int32*	      Cr_g_tab;<br/>
        int32*	      Cb_g_tab;<br/>
        int32*        Y_tab;<br/>
} TIFFYCbCrToRGB;<br/>
</div>
<div class="spacer">
</div>
<i>luma</i> is a float array of three values representing proportions of the red, green and blue in luminance, Y (see section 21 of the TIFF 6.0 specification, where the YCbCr images discussed). <i>TIFFTAG_YCBCRCOEFFICIENTS</i> holds that values in TIFF file. <i>refBlackWhite</i> is a float array of 6 values which specifies a pair of headroom and footroom image data values (codes) for each image component (see section 20 of the TIFF 6.0 specification where the colorinmetry fields discussed). <i>TIFFTAG_REFERENCEBLACKWHITE</i> is responsible for storing these values in TIFF file. Following code snippet should helps to understand the the technique:<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
float *luma, *refBlackWhite;<br/>
uint16 hs, vs;<div class="spacer">
</div>
<br/>
/* Initialize structures */<br/>
ycbcr = (TIFFYCbCrToRGB*)<br/>
	_TIFFmalloc(TIFFroundup(sizeof(TIFFYCbCrToRGB), sizeof(long))<br/>
        	+ 4*256*sizeof(TIFFRGBValue)<br/>
        	+ 2*256*sizeof(int)<br/>
        	+ 3*256*sizeof(int32));<br/>
if (ycbcr == NULL) {<br/>
        TIFFError(&quot;YCbCr-&gt;RGB&quot;,<br/>
		&quot;No space for YCbCr-&gt;RGB conversion state&quot;);<br/>
        exit(0);<br/>
}<div class="spacer">
</div>
<br/>
TIFFGetFieldDefaulted(tif, TIFFTAG_YCBCRCOEFFICIENTS, &amp;luma);<br/>
TIFFGetFieldDefaulted(tif, TIFFTAG_REFERENCEBLACKWHITE, &amp;refBlackWhite);<br/>
if (TIFFYCbCrToRGBInit(ycbcr, luma, refBlackWhite) &lt; 0)<br/>
	exit(0);<div class="spacer">
</div>
<br/>
/* Start conversion */<br/>
uint32 r, g, b;<br/>
uint32 Y;<br/>
int32 Cb, Cr;<div class="spacer">
</div>
<br/>
for each pixel in image<br/>
	TIFFYCbCrtoRGB(img-&gt;ycbcr, Y, Cb, Cr, &amp;r, &amp;g, &amp;b);<div class="spacer">
</div>
<br/>
/* Free state structure */<br/>
_TIFFfree(ycbcr);<br/>
</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>TIFFCIELabToRGBInit()</b> initializes the <i>CIE L*a*b* 1976</i> to <i>RGB</i> conversion state. <b>TIFFCIELabToRGB</b> defined as<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
#define CIELABTORGB_TABLE_RANGE 1500<div class="spacer">
</div>
<br/>
typedef struct {		     /* CIE Lab 1976-&gt;RGB support */<br/>
	int	range;		     /* Size of conversion table */<br/>
	float	rstep, gstep, bstep;<br/>
	float	X0, Y0, Z0;	     /* Reference white point */<br/>
	TIFFDisplay display;<br/>
	float	Yr2r[CIELABTORGB_TABLE_RANGE + 1]; /* Conversion of Yr to r */<br/>
	float	Yg2g[CIELABTORGB_TABLE_RANGE + 1]; /* Conversion of Yg to g */<br/>
	float	Yb2b[CIELABTORGB_TABLE_RANGE + 1]; /* Conversion of Yb to b */<br/>
} TIFFCIELabToRGB;<br/>
</div>
<div class="spacer">
</div>
<i>display</i> is a display device description, declared as<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
typedef struct {<br/>
	float d_mat[3][3]; /* XYZ -&gt; luminance matrix */<br/>
	float d_YCR;       /* Light o/p for reference white */<br/>
	float d_YCG;<br/>
	float d_YCB;<br/>
	uint32 d_Vrwr;     /* Pixel values for ref. white */<br/>
	uint32 d_Vrwg;<br/>
	uint32 d_Vrwb;<br/>
	float d_Y0R;       /* Residual light for black pixel */<br/>
	float d_Y0G;<br/>
	float d_Y0B;<br/>
	float d_gammaR;    /* Gamma values for the three guns */<br/>
	float d_gammaG;<br/>
	float d_gammaB;<br/>
} TIFFDisplay;<br/>
</div>
<div class="spacer">
</div>
For example, the one can use sRGB device, which has the following parameters:<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
TIFFDisplay display_sRGB = {<br/>
	{       /* XYZ -&gt; luminance matrix */<br/>
		{  3.2410F, -1.5374F, -0.4986F },<br/>
		{  -0.9692F, 1.8760F, 0.0416F },<br/>
		{  0.0556F, -0.2040F, 1.0570F }<br/>
	},	<br/>
	100.0F, 100.0F, 100.0F, /* Light o/p for reference white */<br/>
	255, 255, 255,      /* Pixel values for ref. white */<br/>
	1.0F, 1.0F, 1.0F,   /* Residual light o/p for black pixel */<br/>
	2.4F, 2.4F, 2.4F,   /* Gamma values for the three guns */<br/>
};<br/>
</div>
<div class="spacer">
</div>
<i>refWhite</i> is a color temperature of the reference white. The <i>TIFFTAG_WHITEPOINT</i> contains the chromaticity of the white point of the image from where the reference white can be calculated using following formulae:<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
refWhite_Y = 100.0<div style="height: 0.00em;">
&#160;</div>
refWhite_X = whitePoint_x / whitePoint_y * refWhite_Y<div style="height: 0.00em;">
&#160;</div>
refWhite_Z = (1.0 - whitePoint_x - whitePoint_y) / whitePoint_y * refWhite_X<div style="height: 0.00em;">
&#160;</div>
</div>
<div class="spacer">
</div>
The conversion itself performed in two steps: at the first one we will convert <i>CIE L*a*b* 1976</i> to <i>CIE XYZ</i> using <b>TIFFCIELabToXYZ()</b> routine, and at the second step we will convert <i>CIE XYZ</i> to <i>RGB</i> using <b>TIFFXYZToRGB().</b> Look at the code sample below:<div class="spacer">
</div>
<div style="margin-left: 5.00ex;">
<br/>
float   *whitePoint;<br/>
float   refWhite[3];<div class="spacer">
</div>
<br/>
/* Initialize structures */<br/>
img-&gt;cielab = (TIFFCIELabToRGB *)<br/>
	_TIFFmalloc(sizeof(TIFFCIELabToRGB));<br/>
if (!cielab) {<br/>
	TIFFError(&quot;CIE L*a*b*-&gt;RGB&quot;,<br/>
		&quot;No space for CIE L*a*b*-&gt;RGB conversion state.&quot;);<br/>
	exit(0);<br/>
}<div class="spacer">
</div>
<br/>
TIFFGetFieldDefaulted(tif, TIFFTAG_WHITEPOINT, &amp;whitePoint);<br/>
refWhite[1] = 100.0F;<br/>
refWhite[0] = whitePoint[0] / whitePoint[1] * refWhite[1];<br/>
refWhite[2] = (1.0F - whitePoint[0] - whitePoint[1])<br/>
	      / whitePoint[1] * refWhite[1];<br/>
if (TIFFCIELabToRGBInit(cielab, &amp;display_sRGB, refWhite) &lt; 0) {<br/>
	TIFFError(&quot;CIE L*a*b*-&gt;RGB&quot;,<br/>
		&quot;Failed to initialize CIE L*a*b*-&gt;RGB conversion state.&quot;);<br/>
	_TIFFfree(cielab);<br/>
	exit(0);<br/>
}<div class="spacer">
</div>
<br/>
/* Now we can start to convert */<br/>
uint32 r, g, b;<br/>
uint32 L;<br/>
int32 a, b;<br/>
float X, Y, Z;<div class="spacer">
</div>
<br/>
for each pixel in image<br/>
	TIFFCIELabToXYZ(cielab, L, a, b, &amp;X, &amp;Y, &amp;Z);<br/>
	TIFFXYZToRGB(cielab, X, Y, Z, &amp;r, &amp;g, &amp;b);<div class="spacer">
</div>
<br/>
/* Don't forget to free the state structure */<br/>
_TIFFfree(cielab);<br/>
</div>
</div>
<div class="section">
<h1>SEE ALSO</h1> <b>TIFFRGBAImage</b>(3TIFF) <b>libtiff</b>(3TIFF),<div class="spacer">
</div>
Libtiff library home page: <b>http://www.remotesensing.org/libtiff/</b></div>
<table class="foot">
<tr>
<td class="foot-date">
December 21, 2003</td>
<td class="foot-os">
libtiff</td>
</tr>
</table>
</div>
</body>
</html>

