<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Set(3)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Set(3)</td>
<td class="head-vol">
OCaml library</td>
<td class="head-rtitle">
Set(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Set - Sets over ordered types.</div>
<div class="section">
<h1>Module</h1> Module   Set</div>
<div class="section">
<h1>Documentation</h1> Module <b>Set</b><br/>
 : <b>sig end</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
Sets over ordered types.<div style="height: 1.00em;">
&#160;</div>
This module implements the set data structure, given a total ordering function over the set elements. All operations over sets are purely applicative (no side-effects). The implementation uses balanced binary trees, and is therefore reasonably efficient: insertion and membership take time logarithmic in the size of the set, for instance.<div style="height: 1.00em;">
&#160;</div>
The <b>Make</b> functor constructs implementations for any type, given a <b>compare</b> function. For instance: <b>module IntPairs =</b> <b>struct</b> <b>type t = int * int</b> <b>let compare (x0,y0) (x1,y1) =</b> <b>match Pervasives.compare x0 x1 with</b> <b>0 -&gt; Pervasives.compare y0 y1</b> <b>| c -&gt; c</b> <b>end</b> <b>module PairsSet = Set.Make(IntPairs)</b> <b>let m = PairsSet.(empty |&gt; add (2,3) |&gt; add (5,7) |&gt; add (11,13))</b> <b><div style="height: 1.00em;">
&#160;</div>
This creates a new module</b> <b>PairsSet</b> , with a new type <b>PairsSet.t</b> of sets of <b>int * int</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>module type OrderedType =</i> <b>sig end</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
Input signature of the functor <b>Set.Make</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>module type S =</i> <b>sig end</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
Output signature of the functor <b>Set.Make</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>module Make :</i> <b>functor (Ord : OrderedType) -&gt; sig end</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
Functor building an implementation of the set structure given a totally ordered type.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<table class="foot">
<tr>
<td class="foot-date">
2015-08-12</td>
<td class="foot-os">
OCamldoc</td>
</tr>
</table>
</div>
</body>
</html>

