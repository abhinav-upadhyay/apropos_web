<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
CPU_SET(3)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
CPU_SET(3)</td>
<td class="head-vol">
Linux Programmer's Manual</td>
<td class="head-rtitle">
CPU_SET(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> CPU_SET, CPU_CLR, CPU_ISSET, CPU_ZERO, CPU_COUNT, CPU_AND, CPU_OR, CPU_XOR, CPU_EQUAL, CPU_ALLOC, CPU_ALLOC_SIZE, CPU_FREE, CPU_SET_S, CPU_CLR_S, CPU_ISSET_S, CPU_ZERO_S, CPU_COUNT_S, CPU_AND_S, CPU_OR_S, CPU_XOR_S, CPU_EQUAL_S - macros for manipulating CPU sets</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
<b>#define _GNU_SOURCE</b>             /* See feature_test_macros(7) */ <b>#include &lt;sched.h&gt;</b><div style="height: 1.00em;">
&#160;</div>
<br/>
<b>void CPU_ZERO(cpu_set_t *</b><i>set</i><b>);</b><div style="height: 1.00em;">
&#160;</div>
<br/>
<b>void CPU_SET(int </b><i>cpu</i><b>, cpu_set_t *</b><i>set</i><b>);</b><br/>
<b>void CPU_CLR(int </b><i>cpu</i><b>, cpu_set_t *</b><i>set</i><b>);</b><br/>
<b>int  CPU_ISSET(int </b><i>cpu</i><b>, cpu_set_t *</b><i>set</i><b>);</b><div style="height: 1.00em;">
&#160;</div>
<br/>
<b>int  CPU_COUNT(cpu_set_t *</b><i>set</i><b>);</b><div style="height: 1.00em;">
&#160;</div>
<br/>
<b>void CPU_AND(cpu_set_t *</b><i>destset</i><b>,</b><br/>
<b>             cpu_set_t *</b><i>srcset1</i><b>, cpu_set_t *</b><i>srcset2</i><b>);</b><br/>
<b>void CPU_OR(cpu_set_t *</b><i>destset</i><b>,</b><br/>
<b>             cpu_set_t *</b><i>srcset1</i><b>, cpu_set_t *</b><i>srcset2</i><b>);</b><br/>
<b>void CPU_XOR(cpu_set_t *</b><i>destset</i><b>,</b><br/>
<b>             cpu_set_t *</b><i>srcset1</i><b>, cpu_set_t *</b><i>srcset2</i><b>);</b><div style="height: 1.00em;">
&#160;</div>
<br/>
<b>int  CPU_EQUAL(cpu_set_t *</b><i>set1</i><b>, cpu_set_t *</b><i>set2</i><b>);</b><div style="height: 1.00em;">
&#160;</div>
<br/>
<b>cpu_set_t *CPU_ALLOC(int </b><i>num_cpus</i><b>);</b><br/>
<b>void CPU_FREE(cpu_set_t *</b><i>set</i><b>);</b><br/>
<b>size_t CPU_ALLOC_SIZE(int </b><i>num_cpus</i><b>);</b><div style="height: 1.00em;">
&#160;</div>
<br/>
<b>void CPU_ZERO_S(size_t </b><i>setsize</i><b>, cpu_set_t *</b><i>set</i><b>);</b><div style="height: 1.00em;">
&#160;</div>
<br/>
<b>void CPU_SET_S(int </b><i>cpu</i><b>, size_t </b><i>setsize</i><b>, cpu_set_t *</b><i>set</i><b>);</b><br/>
<b>void CPU_CLR_S(int </b><i>cpu</i><b>, size_t </b><i>setsize</i><b>, cpu_set_t *</b><i>set</i><b>);</b><br/>
<b>int  CPU_ISSET_S(int </b><i>cpu</i><b>, size_t </b><i>setsize</i><b>, cpu_set_t *</b><i>set</i><b>);</b><div style="height: 1.00em;">
&#160;</div>
<br/>
<b>int  CPU_COUNT_S(size_t </b><i>setsize</i><b>, cpu_set_t *</b><i>set</i><b>);</b><div style="height: 1.00em;">
&#160;</div>
<br/>
<b>void CPU_AND_S(size_t </b><i>setsize</i><b>, cpu_set_t *</b><i>destset</i><b>,</b><br/>
<b>             cpu_set_t *</b><i>srcset1</i><b>, cpu_set_t *</b><i>srcset2</i><b>);</b><br/>
<b>void CPU_OR_S(size_t </b><i>setsize</i><b>, cpu_set_t *</b><i>destset</i><b>,</b><br/>
<b>             cpu_set_t *</b><i>srcset1</i><b>, cpu_set_t *</b><i>srcset2</i><b>);</b><br/>
<b>void CPU_XOR_S(size_t </b><i>setsize</i><b>, cpu_set_t *</b><i>destset</i><b>,</b><br/>
<b>             cpu_set_t *</b><i>srcset1</i><b>, cpu_set_t *</b><i>srcset2</i><b>);</b><div style="height: 1.00em;">
&#160;</div>
<br/>
<b>int  CPU_EQUAL_S(size_t </b><i>setsize</i><b>, cpu_set_t *</b><i>set1</i><b>, cpu_set_t *</b><i>set2</i><b>);</b><br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> The <i>cpu_set_t</i> data structure represents a set of CPUs. CPU sets are used by <b>sched_setaffinity</b>(2) and similar interfaces.<div style="height: 1.00em;">
&#160;</div>
The <i>cpu_set_t</i> data type is implemented as a bitset. However, the data structure treated as considered opaque: all manipulation of CPU sets should be done via the macros described in this page.<div style="height: 1.00em;">
&#160;</div>
The following macros are provided to operate on the CPU set <i>set</i>:<dl>
<dt>
<b>CPU_ZERO</b>()</dt>
<dd>
Clears <i>set</i>, so that it contains no CPUs.</dd>
</dl>
<dl>
<dt>
<b>CPU_SET</b>()</dt>
<dd>
Add CPU <i>cpu</i> to <i>set</i>.</dd>
</dl>
<dl>
<dt>
<b>CPU_CLR</b>()</dt>
<dd>
Remove CPU <i>cpu</i> from <i>set</i>.</dd>
</dl>
<dl>
<dt>
<b>CPU_ISSET</b>()</dt>
<dd>
Test to see if CPU <i>cpu</i> is a member of <i>set</i>.</dd>
</dl>
<dl>
<dt>
<b>CPU_COUNT</b>()</dt>
<dd>
Return the number of CPUs in <i>set</i>.</dd>
</dl>
<div class="spacer">
</div>
Where a <i>cpu</i> argument is specified, it should not produce side effects, since the above macros may evaluate the argument more than once.<div class="spacer">
</div>
The first available CPU on the system corresponds to a <i>cpu</i> value of 0, the next CPU corresponds to a <i>cpu</i> value of 1, and so on. The constant <b>CPU_SETSIZE</b> (currently 1024) specifies a value one greater than the maximum CPU number that can be stored in <i>cpu_set_t</i>.<div style="height: 1.00em;">
&#160;</div>
The following macros perform logical operations on CPU sets:<dl>
<dt>
<b>CPU_AND</b>()</dt>
<dd>
Store the intersection of the sets <i>srcset1</i> and <i>srcset2</i> in <i>destset</i> (which may be one of the source sets).</dd>
</dl>
<dl>
<dt>
<b>CPU_OR</b>()</dt>
<dd>
Store the union of the sets <i>srcset1</i> and <i>srcset2</i> in <i>destset</i> (which may be one of the source sets).</dd>
</dl>
<dl>
<dt>
<b>CPU_XOR</b>()</dt>
<dd>
Store the XOR of the sets <i>srcset1</i> and <i>srcset2</i> in <i>destset</i> (which may be one of the source sets). The XOR means the set of CPUs that are in either <i>srcset1</i> or <i>srcset2</i>, but not both.</dd>
</dl>
<dl>
<dt>
<b>CPU_EQUAL</b>()</dt>
<dd>
Test whether two CPU set contain exactly the same CPUs.</dd>
</dl>
<div class="subsection">
<h2>Dynamically sized CPU sets</h2> Because some applications may require the ability to dynamically size CPU sets (e.g., to allocate sets larger than that defined by the standard <i>cpu_set_t</i> data type), glibc nowadays provides a set of macros to support this.<div style="height: 1.00em;">
&#160;</div>
The following macros are used to allocate and deallocate CPU sets:<dl>
<dt>
<b>CPU_ALLOC</b>()</dt>
<dd>
Allocate a CPU set large enough to hold CPUs in the range 0 to <i>num_cpus-1</i>.</dd>
</dl>
<dl>
<dt>
<b>CPU_ALLOC_SIZE</b>()</dt>
<dd>
Return the size in bytes of the CPU set that would be needed to hold CPUs in the range 0 to <i>num_cpus-1</i>. This macro provides the value that can be used for the <i>setsize</i> argument in the <b>CPU_*_S</b>() macros described below.</dd>
</dl>
<dl>
<dt>
<b>CPU_FREE</b>()</dt>
<dd>
Free a CPU set previously allocated by <b>CPU_ALLOC</b>().</dd>
</dl>
<div class="spacer">
</div>
The macros whose names end with &quot;_S&quot; are the analogs of the similarly named macros without the suffix. These macros perform the same tasks as their analogs, but operate on the dynamically allocated CPU set(s) whose size is <i>setsize</i> bytes.</div>
</div>
<div class="section">
<h1>RETURN VALUE</h1> <b>CPU_ISSET</b>() and <b>CPU_ISSET_S</b>() return nonzero if <i>cpu</i> is in <i>set</i>; otherwise, it returns 0.<div style="height: 1.00em;">
&#160;</div>
<b>CPU_COUNT</b>() and <b>CPU_COUNT_S</b>() return the number of CPUs in <i>set</i>.<div style="height: 1.00em;">
&#160;</div>
<b>CPU_EQUAL</b>() and <b>CPU_EQUAL_S</b>() return nonzero if the two CPU sets are equal; otherwise it returns 0.<div style="height: 1.00em;">
&#160;</div>
<b>CPU_ALLOC</b>() returns a pointer on success, or NULL on failure. (Errors are as for <b>malloc</b>(3).)<div style="height: 1.00em;">
&#160;</div>
<b>CPU_ALLOC_SIZE</b>() returns the number of bytes required to store a CPU set of the specified cardinality.<div style="height: 1.00em;">
&#160;</div>
The other functions do not return a value.</div>
<div class="section">
<h1>VERSIONS</h1> The <b>CPU_ZERO</b>(), <b>CPU_SET</b>(), <b>CPU_CLR</b>(), and <b>CPU_ISSET</b>() macros were added in glibc 2.3.3.<div style="height: 1.00em;">
&#160;</div>
<b>CPU_COUNT</b>() first appeared in glibc 2.6.<div style="height: 1.00em;">
&#160;</div>
<b>CPU_AND</b>(), <b>CPU_OR</b>(), <b>CPU_XOR</b>(), <b>CPU_EQUAL</b>(), <b>CPU_ALLOC</b>(), <b>CPU_ALLOC_SIZE</b>(), <b>CPU_FREE</b>(), <b>CPU_ZERO_S</b>(), <b>CPU_SET_S</b>(), <b>CPU_CLR_S</b>(), <b>CPU_ISSET_S</b>(), <b>CPU_AND_S</b>(), <b>CPU_OR_S</b>(), <b>CPU_XOR_S</b>(), and <b>CPU_EQUAL_S</b>() first appeared in glibc 2.7.</div>
<div class="section">
<h1>CONFORMING TO</h1> These interfaces are Linux-specific.</div>
<div class="section">
<h1>NOTES</h1> To duplicate a CPU set, use <b>memcpy</b>(3).<div style="height: 1.00em;">
&#160;</div>
Since CPU sets are bitsets allocated in units of long words, the actual number of CPUs in a dynamically allocated CPU set will be rounded up to the next multiple of <i>sizeof(unsigned long)</i>. An application should consider the contents of these extra bits to be undefined.<div style="height: 1.00em;">
&#160;</div>
Notwithstanding the similarity in the names, note that the constant <b>CPU_SETSIZE</b> indicates the number of CPUs in the <i>cpu_set_t</i> data type (thus, it is effectively a count of bits in the bitset), while the <i>setsize</i> argument of the <b>CPU_*_S</b>() macros is a size in bytes.<div style="height: 1.00em;">
&#160;</div>
The data types for arguments and return values shown in the SYNOPSIS are hints what about is expected in each case. However, since these interfaces are implemented as macros, the compiler won't necessarily catch all type errors if you violate the suggestions.</div>
<div class="section">
<h1>EXAMPLE</h1> The following program demonstrates the use of some of the macros used for dynamically allocated CPU sets.<div style="height: 1.00em;">
&#160;</div>
<br/>
#define _GNU_SOURCE<br/>
#include &lt;sched.h&gt;<br/>
#include &lt;stdlib.h&gt;<br/>
#include &lt;unistd.h&gt;<br/>
#include &lt;stdio.h&gt;<br/>
#include &lt;assert.h&gt;<div class="spacer">
</div>
<br/>
int<br/>
main(int argc, char *argv[])<br/>
{<br/>
    cpu_set_t *cpusetp;<br/>
    size_t size;<br/>
    int num_cpus, cpu;<div class="spacer">
</div>
<br/>
    if (argc &lt; 2) {<br/>
        fprintf(stderr, &quot;Usage: %s &lt;num-cpus&gt;\n&quot;, argv[0]);<br/>
        exit(EXIT_FAILURE);<br/>
    }<div class="spacer">
</div>
<br/>
    num_cpus = atoi(argv[1]);<div class="spacer">
</div>
<br/>
    cpusetp = CPU_ALLOC(num_cpus);<br/>
    if (cpusetp == NULL) {<br/>
        perror(&quot;CPU_ALLOC&quot;);<br/>
        exit(EXIT_FAILURE);<br/>
    }<div class="spacer">
</div>
<br/>
    size = CPU_ALLOC_SIZE(num_cpus);<div class="spacer">
</div>
<br/>
    CPU_ZERO_S(size, cpusetp);<br/>
    for (cpu = 0; cpu &lt; num_cpus; cpu += 2)<br/>
        CPU_SET_S(cpu, size, cpusetp);<div class="spacer">
</div>
<br/>
    printf(&quot;CPU_COUNT() of set:    %d\n&quot;, CPU_COUNT_S(size, cpusetp));<div class="spacer">
</div>
<br/>
    CPU_FREE(cpusetp);<br/>
    exit(EXIT_SUCCESS);<br/>
}<br/>
</div>
<div class="section">
<h1>BUGS</h1> On 32-bit platforms with glibc 2.8 and earlier, <b>CPU_ALLOC</b>() allocates twice as much space as is required, and <b>CPU_ALLOC_SIZE</b>() returns a value twice as large as it should. This bug should not affect the semantics of a program, but does result in wasted memory and less efficient operation of the macros that operate on dynamically allocated CPU sets. These bugs are fixed in glibc 2.9.</div>
<div class="section">
<h1>SEE ALSO</h1> <b>sched_setaffinity</b>(2), <b>pthread_attr_setaffinity_np</b>(3), <b>pthread_setaffinity_np</b>(3), <b>cpuset</b>(7)</div>
<div class="section">
<h1>COLOPHON</h1> This page is part of release 3.35 of the Linux <i>man-pages</i> project. A description of the project, and information about reporting bugs, can be found at http://man7.org/linux/man-pages/.</div>
<table class="foot">
<tr>
<td class="foot-date">
2010-09-10</td>
<td class="foot-os">
Linux</td>
</tr>
</table>
</div>
</body>
</html>

