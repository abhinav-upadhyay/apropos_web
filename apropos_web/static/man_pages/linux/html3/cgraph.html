<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
LIBCGRAPH(3)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
LIBCGRAPH(3)</td>
<td class="head-vol">
Library Functions Manual</td>
<td class="head-rtitle">
LIBCGRAPH(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1>  <b>libcgraph</b> - abstract graph library</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
<br/>
#include &lt;graphviz/cgraph.h&gt;<br/>
<br/>
<div class="subsection">
<h2>TYPES</h2><br/>
<br/>
Agraph_t;<br/>
Agnode_t;<br/>
Agedge_t;<br/>
Agdesc_t;<br/>
Agdisc_t;<br/>
Agsym_t;<br/>
<br/>
</div>
<div class="subsection">
<h2>GRAPHS</h2><br/>
<br/>
Agraph_t        *agopen(char *name, Agdesc_t kind, Agdisc_t *disc);<br/>
int             agclose(Agraph_t *g);<br/>
Agraph_t        *agread(void *channel, Agdisc_t *);<br/>
void			agreadline(int line_no);<br/>
void			agsetfile(char *file_name);<br/>
Agraph_t		*agconcat(Agraph_t *g, void *channel, Agdisc_t *disc)<br/>
int             agwrite(Agraph_t *g, void *channel);<br/>
int				agnnodes(Agraph_t *g),agnedges(Agraph_t *g);<br/>
int				agisdirected(Agraph_t * g),agisundirected(Agraph_t * g),agisstrict(Agraph_t * g), agissimple(Agraph_t * g); </div>
<div class="subsection">
<h2>SUBGRAPHS</h2><br/>
<br/>
Agraph_t        *agsubg(Agraph_t *g, char *name, int createflag);<br/>
Agraph_t		*agidsubg(Agraph_t * g, unsigned long id, int cflag);<br/>
Agraph_t        *agfstsubg(Agraph_t *g), agnxtsubg(Agraph_t *);<br/>
Agraph_t        *agparent(Agraph_t *g);<br/>
int				agdelsubg(Agraph_t * g, Agraph_t * sub);	/* same as agclose() */<br/>
<br/>
</div>
<div class="subsection">
<h2>NODES</h2><br/>
<br/>
Agnode_t        *agnode(Agraph_t *g, char *name, int createflag);<br/>
Agnode_t        *agidnode(Agraph_t *g, ulong id, int createflag);<br/>
Agnode_t        *agsubnode(Agraph_t *g, Agnode_t *n, int createflag);<br/>
Agnode_t        *agfstnode(Agraph_t *g);<br/>
Agnode_t        *agnxtnode(Agraph_t *g, Agnode_t *n);<br/>
Agnode_t        *agprvnode(Agraph_t *g, Agnode_t *n);<br/>
Agnode_t        *aglstnode(Agraph_t *g);<br/>
int             agdelnode(Agraph_t *g, Agnode_t *n);<br/>
int				agdegree(Agnode_t *n, int use_inedges, int use_outedges);<br/>
<br/>
</div>
<div class="subsection">
<h2>EDGES</h2><br/>
<br/>
Agedge_t        *agedge(Agraph_t* g, Agnode_t *t, Agnode_t *h, char *name, int createflag);<br/>
Agedge_t		*agidedge(Agraph_t * g, Agnode_t * t, Agnode_t * h, unsigned long id, int createflag);<br/>
Agedge_t        *agsubedge(Agraph_t *g, Agedge_t *e, int createflag);<br/>
Agnode_t        *aghead(Agedge_t *e), *agtail(Agedge_t *e);<br/>
Agedge_t        *agfstedge(Agraph_t* g, Agnode_t *n);<br/>
Agedge_t        *agnxtedge(Agraph_t* g, Agedge_t *e, Agnode_t *n);<br/>
Agedge_t        *agfstin(Agraph_t* g, Agnode_t *n);<br/>
Agedge_t        *agnxtin(Agraph_t* g, Agedge_t *e);<br/>
Agedge_t        *agfstout(Agraph_t* g, Agnode_t *n);<br/>
Agedge_t        *agnxtout(Agraph_t* g, Agedge_t *e);<br/>
int             agdeledge(Agraph_t *g, Agedge_t *e);</div>
<div class="subsection">
<h2>STRING ATTRIBUTES</h2><br/>
<br/>
Agsym_t			*agattr(Agraph_t *g, int kind, char *name, char *value);<br/>
Agsym_t			*agattrsym(void *obj, char *name);<br/>
Agsym_t			*agnxtattr(Agraph_t *g, int kind, Agsym_t *attr);<br/>
char			*agget(void *obj, char *name);<br/>
char			*agxget(void *obj, Agsym_t *sym);<br/>
int				agset(void *obj, char *name, char *value);<br/>
int				agxset(void *obj, Agsym_t *sym, char *value);<br/>
int				agsafeset(void *obj, char *name, char *value, char *def);<br/>
<br/>
</div>
<div class="subsection">
<h2>RECORDS</h2><br/>
<br/>
void		*agbindrec(void *obj, char *name, unsigned int size, move_to_front);<br/>
Agrec_t     *aggetrec(void *obj, char *name, int move_to_front);<br/>
int         agdelrec(Agraph_t *g, void *obj, char *name);<br/>
int			agcopyattr(void *, void *);<br/>
void		aginit(Agraph_t * g, int kind, char *rec_name, int rec_size, int move_to_front);<br/>
void		agclean(Agraph_t * g, int kind, char *rec_name);<br/>
<br/>
</div>
<div class="subsection">
<h2>CALLBACKS</h2><br/>
<br/>
Agcbdisc_t    *agpopdisc(Agraph_t *g);<br/>
void        agpushdisc(Agraph_t *g, Agcbdisc_t *disc);<br/>
void        agmethod(Agraph_t *g, void *obj, Agcbdisc_t *disc, int initflag);<br/>
<br/>
</div>
<div class="subsection">
<h2>MEMORY</h2><br/>
<br/>
void		*agalloc(Agraph_t *g, size_t request);<br/>
void		*agrealloc(Agraph_t *g, void *ptr, size_t oldsize, size_t newsize);<br/>
void		agfree(Agraph_t *g, void *ptr);<br/>
<br/>
</div>
<div class="subsection">
<h2>STRINGS</h2><br/>
<br/>
char		*agstrdup(Agraph_t *, char *);<br/>
char		*agstrdup_html(Agraph_t *, char *);<br/>
int		aghtmlstr(char *);<br/>
char		*agstrbind(Agraph_t * g, char *);<br/>
int		strfree(Agraph_t *, char *);<br/>
char		*agcanonStr(char *);<br/>
char		*agstrcanon(char *, char *);<br/>
<br/>
</div>
<div class="subsection">
<h2>GENERIC OBJECTS</h2><br/>
<br/>
Agraph_t	*agraphof(void*);<br/>
Agraph_t	*agroot(void*);<br/>
int			agcontains(Agraph_t*, void*);<br/>
char		*agnameof(void*);<br/>
void		agdelete(Agraph_t *g, void *obj);<br/>
int 		agobjkind(void *obj);<br/>
Agrec_t		*AGDATA(void *obj);<br/>
ulong		AGID(void *obj);<br/>
int			AGTYPE(void *obj);<br/>
<br/>
</div>
</div>
<div class="section">
<h1>DESCRIPTION</h1> Libcgraph supports graph programming by maintaining graphs in memory and reading and writing graph files. Graphs are composed of nodes, edges, and nested subgraphs. These graph objects may be attributed with string name-value pairs and programmer-defined records (see Attributes).<div class="spacer">
</div>
All of Libcgraph's global symbols have the prefix <b>ag</b> (case varying).</div>
<div class="section">
<h1>GRAPH AND SUBGRAPHS</h1> A ``main'' or ``root'' graph defines a namespace for a collection of graph objects (subgraphs, nodes, edges) and their attributes. Objects may be named by unique strings or by 32-bit IDs.<div class="spacer">
</div>
<b>agopen</b> creates a new graph with the given name and kind. (Graph kinds are  <b>Agdirected</b>, <b>Agundirected</b>,  <b>Agstrictdirected</b>, and <b>Agstrictundirected</b>. A strict graph cannot have multi-edges or self-arcs.)  <b>agclose</b> deletes a graph, freeing its associated storage.  <b>agread</b>, <b>agwrite</b>, and <b>agconcat</b> perform file I/O using the graph file language described below.  <b>agread</b> constructs a new graph while  <b>agconcat</b> merges the file contents with a pre-existing graph.  Though I/O methods may be overridden, the default is that the channel argument is a stdio FILE pointer.  <b>agsetfile</b> and <b>agreadline</b> are helper functions that simply set the current file name and input line number for subsequent error reporting.<div class="spacer">
</div>
<b>agsubg</b> finds or creates a subgraph by name.  A new subgraph is is initially empty and is of the same kind as its parent.  Nested subgraph trees may be created. A subgraph's name is only interpreted relative to its parent. A program can scan subgraphs under a given graph using  <b>agfstsubg</b> and agnxtsubg.  A subgraph is deleted with  <b>agdelsubg</b> (or <b>agclose</b>).<div class="spacer">
</div>
By default, nodes are stored in ordered sets for efficient random access to insert, find, and delete nodes. The edges of a node are also stored in ordered sets. The sets are maintained internally as splay tree dictionaries using Phong Vo's cdt library.<div class="spacer">
</div>
<b>agnnodes</b>, <b>agnedges</b>, and <b>agdegree</b> return the sizes of node and edge sets of a graph.  The  <b>agdegree</b> returns the size of the edge set of a nodes, and takes flags to select in-edges, out-edges, or both.<div class="spacer">
</div>
An <b>Agdisc_t</b> defines callbacks to be invoked by libcgraph when initializing, modifying, or finalizing graph objects.  (Casual users can ignore the following.) Disciplines are kept on a stack.  Libcgraph automatically calls the methods on the stack, top-down.  Callbacks are installed with  <b>agpushdisc</b>, uninstalled with <b>agpopdisc</b>, and can be held pending or released via  <b>agcallbacks</b>.<div class="spacer">
</div>
(Casual users may ignore the following. When Libcgraph is compiled with Vmalloc (which is not the default), each graph has its own heap. Programmers may allocate application-dependent data within the same heap as the rest of the graph.  The advantage is that a graph can be deleted by atomically freeing its entire heap without scanning each individual node and edge.</div>
<div class="section">
<h1>NODES</h1> A node is created by giving a unique string name or programmer defined 32-bit ID, and is represented by a unique internal object. (Node equality can checked by pointer comparison.)<div class="spacer">
</div>
<b>agnode</b> searches in a graph or subgraph for a node with the given name, and returns it if found. If not found, if  <b>createflag</b> is boolean true a new node is created and returned, otherwise a nil pointer is returned.  <b>agidnode</b> allows a programmer to specify the node by a unique 32-bit ID.  <b>agsubnode</b> performs a similar operation on an existing node and a subgraph.<div class="spacer">
</div>
<b>agfstnode</b> and <b>agnxtnode</b> scan node lists.  <b>agprvnode</b> and <b>aglstnode</b> are symmetric but scan backward. The default sequence is order of creation (object timestamp.)  <b>agdelnode</b> removes a node from a graph or subgraph.</div>
<div class="section">
<h1>EDGES</h1> An abstract edge has two endpoint nodes called tail and head where the all outedges of the same node have it as the tail value and similarly all inedges have it as the head. In an undirected graph, head and tail are interchangeable. If a graph has multi-edges between the same pair of nodes, the edge's string name behaves as a secondary key.<div class="spacer">
</div>
<b>agedge</b> searches in a graph of subgraph for an edge between the given endpoints (with an optional multi-edge selector name) and returns it if found. Otherwise, if  <b>createflag</b> is boolean true, a new edge is created and returned: otherwise a nil pointer is returned.  If the  <b>name</b> is NULL, then an anonymous internal value is generated.  <b>agidedge</b> allows a programmer to create an edge by giving its unique 32-bit ID.  <b>agfstin</b>, <b>agnxtint</b>, <b>agfstout</b>, and  <b>agnxtout</b> visit directed in- and out- edge lists, and ordinarily apply only in directed graphs.  <b>agfstedge</b> and <b>agnxtedge</b> visit all edges incident to a node.   <b>agtail</b> and <b>aghead</b> get the endpoint of an edge.</div>
<div class="section">
<h1>INTERNAL ATTRIBUTES</h1> Programmer-defined values may be dynamically attached to graphs, subgraphs, nodes, and edges. Such values are either uninterpreted binary records (for implementing efficient algorithms) or character string data (for I/O).</div>
<div class="section">
<h1>STRING ATTRIBUTES</h1> String attributes are handled automatically in reading and writing graph files. A string attribute is identified by name and by an internal symbol table entry ( <b>Agsym_t</b>) created by Libcgraph. Attributes of nodes, edges, and graphs (with their subgraphs) have separate namespaces.  The contents of an  <b>Agsym_t</b> is listed below, followed by primitives to operate on string attributes.<br/>
<br/>
typedef struct Agsym_s {        /* symbol in one of the above dictionaries */<br/>
    Dtlink_t        link;<br/>
    char            *name;      /* attribute's name */<br/>
    char            *defval;    /* its default value for initialization */<br/>
    int             id;         /* its index in attr[] */<br/>
    unsigned char	kind;		/* referent object type */<br/>
    unsigned char	fixed;		/* immutable value */<br/>
} Agsym_t;<br/>
<br/>
<div class="spacer">
</div>
<b>agattr</b> creates or looks up attributes.  <b>kind</b> may be <b>AGRAPH</b>, <b>AGNODE</b>, or <b>AGEDGE</b>. If  <b>value</b> is <b>(char*)0)</b>, the request is to search for an existing attribute of the given kind and name. Otherwise, if the attribute already exists, its default for creating new objects is set to the given value; if it does not exist, a new attribute is created with the given default, and the default is applied to all pre-existing objects of the given kind. If  <b>g</b> is NIL, the default is set for all graphs created subsequently.  <b>agattrsym</b> is a helper function that looks up an attribute for a graph object given as an argument.  <b>agnxtattr</b> permits traversing the list of attributes of a given type.  If  <b>NIL</b> is passed as an argument it gets the first attribute, otherwise it returns the next one in succession or returns  <b>NIL</b> at the end of the list.  <b>agget</b> and <b>agset</b> allow fetching and updating a string attribute for an object taking the attribute name as an argument.  <b>agxget</b> and <b>agxset</b> do this but with an attribute symbol table entry as an argument (to avoid the cost of the string lookup).   <b>agsafeset</b> is a convenience function that ensures the given attribute is declared before setting it locally on an object.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>STRINGS</h1> Libcgraph performs its own storage management of strings as reference-counted strings. The caller does not need to dynamically allocate storage.<div class="spacer">
</div>
<b>agstrdup</b> returns a pointer to a reference-counted copy of the argument string, creating one if necessary.  <b>agstrbind</b> returns a pointer to a reference-counted string if it exists, or NULL if not. All uses of cgraph strings need to be freed using  <b>agstrfree</b> in order to correctly maintain the reference count.<div class="spacer">
</div>
<b>agcanonStr</b> returns a pointer to a version of the input string canonicalized for output for later re-parsing. This includes quoting special characters and keywords. It uses its own internal buffer, so the value will be lost on the next call to  <b>agcanonStr</b>.  <b>agstrcanon</b> is an unsafe version of <b>agcanonStr</b>, in which the application passes in a buffer as the second argument. Note that the buffer may not be used; if the input string is in canonical form, the function will just return a pointer to it.<div class="spacer">
</div>
The cgraph parser handles HTML-like strings. These should be indistinguishable from other strings for most purposes. To create an HTML-like string, use  <b>agstrdup_html</b>. The <b>aghtmlstr</b> function can be used to query if a string is an ordinary string or an HTML-like string.</div>
<div class="section">
<h1>RECORDS</h1> Uninterpreted records may be attached to graphs, subgraphs, nodes, and edges for efficient operations on values such as marks, weights, counts, and pointers needed by algorithms.  Application programmers define the fields of these records, but they must be declared with a common header as shown below.<br/>
<br/>
typedef struct Agrec_s {<br/>
    Agrec_t		header;<br/>
    /* programmer-defined fields follow */<br/>
} Agrec_t;<br/>
<br/>
Records are created and managed by Libcgraph. A programmer must explicitly attach them to the objects in a graph, either to individual objects one at a time via  <b>agbindrec</b>, or to all the objects of the same class in a graph via  <b>aginit</b>. (Note that for graphs, aginit is applied recursively to the graph and its subgraphs if rec_size is negative (of the actual rec_size.)) The  <b>name</b> argument a record distinguishes various types of records, and is programmer defined (Libcgraph reserves the prefix  <b>_ag</b>). If size is 0, the call to  <b>agbindrec</b> is simply a lookup.  <b>agdelrec</b> is the deletes records one at a time.  <b>agclean</b> does the same for all objects of the same class in an entire graph.<div style="height: 1.00em;">
&#160;</div>
Internally, records are maintained in circular linked lists attached to graph objects. To allow referencing application-dependent data without function calls or search, Libcgraph allows setting and locking the list pointer of a graph, node, or edge on a particular record. This pointer can be obtained with the macro  <b>AGDATA(obj)</b>. A cast, generally within a macro or inline function, is usually applied to convert the list pointer to an appropriate programmer-defined type.<div style="height: 1.00em;">
&#160;</div>
To control the setting of this pointer, the  <b>move_to_front</b> flag may be <b>AG_MTF_FALSE</b>,  <b>AG_MTF_SOFT</b>, or <b>AG_MTF_HARD</b> accordingly. The  <b>AG_MTF_SOFT</b> field is only a hint that decreases overhead in subsequent calls of  <b>aggetrec</b>;  <b>AG_MTF_HARD</b> guarantees that a lock was obtained. To release locks, use  <b>AG_MTF_SOFT</b> or <b>AG_MTF_FALSE</b>. Use of this feature implies cooperation or at least isolation from other functions also using the move-to-front convention.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>DISCIPLINES</h1> (The following is not intended for casual users.) Programmer-defined disciplines customize certain resources- ID namespace, memory, and I/O - needed by Libcgraph. A discipline struct (or NIL) is passed at graph creation time.<br/>
<br/>
struct Agdisc_s {			/* user's discipline */<br/>
	Agmemdisc_t			*mem;<br/>
	Agiddisc_t			*id;<br/>
	Agiodisc_t			*io;<br/>
} ;<br/>
<br/>
A default discipline is supplied when NIL is given for any of these fields.<div style="height: 1.00em;">
&#160;</div>
An ID allocator discipline allows a client to control assignment of IDs (uninterpreted 32-bit values) to objects, and possibly how they are mapped to and from strings.<div style="height: 1.00em;">
&#160;</div>
<br/>
<br/>
struct Agiddisc_s {		/* object ID allocator */<br/>
	void	*(*open)(Agraph_t *g);	/* associated with a graph */<br/>
	int		(*map)(void *state, int objtype, char *str, ulong *id, int createflag);<br/>
	int		(*alloc)(void *state, int objtype, ulong id);<br/>
	void	(*free)(void *state, int objtype, ulong id);<br/>
	char	*(*print)(void *state, int objtype, ulong id);<br/>
	void	(*close)(void *state);<br/>
} ;<br/>
<br/>
<div style="height: 1.00em;">
&#160;</div>
open permits the ID discipline to initialize any data structures that maintains per individual graph. Its return value is then passed as the first argument to all subsequent ID manager calls.<div style="height: 1.00em;">
&#160;</div>
alloc informs the ID manager that Libcgraph is attempting to create an object with a specific ID that was given by a client. The ID manager should return TRUE (nonzero) if the ID can be allocated, or FALSE (which aborts the operation).<div style="height: 1.00em;">
&#160;</div>
free is called to inform the ID manager that the object labeled with the given ID is about to go out of existence.<div style="height: 1.00em;">
&#160;</div>
map is called to create or look-up IDs by string name (if supported by the ID manager).  Returning TRUE (nonzero) in all cases means that the request succeeded (with a valid ID stored through result.  There are four cases:<div class="spacer">
</div>
name != NULL and createflag == 1: This requests mapping a string (e.g. a name in a graph file) into a new ID. If the ID manager can comply, then it stores the result and returns TRUE. It is then also responsible for being able to print the ID again as a string.  Otherwise the ID manager may return FALSE but it must implement the following (at least for graph file reading and writing to work):<div class="spacer">
</div>
name == NULL and createflag == 1: The ID manager creates a unique new ID of its own choosing. Although it may return FALSE if it does not support anonymous objects, but this is strongly discouraged (to support &quot;local names&quot; in graph files.)<div class="spacer">
</div>
name != NULL and createflag == 0: This is a namespace probe.  If the name was previously mapped into an allocated ID by the ID manager, then the manager must return this ID. Otherwise, the ID manager may either return FALSE, or may store any unallocated ID into result. (This is convenient, for example, if names are known to be digit strings that are directly converted into 32 bit values.)<div class="spacer">
</div>
name == NULL and createflag == 0: forbidden.<div class="spacer">
</div>
print is allowed to return a pointer to a static buffer; a caller must copy its value if needed past subsequent calls. NULL should be returned by ID managers that do not map names.<div class="spacer">
</div>
The map and alloc calls do not pass a pointer to the newly allocated object.  If a client needs to install object pointers in a handle table, it can obtain them via new object callbacks.<br/>
<br/>
struct Agiodisc_s {<br/>
	int		(*fread)(void *chan, char *buf, int bufsize);<br/>
	int		(*putstr)(void *chan, char *str);<br/>
	int		(*flush)(void *chan);	/* sync */<br/>
	/* error messages? */<br/>
} ;<div class="spacer">
</div>
<br/>
struct Agmemdisc_s {	/* memory allocator */<br/>
	void	*(*open)(void);		/* independent of other resources */<br/>
	void	*(*alloc)(void *state, size_t req);<br/>
	void	*(*resize)(void *state, void *ptr, size_t old, size_t req);<br/>
	void	(*free)(void *state, void *ptr);<br/>
	void	(*close)(void *state);<br/>
} ;<br/>
<br/>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>EXAMPLE PROGRAM</h1><br/>
<br/>
#include &lt;graphviz/cgraph.h&gt;<br/>
typedef struct mydata_s {Agrec_t hdr; int x,y,z;} mydata;<div class="spacer">
</div>
<br/>
main(int argc, char **argv)<br/>
{<br/>
    Agraph_t    *g;<br/>
    Agnode_t    *v;<br/>
    Agedge_t    *e;<br/>
    Agsym_t     *attr;<br/>
    Dict_t      *d<br/>
    int         cnt;<br/>
    mydata      *p;<div class="spacer">
</div>
<br/>
    if (g = agread(stdin,NIL(Agdisc_t*))) {<br/>
		cnt = 0; attr = 0;<br/>
		while (attr = agnxtattr(g, AGNODE, attr)) cnt++;<br/>
		printf(&quot;The graph %s has %d attributes0,agnameof(g),cnt);<div class="spacer">
</div>
<br/>
		/* make the graph have a node color attribute, default is blue */<br/>
        attr = agattr(g,AGNODE,&quot;color&quot;,&quot;blue&quot;);<div class="spacer">
</div>
<br/>
        /* create a new graph of the same kind as g */<br/>
        h = agopen(&quot;tmp&quot;,g-&gt;desc);<div class="spacer">
</div>
<br/>
        /* this is a way of counting all the edges of the graph */<br/>
        cnt = 0;<br/>
        for (v = agfstnode(g); v; v = agnxtnode(g,v))<br/>
            for (e = agfstout(g,v); e; e = agnxtout(g,e))<br/>
                cnt++;<div class="spacer">
</div>
<br/>
        /* attach records to edges */<br/>
        for (v = agfstnode(g); v; v = agnxtnode(g,v))<br/>
            for (e = agfstout(g,v); e; e; = agnxtout(g,e)) {<br/>
                p = (mydata*) agbindrec(g,e,&quot;mydata&quot;,sizeof(mydata),TRUE);<br/>
                p-&gt;x = 27;  /* meaningless data access example */<br/>
				((mydata*)(AGDATA(e)))-&gt;y = 999; /* another example */<br/>
        }<br/>
    }<br/>
}<br/>
<br/>
</div>
<div class="section">
<h1>EXAMPLE GRAPH FILES</h1><br/>
<br/>
digraph G {<br/>
    a -&gt; b;<br/>
    c [shape=box];<br/>
    a -&gt; c [weight=29,label=&quot;some text];<br/>
    subgraph anything {<br/>
        /* the following affects only x,y,z */<br/>
        node [shape=circle];<br/>
        a; x; y -&gt; z; y -&gt; z;  /* multiple edges */<br/>
    }<br/>
}<div class="spacer">
</div>
<br/>
strict graph H {<br/>
    n0 -- n1 -- n2 -- n0;  /* a cycle */<br/>
    n0 -- {a b c d};       /* a star */<br/>
    n0 -- n3;<br/>
    n0 -- n3 [weight=1];   /* same edge because graph is strict */<br/>
}<br/>
<br/>
</div>
<div class="section">
<h1>SEE ALSO</h1> Libcdt(3)<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>BUGS</h1> It is difficult to change endpoints of edges, delete string attributes or modify edge keys.  The work-around is to create a new object and copy the contents of an old one (but new object obviously has a different ID, internal address, and object creation timestamp).<div style="height: 1.00em;">
&#160;</div>
The API lacks convenient functions to substitute programmer-defined ordering of nodes and edges but in principle this can be supported.</div>
<div class="section">
<h1>AUTHOR</h1> Stephen North, north@research.att.com, AT&amp;T Research.</div>
<table class="foot">
<tr>
<td class="foot-date">
30 JULY 2007</td>
<td class="foot-os">
</td>
</tr>
</table>
</div>
</body>
</html>

