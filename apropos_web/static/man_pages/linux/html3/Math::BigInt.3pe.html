<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Math::BigInt(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Math::BigInt(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
Math::BigInt(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Math::BigInt - Arbitrary size integer/float math package</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
  use Math::BigInt;<br/>
<br/>
  # or make it faster with huge numbers: install (optional)<br/>
  # Math::BigInt::GMP and always use (it will fall back to<br/>
  # pure Perl if the GMP library is not installed):<br/>
  # (See also the L&lt;MATH LIBRARY&gt; section!)<br/>
<br/>
  # will warn if Math::BigInt::GMP cannot be found<br/>
  use Math::BigInt lib =&gt; 'GMP';<br/>
<br/>
  # to suppress the warning use this:<br/>
  # use Math::BigInt try =&gt; 'GMP';<br/>
<br/>
  # dies if GMP cannot be loaded:<br/>
  # use Math::BigInt only =&gt; 'GMP';<br/>
<br/>
  my $str = '1234567890';<br/>
  my @values = (64,74,18);<br/>
  my $n = 1; my $sign = '-';<br/>
<br/>
  # Number creation     <br/>
  my $x = Math::BigInt-&gt;new($str);      # defaults to 0<br/>
  my $y = $x-&gt;copy();                   # make a true copy<br/>
  my $nan  = Math::BigInt-&gt;bnan();      # create a NotANumber<br/>
  my $zero = Math::BigInt-&gt;bzero();     # create a +0<br/>
  my $inf = Math::BigInt-&gt;binf();       # create a +inf<br/>
  my $inf = Math::BigInt-&gt;binf('-');    # create a -inf<br/>
  my $one = Math::BigInt-&gt;bone();       # create a +1<br/>
  my $mone = Math::BigInt-&gt;bone('-');   # create a -1<br/>
<br/>
  my $pi = Math::BigInt-&gt;bpi();         # returns '3'<br/>
                                        # see Math::BigFloat::bpi()<br/>
<br/>
  $h = Math::BigInt-&gt;new('0x123');      # from hexadecimal<br/>
  $b = Math::BigInt-&gt;new('0b101');      # from binary<br/>
  $o = Math::BigInt-&gt;from_oct('0101');  # from octal<br/>
<br/>
  # Testing (don't modify their arguments)<br/>
  # (return true if the condition is met, otherwise false)<br/>
<br/>
  $x-&gt;is_zero();        # if $x is +0<br/>
  $x-&gt;is_nan();         # if $x is NaN<br/>
  $x-&gt;is_one();         # if $x is +1<br/>
  $x-&gt;is_one('-');      # if $x is -1<br/>
  $x-&gt;is_odd();         # if $x is odd<br/>
  $x-&gt;is_even();        # if $x is even<br/>
  $x-&gt;is_pos();         # if $x &gt; 0<br/>
  $x-&gt;is_neg();         # if $x &lt; 0<br/>
  $x-&gt;is_inf($sign);    # if $x is +inf, or -inf (sign is default '+')<br/>
  $x-&gt;is_int();         # if $x is an integer (not a float)<br/>
<br/>
  # comparing and digit/sign extraction<br/>
  $x-&gt;bcmp($y);         # compare numbers (undef,&lt;0,=0,&gt;0)<br/>
  $x-&gt;bacmp($y);        # compare absolutely (undef,&lt;0,=0,&gt;0)<br/>
  $x-&gt;sign();           # return the sign, either +,- or NaN<br/>
  $x-&gt;digit($n);        # return the nth digit, counting from right<br/>
  $x-&gt;digit(-$n);       # return the nth digit, counting from left<br/>
<br/>
  # The following all modify their first argument. If you want to preserve<br/>
  # $x, use $z = $x-&gt;copy()-&gt;bXXX($y); See under L&lt;CAVEATS&gt; for why this is<br/>
  # necessary when mixing $a = $b assignments with non-overloaded math.<br/>
<br/>
  $x-&gt;bzero();          # set $x to 0<br/>
  $x-&gt;bnan();           # set $x to NaN<br/>
  $x-&gt;bone();           # set $x to +1<br/>
  $x-&gt;bone('-');        # set $x to -1<br/>
  $x-&gt;binf();           # set $x to inf<br/>
  $x-&gt;binf('-');        # set $x to -inf<br/>
<br/>
  $x-&gt;bneg();           # negation<br/>
  $x-&gt;babs();           # absolute value<br/>
  $x-&gt;bnorm();          # normalize (no-op in BigInt)<br/>
  $x-&gt;bnot();           # two's complement (bit wise not)<br/>
  $x-&gt;binc();           # increment $x by 1<br/>
  $x-&gt;bdec();           # decrement $x by 1<br/>
<br/>
  $x-&gt;badd($y);         # addition (add $y to $x)<br/>
  $x-&gt;bsub($y);         # subtraction (subtract $y from $x)<br/>
  $x-&gt;bmul($y);         # multiplication (multiply $x by $y)<br/>
  $x-&gt;bdiv($y);         # divide, set $x to quotient<br/>
                        # return (quo,rem) or quo if scalar<br/>
<br/>
  $x-&gt;bmuladd($y,$z);   # $x = $x * $y + $z<br/>
<br/>
  $x-&gt;bmod($y);            # modulus (x % y)<br/>
  $x-&gt;bmodpow($y,$mod);    # modular exponentiation (($x ** $y) % $mod)<br/>
  $x-&gt;bmodinv($mod);       # modular multiplicative inverse<br/>
  $x-&gt;bpow($y);            # power of arguments (x ** y)<br/>
  $x-&gt;blsft($y);           # left shift in base 2<br/>
  $x-&gt;brsft($y);           # right shift in base 2<br/>
                           # returns (quo,rem) or quo if in scalar context<br/>
  $x-&gt;blsft($y,$n);        # left shift by $y places in base $n<br/>
  $x-&gt;brsft($y,$n);        # right shift by $y places in base $n<br/>
                           # returns (quo,rem) or quo if in scalar context<br/>
<br/>
  $x-&gt;band($y);            # bitwise and<br/>
  $x-&gt;bior($y);            # bitwise inclusive or<br/>
  $x-&gt;bxor($y);            # bitwise exclusive or<br/>
  $x-&gt;bnot();              # bitwise not (two's complement)<br/>
<br/>
  $x-&gt;bsqrt();             # calculate square-root<br/>
  $x-&gt;broot($y);           # $y'th root of $x (e.g. $y == 3 =&gt; cubic root)<br/>
  $x-&gt;bfac();              # factorial of $x (1*2*3*4*..$x)<br/>
<br/>
  $x-&gt;bnok($y);            # x over y (binomial coefficient n over k)<br/>
<br/>
  $x-&gt;blog();              # logarithm of $x to base e (Euler's number)<br/>
  $x-&gt;blog($base);         # logarithm of $x to base $base (f.i. 2)<br/>
  $x-&gt;bexp();              # calculate e ** $x where e is Euler's number<br/>
<br/>
  $x-&gt;round($A,$P,$mode);  # round to accuracy or precision using mode $mode<br/>
  $x-&gt;bround($n);          # accuracy: preserve $n digits<br/>
  $x-&gt;bfround($n);         # $n &gt; 0: round $nth digits,<br/>
                           # $n &lt; 0: round to the $nth digit after the<br/>
                           # dot, no-op for BigInts<br/>
<br/>
  # The following do not modify their arguments in BigInt (are no-ops),<br/>
  # but do so in BigFloat:<br/>
<br/>
  $x-&gt;bfloor();            # return integer less or equal than $x<br/>
  $x-&gt;bceil();             # return integer greater or equal than $x<br/>
<br/>
  # The following do not modify their arguments:<br/>
<br/>
  # greatest common divisor (no OO style)<br/>
  my $gcd = Math::BigInt::bgcd(@values);<br/>
  # lowest common multiple (no OO style)<br/>
  my $lcm = Math::BigInt::blcm(@values);<br/>
<br/>
  $x-&gt;length();            # return number of digits in number<br/>
  ($xl,$f) = $x-&gt;length(); # length of number and length of fraction part,<br/>
                           # latter is always 0 digits long for BigInts<br/>
<br/>
  $x-&gt;exponent();          # return exponent as BigInt<br/>
  $x-&gt;mantissa();          # return (signed) mantissa as BigInt<br/>
  $x-&gt;parts();             # return (mantissa,exponent) as BigInt<br/>
  $x-&gt;copy();              # make a true copy of $x (unlike $y = $x;)<br/>
  $x-&gt;as_int();            # return as BigInt (in BigInt: same as copy())<br/>
  $x-&gt;numify();            # return as scalar (might overflow!)<br/>
<br/>
  # conversion to string (do not modify their argument)<br/>
  $x-&gt;bstr();              # normalized string (e.g. '3')<br/>
  $x-&gt;bsstr();             # norm. string in scientific notation (e.g. '3E0')<br/>
  $x-&gt;as_hex();            # as signed hexadecimal string with prefixed 0x<br/>
  $x-&gt;as_bin();            # as signed binary string with prefixed 0b<br/>
  $x-&gt;as_oct();            # as signed octal string with prefixed 0<br/>
<br/>
<br/>
  # precision and accuracy (see section about rounding for more)<br/>
  $x-&gt;precision();         # return P of $x (or global, if P of $x undef)<br/>
  $x-&gt;precision($n);       # set P of $x to $n<br/>
  $x-&gt;accuracy();          # return A of $x (or global, if A of $x undef)<br/>
  $x-&gt;accuracy($n);        # set A $x to $n<br/>
<br/>
  # Global methods<br/>
  Math::BigInt-&gt;precision();    # get/set global P for all BigInt objects<br/>
  Math::BigInt-&gt;accuracy();     # get/set global A for all BigInt objects<br/>
  Math::BigInt-&gt;round_mode();   # get/set global round mode, one of<br/>
                                # 'even', 'odd', '+inf', '-inf', 'zero', 'trunc' or 'common'<br/>
  Math::BigInt-&gt;config();       # return hash containing configuration<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> All operators (including basic math operations) are overloaded if you declare your big integers as<div class="spacer">
</div>
<br/>
  $i = new Math::BigInt '123_456_789_123_456_789';<br/>
<div class="spacer">
</div>
Operations with overloaded operators preserve the arguments which is exactly what you expect.<dl>
<dt>
Input</dt>
<dd>
Input values to these routines may be any string, that looks like a number and results in an integer, including hexadecimal and binary numbers.<div style="height: 1.00em;">
&#160;</div>
Scalars holding numbers may also be passed, but note that non-integer numbers may already have lost precision due to the conversion to float. Quote your input if you want BigInt to see all the digits:<div style="height: 1.00em;">
&#160;</div>
<br/>
        $x = Math::BigInt-&gt;new(12345678890123456789);   # bad<br/>
        $x = Math::BigInt-&gt;new('12345678901234567890'); # good<br/>
<div style="height: 1.00em;">
&#160;</div>
You can include one underscore between any two digits.<div style="height: 1.00em;">
&#160;</div>
This means integer values like 1.01E2 or even 1000E-2 are also accepted. Non-integer values result in NaN.<div style="height: 1.00em;">
&#160;</div>
Hexadecimal (prefixed with &quot;0x&quot;) and binary numbers (prefixed with &quot;0b&quot;) are accepted, too. Please note that octal numbers are not recognized by  <i>new()</i>, so the following will print &quot;123&quot;:<div style="height: 1.00em;">
&#160;</div>
<br/>
        perl -MMath::BigInt -le 'print Math::BigInt-&gt;new(&quot;0123&quot;)'<br/>
<div style="height: 1.00em;">
&#160;</div>
To convert an octal number, use <i>from_oct()</i>;<div style="height: 1.00em;">
&#160;</div>
<br/>
        perl -MMath::BigInt -le 'print Math::BigInt-&gt;from_oct(&quot;0123&quot;)'<br/>
<div style="height: 1.00em;">
&#160;</div>
Currently, <i>Math::BigInt::new()</i> defaults to 0, while Math::BigInt::new('') results in 'NaN'. This might change in the future, so use always the following explicit forms to get a zero or NaN:<div style="height: 1.00em;">
&#160;</div>
<br/>
        $zero = Math::BigInt-&gt;bzero();<br/>
        $nan = Math::BigInt-&gt;bnan();<br/>
<div style="height: 1.00em;">
&#160;</div>
&quot;bnorm()&quot; on a BigInt object is now effectively a no-op, since the numbers are always stored in normalized form. If passed a string, creates a BigInt object from the input.</dd>
</dl>
<dl>
<dt>
Output</dt>
<dd>
Output values are BigInt objects (normalized), except for the methods which return a string (see SYNOPSIS).<div style="height: 1.00em;">
&#160;</div>
Some routines (&quot;is_odd()&quot;, &quot;is_even()&quot;, &quot;is_zero()&quot;, &quot;is_one()&quot;, &quot;is_nan()&quot;, etc.) return true or false, while others (&quot;bcmp()&quot;, &quot;bacmp()&quot;) return either undef (if NaN is involved), &lt;0, 0 or &gt;0 and are suited for sort.</dd>
</dl>
</div>
<div class="section">
<h1>METHODS</h1> Each of the methods below (except  <i>config()</i>, <i>accuracy()</i> and <i>precision()</i>) accepts three additional parameters. These arguments $A, $P and $R are &quot;accuracy&quot;, &quot;precision&quot; and &quot;round_mode&quot;. Please see the section about &quot;ACCURACY and PRECISION&quot; for more information.<div class="subsection">
<h2><i>config()</i></h2><br/>
        use Data::Dumper;<br/>
<br/>
        print Dumper ( Math::BigInt-&gt;config() );<br/>
        print Math::BigInt-&gt;config()-&gt;{lib},&quot;\n&quot;;<br/>
<div class="spacer">
</div>
Returns a hash containing the configuration, e.g. the version number, lib loaded etc. The following hash keys are currently filled in with the appropriate information.<div class="spacer">
</div>
<br/>
        key             Description<br/>
                        Example<br/>
        ============================================================<br/>
        lib             Name of the low-level math library<br/>
                        Math::BigInt::Calc<br/>
        lib_version     Version of low-level math library (see 'lib')<br/>
                        0.30<br/>
        class           The class name of config() you just called<br/>
                        Math::BigInt<br/>
        upgrade         To which class math operations might be upgraded<br/>
                        Math::BigFloat<br/>
        downgrade       To which class math operations might be downgraded<br/>
                        undef<br/>
        precision       Global precision<br/>
                        undef<br/>
        accuracy        Global accuracy<br/>
                        undef<br/>
        round_mode      Global round mode<br/>
                        even<br/>
        version         version number of the class you used<br/>
                        1.61<br/>
        div_scale       Fallback accuracy for div<br/>
                        40<br/>
        trap_nan        If true, traps creation of NaN via croak()<br/>
                        1<br/>
        trap_inf        If true, traps creation of +inf/-inf via croak()<br/>
                        1<br/>
<div class="spacer">
</div>
The following values can be set by passing &quot;config()&quot; a reference to a hash:<div class="spacer">
</div>
<br/>
        trap_inf trap_nan<br/>
        upgrade downgrade precision accuracy round_mode div_scale<br/>
<div class="spacer">
</div>
Example:<div class="spacer">
</div>
<br/>
        $new_cfg = Math::BigInt-&gt;config( { trap_inf =&gt; 1, precision =&gt; 5 } );<br/>
</div>
<div class="subsection">
<h2><i>accuracy()</i></h2><br/>
        $x-&gt;accuracy(5);                # local for $x<br/>
        CLASS-&gt;accuracy(5);             # global for all members of CLASS<br/>
                                        # Note: This also applies to new()!<br/>
<br/>
        $A = $x-&gt;accuracy();            # read out accuracy that affects $x<br/>
        $A = CLASS-&gt;accuracy();         # read out global accuracy<br/>
<div class="spacer">
</div>
Set or get the global or local accuracy, aka how many significant digits the results have. If you set a global accuracy, then this also applies to  <i>new()</i>!<div class="spacer">
</div>
Warning! The accuracy <i>sticks</i>, e.g. once you created a number under the influence of &quot;CLASS-&gt;accuracy($A)&quot;, all results from math operations with that number will also be rounded.<div class="spacer">
</div>
In most cases, you should probably round the results explicitly using one of  <i>round()</i>, <i>bround()</i> or <i>bfround()</i> or by passing the desired accuracy to the math operation as additional parameter:<div class="spacer">
</div>
<br/>
        my $x = Math::BigInt-&gt;new(30000);<br/>
        my $y = Math::BigInt-&gt;new(7);<br/>
        print scalar $x-&gt;copy()-&gt;bdiv($y, 2);           # print 4300<br/>
        print scalar $x-&gt;copy()-&gt;bdiv($y)-&gt;bround(2);   # print 4300<br/>
<div class="spacer">
</div>
Please see the section about &quot;ACCURACY and PRECISION&quot; for further details.<div class="spacer">
</div>
Value must be greater than zero. Pass an undef value to disable it:<div class="spacer">
</div>
<br/>
        $x-&gt;accuracy(undef);<br/>
        Math::BigInt-&gt;accuracy(undef);<br/>
<div class="spacer">
</div>
Returns the current accuracy. For &quot;$x-&gt;accuracy()&quot; it will return either the local accuracy, or if not defined, the global. This means the return value represents the accuracy that will be in effect for $x:<div class="spacer">
</div>
<br/>
        $y = Math::BigInt-&gt;new(1234567);        # unrounded<br/>
        print Math::BigInt-&gt;accuracy(4),&quot;\n&quot;;   # set 4, print 4<br/>
        $x = Math::BigInt-&gt;new(123456);         # $x will be automatically rounded!<br/>
        print &quot;$x $y\n&quot;;                        # '123500 1234567'<br/>
        print $x-&gt;accuracy(),&quot;\n&quot;;              # will be 4<br/>
        print $y-&gt;accuracy(),&quot;\n&quot;;              # also 4, since global is 4<br/>
        print Math::BigInt-&gt;accuracy(5),&quot;\n&quot;;   # set to 5, print 5<br/>
        print $x-&gt;accuracy(),&quot;\n&quot;;              # still 4<br/>
        print $y-&gt;accuracy(),&quot;\n&quot;;              # 5, since global is 5<br/>
<div class="spacer">
</div>
Note: Works also for subclasses like Math::BigFloat. Each class has it's own globals separated from Math::BigInt, but it is possible to subclass Math::BigInt and make the globals of the subclass aliases to the ones from Math::BigInt.</div>
<div class="subsection">
<h2><i>precision()</i></h2><br/>
        $x-&gt;precision(-2);      # local for $x, round at the second digit right of the dot<br/>
        $x-&gt;precision(2);       # ditto, round at the second digit left of the dot<br/>
<br/>
        CLASS-&gt;precision(5);    # Global for all members of CLASS<br/>
                                # This also applies to new()!<br/>
        CLASS-&gt;precision(-5);   # ditto<br/>
<br/>
        $P = CLASS-&gt;precision();        # read out global precision<br/>
        $P = $x-&gt;precision();           # read out precision that affects $x<br/>
<div class="spacer">
</div>
Note: You probably want to use <i>accuracy()</i> instead. With accuracy you set the number of digits each result should have, with precision you set the place where to round!<div class="spacer">
</div>
&quot;precision()&quot; sets or gets the global or local precision, aka at which digit before or after the dot to round all results. A set global precision also applies to all newly created numbers!<div class="spacer">
</div>
In Math::BigInt, passing a negative number precision has no effect since no numbers have digits after the dot. In Math::BigFloat, it will round all results to P digits after the dot.<div class="spacer">
</div>
Please see the section about &quot;ACCURACY and PRECISION&quot; for further details.<div class="spacer">
</div>
Pass an undef value to disable it:<div class="spacer">
</div>
<br/>
        $x-&gt;precision(undef);<br/>
        Math::BigInt-&gt;precision(undef);<br/>
<div class="spacer">
</div>
Returns the current precision. For &quot;$x-&gt;precision()&quot; it will return either the local precision of $x, or if not defined, the global. This means the return value represents the prevision that will be in effect for $x:<div class="spacer">
</div>
<br/>
        $y = Math::BigInt-&gt;new(1234567);        # unrounded<br/>
        print Math::BigInt-&gt;precision(4),&quot;\n&quot;;  # set 4, print 4<br/>
        $x = Math::BigInt-&gt;new(123456);         # will be automatically rounded<br/>
        print $x;                               # print &quot;120000&quot;!<br/>
<div class="spacer">
</div>
Note: Works also for subclasses like Math::BigFloat. Each class has its own globals separated from Math::BigInt, but it is possible to subclass Math::BigInt and make the globals of the subclass aliases to the ones from Math::BigInt.</div>
<div class="subsection">
<h2><i>brsft()</i></h2><br/>
        $x-&gt;brsft($y,$n);<br/>
<div class="spacer">
</div>
Shifts $x right by $y in base $n. Default is base 2, used are usually 10 and 2, but others work, too.<div class="spacer">
</div>
Right shifting usually amounts to dividing $x by $n ** $y and truncating the result:<div class="spacer">
</div>
<br/>
        $x = Math::BigInt-&gt;new(10);<br/>
        $x-&gt;brsft(1);                   # same as $x &gt;&gt; 1: 5<br/>
        $x = Math::BigInt-&gt;new(1234);<br/>
        $x-&gt;brsft(2,10);                # result 12<br/>
<div class="spacer">
</div>
There is one exception, and that is base 2 with negative $x:<div class="spacer">
</div>
<br/>
        $x = Math::BigInt-&gt;new(-5);<br/>
        print $x-&gt;brsft(1);<br/>
<div class="spacer">
</div>
This will print -3, not -2 (as it would if you divide -5 by 2 and truncate the result).</div>
<div class="subsection">
<h2><i>new()</i></h2><br/>
        $x = Math::BigInt-&gt;new($str,$A,$P,$R);<br/>
<div class="spacer">
</div>
Creates a new BigInt object from a scalar or another BigInt object. The input is accepted as decimal, hex (with leading '0x') or binary (with leading '0b').<div class="spacer">
</div>
See Input for more info on accepted input formats.</div>
<div class="subsection">
<h2><i>from_oct()</i></h2><br/>
        $x = Math::BigInt-&gt;from_oct(&quot;0775&quot;);    # input is octal<br/>
<div class="spacer">
</div>
Interpret the input as an octal string and return the corresponding value. A &quot;0&quot; (zero) prefix is optional. A single underscore character may be placed right after the prefix, if present, or between any two digits. If the input is invalid, a NaN is returned.</div>
<div class="subsection">
<h2><i>from_hex()</i></h2><br/>
        $x = Math::BigInt-&gt;from_hex(&quot;0xcafe&quot;);  # input is hexadecimal<br/>
<div class="spacer">
</div>
Interpret input as a hexadecimal string. A &quot;0x&quot; or &quot;x&quot; prefix is optional. A single underscore character may be placed right after the prefix, if present, or between any two digits. If the input is invalid, a NaN is returned.</div>
<div class="subsection">
<h2><i>from_bin()</i></h2><br/>
        $x = Math::BigInt-&gt;from_bin(&quot;0b10011&quot;); # input is binary<br/>
<div class="spacer">
</div>
Interpret the input as a binary string. A &quot;0b&quot; or &quot;b&quot; prefix is optional. A single underscore character may be placed right after the prefix, if present, or between any two digits. If the input is invalid, a NaN is returned.</div>
<div class="subsection">
<h2><i>bnan()</i></h2><br/>
        $x = Math::BigInt-&gt;bnan();<br/>
<div class="spacer">
</div>
Creates a new BigInt object representing NaN (Not A Number). If used on an object, it will set it to NaN:<div class="spacer">
</div>
<br/>
        $x-&gt;bnan();<br/>
</div>
<div class="subsection">
<h2><i>bzero()</i></h2><br/>
        $x = Math::BigInt-&gt;bzero();<br/>
<div class="spacer">
</div>
Creates a new BigInt object representing zero. If used on an object, it will set it to zero:<div class="spacer">
</div>
<br/>
        $x-&gt;bzero();<br/>
</div>
<div class="subsection">
<h2><i>binf()</i></h2><br/>
        $x = Math::BigInt-&gt;binf($sign);<br/>
<div class="spacer">
</div>
Creates a new BigInt object representing infinity. The optional argument is either '-' or '+', indicating whether you want infinity or minus infinity. If used on an object, it will set it to infinity:<div class="spacer">
</div>
<br/>
        $x-&gt;binf();<br/>
        $x-&gt;binf('-');<br/>
</div>
<div class="subsection">
<h2><i>bone()</i></h2><br/>
        $x = Math::BigInt-&gt;binf($sign);<br/>
<div class="spacer">
</div>
Creates a new BigInt object representing one. The optional argument is either '-' or '+', indicating whether you want one or minus one. If used on an object, it will set it to one:<div class="spacer">
</div>
<br/>
        $x-&gt;bone();             # +1<br/>
        $x-&gt;bone('-');          # -1<br/>
</div>
<div class="subsection">
<h2><i>is_one()</i>/<i>is_zero()</i>/<i>is_nan()</i>/<i>is_inf()</i></h2><br/>
        $x-&gt;is_zero();                  # true if arg is +0<br/>
        $x-&gt;is_nan();                   # true if arg is NaN<br/>
        $x-&gt;is_one();                   # true if arg is +1<br/>
        $x-&gt;is_one('-');                # true if arg is -1<br/>
        $x-&gt;is_inf();                   # true if +inf<br/>
        $x-&gt;is_inf('-');                # true if -inf (sign is default '+')<br/>
<div class="spacer">
</div>
These methods all test the BigInt for being one specific value and return true or false depending on the input. These are faster than doing something like:<div class="spacer">
</div>
<br/>
        if ($x == 0)<br/>
</div>
<div class="subsection">
<h2><i>is_pos()</i>/<i>is_neg()</i>/<i>is_positive()</i>/<i>is_negative()</i></h2><br/>
        $x-&gt;is_pos();                   # true if &gt; 0<br/>
        $x-&gt;is_neg();                   # true if &lt; 0<br/>
<div class="spacer">
</div>
The methods return true if the argument is positive or negative, respectively. &quot;NaN&quot; is neither positive nor negative, while &quot;+inf&quot; counts as positive, and &quot;-inf&quot; is negative. A &quot;zero&quot; is neither positive nor negative.<div class="spacer">
</div>
These methods are only testing the sign, and not the value.<div class="spacer">
</div>
&quot;is_positive()&quot; and &quot;is_negative()&quot; are aliases to &quot;is_pos()&quot; and &quot;is_neg()&quot;, respectively. &quot;is_positive()&quot; and &quot;is_negative()&quot; were introduced in v1.36, while &quot;is_pos()&quot; and &quot;is_neg()&quot; were only introduced in v1.68.</div>
<div class="subsection">
<h2><i>is_odd()</i>/<i>is_even()</i>/<i>is_int()</i></h2><br/>
        $x-&gt;is_odd();                   # true if odd, false for even<br/>
        $x-&gt;is_even();                  # true if even, false for odd<br/>
        $x-&gt;is_int();                   # true if $x is an integer<br/>
<div class="spacer">
</div>
The return true when the argument satisfies the condition. &quot;NaN&quot;, &quot;+inf&quot;, &quot;-inf&quot; are not integers and are neither odd nor even.<div class="spacer">
</div>
In BigInt, all numbers except &quot;NaN&quot;, &quot;+inf&quot; and &quot;-inf&quot; are integers.</div>
<div class="subsection">
<h2><i>bcmp()</i></h2><br/>
        $x-&gt;bcmp($y);<br/>
<div class="spacer">
</div>
Compares $x with $y and takes the sign into account. Returns -1, 0, 1 or undef.</div>
<div class="subsection">
<h2><i>bacmp()</i></h2><br/>
        $x-&gt;bacmp($y);<br/>
<div class="spacer">
</div>
Compares $x with $y while ignoring their sign. Returns -1, 0, 1 or undef.</div>
<div class="subsection">
<h2><i>sign()</i></h2><br/>
        $x-&gt;sign();<br/>
<div class="spacer">
</div>
Return the sign, of $x, meaning either &quot;+&quot;, &quot;-&quot;, &quot;-inf&quot;, &quot;+inf&quot; or NaN.<div class="spacer">
</div>
If you want $x to have a certain sign, use one of the following methods:<div class="spacer">
</div>
<br/>
        $x-&gt;babs();             # '+'<br/>
        $x-&gt;babs()-&gt;bneg();     # '-'<br/>
        $x-&gt;bnan();             # 'NaN'<br/>
        $x-&gt;binf();             # '+inf'<br/>
        $x-&gt;binf('-');          # '-inf'<br/>
</div>
<div class="subsection">
<h2><i>digit()</i></h2><br/>
        $x-&gt;digit($n);          # return the nth digit, counting from right<br/>
<div class="spacer">
</div>
If $n is negative, returns the digit counting from left.</div>
<div class="subsection">
<h2><i>bneg()</i></h2><br/>
        $x-&gt;bneg();<br/>
<div class="spacer">
</div>
Negate the number, e.g. change the sign between '+' and '-', or between '+inf' and '-inf', respectively. Does nothing for NaN or zero.</div>
<div class="subsection">
<h2><i>babs()</i></h2><br/>
        $x-&gt;babs();<br/>
<div class="spacer">
</div>
Set the number to its absolute value, e.g. change the sign from '-' to '+' and from '-inf' to '+inf', respectively. Does nothing for NaN or positive numbers.</div>
<div class="subsection">
<h2><i>bnorm()</i></h2><br/>
        $x-&gt;bnorm();                    # normalize (no-op)<br/>
</div>
<div class="subsection">
<h2><i>bnot()</i></h2><br/>
        $x-&gt;bnot();<br/>
<div class="spacer">
</div>
Two's complement (bitwise not). This is equivalent to<div class="spacer">
</div>
<br/>
        $x-&gt;binc()-&gt;bneg();<br/>
<div class="spacer">
</div>
but faster.</div>
<div class="subsection">
<h2><i>binc()</i></h2><br/>
        $x-&gt;binc();                     # increment x by 1<br/>
</div>
<div class="subsection">
<h2><i>bdec()</i></h2><br/>
        $x-&gt;bdec();                     # decrement x by 1<br/>
</div>
<div class="subsection">
<h2><i>badd()</i></h2><br/>
        $x-&gt;badd($y);                   # addition (add $y to $x)<br/>
</div>
<div class="subsection">
<h2><i>bsub()</i></h2><br/>
        $x-&gt;bsub($y);                   # subtraction (subtract $y from $x)<br/>
</div>
<div class="subsection">
<h2><i>bmul()</i></h2><br/>
        $x-&gt;bmul($y);                   # multiplication (multiply $x by $y)<br/>
</div>
<div class="subsection">
<h2><i>bmuladd()</i></h2><br/>
        $x-&gt;bmuladd($y,$z);<br/>
<div class="spacer">
</div>
Multiply $x by $y, and then add $z to the result,<div class="spacer">
</div>
This method was added in v1.87 of Math::BigInt (June 2007).</div>
<div class="subsection">
<h2><i>bdiv()</i></h2><br/>
        $x-&gt;bdiv($y);                   # divide, set $x to quotient<br/>
                                        # return (quo,rem) or quo if scalar<br/>
</div>
<div class="subsection">
<h2><i>bmod()</i></h2><br/>
        $x-&gt;bmod($y);                   # modulus (x % y)<br/>
</div>
<div class="subsection">
<h2><i>bmodinv()</i></h2><br/>
        $x-&gt;bmodinv($mod);              # modular multiplicative inverse<br/>
<div class="spacer">
</div>
Returns the multiplicative inverse of $x modulo $mod. If<div class="spacer">
</div>
<br/>
        $y = $x -&gt; copy() -&gt; bmodinv($mod)<br/>
<div class="spacer">
</div>
then $y is the number closest to zero, and with the same sign as $mod, satisfying<div class="spacer">
</div>
<br/>
        ($x * $y) % $mod = 1 % $mod<br/>
<div class="spacer">
</div>
If $x and $y are non-zero, they must be relative primes, i.e., &quot;bgcd($y, $mod)==1&quot;. '&quot;NaN&quot;' is returned when no modular multiplicative inverse exists.</div>
<div class="subsection">
<h2><i>bmodpow()</i></h2><br/>
        $num-&gt;bmodpow($exp,$mod);       # modular exponentiation<br/>
                                        # ($num**$exp % $mod)<br/>
<div class="spacer">
</div>
Returns the value of $num taken to the power $exp in the modulus $mod using binary exponentiation.  &quot;bmodpow&quot; is far superior to writing<div class="spacer">
</div>
<br/>
        $num ** $exp % $mod<br/>
<div class="spacer">
</div>
because it is much faster - it reduces internal variables into the modulus whenever possible, so it operates on smaller numbers.<div class="spacer">
</div>
&quot;bmodpow&quot; also supports negative exponents.<div class="spacer">
</div>
<br/>
        bmodpow($num, -1, $mod)<br/>
<div class="spacer">
</div>
is exactly equivalent to<div class="spacer">
</div>
<br/>
        bmodinv($num, $mod)<br/>
</div>
<div class="subsection">
<h2><i>bpow()</i></h2><br/>
        $x-&gt;bpow($y);                   # power of arguments (x ** y)<br/>
</div>
<div class="subsection">
<h2><i>blog()</i></h2><br/>
        $x-&gt;blog($base, $accuracy);     # logarithm of x to the base $base<br/>
<div class="spacer">
</div>
If $base is not defined, Euler's number (e) is used:<div class="spacer">
</div>
<br/>
        print $x-&gt;blog(undef, 100);     # log(x) to 100 digits<br/>
</div>
<div class="subsection">
<h2><i>bexp()</i></h2><br/>
        $x-&gt;bexp($accuracy);            # calculate e ** X<br/>
<div class="spacer">
</div>
Calculates the expression &quot;e ** $x&quot; where &quot;e&quot; is Euler's number.<div class="spacer">
</div>
This method was added in v1.82 of Math::BigInt (April 2007).<div class="spacer">
</div>
See also <i>blog()</i>.</div>
<div class="subsection">
<h2><i>bnok()</i></h2><br/>
        $x-&gt;bnok($y);              # x over y (binomial coefficient n over k)<br/>
<div class="spacer">
</div>
Calculates the binomial coefficient n over k, also called the &quot;choose&quot; function. The result is equivalent to:<div class="spacer">
</div>
<br/>
        ( n )      n!<br/>
        | - |  = -------<br/>
        ( k )    k!(n-k)!<br/>
<div class="spacer">
</div>
This method was added in v1.84 of Math::BigInt (April 2007).</div>
<div class="subsection">
<h2><i>bpi()</i></h2><br/>
        print Math::BigInt-&gt;bpi(100), &quot;\n&quot;;             # 3<br/>
<div class="spacer">
</div>
Returns PI truncated to an integer, with the argument being ignored. This means under BigInt this always returns 3.<div class="spacer">
</div>
If upgrading is in effect, returns PI, rounded to N digits with the current rounding mode:<div class="spacer">
</div>
<br/>
        use Math::BigFloat;<br/>
        use Math::BigInt upgrade =&gt; Math::BigFloat;<br/>
        print Math::BigInt-&gt;bpi(3), &quot;\n&quot;;               # 3.14<br/>
        print Math::BigInt-&gt;bpi(100), &quot;\n&quot;;             # 3.1415....<br/>
<div class="spacer">
</div>
This method was added in v1.87 of Math::BigInt (June 2007).</div>
<div class="subsection">
<h2><i>bcos()</i></h2><br/>
        my $x = Math::BigInt-&gt;new(1);<br/>
        print $x-&gt;bcos(100), &quot;\n&quot;;<br/>
<div class="spacer">
</div>
Calculate the cosinus of $x, modifying $x in place.<div class="spacer">
</div>
In BigInt, unless upgrading is in effect, the result is truncated to an integer.<div class="spacer">
</div>
This method was added in v1.87 of Math::BigInt (June 2007).</div>
<div class="subsection">
<h2><i>bsin()</i></h2><br/>
        my $x = Math::BigInt-&gt;new(1);<br/>
        print $x-&gt;bsin(100), &quot;\n&quot;;<br/>
<div class="spacer">
</div>
Calculate the sinus of $x, modifying $x in place.<div class="spacer">
</div>
In BigInt, unless upgrading is in effect, the result is truncated to an integer.<div class="spacer">
</div>
This method was added in v1.87 of Math::BigInt (June 2007).</div>
<div class="subsection">
<h2><i>batan2()</i></h2><br/>
        my $x = Math::BigInt-&gt;new(1);<br/>
        my $y = Math::BigInt-&gt;new(1);<br/>
        print $y-&gt;batan2($x), &quot;\n&quot;;<br/>
<div class="spacer">
</div>
Calculate the arcus tangens of $y divided by $x, modifying $y in place.<div class="spacer">
</div>
In BigInt, unless upgrading is in effect, the result is truncated to an integer.<div class="spacer">
</div>
This method was added in v1.87 of Math::BigInt (June 2007).</div>
<div class="subsection">
<h2><i>batan()</i></h2><br/>
        my $x = Math::BigFloat-&gt;new(0.5);<br/>
        print $x-&gt;batan(100), &quot;\n&quot;;<br/>
<div class="spacer">
</div>
Calculate the arcus tangens of $x, modifying $x in place.<div class="spacer">
</div>
In BigInt, unless upgrading is in effect, the result is truncated to an integer.<div class="spacer">
</div>
This method was added in v1.87 of Math::BigInt (June 2007).</div>
<div class="subsection">
<h2><i>blsft()</i></h2><br/>
        $x-&gt;blsft($y);          # left shift in base 2<br/>
        $x-&gt;blsft($y,$n);       # left shift, in base $n (like 10)<br/>
</div>
<div class="subsection">
<h2><i>brsft()</i></h2><br/>
        $x-&gt;brsft($y);          # right shift in base 2<br/>
        $x-&gt;brsft($y,$n);       # right shift, in base $n (like 10)<br/>
</div>
<div class="subsection">
<h2><i>band()</i></h2><br/>
        $x-&gt;band($y);                   # bitwise and<br/>
</div>
<div class="subsection">
<h2><i>bior()</i></h2><br/>
        $x-&gt;bior($y);                   # bitwise inclusive or<br/>
</div>
<div class="subsection">
<h2><i>bxor()</i></h2><br/>
        $x-&gt;bxor($y);                   # bitwise exclusive or<br/>
</div>
<div class="subsection">
<h2><i>bnot()</i></h2><br/>
        $x-&gt;bnot();                     # bitwise not (two's complement)<br/>
</div>
<div class="subsection">
<h2><i>bsqrt()</i></h2><br/>
        $x-&gt;bsqrt();                    # calculate square-root<br/>
</div>
<div class="subsection">
<h2><i>broot()</i></h2><br/>
        $x-&gt;broot($N);<br/>
<div class="spacer">
</div>
Calculates the N'th root of $x.</div>
<div class="subsection">
<h2><i>bfac()</i></h2><br/>
        $x-&gt;bfac();                     # factorial of $x (1*2*3*4*..$x)<br/>
</div>
<div class="subsection">
<h2><i>round()</i></h2><br/>
        $x-&gt;round($A,$P,$round_mode);<br/>
<div class="spacer">
</div>
Round $x to accuracy $A or precision $P using the round mode $round_mode.</div>
<div class="subsection">
<h2><i>bround()</i></h2><br/>
        $x-&gt;bround($N);               # accuracy: preserve $N digits<br/>
</div>
<div class="subsection">
<h2><i>bfround()</i></h2><br/>
        $x-&gt;bfround($N);<br/>
<div class="spacer">
</div>
If N is &gt; 0, rounds to the Nth digit from the left. If N &lt; 0, rounds to the Nth digit after the dot. Since BigInts are integers, the case N &lt; 0 is a no-op for them.<div class="spacer">
</div>
Examples:<div class="spacer">
</div>
<br/>
        Input           N               Result<br/>
        ===================================================<br/>
        123456.123456   3               123500<br/>
        123456.123456   2               123450<br/>
        123456.123456   -2              123456.12<br/>
        123456.123456   -3              123456.123<br/>
</div>
<div class="subsection">
<h2><i>bfloor()</i></h2><br/>
        $x-&gt;bfloor();<br/>
<div class="spacer">
</div>
Set $x to the integer less or equal than $x. This is a no-op in BigInt, but does change $x in BigFloat.</div>
<div class="subsection">
<h2><i>bceil()</i></h2><br/>
        $x-&gt;bceil();<br/>
<div class="spacer">
</div>
Set $x to the integer greater or equal than $x. This is a no-op in BigInt, but does change $x in BigFloat.</div>
<div class="subsection">
<h2><i>bgcd()</i></h2><br/>
        bgcd(@values);          # greatest common divisor (no OO style)<br/>
</div>
<div class="subsection">
<h2><i>blcm()</i></h2><br/>
        blcm(@values);          # lowest common multiple (no OO style)<br/>
<div class="spacer">
</div>
head2 <i>length()</i><div class="spacer">
</div>
<br/>
        $x-&gt;length();<br/>
        ($xl,$fl) = $x-&gt;length();<br/>
<div class="spacer">
</div>
Returns the number of digits in the decimal representation of the number. In list context, returns the length of the integer and fraction part. For BigInt's, the length of the fraction part will always be 0.</div>
<div class="subsection">
<h2><i>exponent()</i></h2><br/>
        $x-&gt;exponent();<br/>
<div class="spacer">
</div>
Return the exponent of $x as BigInt.</div>
<div class="subsection">
<h2><i>mantissa()</i></h2><br/>
        $x-&gt;mantissa();<br/>
<div class="spacer">
</div>
Return the signed mantissa of $x as BigInt.</div>
<div class="subsection">
<h2><i>parts()</i></h2><br/>
        $x-&gt;parts();            # return (mantissa,exponent) as BigInt<br/>
</div>
<div class="subsection">
<h2><i>copy()</i></h2><br/>
        $x-&gt;copy();             # make a true copy of $x (unlike $y = $x;)<br/>
</div>
<div class="subsection">
<h2><i>as_int()</i>/<i>as_number()</i></h2><br/>
        $x-&gt;as_int();<br/>
<div class="spacer">
</div>
Returns $x as a BigInt (truncated towards zero). In BigInt this is the same as &quot;copy()&quot;.<div class="spacer">
</div>
&quot;as_number()&quot; is an alias to this method. &quot;as_number&quot; was introduced in v1.22, while &quot;as_int()&quot; was only introduced in v1.68.</div>
<div class="subsection">
<h2><i>bstr()</i></h2><br/>
        $x-&gt;bstr();<br/>
<div class="spacer">
</div>
Returns a normalized string representation of $x.</div>
<div class="subsection">
<h2><i>bsstr()</i></h2><br/>
        $x-&gt;bsstr();            # normalized string in scientific notation<br/>
</div>
<div class="subsection">
<h2><i>as_hex()</i></h2><br/>
        $x-&gt;as_hex();           # as signed hexadecimal string with prefixed 0x<br/>
</div>
<div class="subsection">
<h2><i>as_bin()</i></h2><br/>
        $x-&gt;as_bin();           # as signed binary string with prefixed 0b<br/>
</div>
<div class="subsection">
<h2><i>as_oct()</i></h2><br/>
        $x-&gt;as_oct();           # as signed octal string with prefixed 0<br/>
</div>
<div class="subsection">
<h2><i>numify()</i></h2><br/>
        print $x-&gt;numify();<br/>
<div class="spacer">
</div>
This returns a normal Perl scalar from $x. It is used automatically whenever a scalar is needed, for instance in array index operations.<div class="spacer">
</div>
This loses precision, to avoid this use <i>as_int()</i> instead.</div>
<div class="subsection">
<h2><i>modify()</i></h2><br/>
        $x-&gt;modify('bpowd');<br/>
<div class="spacer">
</div>
This method returns 0 if the object can be modified with the given operation, or 1 if not.<div class="spacer">
</div>
This is used for instance by Math::BigInt::Constant.</div>
<div class="subsection">
<h2><i>upgrade()</i>/<i>downgrade()</i></h2> Set/get the class for downgrade/upgrade operations. Thuis is used for instance by bignum. The defaults are '', thus the following operation will create a BigInt, not a BigFloat:<div class="spacer">
</div>
<br/>
        my $i = Math::BigInt-&gt;new(123);<br/>
        my $f = Math::BigFloat-&gt;new('123.1');<br/>
<br/>
        print $i + $f,&quot;\n&quot;;                     # print 246<br/>
</div>
<div class="subsection">
<h2><i>div_scale()</i></h2> Set/get the number of digits for the default precision in divide operations.</div>
<div class="subsection">
<h2><i>round_mode()</i></h2> Set/get the current round mode.</div>
</div>
<div class="section">
<h1>ACCURACY and PRECISION</h1> Since version v1.33, Math::BigInt and Math::BigFloat have full support for accuracy and precision based rounding, both automatically after every operation, as well as manually.<div class="spacer">
</div>
This section describes the accuracy/precision handling in Math::Big* as it used to be and as it is now, complete with an explanation of all terms and abbreviations.<div class="spacer">
</div>
Not yet implemented things (but with correct description) are marked with '!', things that need to be answered are marked with '?'.<div class="spacer">
</div>
In the next paragraph follows a short description of terms used here (because these may differ from terms used by others people or documentation).<div class="spacer">
</div>
During the rest of this document, the shortcuts A (for accuracy), P (for precision), F (fallback) and R (rounding mode) will be used.<div class="subsection">
<h2>Precision P</h2> A fixed number of digits before (positive) or after (negative) the decimal point. For example, 123.45 has a precision of -2. 0 means an integer like 123 (or 120). A precision of 2 means two digits to the left of the decimal point are zero, so 123 with P = 1 becomes 120. Note that numbers with zeros before the decimal point may have different precisions, because 1200 can have p = 0, 1 or 2 (depending on what the initial value was). It could also have p &lt; 0, when the digits after the decimal point are zero.<div class="spacer">
</div>
The string output (of floating point numbers) will be padded with zeros:<div class="spacer">
</div>
<br/>
        Initial value   P       A       Result          String<br/>
        ------------------------------------------------------------<br/>
        1234.01         -3              1000            1000<br/>
        1234            -2              1200            1200<br/>
        1234.5          -1              1230            1230<br/>
        1234.001        1               1234            1234.0<br/>
        1234.01         0               1234            1234<br/>
        1234.01         2               1234.01         1234.01<br/>
        1234.01         5               1234.01         1234.01000<br/>
<div class="spacer">
</div>
For BigInts, no padding occurs.</div>
<div class="subsection">
<h2>Accuracy A</h2> Number of significant digits. Leading zeros are not counted. A number may have an accuracy greater than the non-zero digits when there are zeros in it or trailing zeros. For example, 123.456 has A of 6, 10203 has 5, 123.0506 has 7, 123.450000 has 8 and 0.000123 has 3.<div class="spacer">
</div>
The string output (of floating point numbers) will be padded with zeros:<div class="spacer">
</div>
<br/>
        Initial value   P       A       Result          String<br/>
        ------------------------------------------------------------<br/>
        1234.01                 3       1230            1230<br/>
        1234.01                 6       1234.01         1234.01<br/>
        1234.1                  8       1234.1          1234.1000<br/>
<div class="spacer">
</div>
For BigInts, no padding occurs.</div>
<div class="subsection">
<h2>Fallback F</h2> When both A and P are undefined, this is used as a fallback accuracy when dividing numbers.</div>
<div class="subsection">
<h2>Rounding mode R</h2> When rounding a number, different 'styles' or 'kinds' of rounding are possible. (Note that random rounding, as in Math::Round, is not implemented.)<dl>
<dt>
'trunc'</dt>
<dd>
truncation invariably removes all digits following the rounding place, replacing them with zeros. Thus, 987.65 rounded to tens (P=1) becomes 980, and rounded to the fourth sigdig becomes 987.6 (A=4). 123.456 rounded to the second place after the decimal point (P=-2) becomes 123.46.<div style="height: 1.00em;">
&#160;</div>
All other implemented styles of rounding attempt to round to the &quot;nearest digit.&quot; If the digit D immediately to the right of the rounding place (skipping the decimal point) is greater than 5, the number is incremented at the rounding place (possibly causing a cascade of incrementation): e.g. when rounding to units, 0.9 rounds to 1, and -19.9 rounds to -20. If D &lt; 5, the number is similarly truncated at the rounding place: e.g. when rounding to units, 0.4 rounds to 0, and -19.4 rounds to -19.<div style="height: 1.00em;">
&#160;</div>
However the results of other styles of rounding differ if the digit immediately to the right of the rounding place (skipping the decimal point) is 5 and if there are no digits, or no digits other than 0, after that 5. In such cases:</dd>
</dl>
<dl>
<dt>
'even'</dt>
<dd>
rounds the digit at the rounding place to 0, 2, 4, 6, or 8 if it is not already. E.g., when rounding to the first sigdig, 0.45 becomes 0.4, -0.55 becomes -0.6, but 0.4501 becomes 0.5.</dd>
</dl>
<dl>
<dt>
'odd'</dt>
<dd>
rounds the digit at the rounding place to 1, 3, 5, 7, or 9 if it is not already. E.g., when rounding to the first sigdig, 0.45 becomes 0.5, -0.55 becomes -0.5, but 0.5501 becomes 0.6.</dd>
</dl>
<dl>
<dt>
'+inf'</dt>
<dd>
round to plus infinity, i.e. always round up. E.g., when rounding to the first sigdig, 0.45 becomes 0.5, -0.55 becomes -0.5, and 0.4501 also becomes 0.5.</dd>
</dl>
<dl>
<dt>
'-inf'</dt>
<dd>
round to minus infinity, i.e. always round down. E.g., when rounding to the first sigdig, 0.45 becomes 0.4, -0.55 becomes -0.6, but 0.4501 becomes 0.5.</dd>
</dl>
<dl>
<dt>
'zero'</dt>
<dd>
round to zero, i.e. positive numbers down, negative ones up. E.g., when rounding to the first sigdig, 0.45 becomes 0.4, -0.55 becomes -0.5, but 0.4501 becomes 0.5.</dd>
</dl>
<dl>
<dt>
'common'</dt>
<dd>
round up if the digit immediately to the right of the rounding place is 5 or greater, otherwise round down. E.g., 0.15 becomes 0.2 and 0.149 becomes 0.1.</dd>
</dl>
<div class="spacer">
</div>
The handling of A &amp; P in MBI/MBF (the old core code shipped with Perl versions &lt;= 5.7.2) is like this:<dl>
<dt>
Precision</dt>
<dd>
<br/>
  * ffround($p) is able to round to $p number of digits after the decimal<br/>
    point<br/>
  * otherwise P is unused<br/>
</dd>
</dl>
<dl>
<dt>
Accuracy (significant digits)</dt>
<dd>
<br/>
  * fround($a) rounds to $a significant digits<br/>
  * only fdiv() and fsqrt() take A as (optional) parameter<br/>
    + other operations simply create the same number (fneg etc), or more (fmul)<br/>
      of digits<br/>
    + rounding/truncating is only done when explicitly calling one of fround<br/>
      or ffround, and never for BigInt (not implemented)<br/>
  * fsqrt() simply hands its accuracy argument over to fdiv.<br/>
  * the documentation and the comment in the code indicate two different ways<br/>
    on how fdiv() determines the maximum number of digits it should calculate,<br/>
    and the actual code does yet another thing<br/>
    POD:<br/>
      max($Math::BigFloat::div_scale,length(dividend)+length(divisor))<br/>
    Comment:<br/>
      result has at most max(scale, length(dividend), length(divisor)) digits<br/>
    Actual code:<br/>
      scale = max(scale, length(dividend)-1,length(divisor)-1);<br/>
      scale += length(divisor) - length(dividend);<br/>
    So for lx = 3, ly = 9, scale = 10, scale will actually be 16 (10+9-3).<br/>
    Actually, the 'difference' added to the scale is calculated from the<br/>
    number of &quot;significant digits&quot; in dividend and divisor, which is derived<br/>
    by looking at the length of the mantissa. Which is wrong, since it includes<br/>
    the + sign (oops) and actually gets 2 for '+100' and 4 for '+101'. Oops<br/>
    again. Thus 124/3 with div_scale=1 will get you '41.3' based on the strange<br/>
    assumption that 124 has 3 significant digits, while 120/7 will get you<br/>
    '17', not '17.1' since 120 is thought to have 2 significant digits.<br/>
    The rounding after the division then uses the remainder and $y to determine<br/>
    whether it must round up or down.<br/>
 ?  I have no idea which is the right way. That's why I used a slightly more<br/>
 ?  simple scheme and tweaked the few failing testcases to match it.<br/>
</dd>
</dl>
<div class="spacer">
</div>
This is how it works now:<dl>
<dt>
Setting/Accessing</dt>
<dd>
<br/>
  * You can set the A global via C&lt;&lt; Math::BigInt-&gt;accuracy() &gt;&gt; or<br/>
    C&lt;&lt; Math::BigFloat-&gt;accuracy() &gt;&gt; or whatever class you are using.<br/>
  * You can also set P globally by using C&lt;&lt; Math::SomeClass-&gt;precision() &gt;&gt;<br/>
    likewise.<br/>
  * Globals are classwide, and not inherited by subclasses.<br/>
  * to undefine A, use C&lt;&lt; Math::SomeCLass-&gt;accuracy(undef); &gt;&gt;<br/>
  * to undefine P, use C&lt;&lt; Math::SomeClass-&gt;precision(undef); &gt;&gt;<br/>
  * Setting C&lt;&lt; Math::SomeClass-&gt;accuracy() &gt;&gt; clears automatically<br/>
    C&lt;&lt; Math::SomeClass-&gt;precision() &gt;&gt;, and vice versa.<br/>
  * To be valid, A must be &gt; 0, P can have any value.<br/>
  * If P is negative, this means round to the P'th place to the right of the<br/>
    decimal point; positive values mean to the left of the decimal point.<br/>
    P of 0 means round to integer.<br/>
  * to find out the current global A, use C&lt;&lt; Math::SomeClass-&gt;accuracy() &gt;&gt;<br/>
  * to find out the current global P, use C&lt;&lt; Math::SomeClass-&gt;precision() &gt;&gt;<br/>
  * use C&lt;&lt; $x-&gt;accuracy() &gt;&gt; respective C&lt;&lt; $x-&gt;precision() &gt;&gt; for the local<br/>
    setting of C&lt;&lt; $x &gt;&gt;.<br/>
  * Please note that C&lt;&lt; $x-&gt;accuracy() &gt;&gt; respective C&lt;&lt; $x-&gt;precision() &gt;&gt;<br/>
    return eventually defined global A or P, when C&lt;&lt; $x &gt;&gt;'s A or P is not<br/>
    set.<br/>
</dd>
</dl>
<dl>
<dt>
Creating numbers</dt>
<dd>
<br/>
  * When you create a number, you can give the desired A or P via:<br/>
    $x = Math::BigInt-&gt;new($number,$A,$P);<br/>
  * Only one of A or P can be defined, otherwise the result is NaN<br/>
  * If no A or P is give ($x = Math::BigInt-&gt;new($number) form), then the<br/>
    globals (if set) will be used. Thus changing the global defaults later on<br/>
    will not change the A or P of previously created numbers (i.e., A and P of<br/>
    $x will be what was in effect when $x was created)<br/>
  * If given undef for A and P, B&lt;no&gt; rounding will occur, and the globals will<br/>
    B&lt;not&gt; be used. This is used by subclasses to create numbers without<br/>
    suffering rounding in the parent. Thus a subclass is able to have its own<br/>
    globals enforced upon creation of a number by using<br/>
    C&lt;&lt; $x = Math::BigInt-&gt;new($number,undef,undef) &gt;&gt;:<br/>
<br/>
        use Math::BigInt::SomeSubclass;<br/>
        use Math::BigInt;<br/>
<br/>
        Math::BigInt-&gt;accuracy(2);<br/>
        Math::BigInt::SomeSubClass-&gt;accuracy(3);<br/>
        $x = Math::BigInt::SomeSubClass-&gt;new(1234);<br/>
<br/>
    $x is now 1230, and not 1200. A subclass might choose to implement<br/>
    this otherwise, e.g. falling back to the parent's A and P.<br/>
</dd>
</dl>
<dl>
<dt>
Usage</dt>
<dd>
<br/>
  * If A or P are enabled/defined, they are used to round the result of each<br/>
    operation according to the rules below<br/>
  * Negative P is ignored in Math::BigInt, since BigInts never have digits<br/>
    after the decimal point<br/>
  * Math::BigFloat uses Math::BigInt internally, but setting A or P inside<br/>
    Math::BigInt as globals does not tamper with the parts of a BigFloat.<br/>
    A flag is used to mark all Math::BigFloat numbers as 'never round'.<br/>
</dd>
</dl>
<dl>
<dt>
Precedence</dt>
<dd>
<br/>
  * It only makes sense that a number has only one of A or P at a time.<br/>
    If you set either A or P on one object, or globally, the other one will<br/>
    be automatically cleared.<br/>
  * If two objects are involved in an operation, and one of them has A in<br/>
    effect, and the other P, this results in an error (NaN).<br/>
  * A takes precedence over P (Hint: A comes before P).<br/>
    If neither of them is defined, nothing is used, i.e. the result will have<br/>
    as many digits as it can (with an exception for fdiv/fsqrt) and will not<br/>
    be rounded.<br/>
  * There is another setting for fdiv() (and thus for fsqrt()). If neither of<br/>
    A or P is defined, fdiv() will use a fallback (F) of $div_scale digits.<br/>
    If either the dividend's or the divisor's mantissa has more digits than<br/>
    the value of F, the higher value will be used instead of F.<br/>
    This is to limit the digits (A) of the result (just consider what would<br/>
    happen with unlimited A and P in the case of 1/3 :-)<br/>
  * fdiv will calculate (at least) 4 more digits than required (determined by<br/>
    A, P or F), and, if F is not used, round the result<br/>
    (this will still fail in the case of a result like 0.12345000000001 with A<br/>
    or P of 5, but this can not be helped - or can it?)<br/>
  * Thus you can have the math done by on Math::Big* class in two modi:<br/>
    + never round (this is the default):<br/>
      This is done by setting A and P to undef. No math operation<br/>
      will round the result, with fdiv() and fsqrt() as exceptions to guard<br/>
      against overflows. You must explicitly call bround(), bfround() or<br/>
      round() (the latter with parameters).<br/>
      Note: Once you have rounded a number, the settings will 'stick' on it<br/>
      and 'infect' all other numbers engaged in math operations with it, since<br/>
      local settings have the highest precedence. So, to get SaferRound[tm],<br/>
      use a copy() before rounding like this:<br/>
<br/>
        $x = Math::BigFloat-&gt;new(12.34);<br/>
        $y = Math::BigFloat-&gt;new(98.76);<br/>
        $z = $x * $y;                           # 1218.6984<br/>
        print $x-&gt;copy()-&gt;fround(3);            # 12.3 (but A is now 3!)<br/>
        $z = $x * $y;                           # still 1218.6984, without<br/>
                                                # copy would have been 1210!<br/>
<br/>
    + round after each op:<br/>
      After each single operation (except for testing like is_zero()), the<br/>
      method round() is called and the result is rounded appropriately. By<br/>
      setting proper values for A and P, you can have all-the-same-A or<br/>
      all-the-same-P modes. For example, Math::Currency might set A to undef,<br/>
      and P to -2, globally.<br/>
<br/>
 ?Maybe an extra option that forbids local A &amp; P settings would be in order,<br/>
 ?so that intermediate rounding does not 'poison' further math?<br/>
</dd>
</dl>
<dl>
<dt>
Overriding globals</dt>
<dd>
<br/>
  * you will be able to give A, P and R as an argument to all the calculation<br/>
    routines; the second parameter is A, the third one is P, and the fourth is<br/>
    R (shift right by one for binary operations like badd). P is used only if<br/>
    the first parameter (A) is undefined. These three parameters override the<br/>
    globals in the order detailed as follows, i.e. the first defined value<br/>
    wins:<br/>
    (local: per object, global: global default, parameter: argument to sub)<br/>
      + parameter A<br/>
      + parameter P<br/>
      + local A (if defined on both of the operands: smaller one is taken)<br/>
      + local P (if defined on both of the operands: bigger one is taken)<br/>
      + global A<br/>
      + global P<br/>
      + global F<br/>
  * fsqrt() will hand its arguments to fdiv(), as it used to, only now for two<br/>
    arguments (A and P) instead of one<br/>
</dd>
</dl>
<dl>
<dt>
Local settings</dt>
<dd>
<br/>
  * You can set A or P locally by using C&lt;&lt; $x-&gt;accuracy() &gt;&gt; or<br/>
    C&lt;&lt; $x-&gt;precision() &gt;&gt;<br/>
    and thus force different A and P for different objects/numbers.<br/>
  * Setting A or P this way immediately rounds $x to the new value.<br/>
  * C&lt;&lt; $x-&gt;accuracy() &gt;&gt; clears C&lt;&lt; $x-&gt;precision() &gt;&gt;, and vice versa.<br/>
</dd>
</dl>
<dl>
<dt>
Rounding</dt>
<dd>
<br/>
  * the rounding routines will use the respective global or local settings.<br/>
    fround()/bround() is for accuracy rounding, while ffround()/bfround()<br/>
    is for precision<br/>
  * the two rounding functions take as the second parameter one of the<br/>
    following rounding modes (R):<br/>
    'even', 'odd', '+inf', '-inf', 'zero', 'trunc', 'common'<br/>
  * you can set/get the global R by using C&lt;&lt; Math::SomeClass-&gt;round_mode() &gt;&gt;<br/>
    or by setting C&lt;&lt; $Math::SomeClass::round_mode &gt;&gt;<br/>
  * after each operation, C&lt;&lt; $result-&gt;round() &gt;&gt; is called, and the result may<br/>
    eventually be rounded (that is, if A or P were set either locally,<br/>
    globally or as parameter to the operation)<br/>
  * to manually round a number, call C&lt;&lt; $x-&gt;round($A,$P,$round_mode); &gt;&gt;<br/>
    this will round the number by using the appropriate rounding function<br/>
    and then normalize it.<br/>
  * rounding modifies the local settings of the number:<br/>
<br/>
        $x = Math::BigFloat-&gt;new(123.456);<br/>
        $x-&gt;accuracy(5);<br/>
        $x-&gt;bround(4);<br/>
<br/>
    Here 4 takes precedence over 5, so 123.5 is the result and $x-&gt;accuracy()<br/>
    will be 4 from now on.<br/>
</dd>
</dl>
<dl>
<dt>
Default values</dt>
<dd>
<br/>
  * R: 'even'<br/>
  * F: 40<br/>
  * A: undef<br/>
  * P: undef<br/>
</dd>
</dl>
<dl>
<dt>
Remarks</dt>
<dd>
<br/>
  * The defaults are set up so that the new code gives the same results as<br/>
    the old code (except in a few cases on fdiv):<br/>
    + Both A and P are undefined and thus will not be used for rounding<br/>
      after each operation.<br/>
    + round() is thus a no-op, unless given extra parameters A and P<br/>
</dd>
</dl>
</div>
</div>
<div class="section">
<h1>Infinity and Not a Number</h1> While BigInt has extensive handling of inf and NaN, certain quirks remain.<dl>
<dt>
<i>oct()</i>/<i>hex()</i></dt>
<dd>
These perl routines currently (as of Perl v.5.8.6) cannot handle passed inf.<div style="height: 1.00em;">
&#160;</div>
<br/>
        te@linux:~&gt; perl -wle 'print 2 ** 3333'<br/>
        inf<br/>
        te@linux:~&gt; perl -wle 'print 2 ** 3333 == 2 ** 3333'<br/>
        1<br/>
        te@linux:~&gt; perl -wle 'print oct(2 ** 3333)'<br/>
        0<br/>
        te@linux:~&gt; perl -wle 'print hex(2 ** 3333)'<br/>
        Illegal hexadecimal digit 'i' ignored at -e line 1.<br/>
        0<br/>
<div style="height: 1.00em;">
&#160;</div>
The same problems occur if you pass them Math::BigInt-&gt;<i>binf()</i> objects. Since overloading these routines is not possible, this cannot be fixed from BigInt.</dd>
</dl>
<dl>
<dt>
==, !=, &lt;, &gt;, &lt;=, &gt;= with NaNs</dt>
<dd>
BigInt's <i>bcmp()</i> routine currently returns undef to signal that a NaN was involved in a comparison. However, the overload code turns that into either 1 or '' and thus operations like &quot;NaN != NaN&quot; might return wrong values.</dd>
</dl>
<dl>
<dt>
log(-inf)</dt>
<dd>
&quot;log(-inf)&quot; is highly weird. Since log(-x)=pi*i+log(x), then log(-inf)=pi*i+inf. However, since the imaginary part is finite, the real infinity &quot;overshadows&quot; it, so the number might as well just be infinity. However, the result is a complex number, and since BigInt/BigFloat can only have real numbers as results, the result is NaN.</dd>
</dl>
<dl>
<dt>
<i>exp()</i>, <i>cos()</i>, <i>sin()</i>, <i>atan2()</i></dt>
<dd>
These all might have problems handling infinity right.</dd>
</dl>
</div>
<div class="section">
<h1>INTERNALS</h1> The actual numbers are stored as unsigned big integers (with separate sign).<div class="spacer">
</div>
You should neither care about nor depend on the internal representation; it might change without notice. Use  <b>ONLY</b> method calls like &quot;$x-&gt;sign();&quot; instead relying on the internal representation.<div class="subsection">
<h2>MATH LIBRARY</h2> Math with the numbers is done (by default) by a module called &quot;Math::BigInt::Calc&quot;. This is equivalent to saying:<div class="spacer">
</div>
<br/>
        use Math::BigInt try =&gt; 'Calc';<br/>
<div class="spacer">
</div>
You can change this backend library by using:<div class="spacer">
</div>
<br/>
        use Math::BigInt try =&gt; 'GMP';<br/>
<div class="spacer">
</div>
<b>Note</b>: General purpose packages should not be explicit about the library to use; let the script author decide which is best.<div class="spacer">
</div>
If your script works with huge numbers and Calc is too slow for them, you can also for the loading of one of these libraries and if none of them can be used, the code will die:<div class="spacer">
</div>
<br/>
        use Math::BigInt only =&gt; 'GMP,Pari';<br/>
<div class="spacer">
</div>
The following would first try to find Math::BigInt::Foo, then Math::BigInt::Bar, and when this also fails, revert to Math::BigInt::Calc:<div class="spacer">
</div>
<br/>
        use Math::BigInt try =&gt; 'Foo,Math::BigInt::Bar';<br/>
<div class="spacer">
</div>
The library that is loaded last will be used. Note that this can be overwritten at any time by loading a different library, and numbers constructed with different libraries cannot be used in math operations together.<div class="spacer">
</div>
<i>What library to use?</i><div class="spacer">
</div>
<b>Note</b>: General purpose packages should not be explicit about the library to use; let the script author decide which is best.<div class="spacer">
</div>
Math::BigInt::GMP and Math::BigInt::Pari are in cases involving big numbers much faster than Calc, however it is slower when dealing with very small numbers (less than about 20 digits) and when converting very large numbers to decimal (for instance for printing, rounding, calculating their length in decimal etc).<div class="spacer">
</div>
So please select carefully what library you want to use.<div class="spacer">
</div>
Different low-level libraries use different formats to store the numbers. However, you should  <b>NOT</b> depend on the number having a specific format internally.<div class="spacer">
</div>
See the respective math library module documentation for further details.</div>
<div class="subsection">
<h2>SIGN</h2> The sign is either '+', '-', 'NaN', '+inf' or '-inf'.<div class="spacer">
</div>
A sign of 'NaN' is used to represent the result when input arguments are not numbers or as a result of 0/0. '+inf' and '-inf' represent plus respectively minus infinity. You will get '+inf' when dividing a positive number by 0, and '-inf' when dividing any negative number by 0.</div>
<div class="subsection">
<h2><i>mantissa()</i>, <i>exponent()</i> and <i>parts()</i></h2> &quot;mantissa()&quot; and &quot;exponent()&quot; return the said parts of the BigInt such that:<div class="spacer">
</div>
<br/>
        $m = $x-&gt;mantissa();<br/>
        $e = $x-&gt;exponent();<br/>
        $y = $m * ( 10 ** $e );<br/>
        print &quot;ok\n&quot; if $x == $y;<br/>
<div class="spacer">
</div>
&quot;($m,$e) = $x-&gt;parts()&quot; is just a shortcut that gives you both of them in one go. Both the returned mantissa and exponent have a sign.<div class="spacer">
</div>
Currently, for BigInts $e is always 0, except +inf and -inf, where it is &quot;+inf&quot;; and for NaN, where it is &quot;NaN&quot;; and for &quot;$x == 0&quot;, where it is 1 (to be compatible with Math::BigFloat's internal representation of a zero as 0E1).<div class="spacer">
</div>
$m is currently just a copy of the original number. The relation between $e and $m will stay always the same, though their real values might change.</div>
</div>
<div class="section">
<h1>EXAMPLES</h1><br/>
  use Math::BigInt;<br/>
<br/>
  sub bint { Math::BigInt-&gt;new(shift); }<br/>
<br/>
  $x = Math::BigInt-&gt;bstr(&quot;1234&quot;)       # string &quot;1234&quot;<br/>
  $x = &quot;$x&quot;;                            # same as bstr()<br/>
  $x = Math::BigInt-&gt;bneg(&quot;1234&quot;);      # BigInt &quot;-1234&quot;<br/>
  $x = Math::BigInt-&gt;babs(&quot;-12345&quot;);    # BigInt &quot;12345&quot;<br/>
  $x = Math::BigInt-&gt;bnorm(&quot;-0.00&quot;);    # BigInt &quot;0&quot;<br/>
  $x = bint(1) + bint(2);               # BigInt &quot;3&quot;<br/>
  $x = bint(1) + &quot;2&quot;;                   # ditto (auto-BigIntify of &quot;2&quot;)<br/>
  $x = bint(1);                         # BigInt &quot;1&quot;<br/>
  $x = $x + 5 / 2;                      # BigInt &quot;3&quot;<br/>
  $x = $x ** 3;                         # BigInt &quot;27&quot;<br/>
  $x *= 2;                              # BigInt &quot;54&quot;<br/>
  $x = Math::BigInt-&gt;new(0);            # BigInt &quot;0&quot;<br/>
  $x--;                                 # BigInt &quot;-1&quot;<br/>
  $x = Math::BigInt-&gt;badd(4,5)          # BigInt &quot;9&quot;<br/>
  print $x-&gt;bsstr();                    # 9e+0<br/>
<div class="spacer">
</div>
Examples for rounding:<div class="spacer">
</div>
<br/>
  use Math::BigFloat;<br/>
  use Test;<br/>
<br/>
  $x = Math::BigFloat-&gt;new(123.4567);<br/>
  $y = Math::BigFloat-&gt;new(123.456789);<br/>
  Math::BigFloat-&gt;accuracy(4);          # no more A than 4<br/>
<br/>
  ok ($x-&gt;copy()-&gt;fround(),123.4);      # even rounding<br/>
  print $x-&gt;copy()-&gt;fround(),&quot;\n&quot;;      # 123.4<br/>
  Math::BigFloat-&gt;round_mode('odd');    # round to odd<br/>
  print $x-&gt;copy()-&gt;fround(),&quot;\n&quot;;      # 123.5<br/>
  Math::BigFloat-&gt;accuracy(5);          # no more A than 5<br/>
  Math::BigFloat-&gt;round_mode('odd');    # round to odd<br/>
  print $x-&gt;copy()-&gt;fround(),&quot;\n&quot;;      # 123.46<br/>
  $y = $x-&gt;copy()-&gt;fround(4),&quot;\n&quot;;      # A = 4: 123.4<br/>
  print &quot;$y, &quot;,$y-&gt;accuracy(),&quot;\n&quot;;     # 123.4, 4<br/>
<br/>
  Math::BigFloat-&gt;accuracy(undef);      # A not important now<br/>
  Math::BigFloat-&gt;precision(2);         # P important<br/>
  print $x-&gt;copy()-&gt;bnorm(),&quot;\n&quot;;       # 123.46<br/>
  print $x-&gt;copy()-&gt;fround(),&quot;\n&quot;;      # 123.46<br/>
<div class="spacer">
</div>
Examples for converting:<div class="spacer">
</div>
<br/>
  my $x = Math::BigInt-&gt;new('0b1'.'01' x 123);<br/>
  print &quot;bin: &quot;,$x-&gt;as_bin(),&quot; hex:&quot;,$x-&gt;as_hex(),&quot; dec: &quot;,$x,&quot;\n&quot;;<br/>
</div>
<div class="section">
<h1>Autocreating constants</h1> After &quot;use Math::BigInt ':constant'&quot; all the  <b>integer</b> decimal, hexadecimal and binary constants in the given scope are converted to &quot;Math::BigInt&quot;. This conversion happens at compile time.<div class="spacer">
</div>
In particular,<div class="spacer">
</div>
<br/>
  perl -MMath::BigInt=:constant -e 'print 2**100,&quot;\n&quot;'<br/>
<div class="spacer">
</div>
prints the integer value of &quot;2**100&quot;. Note that without conversion of constants the expression 2**100 will be calculated as perl scalar.<div class="spacer">
</div>
Please note that strings and floating point constants are not affected, so that<div class="spacer">
</div>
<br/>
        use Math::BigInt qw/:constant/;<br/>
<br/>
        $x = 1234567890123456789012345678901234567890<br/>
                + 123456789123456789;<br/>
        $y = '1234567890123456789012345678901234567890'<br/>
                + '123456789123456789';<br/>
<div class="spacer">
</div>
do not work. You need an explicit Math::BigInt-&gt;<i>new()</i> around one of the operands. You should also quote large constants to protect loss of precision:<div class="spacer">
</div>
<br/>
        use Math::BigInt;<br/>
<br/>
        $x = Math::BigInt-&gt;new('1234567889123456789123456789123456789');<br/>
<div class="spacer">
</div>
Without the quotes Perl would convert the large number to a floating point constant at compile time and then hand the result to BigInt, which results in an truncated result or a NaN.<div class="spacer">
</div>
This also applies to integers that look like floating point constants:<div class="spacer">
</div>
<br/>
        use Math::BigInt ':constant';<br/>
<br/>
        print ref(123e2),&quot;\n&quot;;<br/>
        print ref(123.2e2),&quot;\n&quot;;<br/>
<div class="spacer">
</div>
will print nothing but newlines. Use either bignum or Math::BigFloat to get this to work.</div>
<div class="section">
<h1>PERFORMANCE</h1> Using the form $x += $y; etc over $x = $x + $y is faster, since a copy of $x must be made in the second case. For long numbers, the copy can eat up to 20% of the work (in the case of addition/subtraction, less for multiplication/division). If $y is very small compared to $x, the form $x += $y is MUCH faster than $x = $x + $y since making the copy of $x takes more time then the actual addition.<div class="spacer">
</div>
With a technique called copy-on-write, the cost of copying with overload could be minimized or even completely avoided. A test implementation of COW did show performance gains for overloaded math, but introduced a performance loss due to a constant overhead for all other operations. So Math::BigInt does currently not COW.<div class="spacer">
</div>
The rewritten version of this module (vs. v0.01) is slower on certain operations, like &quot;new()&quot;, &quot;bstr()&quot; and &quot;numify()&quot;. The reason are that it does now more work and handles much more cases. The time spent in these operations is usually gained in the other math operations so that code on the average should get (much) faster. If they don't, please contact the author.<div class="spacer">
</div>
Some operations may be slower for small numbers, but are significantly faster for big numbers. Other operations are now constant (O(1), like &quot;bneg()&quot;, &quot;babs()&quot; etc), instead of O(N) and thus nearly always take much less time. These optimizations were done on purpose.<div class="spacer">
</div>
If you find the Calc module to slow, try to install any of the replacement modules and see if they help you.<div class="subsection">
<h2>Alternative math libraries</h2> You can use an alternative library to drive Math::BigInt. See the section &quot;MATH LIBRARY&quot; for more information.<div class="spacer">
</div>
For more benchmark results see &lt;http://bloodgate.com/perl/benchmarks.html&gt;.</div>
<div class="subsection">
<h2>SUBCLASSING</h2></div>
</div>
<div class="section">
<h1>Subclassing Math::BigInt</h1> The basic design of Math::BigInt allows simple subclasses with very little work, as long as a few simple rules are followed:<dl>
<dt>
&#8226;</dt>
<dd>
The public API must remain consistent, i.e. if a sub-class is overloading addition, the sub-class must use the same name, in this case  <i>badd()</i>. The reason for this is that Math::BigInt is optimized to call the object methods directly.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
The private object hash keys like &quot;$x-&gt;{sign}&quot; may not be changed, but additional keys can be added, like &quot;$x-&gt;{_custom}&quot;.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Accessor functions are available for all existing object hash keys and should be used instead of directly accessing the internal hash keys. The reason for this is that Math::BigInt itself has a pluggable interface which permits it to support different storage methods.</dd>
</dl>
<div class="spacer">
</div>
More complex sub-classes may have to replicate more of the logic internal of Math::BigInt if they need to change more basic behaviors. A subclass that needs to merely change the output only needs to overload &quot;bstr()&quot;.<div class="spacer">
</div>
All other object methods and overloaded functions can be directly inherited from the parent class.<div class="spacer">
</div>
At the very minimum, any subclass will need to provide its own &quot;new()&quot; and can store additional hash keys in the object. There are also some package globals that must be defined, e.g.:<div class="spacer">
</div>
<br/>
  # Globals<br/>
  $accuracy = undef;<br/>
  $precision = -2;       # round to 2 decimal places<br/>
  $round_mode = 'even';<br/>
  $div_scale = 40;<br/>
<div class="spacer">
</div>
Additionally, you might want to provide the following two globals to allow auto-upgrading and auto-downgrading to work correctly:<div class="spacer">
</div>
<br/>
  $upgrade = undef;<br/>
  $downgrade = undef;<br/>
<div class="spacer">
</div>
This allows Math::BigInt to correctly retrieve package globals from the subclass, like $SubClass::precision.  See t/Math/BigInt/Subclass.pm or t/Math/BigFloat/SubClass.pm completely functional subclass examples.<div class="spacer">
</div>
Don't forget to<div class="spacer">
</div>
<br/>
        use overload;<br/>
<div class="spacer">
</div>
in your subclass to automatically inherit the overloading from the parent. If you like, you can change part of the overloading, look at Math::String for an example.</div>
<div class="section">
<h1>UPGRADING</h1> When used like this:<div class="spacer">
</div>
<br/>
        use Math::BigInt upgrade =&gt; 'Foo::Bar';<br/>
<div class="spacer">
</div>
certain operations will 'upgrade' their calculation and thus the result to the class Foo::Bar. Usually this is used in conjunction with Math::BigFloat:<div class="spacer">
</div>
<br/>
        use Math::BigInt upgrade =&gt; 'Math::BigFloat';<br/>
<div class="spacer">
</div>
As a shortcut, you can use the module &quot;bignum&quot;:<div class="spacer">
</div>
<br/>
        use bignum;<br/>
<div class="spacer">
</div>
Also good for one-liners:<div class="spacer">
</div>
<br/>
        perl -Mbignum -le 'print 2 ** 255'<br/>
<div class="spacer">
</div>
This makes it possible to mix arguments of different classes (as in 2.5 + 2) as well es preserve accuracy (as in  <i>sqrt</i>(3)).<div class="spacer">
</div>
Beware: This feature is not fully implemented yet.<div class="subsection">
<h2>Auto-upgrade</h2> The following methods upgrade themselves unconditionally; that is if upgrade is in effect, they will always hand up their work:<dl>
<dt>
<i>bsqrt()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>div()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>blog()</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>bexp()</i></dt>
<dd>
</dd>
</dl>
<div class="spacer">
</div>
Beware: This list is not complete.<div class="spacer">
</div>
All other methods upgrade themselves only when one (or all) of their arguments are of the class mentioned in $upgrade (This might change in later versions to a more sophisticated scheme):</div>
</div>
<div class="section">
<h1>EXPORTS</h1> &quot;Math::BigInt&quot; exports nothing by default, but can export the following methods:<div class="spacer">
</div>
<br/>
        bgcd<br/>
        blcm<br/>
</div>
<div class="section">
<h1>CAVEATS</h1> Some things might not work as you expect them. Below is documented what is known to be troublesome:<dl>
<dt>
<i>bstr()</i>, <i>bsstr()</i> and 'cmp'</dt>
<dd>
Both &quot;bstr()&quot; and &quot;bsstr()&quot; as well as automated stringify via overload now drop the leading '+'. The old code would return '+3', the new returns '3'. This is to be consistent with Perl and to make &quot;cmp&quot; (especially with overloading) to work as you expect. It also solves problems with &quot;Test.pm&quot;, because its &quot;ok()&quot; uses 'eq' internally.<div style="height: 1.00em;">
&#160;</div>
Mark Biggar said, when asked about to drop the '+' altogether, or make only &quot;cmp&quot; work:<div style="height: 1.00em;">
&#160;</div>
<br/>
        I agree (with the first alternative), don't add the '+' on positive<br/>
        numbers.  It's not as important anymore with the new internal <br/>
        form for numbers.  It made doing things like abs and neg easier,<br/>
        but those have to be done differently now anyway.<br/>
<div style="height: 1.00em;">
&#160;</div>
So, the following examples will now work all as expected:<div style="height: 1.00em;">
&#160;</div>
<br/>
        use Test;<br/>
        BEGIN { plan tests =&gt; 1 }<br/>
        use Math::BigInt;<br/>
<br/>
        my $x = new Math::BigInt 3*3;<br/>
        my $y = new Math::BigInt 3*3;<br/>
<br/>
        ok ($x,3*3);<br/>
        print &quot;$x eq 9&quot; if $x eq $y;<br/>
        print &quot;$x eq 9&quot; if $x eq '9';<br/>
        print &quot;$x eq 9&quot; if $x eq 3*3;<br/>
<div style="height: 1.00em;">
&#160;</div>
Additionally, the following still works:<div style="height: 1.00em;">
&#160;</div>
<br/>
        print &quot;$x == 9&quot; if $x == $y;<br/>
        print &quot;$x == 9&quot; if $x == 9;<br/>
        print &quot;$x == 9&quot; if $x == 3*3;<br/>
<div style="height: 1.00em;">
&#160;</div>
There is now a &quot;bsstr()&quot; method to get the string in scientific notation aka 1e+2 instead of 100. Be advised that overloaded 'eq' always uses  <i>bstr()</i> for comparison, but Perl will represent some numbers as 100 and others as 1e+308. If in doubt, convert both arguments to Math::BigInt before comparing them as strings:<div style="height: 1.00em;">
&#160;</div>
<br/>
        use Test;<br/>
        BEGIN { plan tests =&gt; 3 }<br/>
        use Math::BigInt;<br/>
<br/>
        $x = Math::BigInt-&gt;new('1e56'); $y = 1e56;<br/>
        ok ($x,$y);                     # will fail<br/>
        ok ($x-&gt;bsstr(),$y);            # okay<br/>
        $y = Math::BigInt-&gt;new($y);<br/>
        ok ($x,$y);                     # okay<br/>
<div style="height: 1.00em;">
&#160;</div>
Alternatively, simple use &quot;&lt;=&gt;&quot; for comparisons, this will get it always right. There is not yet a way to get a number automatically represented as a string that matches exactly the way Perl represents it.<div style="height: 1.00em;">
&#160;</div>
See also the section about &quot;Infinity and Not a Number&quot; for problems in comparing NaNs.</dd>
</dl>
<dl>
<dt>
<i>int()</i></dt>
<dd>
&quot;int()&quot; will return (at least for Perl v5.7.1 and up) another BigInt, not a Perl scalar:<div style="height: 1.00em;">
&#160;</div>
<br/>
        $x = Math::BigInt-&gt;new(123);<br/>
        $y = int($x);                           # BigInt 123<br/>
        $x = Math::BigFloat-&gt;new(123.45);<br/>
        $y = int($x);                           # BigInt 123<br/>
<div style="height: 1.00em;">
&#160;</div>
In all Perl versions you can use &quot;as_number()&quot; or &quot;as_int&quot; for the same effect:<div style="height: 1.00em;">
&#160;</div>
<br/>
        $x = Math::BigFloat-&gt;new(123.45);<br/>
        $y = $x-&gt;as_number();                   # BigInt 123<br/>
        $y = $x-&gt;as_int();                      # ditto<br/>
<div style="height: 1.00em;">
&#160;</div>
This also works for other subclasses, like Math::String.<div style="height: 1.00em;">
&#160;</div>
If you want a real Perl scalar, use &quot;numify()&quot;:<div style="height: 1.00em;">
&#160;</div>
<br/>
        $y = $x-&gt;numify();                      # 123 as scalar<br/>
<div style="height: 1.00em;">
&#160;</div>
This is seldom necessary, though, because this is done automatically, like when you access an array:<div style="height: 1.00em;">
&#160;</div>
<br/>
        $z = $array[$x];                        # does work automatically<br/>
</dd>
</dl>
<dl>
<dt>
length</dt>
<dd>
The following will probably not do what you expect:<div style="height: 1.00em;">
&#160;</div>
<br/>
        $c = Math::BigInt-&gt;new(123);<br/>
        print $c-&gt;length(),&quot;\n&quot;;                # prints 30<br/>
<div style="height: 1.00em;">
&#160;</div>
It prints both the number of digits in the number and in the fraction part since print calls &quot;length()&quot; in list context. Use something like:<div style="height: 1.00em;">
&#160;</div>
<br/>
        print scalar $c-&gt;length(),&quot;\n&quot;;         # prints 3<br/>
</dd>
</dl>
<dl>
<dt>
bdiv</dt>
<dd>
The following will probably not do what you expect:<div style="height: 1.00em;">
&#160;</div>
<br/>
        print $c-&gt;bdiv(10000),&quot;\n&quot;;<br/>
<div style="height: 1.00em;">
&#160;</div>
It prints both quotient and remainder since print calls &quot;bdiv()&quot; in list context. Also, &quot;bdiv()&quot; will modify $c, so be careful. You probably want to use<div style="height: 1.00em;">
&#160;</div>
<br/>
        print $c / 10000,&quot;\n&quot;;<br/>
        print scalar $c-&gt;bdiv(10000),&quot;\n&quot;;  # or if you want to modify $c<br/>
<div style="height: 1.00em;">
&#160;</div>
instead.<div style="height: 1.00em;">
&#160;</div>
The quotient is always the greatest integer less than or equal to the real-valued quotient of the two operands, and the remainder (when it is non-zero) always has the same sign as the second operand; so, for example,<div style="height: 1.00em;">
&#160;</div>
<br/>
          1 / 4  =&gt; ( 0, 1)<br/>
          1 / -4 =&gt; (-1,-3)<br/>
         -3 / 4  =&gt; (-1, 1)<br/>
         -3 / -4 =&gt; ( 0,-3)<br/>
        -11 / 2  =&gt; (-5,1)<br/>
         11 /-2  =&gt; (-5,-1)<br/>
<div style="height: 1.00em;">
&#160;</div>
As a consequence, the behavior of the operator % agrees with the behavior of Perl's built-in % operator (as documented in the perlop manpage), and the equation<div style="height: 1.00em;">
&#160;</div>
<br/>
        $x == ($x / $y) * $y + ($x % $y)<br/>
<div style="height: 1.00em;">
&#160;</div>
holds true for any $x and $y, which justifies calling the two return values of  <i>bdiv()</i> the quotient and remainder. The only exception to this rule are when $y == 0 and $x is negative, then the remainder will also be negative. See below under &quot;infinity handling&quot; for the reasoning behind this.<div style="height: 1.00em;">
&#160;</div>
Perl's 'use integer;' changes the behaviour of % and / for scalars, but will not change BigInt's way to do things. This is because under 'use integer' Perl will do what the underlying C thinks is right and this is different for each system. If you need BigInt's behaving exactly like Perl's 'use integer', bug the author to implement it ;)</dd>
</dl>
<dl>
<dt>
infinity handling</dt>
<dd>
Here are some examples that explain the reasons why certain results occur while handling infinity:<div style="height: 1.00em;">
&#160;</div>
The following table shows the result of the division and the remainder, so that the equation above holds true. Some &quot;ordinary&quot; cases are strewn in to show more clearly the reasoning:<div style="height: 1.00em;">
&#160;</div>
<br/>
        A /  B  =   C,     R so that C *    B +    R =    A<br/>
     =========================================================<br/>
        5 /   8 =   0,     5         0 *    8 +    5 =    5<br/>
        0 /   8 =   0,     0         0 *    8 +    0 =    0<br/>
        0 / inf =   0,     0         0 *  inf +    0 =    0<br/>
        0 /-inf =   0,     0         0 * -inf +    0 =    0<br/>
        5 / inf =   0,     5         0 *  inf +    5 =    5<br/>
        5 /-inf =   0,     5         0 * -inf +    5 =    5<br/>
        -5/ inf =   0,    -5         0 *  inf +   -5 =   -5<br/>
        -5/-inf =   0,    -5         0 * -inf +   -5 =   -5<br/>
       inf/   5 =  inf,    0       inf *    5 +    0 =  inf<br/>
      -inf/   5 = -inf,    0      -inf *    5 +    0 = -inf<br/>
       inf/  -5 = -inf,    0      -inf *   -5 +    0 =  inf<br/>
      -inf/  -5 =  inf,    0       inf *   -5 +    0 = -inf<br/>
         5/   5 =    1,    0         1 *    5 +    0 =    5<br/>
        -5/  -5 =    1,    0         1 *   -5 +    0 =   -5<br/>
       inf/ inf =    1,    0         1 *  inf +    0 =  inf<br/>
      -inf/-inf =    1,    0         1 * -inf +    0 = -inf<br/>
       inf/-inf =   -1,    0        -1 * -inf +    0 =  inf<br/>
      -inf/ inf =   -1,    0         1 * -inf +    0 = -inf<br/>
         8/   0 =  inf,    8       inf *    0 +    8 =    8<br/>
       inf/   0 =  inf,  inf       inf *    0 +  inf =  inf<br/>
         0/   0 =  NaN<br/>
<div style="height: 1.00em;">
&#160;</div>
These cases below violate the &quot;remainder has the sign of the second of the two arguments&quot;, since they wouldn't match up otherwise.<div style="height: 1.00em;">
&#160;</div>
<br/>
        A /  B  =   C,     R so that C *    B +    R =    A<br/>
     ========================================================<br/>
      -inf/   0 = -inf, -inf      -inf *    0 +  inf = -inf<br/>
        -8/   0 = -inf,   -8      -inf *    0 +    8 = -8<br/>
</dd>
</dl>
<dl>
<dt>
Modifying and =</dt>
<dd>
Beware of:<div style="height: 1.00em;">
&#160;</div>
<br/>
        $x = Math::BigFloat-&gt;new(5);<br/>
        $y = $x;<br/>
<div style="height: 1.00em;">
&#160;</div>
It will not do what you think, e.g. making a copy of $x. Instead it just makes a second reference to the  <b>same</b> object and stores it in $y. Thus anything that modifies $x (except overloaded operators) will modify $y, and vice versa. Or in other words, &quot;=&quot; is only safe if you modify your BigInts only via overloaded math. As soon as you use a method call it breaks:<div style="height: 1.00em;">
&#160;</div>
<br/>
        $x-&gt;bmul(2);<br/>
        print &quot;$x, $y\n&quot;;       # prints '10, 10'<br/>
<div style="height: 1.00em;">
&#160;</div>
If you want a true copy of $x, use:<div style="height: 1.00em;">
&#160;</div>
<br/>
        $y = $x-&gt;copy();<br/>
<div style="height: 1.00em;">
&#160;</div>
You can also chain the calls like this, this will make first a copy and then multiply it by 2:<div style="height: 1.00em;">
&#160;</div>
<br/>
        $y = $x-&gt;copy()-&gt;bmul(2);<br/>
<div style="height: 1.00em;">
&#160;</div>
See also the documentation for overload.pm regarding &quot;=&quot;.</dd>
</dl>
<dl>
<dt>
bpow</dt>
<dd>
&quot;bpow()&quot; (and the rounding functions) now modifies the first argument and returns it, unlike the old code which left it alone and only returned the result. This is to be consistent with &quot;badd()&quot; etc. The first three will modify $x, the last one won't:<div style="height: 1.00em;">
&#160;</div>
<br/>
        print bpow($x,$i),&quot;\n&quot;;         # modify $x<br/>
        print $x-&gt;bpow($i),&quot;\n&quot;;        # ditto<br/>
        print $x **= $i,&quot;\n&quot;;           # the same<br/>
        print $x ** $i,&quot;\n&quot;;            # leave $x alone<br/>
<div style="height: 1.00em;">
&#160;</div>
The form &quot;$x **= $y&quot; is faster than &quot;$x = $x ** $y;&quot;, though.</dd>
</dl>
<dl>
<dt>
Overloading -$x</dt>
<dd>
The following:<div style="height: 1.00em;">
&#160;</div>
<br/>
        $x = -$x;<br/>
<div style="height: 1.00em;">
&#160;</div>
is slower than<div style="height: 1.00em;">
&#160;</div>
<br/>
        $x-&gt;bneg();<br/>
<div style="height: 1.00em;">
&#160;</div>
since overload calls &quot;sub($x,0,1);&quot; instead of &quot;neg($x)&quot;. The first variant needs to preserve $x since it does not know that it later will get overwritten. This makes a copy of $x and takes O(N), but $x-&gt; <i>bneg()</i> is O(1).</dd>
</dl>
<dl>
<dt>
Mixing different object types</dt>
<dd>
In Perl you will get a floating point value if you do one of the following:<div style="height: 1.00em;">
&#160;</div>
<br/>
        $float = 5.0 + 2;<br/>
        $float = 2 + 5.0;<br/>
        $float = 5 / 2;<br/>
<div style="height: 1.00em;">
&#160;</div>
With overloaded math, only the first two variants will result in a BigFloat:<div style="height: 1.00em;">
&#160;</div>
<br/>
        use Math::BigInt;<br/>
        use Math::BigFloat;<br/>
        <br/>
        $mbf = Math::BigFloat-&gt;new(5);<br/>
        $mbi2 = Math::BigInteger-&gt;new(5);<br/>
        $mbi = Math::BigInteger-&gt;new(2);<br/>
<br/>
                                        # what actually gets called:<br/>
        $float = $mbf + $mbi;           # $mbf-&gt;badd()<br/>
        $float = $mbf / $mbi;           # $mbf-&gt;bdiv()<br/>
        $integer = $mbi + $mbf;         # $mbi-&gt;badd()<br/>
        $integer = $mbi2 / $mbi;        # $mbi2-&gt;bdiv()<br/>
        $integer = $mbi2 / $mbf;        # $mbi2-&gt;bdiv()<br/>
<div style="height: 1.00em;">
&#160;</div>
This is because math with overloaded operators follows the first (dominating) operand, and the operation of that is called and returns thus the result. So,  <i>Math::BigInt::bdiv()</i> will always return a Math::BigInt, regardless whether the result should be a Math::BigFloat or the second operant is one.<div style="height: 1.00em;">
&#160;</div>
To get a Math::BigFloat you either need to call the operation manually, make sure the operands are already of the proper type or casted to that type via Math::BigFloat-&gt; <i>new()</i>:<div style="height: 1.00em;">
&#160;</div>
<br/>
        $float = Math::BigFloat-&gt;new($mbi2) / $mbi;     # = 2.5<br/>
<div style="height: 1.00em;">
&#160;</div>
Beware of simple &quot;casting&quot; the entire expression, this would only convert the already computed result:<div style="height: 1.00em;">
&#160;</div>
<br/>
        $float = Math::BigFloat-&gt;new($mbi2 / $mbi);     # = 2.0 thus wrong!<br/>
<div style="height: 1.00em;">
&#160;</div>
Beware also of the order of more complicated expressions like:<div style="height: 1.00em;">
&#160;</div>
<br/>
        $integer = ($mbi2 + $mbi) / $mbf;               # int / float =&gt; int<br/>
        $integer = $mbi2 / Math::BigFloat-&gt;new($mbi);   # ditto<br/>
<div style="height: 1.00em;">
&#160;</div>
If in doubt, break the expression into simpler terms, or cast all operands to the desired resulting type.<div style="height: 1.00em;">
&#160;</div>
Scalar values are a bit different, since:<div style="height: 1.00em;">
&#160;</div>
<br/>
        $float = 2 + $mbf;<br/>
        $float = $mbf + 2;<br/>
<div style="height: 1.00em;">
&#160;</div>
will both result in the proper type due to the way the overloaded math works.<div style="height: 1.00em;">
&#160;</div>
This section also applies to other overloaded math packages, like Math::String.<div style="height: 1.00em;">
&#160;</div>
One solution to you problem might be autoupgrading|upgrading. See the pragmas bignum, bigint and bigrat for an easy way to do this.</dd>
</dl>
<dl>
<dt>
<i>bsqrt()</i></dt>
<dd>
&quot;bsqrt()&quot; works only good if the result is a big integer, e.g. the square root of 144 is 12, but from 12 the square root is 3, regardless of rounding mode. The reason is that the result is always truncated to an integer.<div style="height: 1.00em;">
&#160;</div>
If you want a better approximation of the square root, then use:<div style="height: 1.00em;">
&#160;</div>
<br/>
        $x = Math::BigFloat-&gt;new(12);<br/>
        Math::BigFloat-&gt;precision(0);<br/>
        Math::BigFloat-&gt;round_mode('even');<br/>
        print $x-&gt;copy-&gt;bsqrt(),&quot;\n&quot;;           # 4<br/>
<br/>
        Math::BigFloat-&gt;precision(2);<br/>
        print $x-&gt;bsqrt(),&quot;\n&quot;;                 # 3.46<br/>
        print $x-&gt;bsqrt(3),&quot;\n&quot;;                # 3.464<br/>
</dd>
</dl>
<dl>
<dt>
<i>brsft()</i></dt>
<dd>
For negative numbers in base see also brsft.</dd>
</dl>
</div>
<div class="section">
<h1>LICENSE</h1> This program is free software; you may redistribute it and/or modify it under the same terms as Perl itself.</div>
<div class="section">
<h1>SEE ALSO</h1> Math::BigFloat, Math::BigRat and Math::Big as well as Math::BigInt::BitVect, Math::BigInt::Pari and  Math::BigInt::GMP.<div class="spacer">
</div>
The pragmas bignum, bigint and bigrat also might be of interest because they solve the autoupgrading/downgrading issue, at least partly.<div class="spacer">
</div>
The package at &lt;http://search.cpan.org/search?mode=module&amp;query=Math%3A%3ABigInt&gt; contains more documentation including a full version history, testcases, empty subclass files and benchmarks.</div>
<div class="section">
<h1>AUTHORS</h1> Original code by Mark Biggar, overloaded interface by Ilya Zakharevich. Completely rewritten by Tels http://bloodgate.com in late 2000, 2001 - 2006 and still at it in 2007.<div class="spacer">
</div>
Many people contributed in one or more ways to the final beast, see the file CREDITS for an (incomplete) list. If you miss your name, please drop me a mail. Thank you!</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-09-26</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

