<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
d2i_X509(3SSL)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
d2i_X509(3SSL)</td>
<td class="head-vol">
OpenSSL</td>
<td class="head-rtitle">
d2i_X509(3SSL)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> d2i_X509, i2d_X509, d2i_X509_bio, d2i_X509_fp, i2d_X509_bio, i2d_X509_fp - X509 encode and decode functions</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
 #include &lt;openssl/x509.h&gt;<br/>
<br/>
 X509 *d2i_X509(X509 **px, const unsigned char **in, int len);<br/>
 int i2d_X509(X509 *x, unsigned char **out);<br/>
<br/>
 X509 *d2i_X509_bio(BIO *bp, X509 **x);<br/>
 X509 *d2i_X509_fp(FILE *fp, X509 **x);<br/>
<br/>
 int i2d_X509_bio(BIO *bp, X509 *x);<br/>
 int i2d_X509_fp(FILE *fp, X509 *x);<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> The X509 encode and decode routines encode and parse an  <b>X509</b> structure, which represents an X509 certificate.<div class="spacer">
</div>
<i>d2i_X509()</i> attempts to decode <b>len</b> bytes at <b>*in</b>. If successful a pointer to the  <b>X509</b> structure is returned. If an error occurred then  <b>NULL</b> is returned. If <b>px</b> is not <b>NULL</b> then the returned structure is written to  <b>*px</b>. If <b>*px</b> is not <b>NULL</b> then it is assumed that  <b>*px</b> contains a valid <b>X509</b> structure and an attempt is made to reuse it. If the call is successful  <b>*in</b> is incremented to the byte following the parsed data.<div class="spacer">
</div>
<i>i2d_X509()</i> encodes the structure pointed to by <b>x</b> into DER format. If  <b>out</b> is not <b>NULL</b> is writes the DER encoded data to the buffer at  <b>*out</b>, and increments it to point after the data just written. If the return value is negative an error occurred, otherwise it returns the length of the encoded data.<div class="spacer">
</div>
For OpenSSL 0.9.7 and later if <b>*out</b> is <b>NULL</b> memory will be allocated for a buffer and the encoded data written to it. In this case  <b>*out</b> is not incremented and it points to the start of the data just written.<div class="spacer">
</div>
<i>d2i_X509_bio()</i> is similar to <i>d2i_X509()</i> except it attempts to parse data from BIO  <b>bp</b>.<div class="spacer">
</div>
<i>d2i_X509_fp()</i> is similar to <i>d2i_X509()</i> except it attempts to parse data from FILE pointer  <b>fp</b>.<div class="spacer">
</div>
<i>i2d_X509_bio()</i> is similar to <i>i2d_X509()</i> except it writes the encoding of the structure  <b>x</b> to BIO <b>bp</b> and it returns 1 for success and 0 for failure.<div class="spacer">
</div>
<i>i2d_X509_fp()</i> is similar to <i>i2d_X509()</i> except it writes the encoding of the structure  <b>x</b> to BIO <b>bp</b> and it returns 1 for success and 0 for failure.</div>
<div class="section">
<h1>NOTES</h1> The letters  <b>i</b> and <b>d</b> in for example <b>i2d_X509</b> stand for &quot;internal&quot; (that is an internal C structure) and &quot;DER&quot;. So that  <b>i2d_X509</b> converts from internal to DER.<div class="spacer">
</div>
The functions can also understand <b>BER</b> forms.<div class="spacer">
</div>
The actual X509 structure passed to <i>i2d_X509()</i> must be a valid populated  <b>X509</b> structure it can <b>not</b> simply be fed with an empty structure such as that returned by  <i>X509_new()</i>.<div class="spacer">
</div>
The encoded data is in binary form and may contain embedded zeroes. Therefore any FILE pointers or BIOs should be opened in binary mode. Functions such as  <b></b><b><i>strlen()</i></b><b></b> will <b>not</b> return the correct length of the encoded structure.<div class="spacer">
</div>
The ways that <b>*in</b> and <b>*out</b> are incremented after the operation can trap the unwary. See the  <b>WARNINGS</b> section for some common errors.<div class="spacer">
</div>
The reason for the auto increment behaviour is to reflect a typical usage of ASN1 functions: after one structure is encoded or decoded another will processed after it.</div>
<div class="section">
<h1>EXAMPLES</h1> Allocate and encode the DER encoding of an X509 structure:<div class="spacer">
</div>
<br/>
 int len;<br/>
 unsigned char *buf, *p;<br/>
<br/>
 len = i2d_X509(x, NULL);<br/>
<br/>
 buf = OPENSSL_malloc(len);<br/>
<br/>
 if (buf == NULL)<br/>
        /* error */<br/>
<br/>
 p = buf;<br/>
<br/>
 i2d_X509(x, &amp;p);<br/>
<div class="spacer">
</div>
If you are using OpenSSL 0.9.7 or later then this can be simplified to:<div class="spacer">
</div>
<br/>
 int len;<br/>
 unsigned char *buf;<br/>
<br/>
 buf = NULL;<br/>
<br/>
 len = i2d_X509(x, &amp;buf);<br/>
<br/>
 if (len &lt; 0)<br/>
        /* error */<br/>
<div class="spacer">
</div>
Attempt to decode a buffer:<div class="spacer">
</div>
<br/>
 X509 *x;<br/>
<br/>
 unsigned char *buf, *p;<br/>
<br/>
 int len;<br/>
<br/>
 /* Something to setup buf and len */<br/>
<br/>
 p = buf;<br/>
<br/>
 x = d2i_X509(NULL, &amp;p, len);<br/>
<br/>
 if (x == NULL)<br/>
    /* Some error */<br/>
<div class="spacer">
</div>
Alternative technique:<div class="spacer">
</div>
<br/>
 X509 *x;<br/>
<br/>
 unsigned char *buf, *p;<br/>
<br/>
 int len;<br/>
<br/>
 /* Something to setup buf and len */<br/>
<br/>
 p = buf;<br/>
<br/>
 x = NULL;<br/>
<br/>
 if(!d2i_X509(&amp;x, &amp;p, len))<br/>
    /* Some error */<br/>
</div>
<div class="section">
<h1>WARNINGS</h1> The use of temporary variable is mandatory. A common mistake is to attempt to use a buffer directly as follows:<div class="spacer">
</div>
<br/>
 int len;<br/>
 unsigned char *buf;<br/>
<br/>
 len = i2d_X509(x, NULL);<br/>
<br/>
 buf = OPENSSL_malloc(len);<br/>
<br/>
 if (buf == NULL)<br/>
        /* error */<br/>
<br/>
 i2d_X509(x, &amp;buf);<br/>
<br/>
 /* Other stuff ... */<br/>
<br/>
 OPENSSL_free(buf);<br/>
<div class="spacer">
</div>
This code will result in <b>buf</b> apparently containing garbage because it was incremented after the call to point after the data just written. Also  <b>buf</b> will no longer contain the pointer allocated by <b></b><b><i>OPENSSL_malloc()</i></b><b></b> and the subsequent call to  <b></b><b><i>OPENSSL_free()</i></b><b></b> may well crash.<div class="spacer">
</div>
The auto allocation feature (setting buf to NULL) only works on OpenSSL 0.9.7 and later. Attempts to use it on earlier versions will typically cause a segmentation violation.<div class="spacer">
</div>
Another trap to avoid is misuse of the <b>xp</b> argument to <b></b><b><i>d2i_X509()</i></b><b></b>:<div class="spacer">
</div>
<br/>
 X509 *x;<br/>
<br/>
 if (!d2i_X509(&amp;x, &amp;p, len))<br/>
        /* Some error */<br/>
<div class="spacer">
</div>
This will probably crash somewhere in <b></b><b><i>d2i_X509()</i></b><b></b>. The reason for this is that the variable  <b>x</b> is uninitialized and an attempt will be made to interpret its (invalid) value as an  <b>X509</b> structure, typically causing a segmentation violation. If  <b>x</b> is set to NULL first then this will not happen.</div>
<div class="section">
<h1>BUGS</h1> In some versions of OpenSSL the &quot;reuse&quot; behaviour of  <i>d2i_X509()</i> when  <b>*px</b> is valid is broken and some parts of the reused structure may persist if they are not present in the new one. As a result the use of this &quot;reuse&quot; behaviour is strongly discouraged.<div class="spacer">
</div>
<i>i2d_X509()</i> will not return an error in many versions of OpenSSL, if mandatory fields are not initialized due to a programming error then the encoded structure may contain invalid data or omit the fields entirely and will not be parsed by  <i>d2i_X509()</i>. This may be fixed in future so code should not assume that  <i>i2d_X509()</i> will always succeed.</div>
<div class="section">
<h1>RETURN VALUES</h1>  <i>d2i_X509()</i>, <i>d2i_X509_bio()</i> and <i>d2i_X509_fp()</i> return a valid <b>X509</b> structure or  <b>NULL</b> if an error occurs. The error code that can be obtained by  <i>ERR_get_error</i>(3).<div class="spacer">
</div>
<i>i2d_X509()</i> returns the number of bytes successfully encoded or a negative value if an error occurs. The error code can be obtained by  <i>ERR_get_error</i>(3).<div class="spacer">
</div>
<i>i2d_X509_bio()</i> and <i>i2d_X509_fp()</i> return 1 for success and 0 if an error occurs The error code can be obtained by  <i>ERR_get_error</i>(3).</div>
<div class="section">
<h1>SEE ALSO</h1>  <i>ERR_get_error</i>(3)</div>
<div class="section">
<h1>HISTORY</h1> d2i_X509, i2d_X509, d2i_X509_bio, d2i_X509_fp, i2d_X509_bio and i2d_X509_fp are available in all versions of SSLeay and OpenSSL.</div>
<table class="foot">
<tr>
<td class="foot-date">
2009-09-12</td>
<td class="foot-os">
1.0.1</td>
</tr>
</table>
</div>
</body>
</html>

