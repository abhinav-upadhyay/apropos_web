<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
PCRECOMPAT(3)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
PCRECOMPAT(3)</td>
<td class="head-vol">
Library Functions Manual</td>
<td class="head-rtitle">
PCRECOMPAT(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> PCRE - Perl-compatible regular expressions</div>
<div class="section">
<h1>DIFFERENCES BETWEEN PCRE AND PERL</h1> This document describes the differences in the ways that PCRE and Perl handle regular expressions. The differences described here are with respect to Perl versions 5.10 and above.<div class="spacer">
</div>
1. PCRE has only a subset of Perl's Unicode support. Details of what it does have are given in the  <b>pcreunicode</b> page.<div class="spacer">
</div>
2. PCRE allows repeat quantifiers only on parenthesized assertions, but they do not mean what you might think. For example, (?!a){3} does not assert that the next three characters are not &quot;a&quot;. It just asserts that the next character is not &quot;a&quot; three times (in principle: PCRE optimizes this to run the assertion just once). Perl allows repeat quantifiers on other assertions such as \b, but these do not seem to have any use.<div class="spacer">
</div>
3. Capturing subpatterns that occur inside negative lookahead assertions are counted, but their entries in the offsets vector are never set. Perl sets its numerical variables from any such patterns that are matched before the assertion fails to match something (thereby succeeding), but only if the negative lookahead assertion contains just one branch.<div class="spacer">
</div>
4. Though binary zero characters are supported in the subject string, they are not allowed in a pattern string because it is passed as a normal C string, terminated by zero. The escape sequence \0 can be used in the pattern to represent a binary zero.<div class="spacer">
</div>
5. The following Perl escape sequences are not supported: \l, \u, \L, \U, and \N when followed by a character name or Unicode value. (\N on its own, matching a non-newline character, is supported.) In fact these are implemented by Perl's general string-handling and are not part of its pattern matching engine. If any of these are encountered by PCRE, an error is generated by default. However, if the PCRE_JAVASCRIPT_COMPAT option is set, \U and \u are interpreted as JavaScript interprets them.<div class="spacer">
</div>
6. The Perl escape sequences \p, \P, and \X are supported only if PCRE is built with Unicode character property support. The properties that can be tested with \p and \P are limited to the general category properties such as Lu and Nd, script names such as Greek or Han, and the derived properties Any and L&amp;. PCRE does support the Cs (surrogate) property, which Perl does not; the Perl documentation says &quot;Because Perl hides the need for the user to understand the internal representation of Unicode characters, there is no need to implement the somewhat messy concept of surrogates.&quot;<div class="spacer">
</div>
7. PCRE implements a simpler version of \X than Perl, which changed to make \X match what Unicode calls an &quot;extended grapheme cluster&quot;. This is more complicated than an extended Unicode sequence, which is what PCRE matches.<div class="spacer">
</div>
8. PCRE does support the \Q...\E escape for quoting substrings. Characters in between are treated as literals. This is slightly different from Perl in that $ and @ are also handled as literals inside the quotes. In Perl, they cause variable interpolation (but of course PCRE does not have variables). Note the following examples:<div style="height: 1.00em;">
&#160;</div>
<br/>
    Pattern            PCRE matches      Perl matches<div style="height: 1.00em;">
&#160;</div>
<br/>
    \Qabc$xyz\E        abc$xyz           abc followed by the<br/>
                                           contents of $xyz<br/>
    \Qabc\$xyz\E       abc\$xyz          abc\$xyz<br/>
    \Qabc\E\$\Qxyz\E   abc$xyz           abc$xyz<div style="height: 1.00em;">
&#160;</div>
The \Q...\E sequence is recognized both inside and outside character classes.<div class="spacer">
</div>
9. Fairly obviously, PCRE does not support the (?{code}) and (??{code}) constructions. However, there is support for recursive patterns. This is not available in Perl 5.8, but it is in Perl 5.10. Also, the PCRE &quot;callout&quot; feature allows an external function to be called during pattern matching. See the  <b>pcrecallout</b> documentation for details.<div class="spacer">
</div>
10. Subpatterns that are called as subroutines (whether or not recursively) are always treated as atomic groups in PCRE. This is like Python, but unlike Perl. Captured values that are set outside a subroutine call can be reference from inside in PCRE, but not in Perl. There is a discussion that explains these differences in more detail in the section on recursion differences from Perl in the  <b>pcrepattern</b> page.<div class="spacer">
</div>
11. If any of the backtracking control verbs are used in an assertion or in a subpattern that is called as a subroutine (whether or not recursively), their effect is confined to that subpattern; it does not extend to the surrounding pattern. This is not always the case in Perl. In particular, if (*THEN) is present in a group that is called as a subroutine, its action is limited to that group, even if the group does not contain any | characters. There is one exception to this: the name from a *(MARK), (*PRUNE), or (*THEN) that is encountered in a successful positive assertion  <i>is</i> passed back when a match succeeds (compare capturing parentheses in assertions). Note that such subpatterns are processed as anchored at the point where they are tested.<div class="spacer">
</div>
12. There are some differences that are concerned with the settings of captured strings when part of a pattern is repeated. For example, matching &quot;aba&quot; against the pattern /^(a(b)?)+$/ in Perl leaves $2 unset, but in PCRE it is set to &quot;b&quot;.<div class="spacer">
</div>
13. PCRE's handling of duplicate subpattern numbers and duplicate subpattern names is not as general as Perl's. This is a consequence of the fact the PCRE works internally just with numbers, using an external table to translate between numbers and names. In particular, a pattern such as (?|(?&lt;a&gt;A)|(?&lt;b)B), where the two capturing parentheses have the same number but different names, is not supported, and causes an error at compile time. If it were allowed, it would not be possible to distinguish which parentheses matched, because both names map to capturing subpattern number 1. To avoid this confusing situation, an error is given at compile time.<div class="spacer">
</div>
14. Perl recognizes comments in some places that PCRE does not, for example, between the ( and ? at the start of a subpattern. If the /x modifier is set, Perl allows white space between ( and ? but PCRE never does, even if the PCRE_EXTENDED option is set.<div class="spacer">
</div>
15. PCRE provides some extensions to the Perl regular expression facilities. Perl 5.10 includes new features that are not in earlier versions of Perl, some of which (such as named parentheses) have been in PCRE for some time. This list is with respect to Perl 5.10:<div style="height: 1.00em;">
&#160;</div>
(a) Although lookbehind assertions in PCRE must match fixed length strings, each alternative branch of a lookbehind assertion can match a different length of string. Perl requires them all to have the same length.<div style="height: 1.00em;">
&#160;</div>
(b) If PCRE_DOLLAR_ENDONLY is set and PCRE_MULTILINE is not set, the $ meta-character matches only at the very end of the string.<div style="height: 1.00em;">
&#160;</div>
(c) If PCRE_EXTRA is set, a backslash followed by a letter with no special meaning is faulted. Otherwise, like Perl, the backslash is quietly ignored. (Perl can be made to issue a warning.)<div style="height: 1.00em;">
&#160;</div>
(d) If PCRE_UNGREEDY is set, the greediness of the repetition quantifiers is inverted, that is, by default they are not greedy, but if followed by a question mark they are.<div style="height: 1.00em;">
&#160;</div>
(e) PCRE_ANCHORED can be used at matching time to force a pattern to be tried only at the first matching position in the subject string.<div style="height: 1.00em;">
&#160;</div>
(f) The PCRE_NOTBOL, PCRE_NOTEOL, PCRE_NOTEMPTY, PCRE_NOTEMPTY_ATSTART, and PCRE_NO_AUTO_CAPTURE options for  <b>pcre_exec()</b> have no Perl equivalents.<div style="height: 1.00em;">
&#160;</div>
(g) The \R escape sequence can be restricted to match only CR, LF, or CRLF by the PCRE_BSR_ANYCRLF option.<div style="height: 1.00em;">
&#160;</div>
(h) The callout facility is PCRE-specific.<div style="height: 1.00em;">
&#160;</div>
(i) The partial matching facility is PCRE-specific.<div style="height: 1.00em;">
&#160;</div>
(j) Patterns compiled by PCRE can be saved and re-used at a later time, even on different hosts that have the other endianness. However, this does not apply to optimized data created by the just-in-time compiler.<div style="height: 1.00em;">
&#160;</div>
(k) The alternative matching functions (<b>pcre_dfa_exec()</b> and  <b>pcre16_dfa_exec()</b>) match in a different way and are not Perl-compatible.<div style="height: 1.00em;">
&#160;</div>
(l) PCRE recognizes some special sequences such as (*CR) at the start of a pattern that set overall options that cannot be changed within the pattern.</div>
<div class="section">
<h1>AUTHOR</h1><br/>
Philip Hazel<br/>
University Computing Service<br/>
Cambridge CB2 3QH, England.<br/>
</div>
<div class="section">
<h1>REVISION</h1><br/>
Last updated: 01 June 2012<br/>
Copyright (c) 1997-2012 University of Cambridge.<br/>
</div>
<table class="foot">
<tr>
<td class="foot-date">
08 January 2012</td>
<td class="foot-os">
PCRE 8.30</td>
</tr>
</table>
</div>
</body>
</html>

