<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
encoding(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
encoding(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
encoding(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> encoding - allows you to write your script in non-ascii or non-utf8</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
  use encoding &quot;greek&quot;;  # Perl like Greek to you?<br/>
  use encoding &quot;euc-jp&quot;; # Jperl!<br/>
<br/>
  # or you can even do this if your shell supports your native encoding<br/>
<br/>
  perl -Mencoding=latin2 -e'...' # Feeling centrally European?<br/>
  perl -Mencoding=euc-kr -e'...' # Or Korean?<br/>
<br/>
  # more control<br/>
<br/>
  # A simple euc-cn =&gt; utf-8 converter<br/>
  use encoding &quot;euc-cn&quot;, STDOUT =&gt; &quot;utf8&quot;;  while(&lt;&gt;){print};<br/>
<br/>
  # &quot;no encoding;&quot; supported (but not scoped!)<br/>
  no encoding;<br/>
<br/>
  # an alternate way, Filter<br/>
  use encoding &quot;euc-jp&quot;, Filter=&gt;1;<br/>
  # now you can use kanji identifiers -- in euc-jp!<br/>
<br/>
  # switch on locale -<br/>
  # note that this probably means that unless you have a complete control<br/>
  # over the environments the application is ever going to be run, you should<br/>
  # NOT use the feature of encoding pragma allowing you to write your script<br/>
  # in any recognized encoding because changing locale settings will wreck<br/>
  # the script; you can of course still use the other features of the pragma.<br/>
  use encoding ':locale';<br/>
</div>
<div class="section">
<h1>ABSTRACT</h1> Let's start with a bit of history: Perl 5.6.0 introduced Unicode support.  You could apply &quot;substr()&quot; and regexes even to complex CJK characters -- so long as the script was written in UTF-8.  But back then, text editors that supported UTF-8 were still rare and many users instead chose to write scripts in legacy encodings, giving up a whole new feature of Perl 5.6.<div class="spacer">
</div>
Rewind to the future: starting from perl 5.8.0 with the <b>encoding</b> pragma, you can write your script in any encoding you like (so long as the &quot;Encode&quot; module supports it) and still enjoy Unicode support. This pragma achieves that by doing the following:<dl>
<dt>
&#8226;</dt>
<dd>
Internally converts all literals (&quot;q//,qq//,qr//,qw///, qx//&quot;) from the encoding specified to utf8.  In Perl 5.8.1 and later, literals in &quot;tr///&quot; and &quot;DATA&quot; pseudo-filehandle are also converted.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Changing PerlIO layers of &quot;STDIN&quot; and &quot;STDOUT&quot; to the encoding<br/>
 specified.</dd>
</dl>
<div class="subsection">
<h2>Literal Conversions</h2> You can write code in EUC-JP as follows:<div class="spacer">
</div>
<br/>
  my $Rakuda = &quot;\xF1\xD1\xF1\xCC&quot;; # Camel in Kanji<br/>
               #&lt;-char-&gt;&lt;-char-&gt;   # 4 octets<br/>
  s/\bCamel\b/$Rakuda/;<br/>
<div class="spacer">
</div>
And with &quot;use encoding &quot;euc-jp&quot;&quot; in effect, it is the same thing as the code in UTF-8:<div class="spacer">
</div>
<br/>
  my $Rakuda = &quot;\x{99F1}\x{99DD}&quot;; # two Unicode Characters<br/>
  s/\bCamel\b/$Rakuda/;<br/>
</div>
<div class="subsection">
<h2>PerlIO layers for &quot;STD(IN|OUT)&quot;</h2> The  <b>encoding</b> pragma also modifies the filehandle layers of STDIN and STDOUT to the specified encoding.  Therefore,<div class="spacer">
</div>
<br/>
  use encoding &quot;euc-jp&quot;;<br/>
  my $message = &quot;Camel is the symbol of perl.\n&quot;;<br/>
  my $Rakuda = &quot;\xF1\xD1\xF1\xCC&quot;; # Camel in Kanji<br/>
  $message =~ s/\bCamel\b/$Rakuda/;<br/>
  print $message;<br/>
<div class="spacer">
</div>
Will print &quot;\xF1\xD1\xF1\xCC is the symbol of perl.\n&quot;, not &quot;\x{99F1}\x{99DD} is the symbol of perl.\n&quot;.<div class="spacer">
</div>
You can override this by giving extra arguments; see below.</div>
<div class="subsection">
<h2>Implicit upgrading for byte strings</h2> By default, if strings operating under byte semantics and strings with Unicode character data are concatenated, the new string will be created by decoding the byte strings as  <i>ISO 8859-1 (Latin-1)</i>.<div class="spacer">
</div>
The <b>encoding</b> pragma changes this to use the specified encoding instead.  For example:<div class="spacer">
</div>
<br/>
    use encoding 'utf8';<br/>
    my $string = chr(20000); # a Unicode string<br/>
    utf8::encode($string);   # now it's a UTF-8 encoded byte string<br/>
    # concatenate with another Unicode string<br/>
    print length($string . chr(20000));<br/>
<div class="spacer">
</div>
Will print 2, because $string is upgraded as UTF-8.  Without &quot;use encoding 'utf8';&quot;, it will print 4 instead, since $string is three octets when interpreted as Latin-1.</div>
<div class="subsection">
<h2>Side effects</h2> If the &quot;encoding&quot; pragma is in scope then the lengths returned are calculated from the length of $/ in Unicode characters, which is not always the same as the length of $/ in the native encoding.<div class="spacer">
</div>
This pragma affects utf8::upgrade, but not utf8::downgrade.</div>
</div>
<div class="section">
<h1>FEATURES THAT REQUIRE 5.8.1</h1> Some of the features offered by this pragma requires perl 5.8.1.  Most of these are done by Inaba Hiroto.  Any other features and changes are good for 5.8.0.<dl>
<dt>
&quot;NON-EUC&quot; doublebyte encodings</dt>
<dd>
Because perl needs to parse script before applying this pragma, such encodings as Shift_JIS and Big-5 that may contain '\' (BACKSLASH; \x5c) in the second byte fails because the second byte may accidentally escape the quoting character that follows.  Perl 5.8.1 or later fixes this problem.</dd>
</dl>
<dl>
<dt>
tr//</dt>
<dd>
&quot;tr//&quot; was overlooked by Perl 5 porters when they released perl 5.8.0 See the section below for details.</dd>
</dl>
<dl>
<dt>
DATA pseudo-filehandle</dt>
<dd>
Another feature that was overlooked was &quot;DATA&quot;.</dd>
</dl>
</div>
<div class="section">
<h1>USAGE</h1><dl>
<dt>
use encoding [<i>ENCNAME</i>] ;</dt>
<dd>
Sets the script encoding to <i>ENCNAME</i>.  And unless ${^UNICODE} exists and non-zero, PerlIO layers of STDIN and STDOUT are set to &quot;:encoding( <i>ENCNAME</i>)&quot;.<div style="height: 1.00em;">
&#160;</div>
Note that STDERR WILL NOT be changed.<div style="height: 1.00em;">
&#160;</div>
Also note that non-STD file handles remain unaffected.  Use &quot;use open&quot; or &quot;binmode&quot; to change layers of those.<div style="height: 1.00em;">
&#160;</div>
If no encoding is specified, the environment variable PERL_ENCODING is consulted.  If no encoding can be found, the error &quot;Unknown encoding ' <i>ENCNAME</i>'&quot; will be thrown.</dd>
</dl>
<dl>
<dt>
use encoding <i>ENCNAME</i> [ STDIN =&gt; <i>ENCNAME_IN</i> ...] ;</dt>
<dd>
You can also individually set encodings of STDIN and STDOUT via the &quot;STDIN =&gt;  <i>ENCNAME</i>&quot; form.  In this case, you cannot omit the first  <i>ENCNAME</i>.  &quot;STDIN =&gt; undef&quot; turns the IO transcoding completely off.<div style="height: 1.00em;">
&#160;</div>
When ${^UNICODE} exists and non-zero, these options will completely ignored.  ${^UNICODE} is a variable introduced in perl 5.8.1.  See perlrun see &quot;${^UNICODE}&quot; in perlvar and &quot;-C&quot; in perlrun for details (perl 5.8.1 and later).</dd>
</dl>
<dl>
<dt>
use encoding <i>ENCNAME</i> Filter=&gt;1;</dt>
<dd>
This turns the encoding pragma into a source filter.  While the default approach just decodes interpolated literals (in  <i>qq()</i> and  <i>qr()</i>), this will apply a source filter to the entire source code.  See &quot;The Filter Option&quot; below for details.</dd>
</dl>
<dl>
<dt>
no encoding;</dt>
<dd>
Unsets the script encoding. The layers of STDIN, STDOUT are reset to &quot;:raw&quot; (the default unprocessed raw stream of bytes).</dd>
</dl>
</div>
<div class="section">
<h1>The Filter Option</h1> The magic of &quot;use encoding&quot; is not applied to the names of identifiers.  In order to make &quot;${&quot;\x{4eba}&quot;}++&quot; ($human++, where human is a single Han ideograph) work, you still need to write your script in UTF-8 -- or use a source filter.  That's what 'Filter=&gt;1' does.<div class="spacer">
</div>
What does this mean?  Your source code behaves as if it is written in UTF-8 with 'use utf8' in effect.  So even if your editor only supports Shift_JIS, for example, you can still try examples in Chapter 15 of &quot;Programming Perl, 3rd Ed.&quot;.  For instance, you can use UTF-8 identifiers.<div class="spacer">
</div>
This option is significantly slower and (as of this writing) non-ASCII identifiers are not very stable WITHOUT this option and with the source code written in UTF-8.<div class="subsection">
<h2>Filter-related changes at Encode version 1.87</h2><dl>
<dt>
&#8226;</dt>
<dd>
The Filter option now sets STDIN and STDOUT like non-filter options. And &quot;STDIN=&gt; <i>ENCODING</i>&quot; and &quot;STDOUT=&gt;<i>ENCODING</i>&quot; work like non-filter version.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;use utf8&quot; is implicitly declared so you no longer have to &quot;use utf8&quot; to &quot;${&quot;\x{4eba}&quot;}++&quot;.</dd>
</dl>
</div>
</div>
<div class="section">
<h1>CAVEATS</h1><div class="subsection">
<h2>NOT SCOPED</h2> The pragma is a per script, not a per block lexical.  Only the last &quot;use encoding&quot; or &quot;no encoding&quot; matters, and it affects  <b>the whole script</b>.  However, the &lt;no encoding&gt; pragma is supported and  <b>use encoding</b> can appear as many times as you want in a given script. The multiple use of this pragma is discouraged.<div class="spacer">
</div>
By the same reason, the use this pragma inside modules is also discouraged (though not as strongly discouraged as the case above. See below).<div class="spacer">
</div>
If you still have to write a module with this pragma, be very careful of the load order.  See the codes below;<div class="spacer">
</div>
<br/>
  # called module<br/>
  package Module_IN_BAR;<br/>
  use encoding &quot;bar&quot;;<br/>
  # stuff in &quot;bar&quot; encoding here<br/>
  1;<br/>
<br/>
  # caller script<br/>
  use encoding &quot;foo&quot;<br/>
  use Module_IN_BAR;<br/>
  # surprise! use encoding &quot;bar&quot; is in effect.<br/>
<div class="spacer">
</div>
The best way to avoid this oddity is to use this pragma RIGHT AFTER other modules are loaded.  i.e.<div class="spacer">
</div>
<br/>
  use Module_IN_BAR;<br/>
  use encoding &quot;foo&quot;;<br/>
</div>
<div class="subsection">
<h2>DO NOT MIX MULTIPLE ENCODINGS</h2> Notice that only literals (string or regular expression) having only legacy code points are affected: if you mix data like this<div class="spacer">
</div>
<br/>
    \xDF\x{100}<br/>
<div class="spacer">
</div>
the data is assumed to be in (Latin 1 and) Unicode, not in your native encoding.  In other words, this will match in &quot;greek&quot;:<div class="spacer">
</div>
<br/>
    &quot;\xDF&quot; =~ /\x{3af}/<br/>
<div class="spacer">
</div>
but this will not<div class="spacer">
</div>
<br/>
    &quot;\xDF\x{100}&quot; =~ /\x{3af}\x{100}/<br/>
<div class="spacer">
</div>
since the &quot;\xDF&quot; (ISO 8859-7 GREEK SMALL LETTER IOTA WITH TONOS) on the left will  <b>not</b> be upgraded to &quot;\x{3af}&quot; (Unicode GREEK SMALL LETTER IOTA WITH TONOS) because of the &quot;\x{100}&quot; on the left.  You should not be mixing your legacy data and Unicode in the same string.<div class="spacer">
</div>
This pragma also affects encoding of the 0x80..0xFF code point range: normally characters in that range are left as eight-bit bytes (unless they are combined with characters with code points 0x100 or larger, in which case all characters need to become UTF-8 encoded), but if the &quot;encoding&quot; pragma is present, even the 0x80..0xFF range always gets UTF-8 encoded.<div class="spacer">
</div>
After all, the best thing about this pragma is that you don't have to resort to \x{....} just to spell your name in a native encoding. So feel free to put your strings in your encoding in quotes and regexes.</div>
<div class="subsection">
<h2>tr/// with ranges</h2> The  <b>encoding</b> pragma works by decoding string literals in &quot;q//,qq//,qr//,qw///, qx//&quot; and so forth.  In perl 5.8.0, this does not apply to &quot;tr///&quot;.  Therefore,<div class="spacer">
</div>
<br/>
  use encoding 'euc-jp';<br/>
  #....<br/>
  $kana =~ tr/\xA4\xA1-\xA4\xF3/\xA5\xA1-\xA5\xF3/;<br/>
  #           -------- -------- -------- --------<br/>
<div class="spacer">
</div>
Does not work as<div class="spacer">
</div>
<br/>
  $kana =~ tr/\x{3041}-\x{3093}/\x{30a1}-\x{30f3}/;<br/>
<dl>
<dt>
Legend of characters above</dt>
<dd>
<br/>
  utf8     euc-jp   charnames::viacode()<br/>
  -----------------------------------------<br/>
  \x{3041} \xA4\xA1 HIRAGANA LETTER SMALL A<br/>
  \x{3093} \xA4\xF3 HIRAGANA LETTER N<br/>
  \x{30a1} \xA5\xA1 KATAKANA LETTER SMALL A<br/>
  \x{30f3} \xA5\xF3 KATAKANA LETTER N<br/>
</dd>
</dl>
<div class="spacer">
</div>
This counterintuitive behavior has been fixed in perl 5.8.1.<div class="spacer">
</div>
<i>workaround to tr///;</i><div class="spacer">
</div>
In perl 5.8.0, you can work around as follows;<div class="spacer">
</div>
<br/>
  use encoding 'euc-jp';<br/>
  #  ....<br/>
  eval qq{ \$kana =~ tr/\xA4\xA1-\xA4\xF3/\xA5\xA1-\xA5\xF3/ };<br/>
<div class="spacer">
</div>
Note the &quot;tr//&quot; expression is surrounded by &quot;qq{}&quot;.  The idea behind is the same as classic idiom that makes &quot;tr///&quot; 'interpolate'.<div class="spacer">
</div>
<br/>
   tr/$from/$to/;            # wrong!<br/>
   eval qq{ tr/$from/$to/ }; # workaround.<br/>
<div class="spacer">
</div>
Nevertheless, in case of <b>encoding</b> pragma even &quot;q//&quot; is affected so &quot;tr///&quot; not being decoded was obviously against the will of Perl5 Porters so it has been fixed in Perl 5.8.1 or later.</div>
</div>
<div class="section">
<h1>EXAMPLE - Greekperl</h1><br/>
    use encoding &quot;iso 8859-7&quot;;<br/>
<br/>
    # \xDF in ISO 8859-7 (Greek) is \x{3af} in Unicode.<br/>
<br/>
    $a = &quot;\xDF&quot;;<br/>
    $b = &quot;\x{100}&quot;;<br/>
<br/>
    printf &quot;%#x\n&quot;, ord($a); # will print 0x3af, not 0xdf<br/>
<br/>
    $c = $a . $b;<br/>
<br/>
    # $c will be &quot;\x{3af}\x{100}&quot;, not &quot;\x{df}\x{100}&quot;.<br/>
<br/>
    # chr() is affected, and ...<br/>
<br/>
    print &quot;mega\n&quot;  if ord(chr(0xdf)) == 0x3af;<br/>
<br/>
    # ... ord() is affected by the encoding pragma ...<br/>
<br/>
    print &quot;tera\n&quot; if ord(pack(&quot;C&quot;, 0xdf)) == 0x3af;<br/>
<br/>
    # ... as are eq and cmp ...<br/>
<br/>
    print &quot;peta\n&quot; if &quot;\x{3af}&quot; eq  pack(&quot;C&quot;, 0xdf);<br/>
    print &quot;exa\n&quot;  if &quot;\x{3af}&quot; cmp pack(&quot;C&quot;, 0xdf) == 0;<br/>
<br/>
    # ... but pack/unpack C are not affected, in case you still<br/>
    # want to go back to your native encoding<br/>
<br/>
    print &quot;zetta\n&quot; if unpack(&quot;C&quot;, (pack(&quot;C&quot;, 0xdf))) == 0xdf;<br/>
</div>
<div class="section">
<h1>KNOWN PROBLEMS</h1><dl>
<dt>
literals in regex that are longer than 127 bytes</dt>
<dd>
For native multibyte encodings (either fixed or variable length), the current implementation of the regular expressions may introduce recoding errors for regular expression literals longer than 127 bytes.</dd>
</dl>
<dl>
<dt>
EBCDIC</dt>
<dd>
The encoding pragma is not supported on EBCDIC platforms. (Porters who are willing and able to remove this limitation are welcome.)</dd>
</dl>
<dl>
<dt>
format</dt>
<dd>
This pragma doesn't work well with format because PerlIO does not get along very well with it.  When format contains non-ascii characters it prints funny or gets &quot;wide character warnings&quot;. To understand it, try the code below.<div style="height: 1.00em;">
&#160;</div>
<br/>
  # Save this one in utf8<br/>
  # replace *non-ascii* with a non-ascii string<br/>
  my $camel;<br/>
  format STDOUT =<br/>
  *non-ascii*@&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br/>
  $camel<br/>
  .<br/>
  $camel = &quot;*non-ascii*&quot;;<br/>
  binmode(STDOUT=&gt;':encoding(utf8)'); # bang!<br/>
  write;              # funny<br/>
  print $camel, &quot;\n&quot;; # fine<br/>
<div style="height: 1.00em;">
&#160;</div>
Without binmode this happens to work but without binmode, <i>print()</i> fails instead of  <i>write()</i>.<div style="height: 1.00em;">
&#160;</div>
At any rate, the very use of format is questionable when it comes to unicode characters since you have to consider such things as character width (i.e. double-width for ideographs) and directions (i.e. BIDI for Arabic and Hebrew).</dd>
</dl>
<dl>
<dt>
Thread safety</dt>
<dd>
&quot;use encoding ...&quot; is not thread-safe (i.e., do not use in threaded applications).</dd>
</dl>
<div class="subsection">
<h2>The Logic of :locale</h2> The logic of &quot;:locale&quot; is as follows:<dl>
<dt>
1.</dt>
<dd>
If the platform supports the langinfo(CODESET) interface, the codeset returned is used as the default encoding for the open pragma.</dd>
</dl>
<dl>
<dt>
2.</dt>
<dd>
If 1. didn't work but we are under the locale pragma, the environment variables LC_ALL and LANG (in that order) are matched for encodings (the part after &quot;.&quot;, if any), and if any found, that is used as the default encoding for the open pragma.</dd>
</dl>
<dl>
<dt>
3.</dt>
<dd>
If 1. and 2. didn't work, the environment variables LC_ALL and LANG (in that order) are matched for anything looking like UTF-8, and if any found, &quot;:utf8&quot; is used as the default encoding for the open pragma.</dd>
</dl>
<div class="spacer">
</div>
If your locale environment variables (LC_ALL, LC_CTYPE, LANG) contain the strings 'UTF-8' or 'UTF8' (case-insensitive matching), the default encoding of your STDIN, STDOUT, and STDERR, and of  <b>any subsequent file open</b>, is UTF-8.</div>
</div>
<div class="section">
<h1>HISTORY</h1> This pragma first appeared in Perl 5.8.0.  For features that require 5.8.1 and better, see above.<div class="spacer">
</div>
The &quot;:locale&quot; subpragma was implemented in 2.01, or Perl 5.8.6.</div>
<div class="section">
<h1>SEE ALSO</h1> perlunicode, Encode, open, Filter::Util::Call,<div class="spacer">
</div>
Ch. 15 of &quot;Programming Perl (3rd Edition)&quot; by Larry Wall, Tom Christiansen, Jon Orwant; O'Reilly &amp; Associates; ISBN 0-596-00027-8</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-09-26</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

