<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
File::Basename(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
File::Basename(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
File::Basename(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> File::Basename - Parse file paths into directory, filename and suffix.</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
    use File::Basename;<br/>
<br/>
    ($name,$path,$suffix) = fileparse($fullname,@suffixlist);<br/>
    $name = fileparse($fullname,@suffixlist);<br/>
<br/>
    $basename = basename($fullname,@suffixlist);<br/>
    $dirname  = dirname($fullname);<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> These routines allow you to parse file paths into their directory, filename and suffix.<div class="spacer">
</div>
<b>NOTE</b>: &quot;dirname()&quot; and &quot;basename()&quot; emulate the behaviours, and quirks, of the shell and C functions of the same name.  See each function's documentation for details.  If your concern is just parsing paths it is safer to use File::Spec's &quot;splitpath()&quot; and &quot;splitdir()&quot; methods.<div class="spacer">
</div>
It is guaranteed that<div class="spacer">
</div>
<br/>
    # Where $path_separator is / for Unix, \ for Windows, etc...<br/>
    dirname($path) . $path_separator . basename($path);<br/>
<div class="spacer">
</div>
is equivalent to the original path for all systems but VMS.<dl>
<dt>
&quot;fileparse&quot;</dt>
<dd>
<br/>
    my($filename, $directories, $suffix) = fileparse($path);<br/>
    my($filename, $directories, $suffix) = fileparse($path, @suffixes);<br/>
    my $filename                         = fileparse($path, @suffixes);<br/>
<div style="height: 1.00em;">
&#160;</div>
The &quot;fileparse()&quot; routine divides a file path into its $directories, $filename and (optionally) the filename $suffix.<div style="height: 1.00em;">
&#160;</div>
$directories contains everything up to and including the last directory separator in the $path including the volume (if applicable). The remainder of the $path is the $filename.<div style="height: 1.00em;">
&#160;</div>
<br/>
     # On Unix returns (&quot;baz&quot;, &quot;/foo/bar/&quot;, &quot;&quot;)<br/>
     fileparse(&quot;/foo/bar/baz&quot;);<br/>
<br/>
     # On Windows returns (&quot;baz&quot;, 'C:\foo\bar\', &quot;&quot;)<br/>
     fileparse('C:\foo\bar\baz');<br/>
<br/>
     # On Unix returns (&quot;&quot;, &quot;/foo/bar/baz/&quot;, &quot;&quot;)<br/>
     fileparse(&quot;/foo/bar/baz/&quot;);<br/>
<div style="height: 1.00em;">
&#160;</div>
If @suffixes are given each element is a pattern (either a string or a &quot;qr//&quot;) matched against the end of the $filename.  The matching portion is removed and becomes the $suffix.<div style="height: 1.00em;">
&#160;</div>
<br/>
     # On Unix returns (&quot;baz&quot;, &quot;/foo/bar/&quot;, &quot;.txt&quot;)<br/>
     fileparse(&quot;/foo/bar/baz.txt&quot;, qr/\.[^.]*/);<br/>
<div style="height: 1.00em;">
&#160;</div>
If type is non-Unix (see &quot;fileparse_set_fstype()&quot;) then the pattern matching for suffix removal is performed case-insensitively, since those systems are not case-sensitive when opening existing files.<div style="height: 1.00em;">
&#160;</div>
You are guaranteed that &quot;$directories . $filename . $suffix&quot; will denote the same location as the original $path.</dd>
</dl>
<dl>
<dt>
&quot;basename&quot;</dt>
<dd>
<br/>
    my $filename = basename($path);<br/>
    my $filename = basename($path, @suffixes);<br/>
<div style="height: 1.00em;">
&#160;</div>
This function is provided for compatibility with the Unix shell command basename(1).  It does  <b>NOT</b> always return the file name portion of a path as you might expect.  To be safe, if you want the file name portion of a path use &quot;fileparse()&quot;.<div style="height: 1.00em;">
&#160;</div>
&quot;basename()&quot; returns the last level of a filepath even if the last level is clearly directory.  In effect, it is acting like &quot;pop()&quot; for paths.  This differs from &quot;fileparse()&quot;'s behaviour.<div style="height: 1.00em;">
&#160;</div>
<br/>
    # Both return &quot;bar&quot;<br/>
    basename(&quot;/foo/bar&quot;);<br/>
    basename(&quot;/foo/bar/&quot;);<br/>
<div style="height: 1.00em;">
&#160;</div>
@suffixes work as in &quot;fileparse()&quot; except all regex metacharacters are quoted.<div style="height: 1.00em;">
&#160;</div>
<br/>
    # These two function calls are equivalent.<br/>
    my $filename = basename(&quot;/foo/bar/baz.txt&quot;,  &quot;.txt&quot;);<br/>
    my $filename = fileparse(&quot;/foo/bar/baz.txt&quot;, qr/\Q.txt\E/);<br/>
<div style="height: 1.00em;">
&#160;</div>
Also note that in order to be compatible with the shell command, &quot;basename()&quot; does not strip off a suffix if it is identical to the remaining characters in the filename.</dd>
</dl>
<dl>
<dt>
&quot;dirname&quot;</dt>
<dd>
This function is provided for compatibility with the Unix shell command dirname(1) and has inherited some of its quirks.  In spite of its name it does  <b>NOT</b> always return the directory name as you might expect.  To be safe, if you want the directory name of a path use &quot;fileparse()&quot;.<div style="height: 1.00em;">
&#160;</div>
Only on VMS (where there is no ambiguity between the file and directory portions of a path) and AmigaOS (possibly due to an implementation quirk in this module) does &quot;dirname()&quot; work like &quot;fileparse($path)&quot;, returning just the $directories.<div style="height: 1.00em;">
&#160;</div>
<br/>
    # On VMS and AmigaOS<br/>
    my $directories = dirname($path);<br/>
<div style="height: 1.00em;">
&#160;</div>
When using Unix or MSDOS syntax this emulates the dirname(1) shell function which is subtly different from how &quot;fileparse()&quot; works.  It returns all but the last level of a file path even if the last level is clearly a directory. In effect, it is not returning the directory portion but simply the path one level up acting like &quot;chop()&quot; for file paths.<div style="height: 1.00em;">
&#160;</div>
Also unlike &quot;fileparse()&quot;, &quot;dirname()&quot; does not include a trailing slash on its returned path.<div style="height: 1.00em;">
&#160;</div>
<br/>
    # returns /foo/bar.  fileparse() would return /foo/bar/<br/>
    dirname(&quot;/foo/bar/baz&quot;);<br/>
<br/>
    # also returns /foo/bar despite the fact that baz is clearly a <br/>
    # directory.  fileparse() would return /foo/bar/baz/<br/>
    dirname(&quot;/foo/bar/baz/&quot;);<br/>
<br/>
    # returns '.'.  fileparse() would return 'foo/'<br/>
    dirname(&quot;foo/&quot;);<br/>
<div style="height: 1.00em;">
&#160;</div>
Under VMS, if there is no directory information in the $path, then the current default device and directory is used.</dd>
</dl>
<dl>
<dt>
&quot;fileparse_set_fstype&quot;</dt>
<dd>
<br/>
  my $type = fileparse_set_fstype();<br/>
  my $previous_type = fileparse_set_fstype($type);<br/>
<div style="height: 1.00em;">
&#160;</div>
Normally File::Basename will assume a file path type native to your current operating system (ie. /foo/bar style on Unix, \foo\bar on Windows, etc...). With this function you can override that assumption.<div style="height: 1.00em;">
&#160;</div>
Valid $types are &quot;MacOS&quot;, &quot;VMS&quot;, &quot;AmigaOS&quot;, &quot;OS2&quot;, &quot;RISCOS&quot;, &quot;MSWin32&quot;, &quot;DOS&quot; (also &quot;MSDOS&quot; for backwards bug compatibility), &quot;Epoc&quot; and &quot;Unix&quot; (all case-insensitive).  If an unrecognized $type is given &quot;Unix&quot; will be assumed.<div style="height: 1.00em;">
&#160;</div>
If you've selected VMS syntax, and the file specification you pass to one of these routines contains a &quot;/&quot;, they assume you are using Unix emulation and apply the Unix syntax rules instead, for that function call only.</dd>
</dl>
</div>
<div class="section">
<h1>SEE ALSO</h1>  <i>dirname</i>(1), <i>basename</i>(1), File::Spec</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-09-26</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

