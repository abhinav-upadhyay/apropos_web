<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Genlex(3)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Genlex(3)</td>
<td class="head-vol">
OCaml library</td>
<td class="head-rtitle">
Genlex(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Genlex - A generic lexical analyzer.</div>
<div class="section">
<h1>Module</h1> Module   Genlex</div>
<div class="section">
<h1>Documentation</h1> Module <b>Genlex</b><br/>
 : <b>sig end</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
A generic lexical analyzer.<div style="height: 1.00em;">
&#160;</div>
This module implements a simple 'standard' lexical analyzer, presented as a function from character streams to token streams. It implements roughly the lexical conventions of OCaml, but is parameterized by the set of keywords of your language.<div style="height: 1.00em;">
&#160;</div>
Example: a lexer suitable for a desk calculator is obtained by <b>let lexer = make_lexer [&quot;+&quot;;&quot;-&quot;;&quot;*&quot;;&quot;/&quot;;&quot;let&quot;;&quot;=&quot;; ( ; ) ]</b><div style="height: 1.00em;">
&#160;</div>
The associated parser would be a function from <b>token stream</b> to, for instance, <b>int</b> , and would have rules such as:<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>let rec parse_expr = parser</b> <b>| [&lt; n1 = parse_atom; n2 = parse_remainder n1 &gt;] -&gt; n2</b> <b>and parse_atom = parser</b> <b>| [&lt; 'Int n &gt;] -&gt; n</b> <b>| [&lt; 'Kwd ( ; n = parse_expr; 'Kwd ) &gt;] -&gt; n</b> <b>and parse_remainder n1 = parser</b> <b>| [&lt; 'Kwd + ; n2 = parse_expr &gt;] -&gt; n1+n2</b> <b>| [&lt; &gt;] -&gt; n1</b> <b><div style="height: 1.00em;">
&#160;</div>
One should notice that the use of the</b> <b>parser</b> keyword and associated notation for streams are only available through camlp4 extensions. This means that one has to preprocess its sources e. g. by using the <b>-pp</b> command-line switch of the compilers.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>type token</i> =<br/>
 | Kwd <b>of</b> <b>string</b><br/>
 | Ident <b>of</b> <b>string</b><br/>
 | Int <b>of</b> <b>int</b><br/>
 | Float <b>of</b> <b>float</b><br/>
 | String <b>of</b> <b>string</b><br/>
 | Char <b>of</b> <b>char</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
The type of tokens. The lexical classes are: <b>Int</b> and <b>Float</b> for integer and floating-point numbers; <b>String</b> for string literals, enclosed in double quotes; <b>Char</b> for character literals, enclosed in single quotes; <b>Ident</b> for identifiers (either sequences of letters, digits, underscores and quotes, or sequences of 'operator characters' such as <b>+</b> , <b>*</b> , etc); and <b>Kwd</b> for keywords (either identifiers or single 'special characters' such as <b>(</b> , <b>}</b> , etc).<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val make_lexer</i> : <b>string list -&gt; char Stream.t -&gt; token Stream.t</b><div style="height: 1.00em;">
&#160;</div>
Construct the lexer function. The first argument is the list of keywords. An identifier <b>s</b> is returned as <b>Kwd s</b> if <b>s</b> belongs to this list, and as <b>Ident s</b> otherwise. A special character <b>s</b> is returned as <b>Kwd s</b> if <b>s</b> belongs to this list, and cause a lexical error (exception <b>Stream.Error</b> with the offending lexeme as its parameter) otherwise. Blanks and newlines are skipped. Comments delimited by <b>(*</b> and <b>*)</b> are skipped as well, and can be nested. A <b>Stream.Failure</b> exception is raised if end of stream is unexpectedly reached.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<table class="foot">
<tr>
<td class="foot-date">
2015-08-12</td>
<td class="foot-os">
OCamldoc</td>
</tr>
</table>
</div>
</body>
</html>

