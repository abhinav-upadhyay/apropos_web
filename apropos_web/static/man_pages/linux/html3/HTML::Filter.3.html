<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
HTML::Filter(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
HTML::Filter(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
HTML::Filter(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> HTML::Filter - Filter HTML text through the parser</div>
<div class="section">
<h1>NOTE</h1>  <b>This module is deprecated.</b> The &quot;HTML::Parser&quot; now provides the functionally of &quot;HTML::Filter&quot; much more efficiently with the the &quot;default&quot; handler.</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
 require HTML::Filter;<br/>
 $p = HTML::Filter-&gt;new-&gt;parse_file(&quot;index.html&quot;);<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> &quot;HTML::Filter&quot; is an HTML parser that by default prints the original text of each HTML element (a slow version of  <i>cat</i>(1) basically). The callback methods may be overridden to modify the filtering for some HTML elements and you can override  <i>output()</i> method which is called to print the HTML text.<div class="spacer">
</div>
&quot;HTML::Filter&quot; is a subclass of &quot;HTML::Parser&quot;. This means that the document should be given to the parser by calling the $p-&gt; <i>parse()</i> or $p-&gt; <i>parse_file()</i> methods.</div>
<div class="section">
<h1>EXAMPLES</h1> The first example is a filter that will remove all comments from an HTML file.  This is achieved by simply overriding the comment method to do nothing.<div class="spacer">
</div>
<br/>
  package CommentStripper;<br/>
  require HTML::Filter;<br/>
  @ISA=qw(HTML::Filter);<br/>
  sub comment { }  # ignore comments<br/>
<div class="spacer">
</div>
The second example shows a filter that will remove any &lt;TABLE&gt;s found in the HTML file.  We specialize the  <i>start()</i> and <i>end()</i> methods to count table tags and then make output not happen when inside a table.<div class="spacer">
</div>
<br/>
  package TableStripper;<br/>
  require HTML::Filter;<br/>
  @ISA=qw(HTML::Filter);<br/>
  sub start<br/>
  {<br/>
     my $self = shift;<br/>
     $self-&gt;{table_seen}++ if $_[0] eq &quot;table&quot;;<br/>
     $self-&gt;SUPER::start(@_);<br/>
  }<br/>
<br/>
  sub end<br/>
  {<br/>
     my $self = shift;<br/>
     $self-&gt;SUPER::end(@_);<br/>
     $self-&gt;{table_seen}-- if $_[0] eq &quot;table&quot;;<br/>
  }<br/>
<br/>
  sub output<br/>
  {<br/>
      my $self = shift;<br/>
      unless ($self-&gt;{table_seen}) {<br/>
          $self-&gt;SUPER::output(@_);<br/>
      }<br/>
  }<br/>
<div class="spacer">
</div>
If you want to collect the parsed text internally you might want to do something like this:<div class="spacer">
</div>
<br/>
  package FilterIntoString;<br/>
  require HTML::Filter;<br/>
  @ISA=qw(HTML::Filter);<br/>
  sub output { push(@{$_[0]-&gt;{fhtml}}, $_[1]) }<br/>
  sub filtered_html { join(&quot;&quot;, @{$_[0]-&gt;{fhtml}}) }<br/>
</div>
<div class="section">
<h1>SEE ALSO</h1> HTML::Parser</div>
<div class="section">
<h1>COPYRIGHT</h1> Copyright 1997-1999 Gisle Aas.<div class="spacer">
</div>
This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</div>
<table class="foot">
<tr>
<td class="foot-date">
2008-04-04</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

