<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
TAP::Parser(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
TAP::Parser(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
TAP::Parser(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> TAP::Parser - Parse TAP output</div>
<div class="section">
<h1>VERSION</h1> Version 3.23</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
    use TAP::Parser;<br/>
<br/>
    my $parser = TAP::Parser-&gt;new( { source =&gt; $source } );<br/>
<br/>
    while ( my $result = $parser-&gt;next ) {<br/>
        print $result-&gt;as_string;<br/>
    }<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> &quot;TAP::Parser&quot; is designed to produce a proper parse of TAP output. For an example of how to run tests through this module, see the simple harnesses &quot;examples/&quot;.<div class="spacer">
</div>
There's a wiki dedicated to the Test Anything Protocol:<div class="spacer">
</div>
&lt;http://testanything.org&gt;<div class="spacer">
</div>
It includes the TAP::Parser Cookbook:<div class="spacer">
</div>
&lt;http://testanything.org/wiki/index.php/TAP::Parser_Cookbook&gt;</div>
<div class="section">
<h1>METHODS</h1><div class="subsection">
<h2>Class Methods</h2>  <i></i><i>&quot;new&quot;</i><i></i><div class="spacer">
</div>
<br/>
 my $parser = TAP::Parser-&gt;new(\%args);<br/>
<div class="spacer">
</div>
Returns a new &quot;TAP::Parser&quot; object.<div class="spacer">
</div>
The arguments should be a hashref with <i>one</i> of the following keys:<dl>
<dt>
&#8226;</dt>
<dd>
&quot;source&quot;<div style="height: 1.00em;">
&#160;</div>
<i>CHANGED in 3.18</i><div style="height: 1.00em;">
&#160;</div>
This is the preferred method of passing input to the constructor.<div style="height: 1.00em;">
&#160;</div>
The &quot;source&quot; is used to create a TAP::Parser::Source that is passed to the &quot;iterator_factory_class&quot; which in turn figures out how to handle the source and creates a &lt;TAP::Parser::Iterator&gt; for it.  The iterator is used by the parser to read in the TAP stream.<div style="height: 1.00em;">
&#160;</div>
To configure the <i>IteratorFactory</i> use the &quot;sources&quot; parameter below.<div style="height: 1.00em;">
&#160;</div>
Note that &quot;source&quot;, &quot;tap&quot; and &quot;exec&quot; are <i>mutually exclusive</i>.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;tap&quot;<div style="height: 1.00em;">
&#160;</div>
<i>CHANGED in 3.18</i><div style="height: 1.00em;">
&#160;</div>
The value should be the complete TAP output.<div style="height: 1.00em;">
&#160;</div>
The <i>tap</i> is used to create a TAP::Parser::Source that is passed to the &quot;iterator_factory_class&quot; which in turn figures out how to handle the source and creates a &lt;TAP::Parser::Iterator&gt; for it.  The iterator is used by the parser to read in the TAP stream.<div style="height: 1.00em;">
&#160;</div>
To configure the <i>IteratorFactory</i> use the &quot;sources&quot; parameter below.<div style="height: 1.00em;">
&#160;</div>
Note that &quot;source&quot;, &quot;tap&quot; and &quot;exec&quot; are <i>mutually exclusive</i>.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;exec&quot;<div style="height: 1.00em;">
&#160;</div>
Must be passed an array reference.<div style="height: 1.00em;">
&#160;</div>
The <i>exec</i> array ref is used to create a TAP::Parser::Source that is passed to the &quot;iterator_factory_class&quot; which in turn figures out how to handle the source and creates a &lt;TAP::Parser::Iterator&gt; for it.  The iterator is used by the parser to read in the TAP stream.<div style="height: 1.00em;">
&#160;</div>
By default the TAP::Parser::SourceHandler::Executable class will create a TAP::Parser::Iterator::Process object to handle the source.  This passes the array reference strings as command arguments to IPC::Open3::open3:<div style="height: 1.00em;">
&#160;</div>
<br/>
 exec =&gt; [ '/usr/bin/ruby', 't/my_test.rb' ]<br/>
<div style="height: 1.00em;">
&#160;</div>
If any &quot;test_args&quot; are given they will be appended to the end of the command argument list.<div style="height: 1.00em;">
&#160;</div>
To configure the <i>IteratorFactory</i> use the &quot;sources&quot; parameter below.<div style="height: 1.00em;">
&#160;</div>
Note that &quot;source&quot;, &quot;tap&quot; and &quot;exec&quot; are <i>mutually exclusive</i>.</dd>
</dl>
<div class="spacer">
</div>
The following keys are optional.<dl>
<dt>
&#8226;</dt>
<dd>
&quot;sources&quot;<div style="height: 1.00em;">
&#160;</div>
<i>NEW to 3.18</i>.<div style="height: 1.00em;">
&#160;</div>
If set, &quot;sources&quot; must be a hashref containing the names of the TAP::Parser::SourceHandlers to load and/or configure.  The values are a hash of configuration that will be accessible to to the source handlers via &quot;config_for&quot; in TAP::Parser::Source.<div style="height: 1.00em;">
&#160;</div>
For example:<div style="height: 1.00em;">
&#160;</div>
<br/>
  sources =&gt; {<br/>
    Perl =&gt; { exec =&gt; '/path/to/custom/perl' },<br/>
    File =&gt; { extensions =&gt; [ '.tap', '.txt' ] },<br/>
    MyCustom =&gt; { some =&gt; 'config' },<br/>
  }<br/>
<div style="height: 1.00em;">
&#160;</div>
This will cause &quot;TAP::Parser&quot; to pass custom configuration to two of the built- in source handlers - TAP::Parser::SourceHandler::Perl, TAP::Parser::SourceHandler::File - and attempt to load the &quot;MyCustom&quot; class.  See &quot;load_handlers&quot; in TAP::Parser::IteratorFactory for more detail.<div style="height: 1.00em;">
&#160;</div>
The &quot;sources&quot; parameter affects how &quot;source&quot;, &quot;tap&quot; and &quot;exec&quot; parameters are handled.<div style="height: 1.00em;">
&#160;</div>
See TAP::Parser::IteratorFactory, TAP::Parser::SourceHandler and subclasses for more details.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;callback&quot;<div style="height: 1.00em;">
&#160;</div>
If present, each callback corresponding to a given result type will be called with the result as the argument if the &quot;run&quot; method is used:<div style="height: 1.00em;">
&#160;</div>
<br/>
 my %callbacks = (<br/>
     test    =&gt; \&amp;test_callback,<br/>
     plan    =&gt; \&amp;plan_callback,<br/>
     comment =&gt; \&amp;comment_callback,<br/>
     bailout =&gt; \&amp;bailout_callback,<br/>
     unknown =&gt; \&amp;unknown_callback,<br/>
 );<br/>
<br/>
 my $aggregator = TAP::Parser::Aggregator-&gt;new;<br/>
 for my $file ( @test_files ) {<br/>
     my $parser = TAP::Parser-&gt;new(<br/>
         {<br/>
             source    =&gt; $file,<br/>
             callbacks =&gt; \%callbacks,<br/>
         }<br/>
     );<br/>
     $parser-&gt;run;<br/>
     $aggregator-&gt;add( $file, $parser );<br/>
 }<br/>
</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;switches&quot;<div style="height: 1.00em;">
&#160;</div>
If using a Perl file as a source, optional switches may be passed which will be used when invoking the perl executable.<div style="height: 1.00em;">
&#160;</div>
<br/>
 my $parser = TAP::Parser-&gt;new( {<br/>
     source   =&gt; $test_file,<br/>
     switches =&gt; [ '-Ilib' ],<br/>
 } );<br/>
</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;test_args&quot;<div style="height: 1.00em;">
&#160;</div>
Used in conjunction with the &quot;source&quot; and &quot;exec&quot; option to supply a reference to an @ARGV style array of arguments to pass to the test program.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;spool&quot;<div style="height: 1.00em;">
&#160;</div>
If passed a filehandle will write a copy of all parsed TAP to that handle.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;merge&quot;<div style="height: 1.00em;">
&#160;</div>
If false, STDERR is not captured (though it is 'relayed' to keep it somewhat synchronized with STDOUT.)<div style="height: 1.00em;">
&#160;</div>
If true, STDERR and STDOUT are the same filehandle.  This may cause breakage if STDERR contains anything resembling TAP format, but does allow exact synchronization.<div style="height: 1.00em;">
&#160;</div>
Subtleties of this behavior may be platform-dependent and may change in the future.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;grammar_class&quot;<div style="height: 1.00em;">
&#160;</div>
This option was introduced to let you easily customize which <i>grammar</i> class the parser should use.  It defaults to TAP::Parser::Grammar.<div style="height: 1.00em;">
&#160;</div>
See also &quot;make_grammar&quot;.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;result_factory_class&quot;<div style="height: 1.00em;">
&#160;</div>
This option was introduced to let you easily customize which <i>result</i> factory class the parser should use.  It defaults to TAP::Parser::ResultFactory.<div style="height: 1.00em;">
&#160;</div>
See also &quot;make_result&quot;.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;iterator_factory_class&quot;<div style="height: 1.00em;">
&#160;</div>
<i>CHANGED in 3.18</i><div style="height: 1.00em;">
&#160;</div>
This option was introduced to let you easily customize which <i>iterator</i> factory class the parser should use.  It defaults to TAP::Parser::IteratorFactory.</dd>
</dl>
</div>
<div class="subsection">
<h2>Instance Methods</h2>  <i></i><i>&quot;next&quot;</i><i></i><div class="spacer">
</div>
<br/>
  my $parser = TAP::Parser-&gt;new( { source =&gt; $file } );<br/>
  while ( my $result = $parser-&gt;next ) {<br/>
      print $result-&gt;as_string, &quot;\n&quot;;<br/>
  }<br/>
<div class="spacer">
</div>
This method returns the results of the parsing, one result at a time.  Note that it is destructive.  You can't rewind and examine previous results.<div class="spacer">
</div>
If callbacks are used, they will be issued before this call returns.<div class="spacer">
</div>
Each result returned is a subclass of TAP::Parser::Result.  See that module and related classes for more information on how to use them.<div class="spacer">
</div>
<i></i><i>&quot;run&quot;</i><i></i><div class="spacer">
</div>
<br/>
  $parser-&gt;run;<br/>
<div class="spacer">
</div>
This method merely runs the parser and parses all of the TAP.<div class="spacer">
</div>
<i></i><i>&quot;make_grammar&quot;</i><i></i><div class="spacer">
</div>
Make a new TAP::Parser::Grammar object and return it.  Passes through any arguments given.<div class="spacer">
</div>
The &quot;grammar_class&quot; can be customized, as described in &quot;new&quot;.<div class="spacer">
</div>
<i></i><i>&quot;make_result&quot;</i><i></i><div class="spacer">
</div>
Make a new TAP::Parser::Result object using the parser's TAP::Parser::ResultFactory, and return it.  Passes through any arguments given.<div class="spacer">
</div>
The &quot;result_factory_class&quot; can be customized, as described in &quot;new&quot;.<div class="spacer">
</div>
<i></i><i>&quot;make_iterator_factory&quot;</i><i></i><div class="spacer">
</div>
<i>NEW to 3.18</i>.<div class="spacer">
</div>
Make a new TAP::Parser::IteratorFactory object and return it.  Passes through any arguments given.<div class="spacer">
</div>
&quot;iterator_factory_class&quot; can be customized, as described in &quot;new&quot;.</div>
</div>
<div class="section">
<h1>INDIVIDUAL RESULTS</h1> If you've read this far in the docs, you've seen this:<div class="spacer">
</div>
<br/>
    while ( my $result = $parser-&gt;next ) {<br/>
        print $result-&gt;as_string;<br/>
    }<br/>
<div class="spacer">
</div>
Each result returned is a TAP::Parser::Result subclass, referred to as  <i>result types</i>.<div class="subsection">
<h2>Result types</h2> Basically, you fetch individual results from the TAP.  The six types, with examples of each, are as follows:<dl>
<dt>
&#8226;</dt>
<dd>
Version<div style="height: 1.00em;">
&#160;</div>
<br/>
 TAP version 12<br/>
</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Plan<div style="height: 1.00em;">
&#160;</div>
<br/>
 1..42<br/>
</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Pragma<div style="height: 1.00em;">
&#160;</div>
<br/>
 pragma +strict<br/>
</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Test<div style="height: 1.00em;">
&#160;</div>
<br/>
 ok 3 - We should start with some foobar!<br/>
</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Comment<div style="height: 1.00em;">
&#160;</div>
<br/>
 # Hope we don't use up the foobar.<br/>
</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Bailout<div style="height: 1.00em;">
&#160;</div>
<br/>
 Bail out!  We ran out of foobar!<br/>
</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Unknown<div style="height: 1.00em;">
&#160;</div>
<br/>
 ... yo, this ain't TAP! ...<br/>
</dd>
</dl>
<div class="spacer">
</div>
Each result fetched is a result object of a different type.  There are common methods to each result object and different types may have methods unique to their type.  Sometimes a type method may be overridden in a subclass, but its use is guaranteed to be identical.</div>
<div class="subsection">
<h2>Common type methods</h2>  <i></i><i>&quot;type&quot;</i><i></i><div class="spacer">
</div>
Returns the type of result, such as &quot;comment&quot; or &quot;test&quot;.<div class="spacer">
</div>
<i></i><i>&quot;as_string&quot;</i><i></i><div class="spacer">
</div>
Prints a string representation of the token.  This might not be the exact output, however.  Tests will have test numbers added if not present, TODO and SKIP directives will be capitalized and, in general, things will be cleaned up.  If you need the original text for the token, see the &quot;raw&quot; method.<div class="spacer">
</div>
<i></i><i>&quot;raw&quot;</i><i></i><div class="spacer">
</div>
Returns the original line of text which was parsed.<div class="spacer">
</div>
<i></i><i>&quot;is_plan&quot;</i><i></i><div class="spacer">
</div>
Indicates whether or not this is the test plan line.<div class="spacer">
</div>
<i></i><i>&quot;is_test&quot;</i><i></i><div class="spacer">
</div>
Indicates whether or not this is a test line.<div class="spacer">
</div>
<i></i><i>&quot;is_comment&quot;</i><i></i><div class="spacer">
</div>
Indicates whether or not this is a comment. Comments will generally only appear in the TAP stream if STDERR is merged to STDOUT. See the &quot;merge&quot; option.<div class="spacer">
</div>
<i></i><i>&quot;is_bailout&quot;</i><i></i><div class="spacer">
</div>
Indicates whether or not this is bailout line.<div class="spacer">
</div>
<i></i><i>&quot;is_yaml&quot;</i><i></i><div class="spacer">
</div>
Indicates whether or not the current item is a YAML block.<div class="spacer">
</div>
<i></i><i>&quot;is_unknown&quot;</i><i></i><div class="spacer">
</div>
Indicates whether or not the current line could be parsed.<div class="spacer">
</div>
<i></i><i>&quot;is_ok&quot;</i><i></i><div class="spacer">
</div>
<br/>
  if ( $result-&gt;is_ok ) { ... }<br/>
<div class="spacer">
</div>
Reports whether or not a given result has passed.  Anything which is <b>not</b> a test result returns true.  This is merely provided as a convenient shortcut which allows you to do this:<div class="spacer">
</div>
<br/>
 my $parser = TAP::Parser-&gt;new( { source =&gt; $source } );<br/>
 while ( my $result = $parser-&gt;next ) {<br/>
     # only print failing results<br/>
     print $result-&gt;as_string unless $result-&gt;is_ok;<br/>
 }<br/>
</div>
<div class="subsection">
<h2>&quot;plan&quot; methods</h2><br/>
 if ( $result-&gt;is_plan ) { ... }<br/>
<div class="spacer">
</div>
If the above evaluates as true, the following methods will be available on the $result object.<div class="spacer">
</div>
<i></i><i>&quot;plan&quot;</i><i></i><div class="spacer">
</div>
<br/>
  if ( $result-&gt;is_plan ) {<br/>
     print $result-&gt;plan;<br/>
  }<br/>
<div class="spacer">
</div>
This is merely a synonym for &quot;as_string&quot;.<div class="spacer">
</div>
<i></i><i>&quot;directive&quot;</i><i></i><div class="spacer">
</div>
<br/>
 my $directive = $result-&gt;directive;<br/>
<div class="spacer">
</div>
If a SKIP directive is included with the plan, this method will return it.<div class="spacer">
</div>
<br/>
 1..0 # SKIP: why bother?<br/>
<div class="spacer">
</div>
<i></i><i>&quot;explanation&quot;</i><i></i><div class="spacer">
</div>
<br/>
 my $explanation = $result-&gt;explanation;<br/>
<div class="spacer">
</div>
If a SKIP directive was included with the plan, this method will return the explanation, if any.</div>
<div class="subsection">
<h2>&quot;pragma&quot; methods</h2><br/>
 if ( $result-&gt;is_pragma ) { ... }<br/>
<div class="spacer">
</div>
If the above evaluates as true, the following methods will be available on the $result object.<div class="spacer">
</div>
<i></i><i>&quot;pragmas&quot;</i><i></i><div class="spacer">
</div>
Returns a list of pragmas each of which is a + or - followed by the pragma name.</div>
<div class="subsection">
<h2>&quot;comment&quot; methods</h2><br/>
 if ( $result-&gt;is_comment ) { ... }<br/>
<div class="spacer">
</div>
If the above evaluates as true, the following methods will be available on the $result object.<div class="spacer">
</div>
<i></i><i>&quot;comment&quot;</i><i></i><div class="spacer">
</div>
<br/>
  if ( $result-&gt;is_comment ) {<br/>
      my $comment = $result-&gt;comment;<br/>
      print &quot;I have something to say:  $comment&quot;;<br/>
  }<br/>
</div>
<div class="subsection">
<h2>&quot;bailout&quot; methods</h2><br/>
 if ( $result-&gt;is_bailout ) { ... }<br/>
<div class="spacer">
</div>
If the above evaluates as true, the following methods will be available on the $result object.<div class="spacer">
</div>
<i></i><i>&quot;explanation&quot;</i><i></i><div class="spacer">
</div>
<br/>
  if ( $result-&gt;is_bailout ) {<br/>
      my $explanation = $result-&gt;explanation;<br/>
      print &quot;We bailed out because ($explanation)&quot;;<br/>
  }<br/>
<div class="spacer">
</div>
If, and only if, a token is a bailout token, you can get an &quot;explanation&quot; via this method.  The explanation is the text after the mystical &quot;Bail out!&quot; words which appear in the tap output.</div>
<div class="subsection">
<h2>&quot;unknown&quot; methods</h2><br/>
 if ( $result-&gt;is_unknown ) { ... }<br/>
<div class="spacer">
</div>
There are no unique methods for unknown results.</div>
<div class="subsection">
<h2>&quot;test&quot; methods</h2><br/>
 if ( $result-&gt;is_test ) { ... }<br/>
<div class="spacer">
</div>
If the above evaluates as true, the following methods will be available on the $result object.<div class="spacer">
</div>
<i></i><i>&quot;ok&quot;</i><i></i><div class="spacer">
</div>
<br/>
  my $ok = $result-&gt;ok;<br/>
<div class="spacer">
</div>
Returns the literal text of the &quot;ok&quot; or &quot;not ok&quot; status.<div class="spacer">
</div>
<i></i><i>&quot;number&quot;</i><i></i><div class="spacer">
</div>
<br/>
  my $test_number = $result-&gt;number;<br/>
<div class="spacer">
</div>
Returns the number of the test, even if the original TAP output did not supply that number.<div class="spacer">
</div>
<i></i><i>&quot;description&quot;</i><i></i><div class="spacer">
</div>
<br/>
  my $description = $result-&gt;description;<br/>
<div class="spacer">
</div>
Returns the description of the test, if any.  This is the portion after the test number but before the directive.<div class="spacer">
</div>
<i></i><i>&quot;directive&quot;</i><i></i><div class="spacer">
</div>
<br/>
  my $directive = $result-&gt;directive;<br/>
<div class="spacer">
</div>
Returns either &quot;TODO&quot; or &quot;SKIP&quot; if either directive was present for a test line.<div class="spacer">
</div>
<i></i><i>&quot;explanation&quot;</i><i></i><div class="spacer">
</div>
<br/>
  my $explanation = $result-&gt;explanation;<br/>
<div class="spacer">
</div>
If a test had either a &quot;TODO&quot; or &quot;SKIP&quot; directive, this method will return the accompanying explanation, if present.<div class="spacer">
</div>
<br/>
  not ok 17 - 'Pigs can fly' # TODO not enough acid<br/>
<div class="spacer">
</div>
For the above line, the explanation is <i>not enough acid</i>.<div class="spacer">
</div>
<i></i><i>&quot;is_ok&quot;</i><i></i><div class="spacer">
</div>
<br/>
  if ( $result-&gt;is_ok ) { ... }<br/>
<div class="spacer">
</div>
Returns a boolean value indicating whether or not the test passed.  Remember that for TODO tests, the test always passes.<div class="spacer">
</div>
<b>Note:</b>  this was formerly &quot;passed&quot;.  The latter method is deprecated and will issue a warning.<div class="spacer">
</div>
<i></i><i>&quot;is_actual_ok&quot;</i><i></i><div class="spacer">
</div>
<br/>
  if ( $result-&gt;is_actual_ok ) { ... }<br/>
<div class="spacer">
</div>
Returns a boolean value indicating whether or not the test passed, regardless of its TODO status.<div class="spacer">
</div>
<b>Note:</b>  this was formerly &quot;actual_passed&quot;.  The latter method is deprecated and will issue a warning.<div class="spacer">
</div>
<i></i><i>&quot;is_unplanned&quot;</i><i></i><div class="spacer">
</div>
<br/>
  if ( $test-&gt;is_unplanned ) { ... }<br/>
<div class="spacer">
</div>
If a test number is greater than the number of planned tests, this method will return true.  Unplanned tests will  <i>always</i> return false for &quot;is_ok&quot;, regardless of whether or not the test &quot;has_todo&quot; (see TAP::Parser::Result::Test for more information about this).<div class="spacer">
</div>
<i></i><i>&quot;has_skip&quot;</i><i></i><div class="spacer">
</div>
<br/>
  if ( $result-&gt;has_skip ) { ... }<br/>
<div class="spacer">
</div>
Returns a boolean value indicating whether or not this test had a SKIP directive.<div class="spacer">
</div>
<i></i><i>&quot;has_todo&quot;</i><i></i><div class="spacer">
</div>
<br/>
  if ( $result-&gt;has_todo ) { ... }<br/>
<div class="spacer">
</div>
Returns a boolean value indicating whether or not this test had a TODO directive.<div class="spacer">
</div>
Note that TODO tests <i>always</i> pass.  If you need to know whether or not they really passed, check the &quot;is_actual_ok&quot; method.<div class="spacer">
</div>
<i></i><i>&quot;in_todo&quot;</i><i></i><div class="spacer">
</div>
<br/>
  if ( $parser-&gt;in_todo ) { ... }<br/>
<div class="spacer">
</div>
True while the most recent result was a TODO. Becomes true before the TODO result is returned and stays true until just before the next non- TODO test is returned.</div>
</div>
<div class="section">
<h1>TOTAL RESULTS</h1> After parsing the TAP, there are many methods available to let you dig through the results and determine what is meaningful to you.<div class="subsection">
<h2>Individual Results</h2> These results refer to individual tests which are run.<div class="spacer">
</div>
<i></i><i>&quot;passed&quot;</i><i></i><div class="spacer">
</div>
<br/>
 my @passed = $parser-&gt;passed; # the test numbers which passed<br/>
 my $passed = $parser-&gt;passed; # the number of tests which passed<br/>
<div class="spacer">
</div>
This method lets you know which (or how many) tests passed.  If a test failed but had a TODO directive, it will be counted as a passed test.<div class="spacer">
</div>
<i></i><i>&quot;failed&quot;</i><i></i><div class="spacer">
</div>
<br/>
 my @failed = $parser-&gt;failed; # the test numbers which failed<br/>
 my $failed = $parser-&gt;failed; # the number of tests which failed<br/>
<div class="spacer">
</div>
This method lets you know which (or how many) tests failed.  If a test passed but had a TODO directive, it will  <b>NOT</b> be counted as a failed test.<div class="spacer">
</div>
<i></i><i>&quot;actual_passed&quot;</i><i></i><div class="spacer">
</div>
<br/>
 # the test numbers which actually passed<br/>
 my @actual_passed = $parser-&gt;actual_passed;<br/>
<br/>
 # the number of tests which actually passed<br/>
 my $actual_passed = $parser-&gt;actual_passed;<br/>
<div class="spacer">
</div>
This method lets you know which (or how many) tests actually passed, regardless of whether or not a TODO directive was found.<div class="spacer">
</div>
<i></i><i>&quot;actual_ok&quot;</i><i></i><div class="spacer">
</div>
This method is a synonym for &quot;actual_passed&quot;.<div class="spacer">
</div>
<i></i><i>&quot;actual_failed&quot;</i><i></i><div class="spacer">
</div>
<br/>
 # the test numbers which actually failed<br/>
 my @actual_failed = $parser-&gt;actual_failed;<br/>
<br/>
 # the number of tests which actually failed<br/>
 my $actual_failed = $parser-&gt;actual_failed;<br/>
<div class="spacer">
</div>
This method lets you know which (or how many) tests actually failed, regardless of whether or not a TODO directive was found.<div class="spacer">
</div>
<i></i><i>&quot;todo&quot;</i><i></i><div class="spacer">
</div>
<br/>
 my @todo = $parser-&gt;todo; # the test numbers with todo directives<br/>
 my $todo = $parser-&gt;todo; # the number of tests with todo directives<br/>
<div class="spacer">
</div>
This method lets you know which (or how many) tests had TODO directives.<div class="spacer">
</div>
<i></i><i>&quot;todo_passed&quot;</i><i></i><div class="spacer">
</div>
<br/>
 # the test numbers which unexpectedly succeeded<br/>
 my @todo_passed = $parser-&gt;todo_passed;<br/>
<br/>
 # the number of tests which unexpectedly succeeded<br/>
 my $todo_passed = $parser-&gt;todo_passed;<br/>
<div class="spacer">
</div>
This method lets you know which (or how many) tests actually passed but were declared as &quot;TODO&quot; tests.<div class="spacer">
</div>
<i></i><i>&quot;todo_failed&quot;</i><i></i><div class="spacer">
</div>
<br/>
  # deprecated in favor of 'todo_passed'.  This method was horribly misnamed.<br/>
<div class="spacer">
</div>
This was a badly misnamed method.  It indicates which TODO tests unexpectedly succeeded.  Will now issue a warning and call &quot;todo_passed&quot;.<div class="spacer">
</div>
<i></i><i>&quot;skipped&quot;</i><i></i><div class="spacer">
</div>
<br/>
 my @skipped = $parser-&gt;skipped; # the test numbers with SKIP directives<br/>
 my $skipped = $parser-&gt;skipped; # the number of tests with SKIP directives<br/>
<div class="spacer">
</div>
This method lets you know which (or how many) tests had SKIP directives.</div>
<div class="subsection">
<h2>Pragmas</h2>  <i></i><i>&quot;pragma&quot;</i><i></i><div class="spacer">
</div>
Get or set a pragma. To get the state of a pragma:<div class="spacer">
</div>
<br/>
  if ( $p-&gt;pragma('strict') ) {<br/>
      # be strict<br/>
  }<br/>
<div class="spacer">
</div>
To set the state of a pragma:<div class="spacer">
</div>
<br/>
  $p-&gt;pragma('strict', 1); # enable strict mode<br/>
<div class="spacer">
</div>
<i></i><i>&quot;pragmas&quot;</i><i></i><div class="spacer">
</div>
Get a list of all the currently enabled pragmas:<div class="spacer">
</div>
<br/>
  my @pragmas_enabled = $p-&gt;pragmas;<br/>
</div>
<div class="subsection">
<h2>Summary Results</h2> These results are &quot;meta&quot; information about the total results of an individual test program.<div class="spacer">
</div>
<i></i><i>&quot;plan&quot;</i><i></i><div class="spacer">
</div>
<br/>
 my $plan = $parser-&gt;plan;<br/>
<div class="spacer">
</div>
Returns the test plan, if found.<div class="spacer">
</div>
<i></i><i>&quot;good_plan&quot;</i><i></i><div class="spacer">
</div>
Deprecated.  Use &quot;is_good_plan&quot; instead.<div class="spacer">
</div>
<i></i><i>&quot;is_good_plan&quot;</i><i></i><div class="spacer">
</div>
<br/>
  if ( $parser-&gt;is_good_plan ) { ... }<br/>
<div class="spacer">
</div>
Returns a boolean value indicating whether or not the number of tests planned matches the number of tests run.<div class="spacer">
</div>
<b>Note:</b>  this was formerly &quot;good_plan&quot;.  The latter method is deprecated and will issue a warning.<div class="spacer">
</div>
And since we're on that subject ...<div class="spacer">
</div>
<i></i><i>&quot;tests_planned&quot;</i><i></i><div class="spacer">
</div>
<br/>
  print $parser-&gt;tests_planned;<br/>
<div class="spacer">
</div>
Returns the number of tests planned, according to the plan.  For example, a plan of '1..17' will mean that 17 tests were planned.<div class="spacer">
</div>
<i></i><i>&quot;tests_run&quot;</i><i></i><div class="spacer">
</div>
<br/>
  print $parser-&gt;tests_run;<br/>
<div class="spacer">
</div>
Returns the number of tests which actually were run.  Hopefully this will match the number of &quot;$parser-&gt;tests_planned&quot;.<div class="spacer">
</div>
<i></i><i>&quot;skip_all&quot;</i><i></i><div class="spacer">
</div>
Returns a true value (actually the reason for skipping) if all tests were skipped.<div class="spacer">
</div>
<i></i><i>&quot;start_time&quot;</i><i></i><div class="spacer">
</div>
Returns the time when the Parser was created.<div class="spacer">
</div>
<i></i><i>&quot;end_time&quot;</i><i></i><div class="spacer">
</div>
Returns the time when the end of TAP input was seen.<div class="spacer">
</div>
<i></i><i>&quot;has_problems&quot;</i><i></i><div class="spacer">
</div>
<br/>
  if ( $parser-&gt;has_problems ) {<br/>
      ...<br/>
  }<br/>
<div class="spacer">
</div>
This is a 'catch-all' method which returns true if any tests have currently failed, any TODO tests unexpectedly succeeded, or any parse errors occurred.<div class="spacer">
</div>
<i></i><i>&quot;version&quot;</i><i></i><div class="spacer">
</div>
<br/>
  $parser-&gt;version;<br/>
<div class="spacer">
</div>
Once the parser is done, this will return the version number for the parsed TAP. Version numbers were introduced with TAP version 13 so if no version number is found version 12 is assumed.<div class="spacer">
</div>
<i></i><i>&quot;exit&quot;</i><i></i><div class="spacer">
</div>
<br/>
  $parser-&gt;exit;<br/>
<div class="spacer">
</div>
Once the parser is done, this will return the exit status.  If the parser ran an executable, it returns the exit status of the executable.<div class="spacer">
</div>
<i></i><i>&quot;wait&quot;</i><i></i><div class="spacer">
</div>
<br/>
  $parser-&gt;wait;<br/>
<div class="spacer">
</div>
Once the parser is done, this will return the wait status.  If the parser ran an executable, it returns the wait status of the executable.  Otherwise, this merely returns the &quot;exit&quot; status.</div>
<div class="subsection">
<h2>&quot;ignore_exit&quot;</h2><br/>
  $parser-&gt;ignore_exit(1);<br/>
<div class="spacer">
</div>
Tell the parser to ignore the exit status from the test when determining whether the test passed. Normally tests with non-zero exit status are considered to have failed even if all individual tests passed. In cases where it is not possible to control the exit value of the test script use this option to ignore it.<div class="spacer">
</div>
<i></i><i>&quot;parse_errors&quot;</i><i></i><div class="spacer">
</div>
<br/>
 my @errors = $parser-&gt;parse_errors; # the parser errors<br/>
 my $errors = $parser-&gt;parse_errors; # the number of parser_errors<br/>
<div class="spacer">
</div>
Fortunately, all TAP output is perfect.  In the event that it is not, this method will return parser errors.  Note that a junk line which the parser does not recognize is &quot;not&quot; an error.  This allows this parser to handle future versions of TAP.  The following are all TAP errors reported by the parser:<dl>
<dt>
&#8226;</dt>
<dd>
Misplaced plan<div style="height: 1.00em;">
&#160;</div>
The plan (for example, '1..5'), must only come at the beginning or end of the TAP output.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
No plan<div style="height: 1.00em;">
&#160;</div>
Gotta have a plan!</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
More than one plan<div style="height: 1.00em;">
&#160;</div>
<br/>
 1..3<br/>
 ok 1 - input file opened<br/>
 not ok 2 - first line of the input valid # todo some data<br/>
 ok 3 read the rest of the file<br/>
 1..3<br/>
<div style="height: 1.00em;">
&#160;</div>
Right.  Very funny.  Don't do that.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Test numbers out of sequence<div style="height: 1.00em;">
&#160;</div>
<br/>
 1..3<br/>
 ok 1 - input file opened<br/>
 not ok 2 - first line of the input valid # todo some data<br/>
 ok 2 read the rest of the file<br/>
<div style="height: 1.00em;">
&#160;</div>
That last test line above should have the number '3' instead of '2'.<div style="height: 1.00em;">
&#160;</div>
Note that it's perfectly acceptable for some lines to have test numbers and others to not have them.  However, when a test number is found, it must be in sequence.  The following is also an error:<div style="height: 1.00em;">
&#160;</div>
<br/>
 1..3<br/>
 ok 1 - input file opened<br/>
 not ok - first line of the input valid # todo some data<br/>
 ok 2 read the rest of the file<br/>
<div style="height: 1.00em;">
&#160;</div>
But this is not:<div style="height: 1.00em;">
&#160;</div>
<br/>
 1..3<br/>
 ok  - input file opened<br/>
 not ok - first line of the input valid # todo some data<br/>
 ok 3 read the rest of the file<br/>
</dd>
</dl>
<div class="spacer">
</div>
<i></i><i>&quot;get_select_handles&quot;</i><i></i><div class="spacer">
</div>
Get an a list of file handles which can be passed to &quot;select&quot; to determine the readiness of this parser.<div class="spacer">
</div>
<i></i><i>&quot;delete_spool&quot;</i><i></i><div class="spacer">
</div>
Delete and return the spool.<div class="spacer">
</div>
<br/>
  my $fh = $parser-&gt;delete_spool;<br/>
</div>
</div>
<div class="section">
<h1>CALLBACKS</h1> As mentioned earlier, a &quot;callback&quot; key may be added to the &quot;TAP::Parser&quot; constructor. If present, each callback corresponding to a given result type will be called with the result as the argument if the &quot;run&quot; method is used. The callback is expected to be a subroutine reference (or anonymous subroutine) which is invoked with the parser result as its argument.<div class="spacer">
</div>
<br/>
 my %callbacks = (<br/>
     test    =&gt; \&amp;test_callback,<br/>
     plan    =&gt; \&amp;plan_callback,<br/>
     comment =&gt; \&amp;comment_callback,<br/>
     bailout =&gt; \&amp;bailout_callback,<br/>
     unknown =&gt; \&amp;unknown_callback,<br/>
 );<br/>
<br/>
 my $aggregator = TAP::Parser::Aggregator-&gt;new;<br/>
 for my $file ( @test_files ) {<br/>
     my $parser = TAP::Parser-&gt;new(<br/>
         {<br/>
             source    =&gt; $file,<br/>
             callbacks =&gt; \%callbacks,<br/>
         }<br/>
     );<br/>
     $parser-&gt;run;<br/>
     $aggregator-&gt;add( $file, $parser );<br/>
 }<br/>
<div class="spacer">
</div>
Callbacks may also be added like this:<div class="spacer">
</div>
<br/>
 $parser-&gt;callback( test =&gt; \&amp;test_callback );<br/>
 $parser-&gt;callback( plan =&gt; \&amp;plan_callback );<br/>
<div class="spacer">
</div>
The following keys allowed for callbacks. These keys are case-sensitive.<dl>
<dt>
&#8226;</dt>
<dd>
&quot;test&quot;<div style="height: 1.00em;">
&#160;</div>
Invoked if &quot;$result-&gt;is_test&quot; returns true.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;version&quot;<div style="height: 1.00em;">
&#160;</div>
Invoked if &quot;$result-&gt;is_version&quot; returns true.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;plan&quot;<div style="height: 1.00em;">
&#160;</div>
Invoked if &quot;$result-&gt;is_plan&quot; returns true.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;comment&quot;<div style="height: 1.00em;">
&#160;</div>
Invoked if &quot;$result-&gt;is_comment&quot; returns true.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;bailout&quot;<div style="height: 1.00em;">
&#160;</div>
Invoked if &quot;$result-&gt;is_unknown&quot; returns true.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;yaml&quot;<div style="height: 1.00em;">
&#160;</div>
Invoked if &quot;$result-&gt;is_yaml&quot; returns true.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;unknown&quot;<div style="height: 1.00em;">
&#160;</div>
Invoked if &quot;$result-&gt;is_unknown&quot; returns true.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;ELSE&quot;<div style="height: 1.00em;">
&#160;</div>
If a result does not have a callback defined for it, this callback will be invoked. Thus, if all of the previous result types are specified as callbacks, this callback will  <i>never</i> be invoked.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;ALL&quot;<div style="height: 1.00em;">
&#160;</div>
This callback will always be invoked and this will happen for each result after one of the above callbacks is invoked.  For example, if Term::ANSIColor is loaded, you could use the following to color your test output:<div style="height: 1.00em;">
&#160;</div>
<br/>
 my %callbacks = (<br/>
     test =&gt; sub {<br/>
         my $test = shift;<br/>
         if ( $test-&gt;is_ok &amp;&amp; not $test-&gt;directive ) {<br/>
             # normal passing test<br/>
             print color 'green';<br/>
         }<br/>
         elsif ( !$test-&gt;is_ok ) {    # even if it's TODO<br/>
             print color 'white on_red';<br/>
         }<br/>
         elsif ( $test-&gt;has_skip ) {<br/>
             print color 'white on_blue';<br/>
<br/>
         }<br/>
         elsif ( $test-&gt;has_todo ) {<br/>
             print color 'white';<br/>
         }<br/>
     },<br/>
     ELSE =&gt; sub {<br/>
         # plan, comment, and so on (anything which isn't a test line)<br/>
         print color 'black on_white';<br/>
     },<br/>
     ALL =&gt; sub {<br/>
         # now print them<br/>
         print shift-&gt;as_string;<br/>
         print color 'reset';<br/>
         print &quot;\n&quot;;<br/>
     },<br/>
 );<br/>
</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;EOF&quot;<div style="height: 1.00em;">
&#160;</div>
Invoked when there are no more lines to be parsed. Since there is no accompanying TAP::Parser::Result object the &quot;TAP::Parser&quot; object is passed instead.</dd>
</dl>
</div>
<div class="section">
<h1>TAP GRAMMAR</h1> If you're looking for an EBNF grammar, see TAP::Parser::Grammar.</div>
<div class="section">
<h1>BACKWARDS COMPATIBILITY</h1> The Perl-QA list attempted to ensure backwards compatibility with Test::Harness.  However, there are some minor differences.<div class="subsection">
<h2>Differences</h2><dl>
<dt>
&#8226;</dt>
<dd>
TODO plans<div style="height: 1.00em;">
&#160;</div>
A little-known feature of Test::Harness is that it supported TODO lists in the plan:<div style="height: 1.00em;">
&#160;</div>
<br/>
 1..2 todo 2<br/>
 ok 1 - We have liftoff<br/>
 not ok 2 - Anti-gravity device activated<br/>
<div style="height: 1.00em;">
&#160;</div>
Under Test::Harness, test number 2 would <i>pass</i> because it was listed as a TODO test on the plan line. However, we are not aware of anyone actually using this feature and hard-coding test numbers is discouraged because it's very easy to add a test and break the test number sequence. This makes test suites very fragile. Instead, the following should be used:<div style="height: 1.00em;">
&#160;</div>
<br/>
 1..2<br/>
 ok 1 - We have liftoff<br/>
 not ok 2 - Anti-gravity device activated # TODO<br/>
</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
'Missing' tests<div style="height: 1.00em;">
&#160;</div>
It rarely happens, but sometimes a harness might encounter 'missing tests:<div style="height: 1.00em;">
&#160;</div>
<br/>
 ok 1<br/>
 ok 2<br/>
 ok 15<br/>
 ok 16<br/>
 ok 17<br/>
<div style="height: 1.00em;">
&#160;</div>
Test::Harness would report tests 3-14 as having failed. For the &quot;TAP::Parser&quot;, these tests are not considered failed because they've never run. They're reported as parse failures (tests out of sequence).</dd>
</dl>
</div>
</div>
<div class="section">
<h1>SUBCLASSING</h1> If you find you need to provide custom functionality (as you would have using Test::Harness::Straps), you're in luck: &quot;TAP::Parser&quot; and friends are designed to be easily plugged-into and/or subclassed.<div class="spacer">
</div>
Before you start, it's important to know a few things:<dl>
<dt>
1.</dt>
<dd>
All &quot;TAP::*&quot; objects inherit from TAP::Object.</dd>
</dl>
<dl>
<dt>
2.</dt>
<dd>
Many &quot;TAP::*&quot; classes have a <i>SUBCLASSING</i> section to guide you.</dd>
</dl>
<dl>
<dt>
3.</dt>
<dd>
Note that &quot;TAP::Parser&quot; is designed to be the central &quot;maker&quot; - ie: it is responsible for creating most new objects in the &quot;TAP::Parser::*&quot; namespace.<div style="height: 1.00em;">
&#160;</div>
This makes it possible for you to have a single point of configuring what subclasses should be used, which means that in many cases you'll find you only need to sub-class one of the parser's components.<div style="height: 1.00em;">
&#160;</div>
The exception to this rule are <i>SourceHandlers</i> &amp; <i>Iterators</i>, but those are both created with customizable  <i>IteratorFactory</i>.</dd>
</dl>
<dl>
<dt>
4.</dt>
<dd>
By subclassing, you may end up overriding undocumented methods.  That's not a bad thing per se, but be forewarned that undocumented methods may change without warning from one release to the next - we cannot guarantee backwards compatibility.  If any  <i>documented</i> method needs changing, it will be deprecated first, and changed in a later release.</dd>
</dl>
<div class="subsection">
<h2>Parser Components</h2>  <i>Sources</i><div class="spacer">
</div>
A TAP parser consumes input from a single <i>raw source</i> of TAP, which could come from anywhere (a file, an executable, a database, an IO handle, a URI, etc..). The source gets bundled up in a TAP::Parser::Source object which gathers some meta data about it.  The parser then uses a TAP::Parser::IteratorFactory to determine which TAP::Parser::SourceHandler to use to turn the raw source into a stream of TAP by way of &quot;Iterators&quot;.<div class="spacer">
</div>
If you simply want &quot;TAP::Parser&quot; to handle a new source of TAP you probably don't need to subclass &quot;TAP::Parser&quot; itself.  Rather, you'll need to create a new TAP::Parser::SourceHandler class, and just plug it into the parser using the  <i>sources</i> param to &quot;new&quot;.  Before you start writing one, read through TAP::Parser::IteratorFactory to get a feel for how the system works first.<div class="spacer">
</div>
If you find you really need to use your own iterator factory you can still do so without sub-classing &quot;TAP::Parser&quot; by setting &quot;iterator_factory_class&quot;.<div class="spacer">
</div>
If you just need to customize the objects on creation, subclass TAP::Parser and override &quot;make_iterator_factory&quot;.<div class="spacer">
</div>
Note that &quot;make_source&quot; &amp; &quot;make_perl_source&quot; have been <i>DEPRECATED</i> and are now removed.<div class="spacer">
</div>
<i>Iterators</i><div class="spacer">
</div>
A TAP parser uses <i>iterators</i> to loop through the <i>stream</i> of TAP read in from the  <i>source</i> it was given.  There are a few types of Iterators available by default, all sub-classes of TAP::Parser::Iterator.  Choosing which iterator to use is the responsibility of the  <i>iterator factory</i>, though it simply delegates to the  <i>Source Handler</i> it uses.<div class="spacer">
</div>
If you're writing your own TAP::Parser::SourceHandler, you may need to create your own iterators too.  If so you'll need to subclass TAP::Parser::Iterator.<div class="spacer">
</div>
Note that &quot;make_iterator&quot; has been <i>DEPRECATED</i> and is now removed.<div class="spacer">
</div>
<i>Results</i><div class="spacer">
</div>
A TAP parser creates TAP::Parser::Results as it iterates through the input  <i>stream</i>.  There are quite a few result types available; choosing which class to use is the responsibility of the  <i>result factory</i>.<div class="spacer">
</div>
To create your own result types you have two options:<dl>
<dt>
option 1</dt>
<dd>
Subclass TAP::Parser::Result and register your new result type/class with the default TAP::Parser::ResultFactory.</dd>
</dl>
<dl>
<dt>
option 2</dt>
<dd>
Subclass TAP::Parser::ResultFactory itself and implement your own TAP::Parser::Result creation logic.  Then you'll need to customize the class used by your parser by setting the &quot;result_factory_class&quot; parameter. See &quot;new&quot; for more details.</dd>
</dl>
<div class="spacer">
</div>
If you need to customize the objects on creation, subclass TAP::Parser and override &quot;make_result&quot;.<div class="spacer">
</div>
<i>Grammar</i><div class="spacer">
</div>
TAP::Parser::Grammar is the heart of the parser.  It tokenizes the TAP input  <i>stream</i> and produces results.  If you need to customize its behaviour you should probably familiarize yourself with the source first.  Enough lecturing.<div class="spacer">
</div>
Subclass TAP::Parser::Grammar and customize your parser by setting the &quot;grammar_class&quot; parameter.  See &quot;new&quot; for more details.<div class="spacer">
</div>
If you need to customize the objects on creation, subclass TAP::Parser and override &quot;make_grammar&quot;</div>
</div>
<div class="section">
<h1>ACKNOWLEDGMENTS</h1> All of the following have helped. Bug reports, patches, (im)moral support, or just words of encouragement have all been forthcoming.<dl>
<dt>
&#8226;</dt>
<dd>
Michael Schwern</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Andy Lester</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
chromatic</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
GEOFFR</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Shlomi Fish</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Torsten Schoenfeld</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Jerry Gay</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Aristotle</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Adam Kennedy</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Yves Orton</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Adrian Howard</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Sean &amp; Lil</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Andreas J. Koenig</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Florian Ragwitz</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Corion</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Mark Stosberg</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Matt Kraai</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
David Wheeler</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Alex Vandiver</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Cosimo Streppone</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Ville SkyttA~X</dd>
</dl>
</div>
<div class="section">
<h1>AUTHORS</h1> Curtis &quot;Ovid&quot; Poe &lt;ovid@cpan.org&gt;<div class="spacer">
</div>
Andy Armstong &lt;andy@hexten.net&gt;<div class="spacer">
</div>
Eric Wilhelm @ &lt;ewilhelm at cpan dot org&gt;<div class="spacer">
</div>
Michael Peters &lt;mpeters at plusthree dot com&gt;<div class="spacer">
</div>
Leif Eriksen &lt;leif dot eriksen at bigpond dot com&gt;<div class="spacer">
</div>
Steve Purkis &lt;spurkis@cpan.org&gt;<div class="spacer">
</div>
Nicholas Clark &lt;nick@ccl4.org&gt;<div class="spacer">
</div>
Lee Johnson &lt;notfadeaway at btinternet dot com&gt;<div class="spacer">
</div>
Philippe Bruhat &lt;book@cpan.org&gt;</div>
<div class="section">
<h1>BUGS</h1> Please report any bugs or feature requests to &quot;bug-test-harness@rt.cpan.org&quot;, or through the web interface at http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness &lt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Harness&gt;. We will be notified, and then you'll automatically be notified of progress on your bug as we make changes.<div class="spacer">
</div>
Obviously, bugs which include patches are best. If you prefer, you can patch against bleed by via anonymous checkout of the latest version:<div class="spacer">
</div>
<br/>
 git clone git://github.com/AndyA/Test-Harness.git<br/>
</div>
<div class="section">
<h1>COPYRIGHT &amp; LICENSE</h1> Copyright 2006-2008 Curtis &quot;Ovid&quot; Poe, all rights reserved.<div class="spacer">
</div>
This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-09-19</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

