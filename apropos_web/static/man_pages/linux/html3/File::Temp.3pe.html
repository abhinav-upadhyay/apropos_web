<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
File::Temp(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
File::Temp(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
File::Temp(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> File::Temp - return name and handle of a temporary file safely</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
  use File::Temp qw/ tempfile tempdir /;<br/>
<br/>
  $fh = tempfile();<br/>
  ($fh, $filename) = tempfile();<br/>
<br/>
  ($fh, $filename) = tempfile( $template, DIR =&gt; $dir);<br/>
  ($fh, $filename) = tempfile( $template, SUFFIX =&gt; '.dat');<br/>
  ($fh, $filename) = tempfile( $template, TMPDIR =&gt; 1 );<br/>
<br/>
  binmode( $fh, &quot;:utf8&quot; );<br/>
<br/>
  $dir = tempdir( CLEANUP =&gt; 1 );<br/>
  ($fh, $filename) = tempfile( DIR =&gt; $dir );<br/>
<div class="spacer">
</div>
Object interface:<div class="spacer">
</div>
<br/>
  require File::Temp;<br/>
  use File::Temp ();<br/>
  use File::Temp qw/ :seekable /;<br/>
<br/>
  $fh = File::Temp-&gt;new();<br/>
  $fname = $fh-&gt;filename;<br/>
<br/>
  $fh = File::Temp-&gt;new(TEMPLATE =&gt; $template);<br/>
  $fname = $fh-&gt;filename;<br/>
<br/>
  $tmp = File::Temp-&gt;new( UNLINK =&gt; 0, SUFFIX =&gt; '.dat' );<br/>
  print $tmp &quot;Some data\n&quot;;<br/>
  print &quot;Filename is $tmp\n&quot;;<br/>
  $tmp-&gt;seek( 0, SEEK_END );<br/>
<div class="spacer">
</div>
The following interfaces are provided for compatibility with existing APIs. They should not be used in new code.<div class="spacer">
</div>
MkTemp family:<div class="spacer">
</div>
<br/>
  use File::Temp qw/ :mktemp  /;<br/>
<br/>
  ($fh, $file) = mkstemp( &quot;tmpfileXXXXX&quot; );<br/>
  ($fh, $file) = mkstemps( &quot;tmpfileXXXXXX&quot;, $suffix);<br/>
<br/>
  $tmpdir = mkdtemp( $template );<br/>
<br/>
  $unopened_file = mktemp( $template );<br/>
<div class="spacer">
</div>
POSIX functions:<div class="spacer">
</div>
<br/>
  use File::Temp qw/ :POSIX /;<br/>
<br/>
  $file = tmpnam();<br/>
  $fh = tmpfile();<br/>
<br/>
  ($fh, $file) = tmpnam();<br/>
<div class="spacer">
</div>
Compatibility functions:<div class="spacer">
</div>
<br/>
  $unopened_file = File::Temp::tempnam( $dir, $pfx );<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> &quot;File::Temp&quot; can be used to create and open temporary files in a safe way.  There is both a function interface and an object-oriented interface.  The File::Temp constructor or the  <i>tempfile()</i> function can be used to return the name and the open filehandle of a temporary file.  The  <i>tempdir()</i> function can be used to create a temporary directory.<div class="spacer">
</div>
The security aspect of temporary file creation is emphasized such that a filehandle and filename are returned together.  This helps guarantee that a race condition can not occur where the temporary file is created by another process between checking for the existence of the file and its opening.  Additional security levels are provided to check, for example, that the sticky bit is set on world writable directories.  See &quot;safe_level&quot; for more information.<div class="spacer">
</div>
For compatibility with popular C library functions, Perl implementations of the  <i>mkstemp()</i> family of functions are provided. These are, <i>mkstemp()</i>,  <i>mkstemps()</i>, <i>mkdtemp()</i> and <i>mktemp()</i>.<div class="spacer">
</div>
Additionally, implementations of the standard POSIX  <i>tmpnam()</i> and <i>tmpfile()</i> functions are provided if required.<div class="spacer">
</div>
Implementations of <i>mktemp()</i>, <i>tmpnam()</i>, and <i>tempnam()</i> are provided, but should be used with caution since they return only a filename that was valid when function was called, so cannot guarantee that the file will not exist by the time the caller opens the filename.<div class="spacer">
</div>
Filehandles returned by these functions support the seekable methods.</div>
<div class="section">
<h1>OBJECT-ORIENTED INTERFACE</h1> This is the primary interface for interacting with &quot;File::Temp&quot;. Using the OO interface a temporary file can be created when the object is constructed and the file can be removed when the object is no longer required.<div class="spacer">
</div>
Note that there is no method to obtain the filehandle from the &quot;File::Temp&quot; object. The object itself acts as a filehandle. Also, the object is configured such that it stringifies to the name of the temporary file, and can be compared to a filename directly. The object isa &quot;IO::Handle&quot; and isa &quot;IO::Seekable&quot; so all those methods are available.<dl>
<dt>
<b>new</b></dt>
<dd>
Create a temporary file object.<div style="height: 1.00em;">
&#160;</div>
<br/>
  my $tmp = File::Temp-&gt;new();<br/>
<div style="height: 1.00em;">
&#160;</div>
by default the object is constructed as if &quot;tempfile&quot; was called without options, but with the additional behaviour that the temporary file is removed by the object destructor if UNLINK is set to true (the default).<div style="height: 1.00em;">
&#160;</div>
Supported arguments are the same as for &quot;tempfile&quot;: UNLINK (defaulting to true), DIR, EXLOCK and SUFFIX. Additionally, the filename template is specified using the TEMPLATE option. The OPEN option is not supported (the file is always opened).<div style="height: 1.00em;">
&#160;</div>
<br/>
 $tmp = File::Temp-&gt;new( TEMPLATE =&gt; 'tempXXXXX',<br/>
                        DIR =&gt; 'mydir',<br/>
                        SUFFIX =&gt; '.dat');<br/>
<div style="height: 1.00em;">
&#160;</div>
Arguments are case insensitive.<div style="height: 1.00em;">
&#160;</div>
Can call <i>croak()</i> if an error occurs.</dd>
</dl>
<dl>
<dt>
<b>newdir</b></dt>
<dd>
Create a temporary directory using an object oriented interface.<div style="height: 1.00em;">
&#160;</div>
<br/>
  $dir = File::Temp-&gt;newdir();<br/>
<div style="height: 1.00em;">
&#160;</div>
By default the directory is deleted when the object goes out of scope.<div style="height: 1.00em;">
&#160;</div>
Supports the same options as the &quot;tempdir&quot; function. Note that directories created with this method default to CLEANUP =&gt; 1.<div style="height: 1.00em;">
&#160;</div>
<br/>
  $dir = File::Temp-&gt;newdir( $template, %options );<br/>
</dd>
</dl>
<dl>
<dt>
<b>filename</b></dt>
<dd>
Return the name of the temporary file associated with this object (if the object was created using the &quot;new&quot; constructor).<div style="height: 1.00em;">
&#160;</div>
<br/>
  $filename = $tmp-&gt;filename;<br/>
<div style="height: 1.00em;">
&#160;</div>
This method is called automatically when the object is used as a string.</dd>
</dl>
<dl>
<dt>
<b>dirname</b></dt>
<dd>
Return the name of the temporary directory associated with this object (if the object was created using the &quot;newdir&quot; constructor).<div style="height: 1.00em;">
&#160;</div>
<br/>
  $dirname = $tmpdir-&gt;dirname;<br/>
<div style="height: 1.00em;">
&#160;</div>
This method is called automatically when the object is used in string context.</dd>
</dl>
<dl>
<dt>
<b>unlink_on_destroy</b></dt>
<dd>
Control whether the file is unlinked when the object goes out of scope. The file is removed if this value is true and $KEEP_ALL is not.<div style="height: 1.00em;">
&#160;</div>
<br/>
 $fh-&gt;unlink_on_destroy( 1 );<br/>
<div style="height: 1.00em;">
&#160;</div>
Default is for the file to be removed.</dd>
</dl>
<dl>
<dt>
<b>DESTROY</b></dt>
<dd>
When the object goes out of scope, the destructor is called. This destructor will attempt to unlink the file (using &quot;unlink1&quot;) if the constructor was called with UNLINK set to 1 (the default state if UNLINK is not specified).<div style="height: 1.00em;">
&#160;</div>
No error is given if the unlink fails.<div style="height: 1.00em;">
&#160;</div>
If the object has been passed to a child process during a fork, the file will be deleted when the object goes out of scope in the parent.<div style="height: 1.00em;">
&#160;</div>
For a temporary directory object the directory will be removed unless the CLEANUP argument was used in the constructor (and set to false) or &quot;unlink_on_destroy&quot; was modified after creation.<div style="height: 1.00em;">
&#160;</div>
If the global variable $KEEP_ALL is true, the file or directory will not be removed.</dd>
</dl>
</div>
<div class="section">
<h1>FUNCTIONS</h1> This section describes the recommended interface for generating temporary files and directories.<dl>
<dt>
<b>tempfile</b></dt>
<dd>
This is the basic function to generate temporary files. The behaviour of the file can be changed using various options:<div style="height: 1.00em;">
&#160;</div>
<br/>
  $fh = tempfile();<br/>
  ($fh, $filename) = tempfile();<br/>
<div style="height: 1.00em;">
&#160;</div>
Create a temporary file in  the directory specified for temporary files, as specified by the  <i>tmpdir()</i> function in File::Spec.<div style="height: 1.00em;">
&#160;</div>
<br/>
  ($fh, $filename) = tempfile($template);<br/>
<div style="height: 1.00em;">
&#160;</div>
Create a temporary file in the current directory using the supplied template.  Trailing `X' characters are replaced with random letters to generate the filename.  At least four `X' characters must be present at the end of the template.<div style="height: 1.00em;">
&#160;</div>
<br/>
  ($fh, $filename) = tempfile($template, SUFFIX =&gt; $suffix)<br/>
<div style="height: 1.00em;">
&#160;</div>
Same as previously, except that a suffix is added to the template after the `X' translation.  Useful for ensuring that a temporary filename has a particular extension when needed by other applications. But see the WARNING at the end.<div style="height: 1.00em;">
&#160;</div>
<br/>
  ($fh, $filename) = tempfile($template, DIR =&gt; $dir);<br/>
<div style="height: 1.00em;">
&#160;</div>
Translates the template as before except that a directory name is specified.<div style="height: 1.00em;">
&#160;</div>
<br/>
  ($fh, $filename) = tempfile($template, TMPDIR =&gt; 1);<br/>
<div style="height: 1.00em;">
&#160;</div>
Equivalent to specifying a DIR of &quot;File::Spec-&gt;tmpdir&quot;, writing the file into the same temporary directory as would be used if no template was specified at all.<div style="height: 1.00em;">
&#160;</div>
<br/>
  ($fh, $filename) = tempfile($template, UNLINK =&gt; 1);<br/>
<div style="height: 1.00em;">
&#160;</div>
Return the filename and filehandle as before except that the file is automatically removed when the program exits (dependent on $KEEP_ALL). Default is for the file to be removed if a file handle is requested and to be kept if the filename is requested. In a scalar context (where no filename is returned) the file is always deleted either (depending on the operating system) on exit or when it is closed (unless $KEEP_ALL is true when the temp file is created).<div style="height: 1.00em;">
&#160;</div>
Use the object-oriented interface if fine-grained control of when a file is removed is required.<div style="height: 1.00em;">
&#160;</div>
If the template is not specified, a template is always automatically generated. This temporary file is placed in  <i>tmpdir()</i> (File::Spec) unless a directory is specified explicitly with the DIR option.<div style="height: 1.00em;">
&#160;</div>
<br/>
  $fh = tempfile( DIR =&gt; $dir );<br/>
<div style="height: 1.00em;">
&#160;</div>
If called in scalar context, only the filehandle is returned and the file will automatically be deleted when closed on operating systems that support this (see the description of  <i>tmpfile()</i> elsewhere in this document).  This is the preferred mode of operation, as if you only have a filehandle, you can never create a race condition by fumbling with the filename. On systems that can not unlink an open file or can not mark a file as temporary when it is opened (for example, Windows NT uses the &quot;O_TEMPORARY&quot; flag) the file is marked for deletion when the program ends (equivalent to setting UNLINK to 1). The &quot;UNLINK&quot; flag is ignored if present.<div style="height: 1.00em;">
&#160;</div>
<br/>
  (undef, $filename) = tempfile($template, OPEN =&gt; 0);<br/>
<div style="height: 1.00em;">
&#160;</div>
This will return the filename based on the template but will not open this file.  Cannot be used in conjunction with UNLINK set to true. Default is to always open the file to protect from possible race conditions. A warning is issued if warnings are turned on. Consider using the  <i>tmpnam()</i> and  <i>mktemp()</i> functions described elsewhere in this document if opening the file is not required.<div style="height: 1.00em;">
&#160;</div>
If the operating system supports it (for example BSD derived systems), the filehandle will be opened with O_EXLOCK (open with exclusive file lock). This can sometimes cause problems if the intention is to pass the filename to another system that expects to take an exclusive lock itself (such as DBD::SQLite) whilst ensuring that the tempfile is not reused. In this situation the &quot;EXLOCK&quot; option can be passed to tempfile. By default EXLOCK will be true (this retains compatibility with earlier releases).<div style="height: 1.00em;">
&#160;</div>
<br/>
  ($fh, $filename) = tempfile($template, EXLOCK =&gt; 0);<br/>
<div style="height: 1.00em;">
&#160;</div>
Options can be combined as required.<div style="height: 1.00em;">
&#160;</div>
Will <i>croak()</i> if there is an error.</dd>
</dl>
<dl>
<dt>
<b>tempdir</b></dt>
<dd>
This is the recommended interface for creation of temporary directories.  By default the directory will not be removed on exit (that is, it won't be temporary; this behaviour can not be changed because of issues with backwards compatibility). To enable removal either use the CLEANUP option which will trigger removal on program exit, or consider using the &quot;newdir&quot; method in the object interface which will allow the directory to be cleaned up when the object goes out of scope.<div style="height: 1.00em;">
&#160;</div>
The behaviour of the function depends on the arguments:<div style="height: 1.00em;">
&#160;</div>
<br/>
  $tempdir = tempdir();<br/>
<div style="height: 1.00em;">
&#160;</div>
Create a directory in <i>tmpdir()</i> (see File::Spec).<div style="height: 1.00em;">
&#160;</div>
<br/>
  $tempdir = tempdir( $template );<br/>
<div style="height: 1.00em;">
&#160;</div>
Create a directory from the supplied template. This template is similar to that described for  <i>tempfile()</i>. `X' characters at the end of the template are replaced with random letters to construct the directory name. At least four `X' characters must be in the template.<div style="height: 1.00em;">
&#160;</div>
<br/>
  $tempdir = tempdir ( DIR =&gt; $dir );<br/>
<div style="height: 1.00em;">
&#160;</div>
Specifies the directory to use for the temporary directory. The temporary directory name is derived from an internal template.<div style="height: 1.00em;">
&#160;</div>
<br/>
  $tempdir = tempdir ( $template, DIR =&gt; $dir );<br/>
<div style="height: 1.00em;">
&#160;</div>
Prepend the supplied directory name to the template. The template should not include parent directory specifications itself. Any parent directory specifications are removed from the template before prepending the supplied directory.<div style="height: 1.00em;">
&#160;</div>
<br/>
  $tempdir = tempdir ( $template, TMPDIR =&gt; 1 );<br/>
<div style="height: 1.00em;">
&#160;</div>
Using the supplied template, create the temporary directory in a standard location for temporary files. Equivalent to doing<div style="height: 1.00em;">
&#160;</div>
<br/>
  $tempdir = tempdir ( $template, DIR =&gt; File::Spec-&gt;tmpdir);<br/>
<div style="height: 1.00em;">
&#160;</div>
but shorter. Parent directory specifications are stripped from the template itself. The &quot;TMPDIR&quot; option is ignored if &quot;DIR&quot; is set explicitly.  Additionally, &quot;TMPDIR&quot; is implied if neither a template nor a directory are supplied.<div style="height: 1.00em;">
&#160;</div>
<br/>
  $tempdir = tempdir( $template, CLEANUP =&gt; 1);<br/>
<div style="height: 1.00em;">
&#160;</div>
Create a temporary directory using the supplied template, but attempt to remove it (and all files inside it) when the program exits. Note that an attempt will be made to remove all files from the directory even if they were not created by this module (otherwise why ask to clean it up?). The directory removal is made with the  <i>rmtree()</i> function from the File::Path module. Of course, if the template is not specified, the temporary directory will be created in  <i>tmpdir()</i> and will also be removed at program exit.<div style="height: 1.00em;">
&#160;</div>
Will <i>croak()</i> if there is an error.</dd>
</dl>
</div>
<div class="section">
<h1>MKTEMP FUNCTIONS</h1> The following functions are Perl implementations of the  <i>mktemp()</i> family of temp file generation system calls.<dl>
<dt>
<b>mkstemp</b></dt>
<dd>
Given a template, returns a filehandle to the temporary file and the name of the file.<div style="height: 1.00em;">
&#160;</div>
<br/>
  ($fh, $name) = mkstemp( $template );<br/>
<div style="height: 1.00em;">
&#160;</div>
In scalar context, just the filehandle is returned.<div style="height: 1.00em;">
&#160;</div>
The template may be any filename with some number of X's appended to it, for example  <i>/tmp/temp.XXXX</i>. The trailing X's are replaced with unique alphanumeric combinations.<div style="height: 1.00em;">
&#160;</div>
Will <i>croak()</i> if there is an error.</dd>
</dl>
<dl>
<dt>
<b>mkstemps</b></dt>
<dd>
Similar to <i>mkstemp()</i>, except that an extra argument can be supplied with a suffix to be appended to the template.<div style="height: 1.00em;">
&#160;</div>
<br/>
  ($fh, $name) = mkstemps( $template, $suffix );<br/>
<div style="height: 1.00em;">
&#160;</div>
For example a template of &quot;testXXXXXX&quot; and suffix of &quot;.dat&quot; would generate a file similar to  <i>testhGji_w.dat</i>.<div style="height: 1.00em;">
&#160;</div>
Returns just the filehandle alone when called in scalar context.<div style="height: 1.00em;">
&#160;</div>
Will <i>croak()</i> if there is an error.</dd>
</dl>
<dl>
<dt>
<b>mkdtemp</b></dt>
<dd>
Create a directory from a template. The template must end in X's that are replaced by the routine.<div style="height: 1.00em;">
&#160;</div>
<br/>
  $tmpdir_name = mkdtemp($template);<br/>
<div style="height: 1.00em;">
&#160;</div>
Returns the name of the temporary directory created.<div style="height: 1.00em;">
&#160;</div>
Directory must be removed by the caller.<div style="height: 1.00em;">
&#160;</div>
Will <i>croak()</i> if there is an error.</dd>
</dl>
<dl>
<dt>
<b>mktemp</b></dt>
<dd>
Returns a valid temporary filename but does not guarantee that the file will not be opened by someone else.<div style="height: 1.00em;">
&#160;</div>
<br/>
  $unopened_file = mktemp($template);<br/>
<div style="height: 1.00em;">
&#160;</div>
Template is the same as that required by <i>mkstemp()</i>.<div style="height: 1.00em;">
&#160;</div>
Will <i>croak()</i> if there is an error.</dd>
</dl>
</div>
<div class="section">
<h1>POSIX FUNCTIONS</h1> This section describes the re-implementation of the  <i>tmpnam()</i> and  <i>tmpfile()</i> functions described in POSIX using the  <i>mkstemp()</i> from this module.<div class="spacer">
</div>
Unlike the POSIX implementations, the directory used for the temporary file is not specified in a system include file (&quot;P_tmpdir&quot;) but simply depends on the choice of  <i>tmpdir()</i> returned by File::Spec. On some implementations this location can be set using the &quot;TMPDIR&quot; environment variable, which may not be secure. If this is a problem, simply use  <i>mkstemp()</i> and specify a template.<dl>
<dt>
<b>tmpnam</b></dt>
<dd>
When called in scalar context, returns the full name (including path) of a temporary file (uses  <i>mktemp()</i>). The only check is that the file does not already exist, but there is no guarantee that that condition will continue to apply.<div style="height: 1.00em;">
&#160;</div>
<br/>
  $file = tmpnam();<br/>
<div style="height: 1.00em;">
&#160;</div>
When called in list context, a filehandle to the open file and a filename are returned. This is achieved by calling  <i>mkstemp()</i> after constructing a suitable template.<div style="height: 1.00em;">
&#160;</div>
<br/>
  ($fh, $file) = tmpnam();<br/>
<div style="height: 1.00em;">
&#160;</div>
If possible, this form should be used to prevent possible race conditions.<div style="height: 1.00em;">
&#160;</div>
See &quot;tmpdir&quot; in File::Spec for information on the choice of temporary directory for a particular operating system.<div style="height: 1.00em;">
&#160;</div>
Will <i>croak()</i> if there is an error.</dd>
</dl>
<dl>
<dt>
<b>tmpfile</b></dt>
<dd>
Returns the filehandle of a temporary file.<div style="height: 1.00em;">
&#160;</div>
<br/>
  $fh = tmpfile();<br/>
<div style="height: 1.00em;">
&#160;</div>
The file is removed when the filehandle is closed or when the program exits. No access to the filename is provided.<div style="height: 1.00em;">
&#160;</div>
If the temporary file can not be created undef is returned. Currently this command will probably not work when the temporary directory is on an NFS file system.<div style="height: 1.00em;">
&#160;</div>
Will <i>croak()</i> if there is an error.</dd>
</dl>
</div>
<div class="section">
<h1>ADDITIONAL FUNCTIONS</h1> These functions are provided for backwards compatibility with common tempfile generation C library functions.<div class="spacer">
</div>
They are not exported and must be addressed using the full package name.<dl>
<dt>
<b>tempnam</b></dt>
<dd>
Return the name of a temporary file in the specified directory using a prefix. The file is guaranteed not to exist at the time the function was called, but such guarantees are good for one clock tick only.  Always use the proper form of &quot;sysopen&quot; with &quot;O_CREAT | O_EXCL&quot; if you must open such a filename.<div style="height: 1.00em;">
&#160;</div>
<br/>
  $filename = File::Temp::tempnam( $dir, $prefix );<br/>
<div style="height: 1.00em;">
&#160;</div>
Equivalent to running <i>mktemp()</i> with $dir/$prefixXXXXXXXX (using unix file convention as an example)<div style="height: 1.00em;">
&#160;</div>
Because this function uses <i>mktemp()</i>, it can suffer from race conditions.<div style="height: 1.00em;">
&#160;</div>
Will <i>croak()</i> if there is an error.</dd>
</dl>
</div>
<div class="section">
<h1>UTILITY FUNCTIONS</h1> Useful functions for dealing with the filehandle and filename.<dl>
<dt>
<b>unlink0</b></dt>
<dd>
Given an open filehandle and the associated filename, make a safe unlink. This is achieved by first checking that the filename and filehandle initially point to the same file and that the number of links to the file is 1 (all fields returned by  <i>stat()</i> are compared). Then the filename is unlinked and the filehandle checked once again to verify that the number of links on that file is now 0.  This is the closest you can come to making sure that the filename unlinked was the same as the file whose descriptor you hold.<div style="height: 1.00em;">
&#160;</div>
<br/>
  unlink0($fh, $path)<br/>
     or die &quot;Error unlinking file $path safely&quot;;<br/>
<div style="height: 1.00em;">
&#160;</div>
Returns false on error but <i>croaks()</i> if there is a security anomaly. The filehandle is not closed since on some occasions this is not required.<div style="height: 1.00em;">
&#160;</div>
On some platforms, for example Windows NT, it is not possible to unlink an open file (the file must be closed first). On those platforms, the actual unlinking is deferred until the program ends and good status is returned. A check is still performed to make sure that the filehandle and filename are pointing to the same thing (but not at the time the end block is executed since the deferred removal may not have access to the filehandle).<div style="height: 1.00em;">
&#160;</div>
Additionally, on Windows NT not all the fields returned by <i>stat()</i> can be compared. For example, the &quot;dev&quot; and &quot;rdev&quot; fields seem to be different.  Also, it seems that the size of the file returned by  <i>stat()</i> does not always agree, with &quot;stat(FH)&quot; being more accurate than &quot;stat(filename)&quot;, presumably because of caching issues even when using autoflush (this is usually overcome by waiting a while after writing to the tempfile before attempting to &quot;unlink0&quot; it).<div style="height: 1.00em;">
&#160;</div>
Finally, on NFS file systems the link count of the file handle does not always go to zero immediately after unlinking. Currently, this command is expected to fail on NFS disks.<div style="height: 1.00em;">
&#160;</div>
This function is disabled if the global variable $KEEP_ALL is true and an unlink on open file is supported. If the unlink is to be deferred to the END block, the file is still registered for removal.<div style="height: 1.00em;">
&#160;</div>
This function should not be called if you are using the object oriented interface since the it will interfere with the object destructor deleting the file.</dd>
</dl>
<dl>
<dt>
<b>cmpstat</b></dt>
<dd>
Compare &quot;stat&quot; of filehandle with &quot;stat&quot; of provided filename.  This can be used to check that the filename and filehandle initially point to the same file and that the number of links to the file is 1 (all fields returned by  <i>stat()</i> are compared).<div style="height: 1.00em;">
&#160;</div>
<br/>
  cmpstat($fh, $path)<br/>
     or die &quot;Error comparing handle with file&quot;;<br/>
<div style="height: 1.00em;">
&#160;</div>
Returns false if the stat information differs or if the link count is greater than 1. Calls croak if there is a security anomaly.<div style="height: 1.00em;">
&#160;</div>
On certain platforms, for example Windows, not all the fields returned by <i>stat()</i> can be compared. For example, the &quot;dev&quot; and &quot;rdev&quot; fields seem to be different in Windows.  Also, it seems that the size of the file returned by  <i>stat()</i> does not always agree, with &quot;stat(FH)&quot; being more accurate than &quot;stat(filename)&quot;, presumably because of caching issues even when using autoflush (this is usually overcome by waiting a while after writing to the tempfile before attempting to &quot;unlink0&quot; it).<div style="height: 1.00em;">
&#160;</div>
Not exported by default.</dd>
</dl>
<dl>
<dt>
<b>unlink1</b></dt>
<dd>
Similar to &quot;unlink0&quot; except after file comparison using cmpstat, the filehandle is closed prior to attempting to unlink the file. This allows the file to be removed without using an END block, but does mean that the post-unlink comparison of the filehandle state provided by &quot;unlink0&quot; is not available.<div style="height: 1.00em;">
&#160;</div>
<br/>
  unlink1($fh, $path)<br/>
     or die &quot;Error closing and unlinking file&quot;;<br/>
<div style="height: 1.00em;">
&#160;</div>
Usually called from the object destructor when using the OO interface.<div style="height: 1.00em;">
&#160;</div>
Not exported by default.<div style="height: 1.00em;">
&#160;</div>
This function is disabled if the global variable $KEEP_ALL is true.<div style="height: 1.00em;">
&#160;</div>
Can call <i>croak()</i> if there is a security anomaly during the <i>stat()</i> comparison.</dd>
</dl>
<dl>
<dt>
<b>cleanup</b></dt>
<dd>
Calling this function will cause any temp files or temp directories that are registered for removal to be removed. This happens automatically when the process exits but can be triggered manually if the caller is sure that none of the temp files are required. This method can be registered as an Apache callback.<div style="height: 1.00em;">
&#160;</div>
On OSes where temp files are automatically removed when the temp file is closed, calling this function will have no effect other than to remove temporary directories (which may include temporary files).<div style="height: 1.00em;">
&#160;</div>
<br/>
  File::Temp::cleanup();<br/>
<div style="height: 1.00em;">
&#160;</div>
Not exported by default.</dd>
</dl>
</div>
<div class="section">
<h1>PACKAGE VARIABLES</h1> These functions control the global state of the package.<dl>
<dt>
<b>safe_level</b></dt>
<dd>
Controls the lengths to which the module will go to check the safety of the temporary file or directory before proceeding. Options are:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
STANDARD</dt>
<dd>
Do the basic security measures to ensure the directory exists and is writable, that temporary files are opened only if they do not already exist, and that possible race conditions are avoided.  Finally the unlink0 function is used to remove files safely.</dd>
</dl>
<dl>
<dt>
MEDIUM</dt>
<dd>
In addition to the STANDARD security, the output directory is checked to make sure that it is owned either by root or the user running the program. If the directory is writable by group or by other, it is then checked to make sure that the sticky bit is set.<div style="height: 1.00em;">
&#160;</div>
Will not work on platforms that do not support the &quot;-k&quot; test for sticky bit.</dd>
</dl>
<dl>
<dt>
HIGH</dt>
<dd>
In addition to the MEDIUM security checks, also check for the possibility of `` <i>chown()</i> giveaway'' using the POSIX  <i>sysconf()</i> function. If this is a possibility, each directory in the path is checked in turn for safeness, recursively walking back to the root directory.<div style="height: 1.00em;">
&#160;</div>
For platforms that do not support the POSIX &quot;_PC_CHOWN_RESTRICTED&quot; symbol (for example, Windows NT) it is assumed that `` <i>chown()</i> giveaway'' is possible and the recursive test is performed.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">
&#160;</div>
The level can be changed as follows:<div style="height: 1.00em;">
&#160;</div>
<br/>
  File::Temp-&gt;safe_level( File::Temp::HIGH );<br/>
<div style="height: 1.00em;">
&#160;</div>
The level constants are not exported by the module.<div style="height: 1.00em;">
&#160;</div>
Currently, you must be running at least perl v5.6.0 in order to run with MEDIUM or HIGH security. This is simply because the safety tests use functions from Fcntl that are not available in older versions of perl. The problem is that the version number for Fcntl is the same in perl 5.6.0 and in 5.005_03 even though they are different versions.<div style="height: 1.00em;">
&#160;</div>
On systems that do not support the HIGH or MEDIUM safety levels (for example Win NT or OS/2) any attempt to change the level will be ignored. The decision to ignore rather than raise an exception allows portable programs to be written with high security in mind for the systems that can support this without those programs failing on systems where the extra tests are irrelevant.<div style="height: 1.00em;">
&#160;</div>
If you really need to see whether the change has been accepted simply examine the return value of &quot;safe_level&quot;.<div style="height: 1.00em;">
&#160;</div>
<br/>
  $newlevel = File::Temp-&gt;safe_level( File::Temp::HIGH );<br/>
  die &quot;Could not change to high security&quot;<br/>
      if $newlevel != File::Temp::HIGH;<br/>
</div>
<dl>
<dt>
TopSystemUID</dt>
<dd>
This is the highest UID on the current system that refers to a root UID. This is used to make sure that the temporary directory is owned by a system UID (&quot;root&quot;, &quot;bin&quot;, &quot;sys&quot; etc) rather than simply by root.<div style="height: 1.00em;">
&#160;</div>
This is required since on many unix systems &quot;/tmp&quot; is not owned by root.<div style="height: 1.00em;">
&#160;</div>
Default is to assume that any UID less than or equal to 10 is a root UID.<div style="height: 1.00em;">
&#160;</div>
<br/>
  File::Temp-&gt;top_system_uid(10);<br/>
  my $topid = File::Temp-&gt;top_system_uid;<br/>
<div style="height: 1.00em;">
&#160;</div>
This value can be adjusted to reduce security checking if required. The value is only relevant when &quot;safe_level&quot; is set to MEDIUM or higher.</dd>
</dl>
<dl>
<dt>
<b></b><b>$KEEP_ALL</b><b></b></dt>
<dd>
Controls whether temporary files and directories should be retained regardless of any instructions in the program to remove them automatically.  This is useful for debugging but should not be used in production code.<div style="height: 1.00em;">
&#160;</div>
<br/>
  $File::Temp::KEEP_ALL = 1;<br/>
<div style="height: 1.00em;">
&#160;</div>
Default is for files to be removed as requested by the caller.<div style="height: 1.00em;">
&#160;</div>
In some cases, files will only be retained if this variable is true when the file is created. This means that you can not create a temporary file, set this variable and expect the temp file to still be around when the program exits.</dd>
</dl>
<dl>
<dt>
<b></b><b>$DEBUG</b><b></b></dt>
<dd>
Controls whether debugging messages should be enabled.<div style="height: 1.00em;">
&#160;</div>
<br/>
  $File::Temp::DEBUG = 1;<br/>
<div style="height: 1.00em;">
&#160;</div>
Default is for debugging mode to be disabled.</dd>
</dl>
</div>
<div class="section">
<h1>WARNING</h1> For maximum security, endeavour always to avoid ever looking at, touching, or even imputing the existence of the filename.  You do not know that that filename is connected to the same file as the handle you have, and attempts to check this can only trigger more race conditions.  It's far more secure to use the filehandle alone and dispense with the filename altogether.<div class="spacer">
</div>
If you need to pass the handle to something that expects a filename then, on a unix system, use &quot;&quot;/dev/fd/&quot; . fileno($fh)&quot; for arbitrary programs, or more generally &quot;&quot;+&lt;=&amp;&quot; . fileno($fh)&quot; for Perl programs.  You will have to clear the close-on-exec bit on that file descriptor before passing it to another process.<div class="spacer">
</div>
<br/>
    use Fcntl qw/F_SETFD F_GETFD/;<br/>
    fcntl($tmpfh, F_SETFD, 0)<br/>
        or die &quot;Can't clear close-on-exec flag on temp fh: $!\n&quot;;<br/>
<div class="subsection">
<h2>Temporary files and NFS</h2> Some problems are associated with using temporary files that reside on NFS file systems and it is recommended that a local filesystem is used whenever possible. Some of the security tests will most probably fail when the temp file is not local. Additionally, be aware that the performance of I/O operations over NFS will not be as good as for a local disk.</div>
<div class="subsection">
<h2>Forking</h2> In some cases files created by File::Temp are removed from within an END block. Since END blocks are triggered when a child process exits (unless &quot;POSIX::_exit()&quot; is used by the child) File::Temp takes care to only remove those temp files created by a particular process ID. This means that a child will not attempt to remove temp files created by the parent process.<div class="spacer">
</div>
If you are forking many processes in parallel that are all creating temporary files, you may need to reset the random number seed using srand(EXPR) in each child else all the children will attempt to walk through the same set of random file names and may well cause themselves to give up if they exceed the number of retry attempts.</div>
<div class="subsection">
<h2>Directory removal</h2> Note that if you have chdir'ed into the temporary directory and it is subsequently cleaned up (either in the END block or as part of object destruction), then you will get a warning from  <i>File::Path::rmtree()</i>.</div>
<div class="subsection">
<h2>BINMODE</h2> The file returned by File::Temp will have been opened in binary mode if such a mode is available. If that is not correct, use the &quot;binmode()&quot; function to change the mode of the filehandle.<div class="spacer">
</div>
Note that you can modify the encoding of a file opened by File::Temp also by using &quot;binmode()&quot;.</div>
</div>
<div class="section">
<h1>HISTORY</h1> Originally began life in May 1999 as an XS interface to the system  <i>mkstemp()</i> function. In March 2000, the OpenBSD <i>mkstemp()</i> code was translated to Perl for total control of the code's security checking, to ensure the presence of the function regardless of operating system and to help with portability. The module was shipped as a standard part of perl from v5.6.1.</div>
<div class="section">
<h1>SEE ALSO</h1> &quot;tmpnam&quot; in POSIX, &quot;tmpfile&quot; in POSIX, File::Spec, File::Path<div class="spacer">
</div>
See IO::File and File::MkTemp, Apache::TempFile for different implementations of temporary file handling.<div class="spacer">
</div>
See File::Tempdir for an alternative object-oriented wrapper for the &quot;tempdir&quot; function.</div>
<div class="section">
<h1>AUTHOR</h1> Tim Jenness &lt;tjenness@cpan.org&gt;<div class="spacer">
</div>
Copyright (C) 2007-2009 Tim Jenness. Copyright (C) 1999-2007 Tim Jenness and the UK Particle Physics and Astronomy Research Council. All Rights Reserved.  This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.<div class="spacer">
</div>
Original Perl implementation loosely based on the OpenBSD C code for  <i>mkstemp()</i>. Thanks to Tom Christiansen for suggesting that this module should be written and providing ideas for code improvements and security enhancements.</div>
<table class="foot">
<tr>
<td class="foot-date">
2010-12-30</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

