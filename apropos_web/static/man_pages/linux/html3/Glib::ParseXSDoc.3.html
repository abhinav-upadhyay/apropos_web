<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Glib::ParseXSDoc(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Glib::ParseXSDoc(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
Glib::ParseXSDoc(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Glib::ParseXSDoc - Parse POD and XSub declarations from XS files.</div>
<div class="section">
<h1>DESCRIPTION</h1> This is the heart of an automatic API reference documentation system for XS-based Perl modules.  FIXME more info here!!<div class="spacer">
</div>
FIXME document recognized POD directives and the output data structures</div>
<div class="section">
<h1>FUNCTIONS</h1><dl>
<dt>
xsdocparse (@filenames)</dt>
<dd>
Parse xs files for xsub signatures and pod.  Writes to standard output a data structure suitable for eval'ing in another Perl script, describing all the stuff found.  The output contains three variables:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
$xspods = ARRAYREF</dt>
<dd>
array of pods found in the verbatim C portion of the XS file, listed in the order found.  These are assumed to pertain to the XS/C api, not the Perl api. Any &quot;=for apidoc&quot; paragraphs following an &quot;=object&quot; paragraphs in the verbatim sections are stripped (as are the &quot;=object&quot; paragraphs), and will appear instead in &quot;$data-&gt;{$package}{pods}&quot;.</dd>
</dl>
<dl>
<dt>
$data = HASHREF</dt>
<dd>
big hash keyed by package name (as found in the MODULE line), containing under each key a hash with all the xsubs and pods in that package, in the order found.  Packages are consolidated across multiple files.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">
&#160;</div>
FYI, this creates a new parser and calls &quot;parse_file&quot; on it for each input filename; then calls &quot;swizzle_pods&quot; to ensure that any &quot;=for apidoc name&quot; pods are matched up with their target xsubs; and finally calls Data::Dumper to write the data to stdout.  So, if you want to get finer control over how the output is created, or keep all the data in-process, now you know how.  :-)</div>
</div>
<div class="section">
<h1>METHODS</h1><dl>
<dt>
$Glib::ParseXSDoc::verbose</dt>
<dd>
If true, this causes the parser to be verbose.</dd>
</dl>
<dl>
<dt>
$parser = Glib::ParseXSDoc-&gt;new</dt>
<dd>
Create a new xsub parser.</dd>
</dl>
<dl>
<dt>
string = $parser-&gt;package</dt>
<dd>
Get the current package name.  Falls back to the module name.  Will be undef if the parser hasn't reached the first MODULE line.</dd>
</dl>
<dl>
<dt>
HASHREF = $parser-&gt;pkgdata</dt>
<dd>
The data hash corresponding to the current package, honoring the most recently encountered &quot;=for object&quot; directive.  Ensures that it exists. Returns a reference to the member of the main data structure, so modifications are permanent and useful.</dd>
</dl>
<dl>
<dt>
$parser-&gt;parse_file (filename)</dt>
<dd>
Parse one xs file.  Stores all the collected data in <i></i><i>$parser</i><i></i>'s internal data structures.</dd>
</dl>
<dl>
<dt>
$parser-&gt;swizzle_pods</dt>
<dd>
Match &quot;=for apidoc&quot; pods to xsubs.</dd>
</dl>
<dl>
<dt>
$parser-&gt;preprocess_pods</dt>
<dd>
Honor the &quot;__hide__&quot; and &quot;__function__&quot; directives in &quot;=for apidoc&quot; lines.<div style="height: 1.00em;">
&#160;</div>
We look for the strings anywhere, but you'll typically have it at the end of the line, e.g.:<div style="height: 1.00em;">
&#160;</div>
<br/>
  =for apidoc symname __hide__        for detached blocks<br/>
  =for apidoc __hide__                for attached blocks<br/>
<br/>
  =for apidoc symname __function__    for functions rather than methods<br/>
  =for apidoc __function__            for functions rather than methods<br/>
</dd>
</dl>
<dl>
<dt>
bool = $parser-&gt;is_module_line ($line)</dt>
<dd>
Analyze <i></i><i>$line</i><i></i> to see if it contains an XS MODULE directive.  If so, returns true after setting the  <i></i><i>$parser</i><i></i>'s <i>module</i>, <i>package</i>, and <i>prefix</i> accordingly.</dd>
</dl>
<dl>
<dt>
$pod = $parser-&gt;slurp_pod_paragraph ($firstline, $term_regex=/^=cut\s*/)</dt>
<dd>
Slurp up POD lines from <i></i><i>$filehandle</i><i></i> from here to the next  <i></i><i>$term_regex</i><i></i> or EOF.  Since you probably already read a line to determine that we needed to start a pod, you can pass that first line to be included.</dd>
</dl>
<dl>
<dt>
$xsub = $parser-&gt;parse_xsub (\@lines)</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$xsub = $parser-&gt;parse_xsub (@lines)</dt>
<dd>
Parse an xsub header, in the form of a list of lines, into a data structure describing the xsub.  That includes pulling out the argument types, aliases, and code type.<div style="height: 1.00em;">
&#160;</div>
Without artificial intelligence, we cannot reliably determine anything about the types or number of parameters returned from xsubs with PPCODE bodies.<div style="height: 1.00em;">
&#160;</div>
OUTLIST parameters are pulled from the args list and put into an &quot;outlist&quot; key.  IN_OUTLIST parameters are put into both.<div style="height: 1.00em;">
&#160;</div>
Data type names are not mangled at all.<div style="height: 1.00em;">
&#160;</div>
Note that the method can take either a list of lines or a reference to a list of lines.  The flat list form is provided for compatibility; the reference form is preferred, to avoid duplicating a potentially large list of strings.</dd>
</dl>
<dl>
<dt>
$parser-&gt;clean_out_empty_pods</dt>
<dd>
Looks through the data member of the parser and removes any keys (and associated values) when no pod, enums, and xsubs exist for the package.</dd>
</dl>
</div>
<div class="section">
<h1>AUTHOR</h1> muppet &lt;scott at asofyet dot org&gt;</div>
<div class="section">
<h1>COPYRIGHT AND LICENSE</h1> Copyright (C) 2003, 2004 by muppet<div class="spacer">
</div>
This library is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.<div class="spacer">
</div>
This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.<div class="spacer">
</div>
You should have received a copy of the GNU Library General Public License along with this library; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307  USA.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-11-18</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

