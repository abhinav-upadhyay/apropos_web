<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
HTTP::Tiny(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
HTTP::Tiny(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
HTTP::Tiny(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> HTTP::Tiny - A small, simple, correct HTTP/1.1 client</div>
<div class="section">
<h1>VERSION</h1> version 0.012</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
    use HTTP::Tiny;<br/>
<br/>
    my $response = HTTP::Tiny-&gt;new-&gt;get('http://example.com/');<br/>
<br/>
    die &quot;Failed!\n&quot; unless $response-&gt;{success};<br/>
<br/>
    print &quot;$response-&gt;{status} $response-&gt;{reason}\n&quot;;<br/>
<br/>
    while (my ($k, $v) = each %{$response-&gt;{headers}}) {<br/>
        for (ref $v eq 'ARRAY' ? @$v : $v) {<br/>
            print &quot;$k: $_\n&quot;;<br/>
        }<br/>
    }<br/>
<br/>
    print $response-&gt;{content} if length $response-&gt;{content};<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> This is a very simple HTTP/1.1 client, designed primarily for doing simple GET requests without the overhead of a large framework like LWP::UserAgent.<div class="spacer">
</div>
It is more correct and more complete than HTTP::Lite.  It supports proxies (currently only non-authenticating ones) and redirection.  It also correctly resumes after EINTR.</div>
<div class="section">
<h1>METHODS</h1><div class="subsection">
<h2>new</h2><br/>
    $http = HTTP::Tiny-&gt;new( %attributes );<br/>
<div class="spacer">
</div>
This constructor returns a new HTTP::Tiny object.  Valid attributes include:<dl>
<dt>
&#8226;</dt>
<dd>
agent<div style="height: 1.00em;">
&#160;</div>
A user-agent string (defaults to 'HTTP::Tiny/$VERSION')</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
default_headers<div style="height: 1.00em;">
&#160;</div>
A hashref of default headers to apply to requests</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
max_redirect<div style="height: 1.00em;">
&#160;</div>
Maximum number of redirects allowed (defaults to 5)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
max_size<div style="height: 1.00em;">
&#160;</div>
Maximum response size (only when not using a data callback).  If defined, responses larger than this will die with an error message</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
proxy<div style="height: 1.00em;">
&#160;</div>
URL of a proxy server to use.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
timeout<div style="height: 1.00em;">
&#160;</div>
Request timeout in seconds (default is 60)</dd>
</dl>
</div>
<div class="subsection">
<h2>get</h2><br/>
    $response = $http-&gt;get($url);<br/>
    $response = $http-&gt;get($url, \%options);<br/>
<div class="spacer">
</div>
Executes a &quot;GET&quot; request for the given URL.  The URL must have unsafe characters escaped and international domain names encoded.  Internally, it just calls &quot;request()&quot; with 'GET' as the method.  See &quot;request()&quot; for valid options and a description of the response.</div>
<div class="subsection">
<h2>mirror</h2><br/>
    $response = $http-&gt;mirror($url, $file, \%options)<br/>
    if ( $response-&gt;{success} ) {<br/>
        print &quot;$file is up to date\n&quot;;<br/>
    }<br/>
<div class="spacer">
</div>
Executes a &quot;GET&quot; request for the URL and saves the response body to the file name provided.  The URL must have unsafe characters escaped and international domain names encoded.  If the file already exists, the request will includes an &quot;If-Modified-Since&quot; header with the modification timestamp of the file.  You may specificy a different &quot;If-Modified-Since&quot; header yourself in the &quot;$options-&gt;{headers}&quot; hash.<div class="spacer">
</div>
The &quot;success&quot; field of the response will be true if the status code is 2XX or 304 (unmodified).<div class="spacer">
</div>
If the file was modified and the server response includes a properly formatted &quot;Last-Modified&quot; header, the file modification time will be updated accordingly.</div>
<div class="subsection">
<h2>request</h2><br/>
    $response = $http-&gt;request($method, $url);<br/>
    $response = $http-&gt;request($method, $url, \%options);<br/>
<div class="spacer">
</div>
Executes an HTTP request of the given method type ('GET', 'HEAD', 'POST', 'PUT', etc.) on the given URL.  The URL must have unsafe characters escaped and international domain names encoded.  A hashref of options may be appended to modify the request.<div class="spacer">
</div>
Valid options are:<dl>
<dt>
&#8226;</dt>
<dd>
headers<div style="height: 1.00em;">
&#160;</div>
A hashref containing headers to include with the request.  If the value for a header is an array reference, the header will be output multiple times with each value in the array.  These headers over-write any default headers.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
content<div style="height: 1.00em;">
&#160;</div>
A scalar to include as the body of the request OR a code reference that will be called iteratively to produce the body of the response</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
trailer_callback<div style="height: 1.00em;">
&#160;</div>
A code reference that will be called if it exists to provide a hashref of trailing headers (only used with chunked transfer-encoding)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
data_callback<div style="height: 1.00em;">
&#160;</div>
A code reference that will be called for each chunks of the response body received.</dd>
</dl>
<div class="spacer">
</div>
If the &quot;content&quot; option is a code reference, it will be called iteratively to provide the content body of the request.  It should return the empty string or undef when the iterator is exhausted.<div class="spacer">
</div>
If the &quot;data_callback&quot; option is provided, it will be called iteratively until the entire response body is received.  The first argument will be a string containing a chunk of the response body, the second argument will be the in-progress response hash reference, as described below.  (This allows customizing the action of the callback based on the &quot;status&quot; or &quot;headers&quot; received prior to the content body.)<div class="spacer">
</div>
The &quot;request&quot; method returns a hashref containing the response.  The hashref will have the following keys:<dl>
<dt>
&#8226;</dt>
<dd>
success<div style="height: 1.00em;">
&#160;</div>
Boolean indicating whether the operation returned a 2XX status code</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
status<div style="height: 1.00em;">
&#160;</div>
The HTTP status code of the response</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
reason<div style="height: 1.00em;">
&#160;</div>
The response phrase returned by the server</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
content<div style="height: 1.00em;">
&#160;</div>
The body of the response.  If the response does not have any content or if a data callback is provided to consume the response body, this will be the empty string</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
headers<div style="height: 1.00em;">
&#160;</div>
A hashref of header fields.  All header field names will be normalized to be lower case. If a header is repeated, the value will be an arrayref; it will otherwise be a scalar string containing the value</dd>
</dl>
<div class="spacer">
</div>
On an exception during the execution of the request, the &quot;status&quot; field will contain 599, and the &quot;content&quot; field will contain the text of the exception.</div>
</div>
<div class="section">
<h1>LIMITATIONS</h1> HTTP::Tiny is  <i>conditionally compliant</i> with the HTTP/1.1 specification &lt;http://www.w3.org/Protocols/rfc2616/rfc2616.html&gt;. It attempts to meet all &quot;MUST&quot; requirements of the specification, but does not implement all &quot;SHOULD&quot; requirements.<div class="spacer">
</div>
Some particular limitations of note include:<dl>
<dt>
&#8226;</dt>
<dd>
HTTP::Tiny focuses on correct transport.  Users are responsible for ensuring that user-defined headers and content are compliant with the HTTP/1.1 specification.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Users must ensure that URLs are properly escaped for unsafe characters and that international domain names are properly encoded to ASCII. See URI::Escape, URI::_punycode and Net::IDN::Encode.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Redirection is very strict against the specification.  Redirection is only automatic for response codes 301, 302 and 307 if the request method is 'GET' or 'HEAD'.  Response code 303 is always converted into a 'GET' redirection, as mandated by the specification.  There is no automatic support for status 305 (&quot;Use proxy&quot;) redirections.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Persistant connections are not supported.  The &quot;Connection&quot; header will always be set to &quot;close&quot;.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Direct &quot;https&quot; connections are supported only if IO::Socket::SSL is installed.  There is no support for &quot;https&quot; connections via proxy. Any SSL certificate that matches the host is accepted -- SSL certificates are not verified against certificate authorities.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Cookies are not directly supported.  Users that set a &quot;Cookie&quot; header should also set &quot;max_redirect&quot; to zero to ensure cookies are not inappropriately re-transmitted.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Proxy environment variables are not supported.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
There is no provision for delaying a request body using an &quot;Expect&quot; header. Unexpected &quot;1XX&quot; responses are silently ignored as per the specification.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Only 'chunked' &quot;Transfer-Encoding&quot; is supported.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
There is no support for a Request-URI of '*' for the 'OPTIONS' request.</dd>
</dl>
</div>
<div class="section">
<h1>SEE ALSO</h1><dl>
<dt>
&#8226;</dt>
<dd>
LWP::UserAgent</dd>
</dl>
</div>
<div class="section">
<h1>SUPPORT</h1><div class="subsection">
<h2>Bugs / Feature Requests</h2> Please report any bugs or feature requests by email to &quot;bug-http-tiny at rt.cpan.org&quot;, or through the web interface at http://rt.cpan.org/Public/Dist/Display.html?Name=HTTP-Tiny &lt;http://rt.cpan.org/Public/Dist/Display.html?Name=HTTP-Tiny&gt;. You will be automatically notified of any progress on the request by the system.</div>
<div class="subsection">
<h2>Source Code</h2> This is open source software.  The code repository is available for public review and contribution under the terms of the license.<div class="spacer">
</div>
http://github.com/dagolden/p5-http-tiny/tree &lt;http://github.com/dagolden/p5-http-tiny/tree&gt;<div class="spacer">
</div>
<br/>
  git clone git://github.com/dagolden/p5-http-tiny.git<br/>
</div>
</div>
<div class="section">
<h1>AUTHORS</h1><dl>
<dt>
&#8226;</dt>
<dd>
Christian Hansen &lt;chansen@cpan.org&gt;</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
David Golden &lt;dagolden@cpan.org&gt;</dd>
</dl>
</div>
<div class="section">
<h1>COPYRIGHT AND LICENSE</h1> This software is copyright (c) 2011 by Christian Hansen.<div class="spacer">
</div>
This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5 programming language system itself.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-09-26</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

