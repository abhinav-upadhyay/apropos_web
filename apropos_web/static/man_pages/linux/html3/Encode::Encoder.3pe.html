<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Encode::Encoder(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Encode::Encoder(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
Encode::Encoder(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Encode::Encoder -- Object Oriented Encoder</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
  use Encode::Encoder;<br/>
  # Encode::encode(&quot;ISO-8859-1&quot;, $data); <br/>
  Encode::Encoder-&gt;new($data)-&gt;iso_8859_1; # OOP way<br/>
  # shortcut<br/>
  use Encode::Encoder qw(encoder);<br/>
  encoder($data)-&gt;iso_8859_1;<br/>
  # you can stack them!<br/>
  encoder($data)-&gt;iso_8859_1-&gt;base64;  # provided base64() is defined<br/>
  # you can use it as a decoder as well<br/>
  encoder($base64)-&gt;bytes('base64')-&gt;latin1;<br/>
  # stringified<br/>
  print encoder($data)-&gt;utf8-&gt;latin1;  # prints the string in latin1<br/>
  # numified<br/>
  encoder(&quot;\x{abcd}\x{ef}g&quot;)-&gt;utf8 == 6; # true. bytes::length($data)<br/>
</div>
<div class="section">
<h1>ABSTRACT</h1>  <b>Encode::Encoder</b> allows you to use Encode in an object-oriented style.  This is not only more intuitive than a functional approach, but also handier when you want to stack encodings.  Suppose you want your UTF-8 string converted to Latin1 then Base64: you can simply say<div class="spacer">
</div>
<br/>
  my $base64 = encoder($utf8)-&gt;latin1-&gt;base64;<br/>
<div class="spacer">
</div>
instead of<div class="spacer">
</div>
<br/>
  my $latin1 = encode(&quot;latin1&quot;, $utf8);<br/>
  my $base64 = encode_base64($utf8);<br/>
<div class="spacer">
</div>
or the lazier and more convoluted<div class="spacer">
</div>
<br/>
  my $base64 = encode_base64(encode(&quot;latin1&quot;, $utf8));<br/>
</div>
<div class="section">
<h1>Description</h1> Here is how to use this module.<dl>
<dt>
&#8226;</dt>
<dd>
There are at least two instance variables stored in a hash reference, {data} and {encoding}.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
When there is no method, it takes the method name as the name of the encoding and encodes the instance  <i>data</i> with <i>encoding</i>.  If successful, the instance  <i>encoding</i> is set accordingly.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
You can retrieve the result via -&gt;data but usually you don't have to because the stringify operator (&quot;&quot;) is overridden to do exactly that.</dd>
</dl>
<div class="subsection">
<h2>Predefined Methods</h2> This module predefines the methods below:<dl>
<dt>
$e = Encode::Encoder-&gt;new([$data, $encoding]);</dt>
<dd>
returns an encoder object.  Its data is initialized with $data if present, and its encoding is set to $encoding if present.<div style="height: 1.00em;">
&#160;</div>
When $encoding is omitted, it defaults to utf8 if $data is already in utf8 or &quot;&quot; (empty string) otherwise.</dd>
</dl>
<dl>
<dt>
<i>encoder()</i></dt>
<dd>
is an alias of Encode::Encoder-&gt;<i>new()</i>.  This one is exported on demand.</dd>
</dl>
<dl>
<dt>
$e-&gt;data([$data])</dt>
<dd>
When $data is present, sets the instance data to $data and returns the object itself.  Otherwise, the current instance data is returned.</dd>
</dl>
<dl>
<dt>
$e-&gt;encoding([$encoding])</dt>
<dd>
When $encoding is present, sets the instance encoding to $encoding and returns the object itself.  Otherwise, the current instance encoding is returned.</dd>
</dl>
<dl>
<dt>
$e-&gt;bytes([$encoding])</dt>
<dd>
decodes instance data from $encoding, or the instance encoding if omitted.  If the conversion is successful, the instance encoding will be set to &quot;&quot;.<div style="height: 1.00em;">
&#160;</div>
The name <i>bytes</i> was deliberately picked to avoid namespace tainting -- this module may be used as a base class so method names that appear in Encode::Encoding are avoided.</dd>
</dl>
</div>
<div class="subsection">
<h2>Example: base64 transcoder</h2> This module is designed to work with Encode::Encoding. To make the Base64 transcoder example above really work, you could write a module like this:<div class="spacer">
</div>
<br/>
  package Encode::Base64;<br/>
  use base 'Encode::Encoding';<br/>
  __PACKAGE__-&gt;Define('base64');<br/>
  use MIME::Base64;<br/>
  sub encode{ <br/>
      my ($obj, $data) = @_; <br/>
      return encode_base64($data);<br/>
  }<br/>
  sub decode{<br/>
      my ($obj, $data) = @_; <br/>
      return decode_base64($data);<br/>
  }<br/>
  1;<br/>
  __END__<br/>
<div class="spacer">
</div>
And your caller module would be something like this:<div class="spacer">
</div>
<br/>
  use Encode::Encoder;<br/>
  use Encode::Base64;<br/>
<br/>
  # now you can really do the following<br/>
<br/>
  encoder($data)-&gt;iso_8859_1-&gt;base64;<br/>
  encoder($base64)-&gt;bytes('base64')-&gt;latin1;<br/>
</div>
<div class="subsection">
<h2>Operator Overloading</h2> This module overloads two operators, stringify (&quot;&quot;) and numify (0+).<div class="spacer">
</div>
Stringify dumps the data inside the object.<div class="spacer">
</div>
Numify returns the number of bytes in the instance data.<div class="spacer">
</div>
They come in handy when you want to print or find the size of data.</div>
</div>
<div class="section">
<h1>SEE ALSO</h1> Encode, Encode::Encoding</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-09-26</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

