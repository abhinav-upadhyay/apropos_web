<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Net::HTTP(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Net::HTTP(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
Net::HTTP(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Net::HTTP - Low-level HTTP connection (client)</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
 use Net::HTTP;<br/>
 my $s = Net::HTTP-&gt;new(Host =&gt; &quot;www.perl.com&quot;) || die $@;<br/>
 $s-&gt;write_request(GET =&gt; &quot;/&quot;, 'User-Agent' =&gt; &quot;Mozilla/5.0&quot;);<br/>
 my($code, $mess, %h) = $s-&gt;read_response_headers;<br/>
<br/>
 while (1) {<br/>
    my $buf;<br/>
    my $n = $s-&gt;read_entity_body($buf, 1024);<br/>
    die &quot;read failed: $!&quot; unless defined $n;<br/>
    last unless $n;<br/>
    print $buf;<br/>
 }<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> The &quot;Net::HTTP&quot; class is a low-level HTTP client.  An instance of the &quot;Net::HTTP&quot; class represents a connection to an HTTP server.  The HTTP protocol is described in RFC 2616.  The &quot;Net::HTTP&quot; class supports &quot;HTTP/1.0&quot; and &quot;HTTP/1.1&quot;.<div class="spacer">
</div>
&quot;Net::HTTP&quot; is a sub-class of &quot;IO::Socket::INET&quot;.  You can mix the methods described below with reading and writing from the socket directly.  This is not necessary a good idea, unless you know what you are doing.<div class="spacer">
</div>
The following methods are provided (in addition to those of &quot;IO::Socket::INET&quot;):<dl>
<dt>
$s = Net::HTTP-&gt;new( %options )</dt>
<dd>
The &quot;Net::HTTP&quot; constructor method takes the same options as &quot;IO::Socket::INET&quot;'s as well as these:<div style="height: 1.00em;">
&#160;</div>
<br/>
  Host:            Initial host attribute value<br/>
  KeepAlive:       Initial keep_alive attribute value<br/>
  SendTE:          Initial send_te attribute_value<br/>
  HTTPVersion:     Initial http_version attribute value<br/>
  PeerHTTPVersion: Initial peer_http_version attribute value<br/>
  MaxLineLength:   Initial max_line_length attribute value<br/>
  MaxHeaderLines:  Initial max_header_lines attribute value<br/>
<div style="height: 1.00em;">
&#160;</div>
The &quot;Host&quot; option is also the default for &quot;IO::Socket::INET&quot;'s &quot;PeerAddr&quot;.  The &quot;PeerPort&quot; defaults to 80 if not provided.<div style="height: 1.00em;">
&#160;</div>
The &quot;Listen&quot; option provided by &quot;IO::Socket::INET&quot;'s constructor method is not allowed.<div style="height: 1.00em;">
&#160;</div>
If unable to connect to the given HTTP server then the constructor returns &quot;undef&quot; and $@ contains the reason.  After a successful connect, a &quot;Net:HTTP&quot; object is returned.</dd>
</dl>
<dl>
<dt>
$s-&gt;host</dt>
<dd>
Get/set the default value of the &quot;Host&quot; header to send.  The $host must not be set to an empty string (or &quot;undef&quot;) for HTTP/1.1.</dd>
</dl>
<dl>
<dt>
$s-&gt;keep_alive</dt>
<dd>
Get/set the <i>keep-alive</i> value.  If this value is TRUE then the request will be sent with headers indicating that the server should try to keep the connection open so that multiple requests can be sent.<div style="height: 1.00em;">
&#160;</div>
The actual headers set will depend on the value of the &quot;http_version&quot; and &quot;peer_http_version&quot; attributes.</dd>
</dl>
<dl>
<dt>
$s-&gt;send_te</dt>
<dd>
Get/set the a value indicating if the request will be sent with a &quot;TE&quot; header to indicate the transfer encodings that the server can choose to use.  The list of encodings announced as accepted by this client depends on availability of the following modules: &quot;Compress::Raw::Zlib&quot; for  <i>deflate</i>, and &quot;IO::Compress::Gunzip&quot; for <i>gzip</i>.</dd>
</dl>
<dl>
<dt>
$s-&gt;http_version</dt>
<dd>
Get/set the HTTP version number that this client should announce. This value can only be set to &quot;1.0&quot; or &quot;1.1&quot;.  The default is &quot;1.1&quot;.</dd>
</dl>
<dl>
<dt>
$s-&gt;peer_http_version</dt>
<dd>
Get/set the protocol version number of our peer.  This value will initially be &quot;1.0&quot;, but will be updated by a successful  <i>read_response_headers()</i> method call.</dd>
</dl>
<dl>
<dt>
$s-&gt;max_line_length</dt>
<dd>
Get/set a limit on the length of response line and response header lines.  The default is 8192.  A value of 0 means no limit.</dd>
</dl>
<dl>
<dt>
$s-&gt;max_header_length</dt>
<dd>
Get/set a limit on the number of header lines that a response can have.  The default is 128.  A value of 0 means no limit.</dd>
</dl>
<dl>
<dt>
$s-&gt;format_request($method, $uri, %headers, [$content])</dt>
<dd>
Format a request message and return it as a string.  If the headers do not include a &quot;Host&quot; header, then a header is inserted with the value of the &quot;host&quot; attribute.  Headers like &quot;Connection&quot; and &quot;Keep-Alive&quot; might also be added depending on the status of the &quot;keep_alive&quot; attribute.<div style="height: 1.00em;">
&#160;</div>
If $content is given (and it is non-empty), then a &quot;Content-Length&quot; header is automatically added unless it was already present.</dd>
</dl>
<dl>
<dt>
$s-&gt;write_request($method, $uri, %headers, [$content])</dt>
<dd>
Format and send a request message.  Arguments are the same as for  <i>format_request()</i>.  Returns true if successful.</dd>
</dl>
<dl>
<dt>
$s-&gt;format_chunk( $data )</dt>
<dd>
Returns the string to be written for the given chunk of data.</dd>
</dl>
<dl>
<dt>
$s-&gt;write_chunk($data)</dt>
<dd>
Will write a new chunk of request entity body data.  This method should only be used if the &quot;Transfer-Encoding&quot; header with a value of &quot;chunked&quot; was sent in the request.  Note, writing zero-length data is a no-op.  Use the  <i>write_chunk_eof()</i> method to signal end of entity body data.<div style="height: 1.00em;">
&#160;</div>
Returns true if successful.</dd>
</dl>
<dl>
<dt>
$s-&gt;format_chunk_eof( %trailers )</dt>
<dd>
Returns the string to be written for signaling EOF when a &quot;Transfer-Encoding&quot; of &quot;chunked&quot; is used.</dd>
</dl>
<dl>
<dt>
$s-&gt;write_chunk_eof( %trailers )</dt>
<dd>
Will write eof marker for chunked data and optional trailers.  Note that trailers should not really be used unless is was signaled with a &quot;Trailer&quot; header.<div style="height: 1.00em;">
&#160;</div>
Returns true if successful.</dd>
</dl>
<dl>
<dt>
($code, $mess, %headers) = $s-&gt;read_response_headers( %opts )</dt>
<dd>
Read response headers from server and return it.  The $code is the 3 digit HTTP status code (see HTTP::Status) and $mess is the textual message that came with it.  Headers are then returned as key/value pairs.  Since key letter casing is not normalized and the same key can even occur multiple times, assigning these values directly to a hash is not wise.  Only the $code is returned if this method is called in scalar context.<div style="height: 1.00em;">
&#160;</div>
As a side effect this method updates the 'peer_http_version' attribute.<div style="height: 1.00em;">
&#160;</div>
Options might be passed in as key/value pairs.  There are currently only two options supported; &quot;laxed&quot; and &quot;junk_out&quot;.<div style="height: 1.00em;">
&#160;</div>
The &quot;laxed&quot; option will make <i>read_response_headers()</i> more forgiving towards servers that have not learned how to speak HTTP properly.  The &quot;laxed&quot; option is a boolean flag, and is enabled by passing in a TRUE value.  The &quot;junk_out&quot; option can be used to capture bad header lines when &quot;laxed&quot; is enabled.  The value should be an array reference. Bad header lines will be pushed onto the array.<div style="height: 1.00em;">
&#160;</div>
The &quot;laxed&quot; option must be specified in order to communicate with pre-HTTP/1.0 servers that don't describe the response outcome or the data they send back with a header block.  For these servers peer_http_version is set to &quot;0.9&quot; and this method returns (200, &quot;Assumed OK&quot;).<div style="height: 1.00em;">
&#160;</div>
The method will raise an exception (die) if the server does not speak proper HTTP or if the &quot;max_line_length&quot; or &quot;max_header_length&quot; limits are reached.  If the &quot;laxed&quot; option is turned on and &quot;max_line_length&quot; and &quot;max_header_length&quot; checks are turned off, then no exception will be raised and this method will always return a response code.</dd>
</dl>
<dl>
<dt>
$n = $s-&gt;read_entity_body($buf, $size);</dt>
<dd>
Reads chunks of the entity body content.  Basically the same interface as for  <i>read()</i> and <i>sysread()</i>, but the buffer offset argument is not supported yet.  This method should only be called after a successful  <i>read_response_headers()</i> call.<div style="height: 1.00em;">
&#160;</div>
The return value will be &quot;undef&quot; on read errors, 0 on EOF, -1 if no data could be returned this time, otherwise the number of bytes assigned to $buf.  The $buf is set to &quot;&quot; when the return value is -1.<div style="height: 1.00em;">
&#160;</div>
You normally want to retry this call if this function returns either -1 or &quot;undef&quot; with $! as EINTR or EAGAIN (see Errno).  EINTR can happen if the application catches signals and EAGAIN can happen if you made the socket non-blocking.<div style="height: 1.00em;">
&#160;</div>
This method will raise exceptions (die) if the server does not speak proper HTTP.  This can only happen when reading chunked data.</dd>
</dl>
<dl>
<dt>
%headers = $s-&gt;get_trailers</dt>
<dd>
After <i>read_entity_body()</i> has returned 0 to indicate end of the entity body, you might call this method to pick up any trailers.</dd>
</dl>
<dl>
<dt>
$s-&gt;_rbuf</dt>
<dd>
Get/set the read buffer content.  The <i>read_response_headers()</i> and  <i>read_entity_body()</i> methods use an internal buffer which they will look for data before they actually sysread more from the socket itself.  If they read too much, the remaining data will be left in this buffer.</dd>
</dl>
<dl>
<dt>
$s-&gt;_rbuf_length</dt>
<dd>
Returns the number of bytes in the read buffer.  This should always be the same as:<div style="height: 1.00em;">
&#160;</div>
<br/>
    length($s-&gt;_rbuf)<br/>
<div style="height: 1.00em;">
&#160;</div>
but might be more efficient.</dd>
</dl>
</div>
<div class="section">
<h1>SUBCLASSING</h1> The  <i>read_response_headers()</i> and <i>read_entity_body()</i> will invoke the  <i>sysread()</i> method when they need more data.  Subclasses might want to override this method to control how reading takes place.<div class="spacer">
</div>
The object itself is a glob.  Subclasses should avoid using hash key names prefixed with &quot;http_&quot; and &quot;io_&quot;.</div>
<div class="section">
<h1>SEE ALSO</h1> LWP, IO::Socket::INET, Net::HTTP::NB</div>
<div class="section">
<h1>COPYRIGHT</h1> Copyright 2001-2003 Gisle Aas.<div class="spacer">
</div>
This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-11-21</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

