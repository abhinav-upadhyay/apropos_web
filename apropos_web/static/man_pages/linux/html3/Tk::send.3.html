<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
send(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
send(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
send(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> send - Execute a command in a different application</div>
<div class="section">
<h1>SYNOPSIS</h1> &#160;&#160;&#160;&#160; <i></i><i>$result</i><i></i> = <i></i><i>$widget</i><i></i>-&gt;<b>send</b>(?<i>options</i>,?<i>app</i>=&gt;<i>cmd</i>?<i>arg arg ...</i>?)</div>
<div class="section">
<h1>DESCRIPTION</h1> This method arranges for  <i>cmd</i> (and <i>arg</i>s) to be 'sent' to the application named by  <i>app</i>.  It returns the result or an error (hence above should probably be 'wrapped' in  <b>eval{}</b> and $@ tested).  <i>App</i> may be the name of any application whose main window is on the display containing the sender's main window;  it need not be within the same process. If no  <i>arg</i> arguments are present, then the string to be sent is contained entirely within the  <i>cmd</i> argument.  If one or more  <i>arg</i>s are present, they are concatenated separated by white space to form the string to be sent.<div class="spacer">
</div>
If the initial arguments of the call begin with ``-'' they are treated as options.  The following options are currently defined:<dl>
<dt>
<b>-async</b></dt>
<dd>
Requests asynchronous invocation.  In this case the <b>send</b> command will complete immediately without waiting for  <i>cmd</i> to complete in the target application;  no result will be available and errors in the sent command will be ignored. If the target application is in the same process as the sending application then the  <b>-async</b> option is ignored.</dd>
</dl>
<dl>
<dt>
<b>--</b></dt>
<dd>
Serves no purpose except to terminate the list of options.  This option is needed only if  <i>app</i> could contain a leading ``-'' character.</dd>
</dl>
</div>
<div class="section">
<h1>APPLICATION NAMES</h1> The name of an application is set initially from the name of the program or script that created the application. You can query and change the name of an application with the  <b>appname</b> method.</div>
<div class="section">
<h1>WHAT IS A SEND</h1> The  <b>send</b> mechanism was designed to allow Tcl/Tk applications to send Tcl Scripts to each other. This does not map very well onto perl/Tk. Perl/Tk &quot;sends&quot; a string to  <i>app</i>, what happens as a result of this depends on the receiving application. If the other application is a Tcl/Tk4.* application it will be treated as a Tcl Script. If the &quot;other&quot; application is perl/Tk application (including sends to self) then the string is passed as an argument to a method call of the following form:<div class="spacer">
</div>
<i></i><i>$mainwindow</i><i></i>-&gt;<b>Receive(</b><i>string</i>);<div class="spacer">
</div>
There is a default (AutoLoaded) <b>Tk::Receive</b> which returns an error to the sending application. A particular application may define its own  <b>Receive</b> method in any class in <b>MainWindow</b>'s inheritance tree to do whatever it sees fit. For example it could  <b>eval</b> the string, possibly in a  <b>Safe</b> &quot;compartment&quot;.<div class="spacer">
</div>
If a Tcl/Tk application &quot;sends&quot; anything to a perl/Tk application then the perl/Tk application would have to attempt to interpret the incoming string as a Tcl Script. Simple cases are should not be too hard to emulate (split on white space and treat first element as &quot;command&quot; and other elements as arguments).</div>
<div class="section">
<h1>SECURITY</h1> The  <b>send</b> command is potentially a serious security loophole, since any application that can connect to your X server can send scripts to your applications. Hence the default behaviour outlined above. (With the availability of  <b>Safe</b> it may make sense to relax default behaviour a little.)<div class="spacer">
</div>
Unmonitored <b>eval</b>'ing of these incoming &quot;scripts&quot; can cause perl to read and write files and invoke subprocesses under your name. Host-based access control such as that provided by  <b>xhost</b> is particularly insecure, since it allows anyone with an account on particular hosts to connect to your server, and if disabled it allows anyone anywhere to connect to your server. In order to provide at least a small amount of security, core Tk checks the access control being used by the server and rejects incoming sends unless (a)  <b>xhost</b>-style access control is enabled (i.e. only certain hosts can establish connections) and (b) the list of enabled hosts is empty. This means that applications cannot connect to your server unless they use some other form of authorization such as that provide by  <b>xauth</b>.</div>
<div class="section">
<h1>SEE ALSO</h1> &quot;eval&quot; in perlfunc, Safe, system's administrator/corporate security guidelines etc.</div>
<div class="section">
<h1>KEYWORDS</h1> application, name, remote execution, security, send</div>
<table class="foot">
<tr>
<td class="foot-date">
2007-02-10</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

