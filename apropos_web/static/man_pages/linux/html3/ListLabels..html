<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
ListLabels(3)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
ListLabels(3)</td>
<td class="head-vol">
OCaml library</td>
<td class="head-rtitle">
ListLabels(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> ListLabels - List operations.</div>
<div class="section">
<h1>Module</h1> Module   ListLabels</div>
<div class="section">
<h1>Documentation</h1> Module <b>ListLabels</b><br/>
 : <b>sig end</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
List operations.<div style="height: 1.00em;">
&#160;</div>
Some functions are flagged as not tail-recursive.  A tail-recursive function uses constant stack space, while a non-tail-recursive function uses stack space proportional to the length of its list argument, which can be a problem with very long lists.  When the function takes several list arguments, an approximate formula giving stack usage (in some unspecified constant unit) is shown in parentheses.<div style="height: 1.00em;">
&#160;</div>
The above considerations can usually be ignored if your lists are not longer than about 10000 elements.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val length</i> : <b>'a list -&gt; int</b><div style="height: 1.00em;">
&#160;</div>
Return the length (number of elements) of the given list.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val hd</i> : <b>'a list -&gt; 'a</b><div style="height: 1.00em;">
&#160;</div>
Return the first element of the given list. Raise <b>Failure hd</b> if the list is empty.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val tl</i> : <b>'a list -&gt; 'a list</b><div style="height: 1.00em;">
&#160;</div>
Return the given list without its first element. Raise <b>Failure tl</b> if the list is empty.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val nth</i> : <b>'a list -&gt; int -&gt; 'a</b><div style="height: 1.00em;">
&#160;</div>
Return the <b>n</b> -th element of the given list. The first element (head of the list) is at position 0. Raise <b>Failure nth</b> if the list is too short. Raise <b>Invalid_argument List.nth</b> if <b>n</b> is negative.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val rev</i> : <b>'a list -&gt; 'a list</b><div style="height: 1.00em;">
&#160;</div>
List reversal.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val append</i> : <b>'a list -&gt; 'a list -&gt; 'a list</b><div style="height: 1.00em;">
&#160;</div>
Catenate two lists.  Same function as the infix operator <b>@</b> . Not tail-recursive (length of the first argument).  The <b>@</b> operator is not tail-recursive either.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val rev_append</i> : <b>'a list -&gt; 'a list -&gt; 'a list</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>ListLabels.rev_append l1 l2</b> reverses <b>l1</b> and concatenates it to <b>l2</b> . This is equivalent to <b>ListLabels.rev</b> <b>l1 @ l2</b> , but <b>rev_append</b> is tail-recursive and more efficient.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val concat</i> : <b>'a list list -&gt; 'a list</b><div style="height: 1.00em;">
&#160;</div>
Concatenate a list of lists.  The elements of the argument are all concatenated together (in the same order) to give the result. Not tail-recursive (length of the argument + length of the longest sub-list).<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val flatten</i> : <b>'a list list -&gt; 'a list</b><div style="height: 1.00em;">
&#160;</div>
Same as <b>concat</b> .  Not tail-recursive (length of the argument + length of the longest sub-list).<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Iterators</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val iter</i> : <b>f:('a -&gt; unit) -&gt; 'a list -&gt; unit</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>ListLabels.iter f [a1; ...; an]</b> applies function <b>f</b> in turn to <b>a1; ...; an</b> . It is equivalent to <b>begin f a1; f a2; ...; f an; () end</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val iteri</i> : <b>f:(int -&gt; 'a -&gt; unit) -&gt; 'a list -&gt; unit</b><div style="height: 1.00em;">
&#160;</div>
Same as <b>ListLabels.iter</b> , but the function is applied to the index of the element as first argument (counting from 0), and the element itself as second argument.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>Since</b> 4.00.0<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val map</i> : <b>f:('a -&gt; 'b) -&gt; 'a list -&gt; 'b list</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>ListLabels.map f [a1; ...; an]</b> applies function <b>f</b> to <b>a1, ..., an</b> , and builds the list <b>[f a1; ...; f an]</b> with the results returned by <b>f</b> .  Not tail-recursive.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val mapi</i> : <b>f:(int -&gt; 'a -&gt; 'b) -&gt; 'a list -&gt; 'b list</b><div style="height: 1.00em;">
&#160;</div>
Same as <b>ListLabels.map</b> , but the function is applied to the index of the element as first argument (counting from 0), and the element itself as second argument.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>Since</b> 4.00.0<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val rev_map</i> : <b>f:('a -&gt; 'b) -&gt; 'a list -&gt; 'b list</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>ListLabels.rev_map f l</b> gives the same result as <b>ListLabels.rev</b> <b>(</b> <b>ListLabels.map</b> <b>f l)</b> , but is tail-recursive and more efficient.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val fold_left</i> : <b>f:('a -&gt; 'b -&gt; 'a) -&gt; init:'a -&gt; 'b list -&gt; 'a</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>ListLabels.fold_left f a [b1; ...; bn]</b> is <b>f (... (f (f a b1) b2) ...) bn</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val fold_right</i> : <b>f:('a -&gt; 'b -&gt; 'b) -&gt; 'a list -&gt; init:'b -&gt; 'b</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>ListLabels.fold_right f [a1; ...; an] b</b> is <b>f a1 (f a2 (... (f an b) ...))</b> .  Not tail-recursive.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Iterators on two lists</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val iter2</i> : <b>f:('a -&gt; 'b -&gt; unit) -&gt; 'a list -&gt; 'b list -&gt; unit</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>ListLabels.iter2 f [a1; ...; an] [b1; ...; bn]</b> calls in turn <b>f a1 b1; ...; f an bn</b> . Raise <b>Invalid_argument</b> if the two lists have different lengths.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val map2</i> : <b>f:('a -&gt; 'b -&gt; 'c) -&gt; 'a list -&gt; 'b list -&gt; 'c list</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>ListLabels.map2 f [a1; ...; an] [b1; ...; bn]</b> is <b>[f a1 b1; ...; f an bn]</b> . Raise <b>Invalid_argument</b> if the two lists have different lengths.  Not tail-recursive.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val rev_map2</i> : <b>f:('a -&gt; 'b -&gt; 'c) -&gt; 'a list -&gt; 'b list -&gt; 'c list</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>ListLabels.rev_map2 f l1 l2</b> gives the same result as <b>ListLabels.rev</b> <b>(</b> <b>ListLabels.map2</b> <b>f l1 l2)</b> , but is tail-recursive and more efficient.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val fold_left2</i> : <b>f:('a -&gt; 'b -&gt; 'c -&gt; 'a) -&gt; init:'a -&gt; 'b list -&gt; 'c list -&gt; 'a</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>ListLabels.fold_left2 f a [b1; ...; bn] [c1; ...; cn]</b> is <b>f (... (f (f a b1 c1) b2 c2) ...) bn cn</b> . Raise <b>Invalid_argument</b> if the two lists have different lengths.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val fold_right2</i> : <b>f:('a -&gt; 'b -&gt; 'c -&gt; 'c) -&gt; 'a list -&gt; 'b list -&gt; init:'c -&gt; 'c</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>ListLabels.fold_right2 f [a1; ...; an] [b1; ...; bn] c</b> is <b>f a1 b1 (f a2 b2 (... (f an bn c) ...))</b> . Raise <b>Invalid_argument</b> if the two lists have different lengths.  Not tail-recursive.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>List scanning</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val for_all</i> : <b>f:('a -&gt; bool) -&gt; 'a list -&gt; bool</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>for_all p [a1; ...; an]</b> checks if all elements of the list satisfy the predicate <b>p</b> . That is, it returns <b>(p a1) &amp;&amp; (p a2) &amp;&amp; ... &amp;&amp; (p an)</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val exists</i> : <b>f:('a -&gt; bool) -&gt; 'a list -&gt; bool</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>exists p [a1; ...; an]</b> checks if at least one element of the list satisfies the predicate <b>p</b> . That is, it returns <b>(p a1) || (p a2) || ... || (p an)</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val for_all2</i> : <b>f:('a -&gt; 'b -&gt; bool) -&gt; 'a list -&gt; 'b list -&gt; bool</b><div style="height: 1.00em;">
&#160;</div>
Same as <b>ListLabels.for_all</b> , but for a two-argument predicate. Raise <b>Invalid_argument</b> if the two lists have different lengths.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val exists2</i> : <b>f:('a -&gt; 'b -&gt; bool) -&gt; 'a list -&gt; 'b list -&gt; bool</b><div style="height: 1.00em;">
&#160;</div>
Same as <b>ListLabels.exists</b> , but for a two-argument predicate. Raise <b>Invalid_argument</b> if the two lists have different lengths.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val mem</i> : <b>'a -&gt; set:'a list -&gt; bool</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>mem a l</b> is true if and only if <b>a</b> is equal to an element of <b>l</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val memq</i> : <b>'a -&gt; set:'a list -&gt; bool</b><div style="height: 1.00em;">
&#160;</div>
Same as <b>ListLabels.mem</b> , but uses physical equality instead of structural equality to compare list elements.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>List searching</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val find</i> : <b>f:('a -&gt; bool) -&gt; 'a list -&gt; 'a</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>find p l</b> returns the first element of the list <b>l</b> that satisfies the predicate <b>p</b> . Raise <b>Not_found</b> if there is no value that satisfies <b>p</b> in the list <b>l</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val filter</i> : <b>f:('a -&gt; bool) -&gt; 'a list -&gt; 'a list</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>filter p l</b> returns all the elements of the list <b>l</b> that satisfy the predicate <b>p</b> .  The order of the elements in the input list is preserved.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val find_all</i> : <b>f:('a -&gt; bool) -&gt; 'a list -&gt; 'a list</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>find_all</b> is another name for <b>ListLabels.filter</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val partition</i> : <b>f:('a -&gt; bool) -&gt; 'a list -&gt; 'a list * 'a list</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>partition p l</b> returns a pair of lists <b>(l1, l2)</b> , where <b>l1</b> is the list of all the elements of <b>l</b> that satisfy the predicate <b>p</b> , and <b>l2</b> is the list of all the elements of <b>l</b> that do not satisfy <b>p</b> . The order of the elements in the input list is preserved.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Association lists</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val assoc</i> : <b>'a -&gt; ('a * 'b) list -&gt; 'b</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>assoc a l</b> returns the value associated with key <b>a</b> in the list of pairs <b>l</b> . That is, <b>assoc a [ ...; (a,b); ...] = b</b> if <b>(a,b)</b> is the leftmost binding of <b>a</b> in list <b>l</b> . Raise <b>Not_found</b> if there is no value associated with <b>a</b> in the list <b>l</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val assq</i> : <b>'a -&gt; ('a * 'b) list -&gt; 'b</b><div style="height: 1.00em;">
&#160;</div>
Same as <b>ListLabels.assoc</b> , but uses physical equality instead of structural equality to compare keys.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val mem_assoc</i> : <b>'a -&gt; map:('a * 'b) list -&gt; bool</b><div style="height: 1.00em;">
&#160;</div>
Same as <b>ListLabels.assoc</b> , but simply return true if a binding exists, and false if no bindings exist for the given key.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val mem_assq</i> : <b>'a -&gt; map:('a * 'b) list -&gt; bool</b><div style="height: 1.00em;">
&#160;</div>
Same as <b>ListLabels.mem_assoc</b> , but uses physical equality instead of structural equality to compare keys.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val remove_assoc</i> : <b>'a -&gt; ('a * 'b) list -&gt; ('a * 'b) list</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>remove_assoc a l</b> returns the list of pairs <b>l</b> without the first pair with key <b>a</b> , if any. Not tail-recursive.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val remove_assq</i> : <b>'a -&gt; ('a * 'b) list -&gt; ('a * 'b) list</b><div style="height: 1.00em;">
&#160;</div>
Same as <b>ListLabels.remove_assoc</b> , but uses physical equality instead of structural equality to compare keys.  Not tail-recursive.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Lists of pairs</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val split</i> : <b>('a * 'b) list -&gt; 'a list * 'b list</b><div style="height: 1.00em;">
&#160;</div>
Transform a list of pairs into a pair of lists: <b>split [(a1,b1); ...; (an,bn)]</b> is <b>([a1; ...; an], [b1; ...; bn])</b> . Not tail-recursive.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val combine</i> : <b>'a list -&gt; 'b list -&gt; ('a * 'b) list</b><div style="height: 1.00em;">
&#160;</div>
Transform a pair of lists into a list of pairs: <b>combine [a1; ...; an] [b1; ...; bn]</b> is <b>[(a1,b1); ...; (an,bn)]</b> . Raise <b>Invalid_argument</b> if the two lists have different lengths.  Not tail-recursive.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Sorting</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val sort</i> : <b>cmp:('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list</b><div style="height: 1.00em;">
&#160;</div>
Sort a list in increasing order according to a comparison function.  The comparison function must return 0 if its arguments compare as equal, a positive integer if the first is greater, and a negative integer if the first is smaller (see Array.sort for a complete specification).  For example, <b>Pervasives.compare</b> is a suitable comparison function. The resulting list is sorted in increasing order. <b>ListLabels.sort</b> is guaranteed to run in constant heap space (in addition to the size of the result list) and logarithmic stack space.<div style="height: 1.00em;">
&#160;</div>
The current implementation uses Merge Sort. It runs in constant heap space and logarithmic stack space.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val stable_sort</i> : <b>cmp:('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list</b><div style="height: 1.00em;">
&#160;</div>
Same as <b>ListLabels.sort</b> , but the sorting algorithm is guaranteed to be stable (i.e. elements that compare equal are kept in their original order) .<div style="height: 1.00em;">
&#160;</div>
The current implementation uses Merge Sort. It runs in constant heap space and logarithmic stack space.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val fast_sort</i> : <b>cmp:('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list</b><div style="height: 1.00em;">
&#160;</div>
Same as <b>ListLabels.sort</b> or <b>ListLabels.stable_sort</b> , whichever is faster on typical input.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val merge</i> : <b>cmp:('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list -&gt; 'a list</b><div style="height: 1.00em;">
&#160;</div>
Merge two lists: Assuming that <b>l1</b> and <b>l2</b> are sorted according to the comparison function <b>cmp</b> , <b>merge cmp l1 l2</b> will return a sorted list containting all the elements of <b>l1</b> and <b>l2</b> . If several elements compare equal, the elements of <b>l1</b> will be before the elements of <b>l2</b> . Not tail-recursive (sum of the lengths of the arguments).<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<table class="foot">
<tr>
<td class="foot-date">
2015-08-12</td>
<td class="foot-os">
OCamldoc</td>
</tr>
</table>
</div>
</body>
</html>

