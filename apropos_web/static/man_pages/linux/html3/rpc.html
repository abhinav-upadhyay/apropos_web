<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
RPC(3)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
RPC(3)</td>
<td class="head-vol">
Linux Programmer's Manual</td>
<td class="head-rtitle">
RPC(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> rpc - library routines for remote procedure calls</div>
<div class="section">
<h1>SYNOPSIS AND DESCRIPTION</h1> These routines allow C programs to make procedure calls on other machines across the network. First, the client calls a procedure to send a data packet to the server. Upon receipt of the packet, the server calls a dispatch routine to perform the requested service, and then sends back a reply. Finally, the procedure call returns to the client.<div class="spacer">
</div>
To take use of these routines, include the header file <i>&lt;rpc/rpc.h&gt;</i>.<div style="height: 1.00em;">
&#160;</div>
The prototypes below make use of the following types:<br/>
<div class="spacer">
</div>
<br/>
typedef int <i>bool_t</i>;<div class="spacer">
</div>
<br/>
typedef bool_t (*<i>xdrproc_t</i>) (XDR *, void *,...);<div class="spacer">
</div>
<br/>
typedef bool_t (*<i>resultproc_t</i>) (caddr_t resp,<br/>
                                struct sockaddr_in *raddr);<br/>
<br/>
<div class="spacer">
</div>
See the header files for the declarations of the <i>AUTH</i>, <i>CLIENT</i>, <i>SVCXPRT</i>, and <i>XDR</i> types.<div class="spacer">
</div>
<br/>
<b>void auth_destroy(AUTH *</b><i>auth</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
A macro that destroys the authentication information associated with <i>auth</i>. Destruction usually involves deallocation of private data structures. The use of <i>auth</i> is undefined after calling <b>auth_destroy</b>().</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>AUTH *authnone_create(void);</b><br/>
<dl>
<dt>
</dt>
<dd>
Create and return an RPC authentication handle that passes nonusable authentication information with each remote procedure call. This is the default authentication used by RPC.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>AUTH *authunix_create(char *</b><i>host</i><b>, int </b><i>uid</i><b>, int </b><i>gid</i><b>,</b><br/>
<b>                      int </b><i>len</i><b>, int *</b><i>aup_gids</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
Create and return an RPC authentication handle that contains authentication information. The parameter <i>host</i> is the name of the machine on which the information was created; <i>uid</i> is the user's user ID; <i>gid</i> is the user's current group ID; <i>len</i> and <i>aup_gids</i> refer to a counted array of groups to which the user belongs. It is easy to impersonate a user.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>AUTH *authunix_create_default(void);</b><br/>
<dl>
<dt>
</dt>
<dd>
Calls <b>authunix_create</b>() with the appropriate parameters.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>int callrpc(char *</b><i>host</i><b>, unsigned long </b><i>prognum</i><b>,</b><br/>
<b>            unsigned long </b><i>versnum</i><b>, unsigned long </b><i>procnum</i><b>,</b><br/>
<b>            xdrproc_t </b><i>inproc</i><b>, char *</b><i>in</i><b>,</b><br/>
<b>            xdrproc_t </b><i>outproc</i><b>, char *</b><i>out</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
Call the remote procedure associated with <i>prognum</i>, <i>versnum</i>, and <i>procnum</i> on the machine, <i>host</i>. The parameter <i>in</i> is the address of the procedure's argument(s), and <i>out</i> is the address of where to place the result(s); <i>inproc</i> is used to encode the procedure's parameters, and <i>outproc</i> is used to decode the procedure's results. This routine returns zero if it succeeds, or the value of <b>enum clnt_stat</b> cast to an integer if it fails. The routine <b>clnt_perrno</b>() is handy for translating failure statuses into messages.</dd>
</dl>
<dl>
<dt>
</dt>
<dd>
Warning: calling remote procedures with this routine uses UDP/IP as a transport; see <b>clntudp_create</b>() for restrictions. You do not have control of timeouts or authentication using this routine.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>enum clnt_stat clnt_broadcast(unsigned long </b><i>prognum</i><b>,</b><br/>
<b>                     unsigned long </b><i>versnum</i><b>, unsigned long </b><i>procnum</i><b>,</b><br/>
<b>                     xdrproc_t </b><i>inproc</i><b>, char *</b><i>in</i><b>,</b><br/>
<b>                     xdrproc_t </b><i>outproc</i><b>, char *</b><i>out</i><b>,</b><br/>
<b>                     resultproc_t </b><i>eachresult</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
Like <b>callrpc</b>(), except the call message is broadcast to all locally connected broadcast nets. Each time it receives a response, this routine calls <b>eachresult</b>(), whose form is:</dd>
</dl>
<dl>
<dt>
</dt>
<dd>
<br/>
<br/>
<b>eachresult(char *</b><i>out</i><b>, struct sockaddr_in *</b><i>addr</i><b>);</b><br/>
<br/>
</dd>
</dl>
<dl>
<dt>
</dt>
<dd>
where <i>out</i> is the same as <i>out</i> passed to <b>clnt_broadcast</b>(), except that the remote procedure's output is decoded there; <i>addr</i> points to the address of the machine that sent the results. If <b>eachresult</b>() returns zero, <b>clnt_broadcast</b>() waits for more replies; otherwise it returns with appropriate status.</dd>
</dl>
<dl>
<dt>
</dt>
<dd>
Warning: broadcast sockets are limited in size to the maximum transfer unit of the data link. For ethernet, this value is 1500 bytes.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>enum clnt_stat clnt_call(CLIENT *</b><i>clnt</i><b>, unsigned long </b><i>procnum</i><b>,</b><br/>
<b>                    xdrproc_t </b><i>inproc</i><b>, char *</b><i>in</i><b>,</b><br/>
<b>                    xdrproc_t </b><i>outproc</i><b>, char *</b><i>out</i><b>,</b><br/>
<b>                    struct timeval </b><i>tout</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
A macro that calls the remote procedure <i>procnum</i> associated with the client handle, <i>clnt</i>, which is obtained with an RPC client creation routine such as <b>clnt_create</b>(). The parameter <i>in</i> is the address of the procedure's argument(s), and <i>out</i> is the address of where to place the result(s); <i>inproc</i> is used to encode the procedure's parameters, and <i>outproc</i> is used to decode the procedure's results; <i>tout</i> is the time allowed for results to come back.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>clnt_destroy(CLIENT *</b><i>clnt</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
A macro that destroys the client's RPC handle. Destruction usually involves deallocation of private data structures, including <i>clnt</i> itself. Use of <i>clnt</i> is undefined after calling <b>clnt_destroy</b>(). If the RPC library opened the associated socket, it will close it also. Otherwise, the socket remains open.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>CLIENT *clnt_create(char *</b><i>host</i><b>, unsigned long </b><i>prog</i><b>,</b><br/>
<b>                    unsigned long </b><i>vers</i><b>, char *</b><i>proto</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
Generic client creation routine. <i>host</i> identifies the name of the remote host where the server is located. <i>proto</i> indicates which kind of transport protocol to use. The currently supported values for this field are &#8220;udp&#8221; and &#8220;tcp&#8221;. Default timeouts are set, but can be modified using <b>clnt_control</b>().</dd>
</dl>
<dl>
<dt>
</dt>
<dd>
Warning: Using UDP has its shortcomings. Since UDP-based RPC messages can only hold up to 8 Kbytes of encoded data, this transport cannot be used for procedures that take large arguments or return huge results.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>bool_t clnt_control(CLIENT *</b><i>cl</i><b>, int </b><i>req</i><b>, char *</b><i>info</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
A macro used to change or retrieve various information about a client object. <i>req</i> indicates the type of operation, and <i>info</i> is a pointer to the information. For both UDP and TCP, the supported values of <i>req</i> and their argument types and what they do are:</dd>
</dl>
<dl>
<dt>
</dt>
<dd>
<br/>
<br/>
<b>CLSET_TIMEOUT</b>  <i>struct timeval</i> // set total timeout<br/>
<b>CLGET_TIMEOUT</b>  <i>struct timeval</i> // get total timeout<br/>
<br/>
</dd>
</dl>
<dl>
<dt>
</dt>
<dd>
Note: if you set the timeout using <b>clnt_control</b>(), the timeout parameter passed to <b>clnt_call</b>() will be ignored in all future calls.</dd>
</dl>
<dl>
<dt>
</dt>
<dd>
<br/>
<br/>
<b>CLGET_SERVER_ADDR</b>  <i>struct sockaddr_in </i> // get server's address<br/>
<br/>
</dd>
</dl>
<dl>
<dt>
</dt>
<dd>
The following operations are valid for UDP only:</dd>
</dl>
<dl>
<dt>
</dt>
<dd>
<br/>
<br/>
<b>CLSET_RETRY_TIMEOUT</b>  <i>struct timeval</i> // set the retry timeout<br/>
<b>CLGET_RETRY_TIMEOUT</b>  <i>struct timeval</i> // get the retry timeout<br/>
<br/>
</dd>
</dl>
<dl>
<dt>
</dt>
<dd>
The retry timeout is the time that &quot;UDP RPC&quot; waits for the server to reply before retransmitting the request.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>clnt_freeres(CLIENT * </b><i>clnt</i><b>, xdrproc_t </b><i>outproc</i><b>, char *</b><i>out</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
A macro that frees any data allocated by the RPC/XDR system when it decoded the results of an RPC call. The parameter <i>out</i> is the address of the results, and <i>outproc</i> is the XDR routine describing the results. This routine returns one if the results were successfully freed, and zero otherwise.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>void clnt_geterr(CLIENT *</b><i>clnt</i><b>, struct rpc_err *</b><i>errp</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
A macro that copies the error structure out of the client handle to the structure at address <i>errp</i>.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>void clnt_pcreateerror(char *</b><i>s</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
Print a message to standard error indicating why a client RPC handle could not be created. The message is prepended with string <i>s</i> and a colon. Used when a <b>clnt_create</b>(), <b>clntraw_create</b>(), <b>clnttcp_create</b>(), or <b>clntudp_create</b>() call fails.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>void clnt_perrno(enum clnt_stat </b><i>stat</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
Print a message to standard error corresponding to the condition indicated by <i>stat</i>. Used after <b>callrpc</b>().</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>clnt_perror(CLIENT *</b><i>clnt</i><b>, char *</b><i>s</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
Print a message to standard error indicating why an RPC call failed; <i>clnt</i> is the handle used to do the call. The message is prepended with string <i>s</i> and a colon. Used after <b>clnt_call</b>().</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>char *clnt_spcreateerror(char *</b><i>s</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
Like <b>clnt_pcreateerror</b>(), except that it returns a string instead of printing to the standard error.</dd>
</dl>
<dl>
<dt>
</dt>
<dd>
Bugs: returns pointer to static data that is overwritten on each call.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>char *clnt_sperrno(enum clnt_stat </b><i>stat</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
Take the same arguments as <b>clnt_perrno</b>(), but instead of sending a message to the standard error indicating why an RPC call failed, return a pointer to a string which contains the message. The string ends with a NEWLINE.</dd>
</dl>
<dl>
<dt>
</dt>
<dd>
<b>clnt_sperrno</b>() is used instead of <b>clnt_perrno</b>() if the program does not have a standard error (as a program running as a server quite likely does not), or if the programmer does not want the message to be output with <b>printf</b>(3), or if a message format different than that supported by <b>clnt_perrno</b>() is to be used. Note: unlike <b>clnt_sperror</b>() and <b>clnt_spcreaterror</b>(), <b>clnt_sperrno</b>() returns pointer to static data, but the result will not get overwritten on each call.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>char *clnt_sperror(CLIENT *</b><i>rpch</i><b>, char *</b><i>s</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
Like <b>clnt_perror</b>(), except that (like <b>clnt_sperrno</b>()) it returns a string instead of printing to standard error.</dd>
</dl>
<dl>
<dt>
</dt>
<dd>
Bugs: returns pointer to static data that is overwritten on each call.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>CLIENT *clntraw_create(unsigned long </b><i>prognum</i><b>, unsigned long </b><i>versnum</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
This routine creates a toy RPC client for the remote program <i>prognum</i>, version <i>versnum</i>. The transport used to pass messages to the service is actually a buffer within the process's address space, so the corresponding RPC server should live in the same address space; see <b>svcraw_create</b>(). This allows simulation of RPC and acquisition of RPC overheads, such as round trip times, without any kernel interference. This routine returns NULL if it fails.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>CLIENT *clnttcp_create(struct sockaddr_in *</b><i>addr</i><b>,</b><br/>
<b>                unsigned long </b><i>prognum</i><b>, unsigned long </b><i>versnum</i><b>,</b><br/>
<b>                int *</b><i>sockp</i><b>, unsigned int </b><i>sendsz</i><b>, unsigned int </b><i>recvsz</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
This routine creates an RPC client for the remote program <i>prognum</i>, version <i>versnum</i>; the client uses TCP/IP as a transport. The remote program is located at Internet address <i>*addr</i>. If  <i>addr-&gt;sin_port</i> is zero, then it is set to the actual port that the remote program is listening on (the remote <b>portmap</b> service is consulted for this information). The parameter <i>sockp</i> is a socket; if it is <b>RPC_ANYSOCK</b>, then this routine opens a new one and sets <i>sockp</i>. Since TCP-based RPC uses buffered I/O, the user may specify the size of the send and receive buffers with the parameters <i>sendsz</i> and <i>recvsz</i>; values of zero choose suitable defaults. This routine returns NULL if it fails.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>CLIENT *clntudp_create(struct sockaddr_in *</b><i>addr</i><b>,</b><br/>
<b>                unsigned long </b><i>prognum</i><b>, unsigned long </b><i>versnum</i><b>,</b><br/>
<b>                struct timeval </b><i>wait</i><b>, int *</b><i>sockp</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
This routine creates an RPC client for the remote program <i>prognum</i>, version <i>versnum</i>; the client uses use UDP/IP as a transport. The remote program is located at Internet address <i>addr</i>. If  <i>addr-&gt;sin_port</i> is zero, then it is set to actual port that the remote program is listening on (the remote <b>portmap</b> service is consulted for this information). The parameter <i>sockp</i> is a socket; if it is <b>RPC_ANYSOCK</b>, then this routine opens a new one and sets <i>sockp</i>. The UDP transport resends the call message in intervals of <i>wait</i> time until a response is received or until the call times out. The total time for the call to time out is specified by <b>clnt_call</b>().</dd>
</dl>
<dl>
<dt>
</dt>
<dd>
Warning: since UDP-based RPC messages can only hold up to 8 Kbytes of encoded data, this transport cannot be used for procedures that take large arguments or return huge results.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>CLIENT *clntudp_bufcreate(struct sockaddr_in *</b><i>addr</i><b>,</b><br/>
<b>            unsigned long </b><i>prognum</i><b>, unsigned long </b><i>versnum</i><b>,</b><br/>
<b>            struct timeval </b><i>wait</i><b>, int *</b><i>sockp</i><b>,</b><br/>
<b>            unsigned int </b><i>sendsize</i><b>, unsigned int </b><i>recosize</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
This routine creates an RPC client for the remote program <i>prognum</i>, on <i>versnum</i>; the client uses use UDP/IP as a transport. The remote program is located at Internet address <i>addr</i>. If  <i>addr-&gt;sin_port</i> is zero, then it is set to actual port that the remote program is listening on (the remote <b>portmap</b> service is consulted for this information). The parameter <i>sockp</i> is a socket; if it is <b>RPC_ANYSOCK</b>, then this routine opens a new one and sets <i>sockp</i>. The UDP transport resends the call message in intervals of <i>wait</i> time until a response is received or until the call times out. The total time for the call to time out is specified by <b>clnt_call</b>().</dd>
</dl>
<dl>
<dt>
</dt>
<dd>
This allows the user to specify the maximum packet size for sending and receiving UDP-based RPC messages.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>void get_myaddress(struct sockaddr_in *</b><i>addr</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
Stuff the machine's IP address into <i>*addr</i>, without consulting the library routines that deal with <i>/etc/hosts</i>. The port number is always set to <b>htons(PMAPPORT)</b>.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>struct pmaplist *pmap_getmaps(struct sockaddr_in *</b><i>addr</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
A user interface to the <b>portmap</b> service, which returns a list of the current RPC program-to-port mappings on the host located at IP address <i>*addr</i>. This routine can return NULL. The command <i>rpcinfo&#160;-p</i> uses this routine.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>unsigned short pmap_getport(struct sockaddr_in *</b><i>addr</i><b>,</b><br/>
<b>                    unsigned long </b><i>prognum</i><b>, unsigned long </b><i>versnum</i><b>,</b><br/>
<b>                    unsigned int </b><i>protocol</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
A user interface to the <b>portmap</b> service, which returns the port number on which waits a service that supports program number <i>prognum</i>, version <i>versnum</i>, and speaks the transport protocol associated with <i>protocol</i>. The value of <i>protocol</i> is most likely <b>IPPROTO_UDP</b> or <b>IPPROTO_TCP</b>. A return value of zero means that the mapping does not exist or that the RPC system failed to contact the remote <b>portmap</b> service. In the latter case, the global variable <i>rpc_createerr</i> contains the RPC status.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>enum clnt_stat pmap_rmtcall(struct sockaddr_in *</b><i>addr</i><b>,</b><br/>
<b>                    unsigned long </b><i>prognum</i><b>, unsigned long </b><i>versnum</i><b>,</b><br/>
<b>                    unsigned long </b><i>procnum</i><b>,</b><br/>
<b>                    xdrproc_t </b><i>inproc</i><b>, char *</b><i>in</i><b>,</b><br/>
<b>                    xdrproc_t </b><i>outproc</i><b>, char *</b><i>out</i><b>,</b><br/>
<b>                    struct timeval </b><i>tout</i><b>, unsigned long *</b><i>portp</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
A user interface to the <b>portmap</b> service, which instructs <b>portmap</b> on the host at IP address <i>*addr</i> to make an RPC call on your behalf to a procedure on that host. The parameter <i>*portp</i> will be modified to the program's port number if the procedure succeeds. The definitions of other parameters are discussed in <b>callrpc</b>() and <b>clnt_call</b>(). This procedure should be used for a &#8220;ping&#8221; and nothing else. See also <b>clnt_broadcast</b>().</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>bool_t pmap_set(unsigned long </b><i>prognum</i><b>, unsigned long </b><i>versnum</i><b>,</b><br/>
<b>                unsigned int </b><i>protocol</i><b>, unsigned short </b><i>port</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
A user interface to the <b>portmap</b> service, which establishes a mapping between the triple [<i>prognum</i>,<i>versnum</i>,<i>protocol]</i> and <i>port</i> on the machine's <b>portmap</b> service. The value of <i>protocol</i> is most likely <b>IPPROTO_UDP</b> or <b>IPPROTO_TCP</b>. This routine returns one if it succeeds, zero otherwise. Automatically done by <b>svc_register</b>().</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>bool_t pmap_unset(unsigned long </b><i>prognum</i><b>, unsigned long </b><i>versnum</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
A user interface to the <b>portmap</b> service, which destroys all mapping between the triple [<i>prognum</i>,<i>versnum</i>,<i>*]</i> and <b>ports</b> on the machine's <b>portmap</b> service. This routine returns one if it succeeds, zero otherwise.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>int registerrpc(unsigned long </b><i>prognum</i><b>, unsigned long </b><i>versnum</i><b>,</b><br/>
<b>                unsigned long </b><i>procnum</i><b>, char *(*</b><i>procname</i><b>)(char *),</b><br/>
<b>                xdrproc_t </b><i>inproc</i><b>, xdrproc_t </b><i>outproc</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
Register procedure <i>procname</i> with the RPC service package. If a request arrives for program <i>prognum</i>, version <i>versnum</i>, and procedure <i>procnum</i>, <i>procname</i> is called with a pointer to its parameter(s); <i>progname</i> should return a pointer to its static result(s); <i>inproc</i> is used to decode the parameters while <i>outproc</i> is used to encode the results. This routine returns zero if the registration succeeded, -1 otherwise.</dd>
</dl>
<dl>
<dt>
</dt>
<dd>
Warning: remote procedures registered in this form are accessed using the UDP/IP transport; see <b>svcudp_create</b>() for restrictions.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>struct rpc_createerr </b><i>rpc_createerr</i><b>;</b><br/>
<dl>
<dt>
</dt>
<dd>
A global variable whose value is set by any RPC client creation routine that does not succeed. Use the routine <b>clnt_pcreateerror</b>() to print the reason why.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>void svc_destroy(SVCXPRT *</b><i>xprt</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
A macro that destroys the RPC service transport handle, <i>xprt</i>. Destruction usually involves deallocation of private data structures, including <i>xprt</i> itself. Use of <i>xprt</i> is undefined after calling this routine.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>fd_set </b><i>svc_fdset</i><b>;</b><br/>
<dl>
<dt>
</dt>
<dd>
A global variable reflecting the RPC service side's read file descriptor bit mask; it is suitable as a parameter to the <b>select</b>(2) system call. This is only of interest if a service implementor does not call <b>svc_run</b>(), but rather does his own asynchronous event processing. This variable is read-only (do not pass its address to <b>select</b>(2)!), yet it may change after calls to <b>svc_getreqset</b>() or any creation routines.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>int </b><i>svc_fds</i><b>;</b><br/>
<dl>
<dt>
</dt>
<dd>
Similar to <b>svc_fdset</b>, but limited to 32 descriptors. This interface is obsoleted by <b>svc_fdset</b>.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>svc_freeargs(SVCXPRT *</b><i>xprt</i><b>, xdrproc_t </b><i>inproc</i><b>, char *</b><i>in</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
A macro that frees any data allocated by the RPC/XDR system when it decoded the arguments to a service procedure using <b>svc_getargs</b>(). This routine returns 1 if the results were successfully freed, and zero otherwise.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>svc_getargs(SVCXPRT *</b><i>xprt</i><b>, xdrproc_t </b><i>inproc</i><b>, char *</b><i>in</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
A macro that decodes the arguments of an RPC request associated with the RPC service transport handle, <i>xprt</i>. The parameter <i>in</i> is the address where the arguments will be placed; <i>inproc</i> is the XDR routine used to decode the arguments. This routine returns one if decoding succeeds, and zero otherwise.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>struct sockaddr_in *svc_getcaller(SVCXPRT *</b><i>xprt</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
The approved way of getting the network address of the caller of a procedure associated with the RPC service transport handle, <i>xprt</i>.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>void svc_getreqset(fd_set *</b><i>rdfds</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
This routine is only of interest if a service implementor does not call <b>svc_run</b>(), but instead implements custom asynchronous event processing. It is called when the <b>select</b>(2) system call has determined that an RPC request has arrived on some RPC socket(s); <i>rdfds</i> is the resultant read file descriptor bit mask. The routine returns when all sockets associated with the value of <i>rdfds</i> have been serviced.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>void svc_getreq(int </b><i>rdfds</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
Similar to <b>svc_getreqset</b>(), but limited to 32 descriptors. This interface is obsoleted by <b>svc_getreqset</b>().</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>bool_t svc_register(SVCXPRT *</b><i>xprt</i><b>, unsigned long </b><i>prognum</i><b>,</b><br/>
<b>                    unsigned long </b><i>versnum</i><b>,</b><br/>
<b>                    void (*</b><i>dispatch</i><b>)(svc_req *, SVCXPRT *),</b><br/>
<b>                    unsigned long </b><i>protocol</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
Associates <i>prognum</i> and <i>versnum</i> with the service dispatch procedure, <i>dispatch</i>. If <i>protocol</i> is zero, the service is not registered with the <b>portmap</b> service. If <i>protocol</i> is nonzero, then a mapping of the triple [<i>prognum</i>,<i>versnum</i>,<i>protocol]</i> to  <i>xprt-&gt;xp_port</i> is established with the local <b>portmap</b> service (generally <i>protocol</i> is zero, <b>IPPROTO_UDP</b> or <b>IPPROTO_TCP</b>). The procedure <i>dispatch</i> has the following form:<br/>
<div class="spacer">
</div>
<br/>
dispatch(struct svc_req *request, SVCXPRT *xprt);<br/>
<br/>
</dd>
</dl>
<dl>
<dt>
</dt>
<dd>
The <b>svc_register</b>() routine returns one if it succeeds, and zero otherwise.</dd>
</dl>
<div class="spacer">
</div>
<b>void svc_run(void);</b><br/>
<dl>
<dt>
</dt>
<dd>
This routine never returns. It waits for RPC requests to arrive, and calls the appropriate service procedure using <b>svc_getreq</b>() when one arrives. This procedure is usually waiting for a <b>select</b>(2) system call to return.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>bool_t svc_sendreply(SVCXPRT *</b><i>xprt</i><b>, xdrproc_t </b><i>outproc</i><b>, char *</b><i>out</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
Called by an RPC service's dispatch routine to send the results of a remote procedure call. The parameter <i>xprt</i> is the request's associated transport handle; <i>outproc</i> is the XDR routine which is used to encode the results; and <i>out</i> is the address of the results. This routine returns one if it succeeds, zero otherwise.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>void svc_unregister(unsigned long </b><i>prognum</i><b>, unsigned long </b><i>versnum</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
Remove all mapping of the double [<i>prognum</i>,<i>versnum</i>] to dispatch routines, and of the triple [<i>prognum</i>,<i>versnum</i>,<i>*]</i> to port number.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>void svcerr_auth(SVCXPRT *</b><i>xprt</i><b>, enum auth_stat </b><i>why</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
Called by a service dispatch routine that refuses to perform a remote procedure call due to an authentication error.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>void svcerr_decode(SVCXPRT *</b><i>xprt</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
Called by a service dispatch routine that cannot successfully decode its parameters. See also <b>svc_getargs</b>().</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>void svcerr_noproc(SVCXPRT *</b><i>xprt</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
Called by a service dispatch routine that does not implement the procedure number that the caller requests.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>void svcerr_noprog(SVCXPRT *</b><i>xprt</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
Called when the desired program is not registered with the RPC package. Service implementors usually do not need this routine.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>void svcerr_progvers(SVCXPRT *</b><i>xprt</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
Called when the desired version of a program is not registered with the RPC package. Service implementors usually do not need this routine.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>void svcerr_systemerr(SVCXPRT *</b><i>xprt</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
Called by a service dispatch routine when it detects a system error not covered by any particular protocol. For example, if a service can no longer allocate storage, it may call this routine.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>void svcerr_weakauth(SVCXPRT *</b><i>xprt</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
Called by a service dispatch routine that refuses to perform a remote procedure call due to insufficient authentication parameters. The routine calls <b>svcerr_auth(xprt, AUTH_TOOWEAK)</b>.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>SVCXPRT *svcfd_create(int </b><i>fd</i><b>, unsigned int </b><i>sendsize</i><b>,</b><br/>
<b>                      unsigned int </b><i>recvsize</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
Create a service on top of any open descriptor. Typically, this descriptor is a connected socket for a stream protocol such as TCP. <i>sendsize</i> and <i>recvsize</i> indicate sizes for the send and receive buffers. If they are zero, a reasonable default is chosen.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>SVCXPRT *svcraw_create(void);</b><br/>
<dl>
<dt>
</dt>
<dd>
This routine creates a toy RPC service transport, to which it returns a pointer. The transport is really a buffer within the process's address space, so the corresponding RPC client should live in the same address space; see <b>clntraw_create</b>(). This routine allows simulation of RPC and acquisition of RPC overheads (such as round trip times), without any kernel interference. This routine returns NULL if it fails.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>SVCXPRT *svctcp_create(int </b><i>sock</i><b>, unsigned int </b><i>send_buf_size</i><b>,</b><br/>
<b>                       unsigned int </b><i>recv_buf_size</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
This routine creates a TCP/IP-based RPC service transport, to which it returns a pointer. The transport is associated with the socket <i>sock</i>, which may be <b>RPC_ANYSOCK</b>, in which case a new socket is created. If the socket is not bound to a local TCP port, then this routine binds it to an arbitrary port. Upon completion,  <i>xprt-&gt;xp_sock</i> is the transport's socket descriptor, and  <i>xprt-&gt;xp_port</i> is the transport's port number. This routine returns NULL if it fails. Since TCP-based RPC uses buffered I/O, users may specify the size of buffers; values of zero choose suitable defaults.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>SVCXPRT *svcudp_bufcreate(int </b><i>sock</i><b>, unsigned int </b><i>sendsize</i><b>,</b><br/>
<b>                          unsigned int </b><i>recosize</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
This routine creates a UDP/IP-based RPC service transport, to which it returns a pointer. The transport is associated with the socket <i>sock</i>, which may be <b>RPC_ANYSOCK</b>, in which case a new socket is created. If the socket is not bound to a local UDP port, then this routine binds it to an arbitrary port. Upon completion,  <i>xprt-&gt;xp_sock</i> is the transport's socket descriptor, and  <i>xprt-&gt;xp_port</i> is the transport's port number. This routine returns NULL if it fails.</dd>
</dl>
<dl>
<dt>
</dt>
<dd>
This allows the user to specify the maximum packet size for sending and receiving UDP-based RPC messages.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>SVCXPRT *svcudp_create(int </b><i>sock</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
This call is equivalent to  <i>svcudp_bufcreate(sock,SZ,SZ)</i> for some default size  <i>SZ</i>.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>bool_t xdr_accepted_reply(XDR *</b><i>xdrs</i><b>, struct accepted_reply *</b><i>ar</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
Used for encoding RPC reply messages. This routine is useful for users who wish to generate RPC-style messages without using the RPC package.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>bool_t xdr_authunix_parms(XDR *</b><i>xdrs</i><b>, struct authunix_parms *</b><i>aupp</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
Used for describing UNIX credentials. This routine is useful for users who wish to generate these credentials without using the RPC authentication package.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>void xdr_callhdr(XDR *</b><i>xdrs</i><b>, struct rpc_msg *</b><i>chdr</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
Used for describing RPC call header messages. This routine is useful for users who wish to generate RPC-style messages without using the RPC package.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>bool_t xdr_callmsg(XDR *</b><i>xdrs</i><b>, struct rpc_msg *</b><i>cmsg</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
Used for describing RPC call messages. This routine is useful for users who wish to generate RPC-style messages without using the RPC package.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>bool_t xdr_opaque_auth(XDR *</b><i>xdrs</i><b>, struct opaque_auth *</b><i>ap</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
Used for describing RPC authentication information messages. This routine is useful for users who wish to generate RPC-style messages without using the RPC package.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>bool_t xdr_pmap(XDR *</b><i>xdrs</i><b>, struct pmap *</b><i>regs</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
Used for describing parameters to various <b>portmap</b> procedures, externally. This routine is useful for users who wish to generate these parameters without using the <b>pmap</b> interface.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>bool_t xdr_pmaplist(XDR *</b><i>xdrs</i><b>, struct pmaplist **</b><i>rp</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
Used for describing a list of port mappings, externally. This routine is useful for users who wish to generate these parameters without using the <b>pmap</b> interface.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>bool_t xdr_rejected_reply(XDR *</b><i>xdrs</i><b>, struct rejected_reply *</b><i>rr</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
Used for describing RPC reply messages. This routine is useful for users who wish to generate RPC-style messages without using the RPC package.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>bool_t xdr_replymsg(XDR *</b><i>xdrs</i><b>, struct rpc_msg *</b><i>rmsg</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
Used for describing RPC reply messages. This routine is useful for users who wish to generate RPC style messages without using the RPC package.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>void xprt_register(SVCXPRT *</b><i>xprt</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
After RPC service transport handles are created, they should register themselves with the RPC service package. This routine modifies the global variable <i>svc_fds</i>. Service implementors usually do not need this routine.</dd>
</dl>
<div class="spacer">
</div>
<br/>
<b>void xprt_unregister(SVCXPRT *</b><i>xprt</i><b>);</b><br/>
<dl>
<dt>
</dt>
<dd>
Before an RPC service transport handle is destroyed, it should unregister itself with the RPC service package. This routine modifies the global variable <i>svc_fds</i>. Service implementors usually do not need this routine.</dd>
</dl>
</div>
<div class="section">
<h1>SEE ALSO</h1> <b>xdr</b>(3)<div style="height: 0.00em;">
&#160;</div>
The following manuals:<div style="margin-left: 5.00ex;">
Remote Procedure Calls: Protocol Specification<div style="height: 0.00em;">
&#160;</div>
Remote Procedure Call Programming Guide<div style="height: 0.00em;">
&#160;</div>
rpcgen Programming Guide<div style="height: 0.00em;">
&#160;</div>
</div>
<i>RPC: Remote Procedure Call Protocol Specification</i>, RFC&#160;1050, Sun Microsystems, Inc., USC-ISI.</div>
<div class="section">
<h1>COLOPHON</h1> This page is part of release 3.35 of the Linux <i>man-pages</i> project. A description of the project, and information about reporting bugs, can be found at http://man7.org/linux/man-pages/.</div>
<table class="foot">
<tr>
<td class="foot-date">
2008-07-17</td>
<td class="foot-os">
</td>
</tr>
</table>
</div>
</body>
</html>

