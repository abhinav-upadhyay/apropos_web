<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Glib::Object::Subclass(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Glib::Object::Subclass(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
Glib::Object::Subclass(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Glib::Object::Subclass - register a perl class as a GObject class</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
  use Glib::Object::Subclass<br/>
     Some::Base::Class::,   # parent class, derived from Glib::Object<br/>
     signals =&gt; {<br/>
            something_changed =&gt; {<br/>
               class_closure =&gt; sub { do_something_fun () },<br/>
               flags         =&gt; [qw(run-first)],<br/>
               return_type   =&gt; undef,<br/>
               param_types   =&gt; [],<br/>
            },<br/>
            some_existing_signal =&gt; \&amp;class_closure_override,<br/>
     },<br/>
     properties =&gt; [<br/>
        Glib::ParamSpec-&gt;string (<br/>
           'some_string',<br/>
           'Some String Property',<br/>
           'This property is a string that is used as an example',<br/>
           'default value',<br/>
           [qw/readable writable/]<br/>
        ),<br/>
     ];<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> This module allows you to create your own GObject classes, which is useful to e.g. implement your own Gtk2 widgets.<div class="spacer">
</div>
It doesn't &quot;export&quot; anything into your namespace, but acts more like a pragmatic module that modifies your class to make it work as a GObject class.<div class="spacer">
</div>
You may be wondering why you can't just bless a Glib::Object into a different package and add some subs.  Well, if you aren't interested in object parameters, signals, or having your new class interoperate transparently with other GObject-based modules (e.g., Gtk2 and friends), then you can just re-bless.<div class="spacer">
</div>
However, a GObject's signals, properties, virtual functions, and GInterface implementations are specific to its GObjectClass.  If you want to create a new GObject which was a derivative of GtkDrawingArea, but adds a new signal, you must create a new GObjectClass to which to add the new signal. If you don't, then  <i>all</i> of the GtkDrawingAreas in your application will get that new signal!<div class="spacer">
</div>
Thus, the only way to create a new signal or object property in the Perl bindings for Glib is to register a new subclass with the GLib type system via  <i>Glib::Type::register_object()</i>. The Glib::Object::Subclass module is a Perl-developer-friendly interface to this bit of paradigm mismatch.<div class="subsection">
<h2>USAGE</h2> This module works similar to the &quot;use base&quot; pragma in that it registers the current package as a subclass of some other class (which must be a GObjectClass implemented either in C or some other language).<div class="spacer">
</div>
The pragma requires at least one argument, the parent class name.  The remaining arguments are key/value pairs, in any order, all optional:<dl>
<dt>
- properties =&gt; []</dt>
<dd>
Add object properties; see &quot;PROPERTIES&quot;.</dd>
</dl>
<dl>
<dt>
- signals =&gt; {}</dt>
<dd>
Add or override signals; see &quot;SIGNALS&quot; and &quot;OVERRIDING BASE METHODS&quot;.</dd>
</dl>
<dl>
<dt>
- interfaces =&gt; []</dt>
<dd>
Add GInterfaces to your class; see &quot;INTERFACES&quot;.</dd>
</dl>
<div class="spacer">
</div>
(Actually, these parameters are all passed straight through to  <i>Glib::Type::register_object()</i>, adding __PACKAGE__ (the current package name) as the name of the new child class.)</div>
<div class="subsection">
<h2>OBJECT METHODS AND FUNCTIONS</h2> The following methods are either added to your class on request (not yet implemented), or by default unless your own class implements them itself. This means that all these methods and functions will get sensible default implementations unless explicitly overwritten by you (by defining your own version).<div class="spacer">
</div>
Except for &quot;new&quot;, all of the following are <i>functions</i> and no  <i>methods</i>. That means that you should <i>not</i> call the superclass method. Instead, the GObject system will call these functions per class as required, emulating normal inheritance.<dl>
<dt>
$class-&gt;new (attr =&gt; value, ...)</dt>
<dd>
The default constructor just calls &quot;Glib::Object::new&quot;, which allows you to set properties on the newly created object. This is done because many &quot;new&quot; methods inherited by Gtk2 or other libraries don't have &quot;new&quot; methods suitable for subclassing.</dd>
</dl>
<dl>
<dt>
INIT_INSTANCE $self                                 [not a method]</dt>
<dd>
&quot;INIT_INSTANCE&quot; is called on each class in the hierarchy as the object is being created (i.e., from &quot;Glib::Object::new&quot; or our default &quot;new&quot;). Use this function to initialize any member data. The default implementation will leave the object untouched.</dd>
</dl>
<dl>
<dt>
GET_PROPERTY $self, $pspec                          [not a method]</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
SET_PROPERTY $self, $pspec, $newval                 [not a method]</dt>
<dd>
&quot;GET_PROPERTY&quot; and &quot;SET_PROPERTY&quot; are called whenever somebody does &quot;$object-&gt;get ($propname)&quot; or &quot;$object-&gt;set ($propname =&gt; $newval)&quot; (from other languages, too).  The default implementations hold property values in the object hash, equivalent to<div style="height: 1.00em;">
&#160;</div>
<br/>
   sub GET_PROPERTY {<br/>
     my ($self, $pspec) = @_;<br/>
     my $pname = $pspec-&gt;get_name;<br/>
     return (exists $self-&gt;{$pname} ? $self-&gt;{$pname}<br/>
             : $pspec-&gt;get_default_value);  # until set<br/>
   }<br/>
   sub SET_PROPERTY {<br/>
     my ($self, $pspec, $newval) = @_;<br/>
     $self-&gt;{$pspec-&gt;get_name} = $newval;<br/>
   }<br/>
<div style="height: 1.00em;">
&#160;</div>
Because &quot;$pspec-&gt;get_name&quot; converts hyphens to underscores, a property &quot;line-style&quot; is in the hash as &quot;line_style&quot;.<div style="height: 1.00em;">
&#160;</div>
These methods let you store/fetch properties in any way you need to.  They don't have to be in the hash, you can calculate something, read a file, whatever.<div style="height: 1.00em;">
&#160;</div>
Most often you'll write your own &quot;SET_PROPERTY&quot; so you can take action when a property changes, like redraw or resize a widget.  Eg.<div style="height: 1.00em;">
&#160;</div>
<br/>
   sub SET_PROPERTY {<br/>
     my ($self, $pspec, $newval) = @_;<br/>
     my $pname = $pspec-&gt;get_name<br/>
     $self-&gt;{$pname} = $newval; # ready for default GET_PROPERTY<br/>
<br/>
     if ($pname eq 'line_style') {<br/>
       $self-&gt;queue_draw;  # redraw with new lines<br/>
     }<br/>
   }<br/>
<div style="height: 1.00em;">
&#160;</div>
Care must be taken with boxed non-reference-counted types such as &quot;Gtk2::Gdk::Color&quot;.  In &quot;SET_PROPERTY&quot; the $newval is generally good only for the duration of the call.  Use &quot;copy&quot; or similar if keeping it longer (see Glib::Boxed).  In &quot;GET_PROPERTY&quot; the returned memory must last long enough to reach the caller, which generally means returning a field, not a newly created object (which is destroyed with the scalar holding it).<div style="height: 1.00em;">
&#160;</div>
&quot;GET_PROPERTY&quot; is different from a C get_property method in that the perl method returns the retrieved value. For symmetry, the $newval and $pspec args on &quot;SET_PROPERTY&quot; are swapped from the C usage.</dd>
</dl>
<dl>
<dt>
FINALIZE_INSTANCE $self                             [not a method]</dt>
<dd>
&quot;FINALIZE_INSTANCE&quot; is called as the GObject is being finalized, that is, as it is being really destroyed.  This is independent of the more common DESTROY on the perl object; in fact, you must  <i>NOT</i> override &quot;DESTROY&quot; (it's not useful to you, in any case, as it is being called multiple times!).<div style="height: 1.00em;">
&#160;</div>
Use this hook to release anything you have to clean up manually. FINALIZE_INSTANCE will be called for each perl instance, in reverse order of construction.<div style="height: 1.00em;">
&#160;</div>
The default finalizer does nothing.</dd>
</dl>
<dl>
<dt>
$object-&gt;DESTROY           [DO NOT OVERWRITE]</dt>
<dd>
Don't <i>ever</i> overwrite &quot;DESTROY&quot;, use &quot;FINALIZE_INSTANCE&quot; instead.<div style="height: 1.00em;">
&#160;</div>
The DESTROY method of all perl classes derived from GTypes is implemented in the Glib module and (ab-)used for its own internal purposes. Overwriting it is not useful as it will be called  <i>multiple</i> times, and often long before the object actually gets destroyed.  Overwriting might be very harmful to your program, so  <i>never</i> do that.  Especially watch out for other classes in your ISA tree.</dd>
</dl>
</div>
</div>
<div class="section">
<h1>PROPERTIES</h1> To create gobject properties, supply a list of Glib::ParamSpec objects as the value for the key 'properties'.  There are lots of different paramspec constructors, documented in the C API reference's Parameters and Values page, as well as Glib::ParamSpec.<div class="spacer">
</div>
As of Glib 1.060, you can also specify explicit getters and setters for your properties at creation time.  The default values in your properties are also honored if you don't set anything else.  See Glib::Type::register_object in Glib::Type for an example.</div>
<div class="section">
<h1>SIGNALS</h1> Creating new signals for your new object is easy.  Just provide a hash of signal names and signal descriptions under the key 'signals'.  Each signal description is also a hash, with a few expected keys.  All the keys are allowed to default.<dl>
<dt>
flags =&gt; GSignalFlags</dt>
<dd>
If not present, assumed to be 'run-first'.</dd>
</dl>
<dl>
<dt>
param_types =&gt; reference to a list of package names</dt>
<dd>
If not present, assumed to be empty (no parameters).</dd>
</dl>
<dl>
<dt>
class_closure =&gt; reference to a subroutine to call as the class closure.</dt>
<dd>
may also be a string interpreted as the name of a subroutine to call, but you should be very very very careful about that.<div style="height: 1.00em;">
&#160;</div>
If not present, the library will attempt to call the method named &quot;do_signal_name&quot; for the signal &quot;signal_name&quot; (uses underscores).<div style="height: 1.00em;">
&#160;</div>
You'll want to be careful not to let this handler method be a publically callable method, or one that has the name name as something that emits the signal.  Due to the funky ways in which Glib is different from Perl, the class closures  <i>should not</i> inherit through normal perl inheritance.</dd>
</dl>
<dl>
<dt>
return_type =&gt; package name for return value.</dt>
<dd>
If undefined or not present, the signal expects no return value.  if defined, the signal is expected to return a value; flags must be set such that the signal does not run only first (at least use 'run-last').</dd>
</dl>
<dl>
<dt>
accumulator =&gt; signal return value accumulator</dt>
<dd>
quoting the Glib manual: &quot;The signal accumulator is a special callback function that can be used to collect return values of the various callbacks that are called during a signal emission.&quot;<div style="height: 1.00em;">
&#160;</div>
If not specified, the default accumulator is used, and you just get the return value of the last handler to run.<div style="height: 1.00em;">
&#160;</div>
Accumulators are not really documented very much in the C reference, and the perl interface here is slightly different, so here's an inordinate amount of detail for this arcane feature:<div style="height: 1.00em;">
&#160;</div>
The accumulator function is called for every handler as<div style="height: 1.00em;">
&#160;</div>
<br/>
    ($cont, $acc) = &amp;$func ($invocation_hint, $acc, $ret)<br/>
<div style="height: 1.00em;">
&#160;</div>
$invocation_hint is an anonymous hash (including the signal name); $acc is the current accumulated return value; $ret is the value from the most recent handler.<div style="height: 1.00em;">
&#160;</div>
The two return values are a boolean $cont for whether signal emission should continue (false to stop); and a new $acc accumulated return value. (This is different from the C version, which writes through a return_accu.)</dd>
</dl>
</div>
<div class="section">
<h1>OVERRIDING BASE METHODS</h1> GLib pulls some fancy tricks with function pointers to implement methods in C.  This is not very language-binding-friendly, as you might guess.<div class="spacer">
</div>
However, as described above, every signal allows a &quot;class closure&quot;; you may override thie class closure with your own function, and you can chain from the overridden method to the original.  This serves to implement virtual overrides for language bindings.<div class="spacer">
</div>
So, to override a method, you supply a subroutine reference instead of a signal description hash as the value for the name of the existing signal in the &quot;signals&quot; hash described in &quot;SIGNALS&quot;.<div class="spacer">
</div>
<br/>
  # override some important widget methods:<br/>
  use Glib::Object::Subclass<br/>
        Gtk2::Widget::,<br/>
        signals =&gt; {<br/>
                expose_event =&gt; \&amp;expose_event,<br/>
                configure_event =&gt; \&amp;configure_event,<br/>
                button_press_event =&gt; \&amp;button_press_event,<br/>
                button_release_event =&gt; \&amp;button_release_event,<br/>
                motion_notify_event =&gt; \&amp;motion_notify_event,<br/>
                # note the choice of names here... see the discussion.<br/>
                size_request =&gt; \&amp;do_size_request,<br/>
        }<br/>
<div class="spacer">
</div>
It's important to note that the handlers you supply for these are class-specific, and that normal perl method inheritance rules are not followed to invoke them from within the library.  However, perl code can still find them!  Therefore it's rather important that you choose your handlers' names carefully, avoiding any public interfaces that you might call from perl.  Case in point, since size_request is a widget method, i chose do_size_request as the override handler.</div>
<div class="section">
<h1>INTERFACES</h1> GObject supports only single inheritance; in place of multiple inheritance, GObject uses GInterfaces.  In the Perl bindings we have mostly masqueraded this with multiple inheritance (that is, simply adding the GInterface class to the @ISA of the implementing class), but in deriving new objects the facade breaks and the magic leaks out.<div class="spacer">
</div>
In order to derive an object that implements a GInterface, you have to tell the GLib type system you want your class to include a GInterface.  To do this, simply pass a list of package names through the &quot;interfaces&quot; key; this will add these packages to your @ISA, and cause perl to invoke methods that you must provide.<div class="spacer">
</div>
<br/>
  package Mup::MultilineEntry;<br/>
  use Glib::Object::Subclass<br/>
      'Gtk2::TextView',<br/>
      interfaces =&gt; [ 'Gtk2::CellEditable' ],<br/>
      ;<br/>
<br/>
  # perl will now invoke these methods, which are part of the<br/>
  # GtkCellEditable GInterface, when somebody invokes the<br/>
  # corresponding lower-case methods on your objects.<br/>
  sub START_EDITING { warn &quot;start editing\n&quot;; }<br/>
  sub EDITING_DONE { warn &quot;editing done\n&quot;; }<br/>
  sub REMOVE_WIDGET { warn &quot;remove widget\n&quot;; }<br/>
</div>
<div class="section">
<h1>SEE ALSO</h1><br/>
  GObject - http://developer.gnome.org/doc/API/2.0/gobject/<br/>
</div>
<div class="section">
<h1>AUTHORS</h1> Marc Lehmann &lt;schmorp@schmorp.de&gt;, muppet &lt;scott at asofyet dot org&gt;</div>
<div class="section">
<h1>COPYRIGHT AND LICENSE</h1> Copyright 2003-2004, 2010 by muppet and the gtk2-perl team<div class="spacer">
</div>
This library is free software; you can redistribute it and/or modify it under the terms of the Lesser General Public License (LGPL).  For more information, see http://www.fsf.org/licenses/lgpl.txt</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-11-18</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

