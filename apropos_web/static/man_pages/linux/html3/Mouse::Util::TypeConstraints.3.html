<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Mouse::Util::TypeConstraints(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Mouse::Util::TypeConstraints(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
Mouse::Util::TypeConstraints(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Mouse::Util::TypeConstraints - Type constraint system for Mouse</div>
<div class="section">
<h1>VERSION</h1> This document describes Mouse version 0.97<div class="subsection">
<h2>SYNOPSIS</h2><br/>
  use Mouse::Util::TypeConstraints;<br/>
<br/>
  subtype 'Natural'<br/>
      =&gt; as 'Int'<br/>
      =&gt; where { $_ &gt; 0 };<br/>
<br/>
  subtype 'NaturalLessThanTen'<br/>
      =&gt; as 'Natural'<br/>
      =&gt; where { $_ &lt; 10 }<br/>
      =&gt; message { &quot;This number ($_) is not less than ten!&quot; };<br/>
<br/>
  coerce 'Num'<br/>
      =&gt; from 'Str'<br/>
        =&gt; via { 0+$_ };<br/>
<br/>
  enum 'RGBColors' =&gt; qw(red green blue);<br/>
<br/>
  no Mouse::Util::TypeConstraints;<br/>
</div>
</div>
<div class="section">
<h1>DESCRIPTION</h1> This module provides Mouse with the ability to create custom type constraints to be used in attribute definition.<div class="subsection">
<h2>Important Caveat</h2> This is  <b>NOT</b> a type system for Perl 5. These are type constraints, and they are not used by Mouse unless you tell it to. No type inference is performed, expressions are not typed, etc. etc. etc.<div class="spacer">
</div>
A type constraint is at heart a small &quot;check if a value is valid&quot; function. A constraint can be associated with an attribute. This simplifies parameter validation, and makes your code clearer to read, because you can refer to constraints by name.</div>
<div class="subsection">
<h2>Slightly Less Important Caveat</h2> It is  <b>always</b> a good idea to quote your type names.<div class="spacer">
</div>
This prevents Perl from trying to execute the call as an indirect object call. This can be an issue when you have a subtype with the same name as a valid class.<div class="spacer">
</div>
For instance:<div class="spacer">
</div>
<br/>
  subtype DateTime =&gt; as Object =&gt; where { $_-&gt;isa('DateTime') };<br/>
<div class="spacer">
</div>
will <i>just work</i>, while this:<div class="spacer">
</div>
<br/>
  use DateTime;<br/>
  subtype DateTime =&gt; as Object =&gt; where { $_-&gt;isa('DateTime') };<br/>
<div class="spacer">
</div>
will fail silently and cause many headaches. The simple way to solve this, as well as future proof your subtypes from classes which have yet to have been created, is to quote the type name:<div class="spacer">
</div>
<br/>
  use DateTime;<br/>
  subtype 'DateTime' =&gt; as 'Object' =&gt; where { $_-&gt;isa('DateTime') };<br/>
</div>
<div class="subsection">
<h2>Default Type Constraints</h2> This module also provides a simple hierarchy for Perl 5 types, here is that hierarchy represented visually.<div class="spacer">
</div>
<br/>
 Any<br/>
  Item<br/>
      Bool<br/>
      Maybe[`a]<br/>
      Undef<br/>
      Defined<br/>
          Value<br/>
              Str<br/>
                  Num<br/>
                      Int<br/>
                  ClassName<br/>
                  RoleName<br/>
          Ref<br/>
              ScalarRef<br/>
              ArrayRef[`a]<br/>
              HashRef[`a]<br/>
              CodeRef<br/>
              RegexpRef<br/>
              GlobRef<br/>
                  FileHandle<br/>
              Object<br/>
<div class="spacer">
</div>
<b>NOTE:</b> Any type followed by a type parameter &quot;[`a]&quot; can be parameterized, this means you can say:<div class="spacer">
</div>
<br/>
  ArrayRef[Int]    # an array of integers<br/>
  HashRef[CodeRef] # a hash of str to CODE ref mappings<br/>
  Maybe[Str]       # value may be a string, may be undefined<br/>
<div class="spacer">
</div>
If Mouse finds a name in brackets that it does not recognize as an existing type, it assumes that this is a class name, for example &quot;ArrayRef[DateTime]&quot;.<div class="spacer">
</div>
<b>NOTE:</b> The &quot;Undef&quot; type constraint for the most part works correctly now, but edge cases may still exist, please use it sparingly.<div class="spacer">
</div>
<b>NOTE:</b> The &quot;ClassName&quot; type constraint does a complex package existence check. This means that your class  <b>must</b> be loaded for this type constraint to pass.<div class="spacer">
</div>
<b>NOTE:</b> The &quot;RoleName&quot; constraint checks a string is a <i>package</i>  <i>name</i> which is a role, like 'MyApp::Role::Comparable'. The &quot;Role&quot; constraint checks that an  <i>object does</i> the named role.</div>
<div class="subsection">
<h2>Type Constraint Naming</h2> Type name declared via this module can only contain alphanumeric characters, colons (:), and periods (.).<div class="spacer">
</div>
Since the types created by this module are global, it is suggested that you namespace your types just as you would namespace your modules. So instead of creating a  <i>Color</i> type for your  <b>My::Graphics</b> module, you would call the type  <i>My::Graphics::Types::Color</i> instead.</div>
<div class="subsection">
<h2>Use with Other Constraint Modules</h2> This module can play nicely with other constraint modules with some slight tweaking. The &quot;where&quot; clause in types is expected to be a &quot;CODE&quot; reference which checks it's first argument and returns a boolean. Since most constraint modules work in a similar way, it should be simple to adapt them to work with Mouse.<div class="spacer">
</div>
For instance, this is how you could use it with Declare::Constraints::Simple to declare a completely new type.<div class="spacer">
</div>
<br/>
  type 'HashOfArrayOfObjects',<br/>
      {<br/>
      where =&gt; IsHashRef(<br/>
          -keys   =&gt; HasLength,<br/>
          -values =&gt; IsArrayRef(IsObject)<br/>
      )<br/>
  };<br/>
<div class="spacer">
</div>
Here is an example of using Test::Deep and it's non-test related &quot;eq_deeply&quot; function.<div class="spacer">
</div>
<br/>
  type 'ArrayOfHashOfBarsAndRandomNumbers'<br/>
      =&gt; where {<br/>
          eq_deeply($_,<br/>
              array_each(subhashof({<br/>
                  bar           =&gt; isa('Bar'),<br/>
                  random_number =&gt; ignore()<br/>
              })))<br/>
        };<br/>
</div>
</div>
<div class="section">
<h1>METHODS</h1><div class="subsection">
<h2>&quot;list_all_builtin_type_constraints -&gt; (Names)&quot;</h2> Returns the names of builtin type constraints.</div>
<div class="subsection">
<h2>&quot;list_all_type_constraints -&gt; (Names)&quot;</h2> Returns the names of all the type constraints.</div>
</div>
<div class="section">
<h1>FUNCTIONS</h1><dl>
<dt>
&quot;type $name =&gt; where { } ... -&gt; Mouse::Meta::TypeConstraint&quot;</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
&quot;subtype $name =&gt; as $parent =&gt; where { } ... -&gt; Mouse::Meta::TypeConstraint&quot;</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
&quot;subtype as $parent =&gt; where { } ...  -&gt; Mouse::Meta::TypeConstraint&quot;</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
&quot;class_type ($class, ?$options) -&gt; Mouse::Meta::TypeConstraint&quot;</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
&quot;role_type ($role, ?$options) -&gt; Mouse::Meta::TypeConstraint&quot;</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
&quot;duck_type($name, @methods | \@methods) -&gt; Mouse::Meta::TypeConstraint&quot;</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
&quot;duck_type(\@methods) -&gt; Mouse::Meta::TypeConstraint&quot;</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
&quot;enum($name, @values | \@values) -&gt; Mouse::Meta::TypeConstraint&quot;</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
&quot;enum (\@values) -&gt; Mouse::Meta::TypeConstraint&quot;</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
&quot;coerce $type =&gt; from $another_type, via { }, ...&quot;</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
&quot;find_type_constraint(Type) -&gt; Mouse::Meta::TypeConstraint&quot;</dt>
<dd>
</dd>
</dl>
</div>
<div class="section">
<h1>THANKS</h1> Much of this documentation was taken from &quot;Moose::Util::TypeConstraints&quot;</div>
<div class="section">
<h1>SEE ALSO</h1> Moose::Util::TypeConstraints</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-10-09</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

