<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Scanf(3)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Scanf(3)</td>
<td class="head-vol">
OCaml library</td>
<td class="head-rtitle">
Scanf(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Scanf - Formatted input functions.</div>
<div class="section">
<h1>Module</h1> Module   Scanf</div>
<div class="section">
<h1>Documentation</h1> Module <b>Scanf</b><br/>
 : <b>sig end</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
Formatted input functions.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Introduction</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Introduction</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Functional input with format strings</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Introduction</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Functional input with format strings</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== The module Scanf provides formatted input functions or scanners.</b> <b>The formatted input functions can read from any kind of input, including</b> <b>strings, files, or anything that can return characters. The more general</b> <b>source of characters is named a formatted input channel (or scanning buffer) and has type Scanf.Scanning.in_channel. The more general</b> <b>formatted input function reads from any scanning buffer and is named</b> <b>bscanf.</b> <b>Generally speaking, the formatted input functions have 3 arguments:</b> <b>- the first argument is a source of characters for the input,</b> <b>- the second argument is a format string that specifies the values to</b> <b>read,</b> <b>- the third argument is a receiver function that is applied to the</b> <b>values read.</b> <b>Hence, a typical call to the formatted input function Scanf.bscanf is</b> <b>bscanf ic fmt f, where:</b> <b>- ic is a source of characters (typically a formatted input channel with type Scanf.Scanning.in_channel),</b> <b>- fmt is a format string (the same format strings as those used to print</b> <b>material with module Printf or Format),</b> <b>- f is a function that has as many arguments as the number of values to</b> <b>read in the input.</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Introduction</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Functional input with format strings</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== The module Scanf provides formatted input functions or scanners.</b> <b>The formatted input functions can read from any kind of input, including</b> <b>strings, files, or anything that can return characters. The more general</b> <b>source of characters is named a formatted input channel (or scanning buffer) and has type Scanf.Scanning.in_channel. The more general</b> <b>formatted input function reads from any scanning buffer and is named</b> <b>bscanf.</b> <b>Generally speaking, the formatted input functions have 3 arguments:</b> <b>- the first argument is a source of characters for the input,</b> <b>- the second argument is a format string that specifies the values to</b> <b>read,</b> <b>- the third argument is a receiver function that is applied to the</b> <b>values read.</b> <b>Hence, a typical call to the formatted input function Scanf.bscanf is</b> <b>bscanf ic fmt f, where:</b> <b>- ic is a source of characters (typically a formatted input channel with type Scanf.Scanning.in_channel),</b> <b>- fmt is a format string (the same format strings as those used to print</b> <b>material with module Printf or Format),</b> <b>- f is a function that has as many arguments as the number of values to</b> <b>read in the input.</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>A simple example</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Introduction</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Functional input with format strings</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== The module Scanf provides formatted input functions or scanners.</b> <b>The formatted input functions can read from any kind of input, including</b> <b>strings, files, or anything that can return characters. The more general</b> <b>source of characters is named a formatted input channel (or scanning buffer) and has type Scanf.Scanning.in_channel. The more general</b> <b>formatted input function reads from any scanning buffer and is named</b> <b>bscanf.</b> <b>Generally speaking, the formatted input functions have 3 arguments:</b> <b>- the first argument is a source of characters for the input,</b> <b>- the second argument is a format string that specifies the values to</b> <b>read,</b> <b>- the third argument is a receiver function that is applied to the</b> <b>values read.</b> <b>Hence, a typical call to the formatted input function Scanf.bscanf is</b> <b>bscanf ic fmt f, where:</b> <b>- ic is a source of characters (typically a formatted input channel with type Scanf.Scanning.in_channel),</b> <b>- fmt is a format string (the same format strings as those used to print</b> <b>material with module Printf or Format),</b> <b>- f is a function that has as many arguments as the number of values to</b> <b>read in the input.</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>A simple example</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== As suggested above, the expression bscanf ic %d f reads a decimal</b> <b>integer n from the source of characters ic and returns f n.</b> <b>For instance,</b> <b>- if we use stdin as the source of characters (Scanf.Scanning.stdin is</b> <b>the predefined formatted input channel that reads from standard input),</b> <b>- if we define the receiver f as let f x = x + 1,</b> <b>then bscanf Scanning.stdin %d f reads an integer n from the</b> <b>standard input and returns f n (that is n + 1). Thus, if we</b> <b>evaluate bscanf stdin %d f, and then enter 41 at the</b> <b>keyboard, we get 42 as the final result. ===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Introduction</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Functional input with format strings</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== The module Scanf provides formatted input functions or scanners.</b> <b>The formatted input functions can read from any kind of input, including</b> <b>strings, files, or anything that can return characters. The more general</b> <b>source of characters is named a formatted input channel (or scanning buffer) and has type Scanf.Scanning.in_channel. The more general</b> <b>formatted input function reads from any scanning buffer and is named</b> <b>bscanf.</b> <b>Generally speaking, the formatted input functions have 3 arguments:</b> <b>- the first argument is a source of characters for the input,</b> <b>- the second argument is a format string that specifies the values to</b> <b>read,</b> <b>- the third argument is a receiver function that is applied to the</b> <b>values read.</b> <b>Hence, a typical call to the formatted input function Scanf.bscanf is</b> <b>bscanf ic fmt f, where:</b> <b>- ic is a source of characters (typically a formatted input channel with type Scanf.Scanning.in_channel),</b> <b>- fmt is a format string (the same format strings as those used to print</b> <b>material with module Printf or Format),</b> <b>- f is a function that has as many arguments as the number of values to</b> <b>read in the input.</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>A simple example</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== As suggested above, the expression bscanf ic %d f reads a decimal</b> <b>integer n from the source of characters ic and returns f n.</b> <b>For instance,</b> <b>- if we use stdin as the source of characters (Scanf.Scanning.stdin is</b> <b>the predefined formatted input channel that reads from standard input),</b> <b>- if we define the receiver f as let f x = x + 1,</b> <b>then bscanf Scanning.stdin %d f reads an integer n from the</b> <b>standard input and returns f n (that is n + 1). Thus, if we</b> <b>evaluate bscanf stdin %d f, and then enter 41 at the</b> <b>keyboard, we get 42 as the final result. ===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Formatted input as a functional feature</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Introduction</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Functional input with format strings</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== The module Scanf provides formatted input functions or scanners.</b> <b>The formatted input functions can read from any kind of input, including</b> <b>strings, files, or anything that can return characters. The more general</b> <b>source of characters is named a formatted input channel (or scanning buffer) and has type Scanf.Scanning.in_channel. The more general</b> <b>formatted input function reads from any scanning buffer and is named</b> <b>bscanf.</b> <b>Generally speaking, the formatted input functions have 3 arguments:</b> <b>- the first argument is a source of characters for the input,</b> <b>- the second argument is a format string that specifies the values to</b> <b>read,</b> <b>- the third argument is a receiver function that is applied to the</b> <b>values read.</b> <b>Hence, a typical call to the formatted input function Scanf.bscanf is</b> <b>bscanf ic fmt f, where:</b> <b>- ic is a source of characters (typically a formatted input channel with type Scanf.Scanning.in_channel),</b> <b>- fmt is a format string (the same format strings as those used to print</b> <b>material with module Printf or Format),</b> <b>- f is a function that has as many arguments as the number of values to</b> <b>read in the input.</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>A simple example</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== As suggested above, the expression bscanf ic %d f reads a decimal</b> <b>integer n from the source of characters ic and returns f n.</b> <b>For instance,</b> <b>- if we use stdin as the source of characters (Scanf.Scanning.stdin is</b> <b>the predefined formatted input channel that reads from standard input),</b> <b>- if we define the receiver f as let f x = x + 1,</b> <b>then bscanf Scanning.stdin %d f reads an integer n from the</b> <b>standard input and returns f n (that is n + 1). Thus, if we</b> <b>evaluate bscanf stdin %d f, and then enter 41 at the</b> <b>keyboard, we get 42 as the final result. ===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Formatted input as a functional feature</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== The OCaml scanning facility is reminiscent of the corresponding C feature.</b> <b>However, it is also largely different, simpler, and yet more powerful:</b> <b>the formatted input functions are higher-order functionals and the</b> <b>parameter passing mechanism is just the regular function application not</b> <b>the variable assignment based mechanism which is typical for formatted</b> <b>input in imperative languages; the OCaml format strings also feature</b> <b>useful additions to easily define complex tokens; as expected within a</b> <b>functional programming language, the formatted input functions also</b> <b>support polymorphism, in particular arbitrary interaction with</b> <b>polymorphic user-defined scanners. Furthermore, the OCaml formatted input</b> <b>facility is fully type-checked at compile time. ===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Introduction</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Functional input with format strings</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== The module Scanf provides formatted input functions or scanners.</b> <b>The formatted input functions can read from any kind of input, including</b> <b>strings, files, or anything that can return characters. The more general</b> <b>source of characters is named a formatted input channel (or scanning buffer) and has type Scanf.Scanning.in_channel. The more general</b> <b>formatted input function reads from any scanning buffer and is named</b> <b>bscanf.</b> <b>Generally speaking, the formatted input functions have 3 arguments:</b> <b>- the first argument is a source of characters for the input,</b> <b>- the second argument is a format string that specifies the values to</b> <b>read,</b> <b>- the third argument is a receiver function that is applied to the</b> <b>values read.</b> <b>Hence, a typical call to the formatted input function Scanf.bscanf is</b> <b>bscanf ic fmt f, where:</b> <b>- ic is a source of characters (typically a formatted input channel with type Scanf.Scanning.in_channel),</b> <b>- fmt is a format string (the same format strings as those used to print</b> <b>material with module Printf or Format),</b> <b>- f is a function that has as many arguments as the number of values to</b> <b>read in the input.</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>A simple example</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== As suggested above, the expression bscanf ic %d f reads a decimal</b> <b>integer n from the source of characters ic and returns f n.</b> <b>For instance,</b> <b>- if we use stdin as the source of characters (Scanf.Scanning.stdin is</b> <b>the predefined formatted input channel that reads from standard input),</b> <b>- if we define the receiver f as let f x = x + 1,</b> <b>then bscanf Scanning.stdin %d f reads an integer n from the</b> <b>standard input and returns f n (that is n + 1). Thus, if we</b> <b>evaluate bscanf stdin %d f, and then enter 41 at the</b> <b>keyboard, we get 42 as the final result. ===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Formatted input as a functional feature</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== The OCaml scanning facility is reminiscent of the corresponding C feature.</b> <b>However, it is also largely different, simpler, and yet more powerful:</b> <b>the formatted input functions are higher-order functionals and the</b> <b>parameter passing mechanism is just the regular function application not</b> <b>the variable assignment based mechanism which is typical for formatted</b> <b>input in imperative languages; the OCaml format strings also feature</b> <b>useful additions to easily define complex tokens; as expected within a</b> <b>functional programming language, the formatted input functions also</b> <b>support polymorphism, in particular arbitrary interaction with</b> <b>polymorphic user-defined scanners. Furthermore, the OCaml formatted input</b> <b>facility is fully type-checked at compile time. ===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Formatted input channel</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<i>module Scanning :</i> <b>sig end</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Type of formatted input functions</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<i>type</i> <b>('a, 'b, 'c, 'd)</b> <i>scanner</i> = <b>('a, Scanning.in_channel, 'b, 'c, 'a -&gt; 'd, 'd) Pervasives.format6 -&gt;</b> <b>'c</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
The type of formatted input scanners: <b>('a, 'b, 'c, 'd) scanner</b> is the type of a formatted input function that reads from some formatted input channel according to some format string; more precisely, if <b>scan</b> is some formatted input function, then <b>scan</b> <b>ic fmt f</b> applies <b>f</b> to the arguments specified by the format string <b>fmt</b> , when <b>scan</b> has read those arguments from the formatted input channel <b>ic</b> .<div style="height: 1.00em;">
&#160;</div>
For instance, the <b>scanf</b> function below has type <b>('a, 'b, 'c, 'd)</b> <b>scanner</b> , since it is a formatted input function that reads from <b>Scanning.stdin</b> : <b>scanf fmt f</b> applies <b>f</b> to the arguments specified by <b>fmt</b> , reading those arguments from <b>Pervasives.stdin</b> as expected.<div style="height: 1.00em;">
&#160;</div>
If the format <b>fmt</b> has some <b>%r</b> indications, the corresponding input functions must be provided before the receiver <b>f</b> argument. For instance, if <b>read_elem</b> is an input function for values of type <b>t</b> , then <b>bscanf ic %r; read_elem f</b> reads a value <b>v</b> of type <b>t</b> followed by a <b>';'</b> character, and returns <b>f v</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>Since</b> 3.10.0<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>exception Scan_failure</i> <b>of</b> <b>string</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
The exception that formatted input functions raise when the input cannot be read according to the given format.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>The general formatted input function</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val bscanf</i> : <b>Scanning.in_channel -&gt; ('a, 'b, 'c, 'd) scanner</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>bscanf ic fmt r1 ... rN f</b> reads arguments for the function <b>f</b> , from the formatted input channel <b>ic</b> , according to the format string <b>fmt</b> , and applies <b>f</b> to these values. The result of this call to <b>f</b> is returned as the result of the entire <b>bscanf</b> call. For instance, if <b>f</b> is the function <b>fun s i -&gt; i + 1</b> , then <b>Scanf.sscanf x=  1 %s = %i f</b> returns <b>2</b> .<div style="height: 1.00em;">
&#160;</div>
Arguments <b>r1</b> to <b>rN</b> are user-defined input functions that read the argument corresponding to the <b>%r</b> conversions specified in the format string.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Format string description</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Format string description</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== The format string is a character string which contains three types of</b> <b>objects:</b> <b>- plain characters, which are simply matched with the characters of the</b> <b>input (with a special case for space and line feed, see Scanf.space),</b> <b>- conversion specifications, each of which causes reading and conversion of</b> <b>one argument for the function f (see Scanf.conversion),</b> <b>- scanning indications to specify boundaries of tokens</b> <b>(see scanning Scanf.indication).</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Format string description</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== The format string is a character string which contains three types of</b> <b>objects:</b> <b>- plain characters, which are simply matched with the characters of the</b> <b>input (with a special case for space and line feed, see Scanf.space),</b> <b>- conversion specifications, each of which causes reading and conversion of</b> <b>one argument for the function f (see Scanf.conversion),</b> <b>- scanning indications to specify boundaries of tokens</b> <b>(see scanning Scanf.indication).</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>The space character in format strings</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Format string description</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== The format string is a character string which contains three types of</b> <b>objects:</b> <b>- plain characters, which are simply matched with the characters of the</b> <b>input (with a special case for space and line feed, see Scanf.space),</b> <b>- conversion specifications, each of which causes reading and conversion of</b> <b>one argument for the function f (see Scanf.conversion),</b> <b>- scanning indications to specify boundaries of tokens</b> <b>(see scanning Scanf.indication).</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>The space character in format strings</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== As mentioned above, a plain character in the format string is just</b> <b>matched with the next character of the input; however, two characters are</b> <b>special exceptions to this rule: the space character (' ' or ASCII code</b> <b>32) and the line feed character ('\n' or ASCII code 10).</b> <b>A space does not match a single space character, but any amount of</b> <b>'whitespace' in the input. More precisely, a space inside the format</b> <b>string matches any number of tab, space, line feed and carriage</b> <b>return characters. Similarly, a line feed character in the format string</b> <b>matches either a single line feed or a carriage return followed by a line</b> <b>feed.</b> <b>Matching any amount of whitespace, a space in the format string</b> <b>also matches no amount of whitespace at all; hence, the call bscanf ib</b> <b>Price = %d $ (fun p -&gt; p) succeeds and returns 1 when reading an</b> <b>input with various whitespace in it, such as Price = 1 $,</b> <b>Price = 1 $, or even Price=1$. ===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Format string description</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== The format string is a character string which contains three types of</b> <b>objects:</b> <b>- plain characters, which are simply matched with the characters of the</b> <b>input (with a special case for space and line feed, see Scanf.space),</b> <b>- conversion specifications, each of which causes reading and conversion of</b> <b>one argument for the function f (see Scanf.conversion),</b> <b>- scanning indications to specify boundaries of tokens</b> <b>(see scanning Scanf.indication).</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>The space character in format strings</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== As mentioned above, a plain character in the format string is just</b> <b>matched with the next character of the input; however, two characters are</b> <b>special exceptions to this rule: the space character (' ' or ASCII code</b> <b>32) and the line feed character ('\n' or ASCII code 10).</b> <b>A space does not match a single space character, but any amount of</b> <b>'whitespace' in the input. More precisely, a space inside the format</b> <b>string matches any number of tab, space, line feed and carriage</b> <b>return characters. Similarly, a line feed character in the format string</b> <b>matches either a single line feed or a carriage return followed by a line</b> <b>feed.</b> <b>Matching any amount of whitespace, a space in the format string</b> <b>also matches no amount of whitespace at all; hence, the call bscanf ib</b> <b>Price = %d $ (fun p -&gt; p) succeeds and returns 1 when reading an</b> <b>input with various whitespace in it, such as Price = 1 $,</b> <b>Price = 1 $, or even Price=1$. ===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Conversion specifications in format strings</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Format string description</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== The format string is a character string which contains three types of</b> <b>objects:</b> <b>- plain characters, which are simply matched with the characters of the</b> <b>input (with a special case for space and line feed, see Scanf.space),</b> <b>- conversion specifications, each of which causes reading and conversion of</b> <b>one argument for the function f (see Scanf.conversion),</b> <b>- scanning indications to specify boundaries of tokens</b> <b>(see scanning Scanf.indication).</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>The space character in format strings</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== As mentioned above, a plain character in the format string is just</b> <b>matched with the next character of the input; however, two characters are</b> <b>special exceptions to this rule: the space character (' ' or ASCII code</b> <b>32) and the line feed character ('\n' or ASCII code 10).</b> <b>A space does not match a single space character, but any amount of</b> <b>'whitespace' in the input. More precisely, a space inside the format</b> <b>string matches any number of tab, space, line feed and carriage</b> <b>return characters. Similarly, a line feed character in the format string</b> <b>matches either a single line feed or a carriage return followed by a line</b> <b>feed.</b> <b>Matching any amount of whitespace, a space in the format string</b> <b>also matches no amount of whitespace at all; hence, the call bscanf ib</b> <b>Price = %d $ (fun p -&gt; p) succeeds and returns 1 when reading an</b> <b>input with various whitespace in it, such as Price = 1 $,</b> <b>Price = 1 $, or even Price=1$. ===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Conversion specifications in format strings</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== Conversion specifications consist in the % character, followed by</b> <b>an optional flag, an optional field width, and followed by one or</b> <b>two conversion characters. The conversion characters and their</b> <b>meanings are:</b> <b>- d: reads an optionally signed decimal integer.</b> <b>- i: reads an optionally signed integer</b> <b>(usual input conventions for decimal (0-9+), hexadecimal</b> <b>(0x[0-9a-f]+ and 0X[0-9A-F]+), octal (0o[0-7]+), and binary</b> <b>(0b[0-1]+) notations are understood).</b> <b>- u: reads an unsigned decimal integer.</b> <b>- x or X: reads an unsigned hexadecimal integer ([0-9a-fA-F]+).</b> <b>- o: reads an unsigned octal integer ([0-7]+).</b> <b>- s: reads a string argument that spreads as much as possible, until the</b> <b>following bounding condition holds:</b> <b>- a whitespace has been found (see Scanf.space),</b> <b>- a scanning indication (see scanning Scanf.indication) has been</b> <b>encountered,</b> <b>- the end-of-input has been reached.</b> <b>Hence, this conversion always succeeds: it returns an empty</b> <b>string if the bounding condition holds when the scan begins.</b> <b>- S: reads a delimited string argument (delimiters and special</b> <b>escaped characters follow the lexical conventions of OCaml).</b> <b>- c: reads a single character. To test the current input character</b> <b>without reading it, specify a null field width, i.e. use</b> <b>specification %0c. Raise Invalid_argument, if the field width</b> <b>specification is greater than 1.</b> <b>- C: reads a single delimited character (delimiters and special</b> <b>escaped characters follow the lexical conventions of OCaml).</b> <b>- f, e, E, g, G: reads an optionally signed</b> <b>floating-point number in decimal notation, in the style dddd.ddd</b> <b>e/E+-dd.</b> <b>- F: reads a floating point number according to the lexical</b> <b>conventions of OCaml (hence the decimal point is mandatory if the</b> <b>exponent part is not mentioned).</b> <b>- B: reads a boolean argument (true or false).</b> <b>- b: reads a boolean argument (for backward compatibility; do not use</b> <b>in new programs).</b> <b>- ld, li, lu, lx, lX, lo: reads an int32 argument to</b> <b>the format specified by the second letter for regular integers.</b> <b>- nd, ni, nu, nx, nX, no: reads a nativeint argument to</b> <b>the format specified by the second letter for regular integers.</b> <b>- Ld, Li, Lu, Lx, LX, Lo: reads an int64 argument to</b> <b>the format specified by the second letter for regular integers.</b> <b>- [ range ]: reads characters that matches one of the characters</b> <b>mentioned in the range of characters range (or not mentioned in</b> <b>it, if the range starts with ^). Reads a string that can be</b> <b>empty, if the next input character does not match the range. The set of</b> <b>characters from c1 to c2 (inclusively) is denoted by c1-c2.</b> <b>Hence, %[0-9] returns a string representing a decimal number</b> <b>or an empty string if no decimal digit is found; similarly,</b> <b>%[0-9a-f] returns a string of hexadecimal digits.</b> <b>If a closing bracket appears in a range, it must occur as the</b> <b>first character of the range (or just after the ^ in case of</b> <b>range negation); hence []] matches a ] character and</b> <b>[^]] matches any character that is not ].</b> <b>Use %% and %@ to include a % or a @ in a range.</b> <b>- r: user-defined reader. Takes the next ri formatted input</b> <b>function and applies it to the scanning buffer ib to read the</b> <b>next argument. The input function ri must therefore have type</b> <b>Scanning.in_channel -&gt; 'a and the argument read has type 'a.</b> <b>- { fmt %}: reads a format string argument. The format string</b> <b>read must have the same type as the format string specification</b> <b>fmt. For instance, %{ %i %} reads any format string that</b> <b>can read a value of type int; hence, if s is the string</b> <b>fmt:\ number is %u\&quot;&quot;, then Scanf.sscanf s fmt: %{%i%}</b> <b>succeeds and returns the format string number is %u .</b> <b>- ( fmt %): scanning sub-format substitution.</b> <b>Reads a format string rf in the input, then goes on scanning with</b> <b>rf instead of scanning with fmt.</b> <b>The format string rf must have the same type as the format string</b> <b>specification fmt that it replaces.</b> <b>For instance, %( %i %) reads any format string that can read a value</b> <b>of type int.</b> <b>The conversion returns the format string read rf, and then a value</b> <b>read using rf.</b> <b>Hence, if s is the string \ %4d\&quot;1234.00&quot;, then</b> <b>Scanf.sscanf s %(%i%) (fun fmt i -&gt; fmt, i) evaluates to</b> <b>(&quot;%4d&quot;, 1234).</b> <b>This behaviour is not mere format substitution, since the conversion</b> <b>returns the format string read as additional argument. If you need</b> <b>pure format substitution, use special flag _ to discard the</b> <b>extraneous argument: conversion %_( fmt %) reads a format string</b> <b>rf and then behaves the same as format string rf. Hence, if s is</b> <b>the string \ %4d\&quot;1234.00&quot;, then Scanf.sscanf s %_(%i%) is</b> <b>simply equivalent to Scanf.sscanf 1234.00 %4d .</b> <b>- l: returns the number of lines read so far.</b> <b>- n: returns the number of characters read so far.</b> <b>- N or L: returns the number of tokens read so far.</b> <b>- !: matches the end of input condition.</b> <b>- %: matches one % character in the input.</b> <b>- @: matches one @ character in the input.</b> <b>- ,: does nothing.</b> <b>Following the % character that introduces a conversion, there may be</b> <b>the special flag _: the conversion that follows occurs as usual,</b> <b>but the resulting value is discarded.</b> <b>For instance, if f is the function fun i -&gt; i + 1, and s is the</b> <b>string x = 1 , then Scanf.sscanf s %_s = %i f returns 2.</b> <b>The field width is composed of an optional integer literal</b> <b>indicating the maximal width of the token to read.</b> <b>For instance, %6d reads an integer, having at most 6 decimal digits;</b> <b>%4f reads a float with at most 4 characters; and %8[\000-\255]</b> <b>returns the next 8 characters (or all the characters still available,</b> <b>if fewer than 8 characters are available in the input).</b> <b>Notes:</b> <b>- as mentioned above, a %s conversion always succeeds, even if there is</b> <b>nothing to read in the input: in this case, it simply returns  .</b> <b>- in addition to the relevant digits, '_' characters may appear</b> <b>inside numbers (this is reminiscent to the usual OCaml lexical</b> <b>conventions). If stricter scanning is desired, use the range</b> <b>conversion facility instead of the number conversions.</b> <b>- the scanf facility is not intended for heavy duty lexical</b> <b>analysis and parsing. If it appears not expressive enough for your</b> <b>needs, several alternative exists: regular expressions (module</b> <b>Str), stream parsers, ocamllex-generated lexers,</b> <b>ocamlyacc-generated parsers.</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Format string description</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== The format string is a character string which contains three types of</b> <b>objects:</b> <b>- plain characters, which are simply matched with the characters of the</b> <b>input (with a special case for space and line feed, see Scanf.space),</b> <b>- conversion specifications, each of which causes reading and conversion of</b> <b>one argument for the function f (see Scanf.conversion),</b> <b>- scanning indications to specify boundaries of tokens</b> <b>(see scanning Scanf.indication).</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>The space character in format strings</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== As mentioned above, a plain character in the format string is just</b> <b>matched with the next character of the input; however, two characters are</b> <b>special exceptions to this rule: the space character (' ' or ASCII code</b> <b>32) and the line feed character ('\n' or ASCII code 10).</b> <b>A space does not match a single space character, but any amount of</b> <b>'whitespace' in the input. More precisely, a space inside the format</b> <b>string matches any number of tab, space, line feed and carriage</b> <b>return characters. Similarly, a line feed character in the format string</b> <b>matches either a single line feed or a carriage return followed by a line</b> <b>feed.</b> <b>Matching any amount of whitespace, a space in the format string</b> <b>also matches no amount of whitespace at all; hence, the call bscanf ib</b> <b>Price = %d $ (fun p -&gt; p) succeeds and returns 1 when reading an</b> <b>input with various whitespace in it, such as Price = 1 $,</b> <b>Price = 1 $, or even Price=1$. ===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Conversion specifications in format strings</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== Conversion specifications consist in the % character, followed by</b> <b>an optional flag, an optional field width, and followed by one or</b> <b>two conversion characters. The conversion characters and their</b> <b>meanings are:</b> <b>- d: reads an optionally signed decimal integer.</b> <b>- i: reads an optionally signed integer</b> <b>(usual input conventions for decimal (0-9+), hexadecimal</b> <b>(0x[0-9a-f]+ and 0X[0-9A-F]+), octal (0o[0-7]+), and binary</b> <b>(0b[0-1]+) notations are understood).</b> <b>- u: reads an unsigned decimal integer.</b> <b>- x or X: reads an unsigned hexadecimal integer ([0-9a-fA-F]+).</b> <b>- o: reads an unsigned octal integer ([0-7]+).</b> <b>- s: reads a string argument that spreads as much as possible, until the</b> <b>following bounding condition holds:</b> <b>- a whitespace has been found (see Scanf.space),</b> <b>- a scanning indication (see scanning Scanf.indication) has been</b> <b>encountered,</b> <b>- the end-of-input has been reached.</b> <b>Hence, this conversion always succeeds: it returns an empty</b> <b>string if the bounding condition holds when the scan begins.</b> <b>- S: reads a delimited string argument (delimiters and special</b> <b>escaped characters follow the lexical conventions of OCaml).</b> <b>- c: reads a single character. To test the current input character</b> <b>without reading it, specify a null field width, i.e. use</b> <b>specification %0c. Raise Invalid_argument, if the field width</b> <b>specification is greater than 1.</b> <b>- C: reads a single delimited character (delimiters and special</b> <b>escaped characters follow the lexical conventions of OCaml).</b> <b>- f, e, E, g, G: reads an optionally signed</b> <b>floating-point number in decimal notation, in the style dddd.ddd</b> <b>e/E+-dd.</b> <b>- F: reads a floating point number according to the lexical</b> <b>conventions of OCaml (hence the decimal point is mandatory if the</b> <b>exponent part is not mentioned).</b> <b>- B: reads a boolean argument (true or false).</b> <b>- b: reads a boolean argument (for backward compatibility; do not use</b> <b>in new programs).</b> <b>- ld, li, lu, lx, lX, lo: reads an int32 argument to</b> <b>the format specified by the second letter for regular integers.</b> <b>- nd, ni, nu, nx, nX, no: reads a nativeint argument to</b> <b>the format specified by the second letter for regular integers.</b> <b>- Ld, Li, Lu, Lx, LX, Lo: reads an int64 argument to</b> <b>the format specified by the second letter for regular integers.</b> <b>- [ range ]: reads characters that matches one of the characters</b> <b>mentioned in the range of characters range (or not mentioned in</b> <b>it, if the range starts with ^). Reads a string that can be</b> <b>empty, if the next input character does not match the range. The set of</b> <b>characters from c1 to c2 (inclusively) is denoted by c1-c2.</b> <b>Hence, %[0-9] returns a string representing a decimal number</b> <b>or an empty string if no decimal digit is found; similarly,</b> <b>%[0-9a-f] returns a string of hexadecimal digits.</b> <b>If a closing bracket appears in a range, it must occur as the</b> <b>first character of the range (or just after the ^ in case of</b> <b>range negation); hence []] matches a ] character and</b> <b>[^]] matches any character that is not ].</b> <b>Use %% and %@ to include a % or a @ in a range.</b> <b>- r: user-defined reader. Takes the next ri formatted input</b> <b>function and applies it to the scanning buffer ib to read the</b> <b>next argument. The input function ri must therefore have type</b> <b>Scanning.in_channel -&gt; 'a and the argument read has type 'a.</b> <b>- { fmt %}: reads a format string argument. The format string</b> <b>read must have the same type as the format string specification</b> <b>fmt. For instance, %{ %i %} reads any format string that</b> <b>can read a value of type int; hence, if s is the string</b> <b>fmt:\ number is %u\&quot;&quot;, then Scanf.sscanf s fmt: %{%i%}</b> <b>succeeds and returns the format string number is %u .</b> <b>- ( fmt %): scanning sub-format substitution.</b> <b>Reads a format string rf in the input, then goes on scanning with</b> <b>rf instead of scanning with fmt.</b> <b>The format string rf must have the same type as the format string</b> <b>specification fmt that it replaces.</b> <b>For instance, %( %i %) reads any format string that can read a value</b> <b>of type int.</b> <b>The conversion returns the format string read rf, and then a value</b> <b>read using rf.</b> <b>Hence, if s is the string \ %4d\&quot;1234.00&quot;, then</b> <b>Scanf.sscanf s %(%i%) (fun fmt i -&gt; fmt, i) evaluates to</b> <b>(&quot;%4d&quot;, 1234).</b> <b>This behaviour is not mere format substitution, since the conversion</b> <b>returns the format string read as additional argument. If you need</b> <b>pure format substitution, use special flag _ to discard the</b> <b>extraneous argument: conversion %_( fmt %) reads a format string</b> <b>rf and then behaves the same as format string rf. Hence, if s is</b> <b>the string \ %4d\&quot;1234.00&quot;, then Scanf.sscanf s %_(%i%) is</b> <b>simply equivalent to Scanf.sscanf 1234.00 %4d .</b> <b>- l: returns the number of lines read so far.</b> <b>- n: returns the number of characters read so far.</b> <b>- N or L: returns the number of tokens read so far.</b> <b>- !: matches the end of input condition.</b> <b>- %: matches one % character in the input.</b> <b>- @: matches one @ character in the input.</b> <b>- ,: does nothing.</b> <b>Following the % character that introduces a conversion, there may be</b> <b>the special flag _: the conversion that follows occurs as usual,</b> <b>but the resulting value is discarded.</b> <b>For instance, if f is the function fun i -&gt; i + 1, and s is the</b> <b>string x = 1 , then Scanf.sscanf s %_s = %i f returns 2.</b> <b>The field width is composed of an optional integer literal</b> <b>indicating the maximal width of the token to read.</b> <b>For instance, %6d reads an integer, having at most 6 decimal digits;</b> <b>%4f reads a float with at most 4 characters; and %8[\000-\255]</b> <b>returns the next 8 characters (or all the characters still available,</b> <b>if fewer than 8 characters are available in the input).</b> <b>Notes:</b> <b>- as mentioned above, a %s conversion always succeeds, even if there is</b> <b>nothing to read in the input: in this case, it simply returns  .</b> <b>- in addition to the relevant digits, '_' characters may appear</b> <b>inside numbers (this is reminiscent to the usual OCaml lexical</b> <b>conventions). If stricter scanning is desired, use the range</b> <b>conversion facility instead of the number conversions.</b> <b>- the scanf facility is not intended for heavy duty lexical</b> <b>analysis and parsing. If it appears not expressive enough for your</b> <b>needs, several alternative exists: regular expressions (module</b> <b>Str), stream parsers, ocamllex-generated lexers,</b> <b>ocamlyacc-generated parsers.</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Scanning indications in format strings</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Format string description</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== The format string is a character string which contains three types of</b> <b>objects:</b> <b>- plain characters, which are simply matched with the characters of the</b> <b>input (with a special case for space and line feed, see Scanf.space),</b> <b>- conversion specifications, each of which causes reading and conversion of</b> <b>one argument for the function f (see Scanf.conversion),</b> <b>- scanning indications to specify boundaries of tokens</b> <b>(see scanning Scanf.indication).</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>The space character in format strings</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== As mentioned above, a plain character in the format string is just</b> <b>matched with the next character of the input; however, two characters are</b> <b>special exceptions to this rule: the space character (' ' or ASCII code</b> <b>32) and the line feed character ('\n' or ASCII code 10).</b> <b>A space does not match a single space character, but any amount of</b> <b>'whitespace' in the input. More precisely, a space inside the format</b> <b>string matches any number of tab, space, line feed and carriage</b> <b>return characters. Similarly, a line feed character in the format string</b> <b>matches either a single line feed or a carriage return followed by a line</b> <b>feed.</b> <b>Matching any amount of whitespace, a space in the format string</b> <b>also matches no amount of whitespace at all; hence, the call bscanf ib</b> <b>Price = %d $ (fun p -&gt; p) succeeds and returns 1 when reading an</b> <b>input with various whitespace in it, such as Price = 1 $,</b> <b>Price = 1 $, or even Price=1$. ===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Conversion specifications in format strings</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== Conversion specifications consist in the % character, followed by</b> <b>an optional flag, an optional field width, and followed by one or</b> <b>two conversion characters. The conversion characters and their</b> <b>meanings are:</b> <b>- d: reads an optionally signed decimal integer.</b> <b>- i: reads an optionally signed integer</b> <b>(usual input conventions for decimal (0-9+), hexadecimal</b> <b>(0x[0-9a-f]+ and 0X[0-9A-F]+), octal (0o[0-7]+), and binary</b> <b>(0b[0-1]+) notations are understood).</b> <b>- u: reads an unsigned decimal integer.</b> <b>- x or X: reads an unsigned hexadecimal integer ([0-9a-fA-F]+).</b> <b>- o: reads an unsigned octal integer ([0-7]+).</b> <b>- s: reads a string argument that spreads as much as possible, until the</b> <b>following bounding condition holds:</b> <b>- a whitespace has been found (see Scanf.space),</b> <b>- a scanning indication (see scanning Scanf.indication) has been</b> <b>encountered,</b> <b>- the end-of-input has been reached.</b> <b>Hence, this conversion always succeeds: it returns an empty</b> <b>string if the bounding condition holds when the scan begins.</b> <b>- S: reads a delimited string argument (delimiters and special</b> <b>escaped characters follow the lexical conventions of OCaml).</b> <b>- c: reads a single character. To test the current input character</b> <b>without reading it, specify a null field width, i.e. use</b> <b>specification %0c. Raise Invalid_argument, if the field width</b> <b>specification is greater than 1.</b> <b>- C: reads a single delimited character (delimiters and special</b> <b>escaped characters follow the lexical conventions of OCaml).</b> <b>- f, e, E, g, G: reads an optionally signed</b> <b>floating-point number in decimal notation, in the style dddd.ddd</b> <b>e/E+-dd.</b> <b>- F: reads a floating point number according to the lexical</b> <b>conventions of OCaml (hence the decimal point is mandatory if the</b> <b>exponent part is not mentioned).</b> <b>- B: reads a boolean argument (true or false).</b> <b>- b: reads a boolean argument (for backward compatibility; do not use</b> <b>in new programs).</b> <b>- ld, li, lu, lx, lX, lo: reads an int32 argument to</b> <b>the format specified by the second letter for regular integers.</b> <b>- nd, ni, nu, nx, nX, no: reads a nativeint argument to</b> <b>the format specified by the second letter for regular integers.</b> <b>- Ld, Li, Lu, Lx, LX, Lo: reads an int64 argument to</b> <b>the format specified by the second letter for regular integers.</b> <b>- [ range ]: reads characters that matches one of the characters</b> <b>mentioned in the range of characters range (or not mentioned in</b> <b>it, if the range starts with ^). Reads a string that can be</b> <b>empty, if the next input character does not match the range. The set of</b> <b>characters from c1 to c2 (inclusively) is denoted by c1-c2.</b> <b>Hence, %[0-9] returns a string representing a decimal number</b> <b>or an empty string if no decimal digit is found; similarly,</b> <b>%[0-9a-f] returns a string of hexadecimal digits.</b> <b>If a closing bracket appears in a range, it must occur as the</b> <b>first character of the range (or just after the ^ in case of</b> <b>range negation); hence []] matches a ] character and</b> <b>[^]] matches any character that is not ].</b> <b>Use %% and %@ to include a % or a @ in a range.</b> <b>- r: user-defined reader. Takes the next ri formatted input</b> <b>function and applies it to the scanning buffer ib to read the</b> <b>next argument. The input function ri must therefore have type</b> <b>Scanning.in_channel -&gt; 'a and the argument read has type 'a.</b> <b>- { fmt %}: reads a format string argument. The format string</b> <b>read must have the same type as the format string specification</b> <b>fmt. For instance, %{ %i %} reads any format string that</b> <b>can read a value of type int; hence, if s is the string</b> <b>fmt:\ number is %u\&quot;&quot;, then Scanf.sscanf s fmt: %{%i%}</b> <b>succeeds and returns the format string number is %u .</b> <b>- ( fmt %): scanning sub-format substitution.</b> <b>Reads a format string rf in the input, then goes on scanning with</b> <b>rf instead of scanning with fmt.</b> <b>The format string rf must have the same type as the format string</b> <b>specification fmt that it replaces.</b> <b>For instance, %( %i %) reads any format string that can read a value</b> <b>of type int.</b> <b>The conversion returns the format string read rf, and then a value</b> <b>read using rf.</b> <b>Hence, if s is the string \ %4d\&quot;1234.00&quot;, then</b> <b>Scanf.sscanf s %(%i%) (fun fmt i -&gt; fmt, i) evaluates to</b> <b>(&quot;%4d&quot;, 1234).</b> <b>This behaviour is not mere format substitution, since the conversion</b> <b>returns the format string read as additional argument. If you need</b> <b>pure format substitution, use special flag _ to discard the</b> <b>extraneous argument: conversion %_( fmt %) reads a format string</b> <b>rf and then behaves the same as format string rf. Hence, if s is</b> <b>the string \ %4d\&quot;1234.00&quot;, then Scanf.sscanf s %_(%i%) is</b> <b>simply equivalent to Scanf.sscanf 1234.00 %4d .</b> <b>- l: returns the number of lines read so far.</b> <b>- n: returns the number of characters read so far.</b> <b>- N or L: returns the number of tokens read so far.</b> <b>- !: matches the end of input condition.</b> <b>- %: matches one % character in the input.</b> <b>- @: matches one @ character in the input.</b> <b>- ,: does nothing.</b> <b>Following the % character that introduces a conversion, there may be</b> <b>the special flag _: the conversion that follows occurs as usual,</b> <b>but the resulting value is discarded.</b> <b>For instance, if f is the function fun i -&gt; i + 1, and s is the</b> <b>string x = 1 , then Scanf.sscanf s %_s = %i f returns 2.</b> <b>The field width is composed of an optional integer literal</b> <b>indicating the maximal width of the token to read.</b> <b>For instance, %6d reads an integer, having at most 6 decimal digits;</b> <b>%4f reads a float with at most 4 characters; and %8[\000-\255]</b> <b>returns the next 8 characters (or all the characters still available,</b> <b>if fewer than 8 characters are available in the input).</b> <b>Notes:</b> <b>- as mentioned above, a %s conversion always succeeds, even if there is</b> <b>nothing to read in the input: in this case, it simply returns  .</b> <b>- in addition to the relevant digits, '_' characters may appear</b> <b>inside numbers (this is reminiscent to the usual OCaml lexical</b> <b>conventions). If stricter scanning is desired, use the range</b> <b>conversion facility instead of the number conversions.</b> <b>- the scanf facility is not intended for heavy duty lexical</b> <b>analysis and parsing. If it appears not expressive enough for your</b> <b>needs, several alternative exists: regular expressions (module</b> <b>Str), stream parsers, ocamllex-generated lexers,</b> <b>ocamlyacc-generated parsers.</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Scanning indications in format strings</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== Scanning indications appear just after the string conversions %s</b> <b>and %[ range ] to delimit the end of the token. A scanning</b> <b>indication is introduced by a @ character, followed by some</b> <b>plain character c. It means that the string token should end</b> <b>just before the next matching c (which is skipped). If no c</b> <b>character is encountered, the string token spreads as much as</b> <b>possible. For instance, %s@\t reads a string up to the next</b> <b>tab character or to the end of input. If a @ character appears</b> <b>anywhere else in the format string, it is treated as a plain character.</b> <b>Note:</b> <b>- As usual in format strings, % and @ characters must be escaped</b> <b>using %% and %@; this rule still holds within range specifications</b> <b>and scanning indications.</b> <b>For instance, %s@%% reads a string up to the next % character.</b> <b>- The scanning indications introduce slight differences in the syntax of</b> <b>Scanf format strings, compared to those used for the Printf</b> <b>module. However, the scanning indications are similar to those used in</b> <b>the Format module; hence, when producing formatted text to be scanned</b> <b>by !Scanf.bscanf, it is wise to use printing functions from the</b> <b>Format module (or, if you need to use functions from Printf, banish</b> <b>or carefully double check the format strings that contain '@'</b> <b>characters).</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Format string description</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== The format string is a character string which contains three types of</b> <b>objects:</b> <b>- plain characters, which are simply matched with the characters of the</b> <b>input (with a special case for space and line feed, see Scanf.space),</b> <b>- conversion specifications, each of which causes reading and conversion of</b> <b>one argument for the function f (see Scanf.conversion),</b> <b>- scanning indications to specify boundaries of tokens</b> <b>(see scanning Scanf.indication).</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>The space character in format strings</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== As mentioned above, a plain character in the format string is just</b> <b>matched with the next character of the input; however, two characters are</b> <b>special exceptions to this rule: the space character (' ' or ASCII code</b> <b>32) and the line feed character ('\n' or ASCII code 10).</b> <b>A space does not match a single space character, but any amount of</b> <b>'whitespace' in the input. More precisely, a space inside the format</b> <b>string matches any number of tab, space, line feed and carriage</b> <b>return characters. Similarly, a line feed character in the format string</b> <b>matches either a single line feed or a carriage return followed by a line</b> <b>feed.</b> <b>Matching any amount of whitespace, a space in the format string</b> <b>also matches no amount of whitespace at all; hence, the call bscanf ib</b> <b>Price = %d $ (fun p -&gt; p) succeeds and returns 1 when reading an</b> <b>input with various whitespace in it, such as Price = 1 $,</b> <b>Price = 1 $, or even Price=1$. ===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Conversion specifications in format strings</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== Conversion specifications consist in the % character, followed by</b> <b>an optional flag, an optional field width, and followed by one or</b> <b>two conversion characters. The conversion characters and their</b> <b>meanings are:</b> <b>- d: reads an optionally signed decimal integer.</b> <b>- i: reads an optionally signed integer</b> <b>(usual input conventions for decimal (0-9+), hexadecimal</b> <b>(0x[0-9a-f]+ and 0X[0-9A-F]+), octal (0o[0-7]+), and binary</b> <b>(0b[0-1]+) notations are understood).</b> <b>- u: reads an unsigned decimal integer.</b> <b>- x or X: reads an unsigned hexadecimal integer ([0-9a-fA-F]+).</b> <b>- o: reads an unsigned octal integer ([0-7]+).</b> <b>- s: reads a string argument that spreads as much as possible, until the</b> <b>following bounding condition holds:</b> <b>- a whitespace has been found (see Scanf.space),</b> <b>- a scanning indication (see scanning Scanf.indication) has been</b> <b>encountered,</b> <b>- the end-of-input has been reached.</b> <b>Hence, this conversion always succeeds: it returns an empty</b> <b>string if the bounding condition holds when the scan begins.</b> <b>- S: reads a delimited string argument (delimiters and special</b> <b>escaped characters follow the lexical conventions of OCaml).</b> <b>- c: reads a single character. To test the current input character</b> <b>without reading it, specify a null field width, i.e. use</b> <b>specification %0c. Raise Invalid_argument, if the field width</b> <b>specification is greater than 1.</b> <b>- C: reads a single delimited character (delimiters and special</b> <b>escaped characters follow the lexical conventions of OCaml).</b> <b>- f, e, E, g, G: reads an optionally signed</b> <b>floating-point number in decimal notation, in the style dddd.ddd</b> <b>e/E+-dd.</b> <b>- F: reads a floating point number according to the lexical</b> <b>conventions of OCaml (hence the decimal point is mandatory if the</b> <b>exponent part is not mentioned).</b> <b>- B: reads a boolean argument (true or false).</b> <b>- b: reads a boolean argument (for backward compatibility; do not use</b> <b>in new programs).</b> <b>- ld, li, lu, lx, lX, lo: reads an int32 argument to</b> <b>the format specified by the second letter for regular integers.</b> <b>- nd, ni, nu, nx, nX, no: reads a nativeint argument to</b> <b>the format specified by the second letter for regular integers.</b> <b>- Ld, Li, Lu, Lx, LX, Lo: reads an int64 argument to</b> <b>the format specified by the second letter for regular integers.</b> <b>- [ range ]: reads characters that matches one of the characters</b> <b>mentioned in the range of characters range (or not mentioned in</b> <b>it, if the range starts with ^). Reads a string that can be</b> <b>empty, if the next input character does not match the range. The set of</b> <b>characters from c1 to c2 (inclusively) is denoted by c1-c2.</b> <b>Hence, %[0-9] returns a string representing a decimal number</b> <b>or an empty string if no decimal digit is found; similarly,</b> <b>%[0-9a-f] returns a string of hexadecimal digits.</b> <b>If a closing bracket appears in a range, it must occur as the</b> <b>first character of the range (or just after the ^ in case of</b> <b>range negation); hence []] matches a ] character and</b> <b>[^]] matches any character that is not ].</b> <b>Use %% and %@ to include a % or a @ in a range.</b> <b>- r: user-defined reader. Takes the next ri formatted input</b> <b>function and applies it to the scanning buffer ib to read the</b> <b>next argument. The input function ri must therefore have type</b> <b>Scanning.in_channel -&gt; 'a and the argument read has type 'a.</b> <b>- { fmt %}: reads a format string argument. The format string</b> <b>read must have the same type as the format string specification</b> <b>fmt. For instance, %{ %i %} reads any format string that</b> <b>can read a value of type int; hence, if s is the string</b> <b>fmt:\ number is %u\&quot;&quot;, then Scanf.sscanf s fmt: %{%i%}</b> <b>succeeds and returns the format string number is %u .</b> <b>- ( fmt %): scanning sub-format substitution.</b> <b>Reads a format string rf in the input, then goes on scanning with</b> <b>rf instead of scanning with fmt.</b> <b>The format string rf must have the same type as the format string</b> <b>specification fmt that it replaces.</b> <b>For instance, %( %i %) reads any format string that can read a value</b> <b>of type int.</b> <b>The conversion returns the format string read rf, and then a value</b> <b>read using rf.</b> <b>Hence, if s is the string \ %4d\&quot;1234.00&quot;, then</b> <b>Scanf.sscanf s %(%i%) (fun fmt i -&gt; fmt, i) evaluates to</b> <b>(&quot;%4d&quot;, 1234).</b> <b>This behaviour is not mere format substitution, since the conversion</b> <b>returns the format string read as additional argument. If you need</b> <b>pure format substitution, use special flag _ to discard the</b> <b>extraneous argument: conversion %_( fmt %) reads a format string</b> <b>rf and then behaves the same as format string rf. Hence, if s is</b> <b>the string \ %4d\&quot;1234.00&quot;, then Scanf.sscanf s %_(%i%) is</b> <b>simply equivalent to Scanf.sscanf 1234.00 %4d .</b> <b>- l: returns the number of lines read so far.</b> <b>- n: returns the number of characters read so far.</b> <b>- N or L: returns the number of tokens read so far.</b> <b>- !: matches the end of input condition.</b> <b>- %: matches one % character in the input.</b> <b>- @: matches one @ character in the input.</b> <b>- ,: does nothing.</b> <b>Following the % character that introduces a conversion, there may be</b> <b>the special flag _: the conversion that follows occurs as usual,</b> <b>but the resulting value is discarded.</b> <b>For instance, if f is the function fun i -&gt; i + 1, and s is the</b> <b>string x = 1 , then Scanf.sscanf s %_s = %i f returns 2.</b> <b>The field width is composed of an optional integer literal</b> <b>indicating the maximal width of the token to read.</b> <b>For instance, %6d reads an integer, having at most 6 decimal digits;</b> <b>%4f reads a float with at most 4 characters; and %8[\000-\255]</b> <b>returns the next 8 characters (or all the characters still available,</b> <b>if fewer than 8 characters are available in the input).</b> <b>Notes:</b> <b>- as mentioned above, a %s conversion always succeeds, even if there is</b> <b>nothing to read in the input: in this case, it simply returns  .</b> <b>- in addition to the relevant digits, '_' characters may appear</b> <b>inside numbers (this is reminiscent to the usual OCaml lexical</b> <b>conventions). If stricter scanning is desired, use the range</b> <b>conversion facility instead of the number conversions.</b> <b>- the scanf facility is not intended for heavy duty lexical</b> <b>analysis and parsing. If it appears not expressive enough for your</b> <b>needs, several alternative exists: regular expressions (module</b> <b>Str), stream parsers, ocamllex-generated lexers,</b> <b>ocamlyacc-generated parsers.</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Scanning indications in format strings</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== Scanning indications appear just after the string conversions %s</b> <b>and %[ range ] to delimit the end of the token. A scanning</b> <b>indication is introduced by a @ character, followed by some</b> <b>plain character c. It means that the string token should end</b> <b>just before the next matching c (which is skipped). If no c</b> <b>character is encountered, the string token spreads as much as</b> <b>possible. For instance, %s@\t reads a string up to the next</b> <b>tab character or to the end of input. If a @ character appears</b> <b>anywhere else in the format string, it is treated as a plain character.</b> <b>Note:</b> <b>- As usual in format strings, % and @ characters must be escaped</b> <b>using %% and %@; this rule still holds within range specifications</b> <b>and scanning indications.</b> <b>For instance, %s@%% reads a string up to the next % character.</b> <b>- The scanning indications introduce slight differences in the syntax of</b> <b>Scanf format strings, compared to those used for the Printf</b> <b>module. However, the scanning indications are similar to those used in</b> <b>the Format module; hence, when producing formatted text to be scanned</b> <b>by !Scanf.bscanf, it is wise to use printing functions from the</b> <b>Format module (or, if you need to use functions from Printf, banish</b> <b>or carefully double check the format strings that contain '@'</b> <b>characters).</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Exceptions during scanning</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Format string description</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== The format string is a character string which contains three types of</b> <b>objects:</b> <b>- plain characters, which are simply matched with the characters of the</b> <b>input (with a special case for space and line feed, see Scanf.space),</b> <b>- conversion specifications, each of which causes reading and conversion of</b> <b>one argument for the function f (see Scanf.conversion),</b> <b>- scanning indications to specify boundaries of tokens</b> <b>(see scanning Scanf.indication).</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>The space character in format strings</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== As mentioned above, a plain character in the format string is just</b> <b>matched with the next character of the input; however, two characters are</b> <b>special exceptions to this rule: the space character (' ' or ASCII code</b> <b>32) and the line feed character ('\n' or ASCII code 10).</b> <b>A space does not match a single space character, but any amount of</b> <b>'whitespace' in the input. More precisely, a space inside the format</b> <b>string matches any number of tab, space, line feed and carriage</b> <b>return characters. Similarly, a line feed character in the format string</b> <b>matches either a single line feed or a carriage return followed by a line</b> <b>feed.</b> <b>Matching any amount of whitespace, a space in the format string</b> <b>also matches no amount of whitespace at all; hence, the call bscanf ib</b> <b>Price = %d $ (fun p -&gt; p) succeeds and returns 1 when reading an</b> <b>input with various whitespace in it, such as Price = 1 $,</b> <b>Price = 1 $, or even Price=1$. ===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Conversion specifications in format strings</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== Conversion specifications consist in the % character, followed by</b> <b>an optional flag, an optional field width, and followed by one or</b> <b>two conversion characters. The conversion characters and their</b> <b>meanings are:</b> <b>- d: reads an optionally signed decimal integer.</b> <b>- i: reads an optionally signed integer</b> <b>(usual input conventions for decimal (0-9+), hexadecimal</b> <b>(0x[0-9a-f]+ and 0X[0-9A-F]+), octal (0o[0-7]+), and binary</b> <b>(0b[0-1]+) notations are understood).</b> <b>- u: reads an unsigned decimal integer.</b> <b>- x or X: reads an unsigned hexadecimal integer ([0-9a-fA-F]+).</b> <b>- o: reads an unsigned octal integer ([0-7]+).</b> <b>- s: reads a string argument that spreads as much as possible, until the</b> <b>following bounding condition holds:</b> <b>- a whitespace has been found (see Scanf.space),</b> <b>- a scanning indication (see scanning Scanf.indication) has been</b> <b>encountered,</b> <b>- the end-of-input has been reached.</b> <b>Hence, this conversion always succeeds: it returns an empty</b> <b>string if the bounding condition holds when the scan begins.</b> <b>- S: reads a delimited string argument (delimiters and special</b> <b>escaped characters follow the lexical conventions of OCaml).</b> <b>- c: reads a single character. To test the current input character</b> <b>without reading it, specify a null field width, i.e. use</b> <b>specification %0c. Raise Invalid_argument, if the field width</b> <b>specification is greater than 1.</b> <b>- C: reads a single delimited character (delimiters and special</b> <b>escaped characters follow the lexical conventions of OCaml).</b> <b>- f, e, E, g, G: reads an optionally signed</b> <b>floating-point number in decimal notation, in the style dddd.ddd</b> <b>e/E+-dd.</b> <b>- F: reads a floating point number according to the lexical</b> <b>conventions of OCaml (hence the decimal point is mandatory if the</b> <b>exponent part is not mentioned).</b> <b>- B: reads a boolean argument (true or false).</b> <b>- b: reads a boolean argument (for backward compatibility; do not use</b> <b>in new programs).</b> <b>- ld, li, lu, lx, lX, lo: reads an int32 argument to</b> <b>the format specified by the second letter for regular integers.</b> <b>- nd, ni, nu, nx, nX, no: reads a nativeint argument to</b> <b>the format specified by the second letter for regular integers.</b> <b>- Ld, Li, Lu, Lx, LX, Lo: reads an int64 argument to</b> <b>the format specified by the second letter for regular integers.</b> <b>- [ range ]: reads characters that matches one of the characters</b> <b>mentioned in the range of characters range (or not mentioned in</b> <b>it, if the range starts with ^). Reads a string that can be</b> <b>empty, if the next input character does not match the range. The set of</b> <b>characters from c1 to c2 (inclusively) is denoted by c1-c2.</b> <b>Hence, %[0-9] returns a string representing a decimal number</b> <b>or an empty string if no decimal digit is found; similarly,</b> <b>%[0-9a-f] returns a string of hexadecimal digits.</b> <b>If a closing bracket appears in a range, it must occur as the</b> <b>first character of the range (or just after the ^ in case of</b> <b>range negation); hence []] matches a ] character and</b> <b>[^]] matches any character that is not ].</b> <b>Use %% and %@ to include a % or a @ in a range.</b> <b>- r: user-defined reader. Takes the next ri formatted input</b> <b>function and applies it to the scanning buffer ib to read the</b> <b>next argument. The input function ri must therefore have type</b> <b>Scanning.in_channel -&gt; 'a and the argument read has type 'a.</b> <b>- { fmt %}: reads a format string argument. The format string</b> <b>read must have the same type as the format string specification</b> <b>fmt. For instance, %{ %i %} reads any format string that</b> <b>can read a value of type int; hence, if s is the string</b> <b>fmt:\ number is %u\&quot;&quot;, then Scanf.sscanf s fmt: %{%i%}</b> <b>succeeds and returns the format string number is %u .</b> <b>- ( fmt %): scanning sub-format substitution.</b> <b>Reads a format string rf in the input, then goes on scanning with</b> <b>rf instead of scanning with fmt.</b> <b>The format string rf must have the same type as the format string</b> <b>specification fmt that it replaces.</b> <b>For instance, %( %i %) reads any format string that can read a value</b> <b>of type int.</b> <b>The conversion returns the format string read rf, and then a value</b> <b>read using rf.</b> <b>Hence, if s is the string \ %4d\&quot;1234.00&quot;, then</b> <b>Scanf.sscanf s %(%i%) (fun fmt i -&gt; fmt, i) evaluates to</b> <b>(&quot;%4d&quot;, 1234).</b> <b>This behaviour is not mere format substitution, since the conversion</b> <b>returns the format string read as additional argument. If you need</b> <b>pure format substitution, use special flag _ to discard the</b> <b>extraneous argument: conversion %_( fmt %) reads a format string</b> <b>rf and then behaves the same as format string rf. Hence, if s is</b> <b>the string \ %4d\&quot;1234.00&quot;, then Scanf.sscanf s %_(%i%) is</b> <b>simply equivalent to Scanf.sscanf 1234.00 %4d .</b> <b>- l: returns the number of lines read so far.</b> <b>- n: returns the number of characters read so far.</b> <b>- N or L: returns the number of tokens read so far.</b> <b>- !: matches the end of input condition.</b> <b>- %: matches one % character in the input.</b> <b>- @: matches one @ character in the input.</b> <b>- ,: does nothing.</b> <b>Following the % character that introduces a conversion, there may be</b> <b>the special flag _: the conversion that follows occurs as usual,</b> <b>but the resulting value is discarded.</b> <b>For instance, if f is the function fun i -&gt; i + 1, and s is the</b> <b>string x = 1 , then Scanf.sscanf s %_s = %i f returns 2.</b> <b>The field width is composed of an optional integer literal</b> <b>indicating the maximal width of the token to read.</b> <b>For instance, %6d reads an integer, having at most 6 decimal digits;</b> <b>%4f reads a float with at most 4 characters; and %8[\000-\255]</b> <b>returns the next 8 characters (or all the characters still available,</b> <b>if fewer than 8 characters are available in the input).</b> <b>Notes:</b> <b>- as mentioned above, a %s conversion always succeeds, even if there is</b> <b>nothing to read in the input: in this case, it simply returns  .</b> <b>- in addition to the relevant digits, '_' characters may appear</b> <b>inside numbers (this is reminiscent to the usual OCaml lexical</b> <b>conventions). If stricter scanning is desired, use the range</b> <b>conversion facility instead of the number conversions.</b> <b>- the scanf facility is not intended for heavy duty lexical</b> <b>analysis and parsing. If it appears not expressive enough for your</b> <b>needs, several alternative exists: regular expressions (module</b> <b>Str), stream parsers, ocamllex-generated lexers,</b> <b>ocamlyacc-generated parsers.</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Scanning indications in format strings</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== Scanning indications appear just after the string conversions %s</b> <b>and %[ range ] to delimit the end of the token. A scanning</b> <b>indication is introduced by a @ character, followed by some</b> <b>plain character c. It means that the string token should end</b> <b>just before the next matching c (which is skipped). If no c</b> <b>character is encountered, the string token spreads as much as</b> <b>possible. For instance, %s@\t reads a string up to the next</b> <b>tab character or to the end of input. If a @ character appears</b> <b>anywhere else in the format string, it is treated as a plain character.</b> <b>Note:</b> <b>- As usual in format strings, % and @ characters must be escaped</b> <b>using %% and %@; this rule still holds within range specifications</b> <b>and scanning indications.</b> <b>For instance, %s@%% reads a string up to the next % character.</b> <b>- The scanning indications introduce slight differences in the syntax of</b> <b>Scanf format strings, compared to those used for the Printf</b> <b>module. However, the scanning indications are similar to those used in</b> <b>the Format module; hence, when producing formatted text to be scanned</b> <b>by !Scanf.bscanf, it is wise to use printing functions from the</b> <b>Format module (or, if you need to use functions from Printf, banish</b> <b>or carefully double check the format strings that contain '@'</b> <b>characters).</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Exceptions during scanning</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== Scanners may raise the following exceptions when the input cannot be read</b> <b>according to the format string:</b> <b>- Raise Scanf.Scan_failure if the input does not match the format.</b> <b>- Raise Failure if a conversion to a number is not possible.</b> <b>- Raise End_of_file if the end of input is encountered while some more</b> <b>characters are needed to read the current conversion specification.</b> <b>- Raise Invalid_argument if the format string is invalid.</b> <b>Note:</b> <b>- as a consequence, scanning a %s conversion never raises exception</b> <b>End_of_file: if the end of input is reached the conversion succeeds and</b> <b>simply returns the characters read so far, or  if none were ever read.</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Format string description</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== The format string is a character string which contains three types of</b> <b>objects:</b> <b>- plain characters, which are simply matched with the characters of the</b> <b>input (with a special case for space and line feed, see Scanf.space),</b> <b>- conversion specifications, each of which causes reading and conversion of</b> <b>one argument for the function f (see Scanf.conversion),</b> <b>- scanning indications to specify boundaries of tokens</b> <b>(see scanning Scanf.indication).</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>The space character in format strings</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== As mentioned above, a plain character in the format string is just</b> <b>matched with the next character of the input; however, two characters are</b> <b>special exceptions to this rule: the space character (' ' or ASCII code</b> <b>32) and the line feed character ('\n' or ASCII code 10).</b> <b>A space does not match a single space character, but any amount of</b> <b>'whitespace' in the input. More precisely, a space inside the format</b> <b>string matches any number of tab, space, line feed and carriage</b> <b>return characters. Similarly, a line feed character in the format string</b> <b>matches either a single line feed or a carriage return followed by a line</b> <b>feed.</b> <b>Matching any amount of whitespace, a space in the format string</b> <b>also matches no amount of whitespace at all; hence, the call bscanf ib</b> <b>Price = %d $ (fun p -&gt; p) succeeds and returns 1 when reading an</b> <b>input with various whitespace in it, such as Price = 1 $,</b> <b>Price = 1 $, or even Price=1$. ===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Conversion specifications in format strings</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== Conversion specifications consist in the % character, followed by</b> <b>an optional flag, an optional field width, and followed by one or</b> <b>two conversion characters. The conversion characters and their</b> <b>meanings are:</b> <b>- d: reads an optionally signed decimal integer.</b> <b>- i: reads an optionally signed integer</b> <b>(usual input conventions for decimal (0-9+), hexadecimal</b> <b>(0x[0-9a-f]+ and 0X[0-9A-F]+), octal (0o[0-7]+), and binary</b> <b>(0b[0-1]+) notations are understood).</b> <b>- u: reads an unsigned decimal integer.</b> <b>- x or X: reads an unsigned hexadecimal integer ([0-9a-fA-F]+).</b> <b>- o: reads an unsigned octal integer ([0-7]+).</b> <b>- s: reads a string argument that spreads as much as possible, until the</b> <b>following bounding condition holds:</b> <b>- a whitespace has been found (see Scanf.space),</b> <b>- a scanning indication (see scanning Scanf.indication) has been</b> <b>encountered,</b> <b>- the end-of-input has been reached.</b> <b>Hence, this conversion always succeeds: it returns an empty</b> <b>string if the bounding condition holds when the scan begins.</b> <b>- S: reads a delimited string argument (delimiters and special</b> <b>escaped characters follow the lexical conventions of OCaml).</b> <b>- c: reads a single character. To test the current input character</b> <b>without reading it, specify a null field width, i.e. use</b> <b>specification %0c. Raise Invalid_argument, if the field width</b> <b>specification is greater than 1.</b> <b>- C: reads a single delimited character (delimiters and special</b> <b>escaped characters follow the lexical conventions of OCaml).</b> <b>- f, e, E, g, G: reads an optionally signed</b> <b>floating-point number in decimal notation, in the style dddd.ddd</b> <b>e/E+-dd.</b> <b>- F: reads a floating point number according to the lexical</b> <b>conventions of OCaml (hence the decimal point is mandatory if the</b> <b>exponent part is not mentioned).</b> <b>- B: reads a boolean argument (true or false).</b> <b>- b: reads a boolean argument (for backward compatibility; do not use</b> <b>in new programs).</b> <b>- ld, li, lu, lx, lX, lo: reads an int32 argument to</b> <b>the format specified by the second letter for regular integers.</b> <b>- nd, ni, nu, nx, nX, no: reads a nativeint argument to</b> <b>the format specified by the second letter for regular integers.</b> <b>- Ld, Li, Lu, Lx, LX, Lo: reads an int64 argument to</b> <b>the format specified by the second letter for regular integers.</b> <b>- [ range ]: reads characters that matches one of the characters</b> <b>mentioned in the range of characters range (or not mentioned in</b> <b>it, if the range starts with ^). Reads a string that can be</b> <b>empty, if the next input character does not match the range. The set of</b> <b>characters from c1 to c2 (inclusively) is denoted by c1-c2.</b> <b>Hence, %[0-9] returns a string representing a decimal number</b> <b>or an empty string if no decimal digit is found; similarly,</b> <b>%[0-9a-f] returns a string of hexadecimal digits.</b> <b>If a closing bracket appears in a range, it must occur as the</b> <b>first character of the range (or just after the ^ in case of</b> <b>range negation); hence []] matches a ] character and</b> <b>[^]] matches any character that is not ].</b> <b>Use %% and %@ to include a % or a @ in a range.</b> <b>- r: user-defined reader. Takes the next ri formatted input</b> <b>function and applies it to the scanning buffer ib to read the</b> <b>next argument. The input function ri must therefore have type</b> <b>Scanning.in_channel -&gt; 'a and the argument read has type 'a.</b> <b>- { fmt %}: reads a format string argument. The format string</b> <b>read must have the same type as the format string specification</b> <b>fmt. For instance, %{ %i %} reads any format string that</b> <b>can read a value of type int; hence, if s is the string</b> <b>fmt:\ number is %u\&quot;&quot;, then Scanf.sscanf s fmt: %{%i%}</b> <b>succeeds and returns the format string number is %u .</b> <b>- ( fmt %): scanning sub-format substitution.</b> <b>Reads a format string rf in the input, then goes on scanning with</b> <b>rf instead of scanning with fmt.</b> <b>The format string rf must have the same type as the format string</b> <b>specification fmt that it replaces.</b> <b>For instance, %( %i %) reads any format string that can read a value</b> <b>of type int.</b> <b>The conversion returns the format string read rf, and then a value</b> <b>read using rf.</b> <b>Hence, if s is the string \ %4d\&quot;1234.00&quot;, then</b> <b>Scanf.sscanf s %(%i%) (fun fmt i -&gt; fmt, i) evaluates to</b> <b>(&quot;%4d&quot;, 1234).</b> <b>This behaviour is not mere format substitution, since the conversion</b> <b>returns the format string read as additional argument. If you need</b> <b>pure format substitution, use special flag _ to discard the</b> <b>extraneous argument: conversion %_( fmt %) reads a format string</b> <b>rf and then behaves the same as format string rf. Hence, if s is</b> <b>the string \ %4d\&quot;1234.00&quot;, then Scanf.sscanf s %_(%i%) is</b> <b>simply equivalent to Scanf.sscanf 1234.00 %4d .</b> <b>- l: returns the number of lines read so far.</b> <b>- n: returns the number of characters read so far.</b> <b>- N or L: returns the number of tokens read so far.</b> <b>- !: matches the end of input condition.</b> <b>- %: matches one % character in the input.</b> <b>- @: matches one @ character in the input.</b> <b>- ,: does nothing.</b> <b>Following the % character that introduces a conversion, there may be</b> <b>the special flag _: the conversion that follows occurs as usual,</b> <b>but the resulting value is discarded.</b> <b>For instance, if f is the function fun i -&gt; i + 1, and s is the</b> <b>string x = 1 , then Scanf.sscanf s %_s = %i f returns 2.</b> <b>The field width is composed of an optional integer literal</b> <b>indicating the maximal width of the token to read.</b> <b>For instance, %6d reads an integer, having at most 6 decimal digits;</b> <b>%4f reads a float with at most 4 characters; and %8[\000-\255]</b> <b>returns the next 8 characters (or all the characters still available,</b> <b>if fewer than 8 characters are available in the input).</b> <b>Notes:</b> <b>- as mentioned above, a %s conversion always succeeds, even if there is</b> <b>nothing to read in the input: in this case, it simply returns  .</b> <b>- in addition to the relevant digits, '_' characters may appear</b> <b>inside numbers (this is reminiscent to the usual OCaml lexical</b> <b>conventions). If stricter scanning is desired, use the range</b> <b>conversion facility instead of the number conversions.</b> <b>- the scanf facility is not intended for heavy duty lexical</b> <b>analysis and parsing. If it appears not expressive enough for your</b> <b>needs, several alternative exists: regular expressions (module</b> <b>Str), stream parsers, ocamllex-generated lexers,</b> <b>ocamlyacc-generated parsers.</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Scanning indications in format strings</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== Scanning indications appear just after the string conversions %s</b> <b>and %[ range ] to delimit the end of the token. A scanning</b> <b>indication is introduced by a @ character, followed by some</b> <b>plain character c. It means that the string token should end</b> <b>just before the next matching c (which is skipped). If no c</b> <b>character is encountered, the string token spreads as much as</b> <b>possible. For instance, %s@\t reads a string up to the next</b> <b>tab character or to the end of input. If a @ character appears</b> <b>anywhere else in the format string, it is treated as a plain character.</b> <b>Note:</b> <b>- As usual in format strings, % and @ characters must be escaped</b> <b>using %% and %@; this rule still holds within range specifications</b> <b>and scanning indications.</b> <b>For instance, %s@%% reads a string up to the next % character.</b> <b>- The scanning indications introduce slight differences in the syntax of</b> <b>Scanf format strings, compared to those used for the Printf</b> <b>module. However, the scanning indications are similar to those used in</b> <b>the Format module; hence, when producing formatted text to be scanned</b> <b>by !Scanf.bscanf, it is wise to use printing functions from the</b> <b>Format module (or, if you need to use functions from Printf, banish</b> <b>or carefully double check the format strings that contain '@'</b> <b>characters).</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Exceptions during scanning</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== Scanners may raise the following exceptions when the input cannot be read</b> <b>according to the format string:</b> <b>- Raise Scanf.Scan_failure if the input does not match the format.</b> <b>- Raise Failure if a conversion to a number is not possible.</b> <b>- Raise End_of_file if the end of input is encountered while some more</b> <b>characters are needed to read the current conversion specification.</b> <b>- Raise Invalid_argument if the format string is invalid.</b> <b>Note:</b> <b>- as a consequence, scanning a %s conversion never raises exception</b> <b>End_of_file: if the end of input is reached the conversion succeeds and</b> <b>simply returns the characters read so far, or  if none were ever read.</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Specialised formatted input functions</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val fscanf</i> : <b>Pervasives.in_channel -&gt; ('a, 'b, 'c, 'd) scanner</b><div style="height: 1.00em;">
&#160;</div>
Same as <b>Scanf.bscanf</b> , but reads from the given regular input channel.<div style="height: 1.00em;">
&#160;</div>
Warning: since all formatted input functions operate from a formatted input channel, be aware that each <b>fscanf</b> invocation will operate with a formatted input channel reading from the given channel. This extra level of bufferization can lead to a strange scanning behaviour if you use low level primitives on the channel (reading characters, seeking the reading position, and so on).<div style="height: 1.00em;">
&#160;</div>
As a consequence, never mix direct low level reading and high level scanning from the same regular input channel.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val sscanf</i> : <b>string -&gt; ('a, 'b, 'c, 'd) scanner</b><div style="height: 1.00em;">
&#160;</div>
Same as <b>Scanf.bscanf</b> , but reads from the given string.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val scanf</i> : <b>('a, 'b, 'c, 'd) scanner</b><div style="height: 1.00em;">
&#160;</div>
Same as <b>Scanf.bscanf</b> , but reads from the predefined formatted input channel <b>Scanf.Scanning.stdin</b> that is connected to <b>Pervasives.stdin</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val kscanf</i> : <b>Scanning.in_channel -&gt;</b> <b>(Scanning.in_channel -&gt; exn -&gt; 'd) -&gt; ('a, 'b, 'c, 'd) scanner</b><div style="height: 1.00em;">
&#160;</div>
Same as <b>Scanf.bscanf</b> , but takes an additional function argument <b>ef</b> that is called in case of error: if the scanning process or some conversion fails, the scanning function aborts and calls the error handling function <b>ef</b> with the formatted input channel and the exception that aborted the scanning process as arguments.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val ksscanf</i> : <b>string -&gt;</b> <b>(Scanning.in_channel -&gt; exn -&gt; 'd) -&gt; ('a, 'b, 'c, 'd) scanner</b><div style="height: 1.00em;">
&#160;</div>
Same as <b>Scanf.kscanf</b> but reads from the given string.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>Since</b> 4.02.0<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val kfscanf</i> : <b>Pervasives.in_channel -&gt;</b> <b>(Scanning.in_channel -&gt; exn -&gt; 'd) -&gt; ('a, 'b, 'c, 'd) scanner</b><div style="height: 1.00em;">
&#160;</div>
Same as <b>Scanf.kscanf</b> , but reads from the given regular input channel.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>Since</b> 4.02.0<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Reading format strings from input</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val bscanf_format</i> : <b>Scanning.in_channel -&gt;</b> <b>('a, 'b, 'c, 'd, 'e, 'f) Pervasives.format6 -&gt;</b> <b>(('a, 'b, 'c, 'd, 'e, 'f) Pervasives.format6 -&gt; 'g) -&gt; 'g</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>bscanf_format ic fmt f</b> reads a format string token from the formatted input channel <b>ic</b> , according to the given format string <b>fmt</b> , and applies <b>f</b> to the resulting format string value. Raise <b>Scan_failure</b> if the format string value read does not have the same type as <b>fmt</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>Since</b> 3.09.0<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val sscanf_format</i> : <b>string -&gt;</b> <b>('a, 'b, 'c, 'd, 'e, 'f) Pervasives.format6 -&gt;</b> <b>(('a, 'b, 'c, 'd, 'e, 'f) Pervasives.format6 -&gt; 'g) -&gt; 'g</b><div style="height: 1.00em;">
&#160;</div>
Same as <b>Scanf.bscanf_format</b> , but reads from the given string.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>Since</b> 3.09.0<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val format_from_string</i> : <b>string -&gt;</b> <b>('a, 'b, 'c, 'd, 'e, 'f) Pervasives.format6 -&gt;</b> <b>('a, 'b, 'c, 'd, 'e, 'f) Pervasives.format6</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>format_from_string s fmt</b> converts a string argument to a format string, according to the given format string <b>fmt</b> . Raise <b>Scan_failure</b> if <b>s</b> , considered as a format string, does not have the same type as <b>fmt</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>Since</b> 3.10.0<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val unescaped</i> : <b>string -&gt; string</b><div style="height: 1.00em;">
&#160;</div>
Return a copy of the argument with escape sequences, following the lexical conventions of OCaml, replaced by their corresponding special characters. If there is no escape sequence in the argument, still return a copy, contrary to String.escaped.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>Since</b> 4.00.0<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<table class="foot">
<tr>
<td class="foot-date">
2015-08-12</td>
<td class="foot-os">
OCamldoc</td>
</tr>
</table>
</div>
</body>
</html>

