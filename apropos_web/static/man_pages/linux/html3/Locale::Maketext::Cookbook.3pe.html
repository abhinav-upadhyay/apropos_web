<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Locale::Maketext::Cookbook(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Locale::Maketext::Cookbook(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
Locale::Maketext::Cookbook(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Locale::Maketext::Cookbook - recipes for using Locale::Maketext</div>
<div class="section">
<h1>INTRODUCTION</h1> This is a work in progress. Not much progress by now :-)</div>
<div class="section">
<h1>ONESIDED LEXICONS</h1>  <i>Adapted from a suggestion by Dan Muey</i><div class="spacer">
</div>
It may be common (for example at your main lexicon) that the hash keys and values coincide. Like that<div class="spacer">
</div>
<br/>
    q{Hello, tell me your name} <br/>
      =&gt; q{Hello, tell me your name}<br/>
<div class="spacer">
</div>
It would be nice to just write:<div class="spacer">
</div>
<br/>
    q{Hello, tell me your name} =&gt; ''<br/>
<div class="spacer">
</div>
and have this magically inflated to the first form. Among the advantages of such representation, that would lead to smaller files, less prone to mistyping or mispasting, and handy to someone translating it which can simply copy the main lexicon and enter the translation instead of having to remove the value first.<div class="spacer">
</div>
That can be achieved by overriding &quot;init&quot; in your class and working on the main lexicon with code like that:<div class="spacer">
</div>
<br/>
    package My::I18N;<br/>
    ...<br/>
<br/>
    sub init {<br/>
        my $lh = shift; # a newborn handle<br/>
        $lh-&gt;SUPER::init();<br/>
        inflate_lexicon(\%My::I18N::en::Lexicon);<br/>
        return;<br/>
    }<br/>
<br/>
    sub inflate_lexicon {<br/>
        my $lex = shift;<br/>
        while (my ($k, $v) = each %$lex) {<br/>
            $v = $k if !defined $v || $v eq '';<br/>
        }<br/>
    }<br/>
<div class="spacer">
</div>
Here we are assuming &quot;My::I18N::en&quot; to own the main lexicon.<div class="spacer">
</div>
There are some downsides here: the size economy will not stand at runtime after this &quot;init()&quot; runs. But it should not be that critical, since if you don't have space for that, you won't have space for any other language besides the main one as well. You could do that too with ties, expanding the value at lookup time which should be more time expensive as an option.</div>
<div class="section">
<h1>DECIMAL PLACES IN NUMBER FORMATTING</h1>  <i>After CPAN RT #36136 (https://rt.cpan.org/Ticket/Display.html?id=36136)</i><div class="spacer">
</div>
The documentation of Locale::Maketext advises that the standard bracket method &quot;numf&quot; is limited and that you must override that for better results. It even suggests the use of Number::Format.<div class="spacer">
</div>
One such defect of standard &quot;numf&quot; is to not be able to use a certain decimal precision. For example,<div class="spacer">
</div>
<br/>
    $lh-&gt;maketext('pi is [numf,_1]', 355/113);<br/>
<div class="spacer">
</div>
outputs<div class="spacer">
</div>
<br/>
    pi is 3.14159292035398<br/>
<div class="spacer">
</div>
Since pi X 355/116 is only accurate to 6 decimal places, you would want to say:<div class="spacer">
</div>
<br/>
    $lh-&gt;maketext('pi is [numf,_1,6]', 355/113);<br/>
<div class="spacer">
</div>
and get &quot;pi is 3.141592&quot;.<div class="spacer">
</div>
One solution for that could use &quot;Number::Format&quot; like that:<div class="spacer">
</div>
<br/>
    package Wuu;<br/>
<br/>
    use base qw(Locale::Maketext);<br/>
<br/>
    use Number::Format;<br/>
<br/>
    # can be overridden according to language conventions<br/>
    sub _numf_params {<br/>
        return (<br/>
            -thousands_sep  =&gt; '.',<br/>
            -decimal_point  =&gt; ',',<br/>
            -decimal_digits =&gt; 2,<br/>
        );<br/>
    }<br/>
<br/>
    # builds a Number::Format<br/>
    sub _numf_formatter {<br/>
        my ($lh, $scale) = @_;<br/>
        my @params = $lh-&gt;_numf_params;<br/>
        if ($scale) { # use explicit scale rather than default<br/>
            push @params, (-decimal_digits =&gt; $scale);<br/>
        }<br/>
        return Number::Format-&gt;new(@params);<br/>
    }<br/>
<br/>
    sub numf {<br/>
        my ($lh, $n, $scale) = @_;<br/>
        # get the (cached) formatter<br/>
        my $nf = $lh-&gt;{__nf}{$scale} ||= $lh-&gt;_numf_formatter($scale);<br/>
        # format the number itself<br/>
        return $nf-&gt;format_number($n);<br/>
    }<br/>
<br/>
    package Wuu::pt;<br/>
<br/>
    use base qw(Wuu);<br/>
<div class="spacer">
</div>
and then<div class="spacer">
</div>
<br/>
    my $lh = Wuu-&gt;get_handle('pt');<br/>
    $lh-&gt;maketext('A [numf,_1,3] km de distancia', 1550.2222);<br/>
<div class="spacer">
</div>
would return &quot;A 1.550,222 km de distancia&quot;.<div class="spacer">
</div>
Notice that the standard utility methods of &quot;Locale::Maketext&quot; are irremediably limited because they could not aim to do everything that could be expected from them in different languages, cultures and applications. So extending &quot;numf&quot;, &quot;quant&quot;, and &quot;sprintf&quot; is natural as soon as your needs exceed what the standard ones do.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-09-19</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

