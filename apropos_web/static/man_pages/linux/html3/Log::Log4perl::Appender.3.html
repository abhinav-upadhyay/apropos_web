<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Appender(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Appender(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
Appender(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Log::Log4perl::Appender - Log appender class</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
  use Log::Log4perl;<br/>
<br/>
      # Define a logger<br/>
  my $logger = Log::Log4perl-&gt;get_logger(&quot;abc.def.ghi&quot;);<br/>
<br/>
      # Define a layout<br/>
  my $layout = Log::Log4perl::Layout::PatternLayout-&gt;new(<br/>
                   &quot;%d (%F:%L)&gt; %m&quot;);<br/>
<br/>
      # Define an appender<br/>
  my $appender = Log::Log4perl::Appender-&gt;new(<br/>
                   &quot;Log::Log4perl::Appender::Screen&quot;,<br/>
                   name =&gt; 'dumpy');<br/>
<br/>
      # Set the appender's layout<br/>
  $appender-&gt;layout($layout);<br/>
  $logger-&gt;add_appender($appender);<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> This class is a wrapper around the &quot;Log::Log4perl::Appender&quot; appender set.<div class="spacer">
</div>
It also supports the &lt;Log::Dispatch::*&gt; collections of appenders. The module hides the idiosyncrasies of &quot;Log::Dispatch&quot; (e.g. every dispatcher gotta have a name, but there's no accessor to retrieve it) from &quot;Log::Log4perl&quot; and yet re-uses the extremely useful variety of dispatchers already created and tested in &quot;Log::Dispatch&quot;.</div>
<div class="section">
<h1>FUNCTIONS</h1><div class="subsection">
<h2>Log::Log4perl::Appender-&gt;new($dispatcher_class_name, ...);</h2> The constructor &quot;new()&quot; takes the name of the appender class to be created as a  <i>string</i> (!) argument, optionally followed by a number of appender-specific parameters, for example:<div class="spacer">
</div>
<br/>
      # Define an appender<br/>
  my $appender = Log::Log4perl::Appender-&gt;new(<br/>
      &quot;Log::Log4perl::Appender::File&quot;<br/>
      filename =&gt; 'out.log');<br/>
<div class="spacer">
</div>
In case of &quot;Log::Dispatch&quot; appenders, if no &quot;name&quot; parameter is specified, the appender object will create a unique one (format &quot;appNNN&quot;), which can be retrieved later via the &quot;name()&quot; method:<div class="spacer">
</div>
<br/>
  print &quot;The appender's name is &quot;, $appender-&gt;name(), &quot;\n&quot;;<br/>
<div class="spacer">
</div>
Other parameters are specific to the appender class being used. In the case above, the &quot;filename&quot; parameter specifies the name of the &quot;Log::Log4perl::Appender::File&quot; dispatcher used.<div class="spacer">
</div>
However, if, for instance, you're using a &quot;Log::Dispatch::Email&quot; dispatcher to send you email, you'll have to specify &quot;from&quot; and &quot;to&quot; email addresses. Every dispatcher is different. Please check the &quot;Log::Dispatch::*&quot; documentation for the appender used for details on specific requirements.<div class="spacer">
</div>
The &quot;new()&quot; method will just pass these parameters on to a newly created &quot;Log::Dispatch::*&quot; object of the specified type.<div class="spacer">
</div>
When it comes to logging, the &quot;Log::Log4perl::Appender&quot; will transparently relay all messages to the &quot;Log::Dispatch::*&quot; object it carries in its womb.</div>
<div class="subsection">
<h2>$appender-&gt;layout($layout);</h2> The &quot;layout()&quot; method sets the log layout used by the appender to the format specified by the &quot;Log::Log4perl::Layout::*&quot; object which is passed to it as a reference. Currently there's two layouts available:<div class="spacer">
</div>
<br/>
    Log::Log4perl::Layout::SimpleLayout<br/>
    Log::Log4perl::Layout::PatternLayout<br/>
<div class="spacer">
</div>
Please check the Log::Log4perl::Layout::SimpleLayout and Log::Log4perl::Layout::PatternLayout manual pages for details.</div>
</div>
<div class="section">
<h1>Supported Appenders</h1> Here's the list of appender modules currently available via &quot;Log::Dispatch&quot;, if not noted otherwise, written by Dave Rolsky:<div class="spacer">
</div>
<br/>
       Log::Dispatch::ApacheLog<br/>
       Log::Dispatch::DBI (by Tatsuhiko Miyagawa)<br/>
       Log::Dispatch::Email,<br/>
       Log::Dispatch::Email::MailSend,<br/>
       Log::Dispatch::Email::MailSendmail,<br/>
       Log::Dispatch::Email::MIMELite<br/>
       Log::Dispatch::File<br/>
       Log::Dispatch::FileRotate (by Mark Pfeiffer)<br/>
       Log::Dispatch::Handle<br/>
       Log::Dispatch::Screen<br/>
       Log::Dispatch::Syslog<br/>
       Log::Dispatch::Tk (by Dominique Dumont)<br/>
<div class="spacer">
</div>
&quot;Log4perl&quot; doesn't care which ones you use, they're all handled in the same way via the &quot;Log::Log4perl::Appender&quot; interface. Please check the well-written manual pages of the &quot;Log::Dispatch&quot; hierarchy on how to use each one of them.</div>
<div class="section">
<h1>Parameters passed on to the appender's <i>log()</i> method</h1> When calling the appender's  <i>log()</i>-Funktion, Log::Log4perl will submit a list of key/value pairs. Entries to the following keys are guaranteed to be present:<dl>
<dt>
message</dt>
<dd>
Text of the rendered message</dd>
</dl>
<dl>
<dt>
log4p_category</dt>
<dd>
Name of the category of the logger that triggered the event.</dd>
</dl>
<dl>
<dt>
log4p_level</dt>
<dd>
Log::Log4perl level of the event</dd>
</dl>
</div>
<div class="section">
<h1>Pitfalls</h1> Since the &quot;Log::Dispatch::File&quot; appender truncates log files by default, and most of the time this is  <i>not</i> what you want, we've instructed &quot;Log::Log4perl&quot; to change this behavior by slipping it the &quot;mode =&gt; append&quot; parameter behind the scenes. So, effectively with &quot;Log::Log4perl&quot; 0.23, a configuration like<div class="spacer">
</div>
<br/>
    log4perl.category = INFO, FileAppndr<br/>
    log4perl.appender.FileAppndr          = Log::Dispatch::File<br/>
    log4perl.appender.FileAppndr.filename = test.log<br/>
    log4perl.appender.FileAppndr.layout   = Log::Log4perl::Layout::SimpleLayout<br/>
<div class="spacer">
</div>
will always <i>append</i> to an existing logfile &quot;test.log&quot; while if you specifically request clobbering like in<div class="spacer">
</div>
<br/>
    log4perl.category = INFO, FileAppndr<br/>
    log4perl.appender.FileAppndr          = Log::Dispatch::File<br/>
    log4perl.appender.FileAppndr.filename = test.log<br/>
    log4perl.appender.FileAppndr.mode     = write<br/>
    log4perl.appender.FileAppndr.layout   = Log::Log4perl::Layout::SimpleLayout<br/>
<div class="spacer">
</div>
it will overwrite an existing log file &quot;test.log&quot; and start from scratch.</div>
<div class="section">
<h1>Appenders Expecting Message Chunks</h1> Instead of simple strings, certain appenders are expecting multiple fields as log messages. If a statement like<div class="spacer">
</div>
<br/>
    $logger-&gt;debug($ip, $user, &quot;signed in&quot;);<br/>
<div class="spacer">
</div>
causes an off-the-shelf &quot;Log::Log4perl::Appender::Screen&quot; appender to fire, the appender will just concatenate the three message chunks passed to it in order to form a single string. The chunks will be separated by a string defined in $Log::Log4perl::JOIN_MSG_ARRAY_CHAR (defaults to the empty string &quot;&quot;).<div class="spacer">
</div>
However, different appenders might choose to interpret the message above differently: An appender like &quot;Log::Log4perl::Appender::DBI&quot; might take the three arguments passed to the logger and put them in three separate rows into the DB.<div class="spacer">
</div>
The  &quot;warp_message&quot; appender option is used to specify the desired behavior. If no setting for the appender property<div class="spacer">
</div>
<br/>
    # *** Not defined ***<br/>
    # log4perl.appender.SomeApp.warp_message<br/>
<div class="spacer">
</div>
is defined in the Log4perl configuration file, the appender referenced by &quot;SomeApp&quot; will fall back to the standard behavior and join all message chunks together, separating them by $Log::Log4perl::JOIN_MSG_ARRAY_CHAR.<div class="spacer">
</div>
If, on the other hand, it is set to a false value, like in<div class="spacer">
</div>
<br/>
    log4perl.appender.SomeApp.layout=NoopLayout<br/>
    log4perl.appender.SomeApp.warp_message = 0<br/>
<div class="spacer">
</div>
then the message chunks are passed unmodified to the appender as an array reference. Please note that you need to set the appender's layout to &quot;Log::Log4perl::Layout::NoopLayout&quot; which just leaves the messages chunks alone instead of formatting them or replacing conversion specifiers.<div class="spacer">
</div>
<b>Please note that the standard appenders in the Log::Dispatch hierarchy</b>  <b>will choke on a bunch of messages passed to them as an array reference.</b>  <b>You can't use </b><b>&quot;warp_message = 0&quot;</b><b> (or the function name syntax</b>  <b>defined below) on them.</b>  <b>Only special appenders like Log::Log4perl::Appender::DBI can deal with</b>  <b>this.</b><div class="spacer">
</div>
If (and now we're getting fancy) an appender expects message chunks, but we would like to pre-inspect and probably modify them before they're actually passed to the appender's &quot;log&quot; method, an inspection subroutine can be defined with the appender's &quot;warp_message&quot; property:<div class="spacer">
</div>
<br/>
    log4perl.appender.SomeApp.layout=NoopLayout<br/>
    log4perl.appender.SomeApp.warp_message = sub { \<br/>
                                           $#_ = 2 if @_ &gt; 3; \<br/>
                                           return @_; }<br/>
<div class="spacer">
</div>
The inspection subroutine defined by the &quot;warp_message&quot; property will receive the list of message chunks, like they were passed to the logger and is expected to return a corrected list. The example above simply limits the argument list to a maximum of three by cutting off excess elements and returning the shortened list.<div class="spacer">
</div>
Also, the warp function can be specified by name like in<div class="spacer">
</div>
<br/>
    log4perl.appender.SomeApp.layout=NoopLayout<br/>
    log4perl.appender.SomeApp.warp_message = main::filter_my_message<br/>
<div class="spacer">
</div>
In this example, &quot;filter_my_message&quot; is a function in the &quot;main&quot; package, defined like this:<div class="spacer">
</div>
<br/>
    my $COUNTER = 0;<br/>
<br/>
    sub filter_my_message {<br/>
        my @chunks = @_;<br/>
        unshift @chunks, ++$COUNTER;<br/>
        return @chunks;<br/>
    }<br/>
<div class="spacer">
</div>
The subroutine above will add an ever increasing counter as an additional first field to every message passed to the &quot;SomeApp&quot; appender -- but not to any other appender in the system.<div class="subsection">
<h2>Composite Appenders</h2> Composite appenders relay their messages to sub-appenders after providing some filtering or synchronizing functionality on incoming messages. Examples are Log::Log4perl::Appender::Synchronized, Log::Log4perl::Appender::Limit, and Log::Log4perl::Appender::Buffer. Check their manual pages for details.<div class="spacer">
</div>
Composite appender objects are regular Log::Log4perl::Appender objects, but they have the composite flag set:<div class="spacer">
</div>
<br/>
    $app-&gt;composite(1);<br/>
<div class="spacer">
</div>
and they define a <i>post_init()</i> method, which sets the appender it relays its messages to:<div class="spacer">
</div>
<br/>
    ###########################################<br/>
    sub post_init {<br/>
    ############################################<br/>
        my($self) = @_;<br/>
    <br/>
        if(! exists $self-&gt;{appender}) {<br/>
            die &quot;No appender defined for &quot; . __PACKAGE__;<br/>
        }<br/>
    <br/>
        my $appenders = Log::Log4perl-&gt;appenders();<br/>
        my $appender = Log::Log4perl-&gt;appenders()-&gt;{$self-&gt;{appender}};<br/>
    <br/>
        if(! defined $appender) {<br/>
            die &quot;Appender $self-&gt;{appender} not defined (yet) when &quot; .<br/>
                __PACKAGE__ . &quot; needed it&quot;;<br/>
        }<br/>
    <br/>
        $self-&gt;{app} = $appender;<br/>
    }<br/>
<div class="spacer">
</div>
The reason for this post-processing step is that the relay appender might not be defined yet when the composite appender gets defined. This can happen if Log4perl is initialized with a configuration file (which is the most common way to initialize Log4perl), because appenders spring into existance in unpredictable order.<div class="spacer">
</div>
For example, if you define a Synchronized appender like<div class="spacer">
</div>
<br/>
    log4perl.appender.Syncer            = Log::Log4perl::Appender::Synchronized<br/>
    log4perl.appender.Syncer.appender   = Logfile<br/>
<div class="spacer">
</div>
then Log4perl will set the appender's &quot;appender&quot; attribute to the  <i>name</i> of the appender to finally relay messages to. After the Log4perl configuration file has been processed, Log4perl will remember to call the composite appender's  <i>post_init()</i> method, which will grab the relay appender instance referred to by the name (Logfile) and set it in its &quot;app&quot; attribute. This is exactly what the code snippet above does.<div class="spacer">
</div>
But if you initialize Log4perl by its API, you need to remember to perform these steps. Here's the lineup:<div class="spacer">
</div>
<br/>
    use Log::Log4perl qw(get_logger :levels);<br/>
    <br/>
    my $fileApp = Log::Log4perl::Appender-&gt;new(<br/>
                'Log::Log4perl::Appender::File',<br/>
                name     =&gt; 'MyFileApp',<br/>
                filename =&gt; 'mylog',<br/>
                mode     =&gt; 'append',<br/>
                );<br/>
    $fileApp-&gt;layout(<br/>
                Log::Log4perl::Layout::PatternLayout::Multiline-&gt;new(<br/>
                        '%d{yyyy-MM-dd HH:mm:ss} %p [%c] #%P&gt; %m%n')<br/>
                );<br/>
      # Make the appender known to the system (without assigning it to<br/>
      # any logger<br/>
    Log::Log4perl-&gt;add_appender( $fileApp );<br/>
    <br/>
    my $syncApp = Log::Log4perl::Appender-&gt;new(<br/>
                'Log::Log4perl::Appender::Synchronized',<br/>
                name       =&gt; 'MySyncApp',<br/>
                appender   =&gt; 'MyFileApp',<br/>
                key        =&gt; 'nem',<br/>
                );<br/>
    $syncApp-&gt;post_init();<br/>
    $syncApp-&gt;composite(1);<br/>
<br/>
      # The Synchronized appender is now ready, assign it to a logger<br/>
      # and start logging.<br/>
    get_logger(&quot;&quot;)-&gt;add_appender($syncApp);<br/>
<br/>
    get_logger(&quot;&quot;)-&gt;level($DEBUG);<br/>
    get_logger(&quot;wonk&quot;)-&gt;debug(&quot;waah!&quot;);<br/>
<div class="spacer">
</div>
The composite appender's <i>log()</i> function will typically cache incoming messages until a certain trigger condition is met and then forward a bulk of messages to the relay appender.<div class="spacer">
</div>
Caching messages is surprisingly tricky, because you want them to look like they came from the code location they were originally issued from and not from the location that triggers the flush. Luckily, Log4perl offers a cache mechanism for messages, all you need to do is call the base class'  <i>log()</i> function with an additional reference to a scalar, and then save its content to your composite appender's message buffer afterwards:<div class="spacer">
</div>
<br/>
    ###########################################<br/>
    sub log {<br/>
    ###########################################<br/>
        my($self, %params) = @_;<br/>
<br/>
        # ... some logic to decide whether to cache or flush<br/>
<br/>
            # Adjust the caller stack<br/>
        local $Log::Log4perl::caller_depth =<br/>
              $Log::Log4perl::caller_depth + 2;<br/>
<br/>
            # We need to cache.<br/>
            # Ask the appender to save a cached message in $cache<br/>
        $self-&gt;{relay_app}-&gt;SUPER::log(\%params,<br/>
                             $params{log4p_category},<br/>
                             $params{log4p_level}, \my $cache);<br/>
<br/>
            # Save it in the appender's message buffer<br/>
        push @{ $self-&gt;{buffer} }, $cache;<br/>
    }<br/>
<div class="spacer">
</div>
Note that before calling the <i>log()</i> method of the relay appender's base class (and thus introducing two additional levels on the call stack), we need to adjust the call stack to allow Log4perl to render cspecs like the %M or %L correctly.  The cache will then contain a correctly rendered message, according to the layout of the target appender.<div class="spacer">
</div>
Later, when the time comes to flush the cached messages, a call to the relay appender's base class'  <i>log_cached()</i> method with the cached message as an argument will forward the correctly rendered message:<div class="spacer">
</div>
<br/>
    ###########################################<br/>
    sub log {<br/>
    ###########################################<br/>
        my($self, %params) = @_;<br/>
<br/>
        # ... some logic to decide whether to cache or flush<br/>
<br/>
            # Flush pending messages if we have any<br/>
        for my $cache (@{$self-&gt;{buffer}}) {<br/>
            $self-&gt;{relay_app}-&gt;SUPER::log_cached($cache);<br/>
        }<br/>
    }<br/>
</div>
</div>
<div class="section">
<h1>SEE ALSO</h1> Log::Dispatch</div>
<div class="section">
<h1>COPYRIGHT AND LICENSE</h1> Copyright 2002-2009 by Mike Schilli &lt;m@perlmeister.com&gt; and Kevin Goess &lt;cpan@goess.org&gt;.<div class="spacer">
</div>
This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</div>
<table class="foot">
<tr>
<td class="foot-date">
2010-06-17</td>
<td class="foot-os">
perl v5.10.1</td>
</tr>
</table>
</div>
</body>
</html>

