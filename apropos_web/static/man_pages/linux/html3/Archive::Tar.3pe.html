<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Archive::Tar(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Archive::Tar(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
Archive::Tar(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Archive::Tar - module for manipulations of tar archives</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
    use Archive::Tar;<br/>
    my $tar = Archive::Tar-&gt;new;<br/>
<br/>
    $tar-&gt;read('origin.tgz');<br/>
    $tar-&gt;extract();<br/>
<br/>
    $tar-&gt;add_files('file/foo.pl', 'docs/README');<br/>
    $tar-&gt;add_data('file/baz.txt', 'This is the contents now');<br/>
<br/>
    $tar-&gt;rename('oldname', 'new/file/name');<br/>
<br/>
    $tar-&gt;write('files.tar');                   # plain tar<br/>
    $tar-&gt;write('files.tgz', COMPRESS_GZIP);    # gzip compressed<br/>
    $tar-&gt;write('files.tbz', COMPRESS_BZIP);    # bzip2 compressed<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> Archive::Tar provides an object oriented mechanism for handling tar files.  It provides class methods for quick and easy files handling while also allowing for the creation of tar file objects for custom manipulation.  If you have the IO::Zlib module installed, Archive::Tar will also support compressed or gzipped tar files.<div class="spacer">
</div>
An object of class Archive::Tar represents a .tar(.gz) archive full of files and things.</div>
<div class="section">
<h1>Object Methods</h1><div class="subsection">
<h2>Archive::Tar-&gt;new( [$file, $compressed] )</h2> Returns a new Tar object. If given any arguments, &quot;new()&quot; calls the &quot;read()&quot; method automatically, passing on the arguments provided to the &quot;read()&quot; method.<div class="spacer">
</div>
If &quot;new()&quot; is invoked with arguments and the &quot;read()&quot; method fails for any reason, &quot;new()&quot; returns undef.</div>
<div class="subsection">
<h2>$tar-&gt;read ( $filename|$handle, [$compressed, {opt =&gt; 'val'}] )</h2> Read the given tar file into memory. The first argument can either be the name of a file or a reference to an already open filehandle (or an IO::Zlib object if it's compressed)<div class="spacer">
</div>
The &quot;read&quot; will <i>replace</i> any previous content in $tar!<div class="spacer">
</div>
The second argument may be considered optional, but remains for backwards compatibility. Archive::Tar now looks at the file magic to determine what class should be used to open the file and will transparently Do The Right Thing.<div class="spacer">
</div>
Archive::Tar will warn if you try to pass a bzip2 compressed file and the IO::Zlib / IO::Uncompress::Bunzip2 modules are not available and simply return.<div class="spacer">
</div>
Note that you can currently <b>not</b> pass a &quot;gzip&quot; compressed filehandle, which is not opened with &quot;IO::Zlib&quot;, a &quot;bzip2&quot; compressed filehandle, which is not opened with &quot;IO::Uncompress::Bunzip2&quot;, nor a string containing the full archive information (either compressed or uncompressed). These are worth while features, but not currently implemented. See the &quot;TODO&quot; section.<div class="spacer">
</div>
The third argument can be a hash reference with options. Note that all options are case-sensitive.<dl>
<dt>
limit</dt>
<dd>
Do not read more than &quot;limit&quot; files. This is useful if you have very big archives, and are only interested in the first few files.</dd>
</dl>
<dl>
<dt>
filter</dt>
<dd>
Can be set to a regular expression.  Only files with names that match the expression will be read.</dd>
</dl>
<dl>
<dt>
extract</dt>
<dd>
If set to true, immediately extract entries when reading them. This gives you the same memory break as the &quot;extract_archive&quot; function. Note however that entries will not be read into memory, but written straight to disk. This means no &quot;Archive::Tar::File&quot; objects are created for you to inspect.</dd>
</dl>
<div class="spacer">
</div>
All files are stored internally as &quot;Archive::Tar::File&quot; objects. Please consult the Archive::Tar::File documentation for details.<div class="spacer">
</div>
Returns the number of files read in scalar context, and a list of &quot;Archive::Tar::File&quot; objects in list context.</div>
<div class="subsection">
<h2>$tar-&gt;contains_file( $filename )</h2> Check if the archive contains a certain file. It will return true if the file is in the archive, false otherwise.<div class="spacer">
</div>
Note however, that this function does an exact match using &quot;eq&quot; on the full path. So it cannot compensate for case-insensitive file- systems or compare 2 paths to see if they would point to the same underlying file.</div>
<div class="subsection">
<h2>$tar-&gt;extract( [@filenames] )</h2> Write files whose names are equivalent to any of the names in @filenames to disk, creating subdirectories as necessary. This might not work too well under VMS. Under MacPerl, the file's modification time will be converted to the MacOS zero of time, and appropriate conversions will be done to the path.  However, the length of each element of the path is not inspected to see whether it's longer than MacOS currently allows (32 characters).<div class="spacer">
</div>
If &quot;extract&quot; is called without a list of file names, the entire contents of the archive are extracted.<div class="spacer">
</div>
Returns a list of filenames extracted.</div>
<div class="subsection">
<h2>$tar-&gt;extract_file( $file, [$extract_path] )</h2> Write an entry, whose name is equivalent to the file name provided to disk. Optionally takes a second parameter, which is the full native path (including filename) the entry will be written to.<div class="spacer">
</div>
For example:<div class="spacer">
</div>
<br/>
    $tar-&gt;extract_file( 'name/in/archive', 'name/i/want/to/give/it' );<br/>
<br/>
    $tar-&gt;extract_file( $at_file_object,   'name/i/want/to/give/it' );<br/>
<div class="spacer">
</div>
Returns true on success, false on failure.</div>
<div class="subsection">
<h2>$tar-&gt;list_files( [\@properties] )</h2> Returns a list of the names of all the files in the archive.<div class="spacer">
</div>
If &quot;list_files()&quot; is passed an array reference as its first argument it returns a list of hash references containing the requested properties of each file.  The following list of properties is supported: name, size, mtime (last modified date), mode, uid, gid, linkname, uname, gname, devmajor, devminor, prefix.<div class="spacer">
</div>
Passing an array reference containing only one element, 'name', is special cased to return a list of names rather than a list of hash references, making it equivalent to calling &quot;list_files&quot; without arguments.</div>
<div class="subsection">
<h2>$tar-&gt;get_files( [@filenames] )</h2> Returns the &quot;Archive::Tar::File&quot; objects matching the filenames provided. If no filename list was passed, all &quot;Archive::Tar::File&quot; objects in the current Tar object are returned.<div class="spacer">
</div>
Please refer to the &quot;Archive::Tar::File&quot; documentation on how to handle these objects.</div>
<div class="subsection">
<h2>$tar-&gt;get_content( $file )</h2> Return the content of the named file.</div>
<div class="subsection">
<h2>$tar-&gt;replace_content( $file, $content )</h2> Make the string $content be the content for the file named $file.</div>
<div class="subsection">
<h2>$tar-&gt;rename( $file, $new_name )</h2> Rename the file of the in-memory archive to $new_name.<div class="spacer">
</div>
Note that you must specify a Unix path for $new_name, since per tar standard, all files in the archive must be Unix paths.<div class="spacer">
</div>
Returns true on success and false on failure.</div>
<div class="subsection">
<h2>$tar-&gt;remove (@filenamelist)</h2> Removes any entries with names matching any of the given filenames from the in-memory archive. Returns a list of &quot;Archive::Tar::File&quot; objects that remain.</div>
<div class="subsection">
<h2>$tar-&gt;clear</h2> &quot;clear&quot; clears the current in-memory archive. This effectively gives you a 'blank' object, ready to be filled again. Note that &quot;clear&quot; only has effect on the object, not the underlying tarfile.</div>
<div class="subsection">
<h2>$tar-&gt;write ( [$file, $compressed, $prefix] )</h2> Write the in-memory archive to disk.  The first argument can either be the name of a file or a reference to an already open filehandle (a GLOB reference).<div class="spacer">
</div>
The second argument is used to indicate compression. You can either compress using &quot;gzip&quot; or &quot;bzip2&quot;. If you pass a digit, it's assumed to be the &quot;gzip&quot; compression level (between 1 and 9), but the use of constants is preferred:<div class="spacer">
</div>
<br/>
  # write a gzip compressed file<br/>
  $tar-&gt;write( 'out.tgz', COMPRESS_GZIP );<br/>
<br/>
  # write a bzip compressed file<br/>
  $tar-&gt;write( 'out.tbz', COMPRESS_BZIP );<br/>
<div class="spacer">
</div>
Note that when you pass in a filehandle, the compression argument is ignored, as all files are printed verbatim to your filehandle. If you wish to enable compression with filehandles, use an &quot;IO::Zlib&quot; or &quot;IO::Compress::Bzip2&quot; filehandle instead.<div class="spacer">
</div>
The third argument is an optional prefix. All files will be tucked away in the directory you specify as prefix. So if you have files 'a' and 'b' in your archive, and you specify 'foo' as prefix, they will be written to the archive as 'foo/a' and 'foo/b'.<div class="spacer">
</div>
If no arguments are given, &quot;write&quot; returns the entire formatted archive as a string, which could be useful if you'd like to stuff the archive into a socket or a pipe to gzip or something.</div>
<div class="subsection">
<h2>$tar-&gt;add_files( @filenamelist )</h2> Takes a list of filenames and adds them to the in-memory archive.<div class="spacer">
</div>
The path to the file is automatically converted to a Unix like equivalent for use in the archive, and, if on MacOS, the file's modification time is converted from the MacOS epoch to the Unix epoch. So tar archives created on MacOS with  <b>Archive::Tar</b> can be read both with  <i>tar</i> on Unix and applications like <i>suntar</i> or  <i>Stuffit Expander</i> on MacOS.<div class="spacer">
</div>
Be aware that the file's type/creator and resource fork will be lost, which is usually what you want in cross-platform archives.<div class="spacer">
</div>
Instead of a filename, you can also pass it an existing &quot;Archive::Tar::File&quot; object from, for example, another archive. The object will be clone, and effectively be a copy of the original, not an alias.<div class="spacer">
</div>
Returns a list of &quot;Archive::Tar::File&quot; objects that were just added.</div>
<div class="subsection">
<h2>$tar-&gt;add_data ( $filename, $data, [$opthashref] )</h2> Takes a filename, a scalar full of data and optionally a reference to a hash with specific options.<div class="spacer">
</div>
Will add a file to the in-memory archive, with name $filename and content $data. Specific properties can be set using $opthashref. The following list of properties is supported: name, size, mtime (last modified date), mode, uid, gid, linkname, uname, gname, devmajor, devminor, prefix, type.  (On MacOS, the file's path and modification times are converted to Unix equivalents.)<div class="spacer">
</div>
Valid values for the file type are the following constants defined in Archive::Tar::Constants:<dl>
<dt>
FILE</dt>
<dd>
Regular file.</dd>
</dl>
<dl>
<dt>
HARDLINK</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
SYMLINK</dt>
<dd>
Hard and symbolic (&quot;soft&quot;) links; linkname should specify target.</dd>
</dl>
<dl>
<dt>
CHARDEV</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
BLOCKDEV</dt>
<dd>
Character and block devices. devmajor and devminor should specify the major and minor device numbers.</dd>
</dl>
<dl>
<dt>
DIR</dt>
<dd>
Directory.</dd>
</dl>
<dl>
<dt>
FIFO</dt>
<dd>
FIFO (named pipe).</dd>
</dl>
<dl>
<dt>
SOCKET</dt>
<dd>
Socket.</dd>
</dl>
<div class="spacer">
</div>
Returns the &quot;Archive::Tar::File&quot; object that was just added, or &quot;undef&quot; on failure.</div>
<div class="subsection">
<h2>$tar-&gt;error( [$BOOL] )</h2> Returns the current errorstring (usually, the last error reported). If a true value was specified, it will give the &quot;Carp::longmess&quot; equivalent of the error, in effect giving you a stacktrace.<div class="spacer">
</div>
For backwards compatibility, this error is also available as $Archive::Tar::error although it is much recommended you use the method call instead.</div>
<div class="subsection">
<h2>$tar-&gt;setcwd( $cwd );</h2> &quot;Archive::Tar&quot; needs to know the current directory, and it will run &quot;Cwd::cwd()&quot;  <i>every</i> time it extracts a <i>relative</i> entry from the tarfile and saves it in the file system. (As of version 1.30, however, &quot;Archive::Tar&quot; will use the speed optimization described below automatically, so it's only relevant if you're using &quot;extract_file()&quot;).<div class="spacer">
</div>
Since &quot;Archive::Tar&quot; doesn't change the current directory internally while it is extracting the items in a tarball, all calls to &quot;Cwd::cwd()&quot; can be avoided if we can guarantee that the current directory doesn't get changed externally.<div class="spacer">
</div>
To use this performance boost, set the current directory via<div class="spacer">
</div>
<br/>
    use Cwd;<br/>
    $tar-&gt;setcwd( cwd() );<br/>
<div class="spacer">
</div>
once before calling a function like &quot;extract_file&quot; and &quot;Archive::Tar&quot; will use the current directory setting from then on and won't call &quot;Cwd::cwd()&quot; internally.<div class="spacer">
</div>
To switch back to the default behaviour, use<div class="spacer">
</div>
<br/>
    $tar-&gt;setcwd( undef );<br/>
<div class="spacer">
</div>
and &quot;Archive::Tar&quot; will call &quot;Cwd::cwd()&quot; internally again.<div class="spacer">
</div>
If you're using &quot;Archive::Tar&quot;'s &quot;extract()&quot; method, &quot;setcwd()&quot; will be called for you.</div>
</div>
<div class="section">
<h1>Class Methods</h1><div class="subsection">
<h2>Archive::Tar-&gt;create_archive($file, $compressed, @filelist)</h2> Creates a tar file from the list of files provided.  The first argument can either be the name of the tar file to create or a reference to an open file handle (e.g. a GLOB reference).<div class="spacer">
</div>
The second argument is used to indicate compression. You can either compress using &quot;gzip&quot; or &quot;bzip2&quot;. If you pass a digit, it's assumed to be the &quot;gzip&quot; compression level (between 1 and 9), but the use of constants is preferred:<div class="spacer">
</div>
<br/>
  # write a gzip compressed file<br/>
  Archive::Tar-&gt;create_archive( 'out.tgz', COMPRESS_GZIP, @filelist );<br/>
<br/>
  # write a bzip compressed file<br/>
  Archive::Tar-&gt;create_archive( 'out.tbz', COMPRESS_BZIP, @filelist );<br/>
<div class="spacer">
</div>
Note that when you pass in a filehandle, the compression argument is ignored, as all files are printed verbatim to your filehandle. If you wish to enable compression with filehandles, use an &quot;IO::Zlib&quot; or &quot;IO::Compress::Bzip2&quot; filehandle instead.<div class="spacer">
</div>
The remaining arguments list the files to be included in the tar file. These files must all exist. Any files which don't exist or can't be read are silently ignored.<div class="spacer">
</div>
If the archive creation fails for any reason, &quot;create_archive&quot; will return false. Please use the &quot;error&quot; method to find the cause of the failure.<div class="spacer">
</div>
Note that this method does not write &quot;on the fly&quot; as it were; it still reads all the files into memory before writing out the archive. Consult the FAQ below if this is a problem.</div>
<div class="subsection">
<h2>Archive::Tar-&gt;iter( $filename, [ $compressed, {opt =&gt; $val} ] )</h2> Returns an iterator function that reads the tar file without loading it all in memory.  Each time the function is called it will return the next file in the tarball. The files are returned as &quot;Archive::Tar::File&quot; objects. The iterator function returns the empty list once it has exhausted the files contained.<div class="spacer">
</div>
The second argument can be a hash reference with options, which are identical to the arguments passed to &quot;read()&quot;.<div class="spacer">
</div>
Example usage:<div class="spacer">
</div>
<br/>
    my $next = Archive::Tar-&gt;iter( &quot;example.tar.gz&quot;, 1, {filter =&gt; qr/\.pm$/} );<br/>
<br/>
    while( my $f = $next-&gt;() ) {<br/>
        print $f-&gt;name, &quot;\n&quot;;<br/>
<br/>
        $f-&gt;extract or warn &quot;Extraction failed&quot;;<br/>
<br/>
        # ....<br/>
    }<br/>
</div>
<div class="subsection">
<h2>Archive::Tar-&gt;list_archive($file, $compressed, [\@properties])</h2> Returns a list of the names of all the files in the archive.  The first argument can either be the name of the tar file to list or a reference to an open file handle (e.g. a GLOB reference).<div class="spacer">
</div>
If &quot;list_archive()&quot; is passed an array reference as its third argument it returns a list of hash references containing the requested properties of each file.  The following list of properties is supported: full_path, name, size, mtime (last modified date), mode, uid, gid, linkname, uname, gname, devmajor, devminor, prefix.<div class="spacer">
</div>
See &quot;Archive::Tar::File&quot; for details about supported properties.<div class="spacer">
</div>
Passing an array reference containing only one element, 'name', is special cased to return a list of names rather than a list of hash references.</div>
<div class="subsection">
<h2>Archive::Tar-&gt;extract_archive($file, $compressed)</h2> Extracts the contents of the tar file.  The first argument can either be the name of the tar file to create or a reference to an open file handle (e.g. a GLOB reference).  All relative paths in the tar file will be created underneath the current working directory.<div class="spacer">
</div>
&quot;extract_archive&quot; will return a list of files it extracted. If the archive extraction fails for any reason, &quot;extract_archive&quot; will return false.  Please use the &quot;error&quot; method to find the cause of the failure.</div>
<div class="subsection">
<h2>$bool = Archive::Tar-&gt;has_io_string</h2> Returns true if we currently have &quot;IO::String&quot; support loaded.<div class="spacer">
</div>
Either &quot;IO::String&quot; or &quot;perlio&quot; support is needed to support writing stringified archives. Currently, &quot;perlio&quot; is the preferred method, if available.<div class="spacer">
</div>
See the &quot;GLOBAL VARIABLES&quot; section to see how to change this preference.</div>
<div class="subsection">
<h2>$bool = Archive::Tar-&gt;has_perlio</h2> Returns true if we currently have &quot;perlio&quot; support loaded.<div class="spacer">
</div>
This requires &quot;perl-5.8&quot; or higher, compiled with &quot;perlio&quot;<div class="spacer">
</div>
Either &quot;IO::String&quot; or &quot;perlio&quot; support is needed to support writing stringified archives. Currently, &quot;perlio&quot; is the preferred method, if available.<div class="spacer">
</div>
See the &quot;GLOBAL VARIABLES&quot; section to see how to change this preference.</div>
<div class="subsection">
<h2>$bool = Archive::Tar-&gt;has_zlib_support</h2> Returns true if &quot;Archive::Tar&quot; can extract &quot;zlib&quot; compressed archives</div>
<div class="subsection">
<h2>$bool = Archive::Tar-&gt;has_bzip2_support</h2> Returns true if &quot;Archive::Tar&quot; can extract &quot;bzip2&quot; compressed archives</div>
<div class="subsection">
<h2>Archive::Tar-&gt;can_handle_compressed_files</h2> A simple checking routine, which will return true if &quot;Archive::Tar&quot; is able to uncompress compressed archives on the fly with &quot;IO::Zlib&quot; and &quot;IO::Compress::Bzip2&quot; or false if not both are installed.<div class="spacer">
</div>
You can use this as a shortcut to determine whether &quot;Archive::Tar&quot; will do what you think before passing compressed archives to its &quot;read&quot; method.</div>
</div>
<div class="section">
<h1>GLOBAL VARIABLES</h1><div class="subsection">
<h2>$Archive::Tar::FOLLOW_SYMLINK</h2> Set this variable to 1 to make &quot;Archive::Tar&quot; effectively make a copy of the file when extracting. Default is 0, which means the symlink stays intact. Of course, you will have to pack the file linked to as well.<div class="spacer">
</div>
This option is checked when you write out the tarfile using &quot;write&quot; or &quot;create_archive&quot;.<div class="spacer">
</div>
This works just like &quot;/bin/tar&quot;'s &quot;-h&quot; option.</div>
<div class="subsection">
<h2>$Archive::Tar::CHOWN</h2> By default, &quot;Archive::Tar&quot; will try to &quot;chown&quot; your files if it is able to. In some cases, this may not be desired. In that case, set this variable to 0 to disable &quot;chown&quot;-ing, even if it were possible.<div class="spacer">
</div>
The default is 1.</div>
<div class="subsection">
<h2>$Archive::Tar::CHMOD</h2> By default, &quot;Archive::Tar&quot; will try to &quot;chmod&quot; your files to whatever mode was specified for the particular file in the archive. In some cases, this may not be desired. In that case, set this variable to 0 to disable &quot;chmod&quot;-ing.<div class="spacer">
</div>
The default is 1.</div>
<div class="subsection">
<h2>$Archive::Tar::SAME_PERMISSIONS</h2> When, $Archive::Tar::CHMOD is enabled, this setting controls whether the permissions on files from the archive are used without modification of if they are filtered by removing any setid bits and applying the current umask.<div class="spacer">
</div>
The default is 1 for the root user and 0 for normal users.</div>
<div class="subsection">
<h2>$Archive::Tar::DO_NOT_USE_PREFIX</h2> By default, &quot;Archive::Tar&quot; will try to put paths that are over 100 characters in the &quot;prefix&quot; field of your tar header, as defined per POSIX-standard. However, some (older) tar programs do not implement this spec. To retain compatibility with these older or non-POSIX compliant versions, you can set the $DO_NOT_USE_PREFIX variable to a true value, and &quot;Archive::Tar&quot; will use an alternate way of dealing with paths over 100 characters by using the &quot;GNU Extended Header&quot; feature.<div class="spacer">
</div>
Note that clients who do not support the &quot;GNU Extended Header&quot; feature will not be able to read these archives. Such clients include tars on &quot;Solaris&quot;, &quot;Irix&quot; and &quot;AIX&quot;.<div class="spacer">
</div>
The default is 0.</div>
<div class="subsection">
<h2>$Archive::Tar::DEBUG</h2> Set this variable to 1 to always get the &quot;Carp::longmess&quot; output of the warnings, instead of the regular &quot;carp&quot;. This is the same message you would get by doing:<div class="spacer">
</div>
<br/>
    $tar-&gt;error(1);<br/>
<div class="spacer">
</div>
Defaults to 0.</div>
<div class="subsection">
<h2>$Archive::Tar::WARN</h2> Set this variable to 0 if you do not want any warnings printed. Personally I recommend against doing this, but people asked for the option. Also, be advised that this is of course not threadsafe.<div class="spacer">
</div>
Defaults to 1.</div>
<div class="subsection">
<h2>$Archive::Tar::error</h2> Holds the last reported error. Kept for historical reasons, but its use is very much discouraged. Use the &quot;error()&quot; method instead:<div class="spacer">
</div>
<br/>
    warn $tar-&gt;error unless $tar-&gt;extract;<br/>
<div class="spacer">
</div>
Note that in older versions of this module, the &quot;error()&quot; method would return an effectively global value even when called an instance method as above. This has since been fixed, and multiple instances of &quot;Archive::Tar&quot; now have separate error strings.</div>
<div class="subsection">
<h2>$Archive::Tar::INSECURE_EXTRACT_MODE</h2> This variable indicates whether &quot;Archive::Tar&quot; should allow files to be extracted outside their current working directory.<div class="spacer">
</div>
Allowing this could have security implications, as a malicious tar archive could alter or replace any file the extracting user has permissions to. Therefor, the default is to not allow insecure extractions.<div class="spacer">
</div>
If you trust the archive, or have other reasons to allow the archive to write files outside your current working directory, set this variable to &quot;true&quot;.<div class="spacer">
</div>
Note that this is a backwards incompatible change from version 1.36 and before.</div>
<div class="subsection">
<h2>$Archive::Tar::HAS_PERLIO</h2> This variable holds a boolean indicating if we currently have &quot;perlio&quot; support loaded. This will be enabled for any perl greater than 5.8 compiled with &quot;perlio&quot;.<div class="spacer">
</div>
If you feel strongly about disabling it, set this variable to &quot;false&quot;. Note that you will then need &quot;IO::String&quot; installed to support writing stringified archives.<div class="spacer">
</div>
Don't change this variable unless you <b>really</b> know what you're doing.</div>
<div class="subsection">
<h2>$Archive::Tar::HAS_IO_STRING</h2> This variable holds a boolean indicating if we currently have &quot;IO::String&quot; support loaded. This will be enabled for any perl that has a loadable &quot;IO::String&quot; module.<div class="spacer">
</div>
If you feel strongly about disabling it, set this variable to &quot;false&quot;. Note that you will then need &quot;perlio&quot; support from your perl to be able to  write stringified archives.<div class="spacer">
</div>
Don't change this variable unless you <b>really</b> know what you're doing.</div>
<div class="subsection">
<h2>$Archive::Tar::ZERO_PAD_NUMBERS</h2> This variable holds a boolean indicating if we will create zero padded numbers for &quot;size&quot;, &quot;mtime&quot; and &quot;checksum&quot;. The default is 0, indicating that we will create space padded numbers. Added for compatibility with &quot;busybox&quot; implementations.</div>
</div>
<div class="section">
<h1>FAQ</h1><dl>
<dt>
What's the minimum perl version required to run Archive::Tar?</dt>
<dd>
You will need perl version 5.005_03 or newer.</dd>
</dl>
<dl>
<dt>
Isn't Archive::Tar slow?</dt>
<dd>
Yes it is. It's pure perl, so it's a lot slower then your &quot;/bin/tar&quot; However, it's very portable. If speed is an issue, consider using &quot;/bin/tar&quot; instead.</dd>
</dl>
<dl>
<dt>
Isn't Archive::Tar heavier on memory than /bin/tar?</dt>
<dd>
Yes it is, see previous answer. Since &quot;Compress::Zlib&quot; and therefore &quot;IO::Zlib&quot; doesn't support &quot;seek&quot; on their filehandles, there is little choice but to read the archive into memory. This is ok if you want to do in-memory manipulation of the archive.<div style="height: 1.00em;">
&#160;</div>
If you just want to extract, use the &quot;extract_archive&quot; class method instead. It will optimize and write to disk immediately.<div style="height: 1.00em;">
&#160;</div>
Another option is to use the &quot;iter&quot; class method to iterate over the files in the tarball without reading them all in memory at once.</dd>
</dl>
<dl>
<dt>
Can you lazy-load data instead?</dt>
<dd>
In some cases, yes. You can use the &quot;iter&quot; class method to iterate over the files in the tarball without reading them all in memory at once.</dd>
</dl>
<dl>
<dt>
How much memory will an X kb tar file need?</dt>
<dd>
Probably more than X kb, since it will all be read into memory. If this is a problem, and you don't need to do in memory manipulation of the archive, consider using the &quot;iter&quot; class method, or &quot;/bin/tar&quot; instead.</dd>
</dl>
<dl>
<dt>
What do you do with unsupported filetypes in an archive?</dt>
<dd>
&quot;Unix&quot; has a few filetypes that aren't supported on other platforms, like &quot;Win32&quot;. If we encounter a &quot;hardlink&quot; or &quot;symlink&quot; we'll just try to make a copy of the original file, rather than throwing an error.<div style="height: 1.00em;">
&#160;</div>
This does require you to read the entire archive in to memory first, since otherwise we wouldn't know what data to fill the copy with. (This means that you cannot use the class methods, including &quot;iter&quot; on archives that have incompatible filetypes and still expect things to work).<div style="height: 1.00em;">
&#160;</div>
For other filetypes, like &quot;chardevs&quot; and &quot;blockdevs&quot; we'll warn that the extraction of this particular item didn't work.</dd>
</dl>
<dl>
<dt>
I'm using WinZip, or some other non-POSIX client, and files are not being extracted properly!</dt>
<dd>
By default, &quot;Archive::Tar&quot; is in a completely POSIX-compatible mode, which uses the POSIX-specification of &quot;tar&quot; to store files. For paths greater than 100 characters, this is done using the &quot;POSIX header prefix&quot;. Non-POSIX-compatible clients may not support this part of the specification, and may only support the &quot;GNU Extended Header&quot; functionality. To facilitate those clients, you can set the $Archive::Tar::DO_NOT_USE_PREFIX variable to &quot;true&quot;. See the &quot;GLOBAL VARIABLES&quot; section for details on this variable.<div style="height: 1.00em;">
&#160;</div>
Note that GNU tar earlier than version 1.14 does not cope well with the &quot;POSIX header prefix&quot;. If you use such a version, consider setting the $Archive::Tar::DO_NOT_USE_PREFIX variable to &quot;true&quot;.</dd>
</dl>
<dl>
<dt>
How do I extract only files that have property X from an archive?</dt>
<dd>
Sometimes, you might not wish to extract a complete archive, just the files that are relevant to you, based on some criteria.<div style="height: 1.00em;">
&#160;</div>
You can do this by filtering a list of &quot;Archive::Tar::File&quot; objects based on your criteria. For example, to extract only files that have the string &quot;foo&quot; in their title, you would use:<div style="height: 1.00em;">
&#160;</div>
<br/>
    $tar-&gt;extract(<br/>
        grep { $_-&gt;full_path =~ /foo/ } $tar-&gt;get_files<br/>
    );<br/>
<div style="height: 1.00em;">
&#160;</div>
This way, you can filter on any attribute of the files in the archive. Consult the &quot;Archive::Tar::File&quot; documentation on how to use these objects.</dd>
</dl>
<dl>
<dt>
How do I access .tar.Z files?</dt>
<dd>
The &quot;Archive::Tar&quot; module can optionally use &quot;Compress::Zlib&quot; (via the &quot;IO::Zlib&quot; module) to access tar files that have been compressed with &quot;gzip&quot;. Unfortunately tar files compressed with the Unix &quot;compress&quot; utility cannot be read by &quot;Compress::Zlib&quot; and so cannot be directly accesses by &quot;Archive::Tar&quot;.<div style="height: 1.00em;">
&#160;</div>
If the &quot;uncompress&quot; or &quot;gunzip&quot; programs are available, you can use one of these workarounds to read &quot;.tar.Z&quot; files from &quot;Archive::Tar&quot;<div style="height: 1.00em;">
&#160;</div>
Firstly with &quot;uncompress&quot;<div style="height: 1.00em;">
&#160;</div>
<br/>
    use Archive::Tar;<br/>
<br/>
    open F, &quot;uncompress -c $filename |&quot;;<br/>
    my $tar = Archive::Tar-&gt;new(*F);<br/>
    ...<br/>
<div style="height: 1.00em;">
&#160;</div>
and this with &quot;gunzip&quot;<div style="height: 1.00em;">
&#160;</div>
<br/>
    use Archive::Tar;<br/>
<br/>
    open F, &quot;gunzip -c $filename |&quot;;<br/>
    my $tar = Archive::Tar-&gt;new(*F);<br/>
    ...<br/>
<div style="height: 1.00em;">
&#160;</div>
Similarly, if the &quot;compress&quot; program is available, you can use this to write a &quot;.tar.Z&quot; file<div style="height: 1.00em;">
&#160;</div>
<br/>
    use Archive::Tar;<br/>
    use IO::File;<br/>
<br/>
    my $fh = new IO::File &quot;| compress -c &gt;$filename&quot;;<br/>
    my $tar = Archive::Tar-&gt;new();<br/>
    ...<br/>
    $tar-&gt;write($fh);<br/>
    $fh-&gt;close ;<br/>
</dd>
</dl>
<dl>
<dt>
How do I handle Unicode strings?</dt>
<dd>
&quot;Archive::Tar&quot; uses byte semantics for any files it reads from or writes to disk. This is not a problem if you only deal with files and never look at their content or work solely with byte strings. But if you use Unicode strings with character semantics, some additional steps need to be taken.<div style="height: 1.00em;">
&#160;</div>
For example, if you add a Unicode string like<div style="height: 1.00em;">
&#160;</div>
<br/>
    # Problem<br/>
    $tar-&gt;add_data('file.txt', &quot;Euro: \x{20AC}&quot;);<br/>
<div style="height: 1.00em;">
&#160;</div>
then there will be a problem later when the tarfile gets written out to disk via &quot;$tar-&quot; <i>write()</i>&gt;:<div style="height: 1.00em;">
&#160;</div>
<br/>
    Wide character in print at .../Archive/Tar.pm line 1014.<br/>
<div style="height: 1.00em;">
&#160;</div>
The data was added as a Unicode string and when writing it out to disk, the &quot;:utf8&quot; line discipline wasn't set by &quot;Archive::Tar&quot;, so Perl tried to convert the string to ISO-8859 and failed. The written file now contains garbage.<div style="height: 1.00em;">
&#160;</div>
For this reason, Unicode strings need to be converted to UTF-8-encoded bytestrings before they are handed off to &quot;add_data()&quot;:<div style="height: 1.00em;">
&#160;</div>
<br/>
    use Encode;<br/>
    my $data = &quot;Accented character: \x{20AC}&quot;;<br/>
    $data = encode('utf8', $data);<br/>
<br/>
    $tar-&gt;add_data('file.txt', $data);<br/>
<div style="height: 1.00em;">
&#160;</div>
A opposite problem occurs if you extract a UTF8-encoded file from a tarball. Using &quot;get_content()&quot; on the &quot;Archive::Tar::File&quot; object will return its content as a bytestring, not as a Unicode string.<div style="height: 1.00em;">
&#160;</div>
If you want it to be a Unicode string (because you want character semantics with operations like regular expression matching), you need to decode the UTF8-encoded content and have Perl convert it into a Unicode string:<div style="height: 1.00em;">
&#160;</div>
<br/>
    use Encode;<br/>
    my $data = $tar-&gt;get_content();<br/>
<br/>
    # Make it a Unicode string<br/>
    $data = decode('utf8', $data);<br/>
<div style="height: 1.00em;">
&#160;</div>
There is no easy way to provide this functionality in &quot;Archive::Tar&quot;, because a tarball can contain many files, and each of which could be encoded in a different way.</dd>
</dl>
</div>
<div class="section">
<h1>CAVEATS</h1> The AIX tar does not fill all unused space in the tar archive with 0x00. This sometimes leads to warning messages from &quot;Archive::Tar&quot;.<div class="spacer">
</div>
<br/>
  Invalid header block at offset nnn<br/>
<div class="spacer">
</div>
A fix for that problem is scheduled to be released in the following levels of AIX, all of which should be coming out in the 4th quarter of 2009:<div class="spacer">
</div>
<br/>
 AIX 5.3 TL7 SP10<br/>
 AIX 5.3 TL8 SP8<br/>
 AIX 5.3 TL9 SP5<br/>
 AIX 5.3 TL10 SP2<br/>
 <br/>
 AIX 6.1 TL0 SP11<br/>
 AIX 6.1 TL1 SP7<br/>
 AIX 6.1 TL2 SP6<br/>
 AIX 6.1 TL3 SP3<br/>
<div class="spacer">
</div>
The IBM APAR number for this problem is IZ50240 (Reported component ID: 5765G0300 / AIX 5.3). It is possible to get an ifix for that problem. If you need an ifix please contact your local IBM AIX support.</div>
<div class="section">
<h1>TODO</h1><dl>
<dt>
Check if passed in handles are open for read/write</dt>
<dd>
Currently I don't know of any portable pure perl way to do this. Suggestions welcome.</dd>
</dl>
<dl>
<dt>
Allow archives to be passed in as string</dt>
<dd>
Currently, we only allow opened filehandles or filenames, but not strings. The internals would need some reworking to facilitate stringified archives.</dd>
</dl>
<dl>
<dt>
Facilitate processing an opened filehandle of a compressed archive</dt>
<dd>
Currently, we only support this if the filehandle is an IO::Zlib object. Environments, like apache, will present you with an opened filehandle to an uploaded file, which might be a compressed archive.</dd>
</dl>
</div>
<div class="section">
<h1>SEE ALSO</h1><dl>
<dt>
The GNU tar specification</dt>
<dd>
&quot;http://www.gnu.org/software/tar/manual/tar.html&quot;</dd>
</dl>
<dl>
<dt>
The PAX format specification</dt>
<dd>
The specification which tar derives from; &quot; http://www.opengroup.org/onlinepubs/007904975/utilities/pax.html&quot;</dd>
</dl>
<dl>
<dt>
A comparison of GNU and POSIX tar standards; &quot;http://www.delorie.com/gnu/docs/tar/tar_114.html&quot;</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
GNU tar intends to switch to POSIX compatibility</dt>
<dd>
GNU Tar authors have expressed their intention to become completely POSIX-compatible; &quot;http://www.gnu.org/software/tar/manual/html_node/Formats.html&quot;</dd>
</dl>
<dl>
<dt>
A Comparison between various tar implementations</dt>
<dd>
Lists known issues and incompatibilities; &quot;http://gd.tuwien.ac.at/utils/archivers/star/README.otherbugs&quot;</dd>
</dl>
</div>
<div class="section">
<h1>AUTHOR</h1> This module by Jos Boumans &lt;kane@cpan.org&gt;.<div class="spacer">
</div>
Please reports bugs to &lt;bug-archive-tar@rt.cpan.org&gt;.</div>
<div class="section">
<h1>ACKNOWLEDGEMENTS</h1> Thanks to Sean Burke, Chris Nandor, Chip Salzenberg, Tim Heaney, Gisle Aas, Rainer Tammer and especially Andrew Savige for their help and suggestions.</div>
<div class="section">
<h1>COPYRIGHT</h1> This module is copyright (c) 2002 - 2009 Jos Boumans &lt;kane@cpan.org&gt;. All rights reserved.<div class="spacer">
</div>
This library is free software; you may redistribute and/or modify it under the same terms as Perl itself.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-09-26</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

