<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
HTML::Element::traverse(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
HTML::Element::traverse(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
HTML::Element::traverse(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> HTML::Element::traverse - discussion of HTML::Element's traverse method</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
  # $element-&gt;traverse is unnecessary and obscure.<br/>
  #   Don't use it in new code.<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> &quot;HTML::Element&quot; provides a method &quot;traverse&quot; that traverses the tree and calls user-specified callbacks for each node, in pre- or post-order.  However, use of the method is quite superfluous: if you want to recursively visit every node in the tree, it's almost always simpler to write a subroutine does just that, than it is to bundle up the pre- and/or post-order code in callbacks for the &quot;traverse&quot; method.</div>
<div class="section">
<h1>EXAMPLES</h1> Suppose you want to traverse at/under a node $tree and give elements an 'id' attribute unless they already have one.<div class="spacer">
</div>
You can use the &quot;traverse&quot; method:<div class="spacer">
</div>
<br/>
  {<br/>
    my $counter = 'x0000';<br/>
    $start_node-&gt;traverse(<br/>
      [ # Callbacks;<br/>
        # pre-order callback:<br/>
        sub {<br/>
          my $x = $_[0];<br/>
          $x-&gt;attr('id', $counter++) unless defined $x-&gt;attr('id');<br/>
          return HTML::Element::OK; # keep traversing<br/>
        },<br/>
        # post-order callback:<br/>
        undef<br/>
      ],<br/>
      1, # don't call the callbacks for text nodes<br/>
    );<br/>
  }<br/>
<div class="spacer">
</div>
or you can just be simple and clear (and not have to understand the calling format for &quot;traverse&quot;) by writing a sub that traverses the tree by just calling itself:<div class="spacer">
</div>
<br/>
  {<br/>
    my $counter = 'x0000';<br/>
    sub give_id {<br/>
      my $x = $_[0];<br/>
      $x-&gt;attr('id', $counter++) unless defined $x-&gt;attr('id');<br/>
      foreach my $c ($x-&gt;content_list) {<br/>
        give_id($c) if ref $c; # ignore text nodes<br/>
      }<br/>
    };<br/>
    give_id($start_node);<br/>
  }<br/>
<div class="spacer">
</div>
See, isn't that nice and clear?<div class="spacer">
</div>
But, if you really need to know:</div>
<div class="section">
<h1>THE TRAVERSE METHOD</h1> The &quot;traverse()&quot; method is a general object-method for traversing a tree or subtree and calling user-specified callbacks.  It accepts the following syntaxes:<dl>
<dt>
$h-&gt;traverse(\&amp;callback)</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
or $h-&gt;traverse(\&amp;callback, $ignore_text)</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
or $h-&gt;traverse( [\&amp;pre_callback,\&amp;post_callback] , $ignore_text)</dt>
<dd>
</dd>
</dl>
<div class="spacer">
</div>
These all mean to traverse the element and all of its children.  That is, this method starts at node $h, &quot;pre-order visits&quot; $h, traverses its children, and then will &quot;post-order visit&quot; $h.  &quot;Visiting&quot; means that the callback routine is called, with these arguments:<div class="spacer">
</div>
<br/>
    $_[0] : the node (element or text segment),<br/>
    $_[1] : a startflag, and<br/>
    $_[2] : the depth<br/>
<div class="spacer">
</div>
If the $ignore_text parameter is given and true, then the pre-order call  <i>will not</i> be happen for text content.<div class="spacer">
</div>
The startflag is 1 when we enter a node (i.e., in pre-order calls) and 0 when we leave the node (in post-order calls).<div class="spacer">
</div>
Note, however, that post-order calls don't happen for nodes that are text segments or are elements that are prototypically empty (like &quot;br&quot;, &quot;hr&quot;, etc.).<div class="spacer">
</div>
If we visit text nodes (i.e., unless $ignore_text is given and true), then when text nodes are visited, we will also pass two extra arguments to the callback:<div class="spacer">
</div>
<br/>
    $_[3] : the element that's the parent<br/>
             of this text node<br/>
    $_[4] : the index of this text node<br/>
             in its parent's content list<br/>
<div class="spacer">
</div>
Note that you can specify that the pre-order routine can be a different routine from the post-order one:<div class="spacer">
</div>
<br/>
    $h-&gt;traverse( [\&amp;pre_callback,\&amp;post_callback], ...);<br/>
<div class="spacer">
</div>
You can also specify that no post-order calls are to be made, by providing a false value as the post-order routine:<div class="spacer">
</div>
<br/>
    $h-&gt;traverse([ \&amp;pre_callback,0 ], ...);<br/>
<div class="spacer">
</div>
And similarly for suppressing pre-order callbacks:<div class="spacer">
</div>
<br/>
    $h-&gt;traverse([ 0,\&amp;post_callback ], ...);<br/>
<div class="spacer">
</div>
Note that these two syntaxes specify the same operation:<div class="spacer">
</div>
<br/>
    $h-&gt;traverse([\&amp;foo,\&amp;foo], ...);<br/>
    $h-&gt;traverse( \&amp;foo       , ...);<br/>
<div class="spacer">
</div>
The return values from calls to your pre- or post-order routines are significant, and are used to control recursion into the tree.<div class="spacer">
</div>
These are the values you can return, listed in descending order of my estimation of their usefulness:<dl>
<dt>
HTML::Element::OK, 1, or any other true value</dt>
<dd>
...to keep on traversing.<div style="height: 1.00em;">
&#160;</div>
Note that &quot;HTML::Element::OK&quot; et al are constants.  So if you're running under &quot;use strict&quot; (as I hope you are), and you say: &quot;return HTML::Element::PRUEN&quot; the compiler will flag this as an error (an unallowable bareword, specifically), whereas if you spell PRUNE correctly, the compiler will not complain.</dd>
</dl>
<dl>
<dt>
undef, 0, '0', '', or HTML::Element::PRUNE</dt>
<dd>
...to block traversing under the current element's content. (This is ignored if received from a post-order callback, since by then the recursion has already happened.) If this is returned by a pre-order callback, no post-order callback for the current node will happen. (Recall that if your callback exits with just &quot;return;&quot;, it is returning undef -- at least in scalar context, and &quot;traverse&quot; always calls your callbacks in scalar context.)</dd>
</dl>
<dl>
<dt>
HTML::Element::ABORT</dt>
<dd>
...to abort the whole traversal immediately. This is often useful when you're looking for just the first node in the tree that meets some criterion of yours.</dd>
</dl>
<dl>
<dt>
HTML::Element::PRUNE_UP</dt>
<dd>
...to abort continued traversal into this node and its parent node.  No post-order callback for the current or parent node will happen.</dd>
</dl>
<dl>
<dt>
HTML::Element::PRUNE_SOFTLY</dt>
<dd>
Like PRUNE, except that the post-order call for the current node is not blocked.</dd>
</dl>
<div class="spacer">
</div>
Almost every task to do with extracting information from a tree can be expressed in terms of traverse operations (usually in only one pass, and usually paying attention to only pre-order, or to only post-order), or operations based on traversing. (In fact, many of the other methods in this class are basically calls to  <i>traverse()</i> with particular arguments.)<div class="spacer">
</div>
The source code for HTML::Element and HTML::TreeBuilder contain several examples of the use of the &quot;traverse&quot; method to gather information about the content of trees and subtrees.<div class="spacer">
</div>
(Note: you should not change the structure of a tree <i>while</i> you are traversing it.)<div class="spacer">
</div>
[End of documentation for the &quot;traverse()&quot; method]<div class="subsection">
<h2>Traversing with Recursive Anonymous Routines</h2> Now, if you've been reading  <i>Structure and Interpretation of Computer Programs</i> too much, maybe you even want a recursive lambda.  Go ahead:<div class="spacer">
</div>
<br/>
  {<br/>
    my $counter = 'x0000';<br/>
    my $give_id;<br/>
    $give_id = sub {<br/>
      my $x = $_[0];<br/>
      $x-&gt;attr('id', $counter++) unless defined $x-&gt;attr('id');<br/>
      foreach my $c ($x-&gt;content_list) {<br/>
        $give_id-&gt;($c) if ref $c; # ignore text nodes<br/>
      }<br/>
    };<br/>
    $give_id-&gt;($start_node);<br/>
    undef $give_id;<br/>
  }<br/>
<div class="spacer">
</div>
It's a bit nutty, and it's <i>still</i> more concise than a call to the &quot;traverse&quot; method!<div class="spacer">
</div>
It is left as an exercise to the reader to figure out how to do the same thing without using a $give_id symbol at all.<div class="spacer">
</div>
It is also left as an exercise to the reader to figure out why I undefine $give_id, above; and why I could achieved the same effect with any of:<div class="spacer">
</div>
<br/>
    $give_id = 'I like pie!';<br/>
   # or...<br/>
    $give_id = [];<br/>
   # or even;<br/>
    $give_id = sub { print &quot;Mmmm pie!\n&quot; };<br/>
<div class="spacer">
</div>
But not:<div class="spacer">
</div>
<br/>
    $give_id = sub { print &quot;I'm $give_id and I like pie!\n&quot; };<br/>
   # nor...<br/>
    $give_id = \$give_id;<br/>
   # nor...<br/>
    $give_id = { 'pie' =&gt; \$give_id, 'mode' =&gt; 'a la' };<br/>
</div>
<div class="subsection">
<h2>Doing Recursive Things Iteratively</h2> Note that you may at times see an iterative implementation of pre-order traversal, like so:<div class="spacer">
</div>
<br/>
   {<br/>
     my @to_do = ($tree); # start-node<br/>
     while(@to_do) {<br/>
       my $this = shift @to_do;<br/>
       <br/>
       # &quot;Visit&quot; the node:<br/>
       $this-&gt;attr('id', $counter++)<br/>
        unless defined $this-&gt;attr('id');<br/>
       <br/>
       unshift @to_do, grep ref $_, $this-&gt;content_list;<br/>
        # Put children on the stack -- they'll be visited next<br/>
     }<br/>
   }<br/>
<div class="spacer">
</div>
This can <i>under certain circumstances</i> be more efficient than just a normal recursive routine, but at the cost of being rather obscure.  It gains efficiency by avoiding the overhead of function-calling, but since there are several method dispatches however you do it (to &quot;attr&quot; and &quot;content_list&quot;), the overhead for a simple function call is insignificant.</div>
<div class="subsection">
<h2>Pruning and Whatnot</h2> The &quot;traverse&quot; method does have the fairly neat features of the &quot;ABORT&quot;, &quot;PRUNE_UP&quot; and &quot;PRUNE_SOFTLY&quot; signals.  None of these can be implemented  <i>totally</i> straightforwardly with recursive routines, but it is quite possible.  &quot;ABORT&quot;-like behavior can be implemented either with using non-local returning with &quot;eval&quot;/&quot;die&quot;:<div class="spacer">
</div>
<br/>
  my $died_on; # if you need to know where...<br/>
  sub thing {<br/>
    ... visits $_[0]...<br/>
    ... maybe set $died_on to $_[0] and die &quot;ABORT_TRAV&quot; ...<br/>
    ... else call thing($child) for each child...<br/>
    ...any post-order visiting $_[0]...<br/>
  }<br/>
  eval { thing($node) };<br/>
  if($@) {<br/>
    if($@ =~ m&lt;^ABORT_TRAV&gt;) {<br/>
      ...it died (aborted) on $died_on...<br/>
    } else {<br/>
      die $@; # some REAL error happened<br/>
    }<br/>
  }<br/>
<div class="spacer">
</div>
or you can just do it with flags:<div class="spacer">
</div>
<br/>
  my($abort_flag, $died_on);<br/>
  sub thing {<br/>
    ... visits $_[0]...<br/>
    ... maybe set $abort_flag = 1; $died_on = $_[0]; return;<br/>
    foreach my $c ($_[0]-&gt;content_list) {<br/>
      thing($c);<br/>
      return if $abort_flag;<br/>
    }<br/>
    ...any post-order visiting $_[0]...<br/>
    return;<br/>
  }<br/>
<br/>
  $abort_flag = $died_on = undef;<br/>
  thing($node);<br/>
  ...if defined $abort_flag, it died on $died_on<br/>
</div>
</div>
<div class="section">
<h1>SEE ALSO</h1> HTML::Element</div>
<div class="section">
<h1>COPYRIGHT</h1> Copyright 2000,2001 Sean M. Burke</div>
<div class="section">
<h1>AUTHOR Current Author: Jeff Fearn &quot;&lt;jfearn@cpan.org&gt;&quot;.</h1> Original HTML-Tree author: 	Gisle Aas.<div class="spacer">
</div>
Former Authors: 	Sean M. Burke. 	Andy Lester. 	Pete Krawczyk &quot;&lt;petek@cpan.org&gt;&quot;.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-04-30</td>
<td class="foot-os">
perl v5.10.1</td>
</tr>
</table>
</div>
</body>
</html>

