<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Bytes(3)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Bytes(3)</td>
<td class="head-vol">
OCaml library</td>
<td class="head-rtitle">
Bytes(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Bytes - Byte sequence operations.</div>
<div class="section">
<h1>Module</h1> Module   Bytes</div>
<div class="section">
<h1>Documentation</h1> Module <b>Bytes</b><br/>
 : <b>sig end</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
Byte sequence operations.<div style="height: 1.00em;">
&#160;</div>
A byte sequence is a mutable data structure that contains a fixed-length sequence of bytes. Each byte can be indexed in constant time for reading or writing.<div style="height: 1.00em;">
&#160;</div>
Given a byte sequence <b>s</b> of length <b>l</b> , we can access each of the <b>l</b> bytes of <b>s</b> via its index in the sequence. Indexes start at <b>0</b> , and we will call an index valid in <b>s</b> if it falls within the range <b>[0...l-1]</b> (inclusive). A position is the point between two bytes or at the beginning or end of the sequence.  We call a position valid in <b>s</b> if it falls within the range <b>[0...l]</b> (inclusive). Note that the byte at index <b>n</b> is between positions <b>n</b> and <b>n+1</b> .<div style="height: 1.00em;">
&#160;</div>
Two parameters <b>start</b> and <b>len</b> are said to designate a valid range of <b>s</b> if <b>len &gt;= 0</b> and <b>start</b> and <b>start+len</b> are valid positions in <b>s</b> .<div style="height: 1.00em;">
&#160;</div>
Byte sequences can be modified in place, for instance via the <b>set</b> and <b>blit</b> functions described below.  See also strings (module <b>String</b> ), which are almost the same data structure, but cannot be modified in place.<div style="height: 1.00em;">
&#160;</div>
Bytes are represented by the OCaml type <b>char</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>Since</b> 4.02.0<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val length</i> : <b>bytes -&gt; int</b><div style="height: 1.00em;">
&#160;</div>
Return the length (number of bytes) of the argument.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val get</i> : <b>bytes -&gt; int -&gt; char</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>get s n</b> returns the byte at index <b>n</b> in argument <b>s</b> .<div style="height: 1.00em;">
&#160;</div>
Raise <b>Invalid_argument</b> if <b>n</b> not a valid index in <b>s</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val set</i> : <b>bytes -&gt; int -&gt; char -&gt; unit</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>set s n c</b> modifies <b>s</b> in place, replacing the byte at index <b>n</b> with <b>c</b> .<div style="height: 1.00em;">
&#160;</div>
Raise <b>Invalid_argument</b> if <b>n</b> is not a valid index in <b>s</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val create</i> : <b>int -&gt; bytes</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>create n</b> returns a new byte sequence of length <b>n</b> . The sequence is uninitialized and contains arbitrary bytes.<div style="height: 1.00em;">
&#160;</div>
Raise <b>Invalid_argument</b> if <b>n &lt; 0</b> or <b>n &gt;</b> <b>Sys.max_string_length</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val make</i> : <b>int -&gt; char -&gt; bytes</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>make n c</b> returns a new byte sequence of length <b>n</b> , filled with the byte <b>c</b> .<div style="height: 1.00em;">
&#160;</div>
Raise <b>Invalid_argument</b> if <b>n &lt; 0</b> or <b>n &gt;</b> <b>Sys.max_string_length</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val init</i> : <b>int -&gt; (int -&gt; char) -&gt; bytes</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>Bytes.init n f</b> returns a fresh byte sequence of length <b>n</b> , with character <b>i</b> initialized to the result of <b>f i</b> (in increasing index order).<div style="height: 1.00em;">
&#160;</div>
Raise <b>Invalid_argument</b> if <b>n &lt; 0</b> or <b>n &gt;</b> <b>Sys.max_string_length</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val empty</i> : <b>bytes</b><div style="height: 1.00em;">
&#160;</div>
A byte sequence of size 0.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val copy</i> : <b>bytes -&gt; bytes</b><div style="height: 1.00em;">
&#160;</div>
Return a new byte sequence that contains the same bytes as the argument.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val of_string</i> : <b>string -&gt; bytes</b><div style="height: 1.00em;">
&#160;</div>
Return a new byte sequence that contains the same bytes as the given string.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val to_string</i> : <b>bytes -&gt; string</b><div style="height: 1.00em;">
&#160;</div>
Return a new string that contains the same bytes as the given byte sequence.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val sub</i> : <b>bytes -&gt; int -&gt; int -&gt; bytes</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>sub s start len</b> returns a new byte sequence of length <b>len</b> , containing the subsequence of <b>s</b> that starts at position <b>start</b> and has length <b>len</b> .<div style="height: 1.00em;">
&#160;</div>
Raise <b>Invalid_argument</b> if <b>start</b> and <b>len</b> do not designate a valid range of <b>s</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val sub_string</i> : <b>bytes -&gt; int -&gt; int -&gt; string</b><div style="height: 1.00em;">
&#160;</div>
Same as <b>sub</b> but return a string instead of a byte sequence.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val extend</i> : <b>bytes -&gt; int -&gt; int -&gt; bytes</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>extend s left right</b> returns a new byte sequence that contains the bytes of <b>s</b> , with <b>left</b> uninitialized bytes prepended and <b>right</b> uninitialized bytes appended to it. If <b>left</b> or <b>right</b> is negative, then bytes are removed (instead of appended) from the corresponding side of <b>s</b> .<div style="height: 1.00em;">
&#160;</div>
Raise <b>Invalid_argument</b> if the result length is negative or longer than <b>Sys.max_string_length</b> bytes.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val fill</i> : <b>bytes -&gt; int -&gt; int -&gt; char -&gt; unit</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>fill s start len c</b> modifies <b>s</b> in place, replacing <b>len</b> characters with <b>c</b> , starting at <b>start</b> .<div style="height: 1.00em;">
&#160;</div>
Raise <b>Invalid_argument</b> if <b>start</b> and <b>len</b> do not designate a valid range of <b>s</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val blit</i> : <b>bytes -&gt; int -&gt; bytes -&gt; int -&gt; int -&gt; unit</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>blit src srcoff dst dstoff len</b> copies <b>len</b> bytes from sequence <b>src</b> , starting at index <b>srcoff</b> , to sequence <b>dst</b> , starting at index <b>dstoff</b> . It works correctly even if <b>src</b> and <b>dst</b> are the same byte sequence, and the source and destination intervals overlap.<div style="height: 1.00em;">
&#160;</div>
Raise <b>Invalid_argument</b> if <b>srcoff</b> and <b>len</b> do not designate a valid range of <b>src</b> , or if <b>dstoff</b> and <b>len</b> do not designate a valid range of <b>dst</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val blit_string</i> : <b>string -&gt; int -&gt; bytes -&gt; int -&gt; int -&gt; unit</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>blit src srcoff dst dstoff len</b> copies <b>len</b> bytes from string <b>src</b> , starting at index <b>srcoff</b> , to byte sequence <b>dst</b> , starting at index <b>dstoff</b> .<div style="height: 1.00em;">
&#160;</div>
Raise <b>Invalid_argument</b> if <b>srcoff</b> and <b>len</b> do not designate a valid range of <b>src</b> , or if <b>dstoff</b> and <b>len</b> do not designate a valid range of <b>dst</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val concat</i> : <b>bytes -&gt; bytes list -&gt; bytes</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>concat sep sl</b> concatenates the list of byte sequences <b>sl</b> , inserting the separator byte sequence <b>sep</b> between each, and returns the result as a new byte sequence.<div style="height: 1.00em;">
&#160;</div>
Raise <b>Invalid_argument</b> if the result is longer than <b>Sys.max_string_length</b> bytes.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val cat</i> : <b>bytes -&gt; bytes -&gt; bytes</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>cat s1 s2</b> concatenates <b>s1</b> and <b>s2</b> and returns the result as new byte sequence.<div style="height: 1.00em;">
&#160;</div>
Raise <b>Invalid_argument</b> if the result is longer than <b>Sys.max_string_length</b> bytes.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val iter</i> : <b>(char -&gt; unit) -&gt; bytes -&gt; unit</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>iter f s</b> applies function <b>f</b> in turn to all the bytes of <b>s</b> . It is equivalent to <b>f (get s 0); f (get s 1); ...; f (get s</b> <b>(length s - 1)); ()</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val iteri</i> : <b>(int -&gt; char -&gt; unit) -&gt; bytes -&gt; unit</b><div style="height: 1.00em;">
&#160;</div>
Same as <b>Bytes.iter</b> , but the function is applied to the index of the byte as first argument and the byte itself as second argument.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val map</i> : <b>(char -&gt; char) -&gt; bytes -&gt; bytes</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>map f s</b> applies function <b>f</b> in turn to all the bytes of <b>s</b> (in increasing index order) and stores the resulting bytes in a new sequence that is returned as the result.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val mapi</i> : <b>(int -&gt; char -&gt; char) -&gt; bytes -&gt; bytes</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>mapi f s</b> calls <b>f</b> with each character of <b>s</b> and its index (in increasing index order) and stores the resulting bytes in a new sequence that is returned as the result.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val trim</i> : <b>bytes -&gt; bytes</b><div style="height: 1.00em;">
&#160;</div>
Return a copy of the argument, without leading and trailing whitespace. The bytes regarded as whitespace are the ASCII characters <b>' '</b> , <b>'\012'</b> , <b>'\n'</b> , <b>'\r'</b> , and <b>'\t'</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val escaped</i> : <b>bytes -&gt; bytes</b><div style="height: 1.00em;">
&#160;</div>
Return a copy of the argument, with special characters represented by escape sequences, following the lexical conventions of OCaml.<div style="height: 1.00em;">
&#160;</div>
Raise <b>Invalid_argument</b> if the result is longer than <b>Sys.max_string_length</b> bytes.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val index</i> : <b>bytes -&gt; char -&gt; int</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>index s c</b> returns the index of the first occurrence of byte <b>c</b> in <b>s</b> .<div style="height: 1.00em;">
&#160;</div>
Raise <b>Not_found</b> if <b>c</b> does not occur in <b>s</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val rindex</i> : <b>bytes -&gt; char -&gt; int</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>rindex s c</b> returns the index of the last occurrence of byte <b>c</b> in <b>s</b> .<div style="height: 1.00em;">
&#160;</div>
Raise <b>Not_found</b> if <b>c</b> does not occur in <b>s</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val index_from</i> : <b>bytes -&gt; int -&gt; char -&gt; int</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>index_from s i c</b> returns the index of the first occurrence of byte <b>c</b> in <b>s</b> after position <b>i</b> . <b>Bytes.index s c</b> is equivalent to <b>Bytes.index_from s 0 c</b> .<div style="height: 1.00em;">
&#160;</div>
Raise <b>Invalid_argument</b> if <b>i</b> is not a valid position in <b>s</b> . Raise <b>Not_found</b> if <b>c</b> does not occur in <b>s</b> after position <b>i</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val rindex_from</i> : <b>bytes -&gt; int -&gt; char -&gt; int</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>rindex_from s i c</b> returns the index of the last occurrence of byte <b>c</b> in <b>s</b> before position <b>i+1</b> . <b>rindex s c</b> is equivalent to <b>rindex_from s (Bytes.length s - 1) c</b> .<div style="height: 1.00em;">
&#160;</div>
Raise <b>Invalid_argument</b> if <b>i+1</b> is not a valid position in <b>s</b> . Raise <b>Not_found</b> if <b>c</b> does not occur in <b>s</b> before position <b>i+1</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val contains</i> : <b>bytes -&gt; char -&gt; bool</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>contains s c</b> tests if byte <b>c</b> appears in <b>s</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val contains_from</i> : <b>bytes -&gt; int -&gt; char -&gt; bool</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>contains_from s start c</b> tests if byte <b>c</b> appears in <b>s</b> after position <b>start</b> . <b>contains s c</b> is equivalent to <b>contains_from</b> <b>s 0 c</b> .<div style="height: 1.00em;">
&#160;</div>
Raise <b>Invalid_argument</b> if <b>start</b> is not a valid position in <b>s</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val rcontains_from</i> : <b>bytes -&gt; int -&gt; char -&gt; bool</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>rcontains_from s stop c</b> tests if byte <b>c</b> appears in <b>s</b> before position <b>stop+1</b> .<div style="height: 1.00em;">
&#160;</div>
Raise <b>Invalid_argument</b> if <b>stop &lt; 0</b> or <b>stop+1</b> is not a valid position in <b>s</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val uppercase</i> : <b>bytes -&gt; bytes</b><div style="height: 1.00em;">
&#160;</div>
Return a copy of the argument, with all lowercase letters translated to uppercase, including accented letters of the ISO Latin-1 (8859-1) character set.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val lowercase</i> : <b>bytes -&gt; bytes</b><div style="height: 1.00em;">
&#160;</div>
Return a copy of the argument, with all uppercase letters translated to lowercase, including accented letters of the ISO Latin-1 (8859-1) character set.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val capitalize</i> : <b>bytes -&gt; bytes</b><div style="height: 1.00em;">
&#160;</div>
Return a copy of the argument, with the first byte set to uppercase.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val uncapitalize</i> : <b>bytes -&gt; bytes</b><div style="height: 1.00em;">
&#160;</div>
Return a copy of the argument, with the first byte set to lowercase.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>type t</i> = <b>bytes</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
An alias for the type of byte sequences.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val compare</i> : <b>t -&gt; t -&gt; int</b><div style="height: 1.00em;">
&#160;</div>
The comparison function for byte sequences, with the same specification as <b>Pervasives.compare</b> .  Along with the type <b>t</b> , this function <b>compare</b> allows the module <b>Bytes</b> to be passed as argument to the functors <b>Set.Make</b> and <b>Map.Make</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Unsafe conversions (for advanced users)</b> <b>This section describes unsafe, low-level conversion functions</b> <b>between bytes and string. They do not copy the internal data;</b> <b>used improperly, they can break the immutability invariant on</b> <b>strings provided by the -safe-string option. They are available for</b> <b>expert library authors, but for most purposes you should use the</b> <b>always-correct Bytes.to_string and Bytes.of_string instead. ===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val unsafe_to_string</i> : <b>bytes -&gt; string</b><div style="height: 1.00em;">
&#160;</div>
Unsafely convert a byte sequence into a string.<div style="height: 1.00em;">
&#160;</div>
To reason about the use of <b>unsafe_to_string</b> , it is convenient to consider an &quot;ownership&quot; discipline. A piece of code that manipulates some data &quot;owns&quot; it; there are several disjoint ownership modes, including:<div style="height: 1.00em;">
&#160;</div>
-Unique ownership: the data may be accessed and mutated<div style="height: 1.00em;">
&#160;</div>
-Shared ownership: the data has several owners, that may only access it, not mutate it.<div style="height: 1.00em;">
&#160;</div>
Unique ownership is linear: passing the data to another piece of code means giving up ownership (we cannot write the data again). A unique owner may decide to make the data shared (giving up mutation rights on it), but shared data may not become uniquely-owned again.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>unsafe_to_string s</b> can only be used when the caller owns the byte sequence <b>s</b> -- either uniquely or as shared immutable data. The caller gives up ownership of <b>s</b> , and gains ownership of the returned string.<div style="height: 1.00em;">
&#160;</div>
There are two valid use-cases that respect this ownership discipline:<div style="height: 1.00em;">
&#160;</div>
1. Creating a string by initializing and mutating a byte sequence that is never changed after initialization is performed.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>let string_init len f : string =</b> <b>let s = Bytes.create len in</b> <b>for i = 0 to len - 1 do Bytes.set s i (f i) done;</b> <b>Bytes.unsafe_to_string s</b> <b><div style="height: 1.00em;">
&#160;</div>
This function is safe because the byte sequence</b> <b>s</b> will never be accessed or mutated after <b>unsafe_to_string</b> is called. The <b>string_init</b> code gives up ownership of <b>s</b> , and returns the ownership of the resulting string to its caller.<div style="height: 1.00em;">
&#160;</div>
Note that it would be unsafe if <b>s</b> was passed as an additional parameter to the function <b>f</b> as it could escape this way and be mutated in the future -- <b>string_init</b> would give up ownership of <b>s</b> to pass it to <b>f</b> , and could not call <b>unsafe_to_string</b> safely.<div style="height: 1.00em;">
&#160;</div>
We have provided the <b>String.init</b> , <b>String.map</b> and <b>String.mapi</b> functions to cover most cases of building new strings. You should prefer those over <b>to_string</b> or <b>unsafe_to_string</b> whenever applicable.<div style="height: 1.00em;">
&#160;</div>
2. Temporarily giving ownership of a byte sequence to a function that expects a uniquely owned string and returns ownership back, so that we can mutate the sequence again after the call ended.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>let bytes_length (s : bytes) =</b> <b>String.length (Bytes.unsafe_to_string s)</b> <b><div style="height: 1.00em;">
&#160;</div>
In this use-case, we do not promise that</b> <b>s</b> will never be mutated after the call to <b>bytes_length s</b> . The <b>String.length</b> function temporarily borrows unique ownership of the byte sequence (and sees it as a <b>string</b> ), but returns this ownership back to the caller, which may assume that <b>s</b> is still a valid byte sequence after the call. Note that this is only correct because we know that <b>String.length</b> does not capture its argument -- it could escape by a side-channel such as a memoization combinator.<div style="height: 1.00em;">
&#160;</div>
The caller may not mutate <b>s</b> while the string is borrowed (it has temporarily given up ownership). This affects concurrent programs, but also higher-order functions: if <b>String.length</b> returned a closure to be called later, <b>s</b> should not be mutated until this closure is fully applied and returns ownership.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val unsafe_of_string</i> : <b>string -&gt; bytes</b><div style="height: 1.00em;">
&#160;</div>
Unsafely convert a shared string to a byte sequence that should not be mutated.<div style="height: 1.00em;">
&#160;</div>
The same ownership discipline that makes <b>unsafe_to_string</b> correct applies to <b>unsafe_of_string</b> : you may use it if you were the owner of the <b>string</b> value, and you will own the return <b>bytes</b> in the same mode.<div style="height: 1.00em;">
&#160;</div>
In practice, unique ownership of string values is extremely difficult to reason about correctly. You should always assume strings are shared, never uniquely owned.<div style="height: 1.00em;">
&#160;</div>
For example, string literals are implicitly shared by the compiler, so you never uniquely own them.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>let incorrect = Bytes.unsafe_of_string hello</b> <b>let s = Bytes.of_string hello</b> <b><div style="height: 1.00em;">
&#160;</div>
The first declaration is incorrect, because the string literal</b> <b>hello</b> could be shared by the compiler with other parts of the program, and mutating <b>incorrect</b> is a bug. You must always use the second version, which performs a copy and is thus correct.<div style="height: 1.00em;">
&#160;</div>
Assuming unique ownership of strings that are not string literals, but are (partly) built from string literals, is also incorrect. For example, mutating <b>unsafe_of_string (&quot;foo&quot; ^ s)</b> could mutate the shared string <b>foo</b> -- assuming a rope-like representation of strings. More generally, functions operating on strings will assume shared ownership, they do not preserve unique ownership. It is thus incorrect to assume unique ownership of the result of <b>unsafe_of_string</b> .<div style="height: 1.00em;">
&#160;</div>
The only case we have reasonable confidence is safe is if the produced <b>bytes</b> is shared -- used as an immutable byte sequence. This is possibly useful for incremental migration of low-level programs that manipulate immutable sequences of bytes (for example <b>Marshal.from_bytes</b> ) and previously used the <b>string</b> type for this purpose.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<table class="foot">
<tr>
<td class="foot-date">
2015-08-12</td>
<td class="foot-os">
OCamldoc</td>
</tr>
</table>
</div>
</body>
</html>

