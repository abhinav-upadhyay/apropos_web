<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Mutual Exclusion(3)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Mutual Exclusion(3)</td>
<td class="head-vol">
globus common</td>
<td class="head-rtitle">
Mutual Exclusion(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Mutual Exclusion -<div class="subsection">
<h2>Data Structures</h2><br/>
union <b>globus_mutex_t</b><div style="height: 0.00em;">
&#160;</div>
<i>Mutex. </i> union  <b>globus_mutexattr_t</b><div style="height: 0.00em;">
&#160;</div>
<i>Mutex attribute. </i> struct  <b>globus_rmutex_t</b><div style="height: 0.00em;">
&#160;</div>
<i>Recursive Mutex. </i><br/>
</div>
<div class="subsection">
<h2>Typedefs</h2><br/>
typedef int <b>globus_rmutexattr_t</b><div style="height: 0.00em;">
&#160;</div>
<br/>
</div>
<div class="subsection">
<h2>Functions</h2><br/>
int <b>globus_mutex_init</b> (<b>globus_mutex_t</b> *mutex, <b>globus_mutexattr_t</b> *attr)<div style="height: 0.00em;">
&#160;</div>
int <b>globus_mutex_destroy</b> (<b>globus_mutex_t</b> *mutex)<div style="height: 0.00em;">
&#160;</div>
int <b>globus_mutex_lock</b> (<b>globus_mutex_t</b> *mutex)<div style="height: 0.00em;">
&#160;</div>
int <b>globus_mutex_unlock</b> (<b>globus_mutex_t</b> *mutex)<div style="height: 0.00em;">
&#160;</div>
int <b>globus_mutex_trylock</b> (<b>globus_mutex_t</b> *mutex)<div style="height: 0.00em;">
&#160;</div>
int <b>globus_mutexattr_init</b> (<b>globus_mutexattr_t</b> *attr)<div style="height: 0.00em;">
&#160;</div>
int <b>globus_mutexattr_destroy</b> (<b>globus_mutexattr_t</b> *attr)<div style="height: 0.00em;">
&#160;</div>
<br/>
</div>
<div class="subsection">
<h2>Recursive Mutex</h2><br/>
int <b>globus_rmutex_init</b> (<b>globus_rmutex_t</b> *rmutex, <b>globus_rmutexattr_t</b> *rattr)<div style="height: 0.00em;">
&#160;</div>
int <b>globus_rmutex_lock</b> (<b>globus_rmutex_t</b> *rmutex)<div style="height: 0.00em;">
&#160;</div>
int <b>globus_rmutex_unlock</b> (<b>globus_rmutex_t</b> *rmutex)<div style="height: 0.00em;">
&#160;</div>
int <b>globus_rmutex_destroy</b> (<b>globus_rmutex_t</b> *rmutex)<div style="height: 0.00em;">
&#160;</div>
<br/>
</div>
</div>
<div class="section">
<h1>Detailed Description</h1> The Globus runtime includes three portable, related mutual exclusion primitives that can be used in applications and libraries. These are<dl>
<dt>
&#8226;</dt>
<dd>
<b>globus_mutex_t</b>: a non-recursive, non-shared lock</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
<b>globus_rmutex_t</b>: a recursive non-shared lock</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
globus_rw_mutex_t: a reader-writer lock</dd>
</dl>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>Typedef Documentation</h1><div class="subsection">
<h2>typedef int <b>globus_rmutexattr_t</b></h2> Recursive mutex attribute.</div>
</div>
<div class="section">
<h1>Function Documentation</h1><div class="subsection">
<h2>int <b>globus_mutex_init</b> (<b>globus_mutex_t</b> *mutex, <b>globus_mutexattr_t</b> *attr)</h2> Initialize a mutex. The  <b>globus_mutex_init()</b> function creates a mutex variable that can be used for synchronization. Currently, the <i>attr</i> parameter is ignored.<div class="spacer">
</div>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>mutex</i> Pointer to the mutex to initialize.<div style="height: 0.00em;">
&#160;</div>
<i>attr</i> Ignored.</div>
<div class="spacer">
</div>
<b>Returns:</b><div style="margin-left: 4.00ex;">
On success, <b>globus_mutex_init()</b> initializes the mutex and returns GLOBUS_SUCCESS. Otherwise, a non-0 value is returned.</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int <b>globus_mutex_destroy</b> (<b>globus_mutex_t</b> *mutex)</h2> Destroy a mutex. The  <b>globus_mutex_destroy()</b> function destroys the mutex pointed to by its <i>mutex</i> parameter. After a mutex is destroyed it may no longer be used unless it is again initialized by <b>globus_mutex_init()</b>. Behavior is undefined if <b>globus_mutex_destroy()</b> is called with a pointer to a locked mutex.<div class="spacer">
</div>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>mutex</i> The mutex to destroy</div>
<div class="spacer">
</div>
<b>Returns:</b><div style="margin-left: 4.00ex;">
On success, <b>globus_mutex_destroy()</b> returns GLOBUS_SUCCESS. Otherwise, a non-zero implementation-specific error value is returned.</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int <b>globus_mutex_lock</b> (<b>globus_mutex_t</b> *mutex)</h2> Lock a mutex. The  <b>globus_mutex_lock()</b> function locks the mutex pointed to by its <i>mutex</i> parameter. Upon successful return, the thread calling <b>globus_mutex_lock()</b> has an exclusive lock on the resources protected by <i>mutex</i>. Other threads calling <b>globus_mutex_lock()</b> will wait until that thread later calls <b>globus_mutex_unlock()</b> or <b>globus_cond_wait()</b> with that mutex. Depending on the thread model, calling globus_mutex_lock on a mutex locked by the current thread will either return an error or result in deadlock.<div class="spacer">
</div>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>mutex</i> The mutex to lock.</div>
<div class="spacer">
</div>
<b>Returns:</b><div style="margin-left: 4.00ex;">
On success, <b>globus_mutex_lock()</b> returns GLOBUS_SUCCESS. Otherwise, a non-zero implementation-specific error value is returned.</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int <b>globus_mutex_unlock</b> (<b>globus_mutex_t</b> *mutex)</h2> Unlock a mutex. The  <b>globus_mutex_unlock()</b> function unlocks the mutex pointed to by its <i>mutex</i> parameter. Upon successful return, the thread calling <b>globus_mutex_unlock()</b> no longer has an exclusive lock on the resources protected by <i>mutex</i>. Another thread calling <b>globus_mutex_lock()</b> may be unblocked so that it may acquire the mutex. Behavior is undefined if globus_mutex_unlock is called with an unlocked mutex.<div class="spacer">
</div>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>mutex</i> The mutex to unlock.</div>
<div class="spacer">
</div>
<b>Returns:</b><div style="margin-left: 4.00ex;">
On success, <b>globus_mutex_unlock()</b> returns GLOBUS_SUCCESS. Otherwise, a non-zero implementation-specific error value is returned.</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int <b>globus_mutex_trylock</b> (<b>globus_mutex_t</b> *mutex)</h2> Lock a mutex if it is not locked. The  <b>globus_mutex_trylock()</b> function locks the mutex pointed to by its <i>mutex</i> parameter if no thread has already locked the mutex. If <i>mutex</i> is locked, then <b>globus_mutex_trylock()</b> returns EBUSY and does not block the current thread or lock the mutex. Upon successful return, the thread calling <b>globus_mutex_trylock()</b> has an exclusive lock on the resources protected by <i>mutex</i>. Other threads calling <b>globus_mutex_lock()</b> will wait until that thread later calls <b>globus_mutex_unlock()</b> or <b>globus_cond_wait()</b> with that mutex.<div class="spacer">
</div>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>mutex</i> The mutex to lock.</div>
<div class="spacer">
</div>
<b>Returns:</b><div style="margin-left: 4.00ex;">
On success, <b>globus_mutex_trylock()</b> returns GLOBUS_SUCCESS and locks the mutex. If another thread holds the lock, <b>globus_mutex_trylock()</b> returns EBUSY. Otherwise, a non-zero implementation-specific error value is returned.</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int <b>globus_mutexattr_init</b> (<b>globus_mutexattr_t</b> *attr)</h2> Initialize a mutex attribute. The  <b>globus_mutexattr_init()</b> function initializes the mutex attribute structure pointed to by its <i>attr</i> parameter. Currently there are no attribute values that can be set via this API, so there's no real use to calling this function.<div class="spacer">
</div>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>attr</i> Attribute structure to initialize.</div>
<div class="spacer">
</div>
<b>Returns:</b><div style="margin-left: 4.00ex;">
Upon success, <b>globus_mutexattr_init()</b> returns GLOBUS_SUCCESS and modifies the attribute pointed to by <i>attr</i>. If an error occurs, <b>globus_mutexattr_init()</b> returns an implementation-specific non-zero error code.</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int <b>globus_mutexattr_destroy</b> (<b>globus_mutexattr_t</b> *attr)</h2> Destroy a mutex attribute. The  <b>globus_mutexattr_destroy()</b> function destroys the mutex attribute structure pointed to by its <i>attr</i> parameter.<div class="spacer">
</div>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>attr</i> Attribute structure to destroy.</div>
<div class="spacer">
</div>
<b>Returns:</b><div style="margin-left: 4.00ex;">
Upon success, <b>globus_mutexattr_destroy()</b> returns GLOBUS_SUCCESS and modifies the attribute pointed to by <i>attr</i>. If an error occurs, <b>globus_mutexattr_destroy()</b> returns an implementation-specific non-zero error code.</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int <b>globus_rmutex_init</b> (<b>globus_rmutex_t</b> *rmutex, <b>globus_rmutexattr_t</b> *rattr)</h2> Initialize a recursive mutex. The  <b>globus_rmutex_init()</b> function initializes a recursive mutex, that is, one which may be locked multiple times by a single thread without causing deadlock.<div class="spacer">
</div>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>rmutex</i> A pointer to the mutex to initialize<div style="height: 0.00em;">
&#160;</div>
<i>rattr</i> IGNORED</div>
<div class="spacer">
</div>
<b>Returns:</b><div style="margin-left: 4.00ex;">
On success, <b>globus_rmutex_init()</b> initializes the mutex and returns GLOBUS_SUCCESS; otherwise, it returns a non-zero error code.</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int <b>globus_rmutex_lock</b> (<b>globus_rmutex_t</b> *rmutex)</h2> Lock a recursive mutex. The  <b>globus_rmutex_lock()</b> function acquires the lock controlled by <i>rmutex</i>. This may be called multiple times in a single thread without causing deadlock, provided that a call to <b>globus_rmutex_unlock()</b> is called the same number of times as <b>globus_rmutex_lock()</b>. Once acquired, all other threads calling this function will be blocked until the mutex is completely unlocked.<div class="spacer">
</div>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>rmutex</i> A pointer to the mutex to lock</div>
<div class="spacer">
</div>
<b>Returns:</b><div style="margin-left: 4.00ex;">
On success, <b>globus_rmutex_init()</b> increases the lock level for the mutex, blocks other threads trying to acquire the same mutex, and returns GLOBUS_SUCCESS; otherwise, it returns a non-zero error code.</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int <b>globus_rmutex_unlock</b> (<b>globus_rmutex_t</b> *rmutex)</h2> Unlock a recursive mutex. The  <b>globus_rmutex_unlock()</b> function decrements the lock count for the lock pointed to by <i>rmutex</i>. If the lock count is reduced to zero, it also unblocks a thread which is trying to acquire the lock if there is one.<div class="spacer">
</div>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>rmutex</i> Mutex to unlock</div>
<div class="spacer">
</div>
<b>Returns:</b><div style="margin-left: 4.00ex;">
GLOBUS_SUCCESS</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int <b>globus_rmutex_destroy</b> (<b>globus_rmutex_t</b> *rmutex)</h2> Destroy a recursive mutex. The  <b>globus_rmutex_destroy()</b> function destroys a recursive mutex If the mutex is currently locked, behavior is undefined.<div class="spacer">
</div>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>rmutex</i> Mutex to unlock</div>
<div class="spacer">
</div>
<b>Returns:</b><div style="margin-left: 4.00ex;">
GLOBUS_SUCCESS</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
</div>
<div class="section">
<h1>Author</h1> Generated automatically by Doxygen for globus common from the source code.</div>
<table class="foot">
<tr>
<td class="foot-date">
Tue Jan 24 2012</td>
<td class="foot-os">
Version 14.5</td>
</tr>
</table>
</div>
</body>
</html>

