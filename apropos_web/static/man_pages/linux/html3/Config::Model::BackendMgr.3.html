<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Config::Model::BackendMgr(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Config::Model::BackendMgr(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
Config::Model::BackendMgr(3pm)</td>
</tr>
</tbody>
</table>
<div class="subsection">
<h2>write_back ( ... )</h2> Try to run all subroutines registered by auto_write_init write the configuration information until one succeeds (returns true).<div class="spacer">
</div>
You can specify here a pseudo root directory or another config directory to write configuration data back with &quot;root&quot; and &quot;config_dir&quot; parameters. This will override the model specifications.<div class="spacer">
</div>
You can force to use a backend by specifying &quot;backend =&gt; xxx&quot;. For instance, &quot;backend =&gt; 'augeas'&quot; or &quot;backend =&gt; 'custom'&quot;.<div class="spacer">
</div>
You can force to use all backend to write the files by specifying &quot;backend =&gt; 'all'&quot;.<div class="spacer">
</div>
You can force a specific config file to write with &quot;&lt;config_file =&quot; 'foo/bar.conf' &gt;&gt;<div class="spacer">
</div>
&quot;write_back&quot; will croak if no write call-back are known for this node.</div>
<div class="section">
<h1>NAME</h1> Config::Model::BackendMgr - Load configuration node on demand</div>
<div class="section">
<h1>VERSION</h1> version 2.005</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
 # Use BackendMgr to write data in perl data file<br/>
 use Config::Model;<br/>
 use Log::Log4perl qw(:easy);<br/>
 Log::Log4perl-&gt;easy_init($WARN);<br/>
<br/>
 # define configuration tree object<br/>
 my $model = Config::Model-&gt;new;<br/>
 $model-&gt;create_config_class(<br/>
    name    =&gt; &quot;Foo&quot;,<br/>
    element =&gt; [<br/>
        [qw/foo bar/] =&gt; {<br/>
            type       =&gt; 'leaf',<br/>
            value_type =&gt; 'string'<br/>
        },<br/>
    ]<br/>
 ); <br/>
<br/>
 $model-&gt;create_config_class(<br/>
    name =&gt; &quot;MyClass&quot;,<br/>
<br/>
    # read_config spec is used by Config::Model::BackendMgr<br/>
    read_config =&gt; [<br/>
        {<br/>
            backend     =&gt; 'perl_file',<br/>
            config_dir  =&gt; '/tmp/',<br/>
            file        =&gt; 'my_class.pl',<br/>
            auto_create =&gt; 1,<br/>
        },<br/>
    ],<br/>
    <br/>
    element =&gt; [<br/>
        [qw/foo bar/] =&gt; {<br/>
            type       =&gt; 'leaf',<br/>
            value_type =&gt; 'string'<br/>
        },<br/>
        hash_of_nodes =&gt; {<br/>
            type       =&gt; 'hash',     # hash id<br/>
            index_type =&gt; 'string',<br/>
            cargo      =&gt; {<br/>
                type              =&gt; 'node',<br/>
                config_class_name =&gt; 'Foo'<br/>
            },<br/>
        },<br/>
    ],<br/>
 );<br/>
<br/>
 my $inst = $model-&gt;node-&gt;instance( root_class_name =&gt; 'MyClass' );<br/>
<br/>
 my $root = $inst-&gt;config_root;<br/>
<br/>
 # put data<br/>
 my $step = 'foo=FOO hash_of_nodes:fr foo=bonjour -<br/>
   hash_of_nodes:en foo=hello ';<br/>
 $root-&gt;load( step =&gt; $step );<br/>
<br/>
 $inst-&gt;write_back;<br/>
<br/>
 # now look at file /tmp/my_class.pl<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> This class provides a way to specify how to load or store configuration data within the model (instead of writing dedicated perl code).<div class="spacer">
</div>
With these specifications, all the configuration information is read during creation of a node.<div class="spacer">
</div>
This load/store can be done with different &quot;backend&quot;:<dl>
<dt>
cds_file</dt>
<dd>
Config dump string (cds) in a file. I.e. a string that describes the content of a configuration tree is loaded from or saved in a text file. See Config::Model::Dumper.</dd>
</dl>
<dl>
<dt>
ini_file</dt>
<dd>
INI files (written with Config::Model::Backend::IniFile. See limitations in &quot;Limitations depending on storage&quot;.</dd>
</dl>
<dl>
<dt>
perl_file</dt>
<dd>
Perl data structure (perl) in a file. See Config::Model::DumpAsData for details on the data structure.</dd>
</dl>
<dl>
<dt>
custom</dt>
<dd>
Any format when the user provides a dedicated class and function to read and load the configuration tree.</dd>
</dl>
<dl>
<dt>
augeas</dt>
<dd>
Data can be loaded or stored using RedHat's Augeas library. See Config::Model::Backend::Augeas for details.</dd>
</dl>
<div class="spacer">
</div>
After loading the data, the object registers itself to the instance. Then the user can call the &quot;write_back&quot; method on the instance (See Config::Model::Instance) to store all configuration information back.<div class="subsection">
<h2>Built-in backend</h2> &quot;cds_file&quot;, &quot;ini_file&quot; and &quot;perl_file&quot; backend must be specified with mandatory &quot;config_dir&quot; parameter. For instance:<div class="spacer">
</div>
<br/>
   read_config  =&gt; { backend    =&gt; 'cds_file' , <br/>
                     config_dir =&gt; '/etc/cfg_dir',<br/>
                     file       =&gt; 'cfg_file.cds', #optional<br/>
                   },<br/>
<div class="spacer">
</div>
If &quot;file&quot; is not specified, a file name will be constructed with &quot;&lt;config_class_name&gt;.&lt;suffix&gt;&quot; where suffix is &quot;pl&quot; or &quot;ini&quot; or &quot;cds&quot;.</div>
<div class="subsection">
<h2>Plugin backend classes</h2> A plugin backend class can also be specified with:<div class="spacer">
</div>
<br/>
  read_config  =&gt; [ { backend    =&gt; 'foo' , <br/>
                      config_dir =&gt; '/etc/cfg_dir'<br/>
                      file       =&gt; 'foo.conf', # optional<br/>
                    }<br/>
                  ]<br/>
<div class="spacer">
</div>
In this case, this class will try to load &quot;Config::Model::Backend::Foo&quot;. (The class name is constructed with &quot;ucfirst($backend_name)&quot;)<div class="spacer">
</div>
&quot;read_config&quot; can also have custom parameters that will passed verbatim to &quot;Config::Model::Backend::Foo&quot; methods:<div class="spacer">
</div>
<br/>
  read_config  =&gt; [ { backend    =&gt; 'foo' , <br/>
                      config_dir =&gt; '/etc/cfg_dir',<br/>
                      my_param   =&gt; 'my_value',<br/>
                    } <br/>
                  ]<br/>
<div class="spacer">
</div>
This &quot;Config::Model::Backend::Foo&quot; class is expected to provide the following methods:<dl>
<dt>
new</dt>
<dd>
with parameters:<div style="height: 1.00em;">
&#160;</div>
<br/>
 node =&gt; ref_to_config_model_node<br/>
<div style="height: 1.00em;">
&#160;</div>
&quot;new()&quot; must return the newly created object</dd>
</dl>
<dl>
<dt>
read</dt>
<dd>
with parameters:<div style="height: 1.00em;">
&#160;</div>
<br/>
 %custom_parameters,      # model data<br/>
 root =&gt; $root_dir,       # mostly used for tests<br/>
 config_dir =&gt; $read_dir, # path below root<br/>
 file_path =&gt; $full_name, # full file name (root+path+file)<br/>
 io_handle =&gt; $io_file    # IO::File object<br/>
 check     =&gt; [ yes|no|skip]<br/>
<div style="height: 1.00em;">
&#160;</div>
Must return 1 if the read was successful, 0 otherwise.<div style="height: 1.00em;">
&#160;</div>
Following the &quot;my_param&quot; example above, %custom_parameters will contain &quot; ( 'my_param' , 'my_value' ) &quot;, so &quot;read()&quot; will also be called with &quot;root&quot;, &quot;config_dir&quot;, &quot;file_path&quot;, &quot;io_handle&quot;  <b>and</b> &quot;my_param   =&gt; 'my_value'&quot;.</dd>
</dl>
<dl>
<dt>
write</dt>
<dd>
with parameters:<div style="height: 1.00em;">
&#160;</div>
<br/>
 %$write,                     # model data<br/>
 auto_create =&gt; $auto_create, # from model<br/>
 backend     =&gt; $backend,     # backend name<br/>
 config_dir  =&gt; $write_dir,   # override from instance<br/>
 io_handle   =&gt; $fh,          # IO::File object<br/>
 write       =&gt; 1,            # always<br/>
 check       =&gt; [ yes|no|skip] ,<br/>
 root        =&gt; $root_dir,<br/>
<div style="height: 1.00em;">
&#160;</div>
Must return 1 if the write was successful, 0 otherwise</dd>
</dl>
</div>
<div class="subsection">
<h2>Custom backend</h2> Custom backend must be specified with a class name that will features the methods used to write and read the configuration files:<div class="spacer">
</div>
<br/>
  read_config  =&gt; [ { backend =&gt; 'custom' , <br/>
                      class =&gt; 'MyRead',<br/>
                      config_dir =&gt; '/etc/foo', # optional<br/>
                      file =&gt; 'foo.conf',       # optional<br/>
                    } ]<br/>
<div class="spacer">
</div>
&quot;custom&quot; backend parameters are:<dl>
<dt>
class</dt>
<dd>
Specify the class that contain the read method</dd>
</dl>
<dl>
<dt>
config_dir</dt>
<dd>
Specify configuration directory. This parameter is optional as the directory can be hardcoded in the custom class. &quot;config_dir&quot; beginning with '&quot;~&quot;' will be munged so &quot;~&quot; is replaced by &quot;File::HomeDir-&gt;my_data&quot;. See File::HomeDir for details.</dd>
</dl>
<dl>
<dt>
file</dt>
<dd>
optional. This parameter may not apply if the configuration is stored in several files. By default, the instance name is used as configuration file name.</dd>
</dl>
<dl>
<dt>
function</dt>
<dd>
Function name that will be called back to read the file. See &quot;read callback&quot; for details. (default is &quot;read&quot;)</dd>
</dl>
<dl>
<dt>
auto_create</dt>
<dd>
By default, an exception is thrown if no read was successful. This behavior can be overridden by specifying &quot;auto_create =&gt; 1&quot; in one of the backend specification. For instance:<div style="height: 1.00em;">
&#160;</div>
<br/>
    read_config  =&gt; [ { backend =&gt; 'cds_file', config_dir =&gt; '/etc/my_cfg/' } , <br/>
                      { backend =&gt; 'custom', class =&gt; 'Bar' ,<br/>
                        auto_create =&gt; 1<br/>
                      },<br/>
                    ],<br/>
<div style="height: 1.00em;">
&#160;</div>
This feature is necessary to create a configuration from scratch<div style="height: 1.00em;">
&#160;</div>
When set in write backend, missing directory and files will be created with current umask. Default is false.</dd>
</dl>
<div class="spacer">
</div>
Write specification is similar to read_specification. Except that the default value for &quot;function&quot; is &quot;write&quot;. Here's an example:<div class="spacer">
</div>
<br/>
   write_config  =&gt; [ { backend =&gt; 'cds_file', config_dir =&gt; '/etc/my_cfg/' } , <br/>
                      { backend =&gt; 'custom', class =&gt; 'Bar' ,<br/>
                        function =&gt; 'my_write',<br/>
                      },<br/>
                    ],<br/>
</div>
</div>
<div class="section">
<h1>Limitations depending on storage</h1> Some storage system will limit the structure of the model you can map to the file.<div class="subsection">
<h2>Ini files limitation</h2> Structure of the Config::Model must be very simple. Either:<dl>
<dt>
&#8226;</dt>
<dd>
A single class with hash of leaves elements.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
2 levels of classes. The top level has nodes elements. All other classes have only leaf elements.</dd>
</dl>
</div>
</div>
<div class="section">
<h1>Configuration class with auto read or auto write</h1><div class="subsection">
<h2>read specification</h2> A configuration class will be declared with optional &quot;read_config&quot; parameter:<div class="spacer">
</div>
<br/>
  read_config  =&gt; [ { backend =&gt; 'cds_file', config_dir =&gt; '/etc/my_cfg/' } , <br/>
                    { backend =&gt; 'custom', class =&gt; 'Bar' },<br/>
                  ],<br/>
<div class="spacer">
</div>
The read backends will be tried in the specified order:<dl>
<dt>
&#8226;</dt>
<dd>
First the &quot;cds&quot; file whose name depend on the parameters used in model creation and instance creation: &quot;&lt;model_config_dir&gt;/&lt;instance_name&gt;.cds&quot; The syntax of the &quot;cds&quot; file is described in  Config::Model::Dumper.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
A callback to &quot;Bar::read&quot;. See &quot;&quot;read callback&quot; for details.</dd>
</dl>
<div class="spacer">
</div>
When a read operation is successful, the remaining read methods will be skipped.</div>
<div class="subsection">
<h2>write specification</h2> A configuration class will be declared with optional &quot;write_config&quot; parameters (along with &quot;read_config&quot; parameter):<div class="spacer">
</div>
<br/>
  write_config =&gt; [ { backend =&gt; 'cds_file', config_dir =&gt; '/etc/my_cfg/',<br/>
                      auto_create =&gt; 1, },<br/>
                    { backend =&gt; 'custom', class =&gt; 'NewFormat' } ],<br/>
<div class="spacer">
</div>
By default, the specifications are tried in order, until the first succeeds.<div class="spacer">
</div>
When required by the user, all configuration information is written back using  <b>all</b> the write specifications. See &quot;write_back ( ... )&quot; in Config::Model::Instance for details.<div class="spacer">
</div>
The write class declared with &quot;custom&quot; backend must provide a call-back. See &quot;write callback&quot; for details.</div>
<div class="subsection">
<h2>read write directory</h2> By default, configurations files are read from the directory specified by &quot;config_dir&quot; parameter specified in the model. You may override the &quot;root&quot; directory for test.</div>
<div class="subsection">
<h2>read callback</h2> Read callback function will be called with these parameters:<div class="spacer">
</div>
<br/>
  object     =&gt; $obj,         # Config::Model::Node object <br/>
  root       =&gt; './my_test',  # fake root directory, userd for tests<br/>
  config_dir =&gt; /etc/foo',    # absolute path <br/>
  file       =&gt; 'foo.conf',   # file name<br/>
  file_path  =&gt; './my_test/etc/foo/foo.conf' <br/>
  io_handle  =&gt; $io           # IO::File object with binmode :utf8<br/>
  check      =&gt; [yes|no|skip]<br/>
<div class="spacer">
</div>
The IO::File object is undef if the file cannot be read.<div class="spacer">
</div>
The callback must return 0 on failure and 1 on successful read.</div>
<div class="subsection">
<h2>write callback</h2> Write callback function will be called with these parameters:<div class="spacer">
</div>
<br/>
  object      =&gt; $obj,         # Config::Model::Node object <br/>
  root        =&gt; './my_test',  # fake root directory, userd for tests<br/>
  config_dir  =&gt; /etc/foo',    # absolute path <br/>
  file        =&gt; 'foo.conf',   # file name<br/>
  file_path  =&gt; './my_test/etc/foo/foo.conf' <br/>
  io_handle   =&gt; $io           # IO::File object opened in write mode <br/>
                               # with binmode :utf8<br/>
  auto_create =&gt; 1             # create dir as needed<br/>
  check      =&gt; [yes|no|skip]<br/>
<div class="spacer">
</div>
The IO::File object is undef if the file cannot be written to.<div class="spacer">
</div>
The callback must return 0 on failure and 1 on successful write.</div>
</div>
<div class="section">
<h1>CAVEATS</h1> When both &quot;config_dir&quot; and &quot;file&quot; are specified, this class will write-open the configuration file (and thus clobber it) before calling the &quot;write&quot; call-back and pass the file handle with &quot;io_handle&quot; parameter. &quot;write&quot; should use this handle to write data in the target configuration file.<div class="spacer">
</div>
If this behavior causes problem (e.g. with augeas backend), the solution is either to:<dl>
<dt>
&#8226;</dt>
<dd>
Set &quot;file&quot; to undef or an empty string in the &quot;write_config&quot; specification.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Create a &quot;skip_open&quot; function in your backend class that returns 1</dd>
</dl>
</div>
<div class="section">
<h1>EXAMPLES</h1> In the example below, only a &quot;cds&quot; file is written. But, both custom format and &quot;cds&quot; file are tried for read. This is also an example of a graceful migration from a customized format to a &quot;cds&quot; format.<div class="spacer">
</div>
<br/>
  read_config  =&gt; [ { backend =&gt; 'cds_file', config_dir =&gt; '/etc/my_cfg/' } , <br/>
                    { backend =&gt; 'custom', class =&gt; 'Bar' },<br/>
                  ],<br/>
  write_config =&gt; [{ backend =&gt; 'cds_file', config_dir =&gt; '/etc/my_cfg/' }],<br/>
<div class="spacer">
</div>
You can choose also to read and write only customized files:<div class="spacer">
</div>
<br/>
  read_config  =&gt; [{ backend =&gt; 'custom', class =&gt; 'Bar'}],<br/>
<div class="spacer">
</div>
Or to read and write only &quot;cds&quot; files :<div class="spacer">
</div>
<br/>
  read_config  =&gt; [{ backend =&gt; 'cds_file'}] ,<br/>
<div class="spacer">
</div>
You can also specify more parameters that must be passed to your custom class:<div class="spacer">
</div>
<br/>
  read_config  =&gt; [{ backend =&gt; 'custom', class =&gt; 'Bar', <br/>
                    config_dir =&gt; '/etc/foo'}],<br/>
<div class="spacer">
</div>
To migrate from an old format to a new format:<div class="spacer">
</div>
<br/>
  read_config  =&gt; [ { backend =&gt; 'custom',<br/>
                      class =&gt; 'OldFormat',<br/>
                      function =&gt; 'old_read'<br/>
                    } ,<br/>
                    { backend =&gt; 'custom',<br/>
                      class =&gt; 'NewFormat',<br/>
                      function =&gt; 'new_read'<br/>
                    }<br/>
                  ],<br/>
  write_config =&gt; [ { backend =&gt; 'custom',<br/>
                      class =&gt; 'NewFormat'<br/>
                    }<br/>
                  ],<br/>
<div class="spacer">
</div>
If &quot;write_config&quot; is missing, the data provided by &quot;read_config&quot; will be used. For instance:<div class="spacer">
</div>
<br/>
  read_config  =&gt; [ { backend =&gt; 'custom',<br/>
                      class =&gt; 'Bar',<br/>
                      config_dir =&gt; '/etc/foo'<br/>
                  } ],<br/>
<div class="spacer">
</div>
In this case, configuration data will be read by &quot;Bar::read&quot; in directory &quot;/etc/foo&quot; and will be written back there by &quot;Bar::write&quot;.</div>
<div class="section">
<h1>AUTHOR</h1> Dominique Dumont, (ddumont at cpan dot org)</div>
<div class="section">
<h1>SEE ALSO</h1> Config::Model, Config::Model::Instance, Config::Model::Node, Config::Model::Dumper, Config::Augeas</div>
<table class="foot">
<tr>
<td class="foot-date">
2012-02-24</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

