<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
libcurl-share(3)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
libcurl-share(3)</td>
<td class="head-vol">
libcurl share interface</td>
<td class="head-rtitle">
libcurl-share(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> libcurl-share - how to use the share interface</div>
<div class="section">
<h1>DESCRIPTION</h1> This is an overview on how to use the libcurl share interface in your C programs. There are specific man pages for each function mentioned in here.<div style="height: 1.00em;">
&#160;</div>
All functions in the share interface are prefixed with curl_share.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>OBJECTIVES</h1> The share interface was added to enable sharing of data between curl &quot;handles&quot;.</div>
<div class="section">
<h1>ONE SET OF DATA - MANY TRANSFERS</h1> You can have multiple easy handles share data between them. Have them update and use the  <b>same</b> cookie database or DNS cache! This way, each single transfer will take advantage from data updates made by the other transfer(s).</div>
<div class="section">
<h1>SHARE OBJECT</h1> You create a shared object with  <i>curl_share_init(3)</i>. It returns a handle for a newly created one.<div style="height: 1.00em;">
&#160;</div>
You tell the shared object what data you want it to share by using  <i>curl_share_setopt(3)</i>. Currently you can only share DNS and/or COOKIE data.<div style="height: 1.00em;">
&#160;</div>
Since you can use this share from multiple threads, and libcurl has no internal thread synchronization, you must provide mutex callbacks if you're using this multi-threaded. You set lock and unlock functions with  <i>curl_share_setopt(3)</i> too.<div style="height: 1.00em;">
&#160;</div>
Then, you make an easy handle to use this share, you set the  <i>CURLOPT_SHARE</i> option with <i>curl_easy_setopt(3)</i>, and pass in share handle. You can make any number of easy handles share the same share handle.<div style="height: 1.00em;">
&#160;</div>
To make an easy handle stop using that particular share, you set  <i>CURLOPT_SHARE</i> to NULL for that easy handle. To make a handle stop sharing a particular data, you can  <i>CURLSHOPT_UNSHARE</i> it.<div style="height: 1.00em;">
&#160;</div>
When you're done using the share, make sure that no easy handle is still using it, and call  <i>curl_share_cleanup(3)</i> on the handle.</div>
<div class="section">
<h1>SEE ALSO</h1> <b>curl_share_init</b>(3), <b>curl_share_setopt</b>(3), <b>curl_share_cleanup</b>(3)</div>
<table class="foot">
<tr>
<td class="foot-date">
8 Aug 2003</td>
<td class="foot-os">
libcurl 7.10.7</td>
</tr>
</table>
</div>
</body>
</html>

