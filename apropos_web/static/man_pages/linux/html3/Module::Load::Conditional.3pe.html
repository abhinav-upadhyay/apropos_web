<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Module::Load::Conditional(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Module::Load::Conditional(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
Module::Load::Conditional(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Module::Load::Conditional - Looking up module information / loading at runtime</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
    use Module::Load::Conditional qw[can_load check_install requires];<br/>
<br/>
<br/>
    my $use_list = {<br/>
            CPANPLUS        =&gt; 0.05,<br/>
            LWP             =&gt; 5.60,<br/>
            'Test::More'    =&gt; undef,<br/>
    };<br/>
<br/>
    print can_load( modules =&gt; $use_list )<br/>
            ? 'all modules loaded successfully'<br/>
            : 'failed to load required modules';<br/>
<br/>
<br/>
    my $rv = check_install( module =&gt; 'LWP', version =&gt; 5.60 )<br/>
                or print 'LWP is not installed!';<br/>
<br/>
    print 'LWP up to date' if $rv-&gt;{uptodate};<br/>
    print &quot;LWP version is $rv-&gt;{version}\n&quot;;<br/>
    print &quot;LWP is installed as file $rv-&gt;{file}\n&quot;;<br/>
<br/>
<br/>
    print &quot;LWP requires the following modules to be installed:\n&quot;;<br/>
    print join &quot;\n&quot;, requires('LWP');<br/>
<br/>
    ### allow M::L::C to peek in your %INC rather than just<br/>
    ### scanning @INC<br/>
    $Module::Load::Conditional::CHECK_INC_HASH = 1;<br/>
<br/>
    ### reset the 'can_load' cache<br/>
    undef $Module::Load::Conditional::CACHE;<br/>
<br/>
    ### don't have Module::Load::Conditional issue warnings --<br/>
    ### default is '1'<br/>
    $Module::Load::Conditional::VERBOSE = 0;<br/>
<br/>
    ### The last error that happened during a call to 'can_load'<br/>
    my $err = $Module::Load::Conditional::ERROR;<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> Module::Load::Conditional provides simple ways to query and possibly load any of the modules you have installed on your system during runtime.<div class="spacer">
</div>
It is able to load multiple modules at once or none at all if one of them was not able to load. It also takes care of any error checking and so forth.</div>
<div class="section">
<h1>Methods</h1><div class="subsection">
<h2>$href = check_install( module =&gt; NAME [, version =&gt; VERSION, verbose =&gt; BOOL ] );</h2> &quot;check_install&quot; allows you to verify if a certain module is installed or not. You may call it with the following arguments:<dl>
<dt>
module</dt>
<dd>
The name of the module you wish to verify -- this is a required key</dd>
</dl>
<dl>
<dt>
version</dt>
<dd>
The version this module needs to be -- this is optional</dd>
</dl>
<dl>
<dt>
verbose</dt>
<dd>
Whether or not to be verbose about what it is doing -- it will default to $Module::Load::Conditional::VERBOSE</dd>
</dl>
<div class="spacer">
</div>
It will return undef if it was not able to find where the module was installed, or a hash reference with the following keys if it was able to find the file:<dl>
<dt>
file</dt>
<dd>
Full path to the file that contains the module</dd>
</dl>
<dl>
<dt>
dir</dt>
<dd>
Directory, or more exact the @INC entry, where the module was loaded from.</dd>
</dl>
<dl>
<dt>
version</dt>
<dd>
The version number of the installed module - this will be &quot;undef&quot; if the module had no (or unparsable) version number, or if the variable $Module::Load::Conditional::FIND_VERSION was set to true. (See the &quot;GLOBAL VARIABLES&quot; section below for details)</dd>
</dl>
<dl>
<dt>
uptodate</dt>
<dd>
A boolean value indicating whether or not the module was found to be at least the version you specified. If you did not specify a version, uptodate will always be true if the module was found. If no parsable version was found in the module, uptodate will also be true, since &quot;check_install&quot; had no way to verify clearly.<div style="height: 1.00em;">
&#160;</div>
See also $Module::Load::Conditional::DEPRECATED, which affects the outcome of this value.</dd>
</dl>
</div>
<div class="subsection">
<h2>$bool = can_load( modules =&gt; { NAME =&gt; VERSION [,NAME =&gt; VERSION] }, [verbose =&gt; BOOL, nocache =&gt; BOOL] )</h2> &quot;can_load&quot; will take a list of modules, optionally with version numbers and determine if it is able to load them. If it can load *ALL* of them, it will. If one or more are unloadable, none will be loaded.<div class="spacer">
</div>
This is particularly useful if you have More Than One Way (tm) to solve a problem in a program, and only wish to continue down a path if all modules could be loaded, and not load them if they couldn't.<div class="spacer">
</div>
This function uses the &quot;load&quot; function from Module::Load under the hood.<div class="spacer">
</div>
&quot;can_load&quot; takes the following arguments:<dl>
<dt>
modules</dt>
<dd>
This is a hashref of module/version pairs. The version indicates the minimum version to load. If no version is provided, any version is assumed to be good enough.</dd>
</dl>
<dl>
<dt>
verbose</dt>
<dd>
This controls whether warnings should be printed if a module failed to load. The default is to use the value of $Module::Load::Conditional::VERBOSE.</dd>
</dl>
<dl>
<dt>
nocache</dt>
<dd>
&quot;can_load&quot; keeps its results in a cache, so it will not load the same module twice, nor will it attempt to load a module that has already failed to load before. By default, &quot;can_load&quot; will check its cache, but you can override that by setting &quot;nocache&quot; to true.</dd>
</dl>
</div>
<div class="subsection">
<h2>@list = requires( MODULE );</h2> &quot;requires&quot; can tell you what other modules a particular module requires. This is particularly useful when you're intending to write a module for public release and are listing its prerequisites.<div class="spacer">
</div>
&quot;requires&quot; takes but one argument: the name of a module. It will then first check if it can actually load this module, and return undef if it can't. Otherwise, it will return a list of modules and pragmas that would have been loaded on the module's behalf.<div class="spacer">
</div>
Note: The list &quot;require&quot; returns has originated from your current perl and your current install.</div>
</div>
<div class="section">
<h1>Global Variables</h1> The behaviour of Module::Load::Conditional can be altered by changing the following global variables:<div class="subsection">
<h2>$Module::Load::Conditional::VERBOSE</h2> This controls whether Module::Load::Conditional will issue warnings and explanations as to why certain things may have failed. If you set it to 0, Module::Load::Conditional will not output any warnings. The default is 0;</div>
<div class="subsection">
<h2>$Module::Load::Conditional::FIND_VERSION</h2> This controls whether Module::Load::Conditional will try to parse (and eval) the version from the module you're trying to load.<div class="spacer">
</div>
If you don't wish to do this, set this variable to &quot;false&quot;. Understand then that version comparisons are not possible, and Module::Load::Conditional can not tell you what module version you have installed. This may be desirable from a security or performance point of view. Note that $FIND_VERSION code runs safely under &quot;taint mode&quot;.<div class="spacer">
</div>
The default is 1;</div>
<div class="subsection">
<h2>$Module::Load::Conditional::CHECK_INC_HASH</h2> This controls whether &quot;Module::Load::Conditional&quot; checks your %INC hash to see if a module is available. By default, only @INC is scanned to see if a module is physically on your filesystem, or available via an &quot;@INC-hook&quot;. Setting this variable to &quot;true&quot; will trust any entries in %INC and return them for you.<div class="spacer">
</div>
The default is 0;</div>
<div class="subsection">
<h2>$Module::Load::Conditional::CACHE</h2> This holds the cache of the &quot;can_load&quot; function. If you explicitly want to remove the current cache, you can set this variable to &quot;undef&quot;</div>
<div class="subsection">
<h2>$Module::Load::Conditional::ERROR</h2> This holds a string of the last error that happened during a call to &quot;can_load&quot;. It is useful to inspect this when &quot;can_load&quot; returns &quot;undef&quot;.</div>
<div class="subsection">
<h2>$Module::Load::Conditional::DEPRECATED</h2> This controls whether &quot;Module::Load::Conditional&quot; checks if a dual-life core module has been deprecated. If this is set to true &quot;check_install&quot; will return false to &quot;uptodate&quot;, if a dual-life module is found to be loaded from $Config{privlibexp}<div class="spacer">
</div>
The default is 0;</div>
</div>
<div class="section">
<h1>See Also</h1> &quot;Module::Load&quot;</div>
<div class="section">
<h1>BUG REPORTS</h1> Please report bugs or other issues to &lt;bug-module-load-conditional@rt.cpan.org&gt;.</div>
<div class="section">
<h1>AUTHOR</h1> This module by Jos Boumans &lt;kane@cpan.org&gt;.</div>
<div class="section">
<h1>COPYRIGHT</h1> This library is free software; you may redistribute and/or modify it under the same terms as Perl itself.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-09-26</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

