<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Term::UI(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Term::UI(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
Term::UI(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Term::UI - Term::ReadLine UI made easy</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
    use Term::UI;<br/>
    use Term::ReadLine;<br/>
<br/>
    my $term = Term::ReadLine-&gt;new('brand');<br/>
<br/>
    my $reply = $term-&gt;get_reply(<br/>
                    prompt =&gt; 'What is your favourite colour?',<br/>
                    choices =&gt; [qw|blue red green|],<br/>
                    default =&gt; blue,<br/>
    );<br/>
<br/>
    my $bool = $term-&gt;ask_yn(<br/>
                        prompt =&gt; 'Do you like cookies?',<br/>
                        default =&gt; 'y',<br/>
                );<br/>
<br/>
<br/>
    my $string = q[some_command -option --no-foo --quux='this thing'];<br/>
<br/>
    my ($options,$munged_input) = $term-&gt;parse_options($string);<br/>
<br/>
<br/>
    ### don't have Term::UI issue warnings -- default is '1'<br/>
    $Term::UI::VERBOSE = 0;<br/>
<br/>
    ### always pick the default (good for non-interactive terms)<br/>
    ### -- default is '0'<br/>
    $Term::UI::AUTOREPLY = 1;<br/>
    <br/>
    ### Retrieve the entire session as a printable string:<br/>
    $hist = Term::UI::History-&gt;history_as_string;<br/>
    $hist = $term-&gt;history_as_string;<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> &quot;Term::UI&quot; is a transparent way of eliminating the overhead of having to format a question and then validate the reply, informing the user if the answer was not proper and re-issuing the question.<div class="spacer">
</div>
Simply give it the question you want to ask, optionally with choices the user can pick from and a default and &quot;Term::UI&quot; will DWYM.<div class="spacer">
</div>
For asking a yes or no question, there's even a shortcut.</div>
<div class="section">
<h1>HOW IT WORKS</h1> &quot;Term::UI&quot; places itself at the back of the &quot;Term::ReadLine&quot; @ISA array, so you can call its functions through your term object.<div class="spacer">
</div>
&quot;Term::UI&quot; uses &quot;Term::UI::History&quot; to record all interactions with the commandline. You can retrieve this history, or alter the filehandle the interaction is printed to. See the &quot;Term::UI::History&quot; manpage or the &quot;SYNOPSIS&quot; for details.</div>
<div class="section">
<h1>METHODS</h1><div class="subsection">
<h2>$reply = $term-&gt;get_reply( prompt =&gt; 'question?', [choices =&gt; \@list, default =&gt; $list[0], multi =&gt; BOOL, print_me =&gt; &quot;extra text to print &amp; record&quot;, allow =&gt; $ref] );</h2> &quot;get_reply&quot; asks a user a question, and then returns the reply to the caller. If the answer is invalid (more on that below), the question will be reposed, until a satisfactory answer has been entered.<div class="spacer">
</div>
You have the option of providing a list of choices the user can pick from using the &quot;choices&quot; argument. If the answer is not in the list of choices presented, the question will be reposed.<div class="spacer">
</div>
If you provide a &quot;default&quot;  answer, this will be returned when either $AUTOREPLY is set to true, (see the &quot;GLOBAL VARIABLES&quot; section further below), or when the user just hits &quot;enter&quot;.<div class="spacer">
</div>
You can indicate that the user is allowed to enter multiple answers by toggling the &quot;multi&quot; flag. Note that a list of answers will then be returned to you, rather than a simple string.<div class="spacer">
</div>
By specifying an &quot;allow&quot; hander, you can yourself validate the answer a user gives. This can be any of the types that the Params::Check &quot;allow&quot; function allows, so please refer to that manpage for details.<div class="spacer">
</div>
Finally, you have the option of adding a &quot;print_me&quot; argument, which is simply printed before the prompt. It's printed to the same file handle as the rest of the questions, so you can use this to keep track of a full session of Q&amp;A with the user, and retrieve it later using the &quot;Term::UI-&gt;history_as_string&quot; function.<div class="spacer">
</div>
See the &quot;EXAMPLES&quot; section for samples of how to use this function.</div>
<div class="subsection">
<h2>$bool = $term-&gt;ask_yn( prompt =&gt; &quot;your question&quot;, [default =&gt; (y|1,n|0), print_me =&gt; &quot;extra text to print &amp; record&quot;] )</h2> Asks a simple &quot;yes&quot; or &quot;no&quot; question to the user, returning a boolean indicating &quot;true&quot; or &quot;false&quot; to the caller.<div class="spacer">
</div>
The &quot;default&quot; answer will automatically returned, if the user hits &quot;enter&quot; or if $AUTOREPLY is set to true. See the &quot;GLOBAL VARIABLES&quot; section further below.<div class="spacer">
</div>
Also, you have the option of adding a &quot;print_me&quot; argument, which is simply printed before the prompt. It's printed to the same file handle as the rest of the questions, so you can use this to keep track of a full session of Q&amp;A with the user, and retrieve it later using the &quot;Term::UI-&gt;history_as_string&quot; function.<div class="spacer">
</div>
See the &quot;EXAMPLES&quot; section for samples of how to use this function.</div>
<div class="subsection">
<h2>($opts, $munged) = $term-&gt;parse_options( STRING );</h2> &quot;parse_options&quot; will convert all options given from an input string to a hash reference. If called in list context it will also return the part of the input string that it found no options in.<div class="spacer">
</div>
Consider this example:<div class="spacer">
</div>
<br/>
    my $str =   q[command --no-foo --baz --bar=0 --quux=bleh ] .<br/>
                q[--option=&quot;some'thing&quot; -one-dash -single=blah' arg];<br/>
<br/>
    my ($options,$munged) =  $term-&gt;parse_options($str);<br/>
<br/>
    ### $options would contain: ###<br/>
    $options = {<br/>
                'foo'       =&gt; 0,<br/>
                'bar'       =&gt; 0,<br/>
                'one-dash'  =&gt; 1,<br/>
                'baz'       =&gt; 1,<br/>
                'quux'      =&gt; 'bleh',<br/>
                'single'    =&gt; 'blah\'',<br/>
                'option'    =&gt; 'some\'thing'<br/>
    };<br/>
<br/>
    ### and this is the munged version of the input string,<br/>
    ### ie what's left of the input minus the options<br/>
    $munged = 'command arg';<br/>
<div class="spacer">
</div>
As you can see, you can either use a single or a double &quot;-&quot; to indicate an option. If you prefix an option with &quot;no-&quot; and do not give it a value, it will be set to 0. If it has no prefix and no value, it will be set to 1. Otherwise, it will be set to its value. Note also that it can deal fine with single/double quoting issues.</div>
<div class="subsection">
<h2>$str = $term-&gt;history_as_string</h2> Convenience wrapper around &quot;Term::UI::History-&gt;history_as_string&quot;.<div class="spacer">
</div>
Consult the &quot;Term::UI::History&quot; man page for details.</div>
</div>
<div class="section">
<h1>GLOBAL VARIABLES</h1> The behaviour of Term::UI can be altered by changing the following global variables:<div class="subsection">
<h2>$Term::UI::VERBOSE</h2> This controls whether Term::UI will issue warnings and explanations as to why certain things may have failed. If you set it to 0, Term::UI will not output any warnings. The default is 1;</div>
<div class="subsection">
<h2>$Term::UI::AUTOREPLY</h2> This will make every question be answered by the default, and warn if there was no default provided. This is particularly useful if your program is run in non-interactive mode. The default is 0;</div>
<div class="subsection">
<h2>$Term::UI::INVALID</h2> This holds the string that will be printed when the user makes an invalid choice. You can override this string from your program if you, for example, wish to do localization. The default is &quot;Invalid selection, please try again: &quot;</div>
<div class="subsection">
<h2>$Term::UI::History::HISTORY_FH</h2> This is the filehandle all the print statements from this module are being sent to. Please consult the &quot;Term::UI::History&quot; manpage for details.<div class="spacer">
</div>
This defaults to *STDOUT.</div>
</div>
<div class="section">
<h1>EXAMPLES</h1><div class="subsection">
<h2>Basic get_reply sample</h2><br/>
    ### ask a user (with an open question) for their favourite colour<br/>
    $reply = $term-&gt;get_reply( prompt =&gt; 'Your favourite colour? );<br/>
<div class="spacer">
</div>
which would look like:<div class="spacer">
</div>
<br/>
    Your favourite colour?<br/>
<div class="spacer">
</div>
and $reply would hold the text the user typed.</div>
<div class="subsection">
<h2>get_reply with choices</h2><br/>
    ### now provide a list of choices, so the user has to pick one<br/>
    $reply = $term-&gt;get_reply(<br/>
                prompt  =&gt; 'Your favourite colour?',<br/>
                choices =&gt; [qw|red green blue|] );<br/>
<div class="spacer">
</div>
which would look like:<div class="spacer">
</div>
<br/>
      1&gt; red<br/>
      2&gt; green<br/>
      3&gt; blue<br/>
    <br/>
    Your favourite colour?<br/>
<div class="spacer">
</div>
$reply will hold one of the choices presented. &quot;Term::UI&quot; will repose the question if the user attempts to enter an answer that's not in the list of choices. The string presented is held in the $Term::UI::INVALID variable (see the &quot;GLOBAL VARIABLES&quot; section for details.</div>
<div class="subsection">
<h2>get_reply with choices and default</h2><br/>
    ### provide a sensible default option -- everyone loves blue!<br/>
    $reply = $term-&gt;get_reply(<br/>
                prompt  =&gt; 'Your favourite colour?',<br/>
                choices =&gt; [qw|red green blue|],<br/>
                default =&gt; 'blue' );<br/>
<div class="spacer">
</div>
which would look like:<div class="spacer">
</div>
<br/>
      1&gt; red<br/>
      2&gt; green<br/>
      3&gt; blue<br/>
    <br/>
    Your favourite colour? [3]:<br/>
<div class="spacer">
</div>
Note the default answer after the prompt. A user can now just hit &quot;enter&quot; (or set $Term::UI::AUTOREPLY -- see the &quot;GLOBAL VARIABLES&quot; section) and the sensible answer 'blue' will be returned.</div>
<div class="subsection">
<h2>get_reply using print_me &amp; multi</h2><br/>
    ### allow the user to pick more than one colour and add an <br/>
    ### introduction text<br/>
    @reply = $term-&gt;get_reply(<br/>
                print_me    =&gt; 'Tell us what colours you like', <br/>
                prompt      =&gt; 'Your favourite colours?',<br/>
                choices     =&gt; [qw|red green blue|],<br/>
                multi       =&gt; 1 );<br/>
<div class="spacer">
</div>
which would look like:<div class="spacer">
</div>
<br/>
    Tell us what colours you like<br/>
      1&gt; red<br/>
      2&gt; green<br/>
      3&gt; blue<br/>
    <br/>
    Your favourite colours?<br/>
<div class="spacer">
</div>
An answer of &quot;3 2 1&quot; would fill @reply with &quot;blue green red&quot;</div>
<div class="subsection">
<h2>get_reply &amp; allow</h2><br/>
    ### pose an open question, but do a custom verification on <br/>
    ### the answer, which will only exit the question loop, if <br/>
    ### the answer matches the allow handler.<br/>
    $reply = $term-&gt;get_reply(<br/>
                prompt  =&gt; &quot;What is the magic number?&quot;,<br/>
                allow   =&gt; 42 );<br/>
<div class="spacer">
</div>
Unless the user now enters 42, the question will be reposed over and over again. You can use more sophisticated &quot;allow&quot; handlers (even subroutines can be used). The &quot;allow&quot; handler is implemented using &quot;Params::Check&quot;'s &quot;allow&quot; function. Check its manpage for details.</div>
<div class="subsection">
<h2>an elaborate ask_yn sample</h2><br/>
    ### ask a user if he likes cookies. Default to a sensible 'yes'<br/>
    ### and inform him first what cookies are.<br/>
    $bool = $term-&gt;ask_yn( prompt   =&gt; 'Do you like cookies?',<br/>
                           default  =&gt; 'y',<br/>
                           print_me =&gt; 'Cookies are LOVELY!!!' );<br/>
<div class="spacer">
</div>
would print:<div class="spacer">
</div>
<br/>
    Cookies are LOVELY!!!<br/>
    Do you like cookies? [Y/n]:<br/>
<div class="spacer">
</div>
If a user then simply hits &quot;enter&quot;, agreeing with the default, $bool would be set to &quot;true&quot;. (Simply hitting 'y' would also return &quot;true&quot;. Hitting 'n' would return &quot;false&quot;)<div class="spacer">
</div>
We could later retrieve this interaction by printing out the Q&amp;A history as follows:<div class="spacer">
</div>
<br/>
    print $term-&gt;history_as_string;<br/>
<div class="spacer">
</div>
which would then print:<div class="spacer">
</div>
<br/>
    Cookies are LOVELY!!!<br/>
    Do you like cookies? [Y/n]:  y<br/>
<div class="spacer">
</div>
There's a chance we're doing this non-interactively, because a console is missing, the user indicated he just wanted the defaults, etc.<div class="spacer">
</div>
In this case, simply setting $Term::UI::AUTOREPLY to true, will return from every question with the default answer set for the question. Do note that if &quot;AUTOREPLY&quot; is true, and no default is set, &quot;Term::UI&quot; will warn about this and return &quot;undef&quot;.</div>
</div>
<div class="section">
<h1>See Also</h1> &quot;Params::Check&quot;, &quot;Term::ReadLine&quot;, &quot;Term::UI::History&quot;</div>
<div class="section">
<h1>BUG REPORTS</h1> Please report bugs or other issues to &lt;bug-term-ui@rt.cpan.org&lt;gt&gt;.</div>
<div class="section">
<h1>AUTHOR</h1> This module by Jos Boumans &lt;kane@cpan.org&gt;.</div>
<div class="section">
<h1>COPYRIGHT</h1> This library is free software; you may redistribute and/or modify it under the same terms as Perl itself.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-09-19</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

