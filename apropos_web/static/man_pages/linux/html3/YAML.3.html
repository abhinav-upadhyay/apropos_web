<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
YAML(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
YAML(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
YAML(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> YAML - YAML Ain't Markup Language (tm)</div>
<div class="section">
<h1>NOTE</h1> This module has been released to CPAN as YAML::Old, and soon YAML.pm will be changed to just be a frontend interface module for all the various Perl YAML implementation modules, including YAML::Old.<div class="spacer">
</div>
If you want robust and fast YAML processing using the normal Dump/Load API, please consider switching to YAML::XS. It is by far the best Perl module for YAML at this time. It requires that you have a C compiler, since it is written in C.<div class="spacer">
</div>
If you really need to use this version of YAML.pm it will always be available as YAML::Old.<div class="spacer">
</div>
If you don't care which YAML module use, as long as it's the best one installed on your system, use YAML::Any.<div class="spacer">
</div>
The rest of this documentation is left unchanged, until YAML.pm is switched over to the new UI-only version.</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
    use YAML;<br/>
    <br/>
    # Load a YAML stream of 3 YAML documents into Perl data structures.<br/>
    my ($hashref, $arrayref, $string) = Load(&lt;&lt;'...');<br/>
    ---<br/>
    name: ingy<br/>
    age: old<br/>
    weight: heavy<br/>
    # I should comment that I also like pink, but don't tell anybody.<br/>
    favorite colors:<br/>
        - red<br/>
        - green<br/>
        - blue<br/>
    ---<br/>
    - Clark Evans<br/>
    - Oren Ben-Kiki<br/>
    - Ingy doet Net<br/>
    --- &gt;<br/>
    You probably think YAML stands for &quot;Yet Another Markup Language&quot;. It<br/>
    ain't! YAML is really a data serialization language. But if you want<br/>
    to think of it as a markup, that's OK with me. A lot of people try<br/>
    to use XML as a serialization format.<br/>
    <br/>
    &quot;YAML&quot; is catchy and fun to say. Try it. &quot;YAML, YAML, YAML!!!&quot;<br/>
    ...<br/>
    <br/>
    # Dump the Perl data structures back into YAML.<br/>
    print Dump($string, $arrayref, $hashref);<br/>
    <br/>
    # YAML::Dump is used the same way you'd use Data::Dumper::Dumper<br/>
    use Data::Dumper;<br/>
    print Dumper($string, $arrayref, $hashref);<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> The YAML.pm module implements a YAML Loader and Dumper based on the YAML 1.0 specification. &lt;http://www.yaml.org/spec/&gt;<div class="spacer">
</div>
YAML is a generic data serialization language that is optimized for human readability. It can be used to express the data structures of most modern programming languages. (Including Perl!!!)<div class="spacer">
</div>
For information on the YAML syntax, please refer to the YAML specification.</div>
<div class="section">
<h1>WHY YAML IS COOL</h1><dl>
<dt>
YAML is readable for people.</dt>
<dd>
It makes clear sense out of complex data structures. You should find that YAML is an exceptional data dumping tool. Structure is shown through indentation, YAML supports recursive data, and hash keys are sorted by default. In addition, YAML supports several styles of scalar formatting for different types of data.</dd>
</dl>
<dl>
<dt>
YAML is editable.</dt>
<dd>
YAML was designed from the ground up to be an excellent syntax for configuration files. Almost all programs need configuration files, so why invent a new syntax for each one? And why subject users to the complexities of XML or native Perl code?</dd>
</dl>
<dl>
<dt>
YAML is multilingual.</dt>
<dd>
Yes, YAML supports Unicode. But I'm actually referring to programming languages. YAML was designed to meet the serialization needs of Perl, Python, Ruby, Tcl, PHP, Javascript and Java. It was also designed to be interoperable between those languages. That means YAML serializations produced by Perl can be processed by Python.</dd>
</dl>
<dl>
<dt>
YAML is taint safe.</dt>
<dd>
Using modules like Data::Dumper for serialization is fine as long as you can be sure that nobody can tamper with your data files or transmissions. That's because you need to use Perl's &quot;eval()&quot; built-in to deserialize the data. Somebody could add a snippet of Perl to erase your files.<div style="height: 1.00em;">
&#160;</div>
YAML's parser does not need to eval anything.</dd>
</dl>
<dl>
<dt>
YAML is full featured.</dt>
<dd>
YAML can accurately serialize all of the common Perl data structures and deserialize them again without losing data relationships. Although it is not 100% perfect (no serializer is or can be perfect), it fares as well as the popular current modules: Data::Dumper, Storable, XML::Dumper and Data::Denter.<div style="height: 1.00em;">
&#160;</div>
YAML.pm also has the ability to handle code (subroutine) references and typeglobs. (Still experimental) These features are not found in Perl's other serialization modules.</dd>
</dl>
<dl>
<dt>
YAML is extensible.</dt>
<dd>
The YAML language has been designed to be flexible enough to solve it's own problems. The markup itself has 3 basic construct which resemble Perl's hash, array and scalar. By default, these map to their Perl equivalents. But each YAML node also supports a tagging mechanism (type system) which can cause that node to be interpreted in a completely different manner. That's how YAML can support object serialization and oddball structures like Perl's typeglob.</dd>
</dl>
</div>
<div class="section">
<h1>YAML IMPLEMENTATIONS IN PERL</h1> This module, YAML.pm, is really just the interface module for YAML modules written in Perl. The basic interface for YAML consists of two functions: &quot;Dump&quot; and &quot;Load&quot;. The real work is done by the modules YAML::Dumper and YAML::Loader.<div class="spacer">
</div>
Different YAML module distributions can be created by subclassing YAML.pm and YAML::Loader and YAML::Dumper. For example, YAML-Simple consists of YAML::Simple YAML::Dumper::Simple and YAML::Loader::Simple.<div class="spacer">
</div>
Why would there be more than one implementation of YAML? Well, despite YAML's offering of being a simple data format, YAML is actually very deep and complex. Implementing the entirety of the YAML specification is a daunting task.<div class="spacer">
</div>
For this reason I am currently working on 3 different YAML implementations.<dl>
<dt>
YAML</dt>
<dd>
The main YAML distribution will keeping evolving to support the entire YAML specification in pure Perl. This may not be the fastest or most stable module though. Currently, YAML.pm has lots of known bugs. It is mostly a great tool for dumping Perl data structures to a readable form.</dd>
</dl>
<dl>
<dt>
YAML::Tiny</dt>
<dd>
The point of YAML::Tiny is to strip YAML down to the 90% that people use most and offer that in a small, fast, stable, pure Perl form. YAML::Tiny will simply die when it is asked to do something it can't.</dd>
</dl>
<dl>
<dt>
YAML::Syck</dt>
<dd>
&quot;libsyck&quot; is the C based YAML processing library used by the Ruby programming language (and also Python, PHP and Pugs). YAML::Syck is the Perl binding to &quot;libsyck&quot;. It should be very fast, but may have problems of its own. It will also require C compilation.<div style="height: 1.00em;">
&#160;</div>
NOTE: Audrey Tang has actually completed this module and it works great<br/>
      and is 10 times faster than YAML.pm.</dd>
</dl>
<div class="spacer">
</div>
In the future, there will likely be even more YAML modules. Remember, people other than Ingy are allowed to write YAML modules!</div>
<div class="section">
<h1>FUNCTIONAL USAGE</h1> YAML is completely OO under the hood. Still it exports a few useful top level functions so that it is dead simple to use. These functions just do the OO stuff for you. If you want direct access to the OO API see the documentation for YAML::Dumper and YAML::Loader.<div class="subsection">
<h2>Exported Functions</h2> The following functions are exported by YAML.pm by default. The reason they are exported is so that YAML works much like Data::Dumper. If you don't want functions to be imported, just use YAML with an empty import list:<div class="spacer">
</div>
<br/>
    use YAML ();<br/>
<dl>
<dt>
Dump(list-of-Perl-data-structures)</dt>
<dd>
Turn Perl data into YAML. This function works very much like  <i>Data::Dumper::Dumper()</i>. It takes a list of Perl data strucures and dumps them into a serialized form. It returns a string containing the YAML stream. The structures can be references or plain scalars.</dd>
</dl>
<dl>
<dt>
Load(string-containing-a-YAML-stream)</dt>
<dd>
Turn YAML into Perl data. This is the opposite of Dump. Just like Storable's  <i>thaw()</i> function or the <i>eval()</i> function in relation to Data::Dumper. It parses a string containing a valid YAML stream into a list of Perl data structures.</dd>
</dl>
</div>
<div class="subsection">
<h2>Exportable Functions</h2> These functions are not exported by default but you can request them in an import list like this:<div class="spacer">
</div>
<br/>
    use YAML qw'freeze thaw Bless';<br/>
<dl>
<dt>
<i>freeze()</i> and <i>thaw()</i></dt>
<dd>
Aliases to <i>Dump()</i> and <i>Load()</i> for Storable fans. This will also allow YAML.pm to be plugged directly into modules like POE.pm, that use the freeze/thaw API for internal serialization.</dd>
</dl>
<dl>
<dt>
DumpFile(filepath, list)</dt>
<dd>
Writes the YAML stream to a file instead of just returning a string.</dd>
</dl>
<dl>
<dt>
LoadFile(filepath)</dt>
<dd>
Reads the YAML stream from a file instead of a string.</dd>
</dl>
<dl>
<dt>
Bless(perl-node, [yaml-node | class-name])</dt>
<dd>
Associate a normal Perl node, with a yaml node. A yaml node is an object tied to the YAML::Node class. The second argument is either a yaml node that you've already created or a class (package) name that supports a  <i>yaml_dump()</i> function. A <i>yaml_dump()</i> function should take a perl node and return a yaml node. If no second argument is provided, Bless will create a yaml node. This node is not returned, but can be retrieved with the  <i>Blessed()</i> function.<div style="height: 1.00em;">
&#160;</div>
Here's an example of how to use Bless. Say you have a hash containing three keys, but you only want to dump two of them. Furthermore the keys must be dumped in a certain order. Here's how you do that:<div style="height: 1.00em;">
&#160;</div>
<br/>
    use YAML qw(Dump Bless);<br/>
    $hash = {apple =&gt; 'good', banana =&gt; 'bad', cauliflower =&gt; 'ugly'};<br/>
    print Dump $hash;<br/>
    Bless($hash)-&gt;keys(['banana', 'apple']);<br/>
    print Dump $hash;<br/>
<div style="height: 1.00em;">
&#160;</div>
produces:<div style="height: 1.00em;">
&#160;</div>
<br/>
    ---<br/>
    apple: good<br/>
    banana: bad<br/>
    cauliflower: ugly<br/>
    ---<br/>
    banana: bad<br/>
    apple: good<br/>
<div style="height: 1.00em;">
&#160;</div>
Bless returns the tied part of a yaml-node, so that you can call the YAML::Node methods. This is the same thing that  <i>YAML::Node::ynode()</i> returns. So another way to do the above example is:<div style="height: 1.00em;">
&#160;</div>
<br/>
    use YAML qw(Dump Bless);<br/>
    use YAML::Node;<br/>
    $hash = {apple =&gt; 'good', banana =&gt; 'bad', cauliflower =&gt; 'ugly'};<br/>
    print Dump $hash;<br/>
    Bless($hash);<br/>
    $ynode = ynode(Blessed($hash));<br/>
    $ynode-&gt;keys(['banana', 'apple']);<br/>
    print Dump $hash;<br/>
<div style="height: 1.00em;">
&#160;</div>
Note that Blessing a Perl data structure does not change it anyway. The extra information is stored separately and looked up by the Blessed node's memory address.</dd>
</dl>
<dl>
<dt>
Blessed(perl-node)</dt>
<dd>
Returns the yaml node that a particular perl node is associated with (see above). Returns undef if the node is not (YAML) Blessed.</dd>
</dl>
</div>
</div>
<div class="section">
<h1>GLOBAL OPTIONS</h1> YAML options are set using a group of global variables in the YAML namespace. This is similar to how Data::Dumper works.<div class="spacer">
</div>
For example, to change the indentation width, do something like:<div class="spacer">
</div>
<br/>
    local $YAML::Indent = 3;<br/>
<div class="spacer">
</div>
The current options are:<dl>
<dt>
DumperClass</dt>
<dd>
You can override which module/class YAML uses for Dumping data.</dd>
</dl>
<dl>
<dt>
LoaderClass</dt>
<dd>
You can override which module/class YAML uses for Loading data.</dd>
</dl>
<dl>
<dt>
Indent</dt>
<dd>
This is the number of space characters to use for each indentation level when doing a  <i>Dump()</i>. The default is 2.<div style="height: 1.00em;">
&#160;</div>
By the way, YAML can use any number of characters for indentation at any level. So if you are editing YAML by hand feel free to do it anyway that looks pleasing to you; just be consistent for a given level.</dd>
</dl>
<dl>
<dt>
SortKeys</dt>
<dd>
Default is 1. (true)<div style="height: 1.00em;">
&#160;</div>
Tells YAML.pm whether or not to sort hash keys when storing a document.<div style="height: 1.00em;">
&#160;</div>
YAML::Node objects can have their own sort order, which is usually what you want. To override the YAML::Node order and sort the keys anyway, set SortKeys to 2.</dd>
</dl>
<dl>
<dt>
Stringify</dt>
<dd>
Default is 0. (false)<div style="height: 1.00em;">
&#160;</div>
Objects with string overloading should honor the overloading and dump the stringification of themselves, rather than the actual object's guts.</dd>
</dl>
<dl>
<dt>
UseHeader</dt>
<dd>
Default is 1. (true)<div style="height: 1.00em;">
&#160;</div>
This tells YAML.pm whether to use a separator string for a Dump operation. This only applies to the first document in a stream. Subsequent documents must have a YAML header by definition.</dd>
</dl>
<dl>
<dt>
UseVersion</dt>
<dd>
Default is 0. (false)<div style="height: 1.00em;">
&#160;</div>
Tells YAML.pm whether to include the YAML version on the separator/header.<div style="height: 1.00em;">
&#160;</div>
<br/>
    --- %YAML:1.0<br/>
</dd>
</dl>
<dl>
<dt>
AnchorPrefix</dt>
<dd>
Default is ''.<div style="height: 1.00em;">
&#160;</div>
Anchor names are normally numeric. YAML.pm simply starts with '1' and increases by one for each new anchor. This option allows you to specify a string to be prepended to each anchor number.</dd>
</dl>
<dl>
<dt>
UseCode</dt>
<dd>
Setting the UseCode option is a shortcut to set both the DumpCode and LoadCode options at once. Setting UseCode to '1' tells YAML.pm to dump Perl code references as Perl (using B::Deparse) and to load them back into memory using  <i>eval()</i>. The reason this has to be an option is that using  <i>eval()</i> to parse untrusted code is, well, untrustworthy.</dd>
</dl>
<dl>
<dt>
DumpCode</dt>
<dd>
Determines if and how YAML.pm should serialize Perl code references. By default YAML.pm will dump code references as dummy placeholders (much like Data::Dumper). If DumpCode is set to '1' or 'deparse', code references will be dumped as actual Perl code.<div style="height: 1.00em;">
&#160;</div>
DumpCode can also be set to a subroutine reference so that you can write your own serializing routine. YAML.pm passes you the code ref. You pass back the serialization (as a string) and a format indicator. The format indicator is a simple string like: 'deparse' or 'bytecode'.</dd>
</dl>
<dl>
<dt>
LoadCode</dt>
<dd>
LoadCode is the opposite of DumpCode. It tells YAML if and how to deserialize code references. When set to '1' or 'deparse' it will use &quot;eval()&quot;. Since this is potentially risky, only use this option if you know where your YAML has been.<div style="height: 1.00em;">
&#160;</div>
LoadCode can also be set to a subroutine reference so that you can write your own deserializing routine. YAML.pm passes the serialization (as a string) and a format indicator. You pass back the code reference.</dd>
</dl>
<dl>
<dt>
UseBlock</dt>
<dd>
YAML.pm uses heuristics to guess which scalar style is best for a given node. Sometimes you'll want all multiline scalars to use the 'block' style. If so, set this option to 1.<div style="height: 1.00em;">
&#160;</div>
NOTE: YAML's block style is akin to Perl's here-document.</dd>
</dl>
<dl>
<dt>
UseFold</dt>
<dd>
If you want to force YAML to use the 'folded' style for all multiline scalars, then set $UseFold to 1.<div style="height: 1.00em;">
&#160;</div>
NOTE: YAML's folded style is akin to the way HTML folds text,<br/>
      except smarter.</dd>
</dl>
<dl>
<dt>
UseAliases</dt>
<dd>
YAML has an alias mechanism such that any given structure in memory gets serialized once. Any other references to that structure are serialized only as alias markers. This is how YAML can serialize duplicate and recursive structures.<div style="height: 1.00em;">
&#160;</div>
Sometimes, when you KNOW that your data is nonrecursive in nature, you may want to serialize such that every node is expressed in full. (ie as a copy of the original). Setting $YAML::UseAliases to 0 will allow you to do this. This also may result in faster processing because the lookup overhead is by bypassed.<div style="height: 1.00em;">
&#160;</div>
THIS OPTION CAN BE DANGEROUS. *If* your data is recursive, this option *will* cause  <i>Dump()</i> to run in an endless loop, chewing up your computers memory. You have been warned.</dd>
</dl>
<dl>
<dt>
CompressSeries</dt>
<dd>
Default is 1.<div style="height: 1.00em;">
&#160;</div>
Compresses the formatting of arrays of hashes:<div style="height: 1.00em;">
&#160;</div>
<br/>
    -<br/>
      foo: bar<br/>
    - <br/>
      bar: foo<br/>
<div style="height: 1.00em;">
&#160;</div>
becomes:<div style="height: 1.00em;">
&#160;</div>
<br/>
    - foo: bar<br/>
    - bar: foo<br/>
<div style="height: 1.00em;">
&#160;</div>
Since this output is usually more desirable, this option is turned on by default.</dd>
</dl>
</div>
<div class="section">
<h1>YAML TERMINOLOGY</h1> YAML is a full featured data serialization language, and thus has its own terminology.<div class="spacer">
</div>
It is important to remember that although YAML is heavily influenced by Perl and Python, it is a language in its own right, not merely just a representation of Perl structures.<div class="spacer">
</div>
YAML has three constructs that are conspicuously similar to Perl's hash, array, and scalar. They are called mapping, sequence, and string respectively. By default, they do what you would expect. But each instance may have an explicit or implicit tag (type) that makes it behave differently. In this manner, YAML can be extended to represent Perl's Glob or Python's tuple, or Ruby's Bigint.<dl>
<dt>
stream</dt>
<dd>
A YAML stream is the full sequence of unicode characters that a YAML parser would read or a YAML emitter would write. A stream may contain one or more YAML documents separated by YAML headers.<div style="height: 1.00em;">
&#160;</div>
<br/>
    ---<br/>
    a: mapping<br/>
    foo: bar<br/>
    ---<br/>
    - a<br/>
    - sequence<br/>
</dd>
</dl>
<dl>
<dt>
document</dt>
<dd>
A YAML document is an independent data structure representation within a stream. It is a top level node. Each document in a YAML stream must begin with a YAML header line. Actually the header is optional on the first document.<div style="height: 1.00em;">
&#160;</div>
<br/>
    ---<br/>
    This: top level mapping<br/>
    is:<br/>
        - a<br/>
        - YAML<br/>
        - document<br/>
</dd>
</dl>
<dl>
<dt>
header</dt>
<dd>
A YAML header is a line that begins a YAML document. It consists of three dashes, possibly followed by more info. Another purpose of the header line is that it serves as a place to put top level tag and anchor information.<div style="height: 1.00em;">
&#160;</div>
<br/>
    --- !recursive-sequence &amp;001<br/>
    - * 001<br/>
    - * 001<br/>
</dd>
</dl>
<dl>
<dt>
node</dt>
<dd>
A YAML node is the representation of a particular data stucture. Nodes may contain other nodes. (In Perl terms, nodes are like scalars. Strings, arrayrefs and hashrefs. But this refers to the serialized format, not the in-memory structure.)</dd>
</dl>
<dl>
<dt>
tag</dt>
<dd>
This is similar to a type. It indicates how a particular YAML node serialization should be transferred into or out of memory. For instance a Foo::Bar object would use the tag 'perl/Foo::Bar':<div style="height: 1.00em;">
&#160;</div>
<br/>
    - !perl/Foo::Bar<br/>
        foo: 42<br/>
        bar: stool<br/>
</dd>
</dl>
<dl>
<dt>
collection</dt>
<dd>
A collection is the generic term for a YAML data grouping. YAML has two types of collections: mappings and sequences. (Similar to hashes and arrays)</dd>
</dl>
<dl>
<dt>
mapping</dt>
<dd>
A mapping is a YAML collection defined by unordered key/value pairs with unique keys. By default YAML mappings are loaded into Perl hashes.<div style="height: 1.00em;">
&#160;</div>
<br/>
    a mapping:<br/>
        foo: bar<br/>
        two: times two is 4<br/>
</dd>
</dl>
<dl>
<dt>
sequence</dt>
<dd>
A sequence is a YAML collection defined by an ordered list of elements. By default YAML sequences are loaded into Perl arrays.<div style="height: 1.00em;">
&#160;</div>
<br/>
    a sequence:<br/>
        - one bourbon<br/>
        - one scotch<br/>
        - one beer<br/>
</dd>
</dl>
<dl>
<dt>
scalar</dt>
<dd>
A scalar is a YAML node that is a single value. By default YAML scalars are loaded into Perl scalars.<div style="height: 1.00em;">
&#160;</div>
<br/>
    a scalar key: a scalar value<br/>
<div style="height: 1.00em;">
&#160;</div>
YAML has many styles for representing scalars. This is important because varying data will have varying formatting requirements to retain the optimum human readability.</dd>
</dl>
<dl>
<dt>
plain scalar</dt>
<dd>
A plain sclar is unquoted. All plain scalars are automatic candidates for &quot;implicit tagging&quot;. This means that their tag may be determined automatically by examination. The typical uses for this are plain alpha strings, integers, real numbers, dates, times and currency.<div style="height: 1.00em;">
&#160;</div>
<br/>
    - a plain string<br/>
    - -42<br/>
    - 3.1415<br/>
    - 12:34<br/>
    - 123 this is an error<br/>
</dd>
</dl>
<dl>
<dt>
single quoted scalar</dt>
<dd>
This is similar to Perl's use of single quotes. It means no escaping except for single quotes which are escaped by using two adjacent single quotes.<div style="height: 1.00em;">
&#160;</div>
<br/>
    - 'When I say ''\n'' I mean &quot;backslash en&quot;'<br/>
</dd>
</dl>
<dl>
<dt>
double quoted scalar</dt>
<dd>
This is similar to Perl's use of double quotes. Character escaping can be used.<div style="height: 1.00em;">
&#160;</div>
<br/>
    - &quot;This scalar\nhas two lines, and a bell --&gt;\a&quot;<br/>
</dd>
</dl>
<dl>
<dt>
folded scalar</dt>
<dd>
This is a multiline scalar which begins on the next line. It is indicated by a single right angle bracket. It is unescaped like the single quoted scalar. Line folding is also performed.<div style="height: 1.00em;">
&#160;</div>
<br/>
    - &gt; <br/>
     This is a multiline scalar which begins on<br/>
     the next line. It is indicated by a single<br/>
     carat. It is unescaped like the single<br/>
     quoted scalar. Line folding is also<br/>
     performed.<br/>
</dd>
</dl>
<dl>
<dt>
block scalar</dt>
<dd>
This final multiline form is akin to Perl's here-document except that (as in all YAML data) scope is indicated by indentation. Therefore, no ending marker is required. The data is verbatim. No line folding.<div style="height: 1.00em;">
&#160;</div>
<br/>
    - |<br/>
        QTY  DESC          PRICE  TOTAL<br/>
        ---  ----          -----  -----<br/>
          1  Foo Fighters  $19.95 $19.95<br/>
          2  Bar Belles    $29.95 $59.90<br/>
</dd>
</dl>
<dl>
<dt>
parser</dt>
<dd>
A YAML processor has four stages: parse, load, dump, emit.<div style="height: 1.00em;">
&#160;</div>
A parser parses a YAML stream. YAML.pm's <i>Load()</i> function contains a parser.</dd>
</dl>
<dl>
<dt>
loader</dt>
<dd>
The other half of the <i>Load()</i> function is a loader. This takes the information from the parser and loads it into a Perl data structure.</dd>
</dl>
<dl>
<dt>
dumper</dt>
<dd>
The <i>Dump()</i> function consists of a dumper and an emitter. The dumper walks through each Perl data structure and gives info to the emitter.</dd>
</dl>
<dl>
<dt>
emitter</dt>
<dd>
The emitter takes info from the dumper and turns it into a YAML stream.<div style="height: 1.00em;">
&#160;</div>
NOTE: In YAML.pm the parser/loader and the dumper/emitter code are currently very closely tied together. In the future they may be broken into separate stages.</dd>
</dl>
<div class="spacer">
</div>
For more information please refer to the immensely helpful YAML specification available at &lt;http://www.yaml.org/spec/&gt;.</div>
<div class="section">
<h1>ysh - The YAML Shell</h1> libyaml-shell-perl contains a script called 'ysh', the YAML shell. ysh provides a simple, interactive way to play with YAML. If you type in Perl code, it displays the result in YAML. If you type in YAML it turns it into Perl code.<div class="spacer">
</div>
To run ysh, (assuming you installed it along with YAML.pm) simply type:<div class="spacer">
</div>
<br/>
    ysh [options]<br/>
<div class="spacer">
</div>
Please read the &quot;ysh&quot; documentation for the full details. There are lots of options.</div>
<div class="section">
<h1>BUGS &amp; DEFICIENCIES</h1> If you find a bug in YAML, please try to recreate it in the YAML Shell with logging turned on ('ysh -L'). When you have successfully reproduced the bug, please mail the LOG file to the author (ingy@cpan.org).<div class="spacer">
</div>
WARNING: This is still *ALPHA* code. Well, most of this code has been around for years...<div class="spacer">
</div>
BIGGER WARNING: YAML.pm has been slow in the making, but I am committed to having top notch YAML tools in the Perl world. The YAML team is close to finalizing the YAML 1.1 spec. This version of YAML.pm is based off of a very old pre 1.0 spec. In actuality there isn't a ton of difference, and this YAML.pm is still fairly useful. Things will get much better in the future.</div>
<div class="section">
<h1>RESOURCES</h1> http://lists.sourceforge.net/lists/listinfo/yaml-core &lt;http://lists.sourceforge.net/lists/listinfo/yaml-core&gt; is the mailing list. This is where the language is discussed and designed.<div class="spacer">
</div>
&lt;http://www.yaml.org&gt; is the official YAML website.<div class="spacer">
</div>
&lt;http://www.yaml.org/spec/&gt; is the YAML 1.0 specification.<div class="spacer">
</div>
&lt;http://yaml.kwiki.org&gt; is the official YAML wiki.</div>
<div class="section">
<h1>SEE ALSO</h1> See YAML::Syck. Fast!</div>
<div class="section">
<h1>AUTHOR</h1> Ingy doet Net &lt;ingy@cpan.org&gt;<div class="spacer">
</div>
is resonsible for YAML.pm.<div class="spacer">
</div>
The YAML serialization language is the result of years of collaboration between Oren Ben-Kiki, Clark Evans and Ingy doet Net. Several others have added help along the way.</div>
<div class="section">
<h1>COPYRIGHT</h1> Copyright (c) 2005, 2006, 2008. Ingy doet Net.<div class="spacer">
</div>
Copyright (c) 2001, 2002, 2005. Brian Ingerson.<div class="spacer">
</div>
Some parts copyright (c) 2009 - 2010 Adam Kennedy<div class="spacer">
</div>
This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.<div class="spacer">
</div>
See &lt;http://www.perl.com/perl/misc/Artistic.html&gt;</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-10-17</td>
<td class="foot-os">
perl v5.12.4</td>
</tr>
</table>
</div>
</body>
</html>

