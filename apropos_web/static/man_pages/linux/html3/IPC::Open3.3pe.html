<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
IPC::Open3(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
IPC::Open3(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
IPC::Open3(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> IPC::Open3 - open a process for reading, writing, and error handling using open3()</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
    $pid = open3(\*CHLD_IN, \*CHLD_OUT, \*CHLD_ERR,<br/>
                    'some cmd and args', 'optarg', ...);<br/>
<br/>
    my($wtr, $rdr, $err);<br/>
    use Symbol 'gensym'; $err = gensym;<br/>
    $pid = open3($wtr, $rdr, $err,<br/>
                    'some cmd and args', 'optarg', ...);<br/>
<br/>
    waitpid( $pid, 0 );<br/>
    my $child_exit_status = $? &gt;&gt; 8;<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> Extremely similar to  <i>open2()</i>, <i>open3()</i> spawns the given $cmd and connects CHLD_OUT for reading from the child, CHLD_IN for writing to the child, and CHLD_ERR for errors.  If CHLD_ERR is false, or the same file descriptor as CHLD_OUT, then STDOUT and STDERR of the child are on the same filehandle (this means that an autovivified lexical cannot be used for the STDERR filehandle, see SYNOPSIS).  The CHLD_IN will have autoflush turned on.<div class="spacer">
</div>
If CHLD_IN begins with &quot;&lt;&amp;&quot;, then CHLD_IN will be closed in the parent, and the child will read from it directly.  If CHLD_OUT or CHLD_ERR begins with &quot;&gt;&amp;&quot;, then the child will send output directly to that filehandle.  In both cases, there will be a  <i>dup</i>(2) instead of a  <i>pipe</i>(2) made.<div class="spacer">
</div>
If either reader or writer is the null string, this will be replaced by an autogenerated filehandle.  If so, you must pass a valid lvalue in the parameter slot so it can be overwritten in the caller, or an exception will be raised.<div class="spacer">
</div>
The filehandles may also be integers, in which case they are understood as file descriptors.<div class="spacer">
</div>
<i>open3()</i> returns the process ID of the child process.  It doesn't return on failure: it just raises an exception matching &quot;/^open3:/&quot;.  However, &quot;exec&quot; failures in the child (such as no such file or permission denied), are just reported to CHLD_ERR, as it is not possible to trap them.<div class="spacer">
</div>
If the child process dies for any reason, the next write to CHLD_IN is likely to generate a SIGPIPE in the parent, which is fatal by default. So you may wish to handle this signal.<div class="spacer">
</div>
Note if you specify &quot;-&quot; as the command, in an analogous fashion to &quot;open(FOO, &quot;-|&quot;)&quot; the child process will just be the forked Perl process rather than an external command.  This feature isn't yet supported on Win32 platforms.<div class="spacer">
</div>
<i>open3()</i> does not wait for and reap the child process after it exits. Except for short programs where it's acceptable to let the operating system take care of this, you need to do this yourself.  This is normally as simple as calling &quot;waitpid $pid, 0&quot; when you're done with the process. Failing to do this can result in an accumulation of defunct or &quot;zombie&quot; processes.  See &quot;waitpid&quot; in perlfunc for more information.<div class="spacer">
</div>
If you try to read from the child's stdout writer and their stderr writer, you'll have problems with blocking, which means you'll want to use  <i>select()</i> or the IO::Select, which means you'd best use  <i>sysread()</i> instead of <i>readline()</i> for normal stuff.<div class="spacer">
</div>
This is very dangerous, as you may block forever.  It assumes it's going to talk to something like  <b>bc</b>, both writing to it and reading from it.  This is presumably safe because you &quot;know&quot; that commands like  <b>bc</b> will read a line at a time and output a line at a time. Programs like  <b>sort</b> that read their entire input stream first, however, are quite apt to cause deadlock.<div class="spacer">
</div>
The big problem with this approach is that if you don't have control over source code being run in the child process, you can't control what it does with pipe buffering.  Thus you can't just open a pipe to &quot;cat -v&quot; and continually read and write a line from it.</div>
<div class="section">
<h1>See Also</h1><dl>
<dt>
IPC::Open2</dt>
<dd>
Like Open3 but without STDERR catpure.</dd>
</dl>
<dl>
<dt>
IPC::Run</dt>
<dd>
This is a CPAN module that has better error handling and more facilities than Open3.</dd>
</dl>
</div>
<div class="section">
<h1>WARNING</h1> The order of arguments differs from that of  <i>open2()</i>.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-09-26</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

