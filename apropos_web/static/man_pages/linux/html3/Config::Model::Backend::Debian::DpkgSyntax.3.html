<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Config::Model::Backend::Debian::DpkgSyntax(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Config::Model::Backend::Debian::DpkgSyntax(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
Config::Model::Backend::Debian::DpkgSyntax(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Config::Model::Backend::Debian::DpkgSyntax - Role to read and write files with Dpkg syntax</div>
<div class="section">
<h1>VERSION</h1> version 2.005</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
 package MyParser ;<br/>
 use Log::Log4perl qw(:easy);<br/>
 Log::Log4perl-&gt;easy_init($WARN);<br/>
 <br/>
 use Any::Moose ;<br/>
 with 'Config::Model::Backend::Debian::DpkgSyntax';<br/>
 <br/>
 package main ;<br/>
 use IO::File ;<br/>
 use Data::Dumper ;<br/>
 <br/>
 my $data = [ [ qw/Name Foo Version 1.2/ ],<br/>
              [ qw/Name Bar Version 1.3/ ,<br/>
                Files =&gt; [qw/file1 file2/] ,<br/>
                Description =&gt; &quot;A very\n\nlong description&quot;<br/>
             ]<br/>
           ] ;<br/>
 <br/>
 my $fhw = IO::File-&gt;new ;<br/>
 $fhw -&gt; open ( 'dpkg_file' ,'&gt;' ) ;<br/>
 my $parser = MyParser-&gt;new() ;<br/>
 <br/>
 $parser-&gt;write_dpkg_file($fhw,$data) ;<br/>
<div class="spacer">
</div>
&quot;dpkg_file&quot; will contain:<div class="spacer">
</div>
<br/>
 Name: Foo<br/>
 Version: 1.2<br/>
<br/>
 Name: Bar<br/>
 Version: 1.3<br/>
 Files: file1,<br/>
        file2<br/>
 Description: A very<br/>
  .<br/>
  long description<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> This module is a Moose role to read and write dpkg control files.<div class="spacer">
</div>
Debian control file are read and transformed in a list of list matching the control file. The top level list of a list of section. Each section is mapped to a list made of keywords and values. Since this explanation is probably too abstract, here's an example of a file written with Dpkg syntax:<div class="spacer">
</div>
<br/>
 Name: Foo<br/>
 Version: 1.1<br/>
<br/>
 Name: Bar<br/>
 Version: 1.2<br/>
  Description: A very<br/>
  . <br/>
  long description<br/>
<div class="spacer">
</div>
Once parsed, this file will be stored in the following list of list :<div class="spacer">
</div>
<br/>
 (<br/>
   [ Name =&gt; 'Foo', Version =&gt; '1.1' ],<br/>
   [ Name =&gt; 'Bar', Version =&gt; '1.2', <br/>
     Description =&gt; &quot;A very\n\nlong description&quot;<br/>
   ]<br/>
 )<br/>
<div class="spacer">
</div>
Note: The description is changed into a paragraph without the Dpkg syntax idiosyncrasies. The leading white space is removed and the single dot is transformed in to a &quot;\n&quot;. These characters will be restored when the file is written back.<div class="spacer">
</div>
Last not but not least, this module can be re-used outside of &quot;Config::Model&quot; with some small modifications in exception handing. Ask the author if you want this module shipped in its own distribution.</div>
<div class="section">
<h1><div class="spacer">
</div>
</h1><div class="subsection">
<h2>parse_dpkg_file ( file_handle , check )</h2> Read a control file from the file_handle and returns a nested list (or a list ref) containing data from the file.<div class="spacer">
</div>
The returned list is of the form :<div class="spacer">
</div>
<br/>
 [<br/>
   # section 1<br/>
   [ keyword1 =&gt; value1, # for text or simple values<br/>
     keyword2 =&gt; value2, # etc <br/>
   ],<br/>
   # section 2<br/>
   [ ... ]<br/>
   # etc ...<br/>
 ]<br/>
<div class="spacer">
</div>
check is &quot;yes&quot;, &quot;skip&quot; or &quot;no&quot;</div>
<div class="subsection">
<h2>parse_dpkg_lines (lines, check)</h2> Parse the dpkg date from lines (which is an array ref) and return a data structure like parse_dpkg_file.</div>
<div class="subsection">
<h2>write_dpkg_file ( io_handle, list_ref, list_sep )</h2> Munge the passed list ref into a string compatible with control files and write it in the passed file handle.<div class="spacer">
</div>
The input is a list of list in a form similar to the one generated by parse_dpkg_file:<div class="spacer">
</div>
<br/>
 [ section [ keyword =&gt; value | value_list ] ]<br/>
<div class="spacer">
</div>
Except that the value may be a SCALAR or a list ref. In case, of a list ref, the list items will be joined with the value &quot;list_sep&quot; before being written. Values will be aligned in case of multi-line output of a list.<div class="spacer">
</div>
For instance the following code :<div class="spacer">
</div>
<br/>
 my $ref = [ [ Foo =&gt; 'foo value' , Bar =&gt; [ qw/v1 v2/ ] ];<br/>
 write_dpkg_file ( $ioh, $ref, ', ' )<br/>
<div class="spacer">
</div>
will yield:<div class="spacer">
</div>
<br/>
 Foo: foo value<br/>
 Bar: v1, v2<br/>
</div>
</div>
<div class="section">
<h1>AUTHOR</h1> Dominique Dumont, (ddumont at cpan dot org)</div>
<div class="section">
<h1>SEE ALSO</h1> Config::Model, Config::Model::AutoRead, Config::Model::Backend::Any,</div>
<table class="foot">
<tr>
<td class="foot-date">
2012-02-24</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

