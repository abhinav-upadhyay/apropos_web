<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
CAP_GET_PROC(3)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
CAP_GET_PROC(3)</td>
<td class="head-vol">
Linux Programmer's Manual</td>
<td class="head-rtitle">
CAP_GET_PROC(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> cap_get_proc, cap_set_proc, capgetp, cap_get_bound, cap_drop_bound - capability manipulation on processes</div>
<div class="section">
<h1>SYNOPSIS</h1> <b>#include &lt;sys/capability.h&gt;</b><div style="height: 1.00em;">
&#160;</div>
<b>cap_t cap_get_proc(void);</b><div style="height: 1.00em;">
&#160;</div>
<b>int cap_set_proc(cap_t </b><i>cap_p</i><b>);</b><div style="height: 1.00em;">
&#160;</div>
<b>int cap_get_bound(cap_value_t </b><i>cap</i><b>);</b><div style="height: 1.00em;">
&#160;</div>
<b>CAP_IS_SUPPORTED(cap_value_t </b><i>cap</i><b>);</b><div style="height: 1.00em;">
&#160;</div>
<b>int cap_drop_bound(cap_value_t </b><i>cap</i><b>);</b><div style="height: 1.00em;">
&#160;</div>
<b>#include &lt;sys/types.h&gt;</b><div style="height: 1.00em;">
&#160;</div>
<b>cap_t cap_get_pid(pid_t </b><i>pid</i><b>);</b><div style="height: 1.00em;">
&#160;</div>
Link with <i>-lcap</i>.</div>
<div class="section">
<h1>DESCRIPTION</h1> <b>cap_get_proc</b>() allocates a capability state in working storage, sets its state to that of the calling process, and returns a pointer to this newly created capability state.  The caller should free any releasable memory, when the capability state in working storage is no longer required, by calling <b>cap_free</b>() with the <i>cap_t</i> as an argument.<div class="spacer">
</div>
<b>cap_set_proc</b>() sets the values for all capability flags for all capabilities to the capability state identified by <i>cap_p</i>. The new capability state of the process will be completely determined by the contents of <i>cap_p</i> upon successful return from this function.  If any flag in <i>cap_p</i> is set for any capability not currently permitted for the calling process, the function will fail, and the capability state of the process will remain unchanged.<div class="spacer">
</div>
<b>cap_get_pid</b>() returns <i>cap_d</i>, see <b>cap_init</b>(3), with the process capabilities of the process indicated by <i>pid</i>. This information can also be obtained from the <i>/proc/&lt;pid&gt;/status</i> file.<div class="spacer">
</div>
<b>cap_get_bound</b>() with a <i>cap</i> as an argument returns the current value of this bounding set capability flag in effect for the current process. This operation is unpriveged. Note, a macro function <b>CAP_IS_SUPPORTED(cap_value_t </b><i>cap</i><b>)</b> is provided that evaluates to true (1) if the system supports the specified capability, <i>cap</i>. If the system does not support the capability, this function returns 0. This macro works by testing for an error condition with <b>cap_get_bound</b>().<div class="spacer">
</div>
<b>cap_drop_bound</b>() can be used to lower the specified bounding set capability, <b>cap</b>, To complete successfully, the prevailing <i>effective</i> capability set must have a raised <b>CAP_SETPCAP</b>.</div>
<div class="section">
<h1>RETURN VALUE</h1> The functions <b>cap_get_proc</b>() and <b>cap_get_pid</b>() return a non-NULL value on success, and NULL on failure.<div class="spacer">
</div>
The function <b>cap_get_bound</b>() returns -1 if the requested capability is unknown, otherwise the return value reflects the current state of that capability in the prevailing bounding set. Note, a macro function,<div class="spacer">
</div>
The functions <b>cap_set_proc</b>() and <b>cap_drop_bound</b>() return zero for success, and -1 on failure.<div class="spacer">
</div>
On failure, <i>errno</i> is set to <b>EINVAL</b>, <b>EPERM,</b> or <b>ENOMEM</b>.</div>
<div class="section">
<h1>CONFORMING TO</h1> <b>cap_set_proc</b>() and <b>cap_get_proc</b>() are specified in the withdrawn POSIX.1e draft specification. <b>cap_get_pid</b>() is a Linux extension.</div>
<div class="section">
<h1>NOTES</h1> The library also supports the deprecated functions:<div class="spacer">
</div>
<b>int capgetp(pid_t </b><i>pid</i><b>, cap_t </b><i>cap_d</i><b>);</b><div class="spacer">
</div>
<b>int capsetp(pid_t </b><i>pid</i><b>, cap_t </b><i>cap_d</i><b>);</b><div class="spacer">
</div>
<b>capgetp</b>() attempts to obtain the capabilities of some other process; storing the capabilities in a pre-allocated <i>cap_d</i>.<i>See</i> <b>cap_init</b>() for information on allocating an empty capability set. This function, <b>capgetp</b>(), is deprecated, you should use <b>cap_get_pid</b>().<div class="spacer">
</div>
<b>capsetp</b>() attempts to set the capabilities of some other process(es), <i>pid</i>. If <i>pid</i> is positive it refers to a specific process;  if it is zero, it refers to the current process; -1 refers to all processes other than the current process and process '1' (typically <b>init</b>(8)); other negative values refer to the <i>-pid</i> process group.  In order to use this function, the kernel must support it and the current process must have <b>CAP_SETPCAP</b> raised in its Effective capability set. The capabilities set in the target process(es) are those contained in <i>cap_d</i>. Kernels that support filesystem capabilities redefine the semantics of <b>CAP_SETPCAP</b> and on such systems this function will always fail for any target not equal to the current process. <b>capsetp</b>() returns zero for success, and -1 on failure.<div style="height: 1.00em;">
&#160;</div>
Where supported by the kernel, the function <b>capsetp</b>() should be used with care.  It existed, primarily, to overcome an early lack of support for capabilities in the filesystems supported by Linux.  Note that, by default, the only processes that have <b>CAP_SETPCAP</b> available to them are processes started as a kernel thread. (Typically this includes <b>init</b>(8), kflushd and kswapd). You will need to recompile the kernel to modify this default.</div>
<div class="section">
<h1>EXAMPLE</h1> The code segment below raises the <b>CAP_FOWNER</b> and <b>CAP_SETFCAP</b> effective capabilities for the caller:<div class="spacer">
</div>
<br/>
    cap_t caps;<br/>
    cap_value_t cap_list[2];<div class="spacer">
</div>
<br/>
    if (!CAP_IS_SUPPORTED(CAP_SETFCAP))<br/>
        /* handle error */<div class="spacer">
</div>
<br/>
    caps = cap_get_proc();<br/>
    if (caps == NULL)<br/>
        /* handle error */;<div class="spacer">
</div>
<br/>
    cap_list[0] = CAP_FOWNER;<br/>
    cap_list[1] = CAP_SETFCAP;<br/>
    if (cap_set_flag(caps, CAP_EFFECTIVE, 2, cap_list, CAP_SET) == -1)<br/>
        /* handle error */;<div class="spacer">
</div>
<br/>
    if (cap_set_proc(caps) == -1)<br/>
        /* handle error */;<div class="spacer">
</div>
<br/>
    if (cap_free(caps) == -1)<br/>
        /* handle error */;<br/>
</div>
<div class="section">
<h1>SEE ALSO</h1> <b>libcap</b>(3), <b>cap_clear</b>(3), <b>cap_copy_ext</b>(3), <b>cap_from_text</b>(3), <b>cap_get_file</b>(3), <b>cap_init</b>(3), <b>capabilities</b>(7)</div>
<table class="foot">
<tr>
<td class="foot-date">
2008-05-11</td>
<td class="foot-os">
</td>
</tr>
</table>
</div>
</body>
</html>

