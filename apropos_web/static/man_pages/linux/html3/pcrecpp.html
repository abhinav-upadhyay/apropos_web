<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
PCRECPP(3)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
PCRECPP(3)</td>
<td class="head-vol">
Library Functions Manual</td>
<td class="head-rtitle">
PCRECPP(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> PCRE - Perl-compatible regular expressions.</div>
<div class="section">
<h1>SYNOPSIS OF C++ WRAPPER</h1> <b>#include &lt;pcrecpp.h&gt;</b></div>
<div class="section">
<h1>DESCRIPTION</h1> The C++ wrapper for PCRE was provided by Google Inc. Some additional functionality was added by Giuseppe Maxia. This brief man page was constructed from the notes in the  <i>pcrecpp.h</i> file, which should be consulted for further details. Note that the C++ wrapper supports only the original 8-bit PCRE library. There is no 16-bit support at present.</div>
<div class="section">
<h1>MATCHING INTERFACE</h1> The &quot;FullMatch&quot; operation checks that supplied text matches a supplied pattern exactly. If pointer arguments are supplied, it copies matched sub-strings that match sub-patterns into them.<div style="height: 1.00em;">
&#160;</div>
<br/>
  Example: successful match<br/>
     pcrecpp::RE re(&quot;h.*o&quot;);<br/>
     re.FullMatch(&quot;hello&quot;);<div style="height: 1.00em;">
&#160;</div>
<br/>
  Example: unsuccessful match (requires full match):<br/>
     pcrecpp::RE re(&quot;e&quot;);<br/>
     !re.FullMatch(&quot;hello&quot;);<div style="height: 1.00em;">
&#160;</div>
<br/>
  Example: creating a temporary RE object:<br/>
     pcrecpp::RE(&quot;h.*o&quot;).FullMatch(&quot;hello&quot;);<div style="height: 1.00em;">
&#160;</div>
You can pass in a &quot;const char*&quot; or a &quot;string&quot; for &quot;text&quot;. The examples below tend to use a const char*. You can, as in the different examples above, store the RE object explicitly in a variable or use a temporary RE object. The examples below use one mode or the other arbitrarily. Either could correctly be used for any of these examples.<div class="spacer">
</div>
You must supply extra pointer arguments to extract matched subpieces.<div style="height: 1.00em;">
&#160;</div>
<br/>
  Example: extracts &quot;ruby&quot; into &quot;s&quot; and 1234 into &quot;i&quot;<br/>
     int i;<br/>
     string s;<br/>
     pcrecpp::RE re(&quot;(\\w+):(\\d+)&quot;);<br/>
     re.FullMatch(&quot;ruby:1234&quot;, &amp;s, &amp;i);<div style="height: 1.00em;">
&#160;</div>
<br/>
  Example: does not try to extract any extra sub-patterns<br/>
     re.FullMatch(&quot;ruby:1234&quot;, &amp;s);<div style="height: 1.00em;">
&#160;</div>
<br/>
  Example: does not try to extract into NULL<br/>
     re.FullMatch(&quot;ruby:1234&quot;, NULL, &amp;i);<div style="height: 1.00em;">
&#160;</div>
<br/>
  Example: integer overflow causes failure<br/>
     !re.FullMatch(&quot;ruby:1234567891234&quot;, NULL, &amp;i);<div style="height: 1.00em;">
&#160;</div>
<br/>
  Example: fails because there aren't enough sub-patterns:<br/>
     !pcrecpp::RE(&quot;\\w+:\\d+&quot;).FullMatch(&quot;ruby:1234&quot;, &amp;s);<div style="height: 1.00em;">
&#160;</div>
<br/>
  Example: fails because string cannot be stored in integer<br/>
     !pcrecpp::RE(&quot;(.*)&quot;).FullMatch(&quot;ruby&quot;, &amp;i);<div style="height: 1.00em;">
&#160;</div>
The provided pointer arguments can be pointers to any scalar numeric type, or one of:<div style="height: 1.00em;">
&#160;</div>
<br/>
   string        (matched piece is copied to string)<br/>
   StringPiece   (StringPiece is mutated to point to matched piece)<br/>
   T             (where &quot;bool T::ParseFrom(const char*, int)&quot; exists)<br/>
   NULL          (the corresponding matched sub-pattern is not copied)<div style="height: 1.00em;">
&#160;</div>
The function returns true iff all of the following conditions are satisfied:<div style="height: 1.00em;">
&#160;</div>
<br/>
  a. &quot;text&quot; matches &quot;pattern&quot; exactly;<div style="height: 1.00em;">
&#160;</div>
<br/>
  b. The number of matched sub-patterns is &gt;= number of supplied<br/>
     pointers;<div style="height: 1.00em;">
&#160;</div>
<br/>
  c. The &quot;i&quot;th argument has a suitable type for holding the<br/>
     string captured as the &quot;i&quot;th sub-pattern. If you pass in<br/>
     void * NULL for the &quot;i&quot;th argument, or a non-void * NULL<br/>
     of the correct type, or pass fewer arguments than the<br/>
     number of sub-patterns, &quot;i&quot;th captured sub-pattern is<br/>
     ignored.<div style="height: 1.00em;">
&#160;</div>
CAVEAT: An optional sub-pattern that does not exist in the matched string is assigned the empty string. Therefore, the following will return false (because the empty string is not a valid number):<div style="height: 1.00em;">
&#160;</div>
<br/>
   int number;<br/>
   pcrecpp::RE::FullMatch(&quot;abc&quot;, &quot;[a-z]+(\\d+)?&quot;, &amp;number);<div style="height: 1.00em;">
&#160;</div>
The matching interface supports at most 16 arguments per call. If you need more, consider using the more general interface  <b>pcrecpp::RE::DoMatch</b>. See <b>pcrecpp.h</b> for the signature for  <b>DoMatch</b>.<div class="spacer">
</div>
NOTE: Do not use <b>no_arg</b>, which is used internally to mark the end of a list of optional arguments, as a placeholder for missing arguments, as this can lead to segfaults.</div>
<div class="section">
<h1>QUOTING METACHARACTERS</h1> You can use the &quot;QuoteMeta&quot; operation to insert backslashes before all potentially meaningful characters in a string. The returned string, used as a regular expression, will exactly match the original string.<div style="height: 1.00em;">
&#160;</div>
<br/>
  Example:<br/>
     string quoted = RE::QuoteMeta(unquoted);<div style="height: 1.00em;">
&#160;</div>
Note that it's legal to escape a character even if it has no special meaning in a regular expression -- so this function does that. (This also makes it identical to the perl function of the same name; see &quot;perldoc -f quotemeta&quot;.) For example, &quot;1.5-2.0?&quot; becomes &quot;1\.5\-2\.0\?&quot;.</div>
<div class="section">
<h1>PARTIAL MATCHES</h1> You can use the &quot;PartialMatch&quot; operation when you want the pattern to match any substring of the text.<div style="height: 1.00em;">
&#160;</div>
<br/>
  Example: simple search for a string:<br/>
     pcrecpp::RE(&quot;ell&quot;).PartialMatch(&quot;hello&quot;);<div style="height: 1.00em;">
&#160;</div>
<br/>
  Example: find first number in a string:<br/>
     int number;<br/>
     pcrecpp::RE re(&quot;(\\d+)&quot;);<br/>
     re.PartialMatch(&quot;x*100 + 20&quot;, &amp;number);<br/>
     assert(number == 100);</div>
<div class="section">
<h1>UTF-8 AND THE MATCHING INTERFACE</h1> By default, pattern and text are plain text, one byte per character. The UTF8 flag, passed to the constructor, causes both pattern and string to be treated as UTF-8 text, still a byte stream but potentially multiple bytes per character. In practice, the text is likelier to be UTF-8 than the pattern, but the match returned may depend on the UTF8 flag, so always use it when matching UTF8 text. For example, &quot;.&quot; will match one byte normally but with UTF8 set may match up to three bytes of a multi-byte character.<div style="height: 1.00em;">
&#160;</div>
<br/>
  Example:<br/>
     pcrecpp::RE_Options options;<br/>
     options.set_utf8();<br/>
     pcrecpp::RE re(utf8_pattern, options);<br/>
     re.FullMatch(utf8_string);<div style="height: 1.00em;">
&#160;</div>
<br/>
  Example: using the convenience function UTF8():<br/>
     pcrecpp::RE re(utf8_pattern, pcrecpp::UTF8());<br/>
     re.FullMatch(utf8_string);<div style="height: 1.00em;">
&#160;</div>
NOTE: The UTF8 flag is ignored if pcre was not configured with the<br/>
      --enable-utf8 flag.</div>
<div class="section">
<h1>PASSING MODIFIERS TO THE REGULAR EXPRESSION ENGINE</h1> PCRE defines some modifiers to change the behavior of the regular expression engine. The C++ wrapper defines an auxiliary class, RE_Options, as a vehicle to pass such modifiers to a RE class. Currently, the following modifiers are supported:<div style="height: 1.00em;">
&#160;</div>
<br/>
   modifier              description               Perl corresponding<div style="height: 1.00em;">
&#160;</div>
<br/>
   PCRE_CASELESS         case insensitive match      /i<br/>
   PCRE_MULTILINE        multiple lines match        /m<br/>
   PCRE_DOTALL           dot matches newlines        /s<br/>
   PCRE_DOLLAR_ENDONLY   $ matches only at end       N/A<br/>
   PCRE_EXTRA            strict escape parsing       N/A<br/>
   PCRE_EXTENDED         ignore white spaces         /x<br/>
   PCRE_UTF8             handles UTF8 chars          built-in<br/>
   PCRE_UNGREEDY         reverses * and *?           N/A<br/>
   PCRE_NO_AUTO_CAPTURE  disables capturing parens   N/A (*)<div style="height: 1.00em;">
&#160;</div>
(*) Both Perl and PCRE allow non capturing parentheses by means of the &quot;?:&quot; modifier within the pattern itself. e.g. (?:ab|cd) does not capture, while (ab|cd) does.<div class="spacer">
</div>
For a full account on how each modifier works, please check the PCRE API reference page.<div class="spacer">
</div>
For each modifier, there are two member functions whose name is made out of the modifier in lowercase, without the &quot;PCRE_&quot; prefix. For instance, PCRE_CASELESS is handled by<div style="height: 1.00em;">
&#160;</div>
<br/>
  bool caseless()<div style="height: 1.00em;">
&#160;</div>
which returns true if the modifier is set, and<div style="height: 1.00em;">
&#160;</div>
<br/>
  RE_Options &amp; set_caseless(bool)<div style="height: 1.00em;">
&#160;</div>
which sets or unsets the modifier. Moreover, PCRE_EXTRA_MATCH_LIMIT can be accessed through the  <b>set_match_limit()</b> and <b>match_limit()</b> member functions. Setting  <i>match_limit</i> to a non-zero value will limit the execution of pcre to keep it from doing bad things like blowing the stack or taking an eternity to return a result. A value of 5000 is good enough to stop stack blowup in a 2MB thread stack. Setting  <i>match_limit</i> to zero disables match limiting. Alternatively, you can call  <b>match_limit_recursion()</b> which uses PCRE_EXTRA_MATCH_LIMIT_RECURSION to limit how much PCRE recurses.  <b>match_limit()</b> limits the number of matches PCRE does;  <b>match_limit_recursion()</b> limits the depth of internal recursion, and therefore the amount of stack that is used.<div class="spacer">
</div>
Normally, to pass one or more modifiers to a RE class, you declare a  <i>RE_Options</i> object, set the appropriate options, and pass this object to a RE constructor. Example:<div style="height: 1.00em;">
&#160;</div>
<br/>
   RE_Options opt;<br/>
   opt.set_caseless(true);<br/>
   if (RE(&quot;HELLO&quot;, opt).PartialMatch(&quot;hello world&quot;)) ...<div style="height: 1.00em;">
&#160;</div>
RE_options has two constructors. The default constructor takes no arguments and creates a set of flags that are off by default. The optional parameter  <i>option_flags</i> is to facilitate transfer of legacy code from C programs. This lets you do<div style="height: 1.00em;">
&#160;</div>
<br/>
   RE(pattern,<br/>
     RE_Options(PCRE_CASELESS|PCRE_MULTILINE)).PartialMatch(str);<div style="height: 1.00em;">
&#160;</div>
However, new code is better off doing<div style="height: 1.00em;">
&#160;</div>
<br/>
   RE(pattern,<br/>
     RE_Options().set_caseless(true).set_multiline(true))<br/>
       .PartialMatch(str);<div style="height: 1.00em;">
&#160;</div>
If you are going to pass one of the most used modifiers, there are some convenience functions that return a RE_Options class with the appropriate modifier already set:  <b>CASELESS()</b>, <b>UTF8()</b>,  <b>MULTILINE()</b>, <b>DOTALL</b>(), and <b>EXTENDED()</b>.<div class="spacer">
</div>
If you need to set several options at once, and you don't want to go through the pains of declaring a RE_Options object and setting several options, there is a parallel method that give you such ability on the fly. You can concatenate several  <b>set_xxxxx()</b> member functions, since each of them returns a reference to its class object. For example, to pass PCRE_CASELESS, PCRE_EXTENDED, and PCRE_MULTILINE to a RE with one statement, you may write:<div style="height: 1.00em;">
&#160;</div>
<br/>
   RE(&quot; ^ xyz \\s+ .* blah$&quot;,<br/>
     RE_Options()<br/>
       .set_caseless(true)<br/>
       .set_extended(true)<br/>
       .set_multiline(true)).PartialMatch(sometext);<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>SCANNING TEXT INCREMENTALLY</h1> The &quot;Consume&quot; operation may be useful if you want to repeatedly match regular expressions at the front of a string and skip over them as they match. This requires use of the &quot;StringPiece&quot; type, which represents a sub-range of a real string. Like RE, StringPiece is defined in the pcrecpp namespace.<div style="height: 1.00em;">
&#160;</div>
<br/>
  Example: read lines of the form &quot;var = value&quot; from a string.<br/>
     string contents = ...;                 // Fill string somehow<br/>
     pcrecpp::StringPiece input(contents);  // Wrap in a StringPiece<div style="height: 1.00em;">
&#160;</div>
<br/>
     string var;<br/>
     int value;<br/>
     pcrecpp::RE re(&quot;(\\w+) = (\\d+)\n&quot;);<br/>
     while (re.Consume(&amp;input, &amp;var, &amp;value)) {<br/>
       ...;<br/>
     }<div style="height: 1.00em;">
&#160;</div>
Each successful call to &quot;Consume&quot; will set &quot;var/value&quot;, and also advance &quot;input&quot; so it points past the matched text.<div class="spacer">
</div>
The &quot;FindAndConsume&quot; operation is similar to &quot;Consume&quot; but does not anchor your match at the beginning of the string. For example, you could extract all words from a string by repeatedly calling<div style="height: 1.00em;">
&#160;</div>
<br/>
  pcrecpp::RE(&quot;(\\w+)&quot;).FindAndConsume(&amp;input, &amp;word)</div>
<div class="section">
<h1>PARSING HEX/OCTAL/C-RADIX NUMBERS</h1> By default, if you pass a pointer to a numeric value, the corresponding text is interpreted as a base-10 number. You can instead wrap the pointer with a call to one of the operators Hex(), Octal(), or CRadix() to interpret the text in another base. The CRadix operator interprets C-style &quot;0&quot; (base-8) and &quot;0x&quot; (base-16) prefixes, but defaults to base-10.<div style="height: 1.00em;">
&#160;</div>
<br/>
  Example:<br/>
    int a, b, c, d;<br/>
    pcrecpp::RE re(&quot;(.*) (.*) (.*) (.*)&quot;);<br/>
    re.FullMatch(&quot;100 40 0100 0x40&quot;,<br/>
                 pcrecpp::Octal(&amp;a), pcrecpp::Hex(&amp;b),<br/>
                 pcrecpp::CRadix(&amp;c), pcrecpp::CRadix(&amp;d));<div style="height: 1.00em;">
&#160;</div>
will leave 64 in a, b, c, and d.</div>
<div class="section">
<h1>REPLACING PARTS OF STRINGS</h1> You can replace the first match of &quot;pattern&quot; in &quot;str&quot; with &quot;rewrite&quot;. Within &quot;rewrite&quot;, backslash-escaped digits (\1 to \9) can be used to insert text matching corresponding parenthesized group from the pattern. \0 in &quot;rewrite&quot; refers to the entire matching text. For example:<div style="height: 1.00em;">
&#160;</div>
<br/>
  string s = &quot;yabba dabba doo&quot;;<br/>
  pcrecpp::RE(&quot;b+&quot;).Replace(&quot;d&quot;, &amp;s);<div style="height: 1.00em;">
&#160;</div>
will leave &quot;s&quot; containing &quot;yada dabba doo&quot;. The result is true if the pattern matches and a replacement occurs, false otherwise.<div class="spacer">
</div>
<b>GlobalReplace</b> is like <b>Replace</b> except that it replaces all occurrences of the pattern in the string with the rewrite. Replacements are not subject to re-matching. For example:<div style="height: 1.00em;">
&#160;</div>
<br/>
  string s = &quot;yabba dabba doo&quot;;<br/>
  pcrecpp::RE(&quot;b+&quot;).GlobalReplace(&quot;d&quot;, &amp;s);<div style="height: 1.00em;">
&#160;</div>
will leave &quot;s&quot; containing &quot;yada dada doo&quot;. It returns the number of replacements made.<div class="spacer">
</div>
<b>Extract</b> is like <b>Replace</b>, except that if the pattern matches, &quot;rewrite&quot; is copied into &quot;out&quot; (an additional argument) with substitutions. The non-matching portions of &quot;text&quot; are ignored. Returns true iff a match occurred and the extraction happened successfully;  if no match occurs, the string is left unaffected.</div>
<div class="section">
<h1>AUTHOR</h1><br/>
The C++ wrapper was contributed by Google Inc.<br/>
Copyright (c) 2007 Google Inc.<br/>
</div>
<div class="section">
<h1>REVISION</h1><br/>
Last updated: 08 January 2012<br/>
</div>
<table class="foot">
<tr>
<td class="foot-date">
08 January 2012</td>
<td class="foot-os">
PCRE 8.30</td>
</tr>
</table>
</div>
</body>
</html>

