<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
HTML::Form(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
HTML::Form(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
HTML::Form(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> HTML::Form - Class that represents an HTML form element</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
 use HTML::Form;<br/>
 $form = HTML::Form-&gt;parse($html, $base_uri);<br/>
 $form-&gt;value(query =&gt; &quot;Perl&quot;);<br/>
<br/>
 use LWP::UserAgent;<br/>
 $ua = LWP::UserAgent-&gt;new;<br/>
 $response = $ua-&gt;request($form-&gt;click);<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> Objects of the &quot;HTML::Form&quot; class represents a single HTML &quot;&lt;form&gt; ... &lt;/form&gt;&quot; instance.  A form consists of a sequence of inputs that usually have names, and which can take on various values.  The state of a form can be tweaked and it can then be asked to provide &quot;HTTP::Request&quot; objects that can be passed to the  <i>request()</i> method of &quot;LWP::UserAgent&quot;.<div class="spacer">
</div>
The following methods are available:<dl>
<dt>
@forms = HTML::Form-&gt;parse( $html_document, $base_uri )</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
@forms = HTML::Form-&gt;parse( $html_document, base =&gt; $base_uri, %opt )</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
@forms = HTML::Form-&gt;parse( $response, %opt )</dt>
<dd>
The <i>parse()</i> class method will parse an HTML document and build up &quot;HTML::Form&quot; objects for each &lt;form&gt; element found.  If called in scalar context only returns the first &lt;form&gt;.  Returns an empty list if there are no forms to be found.<div style="height: 1.00em;">
&#160;</div>
The required arguments is the HTML document to parse ($html_document) and the URI used to retrieve the document ($base_uri).  The base URI is needed to resolve relative action URIs.  The provided HTML document should be a Unicode string (or US-ASCII).<div style="height: 1.00em;">
&#160;</div>
By default HTML::Form assumes that the original document was UTF-8 encoded and thus encode forms that don't specify an explict  <i>accept-charset</i> as UTF-8. The charset assumed can be overridden by providing the &quot;charset&quot; option to  <i>parse()</i>.  It's a good idea to be explict about this parameter as well, thus the recommended simplest invocation becomes:<div style="height: 1.00em;">
&#160;</div>
<br/>
    my @forms = HTML::Form-&gt;parse(<br/>
        Encode::decode($encoding, $html_document_bytes),<br/>
        base =&gt; $base_uri,<br/>
        charset =&gt; $encoding,<br/>
    );<br/>
<div style="height: 1.00em;">
&#160;</div>
If the document was retrieved with LWP then the response object provide methods to obtain a proper value for &quot;base&quot; and &quot;charset&quot;:<div style="height: 1.00em;">
&#160;</div>
<br/>
    my $ua = LWP::UserAgent-&gt;new;<br/>
    my $response = $ua-&gt;get(&quot;http://www.example.com/form.html&quot;);<br/>
    my @forms = HTML::Form-&gt;parse($response-&gt;decoded_content,<br/>
        base =&gt; $response-&gt;base,<br/>
        charset =&gt; $response-&gt;content_charset,<br/>
    );<br/>
<div style="height: 1.00em;">
&#160;</div>
In fact, the <i>parse()</i> method can parse from an &quot;HTTP::Response&quot; object directly, so the example above can be more conveniently written as:<div style="height: 1.00em;">
&#160;</div>
<br/>
    my $ua = LWP::UserAgent-&gt;new;<br/>
    my $response = $ua-&gt;get(&quot;http://www.example.com/form.html&quot;);<br/>
    my @forms = HTML::Form-&gt;parse($response);<br/>
<div style="height: 1.00em;">
&#160;</div>
Note that any object that implements a <i>decoded_content()</i>, <i>base()</i> and  <i>content_charset()</i> method with similar behaviour as &quot;HTTP::Response&quot; will do.<div style="height: 1.00em;">
&#160;</div>
Additional options might be passed in to control how the parse method behaves.  The following are all the options currently recognized:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
&quot;base =&gt; $uri&quot;</dt>
<dd>
This is the URI used to retrive the original document.  This option is not optional ;-)</dd>
</dl>
<dl>
<dt>
&quot;charset =&gt; $str&quot;</dt>
<dd>
Specify what charset the original document was encoded in.  This is used as the default for accept_charset.  If not provided this defaults to &quot;UTF-8&quot;.</dd>
</dl>
<dl>
<dt>
&quot;verbose =&gt; $bool&quot;</dt>
<dd>
Warn (print messages to STDERR) about any bad HTML form constructs found. You can trap these with $SIG{__WARN__}.</dd>
</dl>
<dl>
<dt>
&quot;strict =&gt; $bool&quot;</dt>
<dd>
Initialize any form objects with the given strict attribute.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
</div>
<dl>
<dt>
$method = $form-&gt;method</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$form-&gt;method( $new_method )</dt>
<dd>
This method is gets/sets the <i>method</i> name used for the &quot;HTTP::Request&quot; generated.  It is a string like &quot;GET&quot; or &quot;POST&quot;.</dd>
</dl>
<dl>
<dt>
$action = $form-&gt;action</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$form-&gt;action( $new_action )</dt>
<dd>
This method gets/sets the URI which we want to apply the request  <i>method</i> to.</dd>
</dl>
<dl>
<dt>
$enctype = $form-&gt;enctype</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$form-&gt;enctype( $new_enctype )</dt>
<dd>
This method gets/sets the encoding type for the form data.  It is a string like &quot;application/x-www-form-urlencoded&quot; or &quot;multipart/form-data&quot;.</dd>
</dl>
<dl>
<dt>
$accept = $form-&gt;accept_charset</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$form-&gt;accept_charset( $new_accept )</dt>
<dd>
This method gets/sets the list of charset encodings that the server processing the form accepts. Current implementation supports only one-element lists. Default value is &quot;UNKNOWN&quot; which we interpret as a request to use document charset as specified by the 'charset' parameter of the  <i>parse()</i> method.</dd>
</dl>
<dl>
<dt>
$value = $form-&gt;attr( $name )</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$form-&gt;attr( $name, $new_value )</dt>
<dd>
This method give access to the original HTML attributes of the &lt;form&gt; tag. The $name should always be passed in lower case.<div style="height: 1.00em;">
&#160;</div>
Example:<div style="height: 1.00em;">
&#160;</div>
<br/>
   @f = HTML::Form-&gt;parse( $html, $foo );<br/>
   @f = grep $_-&gt;attr(&quot;id&quot;) eq &quot;foo&quot;, @f;<br/>
   die &quot;No form named 'foo' found&quot; unless @f;<br/>
   $foo = shift @f;<br/>
</dd>
</dl>
<dl>
<dt>
$bool = $form-&gt;strict</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$form-&gt;strict( $bool )</dt>
<dd>
Gets/sets the strict attribute of a form.  If the strict is turned on the methods that change values of the form will croak if you try to set illegal values or modify readonly fields.  The default is not to be strict.</dd>
</dl>
<dl>
<dt>
@inputs = $form-&gt;inputs</dt>
<dd>
This method returns the list of inputs in the form.  If called in scalar context it returns the number of inputs contained in the form. See &quot;INPUTS&quot; for what methods are available for the input objects returned.</dd>
</dl>
<dl>
<dt>
$input = $form-&gt;find_input( $selector )</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$input = $form-&gt;find_input( $selector, $type )</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$input = $form-&gt;find_input( $selector, $type, $index )</dt>
<dd>
This method is used to locate specific inputs within the form.  All inputs that match the arguments given are returned.  In scalar context only the first is returned, or &quot;undef&quot; if none match.<div style="height: 1.00em;">
&#160;</div>
If $selector is specified, then the input's name, id, class attribute must match.  A selector prefixed with '#' must match the id attribute of the input. A selector prefixed with '.' matches the class attribute.  A selector prefixed with '^' or with no prefix matches the name attribute.<div style="height: 1.00em;">
&#160;</div>
If $type is specified, then the input must have the specified type. The following type names are used: &quot;text&quot;, &quot;password&quot;, &quot;hidden&quot;, &quot;textarea&quot;, &quot;file&quot;, &quot;image&quot;, &quot;submit&quot;, &quot;radio&quot;, &quot;checkbox&quot; and &quot;option&quot;.<div style="height: 1.00em;">
&#160;</div>
The $index is the sequence number of the input matched where 1 is the first.  If combined with $name and/or $type then it select the  <i>n</i>th input with the given name and/or type.</dd>
</dl>
<dl>
<dt>
$value = $form-&gt;value( $selector )</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$form-&gt;value( $selector, $new_value )</dt>
<dd>
The <i>value()</i> method can be used to get/set the value of some input.  If strict is enabled and no input has the indicated name, then this method will croak.<div style="height: 1.00em;">
&#160;</div>
If multiple inputs have the same name, only the first one will be affected.<div style="height: 1.00em;">
&#160;</div>
The call:<div style="height: 1.00em;">
&#160;</div>
<br/>
    $form-&gt;value('foo')<br/>
<div style="height: 1.00em;">
&#160;</div>
is basically a short-hand for:<div style="height: 1.00em;">
&#160;</div>
<br/>
    $form-&gt;find_input('foo')-&gt;value;<br/>
</dd>
</dl>
<dl>
<dt>
@names = $form-&gt;param</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
@values = $form-&gt;param( $name )</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$form-&gt;param( $name, $value, ... )</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$form-&gt;param( $name, \@values )</dt>
<dd>
Alternative interface to examining and setting the values of the form.<div style="height: 1.00em;">
&#160;</div>
If called without arguments then it returns the names of all the inputs in the form.  The names will not repeat even if multiple inputs have the same name.  In scalar context the number of different names is returned.<div style="height: 1.00em;">
&#160;</div>
If called with a single argument then it returns the value or values of inputs with the given name.  If called in scalar context only the first value is returned.  If no input exists with the given name, then &quot;undef&quot; is returned.<div style="height: 1.00em;">
&#160;</div>
If called with 2 or more arguments then it will set values of the named inputs.  This form will croak if no inputs have the given name or if any of the values provided does not fit.  Values can also be provided as a reference to an array.  This form will allow unsetting all values with the given name as well.<div style="height: 1.00em;">
&#160;</div>
This interface resembles that of the <i>param()</i> function of the CGI module.</dd>
</dl>
<dl>
<dt>
$form-&gt;try_others( \&amp;callback )</dt>
<dd>
This method will iterate over all permutations of unvisited enumerated values (&lt;select&gt;, &lt;radio&gt;, &lt;checkbox&gt;) and invoke the callback for each.  The callback is passed the $form as argument.  The return value from the callback is ignored and the  <i>try_others()</i> method itself does not return anything.</dd>
</dl>
<dl>
<dt>
$request = $form-&gt;make_request</dt>
<dd>
Will return an &quot;HTTP::Request&quot; object that reflects the current setting of the form.  You might want to use the  <i>click()</i> method instead.</dd>
</dl>
<dl>
<dt>
$request = $form-&gt;click</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$request = $form-&gt;click( $selector )</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$request = $form-&gt;click( $x, $y )</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$request = $form-&gt;click( $selector, $x, $y )</dt>
<dd>
Will &quot;click&quot; on the first clickable input (which will be of type &quot;submit&quot; or &quot;image&quot;).  The result of clicking is an &quot;HTTP::Request&quot; object that can then be passed to &quot;LWP::UserAgent&quot; if you want to obtain the server response.<div style="height: 1.00em;">
&#160;</div>
If a $selector is specified, we will click on the first clickable input matching the selector, and the method will croak if no matching clickable input is found.  If $selector is  <i>not</i> specified, then it is ok if the form contains no clickable inputs.  In this case the  <i>click()</i> method returns the same request as the <i>make_request()</i> method would do.  See description of the  <i>find_input()</i> method above for how the $selector is specified.<div style="height: 1.00em;">
&#160;</div>
If there are multiple clickable inputs with the same name, then there is no way to get the  <i>click()</i> method of the &quot;HTML::Form&quot; to click on any but the first.  If you need this you would have to locate the input with  <i>find_input()</i> and invoke the <i>click()</i> method on the given input yourself.<div style="height: 1.00em;">
&#160;</div>
A click coordinate pair can also be provided, but this only makes a difference if you clicked on an image.  The default coordinate is (1,1).  The upper-left corner of the image is (0,0), but some badly coded CGI scripts are known to not recognize this.  Therefore (1,1) was selected as a safer default.</dd>
</dl>
<dl>
<dt>
@kw = $form-&gt;form</dt>
<dd>
Returns the current setting as a sequence of key/value pairs.  Note that keys might be repeated, which means that some values might be lost if the return values are assigned to a hash.<div style="height: 1.00em;">
&#160;</div>
In scalar context this method returns the number of key/value pairs generated.</dd>
</dl>
<dl>
<dt>
$form-&gt;dump</dt>
<dd>
Returns a textual representation of current state of the form.  Mainly useful for debugging.  If called in void context, then the dump is printed on STDERR.</dd>
</dl>
</div>
<div class="section">
<h1>INPUTS</h1> An &quot;HTML::Form&quot; objects contains a sequence of  <i>inputs</i>.  References to the inputs can be obtained with the $form-&gt;inputs or $form-&gt;find_input methods.<div class="spacer">
</div>
Note that there is <i>not</i> a one-to-one correspondence between input  <i>objects</i> and &lt;input&gt; <i>elements</i> in the HTML document.  An input object basically represents a name/value pair, so when multiple HTML elements contribute to the same name/value pair in the submitted form they are combined.<div class="spacer">
</div>
The input elements that are mapped one-to-one are &quot;text&quot;, &quot;textarea&quot;, &quot;password&quot;, &quot;hidden&quot;, &quot;file&quot;, &quot;image&quot;, &quot;submit&quot; and &quot;checkbox&quot;.  For the &quot;radio&quot; and &quot;option&quot; inputs the story is not as simple: All &lt;input type=&quot;radio&quot;&gt; elements with the same name will contribute to the same input radio object.  The number of radio input objects will be the same as the number of distinct names used for the &lt;input type=&quot;radio&quot;&gt; elements.  For a &lt;select&gt; element without the &quot;multiple&quot; attribute there will be one input object of type of &quot;option&quot;.  For a &lt;select multiple&gt; element there will be one input object for each contained &lt;option&gt; element.  Each one of these option objects will have the same name.<div class="spacer">
</div>
The following methods are available for the <i>input</i> objects:<dl>
<dt>
$input-&gt;type</dt>
<dd>
Returns the type of this input.  The type is one of the following strings: &quot;text&quot;, &quot;password&quot;, &quot;hidden&quot;, &quot;textarea&quot;, &quot;file&quot;, &quot;image&quot;, &quot;submit&quot;, &quot;radio&quot;, &quot;checkbox&quot; or &quot;option&quot;.</dd>
</dl>
<dl>
<dt>
$name = $input-&gt;name</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$input-&gt;name( $new_name )</dt>
<dd>
This method can be used to get/set the current name of the input.</dd>
</dl>
<dl>
<dt>
$input-&gt;id</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$input-&gt;class</dt>
<dd>
These methods can be used to get/set the current id or class attribute for the input.</dd>
</dl>
<dl>
<dt>
$input-&gt;selected( $selector )</dt>
<dd>
Returns TRUE if the given selector matched the input.  See the description of the  <i>find_input()</i> method above for a description of the selector syntax.</dd>
</dl>
<dl>
<dt>
$value = $input-&gt;value</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$input-&gt;value( $new_value )</dt>
<dd>
This method can be used to get/set the current value of an input.<div style="height: 1.00em;">
&#160;</div>
If strict is enabled and the input only can take an enumerated list of values, then it is an error to try to set it to something else and the method will croak if you try.<div style="height: 1.00em;">
&#160;</div>
You will also be able to set the value of read-only inputs, but a warning will be generated if running under &quot;perl -w&quot;.</dd>
</dl>
<dl>
<dt>
$input-&gt;possible_values</dt>
<dd>
Returns a list of all values that an input can take.  For inputs that do not have discrete values, this returns an empty list.</dd>
</dl>
<dl>
<dt>
$input-&gt;other_possible_values</dt>
<dd>
Returns a list of all values not tried yet.</dd>
</dl>
<dl>
<dt>
$input-&gt;value_names</dt>
<dd>
For some inputs the values can have names that are different from the values themselves.  The number of names returned by this method will match the number of values reported by $input-&gt;possible_values.<div style="height: 1.00em;">
&#160;</div>
When setting values using the <i>value()</i> method it is also possible to use the value names in place of the value itself.</dd>
</dl>
<dl>
<dt>
$bool = $input-&gt;readonly</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$input-&gt;readonly( $bool )</dt>
<dd>
This method is used to get/set the value of the readonly attribute. You are allowed to modify the value of readonly inputs, but setting the value will generate some noise when warnings are enabled.  Hidden fields always start out readonly.</dd>
</dl>
<dl>
<dt>
$bool = $input-&gt;disabled</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$input-&gt;disabled( $bool )</dt>
<dd>
This method is used to get/set the value of the disabled attribute. Disabled inputs do not contribute any key/value pairs for the form value.</dd>
</dl>
<dl>
<dt>
$input-&gt;form_name_value</dt>
<dd>
Returns a (possible empty) list of key/value pairs that should be incorporated in the form value from this input.</dd>
</dl>
<dl>
<dt>
$input-&gt;check</dt>
<dd>
Some input types represent toggles that can be turned on/off.  This includes &quot;checkbox&quot; and &quot;option&quot; inputs.  Calling this method turns this input on without having to know the value name.  If the input is already on, then nothing happens.<div style="height: 1.00em;">
&#160;</div>
This has the same effect as:<div style="height: 1.00em;">
&#160;</div>
<br/>
    $input-&gt;value($input-&gt;possible_values[1]);<br/>
<div style="height: 1.00em;">
&#160;</div>
The input can be turned off with:<div style="height: 1.00em;">
&#160;</div>
<br/>
    $input-&gt;value(undef);<br/>
</dd>
</dl>
<dl>
<dt>
$input-&gt;click($form, $x, $y)</dt>
<dd>
Some input types (currently &quot;submit&quot; buttons and &quot;images&quot;) can be clicked to submit the form.  The  <i>click()</i> method returns the corresponding &quot;HTTP::Request&quot; object.</dd>
</dl>
<div class="spacer">
</div>
If the input is of type &quot;file&quot;, then it has these additional methods:<dl>
<dt>
$input-&gt;file</dt>
<dd>
This is just an alias for the <i>value()</i> method.  It sets the filename to read data from.<div style="height: 1.00em;">
&#160;</div>
For security reasons this field will never be initialized from the parsing of a form.  This prevents the server from triggering stealth uploads of arbitrary files from the client machine.</dd>
</dl>
<dl>
<dt>
$filename = $input-&gt;filename</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$input-&gt;filename( $new_filename )</dt>
<dd>
This get/sets the filename reported to the server during file upload. This attribute defaults to the value reported by the  <i>file()</i> method.</dd>
</dl>
<dl>
<dt>
$content = $input-&gt;content</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$input-&gt;content( $new_content )</dt>
<dd>
This get/sets the file content provided to the server during file upload.  This method can be used if you do not want the content to be read from an actual file.</dd>
</dl>
<dl>
<dt>
@headers = $input-&gt;headers</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
input-&gt;headers($key =&gt; $value, .... )</dt>
<dd>
This get/set additional header fields describing the file uploaded. This can for instance be used to set the &quot;Content-Type&quot; reported for the file.</dd>
</dl>
</div>
<div class="section">
<h1>SEE ALSO</h1> LWP, LWP::UserAgent, HTML::Parser</div>
<div class="section">
<h1>COPYRIGHT</h1> Copyright 1998-2008 Gisle Aas.<div class="spacer">
</div>
This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-02-27</td>
<td class="foot-os">
perl v5.12.3</td>
</tr>
</table>
</div>
</body>
</html>

