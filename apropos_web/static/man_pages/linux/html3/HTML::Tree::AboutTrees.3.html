<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
HTML::Tree::AboutTrees(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
HTML::Tree::AboutTrees(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
HTML::Tree::AboutTrees(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> HTML::Tree::AboutTrees -- article on tree-shaped data structures in Perl</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
  # This an article, not a module.<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> The following article by Sean M. Burke first appeared in  <i>The Perl</i>  <i>Journal</i> #18 and is copyright 2000 The Perl Journal. It appears courtesy of Jon Orwant and The Perl Journal.  This document may be distributed under the same terms as Perl itself.</div>
<div class="section">
<h1>Trees</h1> -- Sean M. Burke<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
&quot;AaaAAAaauugh!  Watch out for that tree!&quot;<br/>
  -- <i>George of the Jungle theme</i></div>
<div class="spacer">
</div>
Perl's facility with references, combined with its automatic management of memory allocation, makes it straightforward to write programs that store data in structures of arbitrary form and complexity.<div class="spacer">
</div>
But I've noticed that many programmers, especially those who started out with more restrictive languages, seem at home with complex but uniform data structures -- N-dimensional arrays, or more struct-like things like hashes-of-arrays(-of-hashes(-of-hashes), etc.) -- but they're often uneasy with building more freeform, less tabular structures, like tree-shaped data structures.<div class="spacer">
</div>
But trees are easy to build and manage in Perl, as I'll demonstrate by showing off how the HTML::Element class manages elements in an HTML document tree, and by walking you through a from-scratch implementation of game trees.  But first we need to nail down what we mean by a &quot;tree&quot;.<div class="subsection">
<h2>Socratic Dialogues: &quot;What is a Tree?&quot;</h2> My first brush with tree-shaped structures was in linguistics classes, where tree diagrams are used to describe the syntax underlying natural language sentences.  After learning my way around  <i>those</i> trees, I started to wonder -- are what I'm used to calling &quot;trees&quot; the same as what programmers call &quot;trees&quot;?  So I asked lots of helpful and patient programmers how they would define a tree.  Many replied with a answer in jargon that they could not really explain (understandable, since explaining things, especially defining things, is harder than people think):<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
-- So what <i>is</i> a &quot;tree&quot;, a tree-shaped data structure?<div style="height: 1.00em;">
&#160;</div>
-- A tree is a special case of an acyclic directed graph!<div style="height: 1.00em;">
&#160;</div>
-- What's a &quot;graph&quot;?<div style="height: 1.00em;">
&#160;</div>
-- Um... lines... and... you draw it... with... arcs! nodes!  um...</div>
<div class="spacer">
</div>
The most helpful were folks who couldn't explain directly, but with whom I could get into a rather Socratic dialog (where  <i>I</i> asked the half-dim half-earnest questions), often with much doodling of illustrations...<div class="spacer">
</div>
Question: so what's a tree?<div class="spacer">
</div>
Answer: A tree is a collection of nodes that are linked together in a, well, tree-like way!  Like this  <i>[drawing on a napkin]:</i><div class="spacer">
</div>
<br/>
     A<br/>
    / \<br/>
   B   C<br/>
     / | \<br/>
    D  E  F<br/>
<div class="spacer">
</div>
Q: So what do these letters represent?<div class="spacer">
</div>
A: Each is a different node, a bunch of data.  Maybe C is a bunch of data that stores a number, maybe a hash table, maybe nothing at all besides the fact that it links to D, E, and F (which are other nodes).<div class="spacer">
</div>
Q: So what're the lines between the nodes?<div class="spacer">
</div>
A: Links.  Also called &quot;arcs&quot;.  They just symbolize the fact that each node holds a list of nodes it links to.<div class="spacer">
</div>
Q: So what if I draw nodes and links, like this...<div class="spacer">
</div>
<br/>
     B -- E<br/>
    / \  / \<br/>
   A   C    <br/>
    \ /<br/>
     E<br/>
<div class="spacer">
</div>
Is that still a tree?<div class="spacer">
</div>
A: No, not at all.  There's a lot of un-treelike things about that. First off, E has a link coming off of it going into nowhere.  You can't have a link to nothing -- you can only link to another node.  Second off, I don't know what that sideways link between B and E means...<div class="spacer">
</div>
Q: Okay, let's work our way up from something simpler.  Is this a tree...?<div class="spacer">
</div>
<br/>
    A<br/>
<div class="spacer">
</div>
A: Yes, I suppose.  It's a tree of just one node.<div class="spacer">
</div>
Q: And how about...<div class="spacer">
</div>
<br/>
   A<br/>
   <br/>
   B<br/>
<div class="spacer">
</div>
A: No, you can't just have nodes floating there, unattached.<div class="spacer">
</div>
Q: Okay, I'll link A and B.  How's this?<div class="spacer">
</div>
<br/>
   A<br/>
   |<br/>
   B<br/>
<div class="spacer">
</div>
A: Yup, that's a tree.  There's a node A, and a node B, and they're linked.<div class="spacer">
</div>
Q: How is that tree any different from this one...?<div class="spacer">
</div>
<br/>
   B<br/>
   |<br/>
   A<br/>
<div class="spacer">
</div>
A: Well, in both cases A and B are linked.  But it's in a different direction.<div class="spacer">
</div>
Q: Direction?  What does the direction mean?<div class="spacer">
</div>
A: Well, it depends what the tree represents.  If it represents a categorization, like this:<div class="spacer">
</div>
<br/>
          citrus<br/>
       /    |    \<br/>
   orange  lemon  kumquat ...<br/>
<div class="spacer">
</div>
then you mean to say that oranges, lemons, kumquats, etc., are a kind of citrus.  But if you drew it upside down, you'd be saying, falsely, that citrus is a kind of kumquat, a kind of lemon, and a kind of orange. If the tree represented cause-and-effect (or at least what situations could follow others), or represented what's a part of what, you wouldn't want to get those backwards, either.  So with the nodes you draw together on paper, one has to be over the other, so you can tell which way the relationship in the tree works.<div class="spacer">
</div>
Q:  So are these two trees the same?<div class="spacer">
</div>
<br/>
     A          A<br/>
    / \        / \<br/>
   B   C      B   \<br/>
                   C<br/>
<div class="spacer">
</div>
A: Yes, although by convention we often try to line up things in the same generation, like it is in the diagram on the left.<div class="spacer">
</div>
Q: &quot;generation&quot;?  This is a family tree?<div class="spacer">
</div>
A: No, not unless it's a family tree for just yeast cells or something else that reproduces asexually. But for sake of having lots of terms to use, we just pretend that links in the tree represent the &quot;is a child of&quot; relationship, instead of &quot;is a kind of&quot; or &quot;is a part of&quot;, or &quot;could result from&quot;, or whatever the real relationship is.  So we get to borrow a lot of kinship words for describing trees -- B and C are &quot;children&quot; (or &quot;daughters&quot;) of A; A is the &quot;parent&quot; (or &quot;mother&quot;) of B and C.  Node C is a &quot;sibling&quot; (or &quot;sister&quot;) of node C; and so on, with terms like &quot;descendants&quot; (a node's children, children's children, etc.), and &quot;generation&quot; (all the nodes at the same &quot;level&quot; in the tree, i.e., are either all grandchildren of the top node, or all great-grand-children, etc.), and &quot;lineage&quot; or &quot;ancestors&quot; (parents, and parent's parents, etc., all the way to the topmost node).<div class="spacer">
</div>
So then we get to express rules in terms like &quot;<b>A node cannot have more</b>  <b>than one parent</b>&quot;, which means that this is not a valid tree:<div class="spacer">
</div>
<br/>
    A<br/>
   / \<br/>
  B   C<br/>
   \ /<br/>
    E<br/>
<div class="spacer">
</div>
And: &quot;<b>A node can't be its own parent</b>&quot;, which excludes this looped-up connection:<div class="spacer">
</div>
<br/>
    /\<br/>
   A  |<br/>
    \/<br/>
<div class="spacer">
</div>
Or, put more generally: &quot;<b>A node can't be its own ancestor</b>&quot;, which excludes the above loop, as well as the one here:<div class="spacer">
</div>
<br/>
      /\<br/>
     Z  |<br/>
    /   |<br/>
   A    |<br/>
  / \   |<br/>
 B   C  |<br/>
      \/<br/>
<div class="spacer">
</div>
That tree is excluded because A is a child of Z, and Z is a child of C, and C is a child of A, which means A is its own great-grandparent.  So this whole network can't be a tree, because it breaks the sort of meta-rule:  <b>once any node in the supposed tree breaks the rules for</b>  <b>trees, you don't have a tree anymore.</b><div class="spacer">
</div>
Q: Okay, now, are these two trees the same?<div class="spacer">
</div>
<br/>
     A         A<br/>
   / | \     / | \<br/>
  B  C  D   D  C  B<br/>
<div class="spacer">
</div>
A: It depends whether you're basing your concept of trees on each node having a set (unordered list) of children, or an (ordered) list of children.  It's a question of whether ordering is important for what you're doing.  With my diagram of citrus types, ordering isn't important, so these tree diagrams express the same thing:<div class="spacer">
</div>
<br/>
          citrus<br/>
       /    |    \<br/>
   orange  lemon  kumquat<br/>
<br/>
           citrus<br/>
       /     |    \<br/>
   kumquat  orange  lemon<br/>
<div class="spacer">
</div>
because it doesn't make sense to say that oranges are &quot;before&quot; or &quot;after&quot; kumquats in the whole botanical scheme of things.  (Unless, of course, you  <i>are</i> using ordering to mean something, like a degree of genetic similarity.)<div class="spacer">
</div>
But consider a tree that's a diagram of what steps are comprised in an activity, to some degree of specificity:<div class="spacer">
</div>
<br/>
           make tea<br/>
         /    |     \<br/>
   pour     infuse   serve<br/>
 hot water    / \<br/>
in cup/pot  /     \<br/>
           add     let<br/>
           tea     sit<br/>
          leaves<br/>
<div class="spacer">
</div>
This means that making tea consists of putting hot water in a cup or put, infusing it (which itself consists of adding tea leaves and letting it sit), then serving it --  <i>in that order</i>.  If you serve an empty dry pot (sipping from empty cups, etc.), let it sit, add tea leaves, and pour in hot water, then what you're doing is performance art, not tea preparation:<div class="spacer">
</div>
<br/>
          perfomance<br/>
            art<br/>
        /    |     \<br/>
   serve   infuse    pour<br/>
            / \       hot water<br/>
          /     \      in cup/pot<br/>
         let     add<br/>
         sit     tea<br/>
                leaves<br/>
<div class="spacer">
</div>
Except for my having renamed the root, this tree is the same as the making-tea tree as far as what's under what, but it differs in order, and what the tree means makes the order important.<div class="spacer">
</div>
Q: Wait -- &quot;root&quot;?  What's a root?<div class="spacer">
</div>
A: Besides kinship terms like &quot;mother&quot; and &quot;daughter&quot;, the jargon for tree parts also has terms from real-life tree parts:  the part that everything else grows from is called the root; and nodes that don't have nodes attached to them (i.e., childless nodes) are called &quot;leaves&quot;.<div class="spacer">
</div>
Q: But you've been drawing all your trees with the root at the top and leaves at the bottom.<div class="spacer">
</div>
A: Yes, but for some reason, that's the way everyone seems to think of trees.  They can draw trees as above; or they can draw them sort of sideways with indenting representing what nodes are children of what:<div class="spacer">
</div>
<br/>
  * make tea<br/>
     * pour hot water in cup/pot<br/>
     * infuse<br/>
        * add tea leaves<br/>
        * let sit<br/>
     * serve<br/>
<div class="spacer">
</div>
...but folks almost never seem to draw trees with the root at the bottom.  So imagine it's based on spider plant in a hanging pot. Unfortunately, spider plants  <i>aren't</i> botanically trees, they're plants; but &quot;spider plant diagram&quot; is rather a mouthful, so let's just call them trees.</div>
<div class="subsection">
<h2>Trees Defined Formally</h2> In time, I digested all these assorted facts about programmers' ideas of trees (which turned out to be just a more general case of linguistic ideas of trees) into a single rule:<div class="spacer">
</div>
* A node is an item that contains (&quot;is over&quot;, &quot;is parent of&quot;, etc.) zero or more other nodes.<div class="spacer">
</div>
From this you can build up formal definitions for useful terms, like so:<div class="spacer">
</div>
* A node's <b>descendants</b> are defined as all its children, and all their children, and so on.  Or, stated recursively: a node's descendants are all its children, and all its children's descendants. (And if it has no children, it has no descendants.)<div class="spacer">
</div>
* A node's <b>ancestors</b> consist of its parent, and its parent's parent, etc, up to the root.  Or, recursively: a node's ancestors consist of its parent and its parent's ancestors.  (If it has no parent, it has no ancestors.)<div class="spacer">
</div>
* A <b>tree</b> is a root node and all the root's descendants.<div class="spacer">
</div>
And you can add a proviso or two to clarify exactly what I impute to the word &quot;other&quot; in &quot;other nodes&quot;:<div class="spacer">
</div>
* A node cannot contain itself, or contain any node that contains it, etc.  Looking at it the other way: a node cannot be its own parent or ancestor.<div class="spacer">
</div>
* A node can be root (i.e., no other node contains it) or can be contained by only one parent; no node can be the child of two or more parents.<div class="spacer">
</div>
Add to this the idea that children are sometimes ordered, and sometimes not, and that's about all you need to know about defining what a tree is.  From there it's a matter of using them.</div>
<div class="subsection">
<h2>Markup Language Trees: HTML-Tree</h2> While not  <i>all</i> markup languages are inherently tree-like, the best-known family of markup languages, HTML, SGML, and XML, are about as tree-like as you can get.  In these languages, a document consists of elements and character data in a tree structure where there is one root element, and elements can contain either other elements, or character data.<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
Footnote: For sake of simplicity, I'm glossing over comments (&lt;!-- ... --&gt;), processing instructions (&lt;?xml version='1.0'&gt;), and declarations (&lt;!ELEMENT ...&gt;, &lt;!DOCTYPE ...&gt;). And I'm not bothering to distinguish entity references (&amp;lt;, &amp;#64;) or CDATA sections (&lt;![CDATA[ ...]]&gt;) from normal text.</div>
<div class="spacer">
</div>
For example, consider this HTML document:<div class="spacer">
</div>
<br/>
  &lt;html lang=&quot;en-US&quot;&gt;<br/>
    &lt;head&gt;<br/>
      &lt;title&gt;<br/>
        Blank Document!<br/>
      &lt;/title&gt;<br/>
    &lt;/head&gt;<br/>
    &lt;body bgcolor=&quot;#d010ff&quot;&gt;<br/>
      I've got<br/>
      &lt;em&gt;<br/>
        something to saaaaay<br/>
      &lt;/em&gt;<br/>
      !<br/>
    &lt;/body&gt;<br/>
  &lt;/html&gt;<br/>
<div class="spacer">
</div>
I've indented this to point out what nodes (elements or text items) are children of what, with each node on a line of its own.<div class="spacer">
</div>
The HTML::TreeBuilder module (in the CPAN distribution HTML-Tree) does the work of taking HTML source and building in memory the tree that the document source represents.<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
Footnote: it requires the HTML::Parser module, which tokenizes the source -- i.e., identifies each tag, bit of text, comment, etc.</div>
<div class="spacer">
</div>
The trees structures that it builds represent bits of text with normal Perl scalar string values; but elements are represented with objects -- that is, chunks of data that belong to a class (in this case, HTML::Element), a class that provides methods (routines) for accessing the pieces of data in each element, and otherwise doing things with elements.  (See my article in TPJ#17 for a quick explanation of objects, the POD document &quot;perltoot&quot; for a longer explanation, or Damian Conway's excellent book  <i>Object-Oriented Perl</i> for the full story.)<div class="spacer">
</div>
Each HTML::Element object contains a number of pieces of data:<div class="spacer">
</div>
* its element name (&quot;html&quot;, &quot;h1&quot;, etc., accessed as $element-&gt;tag)<div class="spacer">
</div>
* a list of elements (or text segments) that it contains, if any (accessed as $element-&gt;content_list or $element-&gt;content, depending on whether you want a list, or an arrayref)<div class="spacer">
</div>
* what element, if any, contains it (accessed as $element-&gt;parent)<div class="spacer">
</div>
* and any SGML attributes that the element has, such as &quot;lang=&quot;en-US&quot;&quot;, &quot;align=&quot;center&quot;&quot;, etc. (accessed as $element-&gt;attr('lang'), $element-&gt;attr('center'), etc.)<div class="spacer">
</div>
So, for example, when HTML::TreeBuilder builds the tree for the above HTML document source, the object for the &quot;body&quot; element has these pieces of data:<div class="spacer">
</div>
<br/>
 * element name: &quot;body&quot;<br/>
 * nodes it contains:<br/>
    the string &quot;I've got &quot;<br/>
    the object for the &quot;em&quot; element<br/>
    the string &quot;!&quot;<br/>
 * its parent:<br/>
    the object for the &quot;html&quot; element<br/>
 * bgcolor: &quot;#d010ff&quot;<br/>
<div class="spacer">
</div>
Now, once you have this tree of objects, almost anything you'd want to do with it starts with searching the tree for some bit of information in some element.<div class="spacer">
</div>
Accessing a piece of information in, say, a hash of hashes of hashes, is straightforward:<div class="spacer">
</div>
<br/>
  $password{'sean'}{'sburke1'}{'hpux'}<br/>
<div class="spacer">
</div>
because you know that all data points in that structure are accessible with that syntax, but with just different keys.  Now, the &quot;em&quot; element in the above HTML tree does happen to be accessible as the root's child #1's child #1:<div class="spacer">
</div>
<br/>
  $root-&gt;content-&gt;[1]-&gt;content-&gt;[1]<br/>
<div class="spacer">
</div>
But with trees, you typically don't know the exact location (via indexes) of the data you're looking for.  Instead, finding what you want will typically involve searching through the tree, seeing if every node is the kind you want.  Searching the whole tree is simple enough -- look at a given node, and if it's not what you want, look at its children, and so on.  HTML-Tree provides several methods that do this for you, such as &quot;find_by_tag_name&quot;, which returns the elements (or the first element, if called in scalar context) under a given node (typically the root) whose tag name is whatever you specify.<div class="spacer">
</div>
For example, that &quot;em&quot; node can be found as:<div class="spacer">
</div>
<br/>
  my $that_em = $root-&gt;find_by_tag_name('em');<br/>
<div class="spacer">
</div>
or as:<div class="spacer">
</div>
<br/>
  @ems = $root-&gt;find_by_tag_name('em');<br/>
   # will only have one element for this particular tree<br/>
<div class="spacer">
</div>
Now, given an HTML document of whatever structure and complexity, if you wanted to do something like change every<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
&lt;em&gt;<i>stuff</i>&lt;/em&gt;</div>
<div class="spacer">
</div>
to<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
&lt;em class=&quot;funky&quot;&gt;  <b>&lt;b&gt;[-&lt;/b&gt;</b>  <i>stuff</i>  <b>&lt;b&gt;-]&lt;/b&gt;</b> &lt;/em&gt;</div>
<div class="spacer">
</div>
the first step is to frame this operation in terms of what you're doing to the tree.  You're changing this:<div class="spacer">
</div>
<br/>
      em<br/>
       |<br/>
      ...<br/>
<div class="spacer">
</div>
to this:<div class="spacer">
</div>
<br/>
      em<br/>
    /  |  \  <br/>
   b  ...   b<br/>
   |        |<br/>
  &quot;[-&quot;     &quot;-]&quot;<br/>
<div class="spacer">
</div>
In other words, you're finding all elements whose tag name is &quot;em&quot;, setting its class attribute to &quot;funky&quot;, and adding one child to the start of its content list -- a new &quot;b&quot; element whose content is the text string &quot;[-&quot; -- and one to the end of its content list -- a new &quot;b&quot; element whose content is the text string &quot;-]&quot;.<div class="spacer">
</div>
Once you've got it in these terms, it's just a matter of running to the HTML::Element documentation, and coding this up with calls to the appropriate methods, like so:<div class="spacer">
</div>
<br/>
  use HTML::Element 1.53;<br/>
  use HTML::TreeBuilder 2.96;<br/>
  # Build the tree by parsing the document<br/>
  my $root = HTML::TreeBuilder-&gt;new;<br/>
  $root-&gt;parse_file('whatever.html'); # source file<br/>
  <br/>
  # Now make new nodes where needed<br/>
  foreach my $em ($root-&gt;find_by_tag_name('em')) {<br/>
    $em-&gt;attr('class', 'funky'); # Set that attribute<br/>
    <br/>
    # Make the two new B nodes<br/>
    my $new1 = HTML::Element-&gt;new('b');<br/>
    my $new2 = HTML::Element-&gt;new('b');<br/>
    # Give them content (they have none at first)<br/>
    $new1-&gt;push_content('[-');<br/>
    $new2-&gt;push_content('-]');<br/>
    <br/>
    # And put 'em in place!<br/>
    $em-&gt;unshift_content($new1);<br/>
    $em-&gt;push_content($new2);<br/>
  }<br/>
  print<br/>
   &quot;&lt;!-- Looky see what I did! --&gt;\n&quot;,<br/>
   $root-&gt;as_HTML(), &quot;\n&quot;;<br/>
<div class="spacer">
</div>
The class HTML::Element provides just about every method I can image you needing, for manipulating trees made of HTML::Element objects.  (And what it doesn't directly provide, it will give you the components to build it with.)</div>
<div class="subsection">
<h2>Building Your Own Trees</h2> Theoretically, any tree is pretty much like any other tree, so you could use HTML::Element for anything you'd ever want to do with tree-arranged objects.  However, as its name implies, HTML::Element is basically  <i>for</i> HTML elements; it has lots of features that make sense only for HTML elements (like the idea that every element must have a tag-name). And it lacks some features that might be useful for general applications -- such as any sort of checking to make sure that you're not trying to arrange objects in a non-treelike way.  For a general-purpose tree class that does have such features, you can use Tree::DAG_Node, also available from CPAN.<div class="spacer">
</div>
However, if your task is simple enough, you might find it overkill to bother using Tree::DAG_Node.  And, in any case, I find that the best way to learn how something works is to implement it (or something like it, but simpler) yourself.  So I'll here discuss how you'd implement a tree structure,  <i>without</i> using any of the existing classes for tree nodes.</div>
<div class="subsection">
<h2>Implementation: Game Trees for Alak</h2> Suppose that the task at hand is to write a program that can play against a human opponent at a strategic board game (as opposed to a board game where there's an element of chance).  For most such games, a &quot;game tree&quot; is an essential part of the program (as I will argue, below), and this will be our test case for implementing a tree structure from scratch.<div class="spacer">
</div>
For sake of simplicity, our game is not chess or backgammon, but instead a much simpler game called Alak.  Alak was invented by the mathematician A. K.  Dewdney, and described in his 1984 book  <i>Planiverse</i>. The rules of Alak are simple:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
Footnote: Actually, I'm describing only my interpretation of the rules Dewdney describes in  <i>Planiverse</i>.  Many other interpretations are possible.</div>
<div class="spacer">
</div>
* Alak is a two-player game played on a one-dimensional board with eleven slots on it.  Each slot can hold at most one piece at a time. There's two kinds of pieces, which I represent here as &quot;x&quot; and &quot;o&quot; -- x's belong to one player (called X), o's to the other (called O).<div class="spacer">
</div>
* The initial configuration of the board is:<div class="spacer">
</div>
<br/>
   xxxx___oooo<br/>
<div class="spacer">
</div>
For sake of the article, the slots are numbered from 1 (on the left) to 11 (on the right), and X always has the first move.<div class="spacer">
</div>
* The players take turns moving.  At each turn, each player can move only one piece, once.  (This unlike checkers, where you move one piece per move but get to keep moving it if you jump an your opponent's piece.) A player cannot pass up on his turn.  A player can move any one of his pieces to the next unoccupied slot to its right or left, which may involve jumping over occupied slots.  A player cannot move a piece off the side of the board.<div class="spacer">
</div>
* If a move creates a pattern where the opponent's pieces are surrounded, on both sides, by two pieces of the mover's color (with no intervening unoccupied blank slot), then those surrounded pieces are removed from the board.<div class="spacer">
</div>
* The goal of the game is to remove all of your opponent's pieces, at which point the game ends.  Removing all-but-one ends the game as well, since the opponent can't surround you with one piece, and so will always lose within a few moves anyway.<div class="spacer">
</div>
Consider, then, this rather short game where X starts:<div class="spacer">
</div>
<br/>
  xxxx___oooo<br/>
    ^         Move 1: X moves from 3 (shown with caret) to 5<br/>
               (Note that any of X's pieces could move, but<br/>
               that the only place they could move to is 5.)<br/>
  xx_xx__oooo<br/>
          ^   Move 2: O moves from 9 to 7.<br/>
  xx_xx_oo_oo<br/>
     ^        Move 3: X moves from 4 to 6.<br/>
  xx__xxoo_oo<br/>
           ^  Move 4: O (stupidly) moves from 10 to 9.<br/>
  xx__xxooo_o<br/>
      ^       Move 5: X moves from 5 to 10, making the board<br/>
              &quot;xx___xoooxo&quot;.  The three o's that X just<br/>
              surrounded are removed. <br/>
  xx___x___xo<br/>
              O has only one piece, so has lost.<br/>
<div class="spacer">
</div>
Now, move 4 could have gone quite the other way:<div class="spacer">
</div>
<br/>
  xx__xxoo_oo<br/>
              Move 4: O moves from 8 to 4, making the board <br/>
              &quot;xx_oxxo__oo&quot;.  The surrounded x's are removed.<br/>
  xx_o__o__oo<br/>
  ^           Move 5: X moves from 1 to 2.<br/>
  _xxo__o__oo<br/>
        ^     Move 6: O moves from 7 to 6.<br/>
  _xxo_o___oo<br/>
   ^          Move 7: X moves from 2 to 5, removing the o at 4.<br/>
  __x_xo___oo<br/>
              ...and so on.<br/>
<div class="spacer">
</div>
To teach a computer program to play Alak (as player X, say), it needs to be able to look at the configuration of the board, figure out what moves it can make, and weigh the benefit or costs, immediate or eventual, of those moves.<div class="spacer">
</div>
So consider the board from just before move 3, and figure all the possible moves X could make.  X has pieces in slots 1, 2, 4, and 5.  The leftmost two x's (at 1 and 2) are up against the end of the board, so they can move only right.  The other two x's (at 4 and 5) can move either right or left:<div class="spacer">
</div>
<br/>
  Starting board: xx_xx_oo_oo<br/>
   moving 1 to 3 gives _xxxx_oo_oo<br/>
   moving 2 to 3 gives x_xxx_oo_oo<br/>
   moving 4 to 3 gives xxx_x_oo_oo<br/>
   moving 5 to 3 gives xxxx__oo_oo<br/>
   moving 4 to 6 gives xx__xxoo_oo<br/>
   moving 5 to 6 gives xx_x_xoo_oo<br/>
<div class="spacer">
</div>
For the computer to decide which of these is the best move to make, it needs to quantify the benefit of these moves as a number -- call that the &quot;payoff&quot;.  The payoff of a move can be figured as just the number of x pieces removed by the most recent move, minus the number of o pieces removed by the most recent move.  (It so happens that the rules of the game mean that no move can delete both o's and x's, but the formula still applies.)  Since none of these moves removed any pieces, all these moves have the same immediate payoff: 0.<div class="spacer">
</div>
Now, we could race ahead and write an Alak-playing program that could use the immediate payoff to decide which is the best move to make. And when there's more than one best move (as here, where all the moves are equally good), it could choose randomly between the good alternatives.  This strategy is simple to implement; but it makes for a very dumb program.  Consider what O's response to each of the potential moves (above) could be.  Nothing immediately suggests itself for the first four possibilities (X having moved something to position 3), but either of the last two (illustrated below) are pretty perilous, because in either case O has the obvious option (which he would be foolish to pass up) of removing x's from the board:<div class="spacer">
</div>
<br/>
   xx_xx_oo_oo<br/>
      ^        X moves 4 to 6.<br/>
   xx__xxoo_oo<br/>
          ^    O moves 8 to 4, giving &quot;xx_oxxo__oo&quot;.  The two<br/>
               surrounded x's are removed.<br/>
   xx_o__o__oo<br/>
<div class="spacer">
</div>
or<div class="spacer">
</div>
<br/>
   xx_xx_oo_oo<br/>
       ^       X moves 5 to 6.<br/>
   xx_x_xoo_oo<br/>
          ^    O moves 8 to 5, giving &quot;xx_xoxo__oo&quot;.  The one<br/>
               surrounded x is removed.<br/>
   xx_xo_o__oo<br/>
<div class="spacer">
</div>
Both contingencies are quite bad for X -- but this is not captured by the fact that they start out with X thinking his move will be harmless, having a payoff of zero.<div class="spacer">
</div>
So what's needed is for X to think <i>more</i> than one step ahead -- to consider not merely what it can do in this move, and what the payoff is, but to consider what O might do in response, and the payoff of those potential moves, and so on with X's possible responses to those cases could be.  All these possibilities form a game tree -- a tree where each node is a board, and its children are successors of that node -- i.e., the boards that could result from every move possible, given the parent's board.<div class="spacer">
</div>
But how to represent the tree, and how to represent the nodes?<div class="spacer">
</div>
Well, consider that a node holds several pieces of data:<div class="spacer">
</div>
1) the configuration of the board, which, being nice and simple and one-dimensional, can be stored as just a string, like &quot;xx_xx_oo_oo&quot;.<div class="spacer">
</div>
2) whose turn it is, X or O.  (Or: who moved last, from which we can figure whose turn it is).<div class="spacer">
</div>
3) the successors (child nodes).<div class="spacer">
</div>
4) the immediate payoff of having moved to this board position from its predecessor (parent node).<div class="spacer">
</div>
5) and what move gets us from our predecessor node to here.  (Granted, knowing the board configuration before and after the move, it's easy to figure out the move; but it's easier still to store it as one is figuring out a node's successors.)<div class="spacer">
</div>
6) whatever else we might want to add later.<div class="spacer">
</div>
These could be stored equally well in an array or in a hash, but it's my experience that hashes are best for cases where you have more than just two or three bits of data, or especially when you might need to add new bits of data.  Moreover, hash key names are mnemonic -- $node-&gt;{'last_move_payoff'} is plain as day, whereas it's not so easy having to remember with an array that $node-&gt;[3] is where you decided to keep the payoff.<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
Footnote: Of course, there are ways around that problem: just swear you'll never use a real numeric index to access data in the array, and instead use constants with mnemonic names:<div style="height: 1.00em;">
&#160;</div>
<br/>
  use strict;<br/>
  use constant idx_PAYOFF =&gt; 3;<br/>
  ...<br/>
  $n-&gt;[idx_PAYOFF]<br/>
<div style="height: 1.00em;">
&#160;</div>
Or use a pseudohash.  But I prefer to keep it simple, and use a hash.<div style="height: 1.00em;">
&#160;</div>
These are, incidentally, the same arguments that people weigh when trying to decide whether their object-oriented modules should be based on blessed hashes, blessed arrays, or what. Essentially the only difference here is that we're not blessing our nodes or talking in terms of classes and methods.<div style="height: 1.00em;">
&#160;</div>
[end footnote]</div>
<div class="spacer">
</div>
So, we might as well represent nodes like so:<div class="spacer">
</div>
<br/>
  $node = { # hashref<br/>
     'board'          =&gt; ...board string, e.g., &quot;xx_x_xoo_oo&quot;<br/>
     <br/>
     'last_move_payoff' =&gt; ...payoff of the move<br/>
                            that got us here.<br/>
                            <br/>
     'last_move_from' =&gt;  ...the start...<br/>
     'last_move_to'   =&gt;  ...and end point of the move<br/>
                              that got us here.  E.g., 5 and 6,<br/>
                              representing a move from 5 to 6.<br/>
<br/>
     'whose_turn'     =&gt; ...whose move it then becomes.<br/>
                           just an 'x' or 'o'.<br/>
                              <br/>
     'successors' =&gt; ...the successors<br/>
  };<br/>
<div class="spacer">
</div>
Note that we could have a field called something like 'last_move_who' to denote who last moved, but since turns in Alak always alternate (and no-one can pass), storing whose move it is now  <i>and</i> who last moved is redundant -- if X last moved, it's O turn now, and vice versa. I chose to have a 'whose_turn' field instead of a 'last_move_who', but it doesn't really matter.  Either way, we'll end up inferring one from the other at several points in the program.<div class="spacer">
</div>
When we want to store the successors of a node, should we use an array or a hash?  On the one hand, the successors to $node aren't essentially ordered, so there's no reason to use an array per se; on the other hand, if we used a hash, with successor nodes as values, we don't have anything particularly meaningful to use as keys.  (And we can't use the successors themselves as keys, since the nodes are referred to by hash references, and you can't use a reference as a hash key.)  Given no particularly compelling reason to do otherwise, I choose to just use an array to store all a node's successors, although the order is never actually used for anything:<div class="spacer">
</div>
<br/>
  $node = {<br/>
    ...<br/>
    'successors' =&gt; [ ...nodes... ],<br/>
    ...<br/>
  };<br/>
<div class="spacer">
</div>
In any case, now that we've settled on what should be in a node, let's make a little sample tree out of a few nodes and see what we can do with it:<div class="spacer">
</div>
<br/>
  # Board just before move 3 in above game<br/>
  my $n0 = {<br/>
    'board' =&gt; 'xx_xx_oo_oo',<br/>
    'last_move_payoff' =&gt; 0,<br/>
    'last_move_from' =&gt;  9,<br/>
    'last_move_to'   =&gt;  7,<br/>
    'whose_turn' =&gt; 'x',<br/>
    'successors' =&gt; [],<br/>
  };<br/>
<br/>
  # And, for now, just two of the successors:<br/>
  <br/>
  # X moves 4 to 6, giving xx__xxoo_oo<br/>
  my $n1 = {<br/>
    'board' =&gt; 'xx__xxoo_oo',<br/>
    'last_move_payoff' =&gt; 0,<br/>
    'last_move_from' =&gt;  4,<br/>
    'last_move_to'   =&gt;  6,<br/>
    'whose_turn' =&gt; 'o',<br/>
    'successors' =&gt; [],<br/>
  };<br/>
<br/>
  # or X moves 5 to 6, giving xx_x_xoo_oo<br/>
  my $n2 = {<br/>
    'board' =&gt; 'xx_x_xoo_oo',<br/>
    'last_move_payoff' =&gt; 0,<br/>
    'last_move_from' =&gt;  5,<br/>
    'last_move_to'   =&gt;  6,<br/>
    'whose_turn' =&gt; 'o',<br/>
    'successors' =&gt; [],<br/>
  };<br/>
<br/>
  # Now connect them...<br/>
  push @{$n0-&gt;{'successors'}}, $n1, $n2;<br/>
</div>
<div class="subsection">
<h2>Digression: Links to Parents</h2> In comparing what we store in an Alak game tree node to what HTML::Element stores in HTML element nodes, you'll note one big difference: every HTML::Element node contains a link to its parent, whereas we don't have our Alak nodes keeping a link to theirs.<div class="spacer">
</div>
The reason this can be an important difference is because it can affect how Perl knows when you're not using pieces of memory anymore. Consider the tree we just built, above:<div class="spacer">
</div>
<br/>
      node 0<br/>
     /      \<br/>
  node 1    node 2<br/>
<div class="spacer">
</div>
There's two ways Perl knows you're using a piece of memory: 1) it's memory that belongs directly to a variable (i.e., is necessary to hold that variable's value, or value <i>s</i> in the case of a hash or array), or 2) it's a piece of memory that something holds a reference to.  In the above code, Perl knows that the hash for node 0 (for board &quot;xx_xx_oo_oo&quot;) is in use because something (namely, the variable $n0) holds a reference to it.  Now, even if you followed the above code with this:<div class="spacer">
</div>
<br/>
  $n1 = $n2 = 'whatever';<br/>
<div class="spacer">
</div>
to make your variables $n1 and $n2 stop holding references to the hashes for the two successors of node 0, Perl would still know that those hashes are still in use, because node 0's successors array holds a reference to those hashes.  And Perl knows that node 0 is still in use because something still holds a reference to it.  Now, if you added:<div class="spacer">
</div>
<br/>
  my $root = $n0;<br/>
<div class="spacer">
</div>
This would change nothing -- there's just be <i>two</i> things holding a reference to the node 0 hash, which in turn holds a reference to the node 1 and node 2 hashes.  And if you then added:<div class="spacer">
</div>
<br/>
  $n0 = 'stuff';<br/>
<div class="spacer">
</div>
still nothing would change, because something ($root) still holds a reference to the node 0 hash.  But once  <i>nothing</i> holds a reference to the node 0 hash, Perl will know it can destroy that hash (and reclaim the memory for later use, say), and once it does that, nothing will hold a reference to the node 1 or the node 2 hashes, and those will be destroyed too.<div class="spacer">
</div>
But consider if the node 1 and node 2 hashes each had an attribute &quot;parent&quot; (or &quot;predecessor&quot;) that held a reference to node 0.  If your program stopped holding a reference to the node 0 hash, Perl could  <i>not</i> then say that <i>nothing</i> holds a reference to node 0 -- because node 1 and node 2 still do.  So, the memory for nodes 0, 1, and 2 would never get reclaimed (until your program ended, at which point Perl destroys  <i>everything</i>).  If your program grew and discarded lots of nodes in the game tree, but didn't let Perl know it could reclaim their memory, your program could grow to use immense amounts of memory -- never a nice thing to have happen.  There's three ways around this:<div class="spacer">
</div>
1) When you're finished with a node, delete the reference each of its children have to it (in this case, deleting $n1-&gt;{'parent'}, say). When you're finished with a whole tree, just go through the whole tree erasing links that children have to their children.<div class="spacer">
</div>
2) Reconsider whether you really need to have each node hold a reference to its parent.  Just not having those links will avoid the whole problem.<div class="spacer">
</div>
3) use the WeakRef module with Perl 5.6 or later.  This allows you to &quot;weaken&quot; some references (like the references that node 1 and 2 could hold to their parent) so that they don't count when Perl goes asking whether anything holds a reference to a given piece of memory.  This wonderful new module eliminates the headaches that can often crop up with either of the two previous methods.<div class="spacer">
</div>
It so happens that our Alak program is simple enough that we don't need for our nodes to have links to their parents, so the second solution is fine.  But in a more advanced program, the first or third solutions might be unavoidable.</div>
<div class="subsection">
<h2>Recursively Printing the Tree</h2> I don't like working blind -- if I have any kind of a complex data structure in memory for a program I'm working on, the first thing I do is write something that can dump that structure to the screen so I can make sure that what I  <i>think</i> is in memory really <i>is</i> what's in memory.  Now, I could just use the &quot;x&quot; pretty-printer command in Perl's interactive debugger, or I could have the program use the &quot;Data::Dumper&quot; module.  But in this case, I think the output from those is rather too verbose.  Once we have trees with dozens of nodes in them, we'll really want a dump of the tree to be as concise as possible, hopefully just one line per node.  What I'd like is something that can print $n0 and its successors (see above) as something like:<div class="spacer">
</div>
<br/>
  xx_xx_oo_oo  (O moved 9 to 7, 0 payoff)<br/>
    xx__xxoo_oo  (X moved 4 to 6, 0 payoff)<br/>
    xx_x_xoo_oo  (X moved 5 to 6, 0 payoff)<br/>
<div class="spacer">
</div>
A subroutine to print a line for a given node, and then do that again for each successor, would look something like:<div class="spacer">
</div>
<br/>
  sub dump_tree {<br/>
    my $n = $_[0]; # &quot;n&quot; is for node<br/>
    print<br/>
      ...something expressing $n'n content...<br/>
    foreach my $s (@{$n-&gt;{'successors'}}) {<br/>
      # &quot;s for successor<br/>
      dump($s);<br/>
    }<br/>
  }<br/>
<div class="spacer">
</div>
And we could just start that out with a call to &quot;dump_tree($n0)&quot;.<div class="spacer">
</div>
Since this routine...<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
Footnote: I first wrote this routine starting out with &quot;sub dump {&quot;.  But when I tried actually calling &quot;dump($n0)&quot;, Perl would dump core!  Imagine my shock when I discovered that this is absolutely to be expected -- Perl provides a built-in function called &quot;dump&quot;, the purpose of which is to, yes, make Perl dump core.  Calling our routine &quot;dump_tree&quot; instead of &quot;dump&quot; neatly avoids that problem.</div>
<div class="spacer">
</div>
...does its work (dumping the subtree at and under the given node) by calling itself, it's  <b>recursive</b>.  However, there's a special term for this kind of recursion across a tree: traversal.  To  <b>traverse</b> a tree means to do something to a node, and to traverse its children.  There's two prototypical ways to do this, depending on what happens when:<div class="spacer">
</div>
<br/>
  traversing X in pre-order:<br/>
    * do something to X<br/>
    * then traverse X's children<br/>
<br/>
  traversing X in post-order:<br/>
    * traverse X's children<br/>
    * then do something to X<br/>
<div class="spacer">
</div>
Dumping the tree to the screen the way we want it happens to be a matter of pre-order traversal, since the thing we do (print a description of the node) happens before we recurse into the successors.<div class="spacer">
</div>
When we try writing the &quot;print&quot; statement for our above &quot;dump_tree&quot;, we can get something like:<div class="spacer">
</div>
<br/>
  sub dump_tree {<br/>
    my $n = $_[0];<br/>
<br/>
    # &quot;xx_xx_oo_oo  (O moved 9 to 7, 0 payoff)&quot;<br/>
    print<br/>
      $n-&gt;{'board'}, &quot;  (&quot;,<br/>
      ($n-&gt;{'whose_turn'} eq 'o' ? 'X' : 'O'),<br/>
      # Infer who last moved from whose turn it is now.<br/>
      &quot; moved &quot;, $n-&gt;{'last_move_from'},<br/>
      &quot; to &quot;,    $n-&gt;{'last_move_to'},<br/>
      &quot;, &quot;,      $n-&gt;{'last_move_payoff'},<br/>
      &quot; payoff)\n&quot;,<br/>
    ;<br/>
<br/>
    foreach my $s (@{$n-&gt;{'successors'}}) {<br/>
      dump_tree($s);<br/>
    }<br/>
  }<br/>
<div class="spacer">
</div>
If we run this on $n0 from above, we get this:<div class="spacer">
</div>
<br/>
  xx_xx_oo_oo  (O moved 9 to 7, 0 payoff)<br/>
  xx__xxoo_oo  (X moved 4 to 6, 0 payoff)<br/>
  xx_x_xoo_oo  (X moved 5 to 6, 0 payoff)<br/>
<div class="spacer">
</div>
Each line on its own is fine, but we forget to allow for indenting, and without that we can't tell what's a child of what.  (Imagine if the first successor had successors of its own -- you wouldn't be able to tell if it were a child, or a sibling.)  To get indenting, we'll need to have the instances of the &quot;dump_tree&quot; routine know how far down in the tree they're being called, by passing a depth parameter between them:<div class="spacer">
</div>
<br/>
  sub dump_tree {<br/>
    my $n = $_[0];<br/>
    my $depth = $_[1];<br/>
    $depth = 0 unless defined $depth;<br/>
    print<br/>
      &quot;  &quot; x $depth,<br/>
      ...stuff...<br/>
    foreach my $s (@{$n-&gt;{'successors'}}) {<br/>
      dump_tree($s, $depth + 1);<br/>
    }<br/>
  }<br/>
<div class="spacer">
</div>
When we call &quot;dump_tree($n0)&quot;, $depth (from $_[1]) is undefined, so gets set to 0, which translates into an indenting of no spaces.  But when &quot;dump_tree&quot; invokes itself on $n0's children, those instances see $depth + 1 as their $_[1], giving appropriate indenting.<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
Footnote: Passing values around between different invocations of a recursive routine, as shown, is a decent way to share the data.  Another way to share the data is by keeping it in a global variable, like $Depth, initially set to 0.  Each time &quot;dump_tree&quot; is about to recurse, it must &quot;++$Depth&quot;, and when it's back, it must &quot;--$Depth&quot;.<div style="height: 1.00em;">
&#160;</div>
Or, if the reader is familiar with closures, consider this approach:<div style="height: 1.00em;">
&#160;</div>
<br/>
  sub dump_tree {<br/>
    # A wrapper around calls to a recursive closure:<br/>
    my $start_node = $_[0];<br/>
    my $depth = 0;<br/>
     # to be shared across calls to $recursor.<br/>
    my $recursor;<br/>
    $recursor = sub {<br/>
      my $n = $_[0];<br/>
      print &quot;  &quot; x $depth,<br/>
        ...stuff...<br/>
      ++$depth;<br/>
      foreach my $s (@{$n-&gt;{'successors'}}) {<br/>
        $recursor-&gt;($s);<br/>
      }<br/>
      --$depth;<br/>
    }<br/>
    $recursor-&gt;($start_node); # start recursing<br/>
    undef $recursor;<br/>
  }<br/>
<div style="height: 1.00em;">
&#160;</div>
The reader with an advanced understanding of Perl's reference-count-based garbage collection is invited to consider why it is currently necessary to undef $recursor (or otherwise change its value) after all recursion is done.<div style="height: 1.00em;">
&#160;</div>
The reader whose mind is perverse in other ways is invited to consider how (or when!) passing a depth parameter around is unnecessary because of information that Perl's caller(N) function reports!<div style="height: 1.00em;">
&#160;</div>
[end footnote]</div>
</div>
<div class="subsection">
<h2>Growing the Tree</h2> Our &quot;dump_tree&quot; routine works fine for the sample tree we've got, so now we should get the program working on making its own trees, starting from a given board.<div class="spacer">
</div>
In &quot;Games::Alak&quot; (the CPAN-released version of Alak that uses essentially the same code that we're currently discussing the tree-related parts of), there is a routine called &quot;figure_successors&quot; that, given one childless node, will figure out all its possible successors.  That is, it looks at the current board, looks at every piece belonging to the player whose turn it is, and considers the effect of moving each piece every possible way -- notably, it figures out the immediate payoff, and if that move would end the game, it notes that by setting an &quot;endgame&quot; entry in that node's hash.  (That way, we know that that's a node that  <i>can't</i> have successors.)<div class="spacer">
</div>
In the code for &quot;Games::Alak&quot;, &quot;figure_successors&quot; does all these things, in a rather straightforward way.  I won't walk you through the details of the &quot;figure_successors&quot; code I've written, since the code has nothing much to do with trees, and is all just implementation of the Alak rules for what can move where, with what result.  Especially interested readers can puzzle over that part of code in the source listing in the archive from CPAN, but others can just assume that it works as described above.<div class="spacer">
</div>
But consider that &quot;figure_successors&quot;, regardless of its inner workings, does not grow the  <i>tree</i>; it only makes one set of successors for one node at a time.  It has to be up to a different routine to call &quot;figure_successors&quot;, and to keep applying it as needed, in order to make a nice big tree that our game-playing program can base its decisions on.<div class="spacer">
</div>
Now, we could do this by just starting from one node, applying &quot;figure_successors&quot; to it, then applying &quot;figure_successors&quot; on all the resulting children, and so on:<div class="spacer">
</div>
<br/>
  sub grow {  # Just a first attempt at this!<br/>
    my $n = $_[0];<br/>
    figure_successors($n);<br/>
     unless<br/>
      @{$n-&gt;{'successors'}}<br/>
        # already has successors.<br/>
      or $n-&gt;{'endgame'}<br/>
        # can't have successors.<br/>
    }<br/>
    foreach my $s (@{$n-&gt;{'successors'}}) {<br/>
      grow($s); # recurse<br/>
    }<br/>
  }<br/>
<div class="spacer">
</div>
If you have a game tree for tic-tac-toe, and you grow it without limitation (as above), you will soon enough have a fully &quot;solved&quot; tree, where every node that  <i>can</i> have successors <i>does</i>, and all the leaves of the tree are  <i>all</i> the possible endgames (where, in each case, the board is filled).  But a game of Alak is different from tic-tac-toe, because it can, in theory, go on forever.  For example, the following sequence of moves is quite possible:<div class="spacer">
</div>
<br/>
  xxxx___oooo<br/>
  xxx_x__oooo<br/>
  xxx_x_o_ooo<br/>
  xxxx__o_ooo (x moved back)<br/>
  xxxx___oooo (o moved back)<br/>
  ...repeat forever...<br/>
<div class="spacer">
</div>
So if you tried using our above attempt at a &quot;grow&quot; routine, Perl would happily start trying to construct an infinitely deep tree, containing an infinite number of nodes, consuming an infinite amount of memory, and requiring an infinite amount of time.  As the old saying goes: &quot;You can't have everything -- where would you put it?&quot;  So we have to place limits on how much we'll grow the tree.<div class="spacer">
</div>
There's more than one way to do this:<div class="spacer">
</div>
1. We could grow the tree until we hit some limit on the number of nodes we'll allow in the tree.<div class="spacer">
</div>
2. We could grow the tree until we hit some limit on the amount of time we're willing to spend.<div class="spacer">
</div>
3. Or we could grow the tree until it is fully fleshed out to a certain depth.<div class="spacer">
</div>
Since we already know to track depth (as we did in writing &quot;dump_tree&quot;), we'll do it that way, the third way.  The implementation for that third approach is also pretty straightforward:<div class="spacer">
</div>
<br/>
  $Max_depth = 3;<br/>
  sub grow {<br/>
    my $n = $_[0];<br/>
    my $depth = $_[1] || 0;<br/>
    figure_successors($n)<br/>
     unless<br/>
      $depth &gt;= $Max_depth<br/>
      or @{$n-&gt;{'successors'}}<br/>
      or $n-&gt;{'endgame'}<br/>
    }<br/>
    foreach my $s (@{$n-&gt;{'successors'}}) {<br/>
      grow($s, $depth + 1);<br/>
    }<br/>
    # If we're at $Max_depth, then figure_successors<br/>
    #  didn't get called, so there's no successors<br/>
    #  to recurse under -- that's what stops recursion.<br/>
  }<br/>
<div class="spacer">
</div>
If we start from a single node (whether it's a node for the starting board &quot;xxxx___oooo&quot;, or for whatever board the computer is faced with), set $Max_depth to 4, and apply &quot;grow&quot; to it, it will grow the tree to include several hundred nodes.<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
Footnote: If at each move there are four pieces that can move, and they can each move right or left, the &quot;branching factor&quot; of the tree is eight, giving a tree with 1 (depth 0) + 8 (depth 1) + 8 ** 2 + 8 ** 3 + 8 ** 4  = 4681 nodes in it.  But, in practice, not all pieces can move in both directions (none of the x pieces in &quot;xxxx___oooo&quot; can move left, for example), and there may be fewer than four pieces, if some were lost. For example, there are 801 nodes in a tree of depth four starting from &quot;xxxx___oooo&quot;, suggesting an average branching factor of about five (801 ** (1/4) is about 5.3), not eight.</div>
<div class="spacer">
</div>
What we need to derive from that tree is the information about what are the best moves for X.  The simplest way to consider the payoff of different successors is to just average them -- but what we average isn't always their immediate payoffs (because that'd leave us using only one generation of information), but the average payoff of  <i>their</i> successors, if any.  We can formalize this as:<div class="spacer">
</div>
<br/>
  To figure a node's average payoff:<br/>
    If the node has successors:<br/>
      Figure each successor's average payoff.<br/>
      My average payoff is the average of theirs.<br/>
    Otherwise:<br/>
      My average payoff is my immediate payoff.<br/>
<div class="spacer">
</div>
Since this involves recursing into the successors <i>before</i> doing anything with the current node, this will traverse the tree  <i>in post-order</i>.<div class="spacer">
</div>
We could work that up as a routine of its own, and apply that to the tree after we've applied &quot;grow&quot; to it.  But since we'd never grow the tree without also figuring the average benefit, we might as well make that figuring part of the &quot;grow&quot; routine itself:<div class="spacer">
</div>
<br/>
  $Max_depth = 3;<br/>
  sub grow {<br/>
    my $n = $_[0];<br/>
    my $depth = $_[1] || 0;<br/>
    figure_successors($n);<br/>
     unless<br/>
      $depth &gt;= $Max_depth<br/>
      or @{$n-&gt;{'successors'}}<br/>
      or $n-&gt;{'endgame'}<br/>
    }<br/>
<br/>
    if(@{$n-&gt;{'successors'}}) {<br/>
      my $a_payoff_sum = 0;<br/>
      foreach my $s (@{$n-&gt;{'successors'}}) {<br/>
        grow($s, $depth + 1);  # RECURSE<br/>
        $a_payoff_sum += $s-&gt;{'average_payoff'};<br/>
      }<br/>
      $n-&gt;{'average_payoff'}<br/>
       = $a_payoff_sum / @{$n-&gt;{'successors'}};<br/>
    } else {<br/>
      $n-&gt;{'average_payoff'}<br/>
       = $n-&gt;{'last_move_payoff'};<br/>
    }<br/>
  }<br/>
<div class="spacer">
</div>
So, by time &quot;grow&quot; has applied to a node (wherever in the tree it is), it will have figured successors if possible (which, in turn, sets &quot;last_move_payoff&quot; for each node it creates), and will have set &quot;average_benefit&quot;.<div class="spacer">
</div>
Beyond this, all that's needed is to start the board out with a root note of &quot;xxxx___oooo&quot;, and have the computer (X) take turns with the user (O) until someone wins.  Whenever it's O's turn, &quot;Games::Alak&quot; presents a prompt to the user, letting him know the state of the current board, and asking what move he selects.  When it's X's turn, the computer grows the game tree as necessary (using just the &quot;grow&quot; routine from above), then selects the move with the highest average payoff (or one of the highest, in case of a tie).<div class="spacer">
</div>
In either case, &quot;selecting&quot; a move means just setting that move's node as the new root of the program's game tree.  Its sibling nodes and their descendants (the boards that  <i>didn't</i> get selected) and its parent node will be erased from memory, since they will no longer be in use (as Perl can tell by the fact that nothing holds references to them anymore).<div class="spacer">
</div>
The interface code in &quot;Games::Alak&quot; (the code that prompts the user for his move) actually supports quite a few options besides just moving -- including dumping the game tree to a specified depth (using a slightly fancier version of &quot;dump_tree&quot;, above), resetting the game, changing $Max_depth in the middle of the game, and quitting the game.  Like &quot;figure_successors&quot;, it's a bit too long to print here, but interested users are welcome to peruse (and freely modify) the code, as well as to enjoy just playing the game.<div class="spacer">
</div>
Now, in practice, there's more to game trees than this: for games with a larger branching factor than Alak has (which is most!), game trees of depth four or larger would contain too many nodes to be manageable, most of those nodes being strategically quite uninteresting for either player; dealing with game trees specifically is therefore a matter of recognizing uninteresting contingencies and not bothering to grow the tree under them.<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 4.00ex;">
Footnote: For example, to choose a straightforward case: if O has a choice between moves that put him in immediate danger of X winning and moves that don't, then O won't ever choose the dangerous moves (and if he does, the computer will know enough to end the game), so there's no point in growing the tree any further beneath those nodes.</div>
<div class="spacer">
</div>
But this sample implementation should illustrate the basics of how to build and manipulate a simple tree structure in memory. And once you've understood the basics of tree storage here, you should be ready to better understand the complexities and peculiarities of other systems for creating, accessing, and changing trees, including Tree::DAG_Node, HTML::Element, XML::DOM, or related formalisms like XPath and XSL.<div class="spacer">
</div>
<b>[end body of article]</b></div>
<div class="subsection">
<h2>[Author Credit]</h2> Sean M. Burke (&quot;sburke@cpan.org&quot;) is a tree-dwelling hominid.</div>
<div class="subsection">
<h2>References</h2> Dewdney, A[lexander] K[eewatin].  1984.   <i>Planiverse: Computer Contact</i>  <i>with a Two-Dimensional World.</i>  Poseidon Press, New York.<div class="spacer">
</div>
Knuth, Donald Ervin.  1997.  <i>Art of Computer Programming, Volume 1,</i>  <i>Third Edition: Fundamental Algorithms</i>.  Addison-Wesley,  Reading, MA.<div class="spacer">
</div>
Wirth, Niklaus.  1976.  <i>Algorithms + Data Structures = Programs</i> Prentice-Hall, Englewood Cliffs, NJ.<div class="spacer">
</div>
Worth, Stan and Allman Sheldon.  Circa 1967.  <i>George of the Jungle</i> theme.  [music by Jay Ward.]<div class="spacer">
</div>
Wirth's classic, currently and lamentably out of print, has a good section on trees.  I find it clearer than Knuth's (if not quite as encyclopedic), probably because Wirth's example code is in a block-structured high-level language (basically Pascal), instead of in assembler (MIX).  I believe the book was re-issued in the 1980s under the titles  <i>Algorithms and Data Structures</i> and, in a German edition,  <i>Algorithmen und Datenstrukturen</i>.  Cheap copies of these editions should be available through used book services such as &quot;abebooks.com&quot;.<div class="spacer">
</div>
Worth's classic, however, is available on the soundtrack to the 1997  <i>George of the Jungle</i> movie, as performed by The Presidents of the United States of America.</div>
</div>
<div class="section">
<h1>BACK</h1> Return to the HTML::Tree docs.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-04-30</td>
<td class="foot-os">
perl v5.10.1</td>
</tr>
</table>
</div>
</body>
</html>

