<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Module::Runtime(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Module::Runtime(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
Module::Runtime(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Module::Runtime - runtime module handling</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
        use Module::Runtime qw(<br/>
                $module_name_rx is_module_name check_module_name<br/>
                module_notional_filename require_module<br/>
        );<br/>
<br/>
        if($module_name =~ /\A$module_name_rx\z/o) { ...<br/>
        if(is_module_name($module_name)) { ...<br/>
        check_module_name($module_name);<br/>
<br/>
        $notional_filename = module_notional_filename($module_name);<br/>
        require_module($module_name);<br/>
<br/>
        use Module::Runtime qw(use_module use_package_optimistically);<br/>
<br/>
        $bi = use_module(&quot;Math::BigInt&quot;, 1.31)-&gt;new(&quot;1_234&quot;);<br/>
        $widget = use_package_optimistically(&quot;Local::Widget&quot;)-&gt;new;<br/>
<br/>
        use Module::Runtime qw(<br/>
                $top_module_spec_rx $sub_module_spec_rx<br/>
                is_module_spec check_module_spec<br/>
                compose_module_name<br/>
        );<br/>
<br/>
        if($spec =~ /\A$top_module_spec_rx\z/o) { ...<br/>
        if($spec =~ /\A$sub_module_spec_rx\z/o) { ...<br/>
        if(is_module_spec(&quot;Standard::Prefix&quot;, $spec)) { ...<br/>
        check_module_spec(&quot;Standard::Prefix&quot;, $spec);<br/>
<br/>
        $module_name =<br/>
                compose_module_name(&quot;Standard::Prefix&quot;, $spec);<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> The functions exported by this module deal with runtime handling of Perl modules, which are normally handled at compile time.</div>
<div class="section">
<h1>REGULAR EXPRESSIONS</h1> These regular expressions do not include any anchors, so to check whether an entire string matches a syntax item you must supply the anchors yourself.<dl>
<dt>
$module_name_rx</dt>
<dd>
Matches a valid Perl module name in bareword syntax. The rule for this, precisely, is: the string must consist of one or more segments separated by &quot;::&quot;; each segment must consist of one or more identifier characters (alphanumerics plus &quot;_&quot;); the first character of the string must not be a digit.  Thus &quot;&quot;IO::File&quot;&quot;, &quot;&quot;warnings&quot;&quot;, and &quot;&quot;foo::123::x_0&quot;&quot; are all valid module names, whereas &quot;&quot;IO::&quot;&quot; and &quot;&quot;1foo::bar&quot;&quot; are not. Only ASCII characters are permitted; Perl's handling of non-ASCII characters in source code is inconsistent. &quot;'&quot; separators are not permitted.</dd>
</dl>
<dl>
<dt>
$top_module_spec_rx</dt>
<dd>
Matches a module specification for use with &quot;compose_module_name&quot;, where no prefix is being used.</dd>
</dl>
<dl>
<dt>
$sub_module_spec_rx</dt>
<dd>
Matches a module specification for use with &quot;compose_module_name&quot;, where a prefix is being used.</dd>
</dl>
</div>
<div class="section">
<h1>FUNCTIONS</h1><div class="subsection">
<h2>Basic module handling</h2><dl>
<dt>
is_module_name(ARG)</dt>
<dd>
Returns a truth value indicating whether <i>ARG</i> is a plain string satisfying Perl module name syntax as described for &quot;$module_name_rx&quot;.</dd>
</dl>
<dl>
<dt>
is_valid_module_name(ARG)</dt>
<dd>
Deprecated alias for &quot;is_module_name&quot;.</dd>
</dl>
<dl>
<dt>
check_module_name(ARG)</dt>
<dd>
Check whether <i>ARG</i> is a plain string satisfying Perl module name syntax as described for &quot;$module_name_rx&quot;. Return normally if it is, or &quot;die&quot; if it is not.</dd>
</dl>
<dl>
<dt>
module_notional_filename(NAME)</dt>
<dd>
Generates a notional relative filename for a module, which is used in some Perl core interfaces. The  <i>NAME</i> is a string, which should be a valid module name (one or more &quot;::&quot;-separated segments).  If it is not a valid name, the function &quot;die&quot;s.<div style="height: 1.00em;">
&#160;</div>
The notional filename for the named module is generated and returned. This filename is always in Unix style, with &quot;/&quot; directory separators and a &quot;.pm&quot; suffix.  This kind of filename can be used as an argument to &quot;require&quot;, and is the key that appears in %INC to identify a module, regardless of actual local filename syntax.</dd>
</dl>
<dl>
<dt>
require_module(NAME)</dt>
<dd>
This is essentially the bareword form of &quot;require&quot;, in runtime form. The  <i>NAME</i> is a string, which should be a valid module name (one or more &quot;::&quot;-separated segments).  If it is not a valid name, the function &quot;die&quot;s.<div style="height: 1.00em;">
&#160;</div>
The module specified by <i>NAME</i> is loaded, if it hasn't been already, in the manner of the bareword form of &quot;require&quot;.  That means that a search through @INC is performed, and a byte-compiled form of the module will be used if available.<div style="height: 1.00em;">
&#160;</div>
The return value is as for &quot;require&quot;.  That is, it is the value returned by the module itself if the module is loaded anew, or 1 if the module was already loaded.</dd>
</dl>
</div>
<div class="subsection">
<h2>Structured module use</h2><dl>
<dt>
use_module(NAME[, VERSION])</dt>
<dd>
This is essentially &quot;use&quot; in runtime form, but without the importing feature (which is fundamentally a compile-time thing).  The  <i>NAME</i> is handled just like in &quot;require_module&quot; above: it must be a module name, and the named module is loaded as if by the bareword form of &quot;require&quot;.<div style="height: 1.00em;">
&#160;</div>
If a <i>VERSION</i> is specified, the &quot;VERSION&quot; method of the loaded module is called with the specified  <i>VERSION</i> as an argument.  This normally serves to ensure that the version loaded is at least the version required.  This is the same functionality provided by the  <i>VERSION</i> parameter of &quot;use&quot;.<div style="height: 1.00em;">
&#160;</div>
On success, the name of the module is returned.  This is unlike &quot;require_module&quot;, and is done so that the entire call to &quot;use_module&quot; can be used as a class name to call a constructor, as in the example in the synopsis.</dd>
</dl>
<dl>
<dt>
use_package_optimistically(NAME[, VERSION])</dt>
<dd>
This is an analogue of &quot;use_module&quot; for the situation where there is uncertainty as to whether a package/class is defined in its own module or by some other means.  It attempts to arrange for the named package to be available, either by loading a module or by doing nothing and hoping.<div style="height: 1.00em;">
&#160;</div>
An attempt is made to load the named module (as if by the bareword form of &quot;require&quot;).  If the module cannot be found then it is assumed that the package was actually already loaded but wasn't detected correctly, and no error is signalled.  That's the optimistic bit.<div style="height: 1.00em;">
&#160;</div>
This is mostly the same operation that is performed by the base pragma to ensure that the specified base classes are available.  The behaviour of base was simplified in version 2.18, and this function changed to match.<div style="height: 1.00em;">
&#160;</div>
If a <i>VERSION</i> is specified, the &quot;VERSION&quot; method of the loaded package is called with the specified  <i>VERSION</i> as an argument.  This normally serves to ensure that the version loaded is at least the version required. On success, the name of the package is returned.  These aspects of the function work just like &quot;use_module&quot;.</dd>
</dl>
</div>
<div class="subsection">
<h2>Module name composition</h2><dl>
<dt>
is_module_spec(PREFIX, SPEC)</dt>
<dd>
Returns a truth value indicating whether  <i>SPEC</i> is valid input for &quot;compose_module_name&quot;. See below for what that entails.  Whether a  <i>PREFIX</i> is supplied affects the validity of  <i>SPEC</i>, but the exact value of the prefix is unimportant, so this function treats  <i>PREFIX</i> as a truth value.</dd>
</dl>
<dl>
<dt>
is_valid_module_spec(PREFIX, SPEC)</dt>
<dd>
Deprecated alias for &quot;is_module_spec&quot;.</dd>
</dl>
<dl>
<dt>
check_module_spec(PREFIX, SPEC)</dt>
<dd>
Check whether <i>SPEC</i> is valid input for &quot;compose_module_name&quot;. Return normally if it is, or &quot;die&quot; if it is not.</dd>
</dl>
<dl>
<dt>
compose_module_name(PREFIX, SPEC)</dt>
<dd>
This function is intended to make it more convenient for a user to specify a Perl module name at runtime.  Users have greater need for abbreviations and context-sensitivity than programmers, and Perl module names get a little unwieldy.   <i>SPEC</i> is what the user specifies, and this function translates it into a module name in standard form, which it returns.<div style="height: 1.00em;">
&#160;</div>
<i>SPEC</i> has syntax approximately that of a standard module name: it should consist of one or more name segments, each of which consists of one or more identifier characters.  However, &quot;/&quot; is permitted as a separator, in addition to the standard &quot;::&quot;.  The two separators are entirely interchangeable.<div style="height: 1.00em;">
&#160;</div>
Additionally, if <i>PREFIX</i> is not &quot;undef&quot; then it must be a module name in standard form, and it is prefixed to the user-specified name. The user can inhibit the prefix addition by starting  <i>SPEC</i> with a separator (either &quot;/&quot; or &quot;::&quot;).</dd>
</dl>
</div>
</div>
<div class="section">
<h1>SEE ALSO</h1> base, &quot;require&quot; in perlfunc, &quot;use&quot; in perlfunc</div>
<div class="section">
<h1>AUTHOR</h1> Andrew Main (Zefram) &lt;zefram@fysh.org&gt;</div>
<div class="section">
<h1>COPYRIGHT</h1> Copyright (C) 2004, 2006, 2007, 2009, 2010, 2011 Andrew Main (Zefram) &lt;zefram@fysh.org&gt;</div>
<div class="section">
<h1>LICENSE</h1> This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-11-07</td>
<td class="foot-os">
perl v5.12.4</td>
</tr>
</table>
</div>
</body>
</html>

