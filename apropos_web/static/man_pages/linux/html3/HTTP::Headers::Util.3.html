<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
HTTP::Headers::Util(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
HTTP::Headers::Util(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
HTTP::Headers::Util(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> HTTP::Headers::Util - Header value parsing utility functions</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
  use HTTP::Headers::Util qw(split_header_words);<br/>
  @values = split_header_words($h-&gt;header(&quot;Content-Type&quot;));<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> This module provides a few functions that helps parsing and construction of valid HTTP header values.  None of the functions are exported by default.<div class="spacer">
</div>
The following functions are available:<dl>
<dt>
split_header_words( @header_values )</dt>
<dd>
This function will parse the header values given as argument into a list of anonymous arrays containing key/value pairs.  The function knows how to deal with &quot;,&quot;, &quot;;&quot; and &quot;=&quot; as well as quoted values after &quot;=&quot;.  A list of space separated tokens are parsed as if they were separated by &quot;;&quot;.<div style="height: 1.00em;">
&#160;</div>
If the @header_values passed as argument contains multiple values, then they are treated as if they were a single value separated by comma &quot;,&quot;.<div style="height: 1.00em;">
&#160;</div>
This means that this function is useful for parsing header fields that follow this syntax (BNF as from the HTTP/1.1 specification, but we relax the requirement for tokens).<div style="height: 1.00em;">
&#160;</div>
<br/>
  headers           = #header<br/>
  header            = (token | parameter) *( [&quot;;&quot;] (token | parameter))<br/>
<br/>
  token             = 1*&lt;any CHAR except CTLs or separators&gt;<br/>
  separators        = &quot;(&quot; | &quot;)&quot; | &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;@&quot;<br/>
                    | &quot;,&quot; | &quot;;&quot; | &quot;:&quot; | &quot;\&quot; | &lt;&quot;&gt;<br/>
                    | &quot;/&quot; | &quot;[&quot; | &quot;]&quot; | &quot;?&quot; | &quot;=&quot;<br/>
                    | &quot;{&quot; | &quot;}&quot; | SP | HT<br/>
<br/>
  quoted-string     = ( &lt;&quot;&gt; *(qdtext | quoted-pair ) &lt;&quot;&gt; )<br/>
  qdtext            = &lt;any TEXT except &lt;&quot;&gt;&gt;<br/>
  quoted-pair       = &quot;\&quot; CHAR<br/>
<br/>
  parameter         = attribute &quot;=&quot; value<br/>
  attribute         = token<br/>
  value             = token | quoted-string<br/>
<div style="height: 1.00em;">
&#160;</div>
Each <i>header</i> is represented by an anonymous array of key/value pairs.  The keys will be all be forced to lower case. The value for a simple token (not part of a parameter) is &quot;undef&quot;. Syntactically incorrect headers will not necessary be parsed as you would want.<div style="height: 1.00em;">
&#160;</div>
This is easier to describe with some examples:<div style="height: 1.00em;">
&#160;</div>
<br/>
   split_header_words('foo=&quot;bar&quot;; port=&quot;80,81&quot;; DISCARD, BAR=baz');<br/>
   split_header_words('text/html; charset=&quot;iso-8859-1&quot;');<br/>
   split_header_words('Basic realm=&quot;\\&quot;foo\\\\bar\\&quot;&quot;');<br/>
<div style="height: 1.00em;">
&#160;</div>
will return<div style="height: 1.00em;">
&#160;</div>
<br/>
   [foo=&gt;'bar', port=&gt;'80,81', discard=&gt; undef], [bar=&gt;'baz' ]<br/>
   ['text/html' =&gt; undef, charset =&gt; 'iso-8859-1']<br/>
   [basic =&gt; undef, realm =&gt; &quot;\&quot;foo\\bar\&quot;&quot;]<br/>
<div style="height: 1.00em;">
&#160;</div>
If you don't want the function to convert tokens and attribute keys to lower case you can call it as &quot;_split_header_words&quot; instead (with a leading underscore).</dd>
</dl>
<dl>
<dt>
join_header_words( @arrays )</dt>
<dd>
This will do the opposite of the conversion done by <i>split_header_words()</i>. It takes a list of anonymous arrays as arguments (or a list of key/value pairs) and produces a single header value.  Attribute values are quoted if needed.<div style="height: 1.00em;">
&#160;</div>
Example:<div style="height: 1.00em;">
&#160;</div>
<br/>
   join_header_words([&quot;text/plain&quot; =&gt; undef, charset =&gt; &quot;iso-8859/1&quot;]);<br/>
   join_header_words(&quot;text/plain&quot; =&gt; undef, charset =&gt; &quot;iso-8859/1&quot;);<br/>
<div style="height: 1.00em;">
&#160;</div>
will both return the string:<div style="height: 1.00em;">
&#160;</div>
<br/>
   text/plain; charset=&quot;iso-8859/1&quot;<br/>
</dd>
</dl>
</div>
<div class="section">
<h1>COPYRIGHT</h1> Copyright 1997-1998, Gisle Aas<div class="spacer">
</div>
This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-03-07</td>
<td class="foot-os">
perl v5.12.3</td>
</tr>
</table>
</div>
</body>
</html>

