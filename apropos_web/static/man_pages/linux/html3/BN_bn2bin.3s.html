<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
BN_bn2bin(3SSL)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
BN_bn2bin(3SSL)</td>
<td class="head-vol">
OpenSSL</td>
<td class="head-rtitle">
BN_bn2bin(3SSL)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> BN_bn2bin, BN_bin2bn, BN_bn2hex, BN_bn2dec, BN_hex2bn, BN_dec2bn, BN_print, BN_print_fp, BN_bn2mpi, BN_mpi2bn - format conversions</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
 #include &lt;openssl/bn.h&gt;<br/>
<br/>
 int BN_bn2bin(const BIGNUM *a, unsigned char *to);<br/>
 BIGNUM *BN_bin2bn(const unsigned char *s, int len, BIGNUM *ret);<br/>
<br/>
 char *BN_bn2hex(const BIGNUM *a);<br/>
 char *BN_bn2dec(const BIGNUM *a);<br/>
 int BN_hex2bn(BIGNUM **a, const char *str);<br/>
 int BN_dec2bn(BIGNUM **a, const char *str);<br/>
<br/>
 int BN_print(BIO *fp, const BIGNUM *a);<br/>
 int BN_print_fp(FILE *fp, const BIGNUM *a);<br/>
<br/>
 int BN_bn2mpi(const BIGNUM *a, unsigned char *to);<br/>
 BIGNUM *BN_mpi2bn(unsigned char *s, int len, BIGNUM *ret);<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1>  <i>BN_bn2bin()</i> converts the absolute value of <b>a</b> into big-endian form and stores it at  <b>to</b>. <b>to</b> must point to BN_num_bytes(<b>a</b>) bytes of memory.<div class="spacer">
</div>
<i>BN_bin2bn()</i> converts the positive integer in big-endian form of length  <b>len</b> at <b>s</b> into a <b>BIGNUM</b> and places it in <b>ret</b>. If <b>ret</b> is NULL, a new  <b>BIGNUM</b> is created.<div class="spacer">
</div>
<i>BN_bn2hex()</i> and <i>BN_bn2dec()</i> return printable strings containing the hexadecimal and decimal encoding of  <b>a</b> respectively. For negative numbers, the string is prefaced with a leading '-'. The string must be freed later using  <i>OPENSSL_free()</i>.<div class="spacer">
</div>
<i>BN_hex2bn()</i> converts the string <b>str</b> containing a hexadecimal number to a  <b>BIGNUM</b> and stores it in **<b>bn</b>. If *<b>bn</b> is NULL, a new  <b>BIGNUM</b> is created. If <b>bn</b> is NULL, it only computes the number's length in hexadecimal digits. If the string starts with '-', the number is negative.  <i>BN_dec2bn()</i> is the same using the decimal system.<div class="spacer">
</div>
<i>BN_print()</i> and <i>BN_print_fp()</i> write the hexadecimal encoding of <b>a</b>, with a leading '-' for negative numbers, to the  <b>BIO</b> or <b>FILE</b>  <b>fp</b>.<div class="spacer">
</div>
<i>BN_bn2mpi()</i> and <i>BN_mpi2bn()</i> convert <b>BIGNUM</b>s from and to a format that consists of the number's length in bytes represented as a 4-byte big-endian number, and the number itself in big-endian format, where the most significant bit signals a negative number (the representation of numbers with the MSB set is prefixed with null byte).<div class="spacer">
</div>
<i>BN_bn2mpi()</i> stores the representation of <b>a</b> at <b>to</b>, where <b>to</b> must be large enough to hold the result. The size can be determined by calling BN_bn2mpi( <b>a</b>, NULL).<div class="spacer">
</div>
<i>BN_mpi2bn()</i> converts the <b>len</b> bytes long representation at <b>s</b> to a  <b>BIGNUM</b> and stores it at <b>ret</b>, or in a newly allocated <b>BIGNUM</b> if  <b>ret</b> is NULL.</div>
<div class="section">
<h1>RETURN VALUES</h1>  <i>BN_bn2bin()</i> returns the length of the big-endian number placed at <b>to</b>.  <i>BN_bin2bn()</i> returns the <b>BIGNUM</b>, NULL on error.<div class="spacer">
</div>
<i>BN_bn2hex()</i> and <i>BN_bn2dec()</i> return a null-terminated string, or NULL on error.  <i>BN_hex2bn()</i> and <i>BN_dec2bn()</i> return the number's length in hexadecimal or decimal digits, and 0 on error.<div class="spacer">
</div>
<i>BN_print_fp()</i> and <i>BN_print()</i> return 1 on success, 0 on write errors.<div class="spacer">
</div>
<i>BN_bn2mpi()</i> returns the length of the representation. <i>BN_mpi2bn()</i> returns the  <b>BIGNUM</b>, and NULL on error.<div class="spacer">
</div>
The error codes can be obtained by <i>ERR_get_error</i>(3).</div>
<div class="section">
<h1>SEE ALSO</h1>  <i>bn</i>(3), <i>ERR_get_error</i>(3), <i>BN_zero</i>(3),  <i>ASN1_INTEGER_to_BN</i>(3),  <i>BN_num_bytes</i>(3)</div>
<div class="section">
<h1>HISTORY</h1>  <i>BN_bn2bin()</i>, <i>BN_bin2bn()</i>, <i>BN_print_fp()</i> and <i>BN_print()</i> are available in all versions of SSLeay and OpenSSL.<div class="spacer">
</div>
<i>BN_bn2hex()</i>, <i>BN_bn2dec()</i>, <i>BN_hex2bn()</i>, <i>BN_dec2bn()</i>, <i>BN_bn2mpi()</i> and  <i>BN_mpi2bn()</i> were added in SSLeay 0.9.0.</div>
<table class="foot">
<tr>
<td class="foot-date">
2002-09-25</td>
<td class="foot-os">
1.0.1</td>
</tr>
</table>
</div>
</body>
</html>

