<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
LIBPNG(3)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
LIBPNG(3)</td>
<td class="head-vol">
Library Functions Manual</td>
<td class="head-rtitle">
LIBPNG(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> libpng - Portable Network Graphics (PNG) Reference Library 1.2.46</div>
<div class="section">
<h1>SYNOPSIS</h1>  <i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>#include &lt;png.h&gt;</b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_uint_32 png_access_version_number </b><i>(void</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>int png_check_sig (png_bytep </b><i>sig</i><b>, int </b><i>num</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_chunk_error (png_structp </b><i>png_ptr</i><b>, png_const_charp </b><i>error</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_chunk_warning (png_structp </b><i>png_ptr</i><b>, png_const_charp </b><i>message</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_convert_from_struct_tm (png_timep </b><i>ptime</i><b>, struct tm FAR * </b><i>ttime</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_convert_from_time_t (png_timep </b><i>ptime</i><b>, time_t </b><i>ttime</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_charp png_convert_to_rfc1123 (png_structp </b><i>png_ptr</i><b>, png_timep </b><i>ptime</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_infop png_create_info_struct (png_structp </b><i>png_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_structp png_create_read_struct (png_const_charp </b><i>user_png_ver</i><b>, png_voidp </b><i>error_ptr</i><b>, png_error_ptr </b><i>error_fn</i><b>, png_error_ptr </b><i>warn_fn</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_structp png_create_read_struct_2(png_const_charp </b><i>user_png_ver</i><b>, png_voidp </b><i>error_ptr</i><b>, png_error_ptr </b><i>error_fn</i><b>, png_error_ptr </b><i>warn_fn</i><b>, png_voidp </b><i>mem_ptr</i><b>, png_malloc_ptr </b><i>malloc_fn</i><b>, png_free_ptr </b><i>free_fn</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_structp png_create_write_struct (png_const_charp </b><i>user_png_ver</i><b>, png_voidp </b><i>error_ptr</i><b>, png_error_ptr </b><i>error_fn</i><b>, png_error_ptr </b><i>warn_fn</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_structp png_create_write_struct_2(png_const_charp </b><i>user_png_ver</i><b>, png_voidp </b><i>error_ptr</i><b>, png_error_ptr </b><i>error_fn</i><b>, png_error_ptr </b><i>warn_fn</i><b>, png_voidp </b><i>mem_ptr</i><b>, png_malloc_ptr </b><i>malloc_fn</i><b>, png_free_ptr </b><i>free_fn</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>int png_debug(int </b><i>level</i><b>, png_const_charp </b><i>message</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>int png_debug1(int </b><i>level</i><b>, png_const_charp </b><i>message</i><b>, </b><i>p1</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>int png_debug2(int </b><i>level</i><b>, png_const_charp </b><i>message</i><b>, </b><i>p1</i><b>, </b><i>p2</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_destroy_info_struct (png_structp </b><i>png_ptr</i><b>, png_infopp </b><i>info_ptr_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_destroy_read_struct (png_structpp </b><i>png_ptr_ptr</i><b>, png_infopp </b><i>info_ptr_ptr</i><b>, png_infopp </b><i>end_info_ptr_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_destroy_write_struct (png_structpp </b><i>png_ptr_ptr</i><b>, png_infopp </b><i>info_ptr_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_error (png_structp </b><i>png_ptr</i><b>, png_const_charp </b><i>error</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_free (png_structp </b><i>png_ptr</i><b>, png_voidp </b><i>ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_free_chunk_list (png_structp </b><i>png_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_free_default(png_structp </b><i>png_ptr</i><b>, png_voidp </b><i>ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_free_data (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, int </b><i>num</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_byte png_get_bit_depth (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_uint_32 png_get_bKGD (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, png_color_16p </b><i>*background</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_byte png_get_channels (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_uint_32 png_get_cHRM (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, double </b><i>*white_x</i><b>, double </b><i>*white_y</i><b>, double </b><i>*red_x</i><b>, double </b><i>*red_y</i><b>, double </b><i>*green_x</i><b>, double </b><i>*green_y</i><b>, double </b><i>*blue_x</i><b>, double </b><i>*blue_y</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_uint_32 png_get_cHRM_fixed (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, png_uint_32 </b><i>*white_x</i><b>, png_uint_32 </b><i>*white_y</i><b>, png_uint_32 </b><i>*red_x</i><b>, png_uint_32 </b><i>*red_y</i><b>, png_uint_32 </b><i>*green_x</i><b>, png_uint_32 </b><i>*green_y</i><b>, png_uint_32 </b><i>*blue_x</i><b>, png_uint_32 </b><i>*blue_y</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_byte png_get_color_type (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_byte png_get_compression_type (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_byte png_get_copyright (png_structp </b><i>png_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_voidp png_get_error_ptr (png_structp </b><i>png_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_byte png_get_filter_type (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_uint_32 png_get_gAMA (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, double </b><i>*file_gamma</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_uint_32 png_get_gAMA_fixed (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, png_uint_32 </b><i>*int_file_gamma</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_byte png_get_header_ver (png_structp </b><i>png_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_byte png_get_header_version (png_structp </b><i>png_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_uint_32 png_get_hIST (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, png_uint_16p </b><i>*hist</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_uint_32 png_get_iCCP (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, png_charpp </b><i>name</i><b>, int </b><i>*compression_type</i><b>, png_charpp </b><i>profile</i><b>, png_uint_32 </b><i>*proflen</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_uint_32 png_get_IHDR (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, png_uint_32 </b><i>*width</i><b>, png_uint_32 </b><i>*height</i><b>, int </b><i>*bit_depth</i><b>, int </b><i>*color_type</i><b>, int </b><i>*interlace_type</i><b>, int </b><i>*compression_type</i><b>, int </b><i>*filter_type</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_uint_32 png_get_image_height (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_uint_32 png_get_image_width (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>#if </b><i>!defined(PNG_1_0_X)</i><div style="height: 1.00em;">
&#160;</div>
<b>png_int_32 png_get_int_32 (png_bytep </b><i>buf</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b>#endif</b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_byte png_get_interlace_type (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_voidp png_get_io_ptr (png_structp </b><i>png_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_byte png_get_libpng_ver (png_structp </b><i>png_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_voidp png_get_mem_ptr(png_structp </b><i>png_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_uint_32 png_get_oFFs (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, png_uint_32 </b><i>*offset_x</i><b>, png_uint_32 </b><i>*offset_y</i><b>, int </b><i>*unit_type</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_uint_32 png_get_pCAL (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, png_charp </b><i>*purpose</i><b>, png_int_32 </b><i>*X0</i><b>, png_int_32 </b><i>*X1</i><b>, int </b><i>*type</i><b>, int </b><i>*nparams</i><b>, png_charp </b><i>*units</i><b>, png_charpp </b><i>*params</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_uint_32 png_get_pHYs (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, png_uint_32 </b><i>*res_x</i><b>, png_uint_32 </b><i>*res_y</i><b>, int </b><i>*unit_type</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>float png_get_pixel_aspect_ratio (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_uint_32 png_get_pixels_per_meter (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_voidp png_get_progressive_ptr (png_structp </b><i>png_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_uint_32 png_get_PLTE (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, png_colorp </b><i>*palette</i><b>, int </b><i>*num_palette</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_byte png_get_rgb_to_gray_status (png_structp </b><i>png_ptr)</i><div style="height: 1.00em;">
&#160;</div>
<b>png_uint_32 png_get_rowbytes (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_bytepp png_get_rows (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_uint_32 png_get_sBIT (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, png_color_8p </b><i>*sig_bit</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_bytep png_get_signature (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_uint_32 png_get_sPLT (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, png_spalette_p </b><i>*splt_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_uint_32 png_get_sRGB (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, int </b><i>*intent</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_uint_32 png_get_text (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, png_textp </b><i>*text_ptr</i><b>, int </b><i>*num_text</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_uint_32 png_get_tIME (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, png_timep </b><i>*mod_time</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_uint_32 png_get_tRNS (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, png_bytep </b><i>*trans</i><b>, int </b><i>*num_trans</i><b>, png_color_16p </b><i>*trans_values</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>#if </b><i>!defined(PNG_1_0_X)</i><div style="height: 1.00em;">
&#160;</div>
<b>png_uint_16 png_get_uint_16 (png_bytep </b><i>buf</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_uint_32 png_get_uint_31 (png_bytep </b><i>buf</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_uint_32 png_get_uint_32 (png_bytep </b><i>buf</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b>#endif</b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_uint_32 png_get_unknown_chunks (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, png_unknown_chunkpp </b><i>unknowns</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_voidp png_get_user_chunk_ptr (png_structp </b><i>png_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_uint_32 png_get_user_height_max( png_structp </b><i>png_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_voidp png_get_user_transform_ptr (png_structp </b><i>png_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_uint_32 png_get_user_width_max (png_structp </b><i>png_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_uint_32 png_get_valid (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, png_uint_32 </b><i>flag</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_int_32 png_get_x_offset_microns (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_int_32 png_get_x_offset_pixels (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_uint_32 png_get_x_pixels_per_meter (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_int_32 png_get_y_offset_microns (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_int_32 png_get_y_offset_pixels (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_uint_32 png_get_y_pixels_per_meter (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_uint_32 png_get_compression_buffer_size (png_structp </b><i>png_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>int png_handle_as_unknown (png_structp </b><i>png_ptr</i><b>, png_bytep </b><i>chunk_name</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_init_io (png_structp </b><i>png_ptr</i><b>, FILE </b><i>*fp</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>DEPRECATED: void png_info_init (png_infop </b><i>info_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>DEPRECATED: void png_info_init_2 (png_infopp </b><i>ptr_ptr</i><b>, png_size_t </b><i>png_info_struct_size</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_voidp png_malloc (png_structp </b><i>png_ptr</i><b>, png_uint_32 </b><i>size</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_voidp png_malloc_default(png_structp </b><i>png_ptr</i><b>, png_uint_32 </b><i>size</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>voidp png_memcpy (png_voidp </b><i>s1</i><b>, png_voidp </b><i>s2</i><b>, png_size_t </b><i>size</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_voidp png_memcpy_check (png_structp </b><i>png_ptr</i><b>, png_voidp </b><i>s1</i><b>, png_voidp </b><i>s2</i><b>, png_uint_32 </b><i>size</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>voidp png_memset (png_voidp </b><i>s1</i><b>, int </b><i>value</i><b>, png_size_t </b><i>size</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_voidp png_memset_check (png_structp </b><i>png_ptr</i><b>, png_voidp </b><i>s1</i><b>, int </b><i>value</i><b>, png_uint_32 </b><i>size</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>DEPRECATED: void png_permit_empty_plte (png_structp </b><i>png_ptr</i><b>, int </b><i>empty_plte_permitted</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_process_data (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, png_bytep </b><i>buffer</i><b>, png_size_t </b><i>buffer_size</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_progressive_combine_row (png_structp </b><i>png_ptr</i><b>, png_bytep </b><i>old_row</i><b>, png_bytep </b><i>new_row</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_read_destroy (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, png_infop </b><i>end_info_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_read_end (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_read_image (png_structp </b><i>png_ptr</i><b>, png_bytepp </b><i>image</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>DEPRECATED: void png_read_init (png_structp </b><i>png_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>DEPRECATED: void png_read_init_2 (png_structpp </b><i>ptr_ptr</i><b>, png_const_charp </b><i>user_png_ver</i><b>, png_size_t </b><i>png_struct_size</i><b>, png_size_t </b><i>png_info_size</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_read_info (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_read_png (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, int </b><i>transforms</i><b>, png_voidp </b><i>params</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_read_row (png_structp </b><i>png_ptr</i><b>, png_bytep </b><i>row</i><b>, png_bytep </b><i>display_row</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_read_rows (png_structp </b><i>png_ptr</i><b>, png_bytepp </b><i>row</i><b>, png_bytepp </b><i>display_row</i><b>, png_uint_32 </b><i>num_rows</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_read_update_info (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>#if </b><i>!defined(PNG_1_0_X)</i><div style="height: 1.00em;">
&#160;</div>
<b>png_save_int_32 (png_bytep </b><i>buf</i><b>, png_int_32 </b><i>i</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_save_uint_16 (png_bytep </b><i>buf</i><b>, unsigned int </b><i>i</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_save_uint_32 (png_bytep </b><i>buf</i><b>, png_uint_32 </b><i>i</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_add_alpha (png_structp </b><i>png_ptr</i><b>, png_uint_32 </b><i>filler</i><b>, int </b><i>flags</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b>#endif</b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_background (png_structp </b><i>png_ptr</i><b>, png_color_16p </b><i>background_color</i><b>, int </b><i>background_gamma_code</i><b>, int </b><i>need_expand</i><b>, double </b><i>background_gamma</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_bgr (png_structp </b><i>png_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_bKGD (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, png_color_16p </b><i>background</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_cHRM (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, double </b><i>white_x</i><b>, double </b><i>white_y</i><b>, double </b><i>red_x</i><b>, double </b><i>red_y</i><b>, double </b><i>green_x</i><b>, double </b><i>green_y</i><b>, double </b><i>blue_x</i><b>, double </b><i>blue_y</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_cHRM_fixed (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, png_uint_32 </b><i>white_x</i><b>, png_uint_32 </b><i>white_y</i><b>, png_uint_32 </b><i>red_x</i><b>, png_uint_32 </b><i>red_y</i><b>, png_uint_32 </b><i>green_x</i><b>, png_uint_32 </b><i>green_y</i><b>, png_uint_32 </b><i>blue_x</i><b>, png_uint_32 </b><i>blue_y</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_compression_level (png_structp </b><i>png_ptr</i><b>, int </b><i>level</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_compression_mem_level (png_structp </b><i>png_ptr</i><b>, int </b><i>mem_level</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_compression_method (png_structp </b><i>png_ptr</i><b>, int </b><i>method</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_compression_strategy (png_structp </b><i>png_ptr</i><b>, int </b><i>strategy</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_compression_window_bits (png_structp </b><i>png_ptr</i><b>, int </b><i>window_bits</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_crc_action (png_structp </b><i>png_ptr</i><b>, int </b><i>crit_action</i><b>, int </b><i>ancil_action</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_dither (png_structp </b><i>png_ptr</i><b>, png_colorp </b><i>palette</i><b>, int </b><i>num_palette</i><b>, int </b><i>maximum_colors</i><b>, png_uint_16p </b><i>histogram</i><b>, int </b><i>full_dither</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_error_fn (png_structp </b><i>png_ptr</i><b>, png_voidp </b><i>error_ptr</i><b>, png_error_ptr </b><i>error_fn</i><b>, png_error_ptr </b><i>warning_fn</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_expand (png_structp </b><i>png_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_expand_gray_1_2_4_to_8(png_structp </b><i>png_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_filler (png_structp </b><i>png_ptr</i><b>, png_uint_32 </b><i>filler</i><b>, int </b><i>flags</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_filter (png_structp </b><i>png_ptr</i><b>, int </b><i>method</i><b>, int </b><i>filters</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_filter_heuristics (png_structp </b><i>png_ptr</i><b>, int </b><i>heuristic_method</i><b>, int </b><i>num_weights</i><b>, png_doublep </b><i>filter_weights</i><b>, png_doublep </b><i>filter_costs</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_flush (png_structp </b><i>png_ptr</i><b>, int </b><i>nrows</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_gamma (png_structp </b><i>png_ptr</i><b>, double </b><i>screen_gamma</i><b>, double </b><i>default_file_gamma</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_gAMA (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, double </b><i>file_gamma</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_gAMA_fixed (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, png_uint_32 </b><i>file_gamma</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_gray_1_2_4_to_8(png_structp </b><i>png_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_gray_to_rgb (png_structp </b><i>png_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_hIST (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, png_uint_16p </b><i>hist</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_iCCP (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, png_charp </b><i>name</i><b>, int </b><i>compression_type</i><b>, png_charp </b><i>profile</i><b>, png_uint_32 </b><i>proflen</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>int png_set_interlace_handling (png_structp </b><i>png_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_invalid (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, int </b><i>mask</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_invert_alpha (png_structp </b><i>png_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_invert_mono (png_structp </b><i>png_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_IHDR (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, png_uint_32 </b><i>width</i><b>, png_uint_32 </b><i>height</i><b>, int </b><i>bit_depth</i><b>, int </b><i>color_type</i><b>, int </b><i>interlace_type</i><b>, int </b><i>compression_type</i><b>, int </b><i>filter_type</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_keep_unknown_chunks (png_structp </b><i>png_ptr</i><b>, int </b><i>keep</i><b>, png_bytep </b><i>chunk_list</i><b>, int </b><i>num_chunks</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_mem_fn(png_structp </b><i>png_ptr</i><b>, png_voidp </b><i>mem_ptr</i><b>, png_malloc_ptr </b><i>malloc_fn</i><b>, png_free_ptr </b><i>free_fn</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_oFFs (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, png_uint_32 </b><i>offset_x</i><b>, png_uint_32 </b><i>offset_y</i><b>, int </b><i>unit_type</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_packing (png_structp </b><i>png_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_packswap (png_structp </b><i>png_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_palette_to_rgb(png_structp </b><i>png_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_pCAL (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, png_charp </b><i>purpose</i><b>, png_int_32 </b><i>X0</i><b>, png_int_32 </b><i>X1</i><b>, int </b><i>type</i><b>, int </b><i>nparams</i><b>, png_charp </b><i>units</i><b>, png_charpp </b><i>params</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_pHYs (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, png_uint_32 </b><i>res_x</i><b>, png_uint_32 </b><i>res_y</i><b>, int </b><i>unit_type</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_progressive_read_fn (png_structp </b><i>png_ptr</i><b>, png_voidp </b><i>progressive_ptr</i><b>, png_progressive_info_ptr </b><i>info_fn</i><b>, png_progressive_row_ptr </b><i>row_fn</i><b>, png_progressive_end_ptr </b><i>end_fn</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_PLTE (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, png_colorp </b><i>palette</i><b>, int </b><i>num_palette</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_read_fn (png_structp </b><i>png_ptr</i><b>, png_voidp </b><i>io_ptr</i><b>, png_rw_ptr </b><i>read_data_fn</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_read_status_fn (png_structp </b><i>png_ptr</i><b>, png_read_status_ptr </b><i>read_row_fn</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_read_user_transform_fn (png_structp </b><i>png_ptr</i><b>, png_user_transform_ptr </b><i>read_user_transform_fn</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_rgb_to_gray (png_structp </b><i>png_ptr</i><b>, int </b><i>error_action</i><b>, double </b><i>red</i><b>, double </b><i>green</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_rgb_to_gray_fixed (png_structp </b><i>png_ptr</i><b>, int error_action png_fixed_point </b><i>red</i><b>, png_fixed_point </b><i>green</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_rows (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, png_bytepp </b><i>row_pointers</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_sBIT (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, png_color_8p </b><i>sig_bit</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_sCAL (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, png_charp </b><i>unit</i><b>, double </b><i>width</i><b>, double </b><i>height</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_shift (png_structp </b><i>png_ptr</i><b>, png_color_8p </b><i>true_bits</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_sig_bytes (png_structp </b><i>png_ptr</i><b>, int </b><i>num_bytes</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_sPLT (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, png_spalette_p </b><i>splt_ptr</i><b>, int </b><i>num_spalettes</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_sRGB (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, int </b><i>intent</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_sRGB_gAMA_and_cHRM (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, int </b><i>intent</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_strip_16 (png_structp </b><i>png_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_strip_alpha (png_structp </b><i>png_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_swap (png_structp </b><i>png_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_swap_alpha (png_structp </b><i>png_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_text (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, png_textp </b><i>text_ptr</i><b>, int </b><i>num_text</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_tIME (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, png_timep </b><i>mod_time</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_tRNS (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, png_bytep </b><i>trans</i><b>, int </b><i>num_trans</i><b>, png_color_16p </b><i>trans_values</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_tRNS_to_alpha(png_structp </b><i>png_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>png_uint_32 png_set_unknown_chunks (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, png_unknown_chunkp </b><i>unknowns</i><b>, int </b><i>num</i><b>, int </b><i>location</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_unknown_chunk_location(png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, int </b><i>chunk</i><b>, int </b><i>location</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_read_user_chunk_fn (png_structp </b><i>png_ptr</i><b>, png_voidp </b><i>user_chunk_ptr</i><b>, png_user_chunk_ptr </b><i>read_user_chunk_fn</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_user_limits (png_structp </b><i>png_ptr</i><b>, png_uint_32 </b><i>user_width_max</i><b>, png_uint_32 </b><i>user_height_max</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_user_transform_info (png_structp </b><i>png_ptr</i><b>, png_voidp </b><i>user_transform_ptr</i><b>, int </b><i>user_transform_depth</i><b>, int </b><i>user_transform_channels</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_write_fn (png_structp </b><i>png_ptr</i><b>, png_voidp </b><i>io_ptr</i><b>, png_rw_ptr </b><i>write_data_fn</i><b>, png_flush_ptr </b><i>output_flush_fn</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_write_status_fn (png_structp </b><i>png_ptr</i><b>, png_write_status_ptr </b><i>write_row_fn</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_write_user_transform_fn (png_structp </b><i>png_ptr</i><b>, png_user_transform_ptr </b><i>write_user_transform_fn</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_set_compression_buffer_size(png_structp </b><i>png_ptr</i><b>, png_uint_32 </b><i>size</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>int png_sig_cmp (png_bytep </b><i>sig</i><b>, png_size_t </b><i>start</i><b>, png_size_t </b><i>num_to_check</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_start_read_image (png_structp </b><i>png_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_warning (png_structp </b><i>png_ptr</i><b>, png_const_charp </b><i>message</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_write_chunk (png_structp </b><i>png_ptr</i><b>, png_bytep </b><i>chunk_name</i><b>, png_bytep </b><i>data</i><b>, png_size_t </b><i>length</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_write_chunk_data (png_structp </b><i>png_ptr</i><b>, png_bytep </b><i>data</i><b>, png_size_t </b><i>length</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_write_chunk_end (png_structp </b><i>png_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_write_chunk_start (png_structp </b><i>png_ptr</i><b>, png_bytep </b><i>chunk_name</i><b>, png_uint_32 </b><i>length</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_write_destroy (png_structp </b><i>png_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_write_end (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_write_flush (png_structp </b><i>png_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_write_image (png_structp </b><i>png_ptr</i><b>, png_bytepp </b><i>image</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>DEPRECATED: void png_write_init (png_structp </b><i>png_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>DEPRECATED: void png_write_init_2 (png_structpp </b><i>ptr_ptr</i><b>, png_const_charp </b><i>user_png_ver</i><b>, png_size_t </b><i>png_struct_size</i><b>, png_size_t </b><i>png_info_size</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_write_info (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_write_info_before_PLTE (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_write_png (png_structp </b><i>png_ptr</i><b>, png_infop </b><i>info_ptr</i><b>, int </b><i>transforms</i><b>, png_voidp </b><i>params</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_write_row (png_structp </b><i>png_ptr</i><b>, png_bytep </b><i>row</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_write_rows (png_structp </b><i>png_ptr</i><b>, png_bytepp </b><i>row</i><b>, png_uint_32 </b><i>num_rows</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>voidpf png_zalloc (voidpf </b><i>png_ptr</i><b>, uInt </b><i>items</i><b>, uInt </b><i>size</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
<b>void png_zfree (voidpf </b><i>png_ptr</i><b>, voidpf </b><i>ptr</i><b></b><b>);</b><b></b><div style="height: 1.00em;">
&#160;</div>
<i></i><b></b><div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>DESCRIPTION</h1> The <i>libpng</i> library supports encoding, decoding, and various manipulations of the Portable Network Graphics (PNG) format image files.  It uses the <i>zlib(3)</i> compression library. Following is a copy of the libpng.txt file that accompanies libpng.</div>
<div class="section">
<h1>LIBPNG.TXT</h1> libpng.txt - A description on how to use and modify libpng<div style="height: 1.00em;">
&#160;</div>
<br/>
 libpng version 1.2.46 - July 9, 2011<br/>
 Updated and distributed by Glenn Randers-Pehrson<br/>
 &lt;glennrp at users.sourceforge.net&gt;<br/>
 Copyright (c) 1998-2009 Glenn Randers-Pehrson<div style="height: 1.00em;">
&#160;</div>
<br/>
 This document is released under the libpng license.<br/>
 For conditions of distribution and use, see the disclaimer<br/>
 and license in png.h<div style="height: 1.00em;">
&#160;</div>
<br/>
 Based on:<div style="height: 1.00em;">
&#160;</div>
<br/>
 libpng versions 0.97, January 1998, through 1.2.46 - July 9, 2011<br/>
 Updated and distributed by Glenn Randers-Pehrson<br/>
 Copyright (c) 1998-2009 Glenn Randers-Pehrson<div style="height: 1.00em;">
&#160;</div>
<br/>
 libpng 1.0 beta 6  version 0.96 May 28, 1997<br/>
 Updated and distributed by Andreas Dilger<br/>
 Copyright (c) 1996, 1997 Andreas Dilger<div style="height: 1.00em;">
&#160;</div>
<br/>
 libpng 1.0 beta 2 - version 0.88  January 26, 1996<br/>
 For conditions of distribution and use, see copyright<br/>
 notice in png.h. Copyright (c) 1995, 1996 Guy Eric<br/>
 Schalnat, Group 42, Inc.<div style="height: 1.00em;">
&#160;</div>
<br/>
 Updated/rewritten per request in the libpng FAQ<br/>
 Copyright (c) 1995, 1996 Frank J. T. Wojcik<br/>
 December 18, 1995 &amp; January 20, 1996<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>I. Introduction</h1> This file describes how to use and modify the PNG reference library (known as libpng) for your own use.  There are five sections to this file: introduction, structures, reading, writing, and modification and configuration notes for various special platforms.  In addition to this file, example.c is a good starting point for using the library, as it is heavily commented and should include everything most people will need.  We assume that libpng is already installed; see the INSTALL file for instructions on how to install libpng.<div style="height: 1.00em;">
&#160;</div>
For examples of libpng usage, see the files &quot;example.c&quot;, &quot;pngtest.c&quot;, and the files in the &quot;contrib&quot; directory, all of which are included in the libpng distribution.<div style="height: 1.00em;">
&#160;</div>
Libpng was written as a companion to the PNG specification, as a way of reducing the amount of time and effort it takes to support the PNG file format in application programs.<div style="height: 1.00em;">
&#160;</div>
The PNG specification (second edition), November 2003, is available as a W3C Recommendation and as an ISO Standard (ISO/IEC 15948:2003 (E)) at &lt;http://www.w3.org/TR/2003/REC-PNG-20031110/ The W3C and ISO documents have identical technical content.<div style="height: 1.00em;">
&#160;</div>
The PNG-1.2 specification is available at &lt;http://www.libpng.org/pub/png/documents/&gt;.  It is technically equivalent to the PNG specification (second edition) but has some additional material.<div style="height: 1.00em;">
&#160;</div>
The PNG-1.0 specification is available as RFC 2083 &lt;http://www.libpng.org/pub/png/documents/&gt; and as a W3C Recommendation &lt;http://www.w3.org/TR/REC.png.html&gt;.<div style="height: 1.00em;">
&#160;</div>
Some additional chunks are described in the special-purpose public chunks documents at &lt;http://www.libpng.org/pub/png/documents/&gt;.<div style="height: 1.00em;">
&#160;</div>
Other information about PNG, and the latest version of libpng, can be found at the PNG home page, &lt;http://www.libpng.org/pub/png/&gt;.<div style="height: 1.00em;">
&#160;</div>
Most users will not have to modify the library significantly; advanced users may want to modify it more.  All attempts were made to make it as complete as possible, while keeping the code easy to understand. Currently, this library only supports C.  Support for other languages is being considered.<div style="height: 1.00em;">
&#160;</div>
Libpng has been designed to handle multiple sessions at one time, to be easily modifiable, to be portable to the vast majority of machines (ANSI, K&amp;R, 16-, 32-, and 64-bit) available, and to be easy to use.  The ultimate goal of libpng is to promote the acceptance of the PNG file format in whatever way possible.  While there is still work to be done (see the TODO file), libpng should cover the majority of the needs of its users.<div style="height: 1.00em;">
&#160;</div>
Libpng uses zlib for its compression and decompression of PNG files. Further information about zlib, and the latest version of zlib, can be found at the zlib home page, &lt;http://www.info-zip.org/pub/infozip/zlib/&gt;. The zlib compression utility is a general purpose utility that is useful for more than PNG files, and can be used without libpng. See the documentation delivered with zlib for more details. You can usually find the source files for the zlib utility wherever you find the libpng source files.<div style="height: 1.00em;">
&#160;</div>
Libpng is thread safe, provided the threads are using different instances of the structures.  Each thread should have its own png_struct and png_info instances, and thus its own image. Libpng does not protect itself against two threads using the same instance of a structure.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>II. Structures</h1> There are two main structures that are important to libpng, png_struct and png_info.  The first, png_struct, is an internal structure that will not, for the most part, be used by a user except as the first variable passed to every libpng function call.<div style="height: 1.00em;">
&#160;</div>
The png_info structure is designed to provide information about the PNG file.  At one time, the fields of png_info were intended to be directly accessible to the user.  However, this tended to cause problems with applications using dynamically loaded libraries, and as a result a set of interface functions for png_info (the png_get_*() and png_set_*() functions) was developed.  The fields of png_info are still available for older applications, but it is suggested that applications use the new interfaces if at all possible.<div style="height: 1.00em;">
&#160;</div>
Applications that do make direct access to the members of png_struct (except for png_ptr-&gt;jmpbuf) must be recompiled whenever the library is updated, and applications that make direct access to the members of png_info must be recompiled if they were compiled or loaded with libpng version 1.0.6, in which the members were in a different order.  In version 1.0.7, the members of the png_info structure reverted to the old order, as they were in versions 0.97c through 1.0.5.  Starting with version 2.0.0, both structures are going to be hidden, and the contents of the structures will only be accessible through the png_get/png_set functions.<div style="height: 1.00em;">
&#160;</div>
The png.h header file is an invaluable reference for programming with libpng. And while I'm on the topic, make sure you include the libpng header file:<div style="height: 1.00em;">
&#160;</div>
#include &lt;png.h&gt;<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>III. Reading</h1> We'll now walk you through the possible functions to call when reading in a PNG file sequentially, briefly explaining the syntax and purpose of each one.  See example.c and png.h for more detail.  While progressive reading is covered in the next section, you will still need some of the functions discussed in this section to read a PNG file.<div style="height: 1.00em;">
&#160;</div>
<div class="subsection">
<h2>Setup</h2> You will want to do the I/O initialization(*) before you get into libpng, so if it doesn't work, you don't have much to undo.  Of course, you will also want to insure that you are, in fact, dealing with a PNG file.  Libpng provides a simple check to see if a file is a PNG file. To use it, pass in the first 1 to 8 bytes of the file to the function png_sig_cmp(), and it will return 0 (false) if the bytes match the corresponding bytes of the PNG signature, or nonzero (true) otherwise. Of course, the more bytes you pass in, the greater the accuracy of the prediction.<div style="height: 1.00em;">
&#160;</div>
If you are intending to keep the file pointer open for use in libpng, you must ensure you don't read more than 8 bytes from the beginning of the file, and you also have to make a call to png_set_sig_bytes_read() with the number of bytes you read from the beginning.  Libpng will then only check the bytes (if any) that your program didn't read.<div style="height: 1.00em;">
&#160;</div>
(*): If you are not using the standard I/O functions, you will need to replace them with custom functions.  See the discussion under Customizing libpng.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<br/>
    FILE *fp = fopen(file_name, &quot;rb&quot;);<br/>
    if (!fp)<br/>
    {<br/>
        return (ERROR);<br/>
    }<br/>
    fread(header, 1, number, fp);<br/>
    is_png = !png_sig_cmp(header, 0, number);<br/>
    if (!is_png)<br/>
    {<br/>
        return (NOT_PNG);<br/>
    }<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
Next, png_struct and png_info need to be allocated and initialized.  In order to ensure that the size of these structures is correct even with a dynamically linked libpng, there are functions to initialize and allocate the structures.  We also pass the library version, optional pointers to error handling functions, and a pointer to a data struct for use by the error functions, if necessary (the pointer and functions can be NULL if the default error handlers are to be used).  See the section on Changes to Libpng below regarding the old initialization functions. The structure allocation functions quietly return NULL if they fail to create the structure, so your application should check for that.<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_structp png_ptr = png_create_read_struct<br/>
       (PNG_LIBPNG_VER_STRING, (png_voidp)user_error_ptr,<br/>
        user_error_fn, user_warning_fn);<br/>
    if (!png_ptr)<br/>
        return (ERROR);<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_infop info_ptr = png_create_info_struct(png_ptr);<br/>
    if (!info_ptr)<br/>
    {<br/>
        png_destroy_read_struct(&amp;png_ptr,<br/>
           (png_infopp)NULL, (png_infopp)NULL);<br/>
        return (ERROR);<br/>
    }<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_infop end_info = png_create_info_struct(png_ptr);<br/>
    if (!end_info)<br/>
    {<br/>
        png_destroy_read_struct(&amp;png_ptr, &amp;info_ptr,<br/>
          (png_infopp)NULL);<br/>
        return (ERROR);<br/>
    }<div style="height: 1.00em;">
&#160;</div>
If you want to use your own memory allocation routines, define PNG_USER_MEM_SUPPORTED and use png_create_read_struct_2() instead of png_create_read_struct():<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_structp png_ptr = png_create_read_struct_2<br/>
       (PNG_LIBPNG_VER_STRING, (png_voidp)user_error_ptr,<br/>
        user_error_fn, user_warning_fn, (png_voidp)<br/>
        user_mem_ptr, user_malloc_fn, user_free_fn);<div style="height: 1.00em;">
&#160;</div>
The error handling routines passed to png_create_read_struct() and the memory alloc/free routines passed to png_create_struct_2() are only necessary if you are not using the libpng supplied error handling and memory alloc/free functions.<div style="height: 1.00em;">
&#160;</div>
When libpng encounters an error, it expects to longjmp back to your routine.  Therefore, you will need to call setjmp and pass your png_jmpbuf(png_ptr).  If you read the file from different routines, you will need to update the jmpbuf field every time you enter a new routine that will call a png_*() function.<div style="height: 1.00em;">
&#160;</div>
See your documentation of setjmp/longjmp for your compiler for more information on setjmp/longjmp.  See the discussion on libpng error handling in the Customizing Libpng section below for more information on the libpng error handling.  If an error occurs, and libpng longjmp's back to your setjmp, you will want to call png_destroy_read_struct() to free any memory.<div style="height: 1.00em;">
&#160;</div>
<br/>
    if (setjmp(png_jmpbuf(png_ptr)))<br/>
    {<br/>
        png_destroy_read_struct(&amp;png_ptr, &amp;info_ptr,<br/>
           &amp;end_info);<br/>
        fclose(fp);<br/>
        return (ERROR);<br/>
    }<div style="height: 1.00em;">
&#160;</div>
If you would rather avoid the complexity of setjmp/longjmp issues, you can compile libpng with PNG_SETJMP_NOT_SUPPORTED, in which case errors will result in a call to PNG_ABORT() which defaults to abort().<div style="height: 1.00em;">
&#160;</div>
Now you need to set up the input code.  The default for libpng is to use the C function fread().  If you use this, you will need to pass a valid FILE * in the function png_init_io().  Be sure that the file is opened in binary mode.  If you wish to handle reading data in another way, you need not call the png_init_io() function, but you must then implement the libpng I/O methods discussed in the Customizing Libpng section below.<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_init_io(png_ptr, fp);<div style="height: 1.00em;">
&#160;</div>
If you had previously opened the file and read any of the signature from the beginning in order to see if this was a PNG file, you need to let libpng know that there are some bytes missing from the start of the file.<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_sig_bytes(png_ptr, number);<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>Setting up callback code</h2> You can set up a callback function to handle any unknown chunks in the input stream. You must supply the function<div style="height: 1.00em;">
&#160;</div>
<br/>
    read_chunk_callback(png_ptr ptr,<br/>
         png_unknown_chunkp chunk);<br/>
    {<br/>
       /* The unknown chunk structure contains your<br/>
          chunk data, along with similar data for any other<br/>
          unknown chunks: */<div style="height: 1.00em;">
&#160;</div>
<br/>
           png_byte name[5];<br/>
           png_byte *data;<br/>
           png_size_t size;<div style="height: 1.00em;">
&#160;</div>
<br/>
       /* Note that libpng has already taken care of<br/>
          the CRC handling */<div style="height: 1.00em;">
&#160;</div>
<br/>
       /* put your code here.  Search for your chunk in the<br/>
          unknown chunk structure, process it, and return one<br/>
          of the following: */<div style="height: 1.00em;">
&#160;</div>
<br/>
       return (-n); /* chunk had an error */<br/>
       return (0); /* did not recognize */<br/>
       return (n); /* success */<br/>
    }<div style="height: 1.00em;">
&#160;</div>
(You can give your function another name that you like instead of &quot;read_chunk_callback&quot;)<div style="height: 1.00em;">
&#160;</div>
To inform libpng about your function, use<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_read_user_chunk_fn(png_ptr, user_chunk_ptr,<br/>
        read_chunk_callback);<div style="height: 1.00em;">
&#160;</div>
This names not only the callback function, but also a user pointer that you can retrieve with<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_get_user_chunk_ptr(png_ptr);<div style="height: 1.00em;">
&#160;</div>
If you call the png_set_read_user_chunk_fn() function, then all unknown chunks will be saved when read, in case your callback function will need one or more of them.  This behavior can be changed with the png_set_keep_unknown_chunks() function, described below.<div style="height: 1.00em;">
&#160;</div>
At this point, you can set up a callback function that will be called after each row has been read, which you can use to control a progress meter or the like.  It's demonstrated in pngtest.c. You must supply a function<div style="height: 1.00em;">
&#160;</div>
<br/>
    void read_row_callback(png_ptr ptr, png_uint_32 row,<br/>
       int pass);<br/>
    {<br/>
      /* put your code here */<br/>
    }<div style="height: 1.00em;">
&#160;</div>
(You can give it another name that you like instead of &quot;read_row_callback&quot;)<div style="height: 1.00em;">
&#160;</div>
To inform libpng about your function, use<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_read_status_fn(png_ptr, read_row_callback);<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>Unknown-chunk handling</h2> Now you get to set the way the library processes unknown chunks in the input PNG stream. Both known and unknown chunks will be read.  Normal behavior is that known chunks will be parsed into information in various info_ptr members while unknown chunks will be discarded. This behavior can be wasteful if your application will never use some known chunk types. To change this, you can call:<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_keep_unknown_chunks(png_ptr, keep,<br/>
        chunk_list, num_chunks);<br/>
    keep       - 0: default unknown chunk handling<br/>
                 1: ignore; do not keep<br/>
                 2: keep only if safe-to-copy<br/>
                 3: keep even if unsafe-to-copy<br/>
               You can use these definitions:<br/>
                 PNG_HANDLE_CHUNK_AS_DEFAULT   0<br/>
                 PNG_HANDLE_CHUNK_NEVER        1<br/>
                 PNG_HANDLE_CHUNK_IF_SAFE      2<br/>
                 PNG_HANDLE_CHUNK_ALWAYS       3<br/>
    chunk_list - list of chunks affected (a byte string,<br/>
                 five bytes per chunk, NULL or '&#8194;' if<br/>
                 num_chunks is 0)<br/>
    num_chunks - number of chunks affected; if 0, all<br/>
                 unknown chunks are affected.  If nonzero,<br/>
                 only the chunks in the list are affected<div style="height: 1.00em;">
&#160;</div>
Unknown chunks declared in this way will be saved as raw data onto a list of png_unknown_chunk structures.  If a chunk that is normally known to libpng is named in the list, it will be handled as unknown, according to the &quot;keep&quot; directive.  If a chunk is named in successive instances of png_set_keep_unknown_chunks(), the final instance will take precedence.  The IHDR and IEND chunks should not be named in chunk_list; if they are, libpng will process them normally anyway.<div style="height: 1.00em;">
&#160;</div>
Here is an example of the usage of png_set_keep_unknown_chunks(), where the private &quot;vpAg&quot; chunk will later be processed by a user chunk callback function:<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_byte vpAg[5]={118, 112,  65, 103, (png_byte) '&#8194;'};<div style="height: 1.00em;">
&#160;</div>
<br/>
    #if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)<br/>
      png_byte unused_chunks[]=<br/>
      {<br/>
        104,  73,  83,  84, (png_byte) '&#8194;',   /* hIST */<br/>
        105,  84,  88, 116, (png_byte) '&#8194;',   /* iTXt */<br/>
        112,  67,  65,  76, (png_byte) '&#8194;',   /* pCAL */<br/>
        115,  67,  65,  76, (png_byte) '&#8194;',   /* sCAL */<br/>
        115,  80,  76,  84, (png_byte) '&#8194;',   /* sPLT */<br/>
        116,  73,  77,  69, (png_byte) '&#8194;',   /* tIME */<br/>
      };<br/>
    #endif<div style="height: 1.00em;">
&#160;</div>
<br/>
    ...<div style="height: 1.00em;">
&#160;</div>
<br/>
    #if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)<br/>
      /* ignore all unknown chunks: */<br/>
      png_set_keep_unknown_chunks(read_ptr, 1, NULL, 0);<br/>
      /* except for vpAg: */<br/>
      png_set_keep_unknown_chunks(read_ptr, 2, vpAg, 1);<br/>
      /* also ignore unused known chunks: */<br/>
      png_set_keep_unknown_chunks(read_ptr, 1, unused_chunks,<br/>
         (int)sizeof(unused_chunks)/5);<br/>
    #endif<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>User limits</h2> The PNG specification allows the width and height of an image to be as large as 2^31-1 (0x7fffffff), or about 2.147 billion rows and columns. Since very few applications really need to process such large images, we have imposed an arbitrary 1-million limit on rows and columns. Larger images will be rejected immediately with a png_error() call. If you wish to override this limit, you can use<div style="height: 1.00em;">
&#160;</div>
<br/>
   png_set_user_limits(png_ptr, width_max, height_max);<div style="height: 1.00em;">
&#160;</div>
to set your own limits, or use width_max = height_max = 0x7fffffffL to allow all valid dimensions (libpng may reject some very large images anyway because of potential buffer overflow conditions).<div style="height: 1.00em;">
&#160;</div>
You should put this statement after you create the PNG structure and before calling png_read_info(), png_read_png(), or png_process_data(). If you need to retrieve the limits that are being applied, use<div style="height: 1.00em;">
&#160;</div>
<br/>
   width_max = png_get_user_width_max(png_ptr);<br/>
   height_max = png_get_user_height_max(png_ptr);<div style="height: 1.00em;">
&#160;</div>
The PNG specification sets no limit on the number of ancillary chunks allowed in a PNG datastream.  You can impose a limit on the total number of sPLT, tEXt, iTXt, zTXt, and unknown chunks that will be stored, with<div style="height: 1.00em;">
&#160;</div>
<br/>
   png_set_chunk_cache_max(png_ptr, user_chunk_cache_max);<div style="height: 1.00em;">
&#160;</div>
where 0x7fffffffL means unlimited.  You can retrieve this limit with<div style="height: 1.00em;">
&#160;</div>
<br/>
   chunk_cache_max = png_get_chunk_cache_max(png_ptr);<div style="height: 1.00em;">
&#160;</div>
This limit also applies to the number of buffers that can be allocated by png_decompress_chunk() while decompressing iTXt, zTXt, and iCCP chunks.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>The high-level read interface</h2> At this point there are two ways to proceed; through the high-level read interface, or through a sequence of low-level read operations. You can use the high-level interface if (a) you are willing to read the entire image into memory, and (b) the input transformations you want to do are limited to the following set:<div style="height: 1.00em;">
&#160;</div>
<br/>
    PNG_TRANSFORM_IDENTITY      No transformation<br/>
    PNG_TRANSFORM_STRIP_16      Strip 16-bit samples to<br/>
                                8 bits<br/>
    PNG_TRANSFORM_STRIP_ALPHA   Discard the alpha channel<br/>
    PNG_TRANSFORM_PACKING       Expand 1, 2 and 4-bit<br/>
                                samples to bytes<br/>
    PNG_TRANSFORM_PACKSWAP      Change order of packed<br/>
                                pixels to LSB first<br/>
    PNG_TRANSFORM_EXPAND        Perform set_expand()<br/>
    PNG_TRANSFORM_INVERT_MONO   Invert monochrome images<br/>
    PNG_TRANSFORM_SHIFT         Normalize pixels to the<br/>
                                sBIT depth<br/>
    PNG_TRANSFORM_BGR           Flip RGB to BGR, RGBA<br/>
                                to BGRA<br/>
    PNG_TRANSFORM_SWAP_ALPHA    Flip RGBA to ARGB or GA<br/>
                                to AG<br/>
    PNG_TRANSFORM_INVERT_ALPHA  Change alpha from opacity<br/>
                                to transparency<br/>
    PNG_TRANSFORM_SWAP_ENDIAN   Byte-swap 16-bit samples<br/>
    PNG_TRANSFORM_GRAY_TO_RGB   Expand grayscale samples<br/>
                                to RGB (or GA to RGBA)<div style="height: 1.00em;">
&#160;</div>
(This excludes setting a background color, doing gamma transformation, dithering, and setting filler.)  If this is the case, simply do this:<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_read_png(png_ptr, info_ptr, png_transforms, NULL)<div style="height: 1.00em;">
&#160;</div>
where png_transforms is an integer containing the bitwise OR of some set of transformation flags.  This call is equivalent to png_read_info(), followed the set of transformations indicated by the transform mask, then png_read_image(), and finally png_read_end().<div style="height: 1.00em;">
&#160;</div>
(The final parameter of this call is not yet used.  Someday it might point to transformation parameters required by some future input transform.)<div style="height: 1.00em;">
&#160;</div>
You must use png_transforms and not call any png_set_transform() functions when you use png_read_png().<div style="height: 1.00em;">
&#160;</div>
After you have called png_read_png(), you can retrieve the image data with<div style="height: 1.00em;">
&#160;</div>
<br/>
   row_pointers = png_get_rows(png_ptr, info_ptr);<div style="height: 1.00em;">
&#160;</div>
where row_pointers is an array of pointers to the pixel data for each row:<div style="height: 1.00em;">
&#160;</div>
<br/>
   png_bytep row_pointers[height];<div style="height: 1.00em;">
&#160;</div>
If you know your image size and pixel size ahead of time, you can allocate row_pointers prior to calling png_read_png() with<div style="height: 1.00em;">
&#160;</div>
<br/>
   if (height &gt; PNG_UINT_32_MAX/png_sizeof(png_byte))<br/>
      png_error (png_ptr,<br/>
         &quot;Image is too tall to process in memory&quot;);<br/>
   if (width &gt; PNG_UINT_32_MAX/pixel_size)<br/>
      png_error (png_ptr,<br/>
         &quot;Image is too wide to process in memory&quot;);<br/>
   row_pointers = png_malloc(png_ptr,<br/>
      height*png_sizeof(png_bytep));<br/>
   for (int i=0; i&lt;height, i++)<br/>
      row_pointers[i]=NULL;  /* security precaution */<br/>
   for (int i=0; i&lt;height, i++)<br/>
      row_pointers[i]=png_malloc(png_ptr,<br/>
         width*pixel_size);<br/>
   png_set_rows(png_ptr, info_ptr, &amp;row_pointers);<div style="height: 1.00em;">
&#160;</div>
Alternatively you could allocate your image in one big block and define row_pointers[i] to point into the proper places in your block.<div style="height: 1.00em;">
&#160;</div>
If you use png_set_rows(), the application is responsible for freeing row_pointers (and row_pointers[i], if they were separately allocated).<div style="height: 1.00em;">
&#160;</div>
If you don't allocate row_pointers ahead of time, png_read_png() will do it, and it'll be free'ed when you call png_destroy_*().<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>The low-level read interface</h2> If you are going the low-level route, you are now ready to read all the file information up to the actual image data.  You do this with a call to png_read_info().<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_read_info(png_ptr, info_ptr);<div style="height: 1.00em;">
&#160;</div>
This will process all chunks up to but not including the image data.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>Querying the info structure</h2> Functions are used to get the information from the info_ptr once it has been read.  Note that these fields may not be completely filled in until png_read_end() has read the chunk data following the image.<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_get_IHDR(png_ptr, info_ptr, &amp;width, &amp;height,<br/>
       &amp;bit_depth, &amp;color_type, &amp;interlace_type,<br/>
       &amp;compression_type, &amp;filter_method);<div style="height: 1.00em;">
&#160;</div>
<br/>
    width          - holds the width of the image<br/>
                     in pixels (up to 2^31).<br/>
    height         - holds the height of the image<br/>
                     in pixels (up to 2^31).<br/>
    bit_depth      - holds the bit depth of one of the<br/>
                     image channels.  (valid values are<br/>
                     1, 2, 4, 8, 16 and depend also on<br/>
                     the color_type.  See also<br/>
                     significant bits (sBIT) below).<br/>
    color_type     - describes which color/alpha channels<br/>
                         are present.<br/>
                     PNG_COLOR_TYPE_GRAY<br/>
                        (bit depths 1, 2, 4, 8, 16)<br/>
                     PNG_COLOR_TYPE_GRAY_ALPHA<br/>
                        (bit depths 8, 16)<br/>
                     PNG_COLOR_TYPE_PALETTE<br/>
                        (bit depths 1, 2, 4, 8)<br/>
                     PNG_COLOR_TYPE_RGB<br/>
                        (bit_depths 8, 16)<br/>
                     PNG_COLOR_TYPE_RGB_ALPHA<br/>
                        (bit_depths 8, 16)<div style="height: 1.00em;">
&#160;</div>
<br/>
                     PNG_COLOR_MASK_PALETTE<br/>
                     PNG_COLOR_MASK_COLOR<br/>
                     PNG_COLOR_MASK_ALPHA<div style="height: 1.00em;">
&#160;</div>
<br/>
    filter_method  - (must be PNG_FILTER_TYPE_BASE<br/>
                     for PNG 1.0, and can also be<br/>
                     PNG_INTRAPIXEL_DIFFERENCING if<br/>
                     the PNG datastream is embedded in<br/>
                     a MNG-1.0 datastream)<br/>
    compression_type - (must be PNG_COMPRESSION_TYPE_BASE<br/>
                     for PNG 1.0)<br/>
    interlace_type - (PNG_INTERLACE_NONE or<br/>
                     PNG_INTERLACE_ADAM7)<div style="height: 1.00em;">
&#160;</div>
<br/>
    Any or all of interlace_type, compression_type, or<br/>
    filter_method can be NULL if you are<br/>
    not interested in their values.<div style="height: 1.00em;">
&#160;</div>
<br/>
    Note that png_get_IHDR() returns 32-bit data into<br/>
    the application's width and height variables.<br/>
    This is an unsafe situation if these are 16-bit<br/>
    variables.  In such situations, the<br/>
    png_get_image_width() and png_get_image_height()<br/>
    functions described below are safer.<div style="height: 1.00em;">
&#160;</div>
<br/>
    width            = png_get_image_width(png_ptr,<br/>
                         info_ptr);<br/>
    height           = png_get_image_height(png_ptr,<br/>
                         info_ptr);<br/>
    bit_depth        = png_get_bit_depth(png_ptr,<br/>
                         info_ptr);<br/>
    color_type       = png_get_color_type(png_ptr,<br/>
                         info_ptr);<br/>
    filter_method    = png_get_filter_type(png_ptr,<br/>
                         info_ptr);<br/>
    compression_type = png_get_compression_type(png_ptr,<br/>
                         info_ptr);<br/>
    interlace_type   = png_get_interlace_type(png_ptr,<br/>
                         info_ptr);<div style="height: 1.00em;">
&#160;</div>
<br/>
    channels = png_get_channels(png_ptr, info_ptr);<br/>
    channels       - number of channels of info for the<br/>
                     color type (valid values are 1 (GRAY,<br/>
                     PALETTE), 2 (GRAY_ALPHA), 3 (RGB),<br/>
                     4 (RGB_ALPHA or RGB + filler byte))<br/>
    rowbytes = png_get_rowbytes(png_ptr, info_ptr);<br/>
    rowbytes       - number of bytes needed to hold a row<div style="height: 1.00em;">
&#160;</div>
<br/>
    signature = png_get_signature(png_ptr, info_ptr);<br/>
    signature      - holds the signature read from the<br/>
                     file (if any).  The data is kept in<br/>
                     the same offset it would be if the<br/>
                     whole signature were read (i.e. if an<br/>
                     application had already read in 4<br/>
                     bytes of signature before starting<br/>
                     libpng, the remaining 4 bytes would<br/>
                     be in signature[4] through signature[7]<br/>
                     (see png_set_sig_bytes())).<div style="height: 1.00em;">
&#160;</div>
These are also important, but their validity depends on whether the chunk has been read.  The png_get_valid(png_ptr, info_ptr, PNG_INFO_&lt;chunk&gt;) and png_get_&lt;chunk&gt;(png_ptr, info_ptr, ...) functions return non-zero if the data has been read, or zero if it is missing.  The parameters to the png_get_&lt;chunk&gt; are set directly if they are simple data types, or a pointer into the info_ptr is returned for any complex types.<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_get_PLTE(png_ptr, info_ptr, &amp;palette,<br/>
                     &amp;num_palette);<br/>
    palette        - the palette for the file<br/>
                     (array of png_color)<br/>
    num_palette    - number of entries in the palette<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_get_gAMA(png_ptr, info_ptr, &amp;gamma);<br/>
    gamma          - the gamma the file is written<br/>
                     at (PNG_INFO_gAMA)<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_get_sRGB(png_ptr, info_ptr, &amp;srgb_intent);<br/>
    srgb_intent    - the rendering intent (PNG_INFO_sRGB)<br/>
                     The presence of the sRGB chunk<br/>
                     means that the pixel data is in the<br/>
                     sRGB color space.  This chunk also<br/>
                     implies specific values of gAMA and<br/>
                     cHRM.<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_get_iCCP(png_ptr, info_ptr, &amp;name,<br/>
       &amp;compression_type, &amp;profile, &amp;proflen);<br/>
    name            - The profile name.<br/>
    compression     - The compression type; always<br/>
                      PNG_COMPRESSION_TYPE_BASE for PNG 1.0.<br/>
                      You may give NULL to this argument to<br/>
                      ignore it.<br/>
    profile         - International Color Consortium color<br/>
                      profile data. May contain NULs.<br/>
    proflen         - length of profile data in bytes.<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_get_sBIT(png_ptr, info_ptr, &amp;sig_bit);<br/>
    sig_bit        - the number of significant bits for<br/>
                     (PNG_INFO_sBIT) each of the gray,<br/>
                     red, green, and blue channels,<br/>
                     whichever are appropriate for the<br/>
                     given color type (png_color_16)<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_get_tRNS(png_ptr, info_ptr, &amp;trans, &amp;num_trans,<br/>
                     &amp;trans_values);<br/>
    trans          - array of transparent<br/>
                     entries for palette (PNG_INFO_tRNS)<br/>
    trans_values   - graylevel or color sample values of<br/>
                     the single transparent color for<br/>
                     non-paletted images (PNG_INFO_tRNS)<br/>
    num_trans      - number of transparent entries<br/>
                     (PNG_INFO_tRNS)<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_get_hIST(png_ptr, info_ptr, &amp;hist);<br/>
                     (PNG_INFO_hIST)<br/>
    hist           - histogram of palette (array of<br/>
                     png_uint_16)<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_get_tIME(png_ptr, info_ptr, &amp;mod_time);<br/>
    mod_time       - time image was last modified<br/>
                    (PNG_VALID_tIME)<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_get_bKGD(png_ptr, info_ptr, &amp;background);<br/>
    background     - background color (PNG_VALID_bKGD)<br/>
                     valid 16-bit red, green and blue<br/>
                     values, regardless of color_type<div style="height: 1.00em;">
&#160;</div>
<br/>
    num_comments   = png_get_text(png_ptr, info_ptr,<br/>
                     &amp;text_ptr, &amp;num_text);<br/>
    num_comments   - number of comments<br/>
    text_ptr       - array of png_text holding image<br/>
                     comments<br/>
    text_ptr[i].compression - type of compression used<br/>
                 on &quot;text&quot; PNG_TEXT_COMPRESSION_NONE<br/>
                           PNG_TEXT_COMPRESSION_zTXt<br/>
                           PNG_ITXT_COMPRESSION_NONE<br/>
                           PNG_ITXT_COMPRESSION_zTXt<br/>
    text_ptr[i].key   - keyword for comment.  Must contain<br/>
                         1-79 characters.<br/>
    text_ptr[i].text  - text comments for current<br/>
                         keyword.  Can be empty.<br/>
    text_ptr[i].text_length - length of text string,<br/>
                 after decompression, 0 for iTXt<br/>
    text_ptr[i].itxt_length - length of itxt string,<br/>
                 after decompression, 0 for tEXt/zTXt<br/>
    text_ptr[i].lang  - language of comment (empty<br/>
                         string for unknown).<br/>
    text_ptr[i].lang_key  - keyword in UTF-8<br/>
                         (empty string for unknown).<br/>
    Note that the itxt_length, lang, and lang_key<br/>
    members of the text_ptr structure only exist<br/>
    when the library is built with iTXt chunk support.<div style="height: 1.00em;">
&#160;</div>
<br/>
    num_text       - number of comments (same as<br/>
                     num_comments; you can put NULL here<br/>
                     to avoid the duplication)<br/>
    Note while png_set_text() will accept text, language,<br/>
    and translated keywords that can be NULL pointers, the<br/>
    structure returned by png_get_text will always contain<br/>
    regular zero-terminated C strings.  They might be<br/>
    empty strings but they will never be NULL pointers.<div style="height: 1.00em;">
&#160;</div>
<br/>
    num_spalettes = png_get_sPLT(png_ptr, info_ptr,<br/>
       &amp;palette_ptr);<br/>
    palette_ptr    - array of palette structures holding<br/>
                     contents of one or more sPLT chunks<br/>
                     read.<br/>
    num_spalettes  - number of sPLT chunks read.<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_get_oFFs(png_ptr, info_ptr, &amp;offset_x, &amp;offset_y,<br/>
       &amp;unit_type);<br/>
    offset_x       - positive offset from the left edge<br/>
                     of the screen<br/>
    offset_y       - positive offset from the top edge<br/>
                     of the screen<br/>
    unit_type      - PNG_OFFSET_PIXEL, PNG_OFFSET_MICROMETER<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_get_pHYs(png_ptr, info_ptr, &amp;res_x, &amp;res_y,<br/>
       &amp;unit_type);<br/>
    res_x          - pixels/unit physical resolution in<br/>
                     x direction<br/>
    res_y          - pixels/unit physical resolution in<br/>
                     x direction<br/>
    unit_type      - PNG_RESOLUTION_UNKNOWN,<br/>
                     PNG_RESOLUTION_METER<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_get_sCAL(png_ptr, info_ptr, &amp;unit, &amp;width,<br/>
       &amp;height)<br/>
    unit        - physical scale units (an integer)<br/>
    width       - width of a pixel in physical scale units<br/>
    height      - height of a pixel in physical scale units<br/>
                 (width and height are doubles)<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_get_sCAL_s(png_ptr, info_ptr, &amp;unit, &amp;width,<br/>
       &amp;height)<br/>
    unit        - physical scale units (an integer)<br/>
    width       - width of a pixel in physical scale units<br/>
    height      - height of a pixel in physical scale units<br/>
                 (width and height are strings like &quot;2.54&quot;)<div style="height: 1.00em;">
&#160;</div>
<br/>
    num_unknown_chunks = png_get_unknown_chunks(png_ptr,<br/>
       info_ptr, &amp;unknowns)<br/>
    unknowns          - array of png_unknown_chunk<br/>
                        structures holding unknown chunks<br/>
    unknowns[i].name  - name of unknown chunk<br/>
    unknowns[i].data  - data of unknown chunk<br/>
    unknowns[i].size  - size of unknown chunk's data<br/>
    unknowns[i].location - position of chunk in file<div style="height: 1.00em;">
&#160;</div>
<br/>
    The value of &quot;i&quot; corresponds to the order in which the<br/>
    chunks were read from the PNG file or inserted with the<br/>
    png_set_unknown_chunks() function.<div style="height: 1.00em;">
&#160;</div>
The data from the pHYs chunk can be retrieved in several convenient forms:<div style="height: 1.00em;">
&#160;</div>
<br/>
    res_x = png_get_x_pixels_per_meter(png_ptr,<br/>
       info_ptr)<br/>
    res_y = png_get_y_pixels_per_meter(png_ptr,<br/>
       info_ptr)<br/>
    res_x_and_y = png_get_pixels_per_meter(png_ptr,<br/>
       info_ptr)<br/>
    res_x = png_get_x_pixels_per_inch(png_ptr,<br/>
       info_ptr)<br/>
    res_y = png_get_y_pixels_per_inch(png_ptr,<br/>
       info_ptr)<br/>
    res_x_and_y = png_get_pixels_per_inch(png_ptr,<br/>
       info_ptr)<br/>
    aspect_ratio = png_get_pixel_aspect_ratio(png_ptr,<br/>
       info_ptr)<div style="height: 1.00em;">
&#160;</div>
<br/>
   (Each of these returns 0 [signifying &quot;unknown&quot;] if<br/>
       the data is not present or if res_x is 0;<br/>
       res_x_and_y is 0 if res_x != res_y)<div style="height: 1.00em;">
&#160;</div>
The data from the oFFs chunk can be retrieved in several convenient forms:<div style="height: 1.00em;">
&#160;</div>
<br/>
    x_offset = png_get_x_offset_microns(png_ptr, info_ptr);<br/>
    y_offset = png_get_y_offset_microns(png_ptr, info_ptr);<br/>
    x_offset = png_get_x_offset_inches(png_ptr, info_ptr);<br/>
    y_offset = png_get_y_offset_inches(png_ptr, info_ptr);<div style="height: 1.00em;">
&#160;</div>
<br/>
   (Each of these returns 0 [signifying &quot;unknown&quot; if both<br/>
       x and y are 0] if the data is not present or if the<br/>
       chunk is present but the unit is the pixel)<div style="height: 1.00em;">
&#160;</div>
For more information, see the png_info definition in png.h and the PNG specification for chunk contents.  Be careful with trusting rowbytes, as some of the transformations could increase the space needed to hold a row (expand, filler, gray_to_rgb, etc.). See png_read_update_info(), below.<div style="height: 1.00em;">
&#160;</div>
A quick word about text_ptr and num_text.  PNG stores comments in keyword/text pairs, one pair per chunk, with no limit on the number of text chunks, and a 2^31 byte limit on their size.  While there are suggested keywords, there is no requirement to restrict the use to these strings.  It is strongly suggested that keywords and text be sensible to humans (that's the point), so don't use abbreviations.  Non-printing symbols are not allowed.  See the PNG specification for more details. There is also no requirement to have text after the keyword.<div style="height: 1.00em;">
&#160;</div>
Keywords should be limited to 79 Latin-1 characters without leading or trailing spaces, but non-consecutive spaces are allowed within the keyword.  It is possible to have the same keyword any number of times. The text_ptr is an array of png_text structures, each holding a pointer to a language string, a pointer to a keyword and a pointer to a text string.  The text string, language code, and translated keyword may be empty or NULL pointers.  The keyword/text pairs are put into the array in the order that they are received. However, some or all of the text chunks may be after the image, so, to make sure you have read all the text chunks, don't mess with these until after you read the stuff after the image.  This will be mentioned again below in the discussion that goes with png_read_end().<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>Input transformations</h2> After you've read the header information, you can set up the library to handle any special transformations of the image data.  The various ways to transform the data will be described in the order that they should occur.  This is important, as some of these change the color type and/or bit depth of the data, and some others only work on certain color types and bit depths.  Even though each transformation checks to see if it has data that it can do something with, you should make sure to only enable a transformation if it will be valid for the data.  For example, don't swap red and blue on grayscale data.<div style="height: 1.00em;">
&#160;</div>
The colors used for the background and transparency values should be supplied in the same format/depth as the current image data.  They are stored in the same format/depth as the image data in a bKGD or tRNS chunk, so this is what libpng expects for this data.  The colors are transformed to keep in sync with the image data when an application calls the png_read_update_info() routine (see below).<div style="height: 1.00em;">
&#160;</div>
Data will be decoded into the supplied row buffers packed into bytes unless the library has been told to transform it into another format. For example, 4 bit/pixel paletted or grayscale data will be returned 2 pixels/byte with the leftmost pixel in the high-order bits of the byte, unless png_set_packing() is called.  8-bit RGB data will be stored in RGB RGB RGB format unless png_set_filler() or png_set_add_alpha() is called to insert filler bytes, either before or after each RGB triplet. 16-bit RGB data will be returned RRGGBB RRGGBB, with the most significant byte of the color value first, unless png_set_strip_16() is called to transform it to regular RGB RGB triplets, or png_set_filler() or png_set_add alpha() is called to insert filler bytes, either before or after each RRGGBB triplet.  Similarly, 8-bit or 16-bit grayscale data can be modified with png_set_filler(), png_set_add_alpha(), or png_set_strip_16().<div style="height: 1.00em;">
&#160;</div>
The following code transforms grayscale images of less than 8 to 8 bits, changes paletted images to RGB, and adds a full alpha channel if there is transparency information in a tRNS chunk.  This is most useful on grayscale images with bit depths of 2 or 4 or if there is a multiple-image viewing application that wishes to treat all images in the same way.<div style="height: 1.00em;">
&#160;</div>
<br/>
    if (color_type == PNG_COLOR_TYPE_PALETTE)<br/>
        png_set_palette_to_rgb(png_ptr);<div style="height: 1.00em;">
&#160;</div>
<br/>
    if (color_type == PNG_COLOR_TYPE_GRAY &amp;&amp;<br/>
        bit_depth &lt; 8) png_set_expand_gray_1_2_4_to_8(png_ptr);<div style="height: 1.00em;">
&#160;</div>
<br/>
    if (png_get_valid(png_ptr, info_ptr,<br/>
        PNG_INFO_tRNS)) png_set_tRNS_to_alpha(png_ptr);<div style="height: 1.00em;">
&#160;</div>
These three functions are actually aliases for png_set_expand(), added in libpng version 1.0.4, with the function names expanded to improve code readability.  In some future version they may actually do different things.<div style="height: 1.00em;">
&#160;</div>
As of libpng version 1.2.9, png_set_expand_gray_1_2_4_to_8() was added.  It expands the sample depth without changing tRNS to alpha.<div style="height: 1.00em;">
&#160;</div>
As of libpng version 1.2.46, not all possible expansions are supported.<div style="height: 1.00em;">
&#160;</div>
In the following table, the 01 means grayscale with depth&lt;8, 31 means indexed with depth&lt;8, other numerals represent the color type, &quot;T&quot; means the tRNS chunk is present, A means an alpha channel is present, and O means tRNS or alpha is present but all pixels in the image are opaque.<div style="height: 1.00em;">
&#160;</div>
<br/>
  FROM  01  31   0  0T  0O   2  2T  2O   3  3T  3O  4A  4O  6A  6O<br/>
   TO<br/>
   01    -<br/>
   31        -<br/>
    0    1       -<br/>
   0T                -<br/>
   0O                    -<br/>
    2           GX           -<br/>
   2T                            -<br/>
   2O                                -<br/>
    3        1                           -<br/>
   3T                                        -<br/>
   3O                                            -<br/>
   4A                T                               -<br/>
   4O                                                    -<br/>
   6A               GX         TX           TX               -<br/>
   6O                   GX                      TX               -<div style="height: 1.00em;">
&#160;</div>
Within the matrix,<br/>
     &quot;-&quot; means the transformation is not supported.<br/>
     &quot;X&quot; means the transformation is obtained by png_set_expand().<br/>
     &quot;1&quot; means the transformation is obtained by<br/>
         png_set_expand_gray_1_2_4_to_8<br/>
     &quot;G&quot; means the transformation is obtained by<br/>
         png_set_gray_to_rgb().<br/>
     &quot;P&quot; means the transformation is obtained by<br/>
         png_set_expand_palette_to_rgb().<br/>
     &quot;T&quot; means the transformation is obtained by<br/>
         png_set_tRNS_to_alpha().<div style="height: 1.00em;">
&#160;</div>
PNG can have files with 16 bits per channel.  If you only can handle 8 bits per channel, this will strip the pixels down to 8 bit.<div style="height: 1.00em;">
&#160;</div>
<br/>
    if (bit_depth == 16)<br/>
        png_set_strip_16(png_ptr);<div style="height: 1.00em;">
&#160;</div>
If, for some reason, you don't need the alpha channel on an image, and you want to remove it rather than combining it with the background (but the image author certainly had in mind that you *would* combine it with the background, so that's what you should probably do):<div style="height: 1.00em;">
&#160;</div>
<br/>
    if (color_type &amp; PNG_COLOR_MASK_ALPHA)<br/>
        png_set_strip_alpha(png_ptr);<div style="height: 1.00em;">
&#160;</div>
In PNG files, the alpha channel in an image is the level of opacity.  If you need the alpha channel in an image to be the level of transparency instead of opacity, you can invert the alpha channel (or the tRNS chunk data) after it's read, so that 0 is fully opaque and 255 (in 8-bit or paletted images) or 65535 (in 16-bit images) is fully transparent, with<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_invert_alpha(png_ptr);<div style="height: 1.00em;">
&#160;</div>
The PNG format only supports pixels with postmultiplied alpha. If you want to replace the pixels, after reading them, with pixels that have premultiplied color samples, you can do this with<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_premultiply_alpha(png_ptr);<div style="height: 1.00em;">
&#160;</div>
If you do this, any input with a tRNS chunk will be expanded to have an alpha channel.<div style="height: 1.00em;">
&#160;</div>
PNG files pack pixels of bit depths 1, 2, and 4 into bytes as small as they can, resulting in, for example, 8 pixels per byte for 1 bit files.  This code expands to 1 pixel per byte without changing the values of the pixels:<div style="height: 1.00em;">
&#160;</div>
<br/>
    if (bit_depth &lt; 8)<br/>
        png_set_packing(png_ptr);<div style="height: 1.00em;">
&#160;</div>
PNG files have possible bit depths of 1, 2, 4, 8, and 16.  All pixels stored in a PNG image have been &quot;scaled&quot; or &quot;shifted&quot; up to the next higher possible bit depth (e.g. from 5 bits/sample in the range [0,31] to 8 bits/sample in the range [0, 255]).  However, it is also possible to convert the PNG pixel data back to the original bit depth of the image.  This call reduces the pixels back down to the original bit depth:<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_color_8p sig_bit;<div style="height: 1.00em;">
&#160;</div>
<br/>
    if (png_get_sBIT(png_ptr, info_ptr, &amp;sig_bit))<br/>
        png_set_shift(png_ptr, sig_bit);<div style="height: 1.00em;">
&#160;</div>
PNG files store 3-color pixels in red, green, blue order.  This code changes the storage of the pixels to blue, green, red:<div style="height: 1.00em;">
&#160;</div>
<br/>
    if (color_type == PNG_COLOR_TYPE_RGB ||<br/>
        color_type == PNG_COLOR_TYPE_RGB_ALPHA)<br/>
        png_set_bgr(png_ptr);<div style="height: 1.00em;">
&#160;</div>
PNG files store RGB pixels packed into 3 or 6 bytes. This code expands them into 4 or 8 bytes for windowing systems that need them in this format:<div style="height: 1.00em;">
&#160;</div>
<br/>
    if (color_type == PNG_COLOR_TYPE_RGB)<br/>
        png_set_filler(png_ptr, filler, PNG_FILLER_BEFORE);<div style="height: 1.00em;">
&#160;</div>
where &quot;filler&quot; is the 8 or 16-bit number to fill with, and the location is either PNG_FILLER_BEFORE or PNG_FILLER_AFTER, depending upon whether you want the filler before the RGB or after.  This transformation does not affect images that already have full alpha channels.  To add an opaque alpha channel, use filler=0xff or 0xffff and PNG_FILLER_AFTER which will generate RGBA pixels.<div style="height: 1.00em;">
&#160;</div>
Note that png_set_filler() does not change the color type.  If you want to do that, you can add a true alpha channel with<div style="height: 1.00em;">
&#160;</div>
<br/>
    if (color_type == PNG_COLOR_TYPE_RGB ||<br/>
           color_type == PNG_COLOR_TYPE_GRAY)<br/>
    png_set_add_alpha(png_ptr, filler, PNG_FILLER_AFTER);<div style="height: 1.00em;">
&#160;</div>
where &quot;filler&quot; contains the alpha value to assign to each pixel. This function was added in libpng-1.2.7.<div style="height: 1.00em;">
&#160;</div>
If you are reading an image with an alpha channel, and you need the data as ARGB instead of the normal PNG format RGBA:<div style="height: 1.00em;">
&#160;</div>
<br/>
    if (color_type == PNG_COLOR_TYPE_RGB_ALPHA)<br/>
        png_set_swap_alpha(png_ptr);<div style="height: 1.00em;">
&#160;</div>
For some uses, you may want a grayscale image to be represented as RGB.  This code will do that conversion:<div style="height: 1.00em;">
&#160;</div>
<br/>
    if (color_type == PNG_COLOR_TYPE_GRAY ||<br/>
        color_type == PNG_COLOR_TYPE_GRAY_ALPHA)<br/>
          png_set_gray_to_rgb(png_ptr);<div style="height: 1.00em;">
&#160;</div>
Conversely, you can convert an RGB or RGBA image to grayscale or grayscale with alpha.<div style="height: 1.00em;">
&#160;</div>
<br/>
    if (color_type == PNG_COLOR_TYPE_RGB ||<br/>
        color_type == PNG_COLOR_TYPE_RGB_ALPHA)<br/>
          png_set_rgb_to_gray_fixed(png_ptr, error_action,<br/>
             int red_weight, int green_weight);<div style="height: 1.00em;">
&#160;</div>
<br/>
    error_action = 1: silently do the conversion<br/>
    error_action = 2: issue a warning if the original<br/>
                      image has any pixel where<br/>
                      red != green or red != blue<br/>
    error_action = 3: issue an error and abort the<br/>
                      conversion if the original<br/>
                      image has any pixel where<br/>
                      red != green or red != blue<div style="height: 1.00em;">
&#160;</div>
<br/>
    red_weight:       weight of red component times 100000<br/>
    green_weight:     weight of green component times 100000<br/>
                      If either weight is negative, default<br/>
                      weights (21268, 71514) are used.<div style="height: 1.00em;">
&#160;</div>
If you have set error_action = 1 or 2, you can later check whether the image really was gray, after processing the image rows, with the png_get_rgb_to_gray_status(png_ptr) function. It will return a png_byte that is zero if the image was gray or 1 if there were any non-gray pixels.  bKGD and sBIT data will be silently converted to grayscale, using the green channel data, regardless of the error_action setting.<div style="height: 1.00em;">
&#160;</div>
With red_weight+green_weight&lt;=100000, the normalized graylevel is computed:<div style="height: 1.00em;">
&#160;</div>
<br/>
    int rw = red_weight * 65536;<br/>
    int gw = green_weight * 65536;<br/>
    int bw = 65536 - (rw + gw);<br/>
    gray = (rw*red + gw*green + bw*blue)/65536;<div style="height: 1.00em;">
&#160;</div>
The default values approximate those recommended in the Charles Poynton's Color FAQ, &lt;http://www.inforamp.net/~poynton/&gt; Copyright (c) 1998-01-04 Charles Poynton &lt;poynton at inforamp.net&gt;<div style="height: 1.00em;">
&#160;</div>
<br/>
    Y = 0.212671 * R + 0.715160 * G + 0.072169 * B<div style="height: 1.00em;">
&#160;</div>
Libpng approximates this with<div style="height: 1.00em;">
&#160;</div>
<br/>
    Y = 0.21268 * R    + 0.7151 * G    + 0.07217 * B<div style="height: 1.00em;">
&#160;</div>
which can be expressed with integers as<div style="height: 1.00em;">
&#160;</div>
<br/>
    Y = (6969 * R + 23434 * G + 2365 * B)/32768<div style="height: 1.00em;">
&#160;</div>
The calculation is done in a linear colorspace, if the image gamma is known.<div style="height: 1.00em;">
&#160;</div>
If you have a grayscale and you are using png_set_expand_depth(), png_set_expand(), or png_set_gray_to_rgb to change to truecolor or to a higher bit-depth, you must either supply the background color as a gray value at the original file bit-depth (need_expand = 1) or else supply the background color as an RGB triplet at the final, expanded bit depth (need_expand = 0).  Similarly, if you are reading a paletted image, you must either supply the background color as a palette index (need_expand = 1) or as an RGB triplet that may or may not be in the palette (need_expand = 0).<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_color_16 my_background;<br/>
    png_color_16p image_background;<div style="height: 1.00em;">
&#160;</div>
<br/>
    if (png_get_bKGD(png_ptr, info_ptr, &amp;image_background))<br/>
        png_set_background(png_ptr, image_background,<br/>
          PNG_BACKGROUND_GAMMA_FILE, 1, 1.0);<br/>
    else<br/>
        png_set_background(png_ptr, &amp;my_background,<br/>
          PNG_BACKGROUND_GAMMA_SCREEN, 0, 1.0);<div style="height: 1.00em;">
&#160;</div>
The png_set_background() function tells libpng to composite images with alpha or simple transparency against the supplied background color.  If the PNG file contains a bKGD chunk (PNG_INFO_bKGD valid), you may use this color, or supply another color more suitable for the current display (e.g., the background color from a web page).  You need to tell libpng whether the color is in the gamma space of the display (PNG_BACKGROUND_GAMMA_SCREEN for colors you supply), the file (PNG_BACKGROUND_GAMMA_FILE for colors from the bKGD chunk), or one that is neither of these gammas (PNG_BACKGROUND_GAMMA_UNIQUE - I don't know why anyone would use this, but it's here).<div style="height: 1.00em;">
&#160;</div>
To properly display PNG images on any kind of system, the application needs to know what the display gamma is.  Ideally, the user will know this, and the application will allow them to set it.  One method of allowing the user to set the display gamma separately for each system is to check for a SCREEN_GAMMA or DISPLAY_GAMMA environment variable, which will hopefully be correctly set.<div style="height: 1.00em;">
&#160;</div>
Note that display_gamma is the overall gamma correction required to produce pleasing results, which depends on the lighting conditions in the surrounding environment.  In a dim or brightly lit room, no compensation other than the physical gamma exponent of the monitor is needed, while in a dark room a slightly smaller exponent is better.<div style="height: 1.00em;">
&#160;</div>
<br/>
   double gamma, screen_gamma;<div style="height: 1.00em;">
&#160;</div>
<br/>
   if (/* We have a user-defined screen<br/>
       gamma value */)<br/>
   {<br/>
      screen_gamma = user_defined_screen_gamma;<br/>
   }<br/>
   /* One way that applications can share the same<br/>
      screen gamma value */<br/>
   else if ((gamma_str = getenv(&quot;SCREEN_GAMMA&quot;))<br/>
      != NULL)<br/>
   {<br/>
      screen_gamma = (double)atof(gamma_str);<br/>
   }<br/>
   /* If we don't have another value */<br/>
   else<br/>
   {<br/>
      screen_gamma = 2.2; /* A good guess for a<br/>
           PC monitor in a bright office or a dim room */<br/>
      screen_gamma = 2.0; /* A good guess for a<br/>
           PC monitor in a dark room */<br/>
      screen_gamma = 1.7 or 1.0;  /* A good<br/>
           guess for Mac systems */<br/>
   }<div style="height: 1.00em;">
&#160;</div>
The png_set_gamma() function handles gamma transformations of the data. Pass both the file gamma and the current screen_gamma.  If the file does not have a gamma value, you can pass one anyway if you have an idea what it is (usually 0.45455 is a good guess for GIF images on PCs).  Note that file gammas are inverted from screen gammas.  See the discussions on gamma in the PNG specification for an excellent description of what gamma is, and why all applications should support it.  It is strongly recommended that PNG viewers support gamma correction.<div style="height: 1.00em;">
&#160;</div>
<br/>
   if (png_get_gAMA(png_ptr, info_ptr, &amp;gamma))<br/>
      png_set_gamma(png_ptr, screen_gamma, gamma);<br/>
   else<br/>
      png_set_gamma(png_ptr, screen_gamma, 0.45455);<div style="height: 1.00em;">
&#160;</div>
If you need to reduce an RGB file to a paletted file, or if a paletted file has more entries then will fit on your screen, png_set_dither() will do that.  Note that this is a simple match dither that merely finds the closest color available.  This should work fairly well with optimized palettes, and fairly badly with linear color cubes.  If you pass a palette that is larger then maximum_colors, the file will reduce the number of colors in the palette so it will fit into maximum_colors.  If there is a histogram, it will use it to make more intelligent choices when reducing the palette.  If there is no histogram, it may not do as good a job.<div style="height: 1.00em;">
&#160;</div>
<br/>
   if (color_type &amp; PNG_COLOR_MASK_COLOR)<br/>
   {<br/>
      if (png_get_valid(png_ptr, info_ptr,<br/>
         PNG_INFO_PLTE))<br/>
      {<br/>
         png_uint_16p histogram = NULL;<div style="height: 1.00em;">
&#160;</div>
<br/>
         png_get_hIST(png_ptr, info_ptr,<br/>
            &amp;histogram);<br/>
         png_set_dither(png_ptr, palette, num_palette,<br/>
            max_screen_colors, histogram, 1);<br/>
      }<br/>
      else<br/>
      {<br/>
         png_color std_color_cube[MAX_SCREEN_COLORS] =<br/>
            { ... colors ... };<div style="height: 1.00em;">
&#160;</div>
<br/>
         png_set_dither(png_ptr, std_color_cube,<br/>
            MAX_SCREEN_COLORS, MAX_SCREEN_COLORS,<br/>
            NULL,0);<br/>
      }<br/>
   }<div style="height: 1.00em;">
&#160;</div>
PNG files describe monochrome as black being zero and white being one. The following code will reverse this (make black be one and white be zero):<div style="height: 1.00em;">
&#160;</div>
<br/>
   if (bit_depth == 1 &amp;&amp; color_type == PNG_COLOR_TYPE_GRAY)<br/>
      png_set_invert_mono(png_ptr);<div style="height: 1.00em;">
&#160;</div>
This function can also be used to invert grayscale and gray-alpha images:<div style="height: 1.00em;">
&#160;</div>
<br/>
   if (color_type == PNG_COLOR_TYPE_GRAY ||<br/>
        color_type == PNG_COLOR_TYPE_GRAY_ALPHA)<br/>
      png_set_invert_mono(png_ptr);<div style="height: 1.00em;">
&#160;</div>
PNG files store 16 bit pixels in network byte order (big-endian, ie. most significant bits first).  This code changes the storage to the other way (little-endian, i.e. least significant bits first, the way PCs store them):<div style="height: 1.00em;">
&#160;</div>
<br/>
    if (bit_depth == 16)<br/>
        png_set_swap(png_ptr);<div style="height: 1.00em;">
&#160;</div>
If you are using packed-pixel images (1, 2, or 4 bits/pixel), and you need to change the order the pixels are packed into bytes, you can use:<div style="height: 1.00em;">
&#160;</div>
<br/>
    if (bit_depth &lt; 8)<br/>
       png_set_packswap(png_ptr);<div style="height: 1.00em;">
&#160;</div>
Finally, you can write your own transformation function if none of the existing ones meets your needs.  This is done by setting a callback with<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_read_user_transform_fn(png_ptr,<br/>
       read_transform_fn);<div style="height: 1.00em;">
&#160;</div>
You must supply the function<div style="height: 1.00em;">
&#160;</div>
<br/>
    void read_transform_fn(png_ptr ptr, row_info_ptr<br/>
       row_info, png_bytep data)<div style="height: 1.00em;">
&#160;</div>
See pngtest.c for a working example.  Your function will be called after all of the other transformations have been processed.<div style="height: 1.00em;">
&#160;</div>
You can also set up a pointer to a user structure for use by your callback function, and you can inform libpng that your transform function will change the number of channels or bit depth with the function<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_user_transform_info(png_ptr, user_ptr,<br/>
       user_depth, user_channels);<div style="height: 1.00em;">
&#160;</div>
The user's application, not libpng, is responsible for allocating and freeing any memory required for the user structure.<div style="height: 1.00em;">
&#160;</div>
You can retrieve the pointer via the function png_get_user_transform_ptr().  For example:<div style="height: 1.00em;">
&#160;</div>
<br/>
    voidp read_user_transform_ptr =<br/>
       png_get_user_transform_ptr(png_ptr);<div style="height: 1.00em;">
&#160;</div>
The last thing to handle is interlacing; this is covered in detail below, but you must call the function here if you want libpng to handle expansion of the interlaced image.<div style="height: 1.00em;">
&#160;</div>
<br/>
    number_of_passes = png_set_interlace_handling(png_ptr);<div style="height: 1.00em;">
&#160;</div>
After setting the transformations, libpng can update your png_info structure to reflect any transformations you've requested with this call.  This is most useful to update the info structure's rowbytes field so you can use it to allocate your image memory.  This function will also update your palette with the correct screen_gamma and background if these have been given with the calls above.<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_read_update_info(png_ptr, info_ptr);<div style="height: 1.00em;">
&#160;</div>
After you call png_read_update_info(), you can allocate any memory you need to hold the image.  The row data is simply raw byte data for all forms of images.  As the actual allocation varies among applications, no example will be given.  If you are allocating one large chunk, you will need to build an array of pointers to each row, as it will be needed for some of the functions below.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>Reading image data</h2> After you've allocated memory, you can read the image data. The simplest way to do this is in one function call.  If you are allocating enough memory to hold the whole image, you can just call png_read_image() and libpng will read in all the image data and put it in the memory area supplied.  You will need to pass in an array of pointers to each row.<div style="height: 1.00em;">
&#160;</div>
This function automatically handles interlacing, so you don't need to call png_set_interlace_handling() or call this function multiple times, or any of that other stuff necessary with png_read_rows().<div style="height: 1.00em;">
&#160;</div>
<br/>
   png_read_image(png_ptr, row_pointers);<div style="height: 1.00em;">
&#160;</div>
where row_pointers is:<div style="height: 1.00em;">
&#160;</div>
<br/>
   png_bytep row_pointers[height];<div style="height: 1.00em;">
&#160;</div>
You can point to void or char or whatever you use for pixels.<div style="height: 1.00em;">
&#160;</div>
If you don't want to read in the whole image at once, you can use png_read_rows() instead.  If there is no interlacing (check interlace_type == PNG_INTERLACE_NONE), this is simple:<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_read_rows(png_ptr, row_pointers, NULL,<br/>
       number_of_rows);<div style="height: 1.00em;">
&#160;</div>
where row_pointers is the same as in the png_read_image() call.<div style="height: 1.00em;">
&#160;</div>
If you are doing this just one row at a time, you can do this with a single row_pointer instead of an array of row_pointers:<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_bytep row_pointer = row;<br/>
    png_read_row(png_ptr, row_pointer, NULL);<div style="height: 1.00em;">
&#160;</div>
If the file is interlaced (interlace_type != 0 in the IHDR chunk), things get somewhat harder.  The only current (PNG Specification version 1.2) interlacing type for PNG is (interlace_type == PNG_INTERLACE_ADAM7) is a somewhat complicated 2D interlace scheme, known as Adam7, that breaks down an image into seven smaller images of varying size, based on an 8x8 grid.<div style="height: 1.00em;">
&#160;</div>
libpng can fill out those images or it can give them to you &quot;as is&quot;. If you want them filled out, there are two ways to do that.  The one mentioned in the PNG specification is to expand each pixel to cover those pixels that have not been read yet (the &quot;rectangle&quot; method). This results in a blocky image for the first pass, which gradually smooths out as more pixels are read.  The other method is the &quot;sparkle&quot; method, where pixels are drawn only in their final locations, with the rest of the image remaining whatever colors they were initialized to before the start of the read.  The first method usually looks better, but tends to be slower, as there are more pixels to put in the rows.<div style="height: 1.00em;">
&#160;</div>
If you don't want libpng to handle the interlacing details, just call png_read_rows() seven times to read in all seven images.  Each of the images is a valid image by itself, or they can all be combined on an 8x8 grid to form a single image (although if you intend to combine them you would be far better off using the libpng interlace handling).<div style="height: 1.00em;">
&#160;</div>
The first pass will return an image 1/8 as wide as the entire image (every 8th column starting in column 0) and 1/8 as high as the original (every 8th row starting in row 0), the second will be 1/8 as wide (starting in column 4) and 1/8 as high (also starting in row 0).  The third pass will be 1/4 as wide (every 4th pixel starting in column 0) and 1/8 as high (every 8th row starting in row 4), and the fourth pass will be 1/4 as wide and 1/4 as high (every 4th column starting in column 2, and every 4th row starting in row 0).  The fifth pass will return an image 1/2 as wide, and 1/4 as high (starting at column 0 and row 2), while the sixth pass will be 1/2 as wide and 1/2 as high as the original (starting in column 1 and row 0).  The seventh and final pass will be as wide as the original, and 1/2 as high, containing all of the odd numbered scanlines.  Phew!<div style="height: 1.00em;">
&#160;</div>
If you want libpng to expand the images, call this before calling png_start_read_image() or png_read_update_info():<div style="height: 1.00em;">
&#160;</div>
<br/>
    if (interlace_type == PNG_INTERLACE_ADAM7)<br/>
        number_of_passes<br/>
           = png_set_interlace_handling(png_ptr);<div style="height: 1.00em;">
&#160;</div>
This will return the number of passes needed.  Currently, this is seven, but may change if another interlace type is added. This function can be called even if the file is not interlaced, where it will return one pass.<div style="height: 1.00em;">
&#160;</div>
If you are not going to display the image after each pass, but are going to wait until the entire image is read in, use the sparkle effect.  This effect is faster and the end result of either method is exactly the same.  If you are planning on displaying the image after each pass, the &quot;rectangle&quot; effect is generally considered the better looking one.<div style="height: 1.00em;">
&#160;</div>
If you only want the &quot;sparkle&quot; effect, just call png_read_rows() as normal, with the third parameter NULL.  Make sure you make pass over the image number_of_passes times, and you don't change the data in the rows between calls.  You can change the locations of the data, just not the data.  Each pass only writes the pixels appropriate for that pass, and assumes the data from previous passes is still valid.<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_read_rows(png_ptr, row_pointers, NULL,<br/>
       number_of_rows);<div style="height: 1.00em;">
&#160;</div>
If you only want the first effect (the rectangles), do the same as before except pass the row buffer in the third parameter, and leave the second parameter NULL.<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_read_rows(png_ptr, NULL, row_pointers,<br/>
       number_of_rows);<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>Finishing a sequential read</h2> After you are finished reading the image through the low-level interface, you can finish reading the file.  If you are interested in comments or time, which may be stored either before or after the image data, you should pass the separate png_info struct if you want to keep the comments from before and after the image separate.  If you are not interested, you can pass NULL.<div style="height: 1.00em;">
&#160;</div>
<br/>
   png_read_end(png_ptr, end_info);<div style="height: 1.00em;">
&#160;</div>
When you are done, you can free all memory allocated by libpng like this:<div style="height: 1.00em;">
&#160;</div>
<br/>
   png_destroy_read_struct(&amp;png_ptr, &amp;info_ptr,<br/>
       &amp;end_info);<div style="height: 1.00em;">
&#160;</div>
It is also possible to individually free the info_ptr members that point to libpng-allocated storage with the following function:<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_free_data(png_ptr, info_ptr, mask, seq)<br/>
    mask - identifies data to be freed, a mask<br/>
           containing the bitwise OR of one or<br/>
           more of<br/>
             PNG_FREE_PLTE, PNG_FREE_TRNS,<br/>
             PNG_FREE_HIST, PNG_FREE_ICCP,<br/>
             PNG_FREE_PCAL, PNG_FREE_ROWS,<br/>
             PNG_FREE_SCAL, PNG_FREE_SPLT,<br/>
             PNG_FREE_TEXT, PNG_FREE_UNKN,<br/>
           or simply PNG_FREE_ALL<br/>
    seq  - sequence number of item to be freed<br/>
           (-1 for all items)<div style="height: 1.00em;">
&#160;</div>
This function may be safely called when the relevant storage has already been freed, or has not yet been allocated, or was allocated by the user and not by libpng,  and will in those cases do nothing. The &quot;seq&quot; parameter is ignored if only one item of the selected data type, such as PLTE, is allowed.  If &quot;seq&quot; is not -1, and multiple items are allowed for the data type identified in the mask, such as text or sPLT, only the n'th item in the structure is freed, where n is &quot;seq&quot;.<div style="height: 1.00em;">
&#160;</div>
The default behavior is only to free data that was allocated internally by libpng.  This can be changed, so that libpng will not free the data, or so that it will free data that was allocated by the user with png_malloc() or png_zalloc() and passed in via a png_set_*() function, with<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_data_freer(png_ptr, info_ptr, freer, mask)<br/>
    mask   - which data elements are affected<br/>
             same choices as in png_free_data()<br/>
    freer  - one of<br/>
               PNG_DESTROY_WILL_FREE_DATA<br/>
               PNG_SET_WILL_FREE_DATA<br/>
               PNG_USER_WILL_FREE_DATA<div style="height: 1.00em;">
&#160;</div>
This function only affects data that has already been allocated. You can call this function after reading the PNG data but before calling any png_set_*() functions, to control whether the user or the png_set_*() function is responsible for freeing any existing data that might be present, and again after the png_set_*() functions to control whether the user or png_destroy_*() is supposed to free the data.  When the user assumes responsibility for libpng-allocated data, the application must use png_free() to free it, and when the user transfers responsibility to libpng for data that the user has allocated, the user must have used png_malloc() or png_zalloc() to allocate it.<div style="height: 1.00em;">
&#160;</div>
If you allocated your row_pointers in a single block, as suggested above in the description of the high level read interface, you must not transfer responsibility for freeing it to the png_set_rows or png_read_destroy function, because they would also try to free the individual row_pointers[i].<div style="height: 1.00em;">
&#160;</div>
If you allocated text_ptr.text, text_ptr.lang, and text_ptr.translated_keyword separately, do not transfer responsibility for freeing text_ptr to libpng, because when libpng fills a png_text structure it combines these members with the key member, and png_free_data() will free only text_ptr.key.  Similarly, if you transfer responsibility for free'ing text_ptr from libpng to your application, your application must not separately free those members.<div style="height: 1.00em;">
&#160;</div>
The png_free_data() function will turn off the &quot;valid&quot; flag for anything it frees.  If you need to turn the flag off for a chunk that was freed by your application instead of by libpng, you can use<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_invalid(png_ptr, info_ptr, mask);<br/>
    mask - identifies the chunks to be made invalid,<br/>
           containing the bitwise OR of one or<br/>
           more of<br/>
             PNG_INFO_gAMA, PNG_INFO_sBIT,<br/>
             PNG_INFO_cHRM, PNG_INFO_PLTE,<br/>
             PNG_INFO_tRNS, PNG_INFO_bKGD,<br/>
             PNG_INFO_hIST, PNG_INFO_pHYs,<br/>
             PNG_INFO_oFFs, PNG_INFO_tIME,<br/>
             PNG_INFO_pCAL, PNG_INFO_sRGB,<br/>
             PNG_INFO_iCCP, PNG_INFO_sPLT,<br/>
             PNG_INFO_sCAL, PNG_INFO_IDAT<div style="height: 1.00em;">
&#160;</div>
For a more compact example of reading a PNG image, see the file example.c.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>Reading PNG files progressively</h2> The progressive reader is slightly different then the non-progressive reader.  Instead of calling png_read_info(), png_read_rows(), and png_read_end(), you make one call to png_process_data(), which calls callbacks when it has the info, a row, or the end of the image.  You set up these callbacks with png_set_progressive_read_fn().  You don't have to worry about the input/output functions of libpng, as you are giving the library the data directly in png_process_data().  I will assume that you have read the section on reading PNG files above, so I will only highlight the differences (although I will show all of the code).<div style="height: 1.00em;">
&#160;</div>
png_structp png_ptr; png_infop info_ptr;<div style="height: 1.00em;">
&#160;</div>
<br/>
 /*  An example code fragment of how you would<br/>
     initialize the progressive reader in your<br/>
     application. */<br/>
 int<br/>
 initialize_png_reader()<br/>
 {<br/>
    png_ptr = png_create_read_struct<br/>
        (PNG_LIBPNG_VER_STRING, (png_voidp)user_error_ptr,<br/>
         user_error_fn, user_warning_fn);<br/>
    if (!png_ptr)<br/>
        return (ERROR);<br/>
    info_ptr = png_create_info_struct(png_ptr);<br/>
    if (!info_ptr)<br/>
    {<br/>
        png_destroy_read_struct(&amp;png_ptr, (png_infopp)NULL,<br/>
           (png_infopp)NULL);<br/>
        return (ERROR);<br/>
    }<div style="height: 1.00em;">
&#160;</div>
<br/>
    if (setjmp(png_jmpbuf(png_ptr)))<br/>
    {<br/>
        png_destroy_read_struct(&amp;png_ptr, &amp;info_ptr,<br/>
           (png_infopp)NULL);<br/>
        return (ERROR);<br/>
    }<div style="height: 1.00em;">
&#160;</div>
<br/>
    /* This one's new.  You can provide functions<br/>
       to be called when the header info is valid,<br/>
       when each row is completed, and when the image<br/>
       is finished.  If you aren't using all functions,<br/>
       you can specify NULL parameters.  Even when all<br/>
       three functions are NULL, you need to call<br/>
       png_set_progressive_read_fn().  You can use<br/>
       any struct as the user_ptr (cast to a void pointer<br/>
       for the function call), and retrieve the pointer<br/>
       from inside the callbacks using the function<div style="height: 1.00em;">
&#160;</div>
<br/>
          png_get_progressive_ptr(png_ptr);<div style="height: 1.00em;">
&#160;</div>
<br/>
       which will return a void pointer, which you have<br/>
       to cast appropriately.<br/>
     */<br/>
    png_set_progressive_read_fn(png_ptr, (void *)user_ptr,<br/>
        info_callback, row_callback, end_callback);<div style="height: 1.00em;">
&#160;</div>
<br/>
    return 0;<br/>
 }<div style="height: 1.00em;">
&#160;</div>
<br/>
 /* A code fragment that you call as you receive blocks<br/>
   of data */<br/>
 int<br/>
 process_data(png_bytep buffer, png_uint_32 length)<br/>
 {<br/>
    if (setjmp(png_jmpbuf(png_ptr)))<br/>
    {<br/>
        png_destroy_read_struct(&amp;png_ptr, &amp;info_ptr,<br/>
           (png_infopp)NULL);<br/>
        return (ERROR);<br/>
    }<div style="height: 1.00em;">
&#160;</div>
<br/>
    /* This one's new also.  Simply give it a chunk<br/>
       of data from the file stream (in order, of<br/>
       course).  On machines with segmented memory<br/>
       models machines, don't give it any more than<br/>
       64K.  The library seems to run fine with sizes<br/>
       of 4K. Although you can give it much less if<br/>
       necessary (I assume you can give it chunks of<br/>
       1 byte, I haven't tried less then 256 bytes<br/>
       yet).  When this function returns, you may<br/>
       want to display any rows that were generated<br/>
       in the row callback if you don't already do<br/>
       so there.<br/>
     */<br/>
    png_process_data(png_ptr, info_ptr, buffer, length);<br/>
    return 0;<br/>
 }<div style="height: 1.00em;">
&#160;</div>
<br/>
 /* This function is called (as set by<br/>
    png_set_progressive_read_fn() above) when enough data<br/>
    has been supplied so all of the header has been<br/>
    read.<br/>
 */<br/>
 void<br/>
 info_callback(png_structp png_ptr, png_infop info)<br/>
 {<br/>
    /* Do any setup here, including setting any of<br/>
       the transformations mentioned in the Reading<br/>
       PNG files section.  For now, you _must_ call<br/>
       either png_start_read_image() or<br/>
       png_read_update_info() after all the<br/>
       transformations are set (even if you don't set<br/>
       any).  You may start getting rows before<br/>
       png_process_data() returns, so this is your<br/>
       last chance to prepare for that.<br/>
     */<br/>
 }<div style="height: 1.00em;">
&#160;</div>
<br/>
 /* This function is called when each row of image<br/>
    data is complete */<br/>
 void<br/>
 row_callback(png_structp png_ptr, png_bytep new_row,<br/>
    png_uint_32 row_num, int pass)<br/>
 {<br/>
    /* If the image is interlaced, and you turned<br/>
       on the interlace handler, this function will<br/>
       be called for every row in every pass.  Some<br/>
       of these rows will not be changed from the<br/>
       previous pass.  When the row is not changed,<br/>
       the new_row variable will be NULL.  The rows<br/>
       and passes are called in order, so you don't<br/>
       really need the row_num and pass, but I'm<br/>
       supplying them because it may make your life<br/>
       easier.<div style="height: 1.00em;">
&#160;</div>
<br/>
       For the non-NULL rows of interlaced images,<br/>
       you must call png_progressive_combine_row()<br/>
       passing in the row and the old row.  You can<br/>
       call this function for NULL rows (it will just<br/>
       return) and for non-interlaced images (it just<br/>
       does the memcpy for you) if it will make the<br/>
       code easier.  Thus, you can just do this for<br/>
       all cases:<br/>
     */<div style="height: 1.00em;">
&#160;</div>
<br/>
        png_progressive_combine_row(png_ptr, old_row,<br/>
          new_row);<div style="height: 1.00em;">
&#160;</div>
<br/>
    /* where old_row is what was displayed for<br/>
       previously for the row.  Note that the first<br/>
       pass (pass == 0, really) will completely cover<br/>
       the old row, so the rows do not have to be<br/>
       initialized.  After the first pass (and only<br/>
       for interlaced images), you will have to pass<br/>
       the current row, and the function will combine<br/>
       the old row and the new row.<br/>
    */<br/>
 }<div style="height: 1.00em;">
&#160;</div>
<br/>
 void<br/>
 end_callback(png_structp png_ptr, png_infop info)<br/>
 {<br/>
    /* This function is called after the whole image<br/>
       has been read, including any chunks after the<br/>
       image (up to and including the IEND).  You<br/>
       will usually have the same info chunk as you<br/>
       had in the header, although some data may have<br/>
       been added to the comments and time fields.<div style="height: 1.00em;">
&#160;</div>
<br/>
       Most people won't do much here, perhaps setting<br/>
       a flag that marks the image as finished.<br/>
     */<br/>
 }<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
</div>
<div class="section">
<h1>IV. Writing</h1> Much of this is very similar to reading.  However, everything of importance is repeated here, so you won't have to constantly look back up in the reading section to understand writing.<div style="height: 1.00em;">
&#160;</div>
<div class="subsection">
<h2>Setup</h2> You will want to do the I/O initialization before you get into libpng, so if it doesn't work, you don't have anything to undo. If you are not using the standard I/O functions, you will need to replace them with custom writing functions.  See the discussion under Customizing libpng.<div style="height: 1.00em;">
&#160;</div>
<br/>
    FILE *fp = fopen(file_name, &quot;wb&quot;);<br/>
    if (!fp)<br/>
    {<br/>
       return (ERROR);<br/>
    }<div style="height: 1.00em;">
&#160;</div>
Next, png_struct and png_info need to be allocated and initialized. As these can be both relatively large, you may not want to store these on the stack, unless you have stack space to spare.  Of course, you will want to check if they return NULL.  If you are also reading, you won't want to name your read structure and your write structure both &quot;png_ptr&quot;; you can call them anything you like, such as &quot;read_ptr&quot; and &quot;write_ptr&quot;.  Look at pngtest.c, for example.<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_structp png_ptr = png_create_write_struct<br/>
       (PNG_LIBPNG_VER_STRING, (png_voidp)user_error_ptr,<br/>
        user_error_fn, user_warning_fn);<br/>
    if (!png_ptr)<br/>
       return (ERROR);<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_infop info_ptr = png_create_info_struct(png_ptr);<br/>
    if (!info_ptr)<br/>
    {<br/>
       png_destroy_write_struct(&amp;png_ptr,<br/>
         (png_infopp)NULL);<br/>
       return (ERROR);<br/>
    }<div style="height: 1.00em;">
&#160;</div>
If you want to use your own memory allocation routines, define PNG_USER_MEM_SUPPORTED and use png_create_write_struct_2() instead of png_create_write_struct():<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_structp png_ptr = png_create_write_struct_2<br/>
       (PNG_LIBPNG_VER_STRING, (png_voidp)user_error_ptr,<br/>
        user_error_fn, user_warning_fn, (png_voidp)<br/>
        user_mem_ptr, user_malloc_fn, user_free_fn);<div style="height: 1.00em;">
&#160;</div>
After you have these structures, you will need to set up the error handling.  When libpng encounters an error, it expects to longjmp() back to your routine.  Therefore, you will need to call setjmp() and pass the png_jmpbuf(png_ptr).  If you write the file from different routines, you will need to update the png_jmpbuf(png_ptr) every time you enter a new routine that will call a png_*() function.  See your documentation of setjmp/longjmp for your compiler for more information on setjmp/longjmp.  See the discussion on libpng error handling in the Customizing Libpng section below for more information on the libpng error handling.<div style="height: 1.00em;">
&#160;</div>
<br/>
    if (setjmp(png_jmpbuf(png_ptr)))<br/>
    {<br/>
       png_destroy_write_struct(&amp;png_ptr, &amp;info_ptr);<br/>
       fclose(fp);<br/>
       return (ERROR);<br/>
    }<br/>
    ...<br/>
    return;<div style="height: 1.00em;">
&#160;</div>
If you would rather avoid the complexity of setjmp/longjmp issues, you can compile libpng with PNG_SETJMP_NOT_SUPPORTED, in which case errors will result in a call to PNG_ABORT() which defaults to abort().<div style="height: 1.00em;">
&#160;</div>
Now you need to set up the output code.  The default for libpng is to use the C function fwrite().  If you use this, you will need to pass a valid FILE * in the function png_init_io().  Be sure that the file is opened in binary mode.  Again, if you wish to handle writing data in another way, see the discussion on libpng I/O handling in the Customizing Libpng section below.<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_init_io(png_ptr, fp);<div style="height: 1.00em;">
&#160;</div>
If you are embedding your PNG into a datastream such as MNG, and don't want libpng to write the 8-byte signature, or if you have already written the signature in your application, use<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_sig_bytes(png_ptr, 8);<div style="height: 1.00em;">
&#160;</div>
to inform libpng that it should not write a signature.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>Write callbacks</h2> At this point, you can set up a callback function that will be called after each row has been written, which you can use to control a progress meter or the like.  It's demonstrated in pngtest.c. You must supply a function<div style="height: 1.00em;">
&#160;</div>
<br/>
    void write_row_callback(png_ptr, png_uint_32 row,<br/>
       int pass);<br/>
    {<br/>
      /* put your code here */<br/>
    }<div style="height: 1.00em;">
&#160;</div>
(You can give it another name that you like instead of &quot;write_row_callback&quot;)<div style="height: 1.00em;">
&#160;</div>
To inform libpng about your function, use<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_write_status_fn(png_ptr, write_row_callback);<div style="height: 1.00em;">
&#160;</div>
You now have the option of modifying how the compression library will run.  The following functions are mainly for testing, but may be useful in some cases, like if you need to write PNG files extremely fast and are willing to give up some compression, or if you want to get the maximum possible compression at the expense of slower writing.  If you have no special needs in this area, let the library do what it wants by not calling this function at all, as it has been tuned to deliver a good speed/compression ratio. The second parameter to png_set_filter() is the filter method, for which the only valid values are 0 (as of the July 1999 PNG specification, version 1.2) or 64 (if you are writing a PNG datastream that is to be embedded in a MNG datastream).  The third parameter is a flag that indicates which filter type(s) are to be tested for each scanline.  See the PNG specification for details on the specific filter types.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<br/>
    /* turn on or off filtering, and/or choose<br/>
       specific filters.  You can use either a single<br/>
       PNG_FILTER_VALUE_NAME or the bitwise OR of one<br/>
       or more PNG_FILTER_NAME masks. */<br/>
    png_set_filter(png_ptr, 0,<br/>
       PNG_FILTER_NONE  | PNG_FILTER_VALUE_NONE |<br/>
       PNG_FILTER_SUB   | PNG_FILTER_VALUE_SUB  |<br/>
       PNG_FILTER_UP    | PNG_FILTER_VALUE_UP   |<br/>
       PNG_FILTER_AVG   | PNG_FILTER_VALUE_AVG  |<br/>
       PNG_FILTER_PAETH | PNG_FILTER_VALUE_PAETH|<br/>
       PNG_ALL_FILTERS);<div style="height: 1.00em;">
&#160;</div>
If an application wants to start and stop using particular filters during compression, it should start out with all of the filters (to ensure that the previous row of pixels will be stored in case it's needed later), and then add and remove them after the start of compression.<div style="height: 1.00em;">
&#160;</div>
If you are writing a PNG datastream that is to be embedded in a MNG datastream, the second parameter can be either 0 or 64.<div style="height: 1.00em;">
&#160;</div>
The png_set_compression_*() functions interface to the zlib compression library, and should mostly be ignored unless you really know what you are doing.  The only generally useful call is png_set_compression_level() which changes how much time zlib spends on trying to compress the image data.  See the Compression Library (zlib.h and algorithm.txt, distributed with zlib) for details on the compression levels.<div style="height: 1.00em;">
&#160;</div>
<br/>
    /* set the zlib compression level */<br/>
    png_set_compression_level(png_ptr,<br/>
        Z_BEST_COMPRESSION);<div style="height: 1.00em;">
&#160;</div>
<br/>
    /* set other zlib parameters */<br/>
    png_set_compression_mem_level(png_ptr, 8);<br/>
    png_set_compression_strategy(png_ptr,<br/>
        Z_DEFAULT_STRATEGY);<br/>
    png_set_compression_window_bits(png_ptr, 15);<br/>
    png_set_compression_method(png_ptr, 8);<br/>
    png_set_compression_buffer_size(png_ptr, 8192)<div style="height: 1.00em;">
&#160;</div>
extern PNG_EXPORT(void,png_set_zbuf_size)<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>Setting the contents of info for output</h2> You now need to fill in the png_info structure with all the data you wish to write before the actual image.  Note that the only thing you are allowed to write after the image is the text chunks and the time chunk (as of PNG Specification 1.2, anyway).  See png_write_end() and the latest PNG specification for more information on that.  If you wish to write them before the image, fill them in now, and flag that data as being valid.  If you want to wait until after the data, don't fill them until png_write_end().  For all the fields in png_info and their data types, see png.h.  For explanations of what the fields contain, see the PNG specification.<div style="height: 1.00em;">
&#160;</div>
Some of the more important parts of the png_info are:<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_IHDR(png_ptr, info_ptr, width, height,<br/>
       bit_depth, color_type, interlace_type,<br/>
       compression_type, filter_method)<br/>
    width          - holds the width of the image<br/>
                     in pixels (up to 2^31).<br/>
    height         - holds the height of the image<br/>
                     in pixels (up to 2^31).<br/>
    bit_depth      - holds the bit depth of one of the<br/>
                     image channels.<br/>
                     (valid values are 1, 2, 4, 8, 16<br/>
                     and depend also on the<br/>
                     color_type.  See also significant<br/>
                     bits (sBIT) below).<br/>
    color_type     - describes which color/alpha<br/>
                     channels are present.<br/>
                     PNG_COLOR_TYPE_GRAY<br/>
                        (bit depths 1, 2, 4, 8, 16)<br/>
                     PNG_COLOR_TYPE_GRAY_ALPHA<br/>
                        (bit depths 8, 16)<br/>
                     PNG_COLOR_TYPE_PALETTE<br/>
                        (bit depths 1, 2, 4, 8)<br/>
                     PNG_COLOR_TYPE_RGB<br/>
                        (bit_depths 8, 16)<br/>
                     PNG_COLOR_TYPE_RGB_ALPHA<br/>
                        (bit_depths 8, 16)<div style="height: 1.00em;">
&#160;</div>
<br/>
                     PNG_COLOR_MASK_PALETTE<br/>
                     PNG_COLOR_MASK_COLOR<br/>
                     PNG_COLOR_MASK_ALPHA<div style="height: 1.00em;">
&#160;</div>
<br/>
    interlace_type - PNG_INTERLACE_NONE or<br/>
                     PNG_INTERLACE_ADAM7<br/>
    compression_type - (must be<br/>
                     PNG_COMPRESSION_TYPE_DEFAULT)<br/>
    filter_method  - (must be PNG_FILTER_TYPE_DEFAULT<br/>
                     or, if you are writing a PNG to<br/>
                     be embedded in a MNG datastream,<br/>
                     can also be<br/>
                     PNG_INTRAPIXEL_DIFFERENCING)<div style="height: 1.00em;">
&#160;</div>
If you call png_set_IHDR(), the call must appear before any of the other png_set_*() functions, because they might require access to some of the IHDR settings.  The remaining png_set_*() functions can be called in any order.<div style="height: 1.00em;">
&#160;</div>
If you wish, you can reset the compression_type, interlace_type, or filter_method later by calling png_set_IHDR() again; if you do this, the width, height, bit_depth, and color_type must be the same in each call.<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_PLTE(png_ptr, info_ptr, palette,<br/>
       num_palette);<br/>
    palette        - the palette for the file<br/>
                     (array of png_color)<br/>
    num_palette    - number of entries in the palette<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_gAMA(png_ptr, info_ptr, gamma);<br/>
    gamma          - the gamma the image was created<br/>
                     at (PNG_INFO_gAMA)<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_sRGB(png_ptr, info_ptr, srgb_intent);<br/>
    srgb_intent    - the rendering intent<br/>
                     (PNG_INFO_sRGB) The presence of<br/>
                     the sRGB chunk means that the pixel<br/>
                     data is in the sRGB color space.<br/>
                     This chunk also implies specific<br/>
                     values of gAMA and cHRM.  Rendering<br/>
                     intent is the CSS-1 property that<br/>
                     has been defined by the International<br/>
                     Color Consortium<br/>
                     (http://www.color.org).<br/>
                     It can be one of<br/>
                     PNG_sRGB_INTENT_SATURATION,<br/>
                     PNG_sRGB_INTENT_PERCEPTUAL,<br/>
                     PNG_sRGB_INTENT_ABSOLUTE, or<br/>
                     PNG_sRGB_INTENT_RELATIVE.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_sRGB_gAMA_and_cHRM(png_ptr, info_ptr,<br/>
       srgb_intent);<br/>
    srgb_intent    - the rendering intent<br/>
                     (PNG_INFO_sRGB) The presence of the<br/>
                     sRGB chunk means that the pixel<br/>
                     data is in the sRGB color space.<br/>
                     This function also causes gAMA and<br/>
                     cHRM chunks with the specific values<br/>
                     that are consistent with sRGB to be<br/>
                     written.<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_iCCP(png_ptr, info_ptr, name, compression_type,<br/>
                      profile, proflen);<br/>
    name            - The profile name.<br/>
    compression     - The compression type; always<br/>
                      PNG_COMPRESSION_TYPE_BASE for PNG 1.0.<br/>
                      You may give NULL to this argument to<br/>
                      ignore it.<br/>
    profile         - International Color Consortium color<br/>
                      profile data. May contain NULs.<br/>
    proflen         - length of profile data in bytes.<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_sBIT(png_ptr, info_ptr, sig_bit);<br/>
    sig_bit        - the number of significant bits for<br/>
                     (PNG_INFO_sBIT) each of the gray, red,<br/>
                     green, and blue channels, whichever are<br/>
                     appropriate for the given color type<br/>
                     (png_color_16)<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_tRNS(png_ptr, info_ptr, trans, num_trans,<br/>
       trans_values);<br/>
    trans          - array of transparent<br/>
                     entries for palette (PNG_INFO_tRNS)<br/>
    trans_values   - graylevel or color sample values<br/>
                     (in order red, green, blue) of the<br/>
                     single transparent color for<br/>
                     non-paletted images (PNG_INFO_tRNS)<br/>
    num_trans      - number of transparent entries<br/>
                     (PNG_INFO_tRNS)<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_hIST(png_ptr, info_ptr, hist);<br/>
                    (PNG_INFO_hIST)<br/>
    hist           - histogram of palette (array of<br/>
                     png_uint_16)<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_tIME(png_ptr, info_ptr, mod_time);<br/>
    mod_time       - time image was last modified<br/>
                     (PNG_VALID_tIME)<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_bKGD(png_ptr, info_ptr, background);<br/>
    background     - background color (PNG_VALID_bKGD)<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_text(png_ptr, info_ptr, text_ptr, num_text);<br/>
    text_ptr       - array of png_text holding image<br/>
                     comments<br/>
    text_ptr[i].compression - type of compression used<br/>
                 on &quot;text&quot; PNG_TEXT_COMPRESSION_NONE<br/>
                           PNG_TEXT_COMPRESSION_zTXt<br/>
                           PNG_ITXT_COMPRESSION_NONE<br/>
                           PNG_ITXT_COMPRESSION_zTXt<br/>
    text_ptr[i].key   - keyword for comment.  Must contain<br/>
                 1-79 characters.<br/>
    text_ptr[i].text  - text comments for current<br/>
                         keyword.  Can be NULL or empty.<br/>
    text_ptr[i].text_length - length of text string,<br/>
                 after decompression, 0 for iTXt<br/>
    text_ptr[i].itxt_length - length of itxt string,<br/>
                 after decompression, 0 for tEXt/zTXt<br/>
    text_ptr[i].lang  - language of comment (NULL or<br/>
                         empty for unknown).<br/>
    text_ptr[i].translated_keyword  - keyword in UTF-8 (NULL<br/>
                         or empty for unknown).<br/>
    Note that the itxt_length, lang, and lang_key<br/>
    members of the text_ptr structure only exist<br/>
    when the library is built with iTXt chunk support.<div style="height: 1.00em;">
&#160;</div>
<br/>
    num_text       - number of comments<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_sPLT(png_ptr, info_ptr, &amp;palette_ptr,<br/>
       num_spalettes);<br/>
    palette_ptr    - array of png_sPLT_struct structures<br/>
                     to be added to the list of palettes<br/>
                     in the info structure.<br/>
    num_spalettes  - number of palette structures to be<br/>
                     added.<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_oFFs(png_ptr, info_ptr, offset_x, offset_y,<br/>
        unit_type);<br/>
    offset_x  - positive offset from the left<br/>
                     edge of the screen<br/>
    offset_y  - positive offset from the top<br/>
                     edge of the screen<br/>
    unit_type - PNG_OFFSET_PIXEL, PNG_OFFSET_MICROMETER<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_pHYs(png_ptr, info_ptr, res_x, res_y,<br/>
        unit_type);<br/>
    res_x       - pixels/unit physical resolution<br/>
                  in x direction<br/>
    res_y       - pixels/unit physical resolution<br/>
                  in y direction<br/>
    unit_type   - PNG_RESOLUTION_UNKNOWN,<br/>
                  PNG_RESOLUTION_METER<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_sCAL(png_ptr, info_ptr, unit, width, height)<br/>
    unit        - physical scale units (an integer)<br/>
    width       - width of a pixel in physical scale units<br/>
    height      - height of a pixel in physical scale units<br/>
                  (width and height are doubles)<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_sCAL_s(png_ptr, info_ptr, unit, width, height)<br/>
    unit        - physical scale units (an integer)<br/>
    width       - width of a pixel in physical scale units<br/>
    height      - height of a pixel in physical scale units<br/>
                 (width and height are strings like &quot;2.54&quot;)<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_unknown_chunks(png_ptr, info_ptr, &amp;unknowns,<br/>
       num_unknowns)<br/>
    unknowns          - array of png_unknown_chunk<br/>
                        structures holding unknown chunks<br/>
    unknowns[i].name  - name of unknown chunk<br/>
    unknowns[i].data  - data of unknown chunk<br/>
    unknowns[i].size  - size of unknown chunk's data<br/>
    unknowns[i].location - position to write chunk in file<br/>
                           0: do not write chunk<br/>
                           PNG_HAVE_IHDR: before PLTE<br/>
                           PNG_HAVE_PLTE: before IDAT<br/>
                           PNG_AFTER_IDAT: after IDAT<div style="height: 1.00em;">
&#160;</div>
The &quot;location&quot; member is set automatically according to what part of the output file has already been written. You can change its value after calling png_set_unknown_chunks() as demonstrated in pngtest.c.  Within each of the &quot;locations&quot;, the chunks are sequenced according to their position in the structure (that is, the value of &quot;i&quot;, which is the order in which the chunk was either read from the input file or defined with png_set_unknown_chunks).<div style="height: 1.00em;">
&#160;</div>
A quick word about text and num_text.  text is an array of png_text structures.  num_text is the number of valid structures in the array. Each png_text structure holds a language code, a keyword, a text value, and a compression type.<div style="height: 1.00em;">
&#160;</div>
The compression types have the same valid numbers as the compression types of the image data.  Currently, the only valid number is zero. However, you can store text either compressed or uncompressed, unlike images, which always have to be compressed.  So if you don't want the text compressed, set the compression type to PNG_TEXT_COMPRESSION_NONE. Because tEXt and zTXt chunks don't have a language field, if you specify PNG_TEXT_COMPRESSION_NONE or PNG_TEXT_COMPRESSION_zTXt any language code or translated keyword will not be written out.<div style="height: 1.00em;">
&#160;</div>
Until text gets around 1000 bytes, it is not worth compressing it. After the text has been written out to the file, the compression type is set to PNG_TEXT_COMPRESSION_NONE_WR or PNG_TEXT_COMPRESSION_zTXt_WR, so that it isn't written out again at the end (in case you are calling png_write_end() with the same struct.<div style="height: 1.00em;">
&#160;</div>
The keywords that are given in the PNG Specification are:<div style="height: 1.00em;">
&#160;</div>
<br/>
    Title            Short (one line) title or<br/>
                     caption for image<br/>
    Author           Name of image's creator<br/>
    Description      Description of image (possibly long)<br/>
    Copyright        Copyright notice<br/>
    Creation Time    Time of original image creation<br/>
                     (usually RFC 1123 format, see below)<br/>
    Software         Software used to create the image<br/>
    Disclaimer       Legal disclaimer<br/>
    Warning          Warning of nature of content<br/>
    Source           Device used to create the image<br/>
    Comment          Miscellaneous comment; conversion<br/>
                     from other image format<div style="height: 1.00em;">
&#160;</div>
The keyword-text pairs work like this.  Keywords should be short simple descriptions of what the comment is about.  Some typical keywords are found in the PNG specification, as is some recommendations on keywords.  You can repeat keywords in a file.  You can even write some text before the image and some after.  For example, you may want to put a description of the image before the image, but leave the disclaimer until after, so viewers working over modem connections don't have to wait for the disclaimer to go over the modem before they start seeing the image.  Finally, keywords should be full words, not abbreviations.  Keywords and text are in the ISO 8859-1 (Latin-1) character set (a superset of regular ASCII) and can not contain NUL characters, and should not contain control or other unprintable characters.  To make the comments widely readable, stick with basic ASCII, and avoid machine specific character set extensions like the IBM-PC character set.  The keyword must be present, but you can leave off the text string on non-compressed pairs. Compressed pairs must have a text string, as only the text string is compressed anyway, so the compression would be meaningless.<div style="height: 1.00em;">
&#160;</div>
PNG supports modification time via the png_time structure.  Two conversion routines are provided, png_convert_from_time_t() for time_t and png_convert_from_struct_tm() for struct tm.  The time_t routine uses gmtime().  You don't have to use either of these, but if you wish to fill in the png_time structure directly, you should provide the time in universal time (GMT) if possible instead of your local time.  Note that the year number is the full year (e.g. 1998, rather than 98 - PNG is year 2000 compliant!), and that months start with 1.<div style="height: 1.00em;">
&#160;</div>
If you want to store the time of the original image creation, you should use a plain tEXt chunk with the &quot;Creation Time&quot; keyword.  This is necessary because the &quot;creation time&quot; of a PNG image is somewhat vague, depending on whether you mean the PNG file, the time the image was created in a non-PNG format, a still photo from which the image was scanned, or possibly the subject matter itself.  In order to facilitate machine-readable dates, it is recommended that the &quot;Creation Time&quot; tEXt chunk use RFC 1123 format dates (e.g. &quot;22 May 1997 18:07:10 GMT&quot;), although this isn't a requirement.  Unlike the tIME chunk, the &quot;Creation Time&quot; tEXt chunk is not expected to be automatically changed by the software.  To facilitate the use of RFC 1123 dates, a function png_convert_to_rfc1123(png_timep) is provided to convert from PNG time to an RFC 1123 format string.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>Writing unknown chunks</h2> You can use the png_set_unknown_chunks function to queue up chunks for writing.  You give it a chunk name, raw data, and a size; that's all there is to it.  The chunks will be written by the next following png_write_info_before_PLTE, png_write_info, or png_write_end function. Any chunks previously read into the info structure's unknown-chunk list will also be written out in a sequence that satisfies the PNG specification's ordering rules.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>The high-level write interface</h2> At this point there are two ways to proceed; through the high-level write interface, or through a sequence of low-level write operations. You can use the high-level interface if your image data is present in the info structure.  All defined output transformations are permitted, enabled by the following masks.<div style="height: 1.00em;">
&#160;</div>
<br/>
    PNG_TRANSFORM_IDENTITY      No transformation<br/>
    PNG_TRANSFORM_PACKING       Pack 1, 2 and 4-bit samples<br/>
    PNG_TRANSFORM_PACKSWAP      Change order of packed<br/>
                                pixels to LSB first<br/>
    PNG_TRANSFORM_INVERT_MONO   Invert monochrome images<br/>
    PNG_TRANSFORM_SHIFT         Normalize pixels to the<br/>
                                sBIT depth<br/>
    PNG_TRANSFORM_BGR           Flip RGB to BGR, RGBA<br/>
                                to BGRA<br/>
    PNG_TRANSFORM_SWAP_ALPHA    Flip RGBA to ARGB or GA<br/>
                                to AG<br/>
    PNG_TRANSFORM_INVERT_ALPHA  Change alpha from opacity<br/>
                                to transparency<br/>
    PNG_TRANSFORM_SWAP_ENDIAN   Byte-swap 16-bit samples<br/>
    PNG_TRANSFORM_STRIP_FILLER        Strip out filler<br/>
                                      bytes (deprecated).<br/>
    PNG_TRANSFORM_STRIP_FILLER_BEFORE Strip out leading<br/>
                                      filler bytes<br/>
    PNG_TRANSFORM_STRIP_FILLER_AFTER  Strip out trailing<br/>
                                      filler bytes<div style="height: 1.00em;">
&#160;</div>
If you have valid image data in the info structure (you can use png_set_rows() to put image data in the info structure), simply do this:<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_write_png(png_ptr, info_ptr, png_transforms, NULL)<div style="height: 1.00em;">
&#160;</div>
where png_transforms is an integer containing the bitwise OR of some set of transformation flags.  This call is equivalent to png_write_info(), followed the set of transformations indicated by the transform mask, then png_write_image(), and finally png_write_end().<div style="height: 1.00em;">
&#160;</div>
(The final parameter of this call is not yet used.  Someday it might point to transformation parameters required by some future output transform.)<div style="height: 1.00em;">
&#160;</div>
You must use png_transforms and not call any png_set_transform() functions when you use png_write_png().<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>The low-level write interface</h2> If you are going the low-level route instead, you are now ready to write all the file information up to the actual image data.  You do this with a call to png_write_info().<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_write_info(png_ptr, info_ptr);<div style="height: 1.00em;">
&#160;</div>
Note that there is one transformation you may need to do before png_write_info().  In PNG files, the alpha channel in an image is the level of opacity.  If your data is supplied as a level of transparency, you can invert the alpha channel before you write it, so that 0 is fully transparent and 255 (in 8-bit or paletted images) or 65535 (in 16-bit images) is fully opaque, with<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_invert_alpha(png_ptr);<div style="height: 1.00em;">
&#160;</div>
This must appear before png_write_info() instead of later with the other transformations because in the case of paletted images the tRNS chunk data has to be inverted before the tRNS chunk is written.  If your image is not a paletted image, the tRNS data (which in such cases represents a single color to be rendered as transparent) won't need to be changed, and you can safely do this transformation after your png_write_info() call.<div style="height: 1.00em;">
&#160;</div>
If you need to write a private chunk that you want to appear before the PLTE chunk when PLTE is present, you can write the PNG info in two steps, and insert code to write your own chunk between them:<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_write_info_before_PLTE(png_ptr, info_ptr);<br/>
    png_set_unknown_chunks(png_ptr, info_ptr, ...);<br/>
    png_write_info(png_ptr, info_ptr);<div style="height: 1.00em;">
&#160;</div>
After you've written the file information, you can set up the library to handle any special transformations of the image data.  The various ways to transform the data will be described in the order that they should occur.  This is important, as some of these change the color type and/or bit depth of the data, and some others only work on certain color types and bit depths.  Even though each transformation checks to see if it has data that it can do something with, you should make sure to only enable a transformation if it will be valid for the data.  For example, don't swap red and blue on grayscale data.<div style="height: 1.00em;">
&#160;</div>
PNG files store RGB pixels packed into 3 or 6 bytes.  This code tells the library to strip input data that has 4 or 8 bytes per pixel down to 3 or 6 bytes (or strip 2 or 4-byte grayscale+filler data to 1 or 2 bytes per pixel).<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_filler(png_ptr, 0, PNG_FILLER_BEFORE);<div style="height: 1.00em;">
&#160;</div>
where the 0 is unused, and the location is either PNG_FILLER_BEFORE or PNG_FILLER_AFTER, depending upon whether the filler byte in the pixel is stored XRGB or RGBX.<div style="height: 1.00em;">
&#160;</div>
PNG files pack pixels of bit depths 1, 2, and 4 into bytes as small as they can, resulting in, for example, 8 pixels per byte for 1 bit files. If the data is supplied at 1 pixel per byte, use this code, which will correctly pack the pixels into a single byte:<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_packing(png_ptr);<div style="height: 1.00em;">
&#160;</div>
PNG files reduce possible bit depths to 1, 2, 4, 8, and 16.  If your data is of another bit depth, you can write an sBIT chunk into the file so that decoders can recover the original data if desired.<div style="height: 1.00em;">
&#160;</div>
<br/>
    /* Set the true bit depth of the image data */<br/>
    if (color_type &amp; PNG_COLOR_MASK_COLOR)<br/>
    {<br/>
        sig_bit.red = true_bit_depth;<br/>
        sig_bit.green = true_bit_depth;<br/>
        sig_bit.blue = true_bit_depth;<br/>
    }<br/>
    else<br/>
    {<br/>
        sig_bit.gray = true_bit_depth;<br/>
    }<br/>
    if (color_type &amp; PNG_COLOR_MASK_ALPHA)<br/>
    {<br/>
        sig_bit.alpha = true_bit_depth;<br/>
    }<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_sBIT(png_ptr, info_ptr, &amp;sig_bit);<div style="height: 1.00em;">
&#160;</div>
If the data is stored in the row buffer in a bit depth other than one supported by PNG (e.g. 3 bit data in the range 0-7 for a 4-bit PNG), this will scale the values to appear to be the correct bit depth as is required by PNG.<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_shift(png_ptr, &amp;sig_bit);<div style="height: 1.00em;">
&#160;</div>
PNG files store 16 bit pixels in network byte order (big-endian, ie. most significant bits first).  This code would be used if they are supplied the other way (little-endian, i.e. least significant bits first, the way PCs store them):<div style="height: 1.00em;">
&#160;</div>
<br/>
    if (bit_depth &gt; 8)<br/>
       png_set_swap(png_ptr);<div style="height: 1.00em;">
&#160;</div>
If you are using packed-pixel images (1, 2, or 4 bits/pixel), and you need to change the order the pixels are packed into bytes, you can use:<div style="height: 1.00em;">
&#160;</div>
<br/>
    if (bit_depth &lt; 8)<br/>
       png_set_packswap(png_ptr);<div style="height: 1.00em;">
&#160;</div>
PNG files store 3 color pixels in red, green, blue order.  This code would be used if they are supplied as blue, green, red:<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_bgr(png_ptr);<div style="height: 1.00em;">
&#160;</div>
PNG files describe monochrome as black being zero and white being one. This code would be used if the pixels are supplied with this reversed (black being one and white being zero):<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_invert_mono(png_ptr);<div style="height: 1.00em;">
&#160;</div>
Finally, you can write your own transformation function if none of the existing ones meets your needs.  This is done by setting a callback with<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_write_user_transform_fn(png_ptr,<br/>
       write_transform_fn);<div style="height: 1.00em;">
&#160;</div>
You must supply the function<div style="height: 1.00em;">
&#160;</div>
<br/>
    void write_transform_fn(png_ptr ptr, row_info_ptr<br/>
       row_info, png_bytep data)<div style="height: 1.00em;">
&#160;</div>
See pngtest.c for a working example.  Your function will be called before any of the other transformations are processed.<div style="height: 1.00em;">
&#160;</div>
You can also set up a pointer to a user structure for use by your callback function.<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_user_transform_info(png_ptr, user_ptr, 0, 0);<div style="height: 1.00em;">
&#160;</div>
The user_channels and user_depth parameters of this function are ignored when writing; you can set them to zero as shown.<div style="height: 1.00em;">
&#160;</div>
You can retrieve the pointer via the function png_get_user_transform_ptr(). For example:<div style="height: 1.00em;">
&#160;</div>
<br/>
    voidp write_user_transform_ptr =<br/>
       png_get_user_transform_ptr(png_ptr);<div style="height: 1.00em;">
&#160;</div>
It is possible to have libpng flush any pending output, either manually, or automatically after a certain number of lines have been written.  To flush the output stream a single time call:<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_write_flush(png_ptr);<div style="height: 1.00em;">
&#160;</div>
and to have libpng flush the output stream periodically after a certain number of scanlines have been written, call:<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_flush(png_ptr, nrows);<div style="height: 1.00em;">
&#160;</div>
Note that the distance between rows is from the last time png_write_flush() was called, or the first row of the image if it has never been called. So if you write 50 lines, and then png_set_flush 25, it will flush the output on the next scanline, and every 25 lines thereafter, unless png_write_flush() is called before 25 more lines have been written. If nrows is too small (less than about 10 lines for a 640 pixel wide RGB image) the image compression may decrease noticeably (although this may be acceptable for real-time applications).  Infrequent flushing will only degrade the compression performance by a few percent over images that do not use flushing.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>Writing the image data</h2> That's it for the transformations.  Now you can write the image data. The simplest way to do this is in one function call.  If you have the whole image in memory, you can just call png_write_image() and libpng will write the image.  You will need to pass in an array of pointers to each row.  This function automatically handles interlacing, so you don't need to call png_set_interlace_handling() or call this function multiple times, or any of that other stuff necessary with png_write_rows().<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_write_image(png_ptr, row_pointers);<div style="height: 1.00em;">
&#160;</div>
where row_pointers is:<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_byte *row_pointers[height];<div style="height: 1.00em;">
&#160;</div>
You can point to void or char or whatever you use for pixels.<div style="height: 1.00em;">
&#160;</div>
If you don't want to write the whole image at once, you can use png_write_rows() instead.  If the file is not interlaced, this is simple:<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_write_rows(png_ptr, row_pointers,<br/>
       number_of_rows);<div style="height: 1.00em;">
&#160;</div>
row_pointers is the same as in the png_write_image() call.<div style="height: 1.00em;">
&#160;</div>
If you are just writing one row at a time, you can do this with a single row_pointer instead of an array of row_pointers:<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_bytep row_pointer = row;<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_write_row(png_ptr, row_pointer);<div style="height: 1.00em;">
&#160;</div>
When the file is interlaced, things can get a good deal more complicated. The only currently (as of the PNG Specification version 1.2, dated July 1999) defined interlacing scheme for PNG files is the &quot;Adam7&quot; interlace scheme, that breaks down an image into seven smaller images of varying size.  libpng will build these images for you, or you can do them yourself.  If you want to build them yourself, see the PNG specification for details of which pixels to write when.<div style="height: 1.00em;">
&#160;</div>
If you don't want libpng to handle the interlacing details, just use png_set_interlace_handling() and call png_write_rows() the correct number of times to write all seven sub-images.<div style="height: 1.00em;">
&#160;</div>
If you want libpng to build the sub-images, call this before you start writing any rows:<div style="height: 1.00em;">
&#160;</div>
<br/>
    number_of_passes =<br/>
       png_set_interlace_handling(png_ptr);<div style="height: 1.00em;">
&#160;</div>
This will return the number of passes needed.  Currently, this is seven, but may change if another interlace type is added.<div style="height: 1.00em;">
&#160;</div>
Then write the complete image number_of_passes times.<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_write_rows(png_ptr, row_pointers,<br/>
       number_of_rows);<div style="height: 1.00em;">
&#160;</div>
As some of these rows are not used, and thus return immediately, you may want to read about interlacing in the PNG specification, and only update the rows that are actually used.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>Finishing a sequential write</h2> After you are finished writing the image, you should finish writing the file.  If you are interested in writing comments or time, you should pass an appropriately filled png_info pointer.  If you are not interested, you can pass NULL.<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_write_end(png_ptr, info_ptr);<div style="height: 1.00em;">
&#160;</div>
When you are done, you can free all memory used by libpng like this:<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_destroy_write_struct(&amp;png_ptr, &amp;info_ptr);<div style="height: 1.00em;">
&#160;</div>
It is also possible to individually free the info_ptr members that point to libpng-allocated storage with the following function:<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_free_data(png_ptr, info_ptr, mask, seq)<br/>
    mask  - identifies data to be freed, a mask<br/>
            containing the bitwise OR of one or<br/>
            more of<br/>
              PNG_FREE_PLTE, PNG_FREE_TRNS,<br/>
              PNG_FREE_HIST, PNG_FREE_ICCP,<br/>
              PNG_FREE_PCAL, PNG_FREE_ROWS,<br/>
              PNG_FREE_SCAL, PNG_FREE_SPLT,<br/>
              PNG_FREE_TEXT, PNG_FREE_UNKN,<br/>
            or simply PNG_FREE_ALL<br/>
    seq   - sequence number of item to be freed<br/>
            (-1 for all items)<div style="height: 1.00em;">
&#160;</div>
This function may be safely called when the relevant storage has already been freed, or has not yet been allocated, or was allocated by the user  and not by libpng,  and will in those cases do nothing. The &quot;seq&quot; parameter is ignored if only one item of the selected data type, such as PLTE, is allowed.  If &quot;seq&quot; is not -1, and multiple items are allowed for the data type identified in the mask, such as text or sPLT, only the n'th item in the structure is freed, where n is &quot;seq&quot;.<div style="height: 1.00em;">
&#160;</div>
If you allocated data such as a palette that you passed in to libpng with png_set_*, you must not free it until just before the call to png_destroy_write_struct().<div style="height: 1.00em;">
&#160;</div>
The default behavior is only to free data that was allocated internally by libpng.  This can be changed, so that libpng will not free the data, or so that it will free data that was allocated by the user with png_malloc() or png_zalloc() and passed in via a png_set_*() function, with<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_data_freer(png_ptr, info_ptr, freer, mask)<br/>
    mask   - which data elements are affected<br/>
             same choices as in png_free_data()<br/>
    freer  - one of<br/>
               PNG_DESTROY_WILL_FREE_DATA<br/>
               PNG_SET_WILL_FREE_DATA<br/>
               PNG_USER_WILL_FREE_DATA<div style="height: 1.00em;">
&#160;</div>
For example, to transfer responsibility for some data from a read structure to a write structure, you could use<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_data_freer(read_ptr, read_info_ptr,<br/>
       PNG_USER_WILL_FREE_DATA,<br/>
       PNG_FREE_PLTE|PNG_FREE_tRNS|PNG_FREE_hIST)<br/>
    png_data_freer(write_ptr, write_info_ptr,<br/>
       PNG_DESTROY_WILL_FREE_DATA,<br/>
       PNG_FREE_PLTE|PNG_FREE_tRNS|PNG_FREE_hIST)<div style="height: 1.00em;">
&#160;</div>
thereby briefly reassigning responsibility for freeing to the user but immediately afterwards reassigning it once more to the write_destroy function.  Having done this, it would then be safe to destroy the read structure and continue to use the PLTE, tRNS, and hIST data in the write structure.<div style="height: 1.00em;">
&#160;</div>
This function only affects data that has already been allocated. You can call this function before calling after the png_set_*() functions to control whether the user or png_destroy_*() is supposed to free the data. When the user assumes responsibility for libpng-allocated data, the application must use png_free() to free it, and when the user transfers responsibility to libpng for data that the user has allocated, the user must have used png_malloc() or png_zalloc() to allocate it.<div style="height: 1.00em;">
&#160;</div>
If you allocated text_ptr.text, text_ptr.lang, and text_ptr.translated_keyword separately, do not transfer responsibility for freeing text_ptr to libpng, because when libpng fills a png_text structure it combines these members with the key member, and png_free_data() will free only text_ptr.key.  Similarly, if you transfer responsibility for free'ing text_ptr from libpng to your application, your application must not separately free those members. For a more compact example of writing a PNG image, see the file example.c.<div style="height: 1.00em;">
&#160;</div>
</div>
</div>
<div class="section">
<h1>V. Modifying/Customizing libpng:</h1> There are two issues here.  The first is changing how libpng does standard things like memory allocation, input/output, and error handling. The second deals with more complicated things like adding new chunks, adding new transformations, and generally changing how libpng works. Both of those are compile-time issues; that is, they are generally determined at the time the code is written, and there is rarely a need to provide the user with a means of changing them.<div style="height: 1.00em;">
&#160;</div>
Memory allocation, input/output, and error handling<div style="height: 1.00em;">
&#160;</div>
All of the memory allocation, input/output, and error handling in libpng goes through callbacks that are user-settable.  The default routines are in pngmem.c, pngrio.c, pngwio.c, and pngerror.c, respectively.  To change these functions, call the appropriate png_set_*_fn() function.<div style="height: 1.00em;">
&#160;</div>
Memory allocation is done through the functions png_malloc(), png_calloc(), and png_free().  These currently just call the standard C functions. png_calloc() calls png_malloc() and then png_memset() to clear the newly allocated memory to zero.  If your pointers can't access more then 64K at a time, you will want to set MAXSEG_64K in zlib.h.  Since it is unlikely that the method of handling memory allocation on a platform will change between applications, these functions must be modified in the library at compile time.  If you prefer to use a different method of allocating and freeing data, you can use png_create_read_struct_2() or png_create_write_struct_2() to register your own functions as described above.  These functions also provide a void pointer that can be retrieved via<div style="height: 1.00em;">
&#160;</div>
<br/>
    mem_ptr=png_get_mem_ptr(png_ptr);<div style="height: 1.00em;">
&#160;</div>
Your replacement memory functions must have prototypes as follows:<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_voidp malloc_fn(png_structp png_ptr,<br/>
       png_size_t size);<br/>
    void free_fn(png_structp png_ptr, png_voidp ptr);<div style="height: 1.00em;">
&#160;</div>
Your malloc_fn() must return NULL in case of failure.  The png_malloc() function will normally call png_error() if it receives a NULL from the system memory allocator or from your replacement malloc_fn().<div style="height: 1.00em;">
&#160;</div>
Your free_fn() will never be called with a NULL ptr, since libpng's png_free() checks for NULL before calling free_fn().<div style="height: 1.00em;">
&#160;</div>
Input/Output in libpng is done through png_read() and png_write(), which currently just call fread() and fwrite().  The FILE * is stored in png_struct and is initialized via png_init_io().  If you wish to change the method of I/O, the library supplies callbacks that you can set through the function png_set_read_fn() and png_set_write_fn() at run time, instead of calling the png_init_io() function.  These functions also provide a void pointer that can be retrieved via the function png_get_io_ptr().  For example:<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_read_fn(png_structp read_ptr,<br/>
        voidp read_io_ptr, png_rw_ptr read_data_fn)<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_write_fn(png_structp write_ptr,<br/>
        voidp write_io_ptr, png_rw_ptr write_data_fn,<br/>
        png_flush_ptr output_flush_fn);<div style="height: 1.00em;">
&#160;</div>
<br/>
    voidp read_io_ptr = png_get_io_ptr(read_ptr);<br/>
    voidp write_io_ptr = png_get_io_ptr(write_ptr);<div style="height: 1.00em;">
&#160;</div>
The replacement I/O functions must have prototypes as follows:<div style="height: 1.00em;">
&#160;</div>
<br/>
    void user_read_data(png_structp png_ptr,<br/>
        png_bytep data, png_size_t length);<br/>
    void user_write_data(png_structp png_ptr,<br/>
        png_bytep data, png_size_t length);<br/>
    void user_flush_data(png_structp png_ptr);<div style="height: 1.00em;">
&#160;</div>
The user_read_data() function is responsible for detecting and handling end-of-data errors.<div style="height: 1.00em;">
&#160;</div>
Supplying NULL for the read, write, or flush functions sets them back to using the default C stream functions, which expect the io_ptr to point to a standard *FILE structure.  It is probably a mistake to use NULL for one of write_data_fn and output_flush_fn but not both of them, unless you have built libpng with PNG_NO_WRITE_FLUSH defined. It is an error to read from a write stream, and vice versa.<div style="height: 1.00em;">
&#160;</div>
Error handling in libpng is done through png_error() and png_warning(). Errors handled through png_error() are fatal, meaning that png_error() should never return to its caller.  Currently, this is handled via setjmp() and longjmp() (unless you have compiled libpng with PNG_SETJMP_NOT_SUPPORTED, in which case it is handled via PNG_ABORT()), but you could change this to do things like exit() if you should wish.<div style="height: 1.00em;">
&#160;</div>
On non-fatal errors, png_warning() is called to print a warning message, and then control returns to the calling code. By default png_error() and png_warning() print a message on stderr via fprintf() unless the library is compiled with PNG_NO_CONSOLE_IO defined (because you don't want the messages) or PNG_NO_STDIO defined (because fprintf() isn't available).  If you wish to change the behavior of the error functions, you will need to set up your own message callbacks.  These functions are normally supplied at the time that the png_struct is created. It is also possible to redirect errors and warnings to your own replacement functions after png_create_*_struct() has been called by calling:<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_error_fn(png_structp png_ptr,<br/>
        png_voidp error_ptr, png_error_ptr error_fn,<br/>
        png_error_ptr warning_fn);<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_voidp error_ptr = png_get_error_ptr(png_ptr);<div style="height: 1.00em;">
&#160;</div>
If NULL is supplied for either error_fn or warning_fn, then the libpng default function will be used, calling fprintf() and/or longjmp() if a problem is encountered.  The replacement error functions should have parameters as follows:<div style="height: 1.00em;">
&#160;</div>
<br/>
    void user_error_fn(png_structp png_ptr,<br/>
        png_const_charp error_msg);<br/>
    void user_warning_fn(png_structp png_ptr,<br/>
        png_const_charp warning_msg);<div style="height: 1.00em;">
&#160;</div>
The motivation behind using setjmp() and longjmp() is the C++ throw and catch exception handling methods.  This makes the code much easier to write, as there is no need to check every return code of every function call. However, there are some uncertainties about the status of local variables after a longjmp, so the user may want to be careful about doing anything after setjmp returns non-zero besides returning itself.  Consult your compiler documentation for more details.  For an alternative approach, you may wish to use the &quot;cexcept&quot; facility (see http://cexcept.sourceforge.net).<div style="height: 1.00em;">
&#160;</div>
<div class="subsection">
<h2>Custom chunks</h2> If you need to read or write custom chunks, you may need to get deeper into the libpng code.  The library now has mechanisms for storing and writing chunks of unknown type; you can even declare callbacks for custom chunks.  However, this may not be good enough if the library code itself needs to know about interactions between your chunk and existing `intrinsic' chunks.<div style="height: 1.00em;">
&#160;</div>
If you need to write a new intrinsic chunk, first read the PNG specification. Acquire a first level of understanding of how it works. Pay particular attention to the sections that describe chunk names, and look at how other chunks were designed, so you can do things similarly.  Second, check out the sections of libpng that read and write chunks.  Try to find a chunk that is similar to yours and use it as a template.  More details can be found in the comments inside the code.  It is best to handle unknown chunks in a generic method, via callback functions, instead of by modifying libpng functions.<div style="height: 1.00em;">
&#160;</div>
If you wish to write your own transformation for the data, look through the part of the code that does the transformations, and check out some of the simpler ones to get an idea of how they work.  Try to find a similar transformation to the one you want to add and copy off of it.  More details can be found in the comments inside the code itself.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>Configuring for 16 bit platforms</h2> You will want to look into zconf.h to tell zlib (and thus libpng) that it cannot allocate more then 64K at a time.  Even if you can, the memory won't be accessible.  So limit zlib and libpng to 64K by defining MAXSEG_64K.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>Configuring for DOS</h2> For DOS users who only have access to the lower 640K, you will have to limit zlib's memory usage via a png_set_compression_mem_level() call.  See zlib.h or zconf.h in the zlib library for more information.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>Configuring for Medium Model</h2> Libpng's support for medium model has been tested on most of the popular compilers.  Make sure MAXSEG_64K gets defined, USE_FAR_KEYWORD gets defined, and FAR gets defined to far in pngconf.h, and you should be all set.  Everything in the library (except for zlib's structure) is expecting far data.  You must use the typedefs with the p or pp on the end for pointers (or at least look at them and be careful).  Make note that the rows of data are defined as png_bytepp, which is an unsigned char far * far *.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>Configuring for gui/windowing platforms:</h2> You will need to write new error and warning functions that use the GUI interface, as described previously, and set them to be the error and warning functions at the time that png_create_*_struct() is called, in order to have them available during the structure initialization. They can be changed later via png_set_error_fn().  On some compilers, you may also have to change the memory allocators (png_malloc, etc.).<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>Configuring for compiler xxx:</h2> All includes for libpng are in pngconf.h.  If you need to add, change or delete an include, this is the place to do it. The includes that are not needed outside libpng are protected by the PNG_INTERNAL definition, which is only defined for those routines inside libpng itself.  The files in libpng proper only include png.h, which includes pngconf.h.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>Configuring zlib:</h2> There are special functions to configure the compression.  Perhaps the most useful one changes the compression level, which currently uses input compression values in the range 0 - 9.  The library normally uses the default compression level (Z_DEFAULT_COMPRESSION = 6).  Tests have shown that for a large majority of images, compression values in the range 3-6 compress nearly as well as higher levels, and do so much faster.  For online applications it may be desirable to have maximum speed (Z_BEST_SPEED = 1).  With versions of zlib after v0.99, you can also specify no compression (Z_NO_COMPRESSION = 0), but this would create files larger than just storing the raw bitmap.  You can specify the compression level by calling:<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_compression_level(png_ptr, level);<div style="height: 1.00em;">
&#160;</div>
Another useful one is to reduce the memory level used by the library. The memory level defaults to 8, but it can be lowered if you are short on memory (running DOS, for example, where you only have 640K). Note that the memory level does have an effect on compression; among other things, lower levels will result in sections of incompressible data being emitted in smaller stored blocks, with a correspondingly larger relative overhead of up to 15% in the worst case.<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_compression_mem_level(png_ptr, level);<div style="height: 1.00em;">
&#160;</div>
The other functions are for configuring zlib.  They are not recommended for normal use and may result in writing an invalid PNG file.  See zlib.h for more information on what these mean.<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_compression_strategy(png_ptr,<br/>
        strategy);<br/>
    png_set_compression_window_bits(png_ptr,<br/>
        window_bits);<br/>
    png_set_compression_method(png_ptr, method);<br/>
    png_set_compression_buffer_size(png_ptr, size);<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>Controlling row filtering</h2> If you want to control whether libpng uses filtering or not, which filters are used, and how it goes about picking row filters, you can call one of these functions.  The selection and configuration of row filters can have a significant impact on the size and encoding speed and a somewhat lesser impact on the decoding speed of an image.  Filtering is enabled by default for RGB and grayscale images (with and without alpha), but not for paletted images nor for any images with bit depths less than 8 bits/pixel.<div style="height: 1.00em;">
&#160;</div>
The 'method' parameter sets the main filtering method, which is currently only '0' in the PNG 1.2 specification.  The 'filters' parameter sets which filter(s), if any, should be used for each scanline.  Possible values are PNG_ALL_FILTERS and PNG_NO_FILTERS to turn filtering on and off, respectively.<div style="height: 1.00em;">
&#160;</div>
Individual filter types are PNG_FILTER_NONE, PNG_FILTER_SUB, PNG_FILTER_UP, PNG_FILTER_AVG, PNG_FILTER_PAETH, which can be bitwise ORed together with '|' to specify one or more filters to use. These filters are described in more detail in the PNG specification. If you intend to change the filter type during the course of writing the image, you should start with flags set for all of the filters you intend to use so that libpng can initialize its internal structures appropriately for all of the filter types.  (Note that this means the first row must always be adaptively filtered, because libpng currently does not allocate the filter buffers until png_write_row() is called for the first time.)<div style="height: 1.00em;">
&#160;</div>
<br/>
    filters = PNG_FILTER_NONE | PNG_FILTER_SUB<br/>
              PNG_FILTER_UP | PNG_FILTER_AVG |<br/>
              PNG_FILTER_PAETH | PNG_ALL_FILTERS;<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_filter(png_ptr, PNG_FILTER_TYPE_BASE,<br/>
       filters);<br/>
              The second parameter can also be<br/>
              PNG_INTRAPIXEL_DIFFERENCING if you are<br/>
              writing a PNG to be embedded in a MNG<br/>
              datastream.  This parameter must be the<br/>
              same as the value of filter_method used<br/>
              in png_set_IHDR().<div style="height: 1.00em;">
&#160;</div>
It is also possible to influence how libpng chooses from among the available filters.  This is done in one or both of two ways - by telling it how important it is to keep the same filter for successive rows, and by telling it the relative computational costs of the filters.<div style="height: 1.00em;">
&#160;</div>
<br/>
    double weights[3] = {1.5, 1.3, 1.1},<br/>
       costs[PNG_FILTER_VALUE_LAST] =<br/>
       {1.0, 1.3, 1.3, 1.5, 1.7};<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_set_filter_heuristics(png_ptr,<br/>
       PNG_FILTER_HEURISTIC_WEIGHTED, 3,<br/>
       weights, costs);<div style="height: 1.00em;">
&#160;</div>
The weights are multiplying factors that indicate to libpng that the row filter should be the same for successive rows unless another row filter is that many times better than the previous filter.  In the above example, if the previous 3 filters were SUB, SUB, NONE, the SUB filter could have a &quot;sum of absolute differences&quot; 1.5 x 1.3 times higher than other filters and still be chosen, while the NONE filter could have a sum 1.1 times higher than other filters and still be chosen.  Unspecified weights are taken to be 1.0, and the specified weights should probably be declining like those above in order to emphasize recent filters over older filters.<div style="height: 1.00em;">
&#160;</div>
The filter costs specify for each filter type a relative decoding cost to be considered when selecting row filters.  This means that filters with higher costs are less likely to be chosen over filters with lower costs, unless their &quot;sum of absolute differences&quot; is that much smaller. The costs do not necessarily reflect the exact computational speeds of the various filters, since this would unduly influence the final image size.<div style="height: 1.00em;">
&#160;</div>
Note that the numbers above were invented purely for this example and are given only to help explain the function usage.  Little testing has been done to find optimum values for either the costs or the weights.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>Removing unwanted object code</h2> There are a bunch of #define's in pngconf.h that control what parts of libpng are compiled.  All the defines end in _SUPPORTED.  If you are never going to use a capability, you can change the #define to #undef before recompiling libpng and save yourself code and data space, or you can turn off individual capabilities with defines that begin with PNG_NO_.<div style="height: 1.00em;">
&#160;</div>
You can also turn all of the transforms and ancillary chunk capabilities off en masse with compiler directives that define PNG_NO_READ[or WRITE]_TRANSFORMS, or PNG_NO_READ[or WRITE]_ANCILLARY_CHUNKS, or all four, along with directives to turn on any of the capabilities that you do want.  The PNG_NO_READ[or WRITE]_TRANSFORMS directives disable the extra transformations but still leave the library fully capable of reading and writing PNG files with all known public chunks. Use of the PNG_NO_READ[or WRITE]_ANCILLARY_CHUNKS directive produces a library that is incapable of reading or writing ancillary chunks.  If you are not using the progressive reading capability, you can turn that off with PNG_NO_PROGRESSIVE_READ (don't confuse this with the INTERLACING capability, which you'll still have).<div style="height: 1.00em;">
&#160;</div>
All the reading and writing specific code are in separate files, so the linker should only grab the files it needs.  However, if you want to make sure, or if you are building a stand alone library, all the reading files start with pngr and all the writing files start with pngw.  The files that don't match either (like png.c, pngtrans.c, etc.) are used for both reading and writing, and always need to be included. The progressive reader is in pngpread.c<div style="height: 1.00em;">
&#160;</div>
If you are creating or distributing a dynamically linked library (a .so or DLL file), you should not remove or disable any parts of the library, as this will cause applications linked with different versions of the library to fail if they call functions not available in your library. The size of the library itself should not be an issue, because only those sections that are actually used will be loaded into memory.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>Requesting debug printout</h2> The macro definition PNG_DEBUG can be used to request debugging printout.  Set it to an integer value in the range 0 to 3.  Higher numbers result in increasing amounts of debugging information.  The information is printed to the &quot;stderr&quot; file, unless another file name is specified in the PNG_DEBUG_FILE macro definition.<div style="height: 1.00em;">
&#160;</div>
When PNG_DEBUG &gt; 0, the following functions (macros) become available:<div style="height: 1.00em;">
&#160;</div>
<br/>
   png_debug(level, message)<br/>
   png_debug1(level, message, p1)<br/>
   png_debug2(level, message, p1, p2)<div style="height: 1.00em;">
&#160;</div>
in which &quot;level&quot; is compared to PNG_DEBUG to decide whether to print the message, &quot;message&quot; is the formatted string to be printed, and p1 and p2 are parameters that are to be embedded in the string according to printf-style formatting directives.  For example,<div style="height: 1.00em;">
&#160;</div>
<br/>
   png_debug1(2, &quot;foo=%d0, foo);<div style="height: 1.00em;">
&#160;</div>
is expanded to<div style="height: 1.00em;">
&#160;</div>
<br/>
   if(PNG_DEBUG &gt; 2)<br/>
     fprintf(PNG_DEBUG_FILE, &quot;foo=%d0, foo);<div style="height: 1.00em;">
&#160;</div>
When PNG_DEBUG is defined but is zero, the macros aren't defined, but you can still use PNG_DEBUG to control your own debugging:<div style="height: 1.00em;">
&#160;</div>
<br/>
   #ifdef PNG_DEBUG<br/>
       fprintf(stderr, ...<br/>
   #endif<div style="height: 1.00em;">
&#160;</div>
When PNG_DEBUG = 1, the macros are defined, but only png_debug statements having level = 0 will be printed.  There aren't any such statements in this version of libpng, but if you insert some they will be printed.<div style="height: 1.00em;">
&#160;</div>
</div>
</div>
<div class="section">
<h1>VI. MNG support</h1> The MNG specification (available at http://www.libpng.org/pub/mng) allows certain extensions to PNG for PNG images that are embedded in MNG datastreams. Libpng can support some of these extensions.  To enable them, use the png_permit_mng_features() function:<div style="height: 1.00em;">
&#160;</div>
<br/>
   feature_set = png_permit_mng_features(png_ptr, mask)<br/>
   mask is a png_uint_32 containing the bitwise OR of the<br/>
        features you want to enable.  These include<br/>
        PNG_FLAG_MNG_EMPTY_PLTE<br/>
        PNG_FLAG_MNG_FILTER_64<br/>
        PNG_ALL_MNG_FEATURES<br/>
   feature_set is a png_uint_32 that is the bitwise AND of<br/>
      your mask with the set of MNG features that is<br/>
      supported by the version of libpng that you are using.<div style="height: 1.00em;">
&#160;</div>
It is an error to use this function when reading or writing a standalone PNG file with the PNG 8-byte signature.  The PNG datastream must be wrapped in a MNG datastream.  As a minimum, it must have the MNG 8-byte signature and the MHDR and MEND chunks.  Libpng does not provide support for these or any other MNG chunks; your application must provide its own support for them.  You may wish to consider using libmng (available at http://www.libmng.com) instead.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>VII. Changes to Libpng from version 0.88</h1> It should be noted that versions of libpng later than 0.96 are not distributed by the original libpng author, Guy Schalnat, nor by Andreas Dilger, who had taken over from Guy during 1996 and 1997, and distributed versions 0.89 through 0.96, but rather by another member of the original PNG Group, Glenn Randers-Pehrson.  Guy and Andreas are still alive and well, but they have moved on to other things.<div style="height: 1.00em;">
&#160;</div>
The old libpng functions png_read_init(), png_write_init(), png_info_init(), png_read_destroy(), and png_write_destroy() have been moved to PNG_INTERNAL in version 0.95 to discourage their use.  These functions will be removed from libpng version 2.0.0.<div style="height: 1.00em;">
&#160;</div>
The preferred method of creating and initializing the libpng structures is via the png_create_read_struct(), png_create_write_struct(), and png_create_info_struct() because they isolate the size of the structures from the application, allow version error checking, and also allow the use of custom error handling routines during the initialization, which the old functions do not.  The functions png_read_destroy() and png_write_destroy() do not actually free the memory that libpng allocated for these structs, but just reset the data structures, so they can be used instead of png_destroy_read_struct() and png_destroy_write_struct() if you feel there is too much system overhead allocating and freeing the png_struct for each image read.<div style="height: 1.00em;">
&#160;</div>
Setting the error callbacks via png_set_message_fn() before png_read_init() as was suggested in libpng-0.88 is no longer supported because this caused applications that do not use custom error functions to fail if the png_ptr was not initialized to zero.  It is still possible to set the error callbacks AFTER png_read_init(), or to change them with png_set_error_fn(), which is essentially the same function, but with a new name to force compilation errors with applications that try to use the old method.<div style="height: 1.00em;">
&#160;</div>
Starting with version 1.0.7, you can find out which version of the library you are using at run-time:<div style="height: 1.00em;">
&#160;</div>
<br/>
   png_uint_32 libpng_vn = png_access_version_number();<div style="height: 1.00em;">
&#160;</div>
The number libpng_vn is constructed from the major version, minor version with leading zero, and release number with leading zero, (e.g., libpng_vn for version 1.0.7 is 10007).<div style="height: 1.00em;">
&#160;</div>
You can also check which version of png.h you used when compiling your application:<div style="height: 1.00em;">
&#160;</div>
<br/>
   png_uint_32 application_vn = PNG_LIBPNG_VER;<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>VIII. Changes to Libpng from version 1.0.x to 1.2.x</h1> Support for user memory management was enabled by default.  To accomplish this, the functions png_create_read_struct_2(), png_create_write_struct_2(), png_set_mem_fn(), png_get_mem_ptr(), png_malloc_default(), and png_free_default() were added.<div style="height: 1.00em;">
&#160;</div>
Support for the iTXt chunk has been enabled by default as of version 1.2.41.<div style="height: 1.00em;">
&#160;</div>
Support for certain MNG features was enabled.<div style="height: 1.00em;">
&#160;</div>
Support for numbered error messages was added.  However, we never got around to actually numbering the error messages.  The function png_set_strip_error_numbers() was added (Note: the prototype for this function was inadvertently removed from png.h in PNG_NO_ASSEMBLER_CODE builds of libpng-1.2.15.  It was restored in libpng-1.2.36).<div style="height: 1.00em;">
&#160;</div>
The png_malloc_warn() function was added at libpng-1.2.3.  This issues a png_warning and returns NULL instead of aborting when it fails to acquire the requested memory allocation.<div style="height: 1.00em;">
&#160;</div>
Support for setting user limits on image width and height was enabled by default.  The functions png_set_user_limits(), png_get_user_width_max(), and png_get_user_height_max() were added at libpng-1.2.6.<div style="height: 1.00em;">
&#160;</div>
The png_set_add_alpha() function was added at libpng-1.2.7.<div style="height: 1.00em;">
&#160;</div>
The function png_set_expand_gray_1_2_4_to_8() was added at libpng-1.2.9. Unlike png_set_gray_1_2_4_to_8(), the new function does not expand the tRNS chunk to alpha. The png_set_gray_1_2_4_to_8() function is deprecated.<div style="height: 1.00em;">
&#160;</div>
A number of macro definitions in support of runtime selection of assembler code features (especially Intel MMX code support) were added at libpng-1.2.0:<div style="height: 1.00em;">
&#160;</div>
<br/>
    PNG_ASM_FLAG_MMX_SUPPORT_COMPILED<br/>
    PNG_ASM_FLAG_MMX_SUPPORT_IN_CPU<br/>
    PNG_ASM_FLAG_MMX_READ_COMBINE_ROW<br/>
    PNG_ASM_FLAG_MMX_READ_INTERLACE<br/>
    PNG_ASM_FLAG_MMX_READ_FILTER_SUB<br/>
    PNG_ASM_FLAG_MMX_READ_FILTER_UP<br/>
    PNG_ASM_FLAG_MMX_READ_FILTER_AVG<br/>
    PNG_ASM_FLAG_MMX_READ_FILTER_PAETH<br/>
    PNG_ASM_FLAGS_INITIALIZED<br/>
    PNG_MMX_READ_FLAGS<br/>
    PNG_MMX_FLAGS<br/>
    PNG_MMX_WRITE_FLAGS<br/>
    PNG_MMX_FLAGS<div style="height: 1.00em;">
&#160;</div>
We added the following functions in support of runtime selection of assembler code features:<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_get_mmx_flagmask()<br/>
    png_set_mmx_thresholds()<br/>
    png_get_asm_flags()<br/>
    png_get_mmx_bitdepth_threshold()<br/>
    png_get_mmx_rowbytes_threshold()<br/>
    png_set_asm_flags()<div style="height: 1.00em;">
&#160;</div>
We replaced all of these functions with simple stubs in libpng-1.2.20, when the Intel assembler code was removed due to a licensing issue.<div style="height: 1.00em;">
&#160;</div>
These macros are deprecated:<div style="height: 1.00em;">
&#160;</div>
<br/>
    PNG_READ_TRANSFORMS_NOT_SUPPORTED<br/>
    PNG_PROGRESSIVE_READ_NOT_SUPPORTED<br/>
    PNG_NO_SEQUENTIAL_READ_SUPPORTED<br/>
    PNG_WRITE_TRANSFORMS_NOT_SUPPORTED<br/>
    PNG_READ_ANCILLARY_CHUNKS_NOT_SUPPORTED<br/>
    PNG_WRITE_ANCILLARY_CHUNKS_NOT_SUPPORTED<div style="height: 1.00em;">
&#160;</div>
They have been replaced, respectively, by:<div style="height: 1.00em;">
&#160;</div>
<br/>
    PNG_NO_READ_TRANSFORMS<br/>
    PNG_NO_PROGRESSIVE_READ<br/>
    PNG_NO_SEQUENTIAL_READ<br/>
    PNG_NO_WRITE_TRANSFORMS<br/>
    PNG_NO_READ_ANCILLARY_CHUNKS<br/>
    PNG_NO_WRITE_ANCILLARY_CHUNKS<div style="height: 1.00em;">
&#160;</div>
PNG_MAX_UINT was replaced with PNG_UINT_31_MAX.  It has been deprecated since libpng-1.0.16 and libpng-1.2.6.<div style="height: 1.00em;">
&#160;</div>
The function<br/>
    png_check_sig(sig, num) was replaced with<br/>
    !png_sig_cmp(sig, 0, num) It has been deprecated since libpng-0.90.<div style="height: 1.00em;">
&#160;</div>
The function<br/>
    png_set_gray_1_2_4_to_8() which also expands tRNS to alpha was replaced with<br/>
    png_set_expand_gray_1_2_4_to_8() which does not. It has been deprecated since libpng-1.0.18 and 1.2.9.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>IX. (Omitted)</h1></div>
<div class="section">
<h1>X. Detecting libpng</h1> The png_get_io_ptr() function has been present since libpng-0.88, has never changed, and is unaffected by conditional compilation macros.  It is the best choice for use in configure scripts for detecting the presence of any libpng version since 0.88.  In an autoconf &quot;configure.in&quot; you could use<div style="height: 1.00em;">
&#160;</div>
<br/>
    AC_CHECK_LIB(png, png_get_io_ptr, ...<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>XI. Source code repository</h1> Since about February 2009, version 1.2.34, libpng has been under &quot;git&quot; source control.  The git repository was built from old libpng-x.y.z.tar.gz files going back to version 0.70.  You can access the git repository (read only) at<div style="height: 1.00em;">
&#160;</div>
<br/>
    git://libpng.git.sourceforge.net/gitroot/libpng<div style="height: 1.00em;">
&#160;</div>
or you can browse it via &quot;gitweb&quot; at<div style="height: 1.00em;">
&#160;</div>
<br/>
    http://libpng.git.sourceforge.net/git/gitweb.cgi?p=libpng<div style="height: 1.00em;">
&#160;</div>
Patches can be sent to glennrp at users.sourceforge.net or to png-mng-implement at lists.sourceforge.net or you can upload them to the libpng bug tracker at<div style="height: 1.00em;">
&#160;</div>
<br/>
    http://libpng.sourceforge.net<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>XII. Coding style</h1> Our coding style is similar to the &quot;Allman&quot; style, with curly braces on separate lines:<div style="height: 1.00em;">
&#160;</div>
<br/>
    if (condition)<br/>
    {<br/>
       action;<br/>
    }<div style="height: 1.00em;">
&#160;</div>
<br/>
    else if (another condition)<br/>
    {<br/>
       another action;<br/>
    }<div style="height: 1.00em;">
&#160;</div>
The braces can be omitted from simple one-line actions:<div style="height: 1.00em;">
&#160;</div>
<br/>
    if (condition)<br/>
       return (0);<div style="height: 1.00em;">
&#160;</div>
We use 3-space indentation, except for continued statements which are usually indented the same as the first line of the statement plus four more spaces.<div style="height: 1.00em;">
&#160;</div>
For macro definitions we use 2-space indentation, always leaving the &quot;#&quot; in the first column.<div style="height: 1.00em;">
&#160;</div>
<br/>
    #ifndef PNG_NO_FEATURE<br/>
    #  ifndef PNG_FEATURE_SUPPORTED<br/>
    #    define PNG_FEATURE_SUPPORTED<br/>
    #  endif<br/>
    #endif<div style="height: 1.00em;">
&#160;</div>
Comments appear with the leading &quot;/*&quot; at the same indentation as the statement that follows the comment:<div style="height: 1.00em;">
&#160;</div>
<br/>
    /* Single-line comment */<br/>
    statement;<div style="height: 1.00em;">
&#160;</div>
<br/>
    /* Multiple-line<br/>
     * comment<br/>
     */<br/>
    statement;<div style="height: 1.00em;">
&#160;</div>
Very short comments can be placed at the end of the statement to which they pertain:<div style="height: 1.00em;">
&#160;</div>
<br/>
    statement;    /* comment */<div style="height: 1.00em;">
&#160;</div>
We don't use C++ style (&quot;//&quot;) comments. We have, however, used them in the past in some now-abandoned MMX assembler code.<div style="height: 1.00em;">
&#160;</div>
Functions and their curly braces are not indented, and exported functions are marked with PNGAPI:<div style="height: 1.00em;">
&#160;</div>
<br/>
 /* This is a public function that is visible to<br/>
  * application programers. It does thus-and-so.<br/>
  */<br/>
 void PNGAPI<br/>
 png_exported_function(png_ptr, png_info, foo)<br/>
 {<br/>
    body;<br/>
 }<div style="height: 1.00em;">
&#160;</div>
The prototypes for all exported functions appear in png.h, above the comment that says<div style="height: 1.00em;">
&#160;</div>
<br/>
    /* Maintainer: Put new public prototypes here ... */<div style="height: 1.00em;">
&#160;</div>
We mark all non-exported functions with &quot;/* PRIVATE */&quot;&quot;:<div style="height: 1.00em;">
&#160;</div>
<br/>
 void /* PRIVATE */<br/>
 png_non_exported_function(png_ptr, png_info, foo)<br/>
 {<br/>
    body;<br/>
 }<div style="height: 1.00em;">
&#160;</div>
The prototypes for non-exported functions (except for those in pngtest) appear in the PNG_INTERNAL section of png.h above the comment that says<div style="height: 1.00em;">
&#160;</div>
<br/>
  /* Maintainer: Put new private prototypes here ^ and in libpngpf.3 */<div style="height: 1.00em;">
&#160;</div>
The names of all exported functions and variables begin with  &quot;png_&quot;, and all publicly visible C preprocessor macros begin with &quot;PNG_&quot;.<div style="height: 1.00em;">
&#160;</div>
We put a space after each comma and after each semicolon in &quot;for&quot; statments, and we put spaces before and after each C binary operator and after &quot;for&quot; or &quot;while&quot;.  We don't put a space between a typecast and the expression being cast, nor do we put one between a function name and the left parenthesis that follows it:<div style="height: 1.00em;">
&#160;</div>
<br/>
    for (i = 2; i &gt; 0; --i)<br/>
       y[i] = a(x) + (int)b;<div style="height: 1.00em;">
&#160;</div>
We prefer #ifdef and #ifndef to #if defined() and if !defined() when there is only one macro being tested.<div style="height: 1.00em;">
&#160;</div>
We do not use the TAB character for indentation in the C sources.<div style="height: 1.00em;">
&#160;</div>
Lines do not exceed 80 characters.<div style="height: 1.00em;">
&#160;</div>
Other rules can be inferred by inspecting the libpng source.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>XIII. Y2K Compliance in libpng</h1> July 9, 2011<div style="height: 1.00em;">
&#160;</div>
Since the PNG Development group is an ad-hoc body, we can't make an official declaration.<div style="height: 1.00em;">
&#160;</div>
This is your unofficial assurance that libpng from version 0.71 and upward through 1.2.46 are Y2K compliant.  It is my belief that earlier versions were also Y2K compliant.<div style="height: 1.00em;">
&#160;</div>
Libpng only has three year fields.  One is a 2-byte unsigned integer that will hold years up to 65535.  The other two hold the date in text format, and will hold years up to 9999.<div style="height: 1.00em;">
&#160;</div>
The integer is<br/>
    &quot;png_uint_16 year&quot; in png_time_struct.<div style="height: 1.00em;">
&#160;</div>
The strings are<br/>
    &quot;png_charp time_buffer&quot; in png_struct and<br/>
    &quot;near_time_buffer&quot;, which is a local character string in png.c.<div style="height: 1.00em;">
&#160;</div>
There are seven time-related functions:<div style="height: 1.00em;">
&#160;</div>
<br/>
    png_convert_to_rfc_1123() in png.c<br/>
      (formerly png_convert_to_rfc_1152() in error)<br/>
    png_convert_from_struct_tm() in pngwrite.c, called<br/>
      in pngwrite.c<br/>
    png_convert_from_time_t() in pngwrite.c<br/>
    png_get_tIME() in pngget.c<br/>
    png_handle_tIME() in pngrutil.c, called in pngread.c<br/>
    png_set_tIME() in pngset.c<br/>
    png_write_tIME() in pngwutil.c, called in pngwrite.c<div style="height: 1.00em;">
&#160;</div>
All appear to handle dates properly in a Y2K environment.  The png_convert_from_time_t() function calls gmtime() to convert from system clock time, which returns (year - 1900), which we properly convert to the full 4-digit year.  There is a possibility that applications using libpng are not passing 4-digit years into the png_convert_to_rfc_1123() function, or that they are incorrectly passing only a 2-digit year instead of &quot;year - 1900&quot; into the png_convert_from_struct_tm() function, but this is not under our control.  The libpng documentation has always stated that it works with 4-digit years, and the APIs have been documented as such.<div style="height: 1.00em;">
&#160;</div>
The tIME chunk itself is also Y2K compliant.  It uses a 2-byte unsigned integer to hold the year, and can hold years as large as 65535.<div style="height: 1.00em;">
&#160;</div>
zlib, upon which libpng depends, is also Y2K compliant.  It contains no date-related code.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<br/>
   Glenn Randers-Pehrson<br/>
   libpng maintainer<br/>
   PNG Development Group<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>NOTE</h1> Note about libpng version numbers:<div style="height: 1.00em;">
&#160;</div>
Due to various miscommunications, unforeseen code incompatibilities and occasional factors outside the authors' control, version numbering on the library has not always been consistent and straightforward. The following table summarizes matters since version 0.89c, which was the first widely used release:<div style="height: 1.00em;">
&#160;</div>
<br/>
 source             png.h  png.h  shared-lib<br/>
 version            string   int  version<br/>
 -------            ------  ----- ----------<br/>
 0.89c (&quot;beta 3&quot;)  0.89       89  1.0.89<br/>
 0.90  (&quot;beta 4&quot;)  0.90       90  0.90<br/>
 0.95  (&quot;beta 5&quot;)  0.95       95  0.95<br/>
 0.96  (&quot;beta 6&quot;)  0.96       96  0.96<br/>
 0.97b (&quot;beta 7&quot;)  1.00.97    97  1.0.1<br/>
 0.97c             0.97       97  2.0.97<br/>
 0.98              0.98       98  2.0.98<br/>
 0.99              0.99       98  2.0.99<br/>
 0.99a-m           0.99       99  2.0.99<br/>
 1.00              1.00      100  2.1.0<br/>
 1.0.0             1.0.0     100  2.1.0<br/>
 1.0.0   (from here on, the  100  2.1.0<br/>
 1.0.1    png.h string is  10001  2.1.0<br/>
 1.0.1a-e identical to the 10002  from here on, the<br/>
 1.0.2    source version)  10002  shared library is 2.V<br/>
 1.0.2a-b                  10003  where V is the source<br/>
 1.0.1                     10001  code version except as<br/>
 1.0.1a-e                  10002  2.1.0.1a-e   noted.<br/>
 1.0.2                     10002  2.1.0.2<br/>
 1.0.2a-b                  10003  2.1.0.2a-b<br/>
 1.0.3                     10003  2.1.0.3<br/>
 1.0.3a-d                  10004  2.1.0.3a-d<br/>
 1.0.4                     10004  2.1.0.4<br/>
 1.0.4a-f                  10005  2.1.0.4a-f<br/>
 1.0.5 (+ 2 patches)       10005  2.1.0.5<br/>
 1.0.5a-d                  10006  2.1.0.5a-d<br/>
 1.0.5e-r                  10100  2.1.0.5e-r<br/>
 1.0.5s-v                  10006  2.1.0.5s-v<br/>
 1.0.6 (+ 3 patches)       10006  2.1.0.6<br/>
 1.0.6d-g                  10007  2.1.0.6d-g<br/>
 1.0.6h                    10007  10.6h<br/>
 1.0.6i                    10007  10.6i<br/>
 1.0.6j                    10007  2.1.0.6j<br/>
 1.0.7beta11-14    DLLNUM  10007  2.1.0.7beta11-14<br/>
 1.0.7beta15-18       1    10007  2.1.0.7beta15-18<br/>
 1.0.7rc1-2           1    10007  2.1.0.7rc1-2<br/>
 1.0.7                1    10007  2.1.0.7<br/>
 1.0.8beta1-4         1    10008  2.1.0.8beta1-4<br/>
 1.0.8rc1             1    10008  2.1.0.8rc1<br/>
 1.0.8                1    10008  2.1.0.8<br/>
 1.0.9beta1-6         1    10009  2.1.0.9beta1-6<br/>
 1.0.9rc1             1    10009  2.1.0.9rc1<br/>
 1.0.9beta7-10        1    10009  2.1.0.9beta7-10<br/>
 1.0.9rc2             1    10009  2.1.0.9rc2<br/>
 1.0.9                1    10009  2.1.0.9<br/>
 1.0.10beta1          1    10010  2.1.0.10beta1<br/>
 1.0.10rc1            1    10010  2.1.0.10rc1<br/>
 1.0.10               1    10010  2.1.0.10<br/>
 1.0.11beta1-3        1    10011  2.1.0.11beta1-3<br/>
 1.0.11rc1            1    10011  2.1.0.11rc1<br/>
 1.0.11               1    10011  2.1.0.11<br/>
 1.0.12beta1-2        2    10012  2.1.0.12beta1-2<br/>
 1.0.12rc1            2    10012  2.1.0.12rc1<br/>
 1.0.12               2    10012  2.1.0.12<br/>
 1.1.0a-f             -    10100  2.1.1.0a-f abandoned<br/>
 1.2.0beta1-2         2    10200  2.1.2.0beta1-2<br/>
 1.2.0beta3-5         3    10200  3.1.2.0beta3-5<br/>
 1.2.0rc1             3    10200  3.1.2.0rc1<br/>
 1.2.0                3    10200  3.1.2.0<br/>
 1.2.1beta-4          3    10201  3.1.2.1beta1-4<br/>
 1.2.1rc1-2           3    10201  3.1.2.1rc1-2<br/>
 1.2.1                3    10201  3.1.2.1<br/>
 1.2.2beta1-6        12    10202  12.so.0.1.2.2beta1-6<br/>
 1.0.13beta1         10    10013  10.so.0.1.0.13beta1<br/>
 1.0.13rc1           10    10013  10.so.0.1.0.13rc1<br/>
 1.2.2rc1            12    10202  12.so.0.1.2.2rc1<br/>
 1.0.13              10    10013  10.so.0.1.0.13<br/>
 1.2.2               12    10202  12.so.0.1.2.2<br/>
 1.2.3rc1-6          12    10203  12.so.0.1.2.3rc1-6<br/>
 1.2.3               12    10203  12.so.0.1.2.3<br/>
 1.2.4beta1-3        13    10204  12.so.0.1.2.4beta1-3<br/>
 1.2.4rc1            13    10204  12.so.0.1.2.4rc1<br/>
 1.0.14              10    10014  10.so.0.1.0.14<br/>
 1.2.4               13    10204  12.so.0.1.2.4<br/>
 1.2.5beta1-2        13    10205  12.so.0.1.2.5beta1-2<br/>
 1.0.15rc1           10    10015  10.so.0.1.0.15rc1<br/>
 1.0.15              10    10015  10.so.0.1.0.15<br/>
 1.2.5               13    10205  12.so.0.1.2.5<br/>
 1.2.6beta1-4        13    10206  12.so.0.1.2.6beta1-4<br/>
 1.2.6rc1-5          13    10206  12.so.0.1.2.6rc1-5<br/>
 1.0.16              10    10016  10.so.0.1.0.16<br/>
 1.2.6               13    10206  12.so.0.1.2.6<br/>
 1.2.7beta1-2        13    10207  12.so.0.1.2.7beta1-2<br/>
 1.0.17rc1           10    10017  10.so.0.1.0.17rc1<br/>
 1.2.7rc1            13    10207  12.so.0.1.2.7rc1<br/>
 1.0.17              10    10017  10.so.0.1.0.17<br/>
 1.2.7               13    10207  12.so.0.1.2.7<br/>
 1.2.8beta1-5        13    10208  12.so.0.1.2.8beta1-5<br/>
 1.0.18rc1-5         10    10018  10.so.0.1.0.18rc1-5<br/>
 1.2.8rc1-5          13    10208  12.so.0.1.2.8rc1-5<br/>
 1.0.18              10    10018  10.so.0.1.0.18<br/>
 1.2.8               13    10208  12.so.0.1.2.8<br/>
 1.2.9beta1-3        13    10209  12.so.0.1.2.9beta1-3<br/>
 1.2.9beta4-11       13    10209  12.so.0.9[.0]<br/>
 1.2.9rc1            13    10209  12.so.0.9[.0]<br/>
 1.2.9               13    10209  12.so.0.9[.0]<br/>
 1.2.10beta1-8       13    10210  12.so.0.10[.0]<br/>
 1.2.10rc1-3         13    10210  12.so.0.10[.0]<br/>
 1.2.10              13    10210  12.so.0.10[.0]<br/>
 1.2.11beta1-4       13    10211  12.so.0.11[.0]<br/>
 1.0.19rc1-5         10    10019  10.so.0.19[.0]<br/>
 1.2.11rc1-5         13    10211  12.so.0.11[.0]<br/>
 1.0.19              10    10019  10.so.0.19[.0]<br/>
 1.2.11              13    10211  12.so.0.11[.0]<br/>
 1.0.20              10    10020  10.so.0.20[.0]<br/>
 1.2.12              13    10212  12.so.0.12[.0]<br/>
 1.2.13beta1         13    10213  12.so.0.13[.0]<br/>
 1.0.21              10    10021  10.so.0.21[.0]<br/>
 1.2.13              13    10213  12.so.0.13[.0]<br/>
 1.2.14beta1-2       13    10214  12.so.0.14[.0]<br/>
 1.0.22rc1           10    10022  10.so.0.22[.0]<br/>
 1.2.14rc1           13    10214  12.so.0.14[.0]<br/>
 1.2.15beta1-6       13    10215  12.so.0.15[.0]<br/>
 1.0.23rc1-5         10    10023  10.so.0.23[.0]<br/>
 1.2.15rc1-5         13    10215  12.so.0.15[.0]<br/>
 1.0.23              10    10023  10.so.0.23[.0]<br/>
 1.2.15              13    10215  12.so.0.15[.0]<br/>
 1.2.16beta1-2       13    10216  12.so.0.16[.0]<br/>
 1.2.16rc1           13    10216  12.so.0.16[.0]<br/>
 1.0.24              10    10024  10.so.0.24[.0]<br/>
 1.2.16              13    10216  12.so.0.16[.0]<br/>
 1.2.17beta1-2       13    10217  12.so.0.17[.0]<br/>
 1.0.25rc1           10    10025  10.so.0.25[.0]<br/>
 1.2.17rc1-3         13    10217  12.so.0.17[.0]<br/>
 1.0.25              10    10025  10.so.0.25[.0]<br/>
 1.2.17              13    10217  12.so.0.17[.0]<br/>
 1.0.26              10    10026  10.so.0.26[.0]<br/>
 1.2.18              13    10218  12.so.0.18[.0]<br/>
 1.2.19beta1-31      13    10219  12.so.0.19[.0]<br/>
 1.0.27rc1-6         10    10027  10.so.0.27[.0]<br/>
 1.2.19rc1-6         13    10219  12.so.0.19[.0]<br/>
 1.0.27              10    10027  10.so.0.27[.0]<br/>
 1.2.19              13    10219  12.so.0.19[.0]<br/>
 1.2.20beta01-04     13    10220  12.so.0.20[.0]<br/>
 1.0.28rc1-6         10    10028  10.so.0.28[.0]<br/>
 1.2.20rc1-6         13    10220  12.so.0.20[.0]<br/>
 1.0.28              10    10028  10.so.0.28[.0]<br/>
 1.2.20              13    10220  12.so.0.20[.0]<br/>
 1.2.21beta1-2       13    10221  12.so.0.21[.0]<br/>
 1.2.21rc1-3         13    10221  12.so.0.21[.0]<br/>
 1.0.29              10    10029  10.so.0.29[.0]<br/>
 1.2.21              13    10221  12.so.0.21[.0]<br/>
 1.2.22beta1-4       13    10222  12.so.0.22[.0]<br/>
 1.0.30rc1           13    10030  10.so.0.30[.0]<br/>
 1.2.22rc1           13    10222  12.so.0.22[.0]<br/>
 1.0.30              10    10030  10.so.0.30[.0]<br/>
 1.2.22              13    10222  12.so.0.22[.0]<br/>
 1.2.23beta01-05     13    10223  12.so.0.23[.0]<br/>
 1.2.23rc01          13    10223  12.so.0.23[.0]<br/>
 1.2.23              13    10223  12.so.0.23[.0]<br/>
 1.2.24beta01-02     13    10224  12.so.0.24[.0]<br/>
 1.2.24rc01          13    10224  12.so.0.24[.0]<br/>
 1.2.24              13    10224  12.so.0.24[.0]<br/>
 1.2.25beta01-06     13    10225  12.so.0.25[.0]<br/>
 1.2.25rc01-02       13    10225  12.so.0.25[.0]<br/>
 1.0.31              10    10031  10.so.0.31[.0]<br/>
 1.2.25              13    10225  12.so.0.25[.0]<br/>
 1.2.26beta01-06     13    10226  12.so.0.26[.0]<br/>
 1.2.26rc01          13    10226  12.so.0.26[.0]<br/>
 1.2.26              13    10226  12.so.0.26[.0]<br/>
 1.0.32              10    10032  10.so.0.32[.0]<br/>
 1.2.27beta01-06     13    10227  12.so.0.27[.0]<br/>
 1.2.27rc01          13    10227  12.so.0.27[.0]<br/>
 1.0.33              10    10033  10.so.0.33[.0]<br/>
 1.2.27              13    10227  12.so.0.27[.0]<br/>
 1.0.34              10    10034  10.so.0.34[.0]<br/>
 1.2.28              13    10228  12.so.0.28[.0]<br/>
 1.2.29beta01-03     13    10229  12.so.0.29[.0]<br/>
 1.2.29rc01          13    10229  12.so.0.29[.0]<br/>
 1.0.35              10    10035  10.so.0.35[.0]<br/>
 1.2.29              13    10229  12.so.0.29[.0]<br/>
 1.0.37              10    10037  10.so.0.37[.0]<br/>
 1.2.30beta01-04     13    10230  12.so.0.30[.0]<br/>
 1.0.38rc01-08       10    10038  10.so.0.38[.0]<br/>
 1.2.30rc01-08       13    10230  12.so.0.30[.0]<br/>
 1.0.38              10    10038  10.so.0.38[.0]<br/>
 1.2.30              13    10230  12.so.0.30[.0]<br/>
 1.0.39rc01-03       10    10039  10.so.0.39[.0]<br/>
 1.2.31rc01-03       13    10231  12.so.0.31[.0]<br/>
 1.0.39              10    10039  10.so.0.39[.0]<br/>
 1.2.31              13    10231  12.so.0.31[.0]<br/>
 1.2.32beta01-02     13    10232  12.so.0.32[.0]<br/>
 1.0.40rc01          10    10040  10.so.0.40[.0]<br/>
 1.2.32rc01          13    10232  12.so.0.32[.0]<br/>
 1.0.40              10    10040  10.so.0.40[.0]<br/>
 1.2.32              13    10232  12.so.0.32[.0]<br/>
 1.2.33beta01-02     13    10233  12.so.0.33[.0]<br/>
 1.2.33rc01-02       13    10233  12.so.0.33[.0]<br/>
 1.0.41rc01          10    10041  10.so.0.41[.0]<br/>
 1.2.33              13    10233  12.so.0.33[.0]<br/>
 1.0.41              10    10041  10.so.0.41[.0]<br/>
 1.2.34beta01-07     13    10234  12.so.0.34[.0]<br/>
 1.0.42rc01          10    10042  10.so.0.42[.0]<br/>
 1.2.34rc01          13    10234  12.so.0.34[.0]<br/>
 1.0.42              10    10042  10.so.0.42[.0]<br/>
 1.2.34              13    10234  12.so.0.34[.0]<br/>
 1.2.35beta01-03     13    10235  12.so.0.35[.0]<br/>
 1.0.43rc01-02       10    10043  10.so.0.43[.0]<br/>
 1.2.35rc01-02       13    10235  12.so.0.35[.0]<br/>
 1.0.43              10    10043  10.so.0.43[.0]<br/>
 1.2.35              13    10235  12.so.0.35[.0]<br/>
 1.2.36beta01-05     13    10236  12.so.0.36[.0]<br/>
 1.2.36rc01          13    10236  12.so.0.36[.0]<br/>
 1.0.44              10    10044  10.so.0.44[.0]<br/>
 1.2.36              13    10236  12.so.0.36[.0]<br/>
 1.2.37beta01-03     13    10237  12.so.0.37[.0]<br/>
 1.2.37rc01          13    10237  12.so.0.37[.0]<br/>
 1.2.37              13    10237  12.so.0.37[.0]<br/>
 1.0.45              10    10045  12.so.0.45[.0]<br/>
 1.0.46              10    10046  10.so.0.46[.0]<br/>
 1.2.38beta01        13    10238  12.so.0.38[.0]<br/>
 1.2.38rc01-03       13    10238  12.so.0.38[.0]<br/>
 1.0.47              10    10047  10.so.0.47[.0]<br/>
 1.2.38              13    10238  12.so.0.38[.0]<br/>
 1.2.39beta01-05     13    10239  12.so.0.39[.0]<br/>
 1.2.39rc01          13    10239  12.so.0.39[.0]<br/>
 1.0.48              10    10048  10.so.0.48[.0]<br/>
 1.2.39              13    10239  12.so.0.39[.0]<br/>
 1.2.40beta01        13    10240  12.so.0.40[.0]<br/>
 1.2.40rc01          13    10240  12.so.0.40[.0]<br/>
 1.0.49              10    10049  10.so.0.49[.0]<br/>
 1.2.40              13    10240  12.so.0.40[.0]<br/>
 1.0.50              10    10050  10.so.0.50[.0]<br/>
 1.2.41beta01-18     13    10241  12.so.0.41[.0]<br/>
 1.0.51rc01          10    10051  10.so.0.51[.0]<br/>
 1.2.41rc01-03       13    10241  12.so.0.41[.0]<br/>
 1.0.51              10    10051  10.so.0.51[.0]<br/>
 1.2.41              13    10241  12.so.0.41[.0]<br/>
 1.2.42beta01-02     13    10242  12.so.0.42[.0]<br/>
 1.2.42rc01-05       13    10242  12.so.0.42[.0]<br/>
 1.0.52              10    10052  10.so.0.52[.0]<br/>
 1.2.42              13    10242  12.so.0.42[.0]<br/>
 1.2.43beta01-05     13    10243  12.so.0.43[.0]<br/>
 1.0.53rc01-02       10    10053  10.so.0.53[.0]<br/>
 1.2.43rc01-02       13    10243  12.so.0.43[.0]<br/>
 1.0.53              10    10053  10.so.0.53[.0]<br/>
 1.2.43              13    10243  12.so.0.43[.0]<br/>
 1.2.44beta01-03     13    10244  12.so.0.44[.0]<br/>
 1.2.44rc01-03       13    10244  12.so.0.44[.0]<br/>
 1.2.44              13    10244  12.so.0.44[.0]<br/>
 1.2.45beta01-03     13    10245  12.so.0.45[.0]<br/>
 1.0.55rc01          10    10055  10.so.0.55[.0]<br/>
 1.2.45rc01          13    10245  12.so.0.45[.0]<br/>
 1.0.55              10    10055  10.so.0.55[.0]<br/>
 1.2.45              13    10245  12.so.0.45[.0]<br/>
 1.2.46rc01-02       13    10246  12.so.0.46[.0]<br/>
 1.0.56              10    10056  10.so.0.56[.0]<br/>
 1.2.46              13    10246  12.so.0.46[.0]<div style="height: 1.00em;">
&#160;</div>
Henceforth the source version will match the shared-library minor and patch numbers; the shared-library major version number will be used for changes in backward compatibility, as it is intended.  The PNG_PNGLIB_VER macro, which is not used within libpng but is available for applications, is an unsigned integer of the form xyyzz corresponding to the source version x.y.z (leading zeros in y and z).  Beta versions were given the previous public release number plus a letter, until version 1.0.6j; from then on they were given the upcoming public release number plus &quot;betaNN&quot; or &quot;rcN&quot;.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>SEE ALSO</h1> <i>libpngpf(3)</i>, <i>png(5)</i><div class="spacer">
</div>
<i>libpng</i>:<dl>
<dt>
</dt>
<dd>
http://libpng.sourceforge.net (follow the [DOWNLOAD] link) http://www.libpng.org/pub/png<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<div class="spacer">
</div>
<i>zlib</i>:<dl>
<dt>
</dt>
<dd>
(generally) at the same location as <i>libpng</i> or at<div style="height: 0.00em;">
&#160;</div>
ftp://ftp.info-zip.org/pub/infozip/zlib<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<div class="spacer">
</div>
<i>PNG</i>specification:<i>RFC</i>2083<dl>
<dt>
</dt>
<dd>
(generally) at the same location as <i>libpng</i> or at<div style="height: 0.00em;">
&#160;</div>
ftp://ftp.rfc-editor.org:/in-notes/rfc2083.txt<div style="height: 0.00em;">
&#160;</div>
or (as a W3C Recommendation) at<div style="height: 0.00em;">
&#160;</div>
http://www.w3.org/TR/REC-png.html<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<div class="spacer">
</div>
In the case of any inconsistency between the PNG specification and this library, the specification takes precedence.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>AUTHORS</h1> This man page: Glenn Randers-Pehrson &lt;glennrp at users.sourceforge.net&gt;<div style="height: 1.00em;">
&#160;</div>
The contributing authors would like to thank all those who helped with testing, bug fixes, and patience.  This wouldn't have been possible without all of you.<div style="height: 1.00em;">
&#160;</div>
Thanks to Frank J. T. Wojcik for helping with the documentation.<div style="height: 1.00em;">
&#160;</div>
Libpng version 1.2.46 - July 9, 2011: Initially created in 1995 by Guy Eric Schalnat, then of Group 42, Inc. Currently maintained by Glenn Randers-Pehrson (glennrp at users.sourceforge.net).<div style="height: 1.00em;">
&#160;</div>
Supported by the PNG development group<div style="height: 0.00em;">
&#160;</div>
png-mng-implement at lists.sf.net (subscription required; visit png-mng-implement at lists.sourceforge.net (subscription required; visit https://lists.sourceforge.net/lists/listinfo/png-mng-implement to subscribe).<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>COPYRIGHT NOTICE, DISCLAIMER, and LICENSE:</h1> (This copy of the libpng notices is provided for your convenience.  In case of any discrepancy between this copy and the notices in the file png.h that is included in the libpng distribution, the latter shall prevail.)<div style="height: 1.00em;">
&#160;</div>
If you modify libpng you may insert additional notices immediately following this sentence.<div style="height: 1.00em;">
&#160;</div>
This code is released under the libpng license.<div style="height: 1.00em;">
&#160;</div>
libpng versions 1.2.6, August 15, 2004, through 1.2.46, July 9, 2011, are Copyright (c) 2004,2006-2008 Glenn Randers-Pehrson, and are distributed according to the same disclaimer and license as libpng-1.2.5 with the following individual added to the list of Contributing Authors<div style="height: 1.00em;">
&#160;</div>
<br/>
   Cosmin Truta<div style="height: 1.00em;">
&#160;</div>
libpng versions 1.0.7, July 1, 2000, through 1.2.5 - October 3, 2002, are Copyright (c) 2000-2002 Glenn Randers-Pehrson, and are distributed according to the same disclaimer and license as libpng-1.0.6 with the following individuals added to the list of Contributing Authors<div style="height: 1.00em;">
&#160;</div>
<br/>
   Simon-Pierre Cadieux<br/>
   Eric S. Raymond<br/>
   Gilles Vollant<div style="height: 1.00em;">
&#160;</div>
and with the following additions to the disclaimer:<div style="height: 1.00em;">
&#160;</div>
<br/>
   There is no warranty against interference with your<br/>
   enjoyment of the library or against infringement.<br/>
   There is no warranty that our efforts or the library<br/>
   will fulfill any of your particular purposes or needs.<br/>
   This library is provided with all faults, and the entire<br/>
   risk of satisfactory quality, performance, accuracy, and<br/>
   effort is with the user.<div style="height: 1.00em;">
&#160;</div>
libpng versions 0.97, January 1998, through 1.0.6, March 20, 2000, are Copyright (c) 1998, 1999 Glenn Randers-Pehrson Distributed according to the same disclaimer and license as libpng-0.96, with the following individuals added to the list of Contributing Authors:<div style="height: 1.00em;">
&#160;</div>
<br/>
   Tom Lane<br/>
   Glenn Randers-Pehrson<br/>
   Willem van Schaik<div style="height: 1.00em;">
&#160;</div>
libpng versions 0.89, June 1996, through 0.96, May 1997, are Copyright (c) 1996, 1997 Andreas Dilger Distributed according to the same disclaimer and license as libpng-0.88, with the following individuals added to the list of Contributing Authors:<div style="height: 1.00em;">
&#160;</div>
<br/>
   John Bowler<br/>
   Kevin Bracey<br/>
   Sam Bushell<br/>
   Magnus Holmgren<br/>
   Greg Roelofs<br/>
   Tom Tanner<div style="height: 1.00em;">
&#160;</div>
libpng versions 0.5, May 1995, through 0.88, January 1996, are Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.<div style="height: 1.00em;">
&#160;</div>
For the purposes of this copyright and license, &quot;Contributing Authors&quot; is defined as the following set of individuals:<div style="height: 1.00em;">
&#160;</div>
<br/>
   Andreas Dilger<br/>
   Dave Martindale<br/>
   Guy Eric Schalnat<br/>
   Paul Schmidt<br/>
   Tim Wegner<div style="height: 1.00em;">
&#160;</div>
The PNG Reference Library is supplied &quot;AS IS&quot;.  The Contributing Authors and Group 42, Inc. disclaim all warranties, expressed or implied, including, without limitation, the warranties of merchantability and of fitness for any purpose.  The Contributing Authors and Group 42, Inc. assume no liability for direct, indirect, incidental, special, exemplary, or consequential damages, which may result from the use of the PNG Reference Library, even if advised of the possibility of such damage.<div style="height: 1.00em;">
&#160;</div>
Permission is hereby granted to use, copy, modify, and distribute this source code, or portions hereof, for any purpose, without fee, subject to the following restrictions:<div style="height: 1.00em;">
&#160;</div>
1. The origin of this source code must not be misrepresented.<div style="height: 1.00em;">
&#160;</div>
2. Altered versions must be plainly marked as such and<br/>
   must not be misrepresented as being the original source.<div style="height: 1.00em;">
&#160;</div>
3. This Copyright notice may not be removed or altered from<br/>
   any source or altered source distribution.<div style="height: 1.00em;">
&#160;</div>
The Contributing Authors and Group 42, Inc. specifically permit, without fee, and encourage the use of this source code as a component to supporting the PNG file format in commercial products.  If you use this source code in a product, acknowledgment is not required but would be appreciated.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
A &quot;png_get_copyright&quot; function is available, for convenient use in &quot;about&quot; boxes and the like:<div style="height: 1.00em;">
&#160;</div>
<br/>
   printf(&quot;%s&quot;,png_get_copyright(NULL));<div style="height: 1.00em;">
&#160;</div>
Also, the PNG logo (in PNG format, of course) is supplied in the files &quot;pngbar.png&quot; and &quot;pngbar.jpg (88x31) and &quot;pngnow.png&quot; (98x31).<div style="height: 1.00em;">
&#160;</div>
Libpng is OSI Certified Open Source Software.  OSI Certified Open Source is a certification mark of the Open Source Initiative.<div style="height: 1.00em;">
&#160;</div>
Glenn Randers-Pehrson glennrp at users.sourceforge.net July 9, 2011<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<table class="foot">
<tr>
<td class="foot-date">
July 9, 2011</td>
<td class="foot-os">
</td>
</tr>
</table>
</div>
</body>
</html>

