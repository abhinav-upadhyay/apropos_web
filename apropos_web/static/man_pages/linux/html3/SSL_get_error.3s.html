<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
SSL_get_error(3SSL)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
SSL_get_error(3SSL)</td>
<td class="head-vol">
OpenSSL</td>
<td class="head-rtitle">
SSL_get_error(3SSL)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> SSL_get_error - obtain result code for TLS/SSL I/O operation</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
 #include &lt;openssl/ssl.h&gt;<br/>
<br/>
 int SSL_get_error(const SSL *ssl, int ret);<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1>  <i>SSL_get_error()</i> returns a result code (suitable for the C &quot;switch&quot; statement) for a preceding call to  <i>SSL_connect()</i>, <i>SSL_accept()</i>, <i>SSL_do_handshake()</i>,  <i>SSL_read()</i>, <i>SSL_peek()</i>, or <i>SSL_write()</i> on <b>ssl</b>.  The value returned by that TLS/SSL I/O function must be passed to  <i>SSL_get_error()</i> in parameter  <b>ret</b>.<div class="spacer">
</div>
In addition to <b>ssl</b> and <b>ret</b>, <i>SSL_get_error()</i> inspects the current thread's OpenSSL error queue.  Thus,  <i>SSL_get_error()</i> must be used in the same thread that performed the TLS/SSL I/O operation, and no other OpenSSL function calls should appear in between.  The current thread's error queue must be empty before the TLS/SSL I/O operation is attempted, or  <i>SSL_get_error()</i> will not work reliably.</div>
<div class="section">
<h1>RETURN VALUES</h1> The following return values can currently occur:<dl>
<dt>
SSL_ERROR_NONE</dt>
<dd>
The TLS/SSL I/O operation completed.  This result code is returned if and only if  <b>ret &gt; 0</b>.</dd>
</dl>
<dl>
<dt>
SSL_ERROR_ZERO_RETURN</dt>
<dd>
The TLS/SSL connection has been closed.  If the protocol version is SSL 3.0 or TLS 1.0, this result code is returned only if a closure alert has occurred in the protocol, i.e. if the connection has been closed cleanly. Note that in this case  <b>SSL_ERROR_ZERO_RETURN</b> does not necessarily indicate that the underlying transport has been closed.</dd>
</dl>
<dl>
<dt>
SSL_ERROR_WANT_READ, SSL_ERROR_WANT_WRITE</dt>
<dd>
The operation did not complete; the same TLS/SSL I/O function should be called again later.  If, by then, the underlying  <b>BIO</b> has data available for reading (if the result code is  <b>SSL_ERROR_WANT_READ</b>) or allows writing data ( <b>SSL_ERROR_WANT_WRITE</b>), then some TLS/SSL protocol progress will take place, i.e. at least part of an TLS/SSL record will be read or written.  Note that the retry may again lead to a  <b>SSL_ERROR_WANT_READ</b> or <b>SSL_ERROR_WANT_WRITE</b> condition. There is no fixed upper limit for the number of iterations that may be necessary until progress becomes visible at application protocol level.<div style="height: 1.00em;">
&#160;</div>
For socket <b>BIO</b>s (e.g. when <i>SSL_set_fd()</i> was used), <i>select()</i> or  <i>poll()</i> on the underlying socket can be used to find out when the TLS/SSL I/O function should be retried.<div style="height: 1.00em;">
&#160;</div>
Caveat: Any TLS/SSL I/O function can lead to either of  <b>SSL_ERROR_WANT_READ</b> and <b>SSL_ERROR_WANT_WRITE</b>.  In particular,  <i>SSL_read()</i> or <i>SSL_peek()</i> may want to write data and <i>SSL_write()</i> may want to read data.  This is mainly because TLS/SSL handshakes may occur at any time during the protocol (initiated by either the client or the server);  <i>SSL_read()</i>, <i>SSL_peek()</i>, and <i>SSL_write()</i> will handle any pending handshakes.</dd>
</dl>
<dl>
<dt>
SSL_ERROR_WANT_CONNECT, SSL_ERROR_WANT_ACCEPT</dt>
<dd>
The operation did not complete; the same TLS/SSL I/O function should be called again later. The underlying BIO was not connected yet to the peer and the call would block in  <i>connect()</i>/<i>accept()</i>. The SSL function should be called again when the connection is established. These messages can only appear with a  <i>BIO_s_connect()</i> or <i>BIO_s_accept()</i> BIO, respectively. In order to find out, when the connection has been successfully established, on many platforms  <i>select()</i> or <i>poll()</i> for writing on the socket file descriptor can be used.</dd>
</dl>
<dl>
<dt>
SSL_ERROR_WANT_X509_LOOKUP</dt>
<dd>
The operation did not complete because an application callback set by  <i>SSL_CTX_set_client_cert_cb()</i> has asked to be called again. The TLS/SSL I/O function should be called again later. Details depend on the application.</dd>
</dl>
<dl>
<dt>
SSL_ERROR_SYSCALL</dt>
<dd>
Some I/O error occurred.  The OpenSSL error queue may contain more information on the error.  If the error queue is empty (i.e.  <i>ERR_get_error()</i> returns 0), <b>ret</b> can be used to find out more about the error: If  <b>ret == 0</b>, an EOF was observed that violates the protocol.  If  <b>ret == -1</b>, the underlying <b>BIO</b> reported an I/O error (for socket I/O on Unix systems, consult  <b>errno</b> for details).</dd>
</dl>
<dl>
<dt>
SSL_ERROR_SSL</dt>
<dd>
A failure in the SSL library occurred, usually a protocol error.  The OpenSSL error queue contains more information on the error.</dd>
</dl>
</div>
<div class="section">
<h1>SEE ALSO</h1>  <i>ssl</i>(3), <i>err</i>(3)</div>
<div class="section">
<h1>HISTORY</h1>  <i>SSL_get_error()</i> was added in SSLeay 0.8.</div>
<table class="foot">
<tr>
<td class="foot-date">
2005-03-30</td>
<td class="foot-os">
1.0.1</td>
</tr>
</table>
</div>
</body>
</html>

