<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Config::Model::Warper(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Config::Model::Warper(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
Config::Model::Warper(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Config::Model::Warper - Warp tree properties</div>
<div class="section">
<h1>VERSION</h1> version 2.005</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
 # internal class<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> Depending on the value of a warp master (In fact a Config::Model::Value object), this class will change the properties of a node (Config::Model::WarpedNode), a hash (Config::Model::HashId), a list (Config::Model::ListId), a checklist (Config::Model::CheckList) or another value.</div>
<div class="section">
<h1>Warper and warped</h1> Warping an object means that the properties of the object will be changed depending on the value of another object.<div class="spacer">
</div>
The changed object is referred as the <i>warped</i> object.<div class="spacer">
</div>
The other object that holds the important value is referred as the  <i>warp master</i> or the <i>warper</i> object.<div class="spacer">
</div>
You can also set up several warp master for one warped object. This means that the properties of the warped object will be changed according to a combination of values of the warp masters.</div>
<div class="section">
<h1>Warp arguments</h1> Warp arguments are passed in a hash ref whose keys are &quot;follow&quot; and and &quot;rules&quot;:<div class="subsection">
<h2>Warp follow argument</h2> Grab string leading to the &quot;Config::Model::Value&quot; warp master. E.g.:<div class="spacer">
</div>
<br/>
 follow =&gt; '! tree_macro'<br/>
<div class="spacer">
</div>
In case of several warp master, &quot;follow&quot; will be set to an array ref of several grab string:<div class="spacer">
</div>
<br/>
 follow =&gt; [ '! macro1', '- macro2' ]<br/>
<div class="spacer">
</div>
You can also use named parameters:<div class="spacer">
</div>
<br/>
 follow =&gt; { m1 =&gt; '! macro1', m2 =&gt; '- macro2' }<br/>
</div>
<div class="subsection">
<h2>Warp rules argument</h2> String, hash ref or array ref that specify the warped object property changes.  These rules specifies the actual property changes for the warped object depending on the value(s) of the warp master(s).<div class="spacer">
</div>
E.g. for a simple case (rules is a hash ref) :<div class="spacer">
</div>
<br/>
 follow =&gt; '! macro1' ,<br/>
 rules =&gt; { A =&gt; { &lt;effect for macro1 == A&gt; },<br/>
            B =&gt; { &lt;effect for macro1 == B&gt; }<br/>
          }<br/>
<div class="spacer">
</div>
In case of similar effects, you can use named parameters and a boolean expression to specify the effect. The first match will be applied. In this case, rules is a list ref:<div class="spacer">
</div>
<br/>
  follow =&gt; { m =&gt; '! macro1' } ,<br/>
  rules =&gt; [ '$m eq &quot;A&quot;'               =&gt; { &lt;effect for macro1 == A&gt; },<br/>
             '$m eq &quot;B&quot; or $m eq&quot;C &quot;'  =&gt; { &lt;effect for macro1 == B|C &gt; }<br/>
           ]<br/>
<div class="spacer">
</div>
In case of several warp masters, &quot;follow&quot; must use named parameters, and rules must use boolean expression:<div class="spacer">
</div>
<br/>
 follow =&gt; { m1 =&gt; '! macro1', m2 =&gt; '- macro2' } ,<br/>
 rules =&gt; [<br/>
           '$m1 eq &quot;A&quot; &amp;&amp; $m2 eq &quot;C&quot;' =&gt; { &lt;effect for A C&gt; },<br/>
           '$m1 eq &quot;A&quot; &amp;&amp; $m2 eq &quot;D&quot;' =&gt; { &lt;effect for A D&gt; },<br/>
           '$m1 eq &quot;B&quot; &amp;&amp; $m2 eq &quot;C&quot;' =&gt; { &lt;effect for B C&gt; },<br/>
           '$m1 eq &quot;B&quot; &amp;&amp; $m2 eq &quot;D&quot;' =&gt; { &lt;effect for B D&gt; },<br/>
          ]<br/>
<div class="spacer">
</div>
Of course some combinations of warp master values can have the same effect:<div class="spacer">
</div>
<br/>
 follow =&gt; { m1 =&gt; '! macro1', m2 =&gt; '- macro2' } ,<br/>
 rules =&gt; [<br/>
           '$m1 eq &quot;A&quot; &amp;&amp; $m2 eq &quot;C&quot;' =&gt; { &lt;effect X&gt; },<br/>
           '$m1 eq &quot;A&quot; &amp;&amp; $m2 eq &quot;D&quot;' =&gt; { &lt;effect Y&gt; },<br/>
           '$m1 eq &quot;B&quot; &amp;&amp; $m2 eq &quot;C&quot;' =&gt; { &lt;effect Y&gt; },<br/>
           '$m1 eq &quot;B&quot; &amp;&amp; $m2 eq &quot;D&quot;' =&gt; { &lt;effect Y&gt; },<br/>
          ]<br/>
<div class="spacer">
</div>
In this case, you can use different boolean expression to save typing:<div class="spacer">
</div>
<br/>
 follow =&gt; { m1 =&gt; '! macro1', m2 =&gt; '- macro2' } ,<br/>
 rules =&gt; [<br/>
           '$m1 eq &quot;A&quot; &amp;&amp; $m2 eq &quot;C&quot;' =&gt; { &lt;effect X&gt; },<br/>
           '$m1 eq &quot;A&quot; &amp;&amp; $m2 eq &quot;D&quot;' =&gt; { &lt;effect Y&gt; },<br/>
           '$m1 eq &quot;B&quot; &amp;&amp; ( $m2 eq &quot;C&quot; or $m2 eq &quot;D&quot;) ' =&gt; { &lt;effect Y&gt; },<br/>
          ]<br/>
<div class="spacer">
</div>
Note that the boolean expression will be sanitized and used in a Perl eval, so you can use most Perl syntax and regular expressions.<div class="spacer">
</div>
Function (like &amp;foo) will be called like &quot;$self-&gt;foo&quot; before evaluation\ of the boolean expression.</div>
</div>
<div class="section">
<h1>Methods</h1><div class="subsection">
<h2><i>warp_error()</i></h2> This method returns a string describing:<dl>
<dt>
&#8226;</dt>
<dd>
The location(s) of the warp master</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
The current value(s) of the warp master(s)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
The other values accepted by the warp master that can be tried (if the warp master is an enumerated type)</dd>
</dl>
</div>
</div>
<div class="section">
<h1>How does this work ?</h1><dl>
<dt>
Registration</dt>
<dd>
</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
&#8226;</dt>
<dd>
When a warped object is created, the constructor will register to the warp masters. The warp master are found by using the special string passed to the &quot;follow&quot; parameter. As explained in grab method, the string provides the location of the warp master in the configuration tree using a symbolic form.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Then the warped object retrieve the value(s) of the warp master(s)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Then the warped object warps itself using the above value(s). Depending on these value(s), the properties of the warped object will be modified.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
</div>
<dl>
<dt>
Master update</dt>
<dd>
</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
&#8226;</dt>
<dd>
When a warp master value is updated, the warp master will call <i>all</i> its warped object and pass them the new master value.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Then each warped object will modify its properties according to the new warp master value.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
</div>
</div>
<div class="section">
<h1>AUTHOR</h1> Dominique Dumont, (ddumont at cpan dot org)</div>
<div class="section">
<h1>SEE ALSO</h1> Config::Model::AnyThing, Config::Model::HashId, Config::Model::ListId, Config::Model::WarpedNode, Config::Model::Value</div>
<table class="foot">
<tr>
<td class="foot-date">
2012-02-24</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

