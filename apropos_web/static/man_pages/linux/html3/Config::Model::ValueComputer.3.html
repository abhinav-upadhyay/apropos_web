<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Config::Model::ValueComputer(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Config::Model::ValueComputer(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
Config::Model::ValueComputer(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Config::Model::ValueComputer - Provides configuration value computation</div>
<div class="section">
<h1>VERSION</h1> version 2.005</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
 use Config::Model;<br/>
 use Log::Log4perl qw(:easy);<br/>
 Log::Log4perl-&gt;easy_init($WARN);<br/>
<br/>
 # define configuration tree object<br/>
 my $model = Config::Model-&gt;new;<br/>
 $model -&gt;create_config_class (<br/>
    name =&gt; &quot;MyClass&quot;,<br/>
<br/>
    element =&gt; [ <br/>
<br/>
       [qw/av bv/] =&gt; {type =&gt; 'leaf',<br/>
                       value_type =&gt; 'integer',<br/>
                      },<br/>
       compute_int =&gt; { <br/>
            type =&gt; 'leaf',<br/>
            value_type =&gt; 'integer',<br/>
            compute    =&gt; { formula   =&gt; '$a + $b', <br/>
                            variables =&gt; { a =&gt; '- av', b =&gt; '- bv'}<br/>
                          },<br/>
          },<br/>
   ],<br/>
 ) ;<br/>
<br/>
 my $inst = $model-&gt;instance(root_class_name =&gt; 'MyClass' );<br/>
<br/>
 my $root = $inst-&gt;config_root ;<br/>
<br/>
 # put data<br/>
 $root-&gt;load( step =&gt; 'av=33 bv=9' );<br/>
<br/>
 print &quot;Computed value is &quot;,$root-&gt;grab_value('compute_int'),&quot;\n&quot;;<br/>
 # Computed value is 42<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> This class provides a way to compute a configuration value. This computation uses a formula and some other configuration values from the configuration tree.<div class="spacer">
</div>
The computed value can be overridden, in other words, the computed value can be used as a default value.</div>
<div class="section">
<h1>Computed value declaration</h1> A computed value must be declared in a 'leaf' element. The leaf element must have a &quot;compute&quot; argument pointing to a hash ref.<div class="spacer">
</div>
This array ref contains:<dl>
<dt>
&#8226;</dt>
<dd>
A string formula that use variables and replace function.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
A set of variable and their relative location in the tree (using the notation explained in  <i>grab()</i> method</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
An optional set of replace rules.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
An optional parameter to force a Perl eval of a string.</dd>
</dl>
<div class="subsection">
<h2>Compute formula</h2> The first element of the &quot;compute&quot; array ref must be a string that contains the computation algorithm (i.e. a formula for arithmetic computation for integer values or a string template for string values).<div class="spacer">
</div>
This string or formula should contain variables (like $foo or $bar). Note that these variables are not interpolated by Perl.<div class="spacer">
</div>
For instance:<div class="spacer">
</div>
<br/>
  'My cat has $nb legs'<br/>
  '$m * $c**2'<br/>
<div class="spacer">
</div>
This string or formula may also contain:<dl>
<dt>
&#8226;</dt>
<dd>
The index value of the current object : &amp;index or &quot;&amp;index()&quot;.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
The index value of a parent object: &quot;&amp;index(-)&quot;. Ancestor index value can be retrieved with &quot;&amp;index(-2)&quot; or &quot;&amp;index(-3)&quot;.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
The element name of the current object: &amp;element or &quot;&amp;element()&quot;.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
The element name of a parent object: &quot;&amp;element(-)&quot;. Likewise, ancestor element name can be retrieved with &quot;&amp;element(-2)&quot; or &quot;&amp;element(-3)&quot;.<div style="height: 1.00em;">
&#160;</div>
=item*<div style="height: 1.00em;">
&#160;</div>
The full location (path) of the current object: &amp;location or &quot;&amp;location()&quot;.</dd>
</dl>
<div class="spacer">
</div>
For instance, you could have this template string:<div class="spacer">
</div>
<br/>
   'my element is &amp;element, my index is &amp;index' .<br/>
    'upper element is &amp;element(-), upper index is &amp;index(-)',<br/>
<div class="spacer">
</div>
If you need to perform more complex operations than substitution, like extraction with regular expressions, you can force an eval done by Perl with &quot;use_eval =&gt; 1&quot;. In this case, the result of the eval will be used as the computed value.<div class="spacer">
</div>
For instance:<div class="spacer">
</div>
<br/>
  # extract host from url<br/>
  compute =&gt; { formula =&gt; '$old =~ m!http://[\w\.]+(?::\d+)?(/.*)!; $1 ;', <br/>
               variables =&gt; { old =&gt; '- url' } ,<br/>
               use_eval =&gt; 1 ,<br/>
             },<br/>
<br/>
  # capitalize<br/>
  compute =&gt; { formula =&gt; 'uc($old)',<br/>
               variables =&gt; { old =&gt; '- small_caps' } ,<br/>
               use_eval =&gt; 1 <br/>
             }<br/>
</div>
<div class="subsection">
<h2>Compute variables</h2> The following arguments will be a set of &quot;key =&gt; value&quot; to define the variables used in the formula. The key is a variable name used in the computation string. The value is a string that will be used to get the correct Value object.<div class="spacer">
</div>
In this numeric example, &quot;result&quot; default value is &quot;av + bv&quot;:<div class="spacer">
</div>
<br/>
 element =&gt; [<br/>
  av =&gt; { <br/>
    type =&gt; 'leaf',<br/>
    value_type =&gt; 'integer'<br/>
  },<br/>
  bv =&gt; { <br/>
    type =&gt; 'leaf',<br/>
    value_type =&gt; 'integer'<br/>
  },<br/>
  result =&gt; { <br/>
    type =&gt; 'leaf',<br/>
    value_type =&gt; 'integer', <br/>
    compute =&gt; { formula =&gt; '$a + $b' , <br/>
                 variables =&gt; { a =&gt; '- av', b =&gt; '- bv' },<br/>
               }<br/>
  }<br/>
<div class="spacer">
</div>
In this string example, the default value of the &quot;Comp&quot; element is actually a string made of &quot;&quot;macro is &quot;&quot; and the value of the &quot;&quot;macro&quot;&quot; element of the object located 2 nodes above:<div class="spacer">
</div>
<br/>
   comp =&gt; { <br/>
    type =&gt; 'leaf',<br/>
    value_type =&gt; 'string', <br/>
    compute =&gt; { formula =&gt; '&quot;macro is $m&quot;' ,<br/>
                 variables =&gt; { m =&gt; '- - macro' }<br/>
               }<br/>
   }<br/>
</div>
<div class="subsection">
<h2>Compute replace</h2> Sometime, using the value of a tree leaf is not enough and you need to substitute a replacement for any value you can get. This replacement can be done using a hash like notation within the formula using the %replace hash.<div class="spacer">
</div>
For instance, if you want to display a summary of a config, you can do :<div class="spacer">
</div>
<br/>
       compute_with_replace <br/>
       =&gt; {<br/>
            formula =&gt; '$replace{$who} is the $replace{$what} of $replace{$country}',<br/>
            variables =&gt; {<br/>
                           who   =&gt; '! who' ,<br/>
                           what  =&gt; '! what' ,<br/>
                           country =&gt; '- country',<br/>
                         },<br/>
            replace =&gt; {  chief =&gt; 'president', <br/>
                          America =&gt; 'USA'<br/>
                       },<br/>
</div>
<div class="subsection">
<h2>Complex formula</h2> &amp;index, &amp;element, and replace can be combined. But the argument of &amp;element or &amp;index can only be a value object specification (I.e. something like '&quot;- - foo&quot;'), it cannot be a value replacement of another &amp;element or &amp;index.<div class="spacer">
</div>
I.e. &quot;&amp;element($foo)&quot; is ok, but &quot;&amp;element(&amp;index($foo))&quot; is not allowed.</div>
<div class="subsection">
<h2>computed variable</h2> Compute variables can themselves be computed :<div class="spacer">
</div>
<br/>
   compute =&gt; {<br/>
     formula =&gt; 'get_element is $replace{$s}, indirect value is \'$v\'',<br/>
     variables =&gt; { 's' =&gt; '! $where',<br/>
                     where =&gt; '! where_is_element',<br/>
                     v =&gt; '! $replace{$s}',<br/>
                  }<br/>
     replace   =&gt; { m_value_element =&gt; 'm_value',<br/>
                    compute_element =&gt; 'compute' <br/>
                  }<br/>
    }<br/>
<div class="spacer">
</div>
Be sure not to specify a loop when doing recursive computation.</div>
<div class="subsection">
<h2>compute override</h2> In some case, a computed value must be interpreted as a default value and the user must be able to override this computed default value.  In this case, you must use &quot;allow_override =&gt; 1&quot; with the compute parameter:<div class="spacer">
</div>
<br/>
   computed_value_with_override =&gt; { <br/>
    type =&gt; 'leaf',<br/>
    value_type =&gt; 'string', <br/>
    compute =&gt; { formula =&gt; '&quot;macro is $m&quot;' , <br/>
                 variables =&gt; { m =&gt; '- - macro' } ,<br/>
                 allow_override =&gt; 1,<br/>
               }<br/>
   }<br/>
</div>
<div class="subsection">
<h2>Undefined variables</h2> You may need to compute value where one of the variables (i.e. other configuration parameter) is undefined. By default, any formula will yield an undefined value if one variable is undefined.<div class="spacer">
</div>
You may change this behavior with &quot;undef_is&quot; parameter. Depending on your formula and whether &quot;use_eval&quot; is true or not, you may specify a &quot;fallback&quot; value that will be used in your formula.<div class="spacer">
</div>
The most useful will probably be:<div class="spacer">
</div>
<br/>
 undef_is =&gt; &quot;''&quot;, # for string values<br/>
 undef_is =&gt; 0   , # for integers, boolean values<br/>
<div class="spacer">
</div>
Example:<div class="spacer">
</div>
<br/>
        Source =&gt; {<br/>
            value_type   =&gt; 'string',<br/>
            mandatory    =&gt; 1,<br/>
            migrate_from =&gt; {<br/>
                use_eval  =&gt; 1,<br/>
                formula   =&gt; '$old || $older ;',<br/>
                undef_is =&gt; &quot;''&quot;,<br/>
                variables =&gt; {<br/>
                    older =&gt; '- Original-Source-Location',<br/>
                    old   =&gt; '- Upstream-Source'<br/>
                }<br/>
            },<br/>
            type =&gt; 'leaf',<br/>
        },<br/>
        [qw/Upstream-Source Original-Source-Location/] =&gt; {<br/>
            value_type =&gt; 'string',<br/>
            status     =&gt; 'deprecated',<br/>
            type       =&gt; 'leaf'<br/>
        }<br/>
</div>
</div>
<div class="section">
<h1>Examples</h1><div class="subsection">
<h2>String substitution</h2><br/>
    [qw/sav sbv/] =&gt; {<br/>
        type       =&gt; 'leaf',<br/>
        value_type =&gt; 'string',<br/>
      },<br/>
    compute_string =&gt; {<br/>
        type       =&gt; 'leaf',<br/>
        value_type =&gt; 'string',<br/>
        compute    =&gt; {<br/>
            formula   =&gt; 'meet $a and $b',<br/>
            variables =&gt; { '- sav', b =&gt; '- sbv' }<br/>
        },<br/>
    },<br/>
</div>
<div class="subsection">
<h2>Computation with on-the-fly replacement</h2><br/>
    compute_with_replace =&gt; {<br/>
        type       =&gt; 'leaf',<br/>
        value_type =&gt; 'string',<br/>
        compute    =&gt; {<br/>
            formula =&gt;<br/>
              '$replace{$who} is the $replace{$what} of $replace{$country}',<br/>
            variables =&gt; {<br/>
                who     =&gt; '! who',<br/>
                what    =&gt; '! what',<br/>
                country =&gt; '- country',<br/>
            },<br/>
            replace =&gt; {<br/>
                chief   =&gt; 'president',<br/>
                America =&gt; 'USA'<br/>
            },<br/>
        },<br/>
      },<br/>
</div>
<div class="subsection">
<h2>Extract data from a value using a Perl regexp</h2> Extract the host name from an URL:<div class="spacer">
</div>
<br/>
    url =&gt; {<br/>
        type       =&gt; 'leaf',<br/>
        value_type =&gt; 'uniline'<br/>
    },<br/>
    extract_host_from_url =&gt; {<br/>
        type       =&gt; 'leaf',<br/>
        value_type =&gt; 'uniline',<br/>
        compute    =&gt; {<br/>
            formula   =&gt; '$old =~ m!http://([\w\.]+)!; $1 ;',<br/>
            variables =&gt; { old =&gt; '- url' },<br/>
            use_eval  =&gt; 1,<br/>
        },<br/>
    },<br/>
</div>
</div>
<div class="section">
<h1>AUTHOR</h1> Dominique Dumont, (ddumont at cpan dot org)</div>
<div class="section">
<h1>SEE ALSO</h1> Config::Model, Config::Model::Instance, Config::Model::Value</div>
<table class="foot">
<tr>
<td class="foot-date">
2012-02-24</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

