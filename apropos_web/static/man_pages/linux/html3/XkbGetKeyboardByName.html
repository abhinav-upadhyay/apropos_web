<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
XkbGetKeyboardByName(3)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
XkbGetKeyboardByName(3)</td>
<td class="head-vol">
XKB FUNCTIONS</td>
<td class="head-rtitle">
XkbGetKeyboardByName(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> XkbGetKeyboardByName - Build a new keyboard description from a set of named components, and to optionally have the server use the resulting description to replace an active one</div>
<div class="section">
<h1>SYNOPSIS</h1><div style="margin-left: 5.00ex;text-indent: -5.00ex;" class="spacer">
<b>XkbDescPtr XkbGetKeyboardByName</b> <b>(Display *</b><i>dpy</i><b>,</b> <b>unsigned int </b><i>device_spec</i><b>,</b> <b>XkbComponentNamesPtr </b><i>names</i><b>,</b> <b>unsigned int </b><i>want</i><b>,</b> <b>unsigned int </b><i>need</i><b>,</b> <b>Bool </b><i>load</i><b>);</b></div>
</div>
<div class="section">
<h1>ARGUMENTS</h1><dl>
<dt>
<i>- dpy</i></dt>
<dd>
connection to X server</dd>
</dl>
<dl>
<dt>
<i>- device_spec</i></dt>
<dd>
device ID, or XkbUseCoreKbd</dd>
</dl>
<dl>
<dt>
<i>- names</i></dt>
<dd>
names of components to fetch</dd>
</dl>
<dl>
<dt>
<i>- want</i></dt>
<dd>
desired structures in returned record</dd>
</dl>
<dl>
<dt>
<i>- need</i></dt>
<dd>
mandatory structures in returned record</dd>
</dl>
<dl>
<dt>
<i>- load</i></dt>
<dd>
True =&gt; load into <i>device_spec</i></dd>
</dl>
</div>
<div class="section">
<h1>DESCRIPTION</h1> A client may request that the server fetch one or more components from its database and use those components to build a new server keyboard description. The new keyboard description may be built from scratch, or it may be built starting with the current keyboard description for a particular device. Once the keyboard description is built, all or part of it may be returned to the client. The parts returned to the client need not include all of the parts used to build the description. At the time it requests the server to build a new keyboard description, a client may also request that the server use the new description internally to replace the current keyboard description for a specific device, in which case the behavior of the device changes accordingly.<div style="height: 1.00em;">
&#160;</div>
To build a new keyboard description from a set of named components, and to optionally have the server use the resulting description to replace an active one, use <i>XkbGetKeyboardByName.</i><div style="height: 1.00em;">
&#160;</div>
<i>names</i> contains a set of expressions describing the keyboard components the server should use to build the new keyboard description. <i>want</i> and <i>need</i> are bit fields describing the parts of the resulting keyboard description that should be present in the returned XkbDescRec.<div style="height: 1.00em;">
&#160;</div>
The individual fields in <i>names</i> are <i>component expressions</i> composed of keyboard component names (no wildcarding as may be used in <i>XkbListComponents),</i> the special component name symbol `%', and the special operator characters `+' and `|'. A component expression is parsed left to right, as follows:<div style="height: 1.00em;">
&#160;</div>
<dl>
<dt>
&#8226;</dt>
<dd>
The special component name &quot;computed&quot; may be used in keycodes component expressions and refers to a component consisting of a set of keycodes computed automatically by the server as needed.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
The special component name &quot;canonical&quot; may be used in types component expressions and refers to a partial component defining the four standard key types: ALPHABETIC, ONE_LEVEL, TWO_LEVEL, and KEYPAD.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
The special component name `%' refers to the keyboard description for the device specified in device_spec or the keymap names component. If a keymap names component is specified that does not begin with `+' or `|' and does not contain `%', then `%' refers to the description generated by the keymap names component. Otherwise, it refers to the keyboard description for device_spec.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
The `+' operator specifies that the following component should override the currently assembled description; any definitions that are present in both components are taken from the second.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
The `|' operator specifies that the next specified component should augment the currently assembled description; any definitions that are present in both components are taken from the first.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
If the component expression begins with an operator, a leading `%' is implied.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
If any unknown or illegal characters appear anywhere in the expression, the entire expression is invalid and is ignored.<div style="height: 1.00em;">
&#160;</div>
For example, if <i>names-&gt;symbols</i> contained the expression &quot;+de&quot;, it specifies that the default member of the &quot;de&quot; class of symbols should be applied to the current keyboard mapping, overriding any existing definitions (it could also be written &quot;+de(default)&quot;).<div style="height: 1.00em;">
&#160;</div>
Here is a slightly more involved example: the expression &quot;acme(ascii)+de(basic)|iso9995-3&quot; constructs a German (de) mapping for the ASCII keyboard supplied by the &quot;acme&quot; vendor. The new definition begins with the symbols for the ASCII keyboard for Acme <i>(acme(ascii)),</i> overrides them with definitions for the basic German keyboard <i>(de(basic)),</i> and then applies the definitions from the default iso9995-3 keyboard <i>(iso9995-3)</i> to any undefined keys or groups of keys (part three of the iso9995 standard defines a common set of bindings for the secondary group, but allows national layouts to override those definitions where necessary).<div style="height: 1.00em;">
&#160;</div>
<b>NOTE</b> The interpretation of the above expression components (acme, ascii, de, basic, iso9995-3) is not defined by Xkb; only the operations and their ordering are.<div style="height: 1.00em;">
&#160;</div>
Note that the presence of a keymap <i>names</i> component that does not contain `%' (either explicit or implied by virtue of an expression starting with an operator) indicates a description that is independent of the keyboard description for the device specified in <i>device_spec.</i> The same is true of requests in which the keymap names component is empty and all five other names components contain expressions void of references to `%'. Requests of this form allow you to deal with keyboard definitions independent of any actual device.<div style="height: 1.00em;">
&#160;</div>
The server parses all non-NULL fields in <i>names</i> and uses them to build a keyboard description. However, before parsing the expressions in <i>names,</i> the server ORs the bits in <i>want</i> and <i>need</i> together and examines the result in relationship to the expressions in <i>names.</i> Table 1 identifies the components that are required for each of the possible bits in <i>want</i> or <i>need.</i> If a required component has not been specified in the <i>names structure (the corresponding field is NULL), the server substitutes the</i> expression &quot;%&quot;, resulting in the component values being taken from <i>device_spec.</i> In addition, if <i>load</i> is True, the server modifies <i>names</i> if necessary (again using a &quot;%&quot; entry) to ensure all of the following fields are non-NULL: <i>types, keycodes, symbols,</i> and <i>compat.</i><table class="tbl">
<col style="width: 24.00ex;"/>
<col style="width: 46.00ex;"/>
<col style="width: 7.00ex;"/>
<tbody>
<tr>
<td>
Table 1 Want and Need Mask Bits and Required Names Components</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td colspan="0">
</td>
</tr>
<tr>
<td>
want or need mask bit</td>
<td>
Required names Components</td>
<td>
value</td>
</tr>
<tr>
<td colspan="0">
</td>
</tr>
<tr>
<td>
XkbGBN_TypesMask</td>
<td>
Types</td>
<td>
(1L&lt;&lt;0)</td>
</tr>
<tr>
<td>
XkbGBN_CompatMapMask</td>
<td>
Compat</td>
<td>
(1L&lt;&lt;1)</td>
</tr>
<tr>
<td>
XkbGBN_ClientSymbolsMask</td>
<td>
Types + Symbols + Keycodes</td>
<td>
(1L&lt;&lt;2)</td>
</tr>
<tr>
<td>
XkbGBN_ServerSymbolsMask</td>
<td>
Types + Symbols + Keycodes</td>
<td>
(1L&lt;&lt;3)</td>
</tr>
<tr>
<td>
XkbGBN_SymbolsMask</td>
<td>
Symbols</td>
<td>
(1L&lt;&lt;1)</td>
</tr>
<tr>
<td>
XkbGBN_IndicatorMapMask</td>
<td>
Compat</td>
<td>
(1L&lt;&lt;4)</td>
</tr>
<tr>
<td>
XkbGBN_KeyNamesMask</td>
<td>
Keycodes</td>
<td>
(1L&lt;&lt;5)</td>
</tr>
<tr>
<td>
XkbGBN_GeometryMask</td>
<td>
Geometry</td>
<td>
(1L&lt;&lt;6)</td>
</tr>
<tr>
<td>
XkbGBN_OtherNamesMask</td>
<td>
Types + Symbols + Keycodes + Compat + Geometry</td>
<td>
(1L&lt;&lt;7)</td>
</tr>
<tr>
<td>
XkbGBN_AllComponentsMask</td>
<td>
</td>
<td>
(0xff)</td>
</tr>
</tbody>
</table>
<div style="height: 1.00em;">
&#160;</div>
<i>need</i> specifies a set of keyboard components that the server must be able to resolve in order for <i>XkbGetKeyboardByName</i> to succeed; if any of the components specified in <i>need</i> cannot be successfully resolved, <i>XkbGetKeyboardByName</i> fails.<div style="height: 1.00em;">
&#160;</div>
<i>want</i> specifies a set of keyboard components that the server should attempt to resolve, but that are not mandatory. If the server is unable to resolve any of these components, <i>XkbGetKeyboardByName</i> still succeeds. Bits specified in <i>want</i> that are also specified in <i>need</i> have no effect in the context of <i>want.</i><div style="height: 1.00em;">
&#160;</div>
If <i>load</i> is True, the server updates its keyboard description for <i>device_spec</i> to match the result of the keyboard description just built. If load is False, the server's description for device <i>device_spec</i> is not updated. In all cases, the parts specified by <i>want</i> and <i>need</i> from the just-built keyboard description are returned.<div style="height: 1.00em;">
&#160;</div>
The <i>names</i> structure in an XkbDescRec keyboard description record contains one field for each of the five component types used to build a keyboard description. When a keyboard description is built from a set of database components, the corresponding fields in this <i>names</i> structure are set to match the expressions used to build the component.<div style="height: 1.00em;">
&#160;</div>
Building a New Keyboard Description from the Server Database<div style="height: 1.00em;">
&#160;</div>
The information returned to the client in the XkbDescRec is essentially the result of a series of calls to extract information from a fictitious device whose description matches the one just built. The calls corresponding to each of the mask bits are summarized in Table 2, together with the XkbDescRec components that are filled in.<div style="height: 1.00em;">
&#160;</div>
<table class="tbl">
<col style="width: 48.00ex;"/>
<col style="width: 25.00ex;"/>
<col style="width: 43.00ex;"/>
<tbody>
<tr>
<td>
Table 2 XkbDescRec Components Returned for Values of Want &amp; Needs</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td colspan="0">
</td>
</tr>
<tr>
<td>
Request (want+need)</td>
<td>
Fills in Xkb components</td>
<td>
Equivalent Function Call</td>
</tr>
<tr>
<td colspan="0">
</td>
</tr>
<tr>
<td>
XkbGBN_TypesMask</td>
<td>
map.types</td>
<td>
XkbGetUpdatedMap(dpy, XkbTypesMask, Xkb)</td>
</tr>
<tr>
<td>
XkbGBN_ServerSymbolsMask</td>
<td>
server</td>
<td>
XkbGetUpdatedMap(dpy, </td>
</tr>
<tr>
<td>
XkbAllClientInfoMask, Xkb)</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
XkbGBN_ClientSymbolsMask</td>
<td>
map, including map.types</td>
<td>
</td>
</tr>
<tr>
<td>
XkbGetUpdatedMap(dpy, XkbAllServerInfoMask, Xkb)</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
XkbGBN_IndicatorMaps</td>
<td>
indicators</td>
<td>
XkbGetIndicatorMap(dpy, </td>
</tr>
<tr>
<td>
XkbAllIndicators, Xkb)</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td>
XkbGBN_CompatMapMask</td>
<td>
compat</td>
<td>
XkbGetCompatMap(dpy, XkbAllCompatMask, Xkb)</td>
</tr>
<tr>
<td>
XkbGBN_GeometryMask</td>
<td>
geom</td>
<td>
XkbGetGeometry(dpy, Xkb)</td>
</tr>
<tr>
<td>
XkbGBN_KeyNamesMask</td>
<td>
names.keys</td>
<td>
XkbGetNames(dpy, XkbKeyNamesMask |</td>
</tr>
<tr>
<td>
</td>
<td>
names.key_aliases</td>
<td>
XkbKeyAliasesMask, Xkb)</td>
</tr>
<tr>
<td>
XkbGBN_OtherNamesMask</td>
<td>
names.keycodes</td>
<td>
XkbGetNames(dpy, XkbAllNamesMask &amp;</td>
</tr>
<tr>
<td>
</td>
<td>
names.geometry</td>
<td>
~(XkbKeyNamesMask | XkbKeyAliasesMask),</td>
</tr>
<tr>
<td>
</td>
<td>
names.symbols</td>
<td>
Xkb)</td>
</tr>
<tr>
<td>
</td>
<td>
names.types</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
map.types[*].lvl_names[*]</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
names.compat</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
names.vmods</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
names.indicators</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
names.groups</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
names.radio_groups</td>
<td>
</td>
</tr>
<tr>
<td>
</td>
<td>
names.phys_symbols</td>
<td>
</td>
</tr>
</tbody>
</table>
<div style="height: 1.00em;">
&#160;</div>
There is no way to determine which components specified in <i>want</i> (but not in <i>need)</i> were actually fetched, other than breaking the call into successive calls to <i>XkbGetKeyboardByName</i> and specifying individual components.<div style="height: 1.00em;">
&#160;</div>
<i>XkbGetKeyboardByName</i> always sets <i>min_key_code</i> and <i>max_key_code</i> in the returned XkbDescRec structure.<div style="height: 1.00em;">
&#160;</div>
<i>XkbGetKeyboardByName</i> is synchronous; it sends the request to the server to build a new keyboard description and waits for the reply. If successful, the return value is non-NULL. <i>XkbGetKeyboardByName</i> generates a BadMatch protocol error if errors are encountered when building the keyboard description.</dd>
</dl>
</div>
<div class="section">
<h1>STRUCTURES</h1> The complete description of an Xkb keyboard is given by an XkbDescRec. The component structures in the XkbDescRec represent the major Xkb components outlined in Figure 1.1.<div style="height: 1.00em;">
&#160;</div>
<br/>
typedef struct {<br/>
   struct _XDisplay * display;      /&#8727; connection to X server */<br/>
   unsigned short     flags;        /&#8727; private to Xkb, do not modify */<br/>
   unsigned short     device_spec;  /&#8727; device of interest */<br/>
   KeyCode            min_key_code; /&#8727; minimum keycode for device */<br/>
   KeyCode            max_key_code; /&#8727; maximum keycode for device */<br/>
   XkbControlsPtr     ctrls;        /&#8727; controls */<br/>
   XkbServerMapPtr    server;       /&#8727; server keymap */<br/>
   XkbClientMapPtr    map;          /&#8727; client keymap */<br/>
   XkbIndicatorPtr    indicators;   /&#8727; indicator map */<br/>
   XkbNamesPtr        names;        /&#8727; names for all components */<br/>
   XkbCompatMapPtr    compat;       /&#8727; compatibility map */<br/>
   XkbGeometryPtr     geom;         /&#8727; physical geometry of keyboard */<br/>
} XkbDescRec, *XkbDescPtr;<div class="spacer">
</div>
<br/>
The <i>display</i> field points to an X display structure. The <i>flags field is private to the library: modifying</i> <i>flags</i> may yield unpredictable results. The <i>device_spec</i> field specifies the device identifier of the keyboard input device, or XkbUseCoreKeyboard, which specifies the core keyboard device. The <i>min_key_code</i> and <i>max_key_code</i> fields specify the least and greatest keycode that can be returned by the keyboard.<div style="height: 1.00em;">
&#160;</div>
Each structure component has a corresponding mask bit that is used in function calls to indicate that the structure should be manipulated in some manner, such as allocating it or freeing it. These masks and their relationships to the fields in the XkbDescRec are shown in Table 3.<div style="height: 1.00em;">
&#160;</div>
<table class="tbl">
<col style="width: 20.00ex;"/>
<col style="width: 16.00ex;"/>
<col style="width: 7.00ex;"/>
<tbody>
<tr>
<td>
Table 3 Mask Bits for XkbDescRec</td>
<td>
</td>
<td>
</td>
</tr>
<tr>
<td colspan="0">
</td>
</tr>
<tr>
<td>
Mask Bit</td>
<td>
XkbDescRec Field</td>
<td>
Value</td>
</tr>
<tr>
<td colspan="0">
</td>
</tr>
<tr>
<td>
XkbControlsMask</td>
<td>
ctrls</td>
<td>
(1L&lt;&lt;0)</td>
</tr>
<tr>
<td>
XkbServerMapMask</td>
<td>
server</td>
<td>
(1L&lt;&lt;1)</td>
</tr>
<tr>
<td>
XkbIClientMapMask</td>
<td>
map</td>
<td>
(1L&lt;&lt;2)</td>
</tr>
<tr>
<td>
XkbIndicatorMapMask</td>
<td>
indicators</td>
<td>
(1L&lt;&lt;3)</td>
</tr>
<tr>
<td>
XkbNamesMask</td>
<td>
names</td>
<td>
(1L&lt;&lt;4)</td>
</tr>
<tr>
<td>
XkbCompatMapMask</td>
<td>
compat</td>
<td>
(1L&lt;&lt;5)</td>
</tr>
<tr>
<td>
XkbGeometryMask</td>
<td>
geom</td>
<td>
(1L&lt;&lt;6)</td>
</tr>
<tr>
<td>
XkbAllComponentsMask</td>
<td>
All Fields</td>
<td>
(0x7f)</td>
</tr>
</tbody>
</table>
</div>
<div class="section">
<h1>DIAGNOSTICS</h1><dl>
<dt>
<b>BadMatch</b></dt>
<dd>
A compatible version of Xkb was not available in the server or an argument has correct type and range, but is otherwise invalid</dd>
</dl>
</div>
<div class="section">
<h1>SEE ALSO</h1> <b>XkbListComponents</b>(3)<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<table class="foot">
<tr>
<td class="foot-date">
libX11 1.4.99.1</td>
<td class="foot-os">
X Version 11</td>
</tr>
</table>
</div>
</body>
</html>

