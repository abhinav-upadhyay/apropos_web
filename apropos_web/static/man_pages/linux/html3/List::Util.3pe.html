<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
List::Util(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
List::Util(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
List::Util(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> List::Util - A selection of general-utility list subroutines</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
    use List::Util qw(first max maxstr min minstr reduce shuffle sum);<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> &quot;List::Util&quot; contains a selection of subroutines that people have expressed would be nice to have in the perl core, but the usage would not really be high enough to warrant the use of a keyword, and the size so small such that being individual extensions would be wasteful.<div class="spacer">
</div>
By default &quot;List::Util&quot; does not export any subroutines. The subroutines defined are<dl>
<dt>
first BLOCK LIST</dt>
<dd>
Similar to &quot;grep&quot; in that it evaluates BLOCK setting $_ to each element of LIST in turn. &quot;first&quot; returns the first element where the result from BLOCK is a true value. If BLOCK never returns true or LIST was empty then &quot;undef&quot; is returned.<div style="height: 1.00em;">
&#160;</div>
<br/>
    $foo = first { defined($_) } @list    # first defined value in @list<br/>
    $foo = first { $_ &gt; $value } @list    # first value in @list which<br/>
                                          # is greater than $value<br/>
<div style="height: 1.00em;">
&#160;</div>
This function could be implemented using &quot;reduce&quot; like this<div style="height: 1.00em;">
&#160;</div>
<br/>
    $foo = reduce { defined($a) ? $a : wanted($b) ? $b : undef } undef, @list<br/>
<div style="height: 1.00em;">
&#160;</div>
for example <i>wanted()</i> could be <i>defined()</i> which would return the first defined value in @list</dd>
</dl>
<dl>
<dt>
max LIST</dt>
<dd>
Returns the entry in the list with the highest numerical value. If the list is empty then &quot;undef&quot; is returned.<div style="height: 1.00em;">
&#160;</div>
<br/>
    $foo = max 1..10                # 10<br/>
    $foo = max 3,9,12               # 12<br/>
    $foo = max @bar, @baz           # whatever<br/>
<div style="height: 1.00em;">
&#160;</div>
This function could be implemented using &quot;reduce&quot; like this<div style="height: 1.00em;">
&#160;</div>
<br/>
    $foo = reduce { $a &gt; $b ? $a : $b } 1..10<br/>
</dd>
</dl>
<dl>
<dt>
maxstr LIST</dt>
<dd>
Similar to &quot;max&quot;, but treats all the entries in the list as strings and returns the highest string as defined by the &quot;gt&quot; operator. If the list is empty then &quot;undef&quot; is returned.<div style="height: 1.00em;">
&#160;</div>
<br/>
    $foo = maxstr 'A'..'Z'          # 'Z'<br/>
    $foo = maxstr &quot;hello&quot;,&quot;world&quot;   # &quot;world&quot;<br/>
    $foo = maxstr @bar, @baz        # whatever<br/>
<div style="height: 1.00em;">
&#160;</div>
This function could be implemented using &quot;reduce&quot; like this<div style="height: 1.00em;">
&#160;</div>
<br/>
    $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'<br/>
</dd>
</dl>
<dl>
<dt>
min LIST</dt>
<dd>
Similar to &quot;max&quot; but returns the entry in the list with the lowest numerical value. If the list is empty then &quot;undef&quot; is returned.<div style="height: 1.00em;">
&#160;</div>
<br/>
    $foo = min 1..10                # 1<br/>
    $foo = min 3,9,12               # 3<br/>
    $foo = min @bar, @baz           # whatever<br/>
<div style="height: 1.00em;">
&#160;</div>
This function could be implemented using &quot;reduce&quot; like this<div style="height: 1.00em;">
&#160;</div>
<br/>
    $foo = reduce { $a &lt; $b ? $a : $b } 1..10<br/>
</dd>
</dl>
<dl>
<dt>
minstr LIST</dt>
<dd>
Similar to &quot;min&quot;, but treats all the entries in the list as strings and returns the lowest string as defined by the &quot;lt&quot; operator. If the list is empty then &quot;undef&quot; is returned.<div style="height: 1.00em;">
&#160;</div>
<br/>
    $foo = minstr 'A'..'Z'          # 'A'<br/>
    $foo = minstr &quot;hello&quot;,&quot;world&quot;   # &quot;hello&quot;<br/>
    $foo = minstr @bar, @baz        # whatever<br/>
<div style="height: 1.00em;">
&#160;</div>
This function could be implemented using &quot;reduce&quot; like this<div style="height: 1.00em;">
&#160;</div>
<br/>
    $foo = reduce { $a lt $b ? $a : $b } 'A'..'Z'<br/>
</dd>
</dl>
<dl>
<dt>
reduce BLOCK LIST</dt>
<dd>
Reduces LIST by calling BLOCK, in a scalar context, multiple times, setting $a and $b each time. The first call will be with $a and $b set to the first two elements of the list, subsequent calls will be done by setting $a to the result of the previous call and $b to the next element in the list.<div style="height: 1.00em;">
&#160;</div>
Returns the result of the last call to BLOCK. If LIST is empty then &quot;undef&quot; is returned. If LIST only contains one element then that element is returned and BLOCK is not executed.<div style="height: 1.00em;">
&#160;</div>
<br/>
    $foo = reduce { $a &lt; $b ? $a : $b } 1..10       # min<br/>
    $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr<br/>
    $foo = reduce { $a + $b } 1 .. 10               # sum<br/>
    $foo = reduce { $a . $b } @bar                  # concat<br/>
<div style="height: 1.00em;">
&#160;</div>
If your algorithm requires that &quot;reduce&quot; produce an identity value, then make sure that you always pass that identity value as the first argument to prevent &quot;undef&quot; being returned<div style="height: 1.00em;">
&#160;</div>
<br/>
  $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value<br/>
</dd>
</dl>
<dl>
<dt>
shuffle LIST</dt>
<dd>
Returns the elements of LIST in a random order<div style="height: 1.00em;">
&#160;</div>
<br/>
    @cards = shuffle 0..51      # 0..51 in a random order<br/>
</dd>
</dl>
<dl>
<dt>
sum LIST</dt>
<dd>
Returns the sum of all the elements in LIST. If LIST is empty then &quot;undef&quot; is returned.<div style="height: 1.00em;">
&#160;</div>
<br/>
    $foo = sum 1..10                # 55<br/>
    $foo = sum 3,9,12               # 24<br/>
    $foo = sum @bar, @baz           # whatever<br/>
<div style="height: 1.00em;">
&#160;</div>
This function could be implemented using &quot;reduce&quot; like this<div style="height: 1.00em;">
&#160;</div>
<br/>
    $foo = reduce { $a + $b } 1..10<br/>
<div style="height: 1.00em;">
&#160;</div>
If your algorithm requires that &quot;sum&quot; produce an identity of 0, then make sure that you always pass 0 as the first argument to prevent &quot;undef&quot; being returned<div style="height: 1.00em;">
&#160;</div>
<br/>
  $foo = sum 0, @values;<br/>
</dd>
</dl>
</div>
<div class="section">
<h1>KNOWN BUGS</h1> With perl versions prior to 5.005 there are some cases where reduce will return an incorrect result. This will show up as test 7 of reduce.t failing.</div>
<div class="section">
<h1>SUGGESTED ADDITIONS</h1> The following are additions that have been requested, but I have been reluctant to add due to them being very simple to implement in perl<div class="spacer">
</div>
<br/>
  # One argument is true<br/>
<br/>
  sub any { $_ &amp;&amp; return 1 for @_; 0 }<br/>
<br/>
  # All arguments are true<br/>
<br/>
  sub all { $_ || return 0 for @_; 1 }<br/>
<br/>
  # All arguments are false<br/>
<br/>
  sub none { $_ &amp;&amp; return 0 for @_; 1 }<br/>
<br/>
  # One argument is false<br/>
<br/>
  sub notall { $_ || return 1 for @_; 0 }<br/>
<br/>
  # How many elements are true<br/>
<br/>
  sub true { scalar grep { $_ } @_ }<br/>
<br/>
  # How many elements are false<br/>
<br/>
  sub false { scalar grep { !$_ } @_ }<br/>
</div>
<div class="section">
<h1>SEE ALSO</h1> Scalar::Util, List::MoreUtils</div>
<div class="section">
<h1>COPYRIGHT</h1> Copyright (c) 1997-2007 Graham Barr &lt;gbarr@pobox.com&gt;. All rights reserved. This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-09-19</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

