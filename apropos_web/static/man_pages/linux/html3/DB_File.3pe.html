<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
DB_File(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
DB_File(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
DB_File(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> DB_File - Perl5 access to Berkeley DB version 1.x</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
 use DB_File;<br/>
<br/>
 [$X =] tie %hash,  'DB_File', [$filename, $flags, $mode, $DB_HASH] ;<br/>
 [$X =] tie %hash,  'DB_File', $filename, $flags, $mode, $DB_BTREE ;<br/>
 [$X =] tie @array, 'DB_File', $filename, $flags, $mode, $DB_RECNO ;<br/>
<br/>
 $status = $X-&gt;del($key [, $flags]) ;<br/>
 $status = $X-&gt;put($key, $value [, $flags]) ;<br/>
 $status = $X-&gt;get($key, $value [, $flags]) ;<br/>
 $status = $X-&gt;seq($key, $value, $flags) ;<br/>
 $status = $X-&gt;sync([$flags]) ;<br/>
 $status = $X-&gt;fd ;<br/>
<br/>
 # BTREE only<br/>
 $count = $X-&gt;get_dup($key) ;<br/>
 @list  = $X-&gt;get_dup($key) ;<br/>
 %list  = $X-&gt;get_dup($key, 1) ;<br/>
 $status = $X-&gt;find_dup($key, $value) ;<br/>
 $status = $X-&gt;del_dup($key, $value) ;<br/>
<br/>
 # RECNO only<br/>
 $a = $X-&gt;length;<br/>
 $a = $X-&gt;pop ;<br/>
 $X-&gt;push(list);<br/>
 $a = $X-&gt;shift;<br/>
 $X-&gt;unshift(list);<br/>
 @r = $X-&gt;splice(offset, length, elements);<br/>
<br/>
 # DBM Filters<br/>
 $old_filter = $db-&gt;filter_store_key  ( sub { ... } ) ;<br/>
 $old_filter = $db-&gt;filter_store_value( sub { ... } ) ;<br/>
 $old_filter = $db-&gt;filter_fetch_key  ( sub { ... } ) ;<br/>
 $old_filter = $db-&gt;filter_fetch_value( sub { ... } ) ;<br/>
<br/>
 untie %hash ;<br/>
 untie @array ;<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1>  <b>DB_File</b> is a module which allows Perl programs to make use of the facilities provided by Berkeley DB version 1.x (if you have a newer version of DB, see &quot;Using DB_File with Berkeley DB version 2 or greater&quot;). It is assumed that you have a copy of the Berkeley DB manual pages at hand when reading this documentation. The interface defined here mirrors the Berkeley DB interface closely.<div class="spacer">
</div>
Berkeley DB is a C library which provides a consistent interface to a number of database formats.   <b>DB_File</b> provides an interface to all three of the database types currently supported by Berkeley DB.<div class="spacer">
</div>
The file types are:<dl>
<dt>
<b>DB_HASH</b></dt>
<dd>
This database type allows arbitrary key/value pairs to be stored in data files. This is equivalent to the functionality provided by other hashing packages like DBM, NDBM, ODBM, GDBM, and SDBM. Remember though, the files created using DB_HASH are not compatible with any of the other packages mentioned.<div style="height: 1.00em;">
&#160;</div>
A default hashing algorithm, which will be adequate for most applications, is built into Berkeley DB. If you do need to use your own hashing algorithm it is possible to write your own in Perl and have  <b>DB_File</b> use it instead.</dd>
</dl>
<dl>
<dt>
<b>DB_BTREE</b></dt>
<dd>
The btree format allows arbitrary key/value pairs to be stored in a sorted, balanced binary tree.<div style="height: 1.00em;">
&#160;</div>
As with the DB_HASH format, it is possible to provide a user defined Perl routine to perform the comparison of keys. By default, though, the keys are stored in lexical order.</dd>
</dl>
<dl>
<dt>
<b>DB_RECNO</b></dt>
<dd>
DB_RECNO allows both fixed-length and variable-length flat text files to be manipulated using the same key/value pair interface as in DB_HASH and DB_BTREE.  In this case the key will consist of a record (line) number.</dd>
</dl>
<div class="subsection">
<h2>Using DB_File with Berkeley DB version 2 or greater</h2> Although  <b>DB_File</b> is intended to be used with Berkeley DB version 1, it can also be used with version 2, 3 or 4. In this case the interface is limited to the functionality provided by Berkeley DB 1.x. Anywhere the version 2 or greater interface differs,  <b>DB_File</b> arranges for it to work like version 1. This feature allows  <b>DB_File</b> scripts that were built with version 1 to be migrated to version 2 or greater without any changes.<div class="spacer">
</div>
If you want to make use of the new features available in Berkeley DB 2.x or greater, use the Perl module  <b>BerkeleyDB</b> instead.<div class="spacer">
</div>
<b>Note:</b> The database file format has changed multiple times in Berkeley DB version 2, 3 and 4. If you cannot recreate your databases, you must dump any existing databases with either the &quot;db_dump&quot; or the &quot;db_dump185&quot; utility that comes with Berkeley DB. Once you have rebuilt DB_File to use Berkeley DB version 2 or greater, your databases can be recreated using &quot;db_load&quot;. Refer to the Berkeley DB documentation for further details.<div class="spacer">
</div>
Please read &quot;COPYRIGHT&quot; before using version 2.x or greater of Berkeley DB with DB_File.</div>
<div class="subsection">
<h2>Interface to Berkeley DB</h2>  <b>DB_File</b> allows access to Berkeley DB files using the <i>tie()</i> mechanism in Perl 5 (for full details, see &quot; <i>tie()</i>&quot; in perlfunc). This facility allows  <b>DB_File</b> to access Berkeley DB files using either an associative array (for DB_HASH &amp; DB_BTREE file types) or an ordinary array (for the DB_RECNO file type).<div class="spacer">
</div>
In addition to the <i>tie()</i> interface, it is also possible to access most of the functions provided in the Berkeley DB API directly. See &quot;THE API INTERFACE&quot;.</div>
<div class="subsection">
<h2>Opening a Berkeley DB Database File</h2> Berkeley DB uses the function  <i>dbopen()</i> to open or create a database. Here is the C prototype for  <i>dbopen()</i>:<div class="spacer">
</div>
<br/>
      DB*<br/>
      dbopen (const char * file, int flags, int mode, <br/>
              DBTYPE type, const void * openinfo)<br/>
<div class="spacer">
</div>
The parameter &quot;type&quot; is an enumeration which specifies which of the 3 interface methods (DB_HASH, DB_BTREE or DB_RECNO) is to be used. Depending on which of these is actually chosen, the final parameter,  <i>openinfo</i> points to a data structure which allows tailoring of the specific interface method.<div class="spacer">
</div>
This interface is handled slightly differently in <b>DB_File</b>. Here is an equivalent call using  <b>DB_File</b>:<div class="spacer">
</div>
<br/>
        tie %array, 'DB_File', $filename, $flags, $mode, $DB_HASH ;<br/>
<div class="spacer">
</div>
The &quot;filename&quot;, &quot;flags&quot; and &quot;mode&quot; parameters are the direct equivalent of their  <i>dbopen()</i> counterparts. The final parameter $DB_HASH performs the function of both the &quot;type&quot; and &quot;openinfo&quot; parameters in  <i>dbopen()</i>.<div class="spacer">
</div>
In the example above $DB_HASH is actually a pre-defined reference to a hash object.  <b>DB_File</b> has three of these pre-defined references. Apart from $DB_HASH, there is also $DB_BTREE and $DB_RECNO.<div class="spacer">
</div>
The keys allowed in each of these pre-defined references is limited to the names used in the equivalent C structure. So, for example, the $DB_HASH reference will only allow keys called &quot;bsize&quot;, &quot;cachesize&quot;, &quot;ffactor&quot;, &quot;hash&quot;, &quot;lorder&quot; and &quot;nelem&quot;.<div class="spacer">
</div>
To change one of these elements, just assign to it like this:<div class="spacer">
</div>
<br/>
        $DB_HASH-&gt;{'cachesize'} = 10000 ;<br/>
<div class="spacer">
</div>
The three predefined variables $DB_HASH, $DB_BTREE and $DB_RECNO are usually adequate for most applications.  If you do need to create extra instances of these objects, constructors are available for each file type.<div class="spacer">
</div>
Here are examples of the constructors and the valid options available for DB_HASH, DB_BTREE and DB_RECNO respectively.<div class="spacer">
</div>
<br/>
     $a = new DB_File::HASHINFO ;<br/>
     $a-&gt;{'bsize'} ;<br/>
     $a-&gt;{'cachesize'} ;<br/>
     $a-&gt;{'ffactor'};<br/>
     $a-&gt;{'hash'} ;<br/>
     $a-&gt;{'lorder'} ;<br/>
     $a-&gt;{'nelem'} ;<br/>
<br/>
     $b = new DB_File::BTREEINFO ;<br/>
     $b-&gt;{'flags'} ;<br/>
     $b-&gt;{'cachesize'} ;<br/>
     $b-&gt;{'maxkeypage'} ;<br/>
     $b-&gt;{'minkeypage'} ;<br/>
     $b-&gt;{'psize'} ;<br/>
     $b-&gt;{'compare'} ;<br/>
     $b-&gt;{'prefix'} ;<br/>
     $b-&gt;{'lorder'} ;<br/>
<br/>
     $c = new DB_File::RECNOINFO ;<br/>
     $c-&gt;{'bval'} ;<br/>
     $c-&gt;{'cachesize'} ;<br/>
     $c-&gt;{'psize'} ;<br/>
     $c-&gt;{'flags'} ;<br/>
     $c-&gt;{'lorder'} ;<br/>
     $c-&gt;{'reclen'} ;<br/>
     $c-&gt;{'bfname'} ;<br/>
<div class="spacer">
</div>
The values stored in the hashes above are mostly the direct equivalent of their C counterpart. Like their C counterparts, all are set to a default values - that means you don't have to set  <i>all</i> of the values when you only want to change one. Here is an example:<div class="spacer">
</div>
<br/>
     $a = new DB_File::HASHINFO ;<br/>
     $a-&gt;{'cachesize'} =  12345 ;<br/>
     tie %y, 'DB_File', &quot;filename&quot;, $flags, 0777, $a ;<br/>
<div class="spacer">
</div>
A few of the options need extra discussion here. When used, the C equivalent of the keys &quot;hash&quot;, &quot;compare&quot; and &quot;prefix&quot; store pointers to C functions. In  <b>DB_File</b> these keys are used to store references to Perl subs. Below are templates for each of the subs:<div class="spacer">
</div>
<br/>
    sub hash<br/>
    {<br/>
        my ($data) = @_ ;<br/>
        ...<br/>
        # return the hash value for $data<br/>
        return $hash ;<br/>
    }<br/>
<br/>
    sub compare<br/>
    {<br/>
        my ($key, $key2) = @_ ;<br/>
        ...<br/>
        # return  0 if $key1 eq $key2<br/>
        #        -1 if $key1 lt $key2<br/>
        #         1 if $key1 gt $key2<br/>
        return (-1 , 0 or 1) ;<br/>
    }<br/>
<br/>
    sub prefix<br/>
    {<br/>
        my ($key, $key2) = @_ ;<br/>
        ...<br/>
        # return number of bytes of $key2 which are <br/>
        # necessary to determine that it is greater than $key1<br/>
        return $bytes ;<br/>
    }<br/>
<div class="spacer">
</div>
See &quot;Changing the BTREE sort order&quot; for an example of using the &quot;compare&quot; template.<div class="spacer">
</div>
If you are using the DB_RECNO interface and you intend making use of &quot;bval&quot;, you should check out &quot;The 'bval' Option&quot;.</div>
<div class="subsection">
<h2>Default Parameters</h2> It is possible to omit some or all of the final 4 parameters in the call to &quot;tie&quot; and let them take default values. As DB_HASH is the most common file format used, the call:<div class="spacer">
</div>
<br/>
    tie %A, &quot;DB_File&quot;, &quot;filename&quot; ;<br/>
<div class="spacer">
</div>
is equivalent to:<div class="spacer">
</div>
<br/>
    tie %A, &quot;DB_File&quot;, &quot;filename&quot;, O_CREAT|O_RDWR, 0666, $DB_HASH ;<br/>
<div class="spacer">
</div>
It is also possible to omit the filename parameter as well, so the call:<div class="spacer">
</div>
<br/>
    tie %A, &quot;DB_File&quot; ;<br/>
<div class="spacer">
</div>
is equivalent to:<div class="spacer">
</div>
<br/>
    tie %A, &quot;DB_File&quot;, undef, O_CREAT|O_RDWR, 0666, $DB_HASH ;<br/>
<div class="spacer">
</div>
See &quot;In Memory Databases&quot; for a discussion on the use of &quot;undef&quot; in place of a filename.</div>
<div class="subsection">
<h2>In Memory Databases</h2> Berkeley DB allows the creation of in-memory databases by using NULL (that is, a &quot;(char *)0&quot; in C) in place of the filename.   <b>DB_File</b> uses &quot;undef&quot; instead of NULL to provide this functionality.</div>
</div>
<div class="section">
<h1>DB_HASH</h1> The DB_HASH file format is probably the most commonly used of the three file formats that  <b>DB_File</b> supports. It is also very straightforward to use.<div class="subsection">
<h2>A Simple Example</h2> This example shows how to create a database, add key/value pairs to the database, delete keys/value pairs and finally how to enumerate the contents of the database.<div class="spacer">
</div>
<br/>
    use warnings ;<br/>
    use strict ;<br/>
    use DB_File ;<br/>
    our (%h, $k, $v) ;<br/>
<br/>
    unlink &quot;fruit&quot; ;<br/>
    tie %h, &quot;DB_File&quot;, &quot;fruit&quot;, O_RDWR|O_CREAT, 0666, $DB_HASH <br/>
        or die &quot;Cannot open file 'fruit': $!\n&quot;;<br/>
<br/>
    # Add a few key/value pairs to the file<br/>
    $h{&quot;apple&quot;} = &quot;red&quot; ;<br/>
    $h{&quot;orange&quot;} = &quot;orange&quot; ;<br/>
    $h{&quot;banana&quot;} = &quot;yellow&quot; ;<br/>
    $h{&quot;tomato&quot;} = &quot;red&quot; ;<br/>
<br/>
    # Check for existence of a key<br/>
    print &quot;Banana Exists\n\n&quot; if $h{&quot;banana&quot;} ;<br/>
<br/>
    # Delete a key/value pair.<br/>
    delete $h{&quot;apple&quot;} ;<br/>
<br/>
    # print the contents of the file<br/>
    while (($k, $v) = each %h)<br/>
      { print &quot;$k -&gt; $v\n&quot; }<br/>
<br/>
    untie %h ;<br/>
<div class="spacer">
</div>
here is the output:<div class="spacer">
</div>
<br/>
    Banana Exists<br/>
<br/>
    orange -&gt; orange<br/>
    tomato -&gt; red<br/>
    banana -&gt; yellow<br/>
<div class="spacer">
</div>
Note that the like ordinary associative arrays, the order of the keys retrieved is in an apparently random order.</div>
</div>
<div class="section">
<h1>DB_BTREE</h1> The DB_BTREE format is useful when you want to store data in a given order. By default the keys will be stored in lexical order, but as you will see from the example shown in the next section, it is very easy to define your own sorting function.<div class="subsection">
<h2>Changing the BTREE sort order</h2> This script shows how to override the default sorting algorithm that BTREE uses. Instead of using the normal lexical ordering, a case insensitive compare function will be used.<div class="spacer">
</div>
<br/>
    use warnings ;<br/>
    use strict ;<br/>
    use DB_File ;<br/>
<br/>
    my %h ;<br/>
<br/>
    sub Compare<br/>
    {<br/>
        my ($key1, $key2) = @_ ;<br/>
        &quot;\L$key1&quot; cmp &quot;\L$key2&quot; ;<br/>
    }<br/>
<br/>
    # specify the Perl sub that will do the comparison<br/>
    $DB_BTREE-&gt;{'compare'} = \&amp;Compare ;<br/>
<br/>
    unlink &quot;tree&quot; ;<br/>
    tie %h, &quot;DB_File&quot;, &quot;tree&quot;, O_RDWR|O_CREAT, 0666, $DB_BTREE <br/>
        or die &quot;Cannot open file 'tree': $!\n&quot; ;<br/>
<br/>
    # Add a key/value pair to the file<br/>
    $h{'Wall'} = 'Larry' ;<br/>
    $h{'Smith'} = 'John' ;<br/>
    $h{'mouse'} = 'mickey' ;<br/>
    $h{'duck'}  = 'donald' ;<br/>
<br/>
    # Delete<br/>
    delete $h{&quot;duck&quot;} ;<br/>
<br/>
    # Cycle through the keys printing them in order.<br/>
    # Note it is not necessary to sort the keys as<br/>
    # the btree will have kept them in order automatically.<br/>
    foreach (keys %h)<br/>
      { print &quot;$_\n&quot; }<br/>
<br/>
    untie %h ;<br/>
<div class="spacer">
</div>
Here is the output from the code above.<div class="spacer">
</div>
<br/>
    mouse<br/>
    Smith<br/>
    Wall<br/>
<div class="spacer">
</div>
There are a few point to bear in mind if you want to change the ordering in a BTREE database:<dl>
<dt>
1.</dt>
<dd>
The new compare function must be specified when you create the database.</dd>
</dl>
<dl>
<dt>
2.</dt>
<dd>
You cannot change the ordering once the database has been created. Thus you must use the same compare function every time you access the database.</dd>
</dl>
<dl>
<dt>
3.</dt>
<dd>
Duplicate keys are entirely defined by the comparison function. In the case-insensitive example above, the keys: 'KEY' and 'key' would be considered duplicates, and assigning to the second one would overwrite the first. If duplicates are allowed for (with the R_DUP flag discussed below), only a single copy of duplicate keys is stored in the database --- so (again with example above) assigning three values to the keys: 'KEY', 'Key', and 'key' would leave just the first key: 'KEY' in the database with three values. For some situations this results in information loss, so care should be taken to provide fully qualified comparison functions when necessary. For example, the above comparison routine could be modified to additionally compare case-sensitively if two keys are equal in the case insensitive comparison:<div style="height: 1.00em;">
&#160;</div>
<br/>
    sub compare {<br/>
        my($key1, $key2) = @_;<br/>
        lc $key1 cmp lc $key2 ||<br/>
        $key1 cmp $key2;<br/>
    }<br/>
<div style="height: 1.00em;">
&#160;</div>
And now you will only have duplicates when the keys themselves are truly the same. (note: in versions of the db library prior to about November 1996, such duplicate keys were retained so it was possible to recover the original keys in sets of keys that compared as equal).</dd>
</dl>
</div>
<div class="subsection">
<h2>Handling Duplicate Keys</h2> The BTREE file type optionally allows a single key to be associated with an arbitrary number of values. This option is enabled by setting the flags element of $DB_BTREE to R_DUP when creating the database.<div class="spacer">
</div>
There are some difficulties in using the tied hash interface if you want to manipulate a BTREE database with duplicate keys. Consider this code:<div class="spacer">
</div>
<br/>
    use warnings ;<br/>
    use strict ;<br/>
    use DB_File ;<br/>
<br/>
    my ($filename, %h) ;<br/>
<br/>
    $filename = &quot;tree&quot; ;<br/>
    unlink $filename ;<br/>
<br/>
    # Enable duplicate records<br/>
    $DB_BTREE-&gt;{'flags'} = R_DUP ;<br/>
<br/>
    tie %h, &quot;DB_File&quot;, $filename, O_RDWR|O_CREAT, 0666, $DB_BTREE <br/>
        or die &quot;Cannot open $filename: $!\n&quot;;<br/>
<br/>
    # Add some key/value pairs to the file<br/>
    $h{'Wall'} = 'Larry' ;<br/>
    $h{'Wall'} = 'Brick' ; # Note the duplicate key<br/>
    $h{'Wall'} = 'Brick' ; # Note the duplicate key and value<br/>
    $h{'Smith'} = 'John' ;<br/>
    $h{'mouse'} = 'mickey' ;<br/>
<br/>
    # iterate through the associative array<br/>
    # and print each key/value pair.<br/>
    foreach (sort keys %h)<br/>
      { print &quot;$_  -&gt; $h{$_}\n&quot; }<br/>
<br/>
    untie %h ;<br/>
<div class="spacer">
</div>
Here is the output:<div class="spacer">
</div>
<br/>
    Smith   -&gt; John<br/>
    Wall    -&gt; Larry<br/>
    Wall    -&gt; Larry<br/>
    Wall    -&gt; Larry<br/>
    mouse   -&gt; mickey<br/>
<div class="spacer">
</div>
As you can see 3 records have been successfully created with key &quot;Wall&quot; - the only thing is, when they are retrieved from the database they  <i>seem</i> to have the same value, namely &quot;Larry&quot;. The problem is caused by the way that the associative array interface works. Basically, when the associative array interface is used to fetch the value associated with a given key, it will only ever retrieve the first value.<div class="spacer">
</div>
Although it may not be immediately obvious from the code above, the associative array interface can be used to write values with duplicate keys, but it cannot be used to read them back from the database.<div class="spacer">
</div>
The way to get around this problem is to use the Berkeley DB API method called &quot;seq&quot;.  This method allows sequential access to key/value pairs. See &quot;THE API INTERFACE&quot; for details of both the &quot;seq&quot; method and the API in general.<div class="spacer">
</div>
Here is the script above rewritten using the &quot;seq&quot; API method.<div class="spacer">
</div>
<br/>
    use warnings ;<br/>
    use strict ;<br/>
    use DB_File ;<br/>
<br/>
    my ($filename, $x, %h, $status, $key, $value) ;<br/>
<br/>
    $filename = &quot;tree&quot; ;<br/>
    unlink $filename ;<br/>
<br/>
    # Enable duplicate records<br/>
    $DB_BTREE-&gt;{'flags'} = R_DUP ;<br/>
<br/>
    $x = tie %h, &quot;DB_File&quot;, $filename, O_RDWR|O_CREAT, 0666, $DB_BTREE <br/>
        or die &quot;Cannot open $filename: $!\n&quot;;<br/>
<br/>
    # Add some key/value pairs to the file<br/>
    $h{'Wall'} = 'Larry' ;<br/>
    $h{'Wall'} = 'Brick' ; # Note the duplicate key<br/>
    $h{'Wall'} = 'Brick' ; # Note the duplicate key and value<br/>
    $h{'Smith'} = 'John' ;<br/>
    $h{'mouse'} = 'mickey' ;<br/>
<br/>
    # iterate through the btree using seq<br/>
    # and print each key/value pair.<br/>
    $key = $value = 0 ;<br/>
    for ($status = $x-&gt;seq($key, $value, R_FIRST) ;<br/>
         $status == 0 ;<br/>
         $status = $x-&gt;seq($key, $value, R_NEXT) )<br/>
      {  print &quot;$key -&gt; $value\n&quot; }<br/>
<br/>
    undef $x ;<br/>
    untie %h ;<br/>
<div class="spacer">
</div>
that prints:<div class="spacer">
</div>
<br/>
    Smith   -&gt; John<br/>
    Wall    -&gt; Brick<br/>
    Wall    -&gt; Brick<br/>
    Wall    -&gt; Larry<br/>
    mouse   -&gt; mickey<br/>
<div class="spacer">
</div>
This time we have got all the key/value pairs, including the multiple values associated with the key &quot;Wall&quot;.<div class="spacer">
</div>
To make life easier when dealing with duplicate keys, <b>DB_File</b> comes with a few utility methods.</div>
<div class="subsection">
<h2>The <i>get_dup()</i> Method</h2> The &quot;get_dup&quot; method assists in reading duplicate values from BTREE databases. The method can take the following forms:<div class="spacer">
</div>
<br/>
    $count = $x-&gt;get_dup($key) ;<br/>
    @list  = $x-&gt;get_dup($key) ;<br/>
    %list  = $x-&gt;get_dup($key, 1) ;<br/>
<div class="spacer">
</div>
In a scalar context the method returns the number of values associated with the key, $key.<div class="spacer">
</div>
In list context, it returns all the values which match $key. Note that the values will be returned in an apparently random order.<div class="spacer">
</div>
In list context, if the second parameter is present and evaluates TRUE, the method returns an associative array. The keys of the associative array correspond to the values that matched in the BTREE and the values of the array are a count of the number of times that particular value occurred in the BTREE.<div class="spacer">
</div>
So assuming the database created above, we can use &quot;get_dup&quot; like this:<div class="spacer">
</div>
<br/>
    use warnings ;<br/>
    use strict ;<br/>
    use DB_File ;<br/>
<br/>
    my ($filename, $x, %h) ;<br/>
<br/>
    $filename = &quot;tree&quot; ;<br/>
<br/>
    # Enable duplicate records<br/>
    $DB_BTREE-&gt;{'flags'} = R_DUP ;<br/>
<br/>
    $x = tie %h, &quot;DB_File&quot;, $filename, O_RDWR|O_CREAT, 0666, $DB_BTREE <br/>
        or die &quot;Cannot open $filename: $!\n&quot;;<br/>
<br/>
    my $cnt  = $x-&gt;get_dup(&quot;Wall&quot;) ;<br/>
    print &quot;Wall occurred $cnt times\n&quot; ;<br/>
<br/>
    my %hash = $x-&gt;get_dup(&quot;Wall&quot;, 1) ;<br/>
    print &quot;Larry is there\n&quot; if $hash{'Larry'} ;<br/>
    print &quot;There are $hash{'Brick'} Brick Walls\n&quot; ;<br/>
<br/>
    my @list = sort $x-&gt;get_dup(&quot;Wall&quot;) ;<br/>
    print &quot;Wall =&gt;      [@list]\n&quot; ;<br/>
<br/>
    @list = $x-&gt;get_dup(&quot;Smith&quot;) ;<br/>
    print &quot;Smith =&gt;     [@list]\n&quot; ;<br/>
<br/>
    @list = $x-&gt;get_dup(&quot;Dog&quot;) ;<br/>
    print &quot;Dog =&gt;       [@list]\n&quot; ;<br/>
<div class="spacer">
</div>
and it will print:<div class="spacer">
</div>
<br/>
    Wall occurred 3 times<br/>
    Larry is there<br/>
    There are 2 Brick Walls<br/>
    Wall =&gt;     [Brick Brick Larry]<br/>
    Smith =&gt;    [John]<br/>
    Dog =&gt;      []<br/>
</div>
<div class="subsection">
<h2>The <i>find_dup()</i> Method</h2><br/>
    $status = $X-&gt;find_dup($key, $value) ;<br/>
<div class="spacer">
</div>
This method checks for the existence of a specific key/value pair. If the pair exists, the cursor is left pointing to the pair and the method returns 0. Otherwise the method returns a non-zero value.<div class="spacer">
</div>
Assuming the database from the previous example:<div class="spacer">
</div>
<br/>
    use warnings ;<br/>
    use strict ;<br/>
    use DB_File ;<br/>
<br/>
    my ($filename, $x, %h, $found) ;<br/>
<br/>
    $filename = &quot;tree&quot; ;<br/>
<br/>
    # Enable duplicate records<br/>
    $DB_BTREE-&gt;{'flags'} = R_DUP ;<br/>
<br/>
    $x = tie %h, &quot;DB_File&quot;, $filename, O_RDWR|O_CREAT, 0666, $DB_BTREE <br/>
        or die &quot;Cannot open $filename: $!\n&quot;;<br/>
<br/>
    $found = ( $x-&gt;find_dup(&quot;Wall&quot;, &quot;Larry&quot;) == 0 ? &quot;&quot; : &quot;not&quot;) ; <br/>
    print &quot;Larry Wall is $found there\n&quot; ;<br/>
<br/>
    $found = ( $x-&gt;find_dup(&quot;Wall&quot;, &quot;Harry&quot;) == 0 ? &quot;&quot; : &quot;not&quot;) ; <br/>
    print &quot;Harry Wall is $found there\n&quot; ;<br/>
<br/>
    undef $x ;<br/>
    untie %h ;<br/>
<div class="spacer">
</div>
prints this<div class="spacer">
</div>
<br/>
    Larry Wall is  there<br/>
    Harry Wall is not there<br/>
</div>
<div class="subsection">
<h2>The <i>del_dup()</i> Method</h2><br/>
    $status = $X-&gt;del_dup($key, $value) ;<br/>
<div class="spacer">
</div>
This method deletes a specific key/value pair. It returns 0 if they exist and have been deleted successfully. Otherwise the method returns a non-zero value.<div class="spacer">
</div>
Again assuming the existence of the &quot;tree&quot; database<div class="spacer">
</div>
<br/>
    use warnings ;<br/>
    use strict ;<br/>
    use DB_File ;<br/>
<br/>
    my ($filename, $x, %h, $found) ;<br/>
<br/>
    $filename = &quot;tree&quot; ;<br/>
<br/>
    # Enable duplicate records<br/>
    $DB_BTREE-&gt;{'flags'} = R_DUP ;<br/>
<br/>
    $x = tie %h, &quot;DB_File&quot;, $filename, O_RDWR|O_CREAT, 0666, $DB_BTREE <br/>
        or die &quot;Cannot open $filename: $!\n&quot;;<br/>
<br/>
    $x-&gt;del_dup(&quot;Wall&quot;, &quot;Larry&quot;) ;<br/>
<br/>
    $found = ( $x-&gt;find_dup(&quot;Wall&quot;, &quot;Larry&quot;) == 0 ? &quot;&quot; : &quot;not&quot;) ; <br/>
    print &quot;Larry Wall is $found there\n&quot; ;<br/>
<br/>
    undef $x ;<br/>
    untie %h ;<br/>
<div class="spacer">
</div>
prints this<div class="spacer">
</div>
<br/>
    Larry Wall is not there<br/>
</div>
<div class="subsection">
<h2>Matching Partial Keys</h2> The BTREE interface has a feature which allows partial keys to be matched. This functionality is  <i>only</i> available when the &quot;seq&quot; method is used along with the R_CURSOR flag.<div class="spacer">
</div>
<br/>
    $x-&gt;seq($key, $value, R_CURSOR) ;<br/>
<div class="spacer">
</div>
Here is the relevant quote from the dbopen man page where it defines the use of the R_CURSOR flag with seq:<div class="spacer">
</div>
<br/>
    Note, for the DB_BTREE access method, the returned key is not<br/>
    necessarily an exact match for the specified key. The returned key<br/>
    is the smallest key greater than or equal to the specified key,<br/>
    permitting partial key matches and range searches.<br/>
<div class="spacer">
</div>
In the example script below, the &quot;match&quot; sub uses this feature to find and print the first matching key/value pair given a partial key.<div class="spacer">
</div>
<br/>
    use warnings ;<br/>
    use strict ;<br/>
    use DB_File ;<br/>
    use Fcntl ;<br/>
<br/>
    my ($filename, $x, %h, $st, $key, $value) ;<br/>
<br/>
    sub match<br/>
    {<br/>
        my $key = shift ;<br/>
        my $value = 0;<br/>
        my $orig_key = $key ;<br/>
        $x-&gt;seq($key, $value, R_CURSOR) ;<br/>
        print &quot;$orig_key\t-&gt; $key\t-&gt; $value\n&quot; ;<br/>
    }<br/>
<br/>
    $filename = &quot;tree&quot; ;<br/>
    unlink $filename ;<br/>
<br/>
    $x = tie %h, &quot;DB_File&quot;, $filename, O_RDWR|O_CREAT, 0666, $DB_BTREE<br/>
        or die &quot;Cannot open $filename: $!\n&quot;;<br/>
<br/>
    # Add some key/value pairs to the file<br/>
    $h{'mouse'} = 'mickey' ;<br/>
    $h{'Wall'} = 'Larry' ;<br/>
    $h{'Walls'} = 'Brick' ; <br/>
    $h{'Smith'} = 'John' ;<br/>
<br/>
<br/>
    $key = $value = 0 ;<br/>
    print &quot;IN ORDER\n&quot; ;<br/>
    for ($st = $x-&gt;seq($key, $value, R_FIRST) ;<br/>
         $st == 0 ;<br/>
         $st = $x-&gt;seq($key, $value, R_NEXT) )<br/>
<br/>
      {  print &quot;$key    -&gt; $value\n&quot; }<br/>
<br/>
    print &quot;\nPARTIAL MATCH\n&quot; ;<br/>
<br/>
    match &quot;Wa&quot; ;<br/>
    match &quot;A&quot; ;<br/>
    match &quot;a&quot; ;<br/>
<br/>
    undef $x ;<br/>
    untie %h ;<br/>
<div class="spacer">
</div>
Here is the output:<div class="spacer">
</div>
<br/>
    IN ORDER<br/>
    Smith -&gt; John<br/>
    Wall  -&gt; Larry<br/>
    Walls -&gt; Brick<br/>
    mouse -&gt; mickey<br/>
<br/>
    PARTIAL MATCH<br/>
    Wa -&gt; Wall  -&gt; Larry<br/>
    A  -&gt; Smith -&gt; John<br/>
    a  -&gt; mouse -&gt; mickey<br/>
</div>
</div>
<div class="section">
<h1>DB_RECNO</h1> DB_RECNO provides an interface to flat text files. Both variable and fixed length records are supported.<div class="spacer">
</div>
In order to make RECNO more compatible with Perl, the array offset for all RECNO arrays begins at 0 rather than 1 as in Berkeley DB.<div class="spacer">
</div>
As with normal Perl arrays, a RECNO array can be accessed using negative indexes. The index -1 refers to the last element of the array, -2 the second last, and so on. Attempting to access an element before the start of the array will raise a fatal run-time error.<div class="subsection">
<h2>The 'bval' Option</h2> The operation of the bval option warrants some discussion. Here is the definition of bval from the Berkeley DB 1.85 recno manual page:<div class="spacer">
</div>
<br/>
    The delimiting byte to be used to mark  the  end  of  a<br/>
    record for variable-length records, and the pad charac-<br/>
    ter for fixed-length records.  If no  value  is  speci-<br/>
    fied,  newlines  (``\n'')  are  used to mark the end of<br/>
    variable-length records and  fixed-length  records  are<br/>
    padded with spaces.<br/>
<div class="spacer">
</div>
The second sentence is wrong. In actual fact bval will only default to &quot;\n&quot; when the openinfo parameter in dbopen is NULL. If a non-NULL openinfo parameter is used at all, the value that happens to be in bval will be used. That means you always have to specify bval when making use of any of the options in the openinfo parameter. This documentation error will be fixed in the next release of Berkeley DB.<div class="spacer">
</div>
That clarifies the situation with regards Berkeley DB itself. What about  <b>DB_File</b>? Well, the behavior defined in the quote above is quite useful, so  <b>DB_File</b> conforms to it.<div class="spacer">
</div>
That means that you can specify other options (e.g. cachesize) and still have bval default to &quot;\n&quot; for variable length records, and space for fixed length records.<div class="spacer">
</div>
Also note that the bval option only allows you to specify a single byte as a delimiter.</div>
<div class="subsection">
<h2>A Simple Example</h2> Here is a simple example that uses RECNO (if you are using a version of Perl earlier than 5.004_57 this example won't work -- see &quot;Extra RECNO Methods&quot; for a workaround).<div class="spacer">
</div>
<br/>
    use warnings ;<br/>
    use strict ;<br/>
    use DB_File ;<br/>
<br/>
    my $filename = &quot;text&quot; ;<br/>
    unlink $filename ;<br/>
<br/>
    my @h ;<br/>
    tie @h, &quot;DB_File&quot;, $filename, O_RDWR|O_CREAT, 0666, $DB_RECNO <br/>
        or die &quot;Cannot open file 'text': $!\n&quot; ;<br/>
<br/>
    # Add a few key/value pairs to the file<br/>
    $h[0] = &quot;orange&quot; ;<br/>
    $h[1] = &quot;blue&quot; ;<br/>
    $h[2] = &quot;yellow&quot; ;<br/>
<br/>
    push @h, &quot;green&quot;, &quot;black&quot; ;<br/>
<br/>
    my $elements = scalar @h ;<br/>
    print &quot;The array contains $elements entries\n&quot; ;<br/>
<br/>
    my $last = pop @h ;<br/>
    print &quot;popped $last\n&quot; ;<br/>
<br/>
    unshift @h, &quot;white&quot; ;<br/>
    my $first = shift @h ;<br/>
    print &quot;shifted $first\n&quot; ;<br/>
<br/>
    # Check for existence of a key<br/>
    print &quot;Element 1 Exists with value $h[1]\n&quot; if $h[1] ;<br/>
<br/>
    # use a negative index<br/>
    print &quot;The last element is $h[-1]\n&quot; ;<br/>
    print &quot;The 2nd last element is $h[-2]\n&quot; ;<br/>
<br/>
    untie @h ;<br/>
<div class="spacer">
</div>
Here is the output from the script:<div class="spacer">
</div>
<br/>
    The array contains 5 entries<br/>
    popped black<br/>
    shifted white<br/>
    Element 1 Exists with value blue<br/>
    The last element is green<br/>
    The 2nd last element is yellow<br/>
</div>
<div class="subsection">
<h2>Extra RECNO Methods</h2> If you are using a version of Perl earlier than 5.004_57, the tied array interface is quite limited. In the example script above &quot;push&quot;, &quot;pop&quot;, &quot;shift&quot;, &quot;unshift&quot; or determining the array length will not work with a tied array.<div class="spacer">
</div>
To make the interface more useful for older versions of Perl, a number of methods are supplied with  <b>DB_File</b> to simulate the missing array operations. All these methods are accessed via the object returned from the tie call.<div class="spacer">
</div>
Here are the methods:<dl>
<dt>
<b></b><b>$X</b><b>-&gt;push(list) ;</b></dt>
<dd>
Pushes the elements of &quot;list&quot; to the end of the array.</dd>
</dl>
<dl>
<dt>
<b></b><b>$value</b><b> = </b><b><i>$X</i></b><b>-&gt;pop ;</b></dt>
<dd>
Removes and returns the last element of the array.</dd>
</dl>
<dl>
<dt>
<b></b><b>$X</b><b>-&gt;shift</b></dt>
<dd>
Removes and returns the first element of the array.</dd>
</dl>
<dl>
<dt>
<b></b><b>$X</b><b>-&gt;unshift(list) ;</b></dt>
<dd>
Pushes the elements of &quot;list&quot; to the start of the array.</dd>
</dl>
<dl>
<dt>
<b></b><b>$X</b><b>-&gt;length</b></dt>
<dd>
Returns the number of elements in the array.</dd>
</dl>
<dl>
<dt>
<b></b><b>$X</b><b>-&gt;splice(offset, length, elements);</b></dt>
<dd>
Returns a splice of the array.</dd>
</dl>
</div>
<div class="subsection">
<h2>Another Example</h2> Here is a more complete example that makes use of some of the methods described above. It also makes use of the API interface directly (see &quot;THE API INTERFACE&quot;).<div class="spacer">
</div>
<br/>
    use warnings ;<br/>
    use strict ;<br/>
    my (@h, $H, $file, $i) ;<br/>
    use DB_File ;<br/>
    use Fcntl ;<br/>
<br/>
    $file = &quot;text&quot; ;<br/>
<br/>
    unlink $file ;<br/>
<br/>
    $H = tie @h, &quot;DB_File&quot;, $file, O_RDWR|O_CREAT, 0666, $DB_RECNO <br/>
        or die &quot;Cannot open file $file: $!\n&quot; ;<br/>
<br/>
    # first create a text file to play with<br/>
    $h[0] = &quot;zero&quot; ;<br/>
    $h[1] = &quot;one&quot; ;<br/>
    $h[2] = &quot;two&quot; ;<br/>
    $h[3] = &quot;three&quot; ;<br/>
    $h[4] = &quot;four&quot; ;<br/>
<br/>
<br/>
    # Print the records in order.<br/>
    #<br/>
    # The length method is needed here because evaluating a tied<br/>
    # array in a scalar context does not return the number of<br/>
    # elements in the array.  <br/>
<br/>
    print &quot;\nORIGINAL\n&quot; ;<br/>
    foreach $i (0 .. $H-&gt;length - 1) {<br/>
        print &quot;$i: $h[$i]\n&quot; ;<br/>
    }<br/>
<br/>
    # use the push &amp; pop methods<br/>
    $a = $H-&gt;pop ;<br/>
    $H-&gt;push(&quot;last&quot;) ;<br/>
    print &quot;\nThe last record was [$a]\n&quot; ;<br/>
<br/>
    # and the shift &amp; unshift methods<br/>
    $a = $H-&gt;shift ;<br/>
    $H-&gt;unshift(&quot;first&quot;) ;<br/>
    print &quot;The first record was [$a]\n&quot; ;<br/>
<br/>
    # Use the API to add a new record after record 2.<br/>
    $i = 2 ;<br/>
    $H-&gt;put($i, &quot;Newbie&quot;, R_IAFTER) ;<br/>
<br/>
    # and a new record before record 1.<br/>
    $i = 1 ;<br/>
    $H-&gt;put($i, &quot;New One&quot;, R_IBEFORE) ;<br/>
<br/>
    # delete record 3<br/>
    $H-&gt;del(3) ;<br/>
<br/>
    # now print the records in reverse order<br/>
    print &quot;\nREVERSE\n&quot; ;<br/>
    for ($i = $H-&gt;length - 1 ; $i &gt;= 0 ; -- $i)<br/>
      { print &quot;$i: $h[$i]\n&quot; }<br/>
<br/>
    # same again, but use the API functions instead<br/>
    print &quot;\nREVERSE again\n&quot; ;<br/>
    my ($s, $k, $v)  = (0, 0, 0) ;<br/>
    for ($s = $H-&gt;seq($k, $v, R_LAST) ; <br/>
             $s == 0 ; <br/>
             $s = $H-&gt;seq($k, $v, R_PREV))<br/>
      { print &quot;$k: $v\n&quot; }<br/>
<br/>
    undef $H ;<br/>
    untie @h ;<br/>
<div class="spacer">
</div>
and this is what it outputs:<div class="spacer">
</div>
<br/>
    ORIGINAL<br/>
    0: zero<br/>
    1: one<br/>
    2: two<br/>
    3: three<br/>
    4: four<br/>
<br/>
    The last record was [four]<br/>
    The first record was [zero]<br/>
<br/>
    REVERSE<br/>
    5: last<br/>
    4: three<br/>
    3: Newbie<br/>
    2: one<br/>
    1: New One<br/>
    0: first<br/>
<br/>
    REVERSE again<br/>
    5: last<br/>
    4: three<br/>
    3: Newbie<br/>
    2: one<br/>
    1: New One<br/>
    0: first<br/>
<div class="spacer">
</div>
Notes:<dl>
<dt>
1.</dt>
<dd>
Rather than iterating through the array, @h like this:<div style="height: 1.00em;">
&#160;</div>
<br/>
    foreach $i (@h)<br/>
<div style="height: 1.00em;">
&#160;</div>
it is necessary to use either this:<div style="height: 1.00em;">
&#160;</div>
<br/>
    foreach $i (0 .. $H-&gt;length - 1)<br/>
<div style="height: 1.00em;">
&#160;</div>
or this:<div style="height: 1.00em;">
&#160;</div>
<br/>
    for ($a = $H-&gt;get($k, $v, R_FIRST) ;<br/>
         $a == 0 ;<br/>
         $a = $H-&gt;get($k, $v, R_NEXT) )<br/>
</dd>
</dl>
<dl>
<dt>
2.</dt>
<dd>
Notice that both times the &quot;put&quot; method was used the record index was specified using a variable, $i, rather than the literal value itself. This is because &quot;put&quot; will return the record number of the inserted line via that parameter.</dd>
</dl>
</div>
</div>
<div class="section">
<h1>THE API INTERFACE</h1> As well as accessing Berkeley DB using a tied hash or array, it is also possible to make direct use of most of the API functions defined in the Berkeley DB documentation.<div class="spacer">
</div>
To do this you need to store a copy of the object returned from the tie.<div class="spacer">
</div>
<br/>
        $db = tie %hash, &quot;DB_File&quot;, &quot;filename&quot; ;<br/>
<div class="spacer">
</div>
Once you have done that, you can access the Berkeley DB API functions as  <b>DB_File</b> methods directly like this:<div class="spacer">
</div>
<br/>
        $db-&gt;put($key, $value, R_NOOVERWRITE) ;<br/>
<div class="spacer">
</div>
<b>Important:</b> If you have saved a copy of the object returned from &quot;tie&quot;, the underlying database file will  <i>not</i> be closed until both the tied variable is untied and all copies of the saved object are destroyed.<div class="spacer">
</div>
<br/>
    use DB_File ;<br/>
    $db = tie %hash, &quot;DB_File&quot;, &quot;filename&quot; <br/>
        or die &quot;Cannot tie filename: $!&quot; ;<br/>
    ...<br/>
    undef $db ;<br/>
    untie %hash ;<br/>
<div class="spacer">
</div>
See &quot;The <i>untie()</i> Gotcha&quot; for more details.<div class="spacer">
</div>
All the functions defined in dbopen are available except for  <i>close()</i> and <i>dbopen()</i> itself. The <b>DB_File</b> method interface to the supported functions have been implemented to mirror the way Berkeley DB works whenever possible. In particular note that:<dl>
<dt>
&#8226;</dt>
<dd>
The methods return a status value. All return 0 on success. All return -1 to signify an error and set $! to the exact error code. The return code 1 generally (but not always) means that the key specified did not exist in the database.<div style="height: 1.00em;">
&#160;</div>
Other return codes are defined. See below and in the Berkeley DB documentation for details. The Berkeley DB documentation should be used as the definitive source.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Whenever a Berkeley DB function returns data via one of its parameters, the equivalent  <b>DB_File</b> method does exactly the same.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
If you are careful, it is possible to mix API calls with the tied hash/array interface in the same piece of code. Although only a few of the methods used to implement the tied interface currently make use of the cursor, you should always assume that the cursor has been changed any time the tied hash/array interface is used. As an example, this code will probably not do what you expect:<div style="height: 1.00em;">
&#160;</div>
<br/>
    $X = tie %x, 'DB_File', $filename, O_RDWR|O_CREAT, 0777, $DB_BTREE<br/>
        or die &quot;Cannot tie $filename: $!&quot; ;<br/>
<br/>
    # Get the first key/value pair and set  the cursor<br/>
    $X-&gt;seq($key, $value, R_FIRST) ;<br/>
<br/>
    # this line will modify the cursor<br/>
    $count = scalar keys %x ; <br/>
<br/>
    # Get the second key/value pair.<br/>
    # oops, it didn't, it got the last key/value pair!<br/>
    $X-&gt;seq($key, $value, R_NEXT) ;<br/>
<div style="height: 1.00em;">
&#160;</div>
The code above can be rearranged to get around the problem, like this:<div style="height: 1.00em;">
&#160;</div>
<br/>
    $X = tie %x, 'DB_File', $filename, O_RDWR|O_CREAT, 0777, $DB_BTREE<br/>
        or die &quot;Cannot tie $filename: $!&quot; ;<br/>
<br/>
    # this line will modify the cursor<br/>
    $count = scalar keys %x ; <br/>
<br/>
    # Get the first key/value pair and set  the cursor<br/>
    $X-&gt;seq($key, $value, R_FIRST) ;<br/>
<br/>
    # Get the second key/value pair.<br/>
    # worked this time.<br/>
    $X-&gt;seq($key, $value, R_NEXT) ;<br/>
</dd>
</dl>
<div class="spacer">
</div>
All the constants defined in dbopen for use in the flags parameters in the methods defined below are also available. Refer to the Berkeley DB documentation for the precise meaning of the flags values.<div class="spacer">
</div>
Below is a list of the methods available.<dl>
<dt>
<b></b><b>$status</b><b> = </b><b><i>$X</i></b><b>-&gt;get($key, </b><b>$value</b><b> [, </b><b>$flags</b><b>]) ;</b></dt>
<dd>
Given a key ($key) this method reads the value associated with it from the database. The value read from the database is returned in the $value parameter.<div style="height: 1.00em;">
&#160;</div>
If the key does not exist the method returns 1.<div style="height: 1.00em;">
&#160;</div>
No flags are currently defined for this method.</dd>
</dl>
<dl>
<dt>
<b></b><b>$status</b><b> = </b><b><i>$X</i></b><b>-&gt;put($key, </b><b>$value</b><b> [, </b><b>$flags</b><b>]) ;</b></dt>
<dd>
Stores the key/value pair in the database.<div style="height: 1.00em;">
&#160;</div>
If you use either the R_IAFTER or R_IBEFORE flags, the $key parameter will have the record number of the inserted key/value pair set.<div style="height: 1.00em;">
&#160;</div>
Valid flags are R_CURSOR, R_IAFTER, R_IBEFORE, R_NOOVERWRITE and R_SETCURSOR.</dd>
</dl>
<dl>
<dt>
<b></b><b>$status</b><b> = </b><b><i>$X</i></b><b>-&gt;del($key [, </b><b>$flags</b><b>]) ;</b></dt>
<dd>
Removes all key/value pairs with key $key from the database.<div style="height: 1.00em;">
&#160;</div>
A return code of 1 means that the requested key was not in the database.<div style="height: 1.00em;">
&#160;</div>
R_CURSOR is the only valid flag at present.</dd>
</dl>
<dl>
<dt>
<b></b><b>$status</b><b> = </b><b><i>$X</i></b><b>-&gt;fd ;</b></dt>
<dd>
Returns the file descriptor for the underlying database.<div style="height: 1.00em;">
&#160;</div>
See &quot;Locking: The Trouble with fd&quot; for an explanation for why you should not use &quot;fd&quot; to lock your database.</dd>
</dl>
<dl>
<dt>
<b></b><b>$status</b><b> = </b><b><i>$X</i></b><b>-&gt;seq($key, </b><b>$value</b><b>, </b><b>$flags</b><b>) ;</b></dt>
<dd>
This interface allows sequential retrieval from the database. See dbopen for full details.<div style="height: 1.00em;">
&#160;</div>
Both the $key and $value parameters will be set to the key/value pair read from the database.<div style="height: 1.00em;">
&#160;</div>
The flags parameter is mandatory. The valid flag values are R_CURSOR, R_FIRST, R_LAST, R_NEXT and R_PREV.</dd>
</dl>
<dl>
<dt>
<b></b><b>$status</b><b> = </b><b><i>$X</i></b><b>-&gt;sync([$flags]) ;</b></dt>
<dd>
Flushes any cached buffers to disk.<div style="height: 1.00em;">
&#160;</div>
R_RECNOSYNC is the only valid flag at present.</dd>
</dl>
</div>
<div class="section">
<h1>DBM FILTERS</h1> A DBM Filter is a piece of code that is be used when you  <i>always</i> want to make the same transformation to all keys and/or values in a DBM database.<div class="spacer">
</div>
There are four methods associated with DBM Filters. All work identically, and each is used to install (or uninstall) a single DBM Filter. Each expects a single parameter, namely a reference to a sub. The only difference between them is the place that the filter is installed.<div class="spacer">
</div>
To summarise:<dl>
<dt>
<b>filter_store_key</b></dt>
<dd>
If a filter has been installed with this method, it will be invoked every time you write a key to a DBM database.</dd>
</dl>
<dl>
<dt>
<b>filter_store_value</b></dt>
<dd>
If a filter has been installed with this method, it will be invoked every time you write a value to a DBM database.</dd>
</dl>
<dl>
<dt>
<b>filter_fetch_key</b></dt>
<dd>
If a filter has been installed with this method, it will be invoked every time you read a key from a DBM database.</dd>
</dl>
<dl>
<dt>
<b>filter_fetch_value</b></dt>
<dd>
If a filter has been installed with this method, it will be invoked every time you read a value from a DBM database.</dd>
</dl>
<div class="spacer">
</div>
You can use any combination of the methods, from none, to all four.<div class="spacer">
</div>
All filter methods return the existing filter, if present, or &quot;undef&quot; in not.<div class="spacer">
</div>
To delete a filter pass &quot;undef&quot; to it.<div class="subsection">
<h2>The Filter</h2> When each filter is called by Perl, a local copy of $_ will contain the key or value to be filtered. Filtering is achieved by modifying the contents of $_. The return code from the filter is ignored.</div>
<div class="subsection">
<h2>An Example -- the NULL termination problem.</h2> Consider the following scenario. You have a DBM database that you need to share with a third-party C application. The C application assumes that  <i>all</i> keys and values are NULL terminated. Unfortunately when Perl writes to DBM databases it doesn't use NULL termination, so your Perl application will have to manage NULL termination itself. When you write to the database you will have to use something like this:<div class="spacer">
</div>
<br/>
    $hash{&quot;$key\0&quot;} = &quot;$value\0&quot; ;<br/>
<div class="spacer">
</div>
Similarly the NULL needs to be taken into account when you are considering the length of existing keys/values.<div class="spacer">
</div>
It would be much better if you could ignore the NULL terminations issue in the main application code and have a mechanism that automatically added the terminating NULL to all keys and values whenever you write to the database and have them removed when you read from the database. As I'm sure you have already guessed, this is a problem that DBM Filters can fix very easily.<div class="spacer">
</div>
<br/>
    use warnings ;<br/>
    use strict ;<br/>
    use DB_File ;<br/>
<br/>
    my %hash ;<br/>
    my $filename = &quot;filt&quot; ;<br/>
    unlink $filename ;<br/>
<br/>
    my $db = tie %hash, 'DB_File', $filename, O_CREAT|O_RDWR, 0666, $DB_HASH <br/>
      or die &quot;Cannot open $filename: $!\n&quot; ;<br/>
<br/>
    # Install DBM Filters<br/>
    $db-&gt;filter_fetch_key  ( sub { s/\0$//    } ) ;<br/>
    $db-&gt;filter_store_key  ( sub { $_ .= &quot;\0&quot; } ) ;<br/>
    $db-&gt;filter_fetch_value( sub { s/\0$//    } ) ;<br/>
    $db-&gt;filter_store_value( sub { $_ .= &quot;\0&quot; } ) ;<br/>
<br/>
    $hash{&quot;abc&quot;} = &quot;def&quot; ;<br/>
    my $a = $hash{&quot;ABC&quot;} ;<br/>
    # ...<br/>
    undef $db ;<br/>
    untie %hash ;<br/>
<div class="spacer">
</div>
Hopefully the contents of each of the filters should be self-explanatory. Both &quot;fetch&quot; filters remove the terminating NULL, and both &quot;store&quot; filters add a terminating NULL.</div>
<div class="subsection">
<h2>Another Example -- Key is a C int.</h2> Here is another real-life example. By default, whenever Perl writes to a DBM database it always writes the key and value as strings. So when you use this:<div class="spacer">
</div>
<br/>
    $hash{12345} = &quot;something&quot; ;<br/>
<div class="spacer">
</div>
the key 12345 will get stored in the DBM database as the 5 byte string &quot;12345&quot;. If you actually want the key to be stored in the DBM database as a C int, you will have to use &quot;pack&quot; when writing, and &quot;unpack&quot; when reading.<div class="spacer">
</div>
Here is a DBM Filter that does it:<div class="spacer">
</div>
<br/>
    use warnings ;<br/>
    use strict ;<br/>
    use DB_File ;<br/>
    my %hash ;<br/>
    my $filename = &quot;filt&quot; ;<br/>
    unlink $filename ;<br/>
<br/>
<br/>
    my $db = tie %hash, 'DB_File', $filename, O_CREAT|O_RDWR, 0666, $DB_HASH <br/>
      or die &quot;Cannot open $filename: $!\n&quot; ;<br/>
<br/>
    $db-&gt;filter_fetch_key  ( sub { $_ = unpack(&quot;i&quot;, $_) } ) ;<br/>
    $db-&gt;filter_store_key  ( sub { $_ = pack (&quot;i&quot;, $_) } ) ;<br/>
    $hash{123} = &quot;def&quot; ;<br/>
    # ...<br/>
    undef $db ;<br/>
    untie %hash ;<br/>
<div class="spacer">
</div>
This time only two filters have been used -- we only need to manipulate the contents of the key, so it wasn't necessary to install any value filters.</div>
</div>
<div class="section">
<h1>HINTS AND TIPS</h1><div class="subsection">
<h2>Locking: The Trouble with fd</h2> Until version 1.72 of this module, the recommended technique for locking  <b>DB_File</b> databases was to flock the filehandle returned from the &quot;fd&quot; function. Unfortunately this technique has been shown to be fundamentally flawed (Kudos to David Harris for tracking this down). Use it at your own peril!<div class="spacer">
</div>
The locking technique went like this.<div class="spacer">
</div>
<br/>
    $db = tie(%db, 'DB_File', 'foo.db', O_CREAT|O_RDWR, 0644)<br/>
        || die &quot;dbcreat foo.db $!&quot;;<br/>
    $fd = $db-&gt;fd;<br/>
    open(DB_FH, &quot;+&lt;&amp;=$fd&quot;) || die &quot;dup $!&quot;;<br/>
    flock (DB_FH, LOCK_EX) || die &quot;flock: $!&quot;;<br/>
    ...<br/>
    $db{&quot;Tom&quot;} = &quot;Jerry&quot; ;<br/>
    ...<br/>
    flock(DB_FH, LOCK_UN);<br/>
    undef $db;<br/>
    untie %db;<br/>
    close(DB_FH);<br/>
<div class="spacer">
</div>
In simple terms, this is what happens:<dl>
<dt>
1.</dt>
<dd>
Use &quot;tie&quot; to open the database.</dd>
</dl>
<dl>
<dt>
2.</dt>
<dd>
Lock the database with fd &amp; flock.</dd>
</dl>
<dl>
<dt>
3.</dt>
<dd>
Read &amp; Write to the database.</dd>
</dl>
<dl>
<dt>
4.</dt>
<dd>
Unlock and close the database.</dd>
</dl>
<div class="spacer">
</div>
Here is the crux of the problem. A side-effect of opening the <b>DB_File</b> database in step 2 is that an initial block from the database will get read from disk and cached in memory.<div class="spacer">
</div>
To see why this is a problem, consider what can happen when two processes, say &quot;A&quot; and &quot;B&quot;, both want to update the same  <b>DB_File</b> database using the locking steps outlined above. Assume process &quot;A&quot; has already opened the database and has a write lock, but it hasn't actually updated the database yet (it has finished step 2, but not started step 3 yet). Now process &quot;B&quot; tries to open the same database - step 1 will succeed, but it will block on step 2 until process &quot;A&quot; releases the lock. The important thing to notice here is that at this point in time both processes will have cached identical initial blocks from the database.<div class="spacer">
</div>
Now process &quot;A&quot; updates the database and happens to change some of the data held in the initial buffer. Process &quot;A&quot; terminates, flushing all cached data to disk and releasing the database lock. At this point the database on disk will correctly reflect the changes made by process &quot;A&quot;.<div class="spacer">
</div>
With the lock released, process &quot;B&quot; can now continue. It also updates the database and unfortunately it too modifies the data that was in its initial buffer. Once that data gets flushed to disk it will overwrite some/all of the changes process &quot;A&quot; made to the database.<div class="spacer">
</div>
The result of this scenario is at best a database that doesn't contain what you expect. At worst the database will corrupt.<div class="spacer">
</div>
The above won't happen every time competing process update the same  <b>DB_File</b> database, but it does illustrate why the technique should not be used.</div>
<div class="subsection">
<h2>Safe ways to lock a database</h2> Starting with version 2.x, Berkeley DB  has internal support for locking. The companion module to this one,  <b>BerkeleyDB</b>, provides an interface to this locking functionality. If you are serious about locking Berkeley DB databases, I strongly recommend using  <b>BerkeleyDB</b>.<div class="spacer">
</div>
If using <b>BerkeleyDB</b> isn't an option, there are a number of modules available on CPAN that can be used to implement locking. Each one implements locking differently and has different goals in mind. It is therefore worth knowing the difference, so that you can pick the right one for your application. Here are the three locking wrappers:<dl>
<dt>
<b>Tie::DB_Lock</b></dt>
<dd>
A <b>DB_File</b> wrapper which creates copies of the database file for read access, so that you have a kind of a multiversioning concurrent read system. However, updates are still serial. Use for databases where reads may be lengthy and consistency problems may occur.</dd>
</dl>
<dl>
<dt>
<b>Tie::DB_LockFile</b></dt>
<dd>
A <b>DB_File</b> wrapper that has the ability to lock and unlock the database while it is being used. Avoids the tie-before-flock problem by simply re-tie-ing the database when you get or drop a lock.  Because of the flexibility in dropping and re-acquiring the lock in the middle of a session, this can be massaged into a system that will work with long updates and/or reads if the application follows the hints in the POD documentation.</dd>
</dl>
<dl>
<dt>
<b>DB_File::Lock</b></dt>
<dd>
An extremely lightweight <b>DB_File</b> wrapper that simply flocks a lockfile before tie-ing the database and drops the lock after the untie. Allows one to use the same lockfile for multiple databases to avoid deadlock problems, if desired. Use for databases where updates are reads are quick and simple flock locking semantics are enough.</dd>
</dl>
</div>
<div class="subsection">
<h2>Sharing Databases With C Applications</h2> There is no technical reason why a Berkeley DB database cannot be shared by both a Perl and a C application.<div class="spacer">
</div>
The vast majority of problems that are reported in this area boil down to the fact that C strings are NULL terminated, whilst Perl strings are not. See &quot;DBM FILTERS&quot; for a generic way to work around this problem.<div class="spacer">
</div>
Here is a real example. Netscape 2.0 keeps a record of the locations you visit along with the time you last visited them in a DB_HASH database. This is usually stored in the file  <i>~/.netscape/history.db</i>. The key field in the database is the location string and the value field is the time the location was last visited stored as a 4 byte binary value.<div class="spacer">
</div>
If you haven't already guessed, the location string is stored with a terminating NULL. This means you need to be careful when accessing the database.<div class="spacer">
</div>
Here is a snippet of code that is loosely based on Tom Christiansen's  <i>ggh</i> script (available from your nearest CPAN archive in  <i>authors/id/TOMC/scripts/nshist.gz</i>).<div class="spacer">
</div>
<br/>
    use warnings ;<br/>
    use strict ;<br/>
    use DB_File ;<br/>
    use Fcntl ;<br/>
<br/>
    my ($dotdir, $HISTORY, %hist_db, $href, $binary_time, $date) ;<br/>
    $dotdir = $ENV{HOME} || $ENV{LOGNAME};<br/>
<br/>
    $HISTORY = &quot;$dotdir/.netscape/history.db&quot;;<br/>
<br/>
    tie %hist_db, 'DB_File', $HISTORY<br/>
        or die &quot;Cannot open $HISTORY: $!\n&quot; ;;<br/>
<br/>
    # Dump the complete database<br/>
    while ( ($href, $binary_time) = each %hist_db ) {<br/>
<br/>
        # remove the terminating NULL<br/>
        $href =~ s/\x00$// ;<br/>
<br/>
        # convert the binary time into a user friendly string<br/>
        $date = localtime unpack(&quot;V&quot;, $binary_time);<br/>
        print &quot;$date $href\n&quot; ;<br/>
    }<br/>
<br/>
    # check for the existence of a specific key<br/>
    # remember to add the NULL<br/>
    if ( $binary_time = $hist_db{&quot;http://mox.perl.com/\x00&quot;} ) {<br/>
        $date = localtime unpack(&quot;V&quot;, $binary_time) ;<br/>
        print &quot;Last visited mox.perl.com on $date\n&quot; ;<br/>
    }<br/>
    else {<br/>
        print &quot;Never visited mox.perl.com\n&quot;<br/>
    }<br/>
<br/>
    untie %hist_db ;<br/>
</div>
<div class="subsection">
<h2>The <i>untie()</i> Gotcha</h2> If you make use of the Berkeley DB API, it is  <i>very</i> strongly recommended that you read &quot;The untie Gotcha&quot; in perltie.<div class="spacer">
</div>
Even if you don't currently make use of the API interface, it is still worth reading it.<div class="spacer">
</div>
Here is an example which illustrates the problem from a <b>DB_File</b> perspective:<div class="spacer">
</div>
<br/>
    use DB_File ;<br/>
    use Fcntl ;<br/>
<br/>
    my %x ;<br/>
    my $X ;<br/>
<br/>
    $X = tie %x, 'DB_File', 'tst.fil' , O_RDWR|O_TRUNC<br/>
        or die &quot;Cannot tie first time: $!&quot; ;<br/>
<br/>
    $x{123} = 456 ;<br/>
<br/>
    untie %x ;<br/>
<br/>
    tie %x, 'DB_File', 'tst.fil' , O_RDWR|O_CREAT<br/>
        or die &quot;Cannot tie second time: $!&quot; ;<br/>
<br/>
    untie %x ;<br/>
<div class="spacer">
</div>
When run, the script will produce this error message:<div class="spacer">
</div>
<br/>
    Cannot tie second time: Invalid argument at bad.file line 14.<br/>
<div class="spacer">
</div>
Although the error message above refers to the second <i>tie()</i> statement in the script, the source of the problem is really with the  <i>untie()</i> statement that precedes it.<div class="spacer">
</div>
Having read perltie you will probably have already guessed that the error is caused by the extra copy of the tied object stored in $X. If you haven't, then the problem boils down to the fact that the  <b>DB_File</b> destructor, DESTROY, will not be called until <i>all</i> references to the tied object are destroyed. Both the tied variable, %x, and $X above hold a reference to the object. The call to  <i>untie()</i> will destroy the first, but $X still holds a valid reference, so the destructor will not get called and the database file  <i>tst.fil</i> will remain open. The fact that Berkeley DB then reports the attempt to open a database that is already open via the catch-all &quot;Invalid argument&quot; doesn't help.<div class="spacer">
</div>
If you run the script with the &quot;-w&quot; flag the error message becomes:<div class="spacer">
</div>
<br/>
    untie attempted while 1 inner references still exist at bad.file line 12.<br/>
    Cannot tie second time: Invalid argument at bad.file line 14.<br/>
<div class="spacer">
</div>
which pinpoints the real problem. Finally the script can now be modified to fix the original problem by destroying the API object before the untie:<div class="spacer">
</div>
<br/>
    ...<br/>
    $x{123} = 456 ;<br/>
<br/>
    undef $X ;<br/>
    untie %x ;<br/>
<br/>
    $X = tie %x, 'DB_File', 'tst.fil' , O_RDWR|O_CREAT<br/>
    ...<br/>
</div>
</div>
<div class="section">
<h1>COMMON QUESTIONS</h1><div class="subsection">
<h2>Why is there Perl source in my database?</h2> If you look at the contents of a database file created by DB_File, there can sometimes be part of a Perl script included in it.<div class="spacer">
</div>
This happens because Berkeley DB uses dynamic memory to allocate buffers which will subsequently be written to the database file. Being dynamic, the memory could have been used for anything before DB malloced it. As Berkeley DB doesn't clear the memory once it has been allocated, the unused portions will contain random junk. In the case where a Perl script gets written to the database, the random junk will correspond to an area of dynamic memory that happened to be used during the compilation of the script.<div class="spacer">
</div>
Unless you don't like the possibility of there being part of your Perl scripts embedded in a database file, this is nothing to worry about.</div>
<div class="subsection">
<h2>How do I store complex data structures with DB_File?</h2> Although  <b>DB_File</b> cannot do this directly, there is a module which can layer transparently over  <b>DB_File</b> to accomplish this feat.<div class="spacer">
</div>
Check out the MLDBM module, available on CPAN in the directory  <i>modules/by-module/MLDBM</i>.</div>
<div class="subsection">
<h2>What does &quot;Invalid Argument&quot; mean?</h2> You will get this error message when one of the parameters in the &quot;tie&quot; call is wrong. Unfortunately there are quite a few parameters to get wrong, so it can be difficult to figure out which one it is.<div class="spacer">
</div>
Here are a couple of possibilities:<dl>
<dt>
1.</dt>
<dd>
Attempting to reopen a database without closing it.</dd>
</dl>
<dl>
<dt>
2.</dt>
<dd>
Using the O_WRONLY flag.</dd>
</dl>
</div>
<div class="subsection">
<h2>What does &quot;Bareword 'DB_File' not allowed&quot; mean?</h2> You will encounter this particular error message when you have the &quot;strict 'subs'&quot; pragma (or the full strict pragma) in your script. Consider this script:<div class="spacer">
</div>
<br/>
    use warnings ;<br/>
    use strict ;<br/>
    use DB_File ;<br/>
    my %x ;<br/>
    tie %x, DB_File, &quot;filename&quot; ;<br/>
<div class="spacer">
</div>
Running it produces the error in question:<div class="spacer">
</div>
<br/>
    Bareword &quot;DB_File&quot; not allowed while &quot;strict subs&quot; in use<br/>
<div class="spacer">
</div>
To get around the error, place the word &quot;DB_File&quot; in either single or double quotes, like this:<div class="spacer">
</div>
<br/>
    tie %x, &quot;DB_File&quot;, &quot;filename&quot; ;<br/>
<div class="spacer">
</div>
Although it might seem like a real pain, it is really worth the effort of having a &quot;use strict&quot; in all your scripts.</div>
</div>
<div class="section">
<h1>REFERENCES</h1> Articles that are either about  <b>DB_File</b> or make use of it.<dl>
<dt>
1.</dt>
<dd>
<i>Full-Text Searching in Perl</i>, Tim Kientzle (tkientzle@ddj.com), Dr. Dobb's Journal, Issue 295, January 1999, pp 34-41</dd>
</dl>
</div>
<div class="section">
<h1>HISTORY</h1> Moved to the Changes file.</div>
<div class="section">
<h1>BUGS</h1> Some older versions of Berkeley DB had problems with fixed length records using the RECNO file format. This problem has been fixed since version 1.85 of Berkeley DB.<div class="spacer">
</div>
I am sure there are bugs in the code. If you do find any, or can suggest any enhancements, I would welcome your comments.</div>
<div class="section">
<h1>AVAILABILITY</h1>  <b>DB_File</b> comes with the standard Perl source distribution. Look in the directory  <i>ext/DB_File</i>. Given the amount of time between releases of Perl the version that ships with Perl is quite likely to be out of date, so the most recent version can always be found on CPAN (see &quot;CPAN&quot; in perlmodlib for details), in the directory  <i>modules/by-module/DB_File</i>.<div class="spacer">
</div>
This version of <b>DB_File</b> will work with either version 1.x, 2.x or 3.x of Berkeley DB, but is limited to the functionality provided by version 1.<div class="spacer">
</div>
The official web site for Berkeley DB is <i>http://www.oracle.com/technology/products/berkeley-db/db/index.html</i>. All versions of Berkeley DB are available there.<div class="spacer">
</div>
Alternatively, Berkeley DB version 1 is available at your nearest CPAN archive in  <i>src/misc/db.1.85.tar.gz</i>.<div class="spacer">
</div>
If you are running IRIX, then get Berkeley DB version 1 from  <i>http://reality.sgi.com/ariel</i>. It has the patches necessary to compile properly on IRIX 5.3.</div>
<div class="section">
<h1>COPYRIGHT</h1> Copyright (c) 1995-2007 Paul Marquess. All rights reserved. This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.<div class="spacer">
</div>
Although <b>DB_File</b> is covered by the Perl license, the library it makes use of, namely Berkeley DB, is not. Berkeley DB has its own copyright and its own license. Please take the time to read it.<div class="spacer">
</div>
Here are are few words taken from the Berkeley DB FAQ (at  <i>http://www.oracle.com/technology/products/berkeley-db/db/index.html</i>) regarding the license:<div class="spacer">
</div>
<br/>
    Do I have to license DB to use it in Perl scripts? <br/>
<br/>
    No. The Berkeley DB license requires that software that uses<br/>
    Berkeley DB be freely redistributable. In the case of Perl, that<br/>
    software is Perl, and not your scripts. Any Perl scripts that you<br/>
    write are your property, including scripts that make use of<br/>
    Berkeley DB. Neither the Perl license nor the Berkeley DB license<br/>
    place any restriction on what you may do with them.<br/>
<div class="spacer">
</div>
If you are in any doubt about the license situation, contact either the Berkeley DB authors or the author of DB_File. See &quot;AUTHOR&quot; for details.</div>
<div class="section">
<h1>SEE ALSO</h1> perl,  <i>dbopen</i>(3), <i>hash</i>(3), <i>recno</i>(3), <i>btree</i>(3), perldbmfilter</div>
<div class="section">
<h1>AUTHOR</h1> The DB_File interface was written by Paul Marquess &lt;pmqs@cpan.org&gt;.</div>
<table class="foot">
<tr>
<td class="foot-date">
2016-03-01</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

