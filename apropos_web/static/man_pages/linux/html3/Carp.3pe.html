<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Carp(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Carp(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
Carp(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Carp - alternative warn and die for modules</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
    use Carp;<br/>
<br/>
    # warn user (from perspective of caller)<br/>
    carp &quot;string trimmed to 80 chars&quot;;<br/>
<br/>
    # die of errors (from perspective of caller)<br/>
    croak &quot;We're outta here!&quot;;<br/>
<br/>
    # die of errors with stack backtrace<br/>
    confess &quot;not implemented&quot;;<br/>
<br/>
    # cluck not exported by default<br/>
    use Carp qw(cluck);<br/>
    cluck &quot;This is how we got here!&quot;;<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> The Carp routines are useful in your own modules because they act like  <i>die()</i> or <i>warn()</i>, but with a message which is more likely to be useful to a user of your module.  In the case of cluck, confess, and longmess that context is a summary of every call in the call-stack.  For a shorter message you can use &quot;carp&quot; or &quot;croak&quot; which report the error as being from where your module was called.  There is no guarantee that that is where the error was, but it is a good educated guess.<div class="spacer">
</div>
You can also alter the way the output and logic of &quot;Carp&quot; works, by changing some global variables in the &quot;Carp&quot; namespace. See the section on &quot;GLOBAL VARIABLES&quot; below.<div class="spacer">
</div>
Here is a more complete description of how &quot;carp&quot; and &quot;croak&quot; work. What they do is search the call-stack for a function call stack where they have not been told that there shouldn't be an error.  If every call is marked safe, they give up and give a full stack backtrace instead.  In other words they presume that the first likely looking potential suspect is guilty.  Their rules for telling whether a call shouldn't generate errors work as follows:<dl>
<dt>
1.</dt>
<dd>
Any call from a package to itself is safe.</dd>
</dl>
<dl>
<dt>
2.</dt>
<dd>
Packages claim that there won't be errors on calls to or from packages explicitly marked as safe by inclusion in @CARP_NOT, or (if that array is empty) @ISA.  The ability to override what @ISA says is new in 5.8.</dd>
</dl>
<dl>
<dt>
3.</dt>
<dd>
The trust in item 2 is transitive.  If A trusts B, and B trusts C, then A trusts C.  So if you do not override @ISA with @CARP_NOT, then this trust relationship is identical to, &quot;inherits from&quot;.</dd>
</dl>
<dl>
<dt>
4.</dt>
<dd>
Any call from an internal Perl module is safe.  (Nothing keeps user modules from marking themselves as internal to Perl, but this practice is discouraged.)</dd>
</dl>
<dl>
<dt>
5.</dt>
<dd>
Any call to Perl's warning system (eg Carp itself) is safe. (This rule is what keeps it from reporting the error at the point where you call &quot;carp&quot; or &quot;croak&quot;.)</dd>
</dl>
<dl>
<dt>
6.</dt>
<dd>
$Carp::CarpLevel can be set to skip a fixed number of additional call levels.  Using this is not recommended because it is very difficult to get it to behave correctly.</dd>
</dl>
<div class="subsection">
<h2>Forcing a Stack Trace</h2> As a debugging aid, you can force Carp to treat a croak as a confess and a carp as a cluck across  <i>all</i> modules. In other words, force a detailed stack trace to be given.  This can be very helpful when trying to understand why, or from where, a warning or error is being generated.<div class="spacer">
</div>
This feature is enabled by 'importing' the non-existent symbol 'verbose'. You would typically enable it by saying<div class="spacer">
</div>
<br/>
    perl -MCarp=verbose script.pl<br/>
<div class="spacer">
</div>
or by including the string &quot;-MCarp=verbose&quot; in the PERL5OPT environment variable.<div class="spacer">
</div>
Alternately, you can set the global variable $Carp::Verbose to true. See the &quot;GLOBAL VARIABLES&quot; section below.</div>
</div>
<div class="section">
<h1>GLOBAL VARIABLES</h1><div class="subsection">
<h2>$Carp::MaxEvalLen</h2> This variable determines how many characters of a string-eval are to be shown in the output. Use a value of 0 to show all text.<div class="spacer">
</div>
Defaults to 0.</div>
<div class="subsection">
<h2>$Carp::MaxArgLen</h2> This variable determines how many characters of each argument to a function to print. Use a value of 0 to show the full length of the argument.<div class="spacer">
</div>
Defaults to 64.</div>
<div class="subsection">
<h2>$Carp::MaxArgNums</h2> This variable determines how many arguments to each function to show. Use a value of 0 to show all arguments to a function call.<div class="spacer">
</div>
Defaults to 8.</div>
<div class="subsection">
<h2>$Carp::Verbose</h2> This variable makes &quot;carp&quot; and &quot;croak&quot; generate stack backtraces just like &quot;cluck&quot; and &quot;confess&quot;.  This is how &quot;use Carp 'verbose'&quot; is implemented internally.<div class="spacer">
</div>
Defaults to 0.</div>
<div class="subsection">
<h2>@CARP_NOT</h2> This variable,  <i>in your package</i>, says which packages are <i>not</i> to be considered as the location of an error. The &quot;carp()&quot; and &quot;cluck()&quot; functions will skip over callers when reporting where an error occurred.<div class="spacer">
</div>
NB: This variable must be in the package's symbol table, thus:<div class="spacer">
</div>
<br/>
    # These work<br/>
    our @CARP_NOT; # file scope<br/>
    use vars qw(@CARP_NOT); # package scope<br/>
    @My::Package::CARP_NOT = ... ; # explicit package variable<br/>
<br/>
    # These don't work<br/>
    sub xyz { ... @CARP_NOT = ... } # w/o declarations above<br/>
    my @CARP_NOT; # even at top-level<br/>
<div class="spacer">
</div>
Example of use:<div class="spacer">
</div>
<br/>
    package My::Carping::Package;<br/>
    use Carp;<br/>
    our @CARP_NOT;<br/>
    sub bar     { .... or _error('Wrong input') }<br/>
    sub _error  {<br/>
        # temporary control of where'ness, __PACKAGE__ is implicit<br/>
        local @CARP_NOT = qw(My::Friendly::Caller);<br/>
        carp(@_)<br/>
    }<br/>
<div class="spacer">
</div>
This would make &quot;Carp&quot; report the error as coming from a caller not in &quot;My::Carping::Package&quot;, nor from &quot;My::Friendly::Caller&quot;.<div class="spacer">
</div>
Also read the &quot;DESCRIPTION&quot; section above, about how &quot;Carp&quot; decides where the error is reported from.<div class="spacer">
</div>
Use @CARP_NOT, instead of $Carp::CarpLevel.<div class="spacer">
</div>
Overrides &quot;Carp&quot;'s use of @ISA.</div>
<div class="subsection">
<h2>%Carp::Internal</h2> This says what packages are internal to Perl.  &quot;Carp&quot; will never report an error as being from a line in a package that is internal to Perl.  For example:<div class="spacer">
</div>
<br/>
    $Carp::Internal{ (__PACKAGE__) }++;<br/>
    # time passes...<br/>
    sub foo { ... or confess(&quot;whatever&quot;) };<br/>
<div class="spacer">
</div>
would give a full stack backtrace starting from the first caller outside of __PACKAGE__.  (Unless that package was also internal to Perl.)</div>
<div class="subsection">
<h2>%Carp::CarpInternal</h2> This says which packages are internal to Perl's warning system.  For generating a full stack backtrace this is the same as being internal to Perl, the stack backtrace will not start inside packages that are listed in %Carp::CarpInternal.  But it is slightly different for the summary message generated by &quot;carp&quot; or &quot;croak&quot;.  There errors will not be reported on any lines that are calling packages in %Carp::CarpInternal.<div class="spacer">
</div>
For example &quot;Carp&quot; itself is listed in %Carp::CarpInternal. Therefore the full stack backtrace from &quot;confess&quot; will not start inside of &quot;Carp&quot;, and the short message from calling &quot;croak&quot; is not placed on the line where &quot;croak&quot; was called.</div>
<div class="subsection">
<h2>$Carp::CarpLevel</h2> This variable determines how many additional call frames are to be skipped that would not otherwise be when reporting where an error occurred on a call to one of &quot;Carp&quot;'s functions.  It is fairly easy to count these call frames on calls that generate a full stack backtrace.  However it is much harder to do this accounting for calls that generate a short message.  Usually people skip too many call frames.  If they are lucky they skip enough that &quot;Carp&quot; goes all of the way through the call stack, realizes that something is wrong, and then generates a full stack backtrace.  If they are unlucky then the error is reported from somewhere misleading very high in the call stack.<div class="spacer">
</div>
Therefore it is best to avoid $Carp::CarpLevel.  Instead use @CARP_NOT, %Carp::Internal and %Carp::CarpInternal.<div class="spacer">
</div>
Defaults to 0.</div>
</div>
<div class="section">
<h1>BUGS</h1> The Carp routines don't handle exception objects currently. If called with a first argument that is a reference, they simply call  <i>die()</i> or <i>warn()</i>, as appropriate.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-09-26</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

