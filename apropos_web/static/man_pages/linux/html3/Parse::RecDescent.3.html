<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Parse::RecDescent(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Parse::RecDescent(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
Parse::RecDescent(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Parse::RecDescent - Generate Recursive-Descent Parsers</div>
<div class="section">
<h1>VERSION</h1> This document describes version 1.965001 of Parse::RecDescent released April  9, 2003.</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
 use Parse::RecDescent;<br/>
<br/>
 # Generate a parser from the specification in $grammar:<br/>
<br/>
     $parser = new Parse::RecDescent ($grammar);<br/>
<br/>
 # Generate a parser from the specification in $othergrammar<br/>
<br/>
     $anotherparser = new Parse::RecDescent ($othergrammar);<br/>
<br/>
<br/>
 # Parse $text using rule 'startrule' (which must be<br/>
 # defined in $grammar):<br/>
<br/>
    $parser-&gt;startrule($text);<br/>
<br/>
<br/>
 # Parse $text using rule 'otherrule' (which must also<br/>
 # be defined in $grammar):<br/>
<br/>
     $parser-&gt;otherrule($text);<br/>
<br/>
<br/>
 # Change the universal token prefix pattern<br/>
 # (the default is: '\s*'):<br/>
<br/>
    $Parse::RecDescent::skip = '[ \t]+';<br/>
<br/>
<br/>
 # Replace productions of existing rules (or create new ones)<br/>
 # with the productions defined in $newgrammar:<br/>
<br/>
    $parser-&gt;Replace($newgrammar);<br/>
<br/>
<br/>
 # Extend existing rules (or create new ones)<br/>
 # by adding extra productions defined in $moregrammar:<br/>
<br/>
    $parser-&gt;Extend($moregrammar);<br/>
<br/>
<br/>
 # Global flags (useful as command line arguments under -s):<br/>
<br/>
    $::RD_ERRORS       # unless undefined, report fatal errors<br/>
    $::RD_WARN         # unless undefined, also report non-fatal problems<br/>
    $::RD_HINT         # if defined, also suggestion remedies<br/>
    $::RD_TRACE        # if defined, also trace parsers' behaviour<br/>
    $::RD_AUTOSTUB     # if defined, generates &quot;stubs&quot; for undefined rules<br/>
    $::RD_AUTOACTION   # if defined, appends specified action to productions<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1><div class="subsection">
<h2>Overview</h2> Parse::RecDescent incrementally generates top-down recursive-descent text parsers from simple  <i>yacc</i>-like grammar specifications. It provides:<dl>
<dt>
&#8226;</dt>
<dd>
Regular expressions or literal strings as terminals (tokens),</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Multiple (non-contiguous) productions for any rule,</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Repeated and optional subrules within productions,</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Full access to Perl within actions specified as part of the grammar,</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Simple automated error reporting during parser generation and parsing,</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
The ability to commit to, uncommit to, or reject particular productions during a parse,</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
The ability to pass data up and down the parse tree (&quot;down&quot; via subrule argument lists, &quot;up&quot; via subrule return values)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Incremental extension of the parsing grammar (even during a parse),</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Precompilation of parser objects,</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
User-definable reduce-reduce conflict resolution via &quot;scoring&quot; of matching productions.</dd>
</dl>
</div>
<div class="subsection">
<h2>Using &quot;Parse::RecDescent&quot;</h2> Parser objects are created by calling &quot;Parse::RecDescent::new&quot;, passing in a grammar specification (see the following subsections). If the grammar is correct, &quot;new&quot; returns a blessed reference which can then be used to initiate parsing through any rule specified in the original grammar. A typical sequence looks like this:<div class="spacer">
</div>
<br/>
    $grammar = q {<br/>
        # GRAMMAR SPECIFICATION HERE<br/>
         };<br/>
<br/>
    $parser = new Parse::RecDescent ($grammar) or die &quot;Bad grammar!\n&quot;;<br/>
<br/>
    # acquire $text<br/>
<br/>
    defined $parser-&gt;startrule($text) or print &quot;Bad text!\n&quot;;<br/>
<div class="spacer">
</div>
The rule through which parsing is initiated must be explicitly defined in the grammar (i.e. for the above example, the grammar must include a rule of the form: &quot;startrule: &lt;subrules&gt;&quot;.<div class="spacer">
</div>
If the starting rule succeeds, its value (see below) is returned. Failure to generate the original parser or failure to match a text is indicated by returning &quot;undef&quot;. Note that it's easy to set up grammars that can succeed, but which return a value of 0, &quot;0&quot;, or &quot;&quot;.  So don't be tempted to write:<div class="spacer">
</div>
<br/>
    $parser-&gt;startrule($text) or print &quot;Bad text!\n&quot;;<br/>
<div class="spacer">
</div>
Normally, the parser has no effect on the original text. So in the previous example the value of $text would be unchanged after having been parsed.<div class="spacer">
</div>
If, however, the text to be matched is passed by reference:<div class="spacer">
</div>
<br/>
    $parser-&gt;startrule(\$text)<br/>
<div class="spacer">
</div>
then any text which was consumed during the match will be removed from the start of $text.</div>
<div class="subsection">
<h2>Rules</h2> In the grammar from which the parser is built, rules are specified by giving an identifier (which must satisfy /[A-Za-z]\w*/), followed by a colon  <i>on the same line</i>, followed by one or more productions, separated by single vertical bars. The layout of the productions is entirely free-format:<div class="spacer">
</div>
<br/>
    rule1:  production1<br/>
     |  production2 |<br/>
    production3 | production4<br/>
<div class="spacer">
</div>
At any point in the grammar previously defined rules may be extended with additional productions. This is achieved by redeclaring the rule with the new productions. Thus:<div class="spacer">
</div>
<br/>
    rule1: a | b | c<br/>
    rule2: d | e | f<br/>
    rule1: g | h<br/>
<div class="spacer">
</div>
is exactly equivalent to:<div class="spacer">
</div>
<br/>
    rule1: a | b | c | g | h<br/>
    rule2: d | e | f<br/>
<div class="spacer">
</div>
Each production in a rule consists of zero or more items, each of which may be either: the name of another rule to be matched (a &quot;subrule&quot;), a pattern or string literal to be matched directly (a &quot;token&quot;), a block of Perl code to be executed (an &quot;action&quot;), a special instruction to the parser (a &quot;directive&quot;), or a standard Perl comment (which is ignored).<div class="spacer">
</div>
A rule matches a text if one of its productions matches. A production matches if each of its items match consecutive substrings of the text. The productions of a rule being matched are tried in the same order that they appear in the original grammar, and the first matching production terminates the match attempt (successfully). If all productions are tried and none matches, the match attempt fails.<div class="spacer">
</div>
Note that this behaviour is quite different from the &quot;prefer the longer match&quot; behaviour of  <i>yacc</i>. For example, if <i>yacc</i> were parsing the rule:<div class="spacer">
</div>
<br/>
    seq : 'A' 'B'<br/>
    | 'A' 'B' 'C'<br/>
<div class="spacer">
</div>
upon matching &quot;AB&quot; it would look ahead to see if a 'C' is next and, if so, will match the second production in preference to the first. In other words,  <i>yacc</i> effectively tries all the productions of a rule breadth-first in parallel, and selects the &quot;best&quot; match, where &quot;best&quot; means longest (note that this is a gross simplification of the true behaviour of  <i>yacc</i> but it will do for our purposes).<div class="spacer">
</div>
In contrast, &quot;Parse::RecDescent&quot; tries each production depth-first in sequence, and selects the &quot;best&quot; match, where &quot;best&quot; means first. This is the fundamental difference between &quot;bottom-up&quot; and &quot;recursive descent&quot; parsing.<div class="spacer">
</div>
Each successfully matched item in a production is assigned a value, which can be accessed in subsequent actions within the same production (or, in some cases, as the return value of a successful subrule call). Unsuccessful items don't have an associated value, since the failure of an item causes the entire surrounding production to immediately fail. The following sections describe the various types of items and their success values.</div>
<div class="subsection">
<h2>Subrules</h2> A subrule which appears in a production is an instruction to the parser to attempt to match the named rule at that point in the text being parsed. If the named subrule is not defined when requested the production containing it immediately fails (unless it was &quot;autostubbed&quot; - see Autostubbing).<div class="spacer">
</div>
A rule may (recursively) call itself as a subrule, but <i>not</i> as the left-most item in any of its productions (since such recursions are usually non-terminating).<div class="spacer">
</div>
The value associated with a subrule is the value associated with its $return variable (see &quot;Actions&quot; below), or with the last successfully matched item in the subrule match.<div class="spacer">
</div>
Subrules may also be specified with a trailing repetition specifier, indicating that they are to be (greedily) matched the specified number of times. The available specifiers are:<div class="spacer">
</div>
<br/>
    subrule(?)  # Match one-or-zero times<br/>
    subrule(s)  # Match one-or-more times<br/>
    subrule(s?) # Match zero-or-more times<br/>
    subrule(N)  # Match exactly N times for integer N &gt; 0<br/>
    subrule(N..M)   # Match between N and M times<br/>
    subrule(..M)    # Match between 1 and M times<br/>
    subrule(N..)    # Match at least N times<br/>
<div class="spacer">
</div>
Repeated subrules keep matching until either the subrule fails to match, or it has matched the minimal number of times but fails to consume any of the parsed text (this second condition prevents the subrule matching forever in some cases).<div class="spacer">
</div>
Since a repeated subrule may match many instances of the subrule itself, the value associated with it is not a simple scalar, but rather a reference to a list of scalars, each of which is the value associated with one of the individual subrule matches. In other words in the rule:<div class="spacer">
</div>
<br/>
    program: statement(s)<br/>
<div class="spacer">
</div>
the value associated with the repeated subrule &quot;statement(s)&quot; is a reference to an array containing the values matched by each call to the individual subrule &quot;statement&quot;.<div class="spacer">
</div>
Repetition modifiers may include a separator pattern:<div class="spacer">
</div>
<br/>
    program: statement(s /;/)<br/>
<div class="spacer">
</div>
specifying some sequence of characters to be skipped between each repetition. This is really just a shorthand for the &lt;leftop:...&gt; directive (see below).</div>
<div class="subsection">
<h2>Tokens</h2> If a quote-delimited string or a Perl regex appears in a production, the parser attempts to match that string or pattern at that point in the text. For example:<div class="spacer">
</div>
<br/>
    typedef: &quot;typedef&quot; typename identifier ';'<br/>
<br/>
    identifier: /[A-Za-z_][A-Za-z0-9_]*/<br/>
<div class="spacer">
</div>
As in regular Perl, a single quoted string is uninterpolated, whilst a double-quoted string or a pattern is interpolated (at the time of matching,  <i>not</i> when the parser is constructed). Hence, it is possible to define rules in which tokens can be set at run-time:<div class="spacer">
</div>
<br/>
    typedef: &quot;$::typedefkeyword&quot; typename identifier ';'<br/>
<br/>
    identifier: /$::identpat/<br/>
<div class="spacer">
</div>
Note that, since each rule is implemented inside a special namespace belonging to its parser, it is necessary to explicitly quantify variables from the main package.<div class="spacer">
</div>
Regex tokens can be specified using just slashes as delimiters or with the explicit &quot;m&lt;delimiter&gt;......&lt;delimiter&gt;&quot; syntax:<div class="spacer">
</div>
<br/>
    typedef: &quot;typedef&quot; typename identifier ';'<br/>
<br/>
    typename: /[A-Za-z_][A-Za-z0-9_]*/<br/>
<br/>
    identifier: m{[A-Za-z_][A-Za-z0-9_]*}<br/>
<div class="spacer">
</div>
A regex of either type can also have any valid trailing parameter(s) (that is, any of [cgimsox]):<div class="spacer">
</div>
<br/>
    typedef: &quot;typedef&quot; typename identifier ';'<br/>
<br/>
    identifier: / [a-z_]        # LEADING ALPHA OR UNDERSCORE<br/>
          [a-z0-9_]*    # THEN DIGITS ALSO ALLOWED<br/>
        /ix     # CASE/SPACE/COMMENT INSENSITIVE<br/>
<div class="spacer">
</div>
The value associated with any successfully matched token is a string containing the actual text which was matched by the token.<div class="spacer">
</div>
It is important to remember that, since each grammar is specified in a Perl string, all instances of the universal escape character '\' within a grammar must be &quot;doubled&quot;, so that they interpolate to single '\'s when the string is compiled. For example, to use the grammar:<div class="spacer">
</div>
<br/>
    word:       /\S+/ | backslash<br/>
    line:       prefix word(s) &quot;\n&quot;<br/>
    backslash:  '\\'<br/>
<div class="spacer">
</div>
the following code is required:<div class="spacer">
</div>
<br/>
    $parser = new Parse::RecDescent (q{<br/>
<br/>
        word:   /\\S+/ | backslash<br/>
        line:   prefix word(s) &quot;\\n&quot;<br/>
        backslash:  '\\\\'<br/>
<br/>
    });<br/>
</div>
<div class="subsection">
<h2>Anonymous subrules</h2> Parentheses introduce a nested scope that is very like a call to an anonymous subrule. Hence they are useful for &quot;in-lining&quot; subroutine calls, and other kinds of grouping behaviour. For example, instead of:<div class="spacer">
</div>
<br/>
    word:       /\S+/ | backslash<br/>
    line:       prefix word(s) &quot;\n&quot;<br/>
<div class="spacer">
</div>
you could write:<div class="spacer">
</div>
<br/>
    line:       prefix ( /\S+/ | backslash )(s) &quot;\n&quot;<br/>
<div class="spacer">
</div>
and get exactly the same effects.<div class="spacer">
</div>
Parentheses are also use for collecting unrepeated alternations within a single production.<div class="spacer">
</div>
<br/>
    secret_identity: &quot;Mr&quot; (&quot;Incredible&quot;|&quot;Fantastic&quot;|&quot;Sheen&quot;) &quot;, Esq.&quot;<br/>
</div>
<div class="subsection">
<h2>Terminal Separators</h2> For the purpose of matching, each terminal in a production is considered to be preceded by a &quot;prefix&quot; - a pattern which must be matched before a token match is attempted. By default, the prefix is optional whitespace (which always matches, at least trivially), but this default may be reset in any production.<div class="spacer">
</div>
The variable $Parse::RecDescent::skip stores the universal prefix, which is the default for all terminal matches in all parsers built with &quot;Parse::RecDescent&quot;.<div class="spacer">
</div>
The prefix for an individual production can be altered by using the &quot;&lt;skip:...&gt;&quot; directive (see below).</div>
<div class="subsection">
<h2>Actions</h2> An action is a block of Perl code which is to be executed (as the block of a &quot;do&quot; statement) when the parser reaches that point in a production. The action executes within a special namespace belonging to the active parser, so care must be taken in correctly qualifying variable names (see also &quot;Start-up Actions&quot; below).<div class="spacer">
</div>
The action is considered to succeed if the final value of the block is defined (that is, if the implied &quot;do&quot; statement evaluates to a defined value -  <i>even one which would be treated as &quot;false&quot;</i>). Note that the value associated with a successful action is also the final value in the block.<div class="spacer">
</div>
An action will <i>fail</i> if its last evaluated value is &quot;undef&quot;. This is surprisingly easy to accomplish by accident. For instance, here's an infuriating case of an action that makes its production fail, but only when debugging  <i>isn't</i> activated:<div class="spacer">
</div>
<br/>
    description: name rank serial_number<br/>
        { print &quot;Got $item[2] $item[1] ($item[3])\n&quot;<br/>
        if $::debugging<br/>
        }<br/>
<div class="spacer">
</div>
If $debugging is false, no statement in the block is executed, so the final value is &quot;undef&quot;, and the entire production fails. The solution is:<div class="spacer">
</div>
<br/>
    description: name rank serial_number<br/>
        { print &quot;Got $item[2] $item[1] ($item[3])\n&quot;<br/>
        if $::debugging;<br/>
          1;<br/>
        }<br/>
<div class="spacer">
</div>
Within an action, a number of useful parse-time variables are available in the special parser namespace (there are other variables also accessible, but meddling with them will probably just break your parser. As a general rule, if you avoid referring to unqualified variables - especially those starting with an underscore - inside an action, things should be okay):<dl>
<dt>
@item and %item</dt>
<dd>
The array slice @item[1..$#item] stores the value associated with each item (that is, each subrule, token, or action) in the current production. The analogy is to $1, $2, etc. in a  <i>yacc</i> grammar. Note that, for obvious reasons, @item only contains the values of items  <i>before</i> the current point in the production.<div style="height: 1.00em;">
&#160;</div>
The first element ($item[0]) stores the name of the current rule being matched.<div style="height: 1.00em;">
&#160;</div>
@item is a standard Perl array, so it can also be indexed with negative numbers, representing the number of items  <i>back</i> from the current position in the parse:<div style="height: 1.00em;">
&#160;</div>
<br/>
    stuff: /various/ bits 'and' pieces &quot;then&quot; data 'end'<br/>
        { print $item[-2] }  # PRINTS data<br/>
             # (EASIER THAN: $item[6])<br/>
<div style="height: 1.00em;">
&#160;</div>
The %item hash complements the &lt;@item&gt; array, providing named access to the same item values:<div style="height: 1.00em;">
&#160;</div>
<br/>
    stuff: /various/ bits 'and' pieces &quot;then&quot; data 'end'<br/>
        { print $item{data}  # PRINTS data<br/>
             # (EVEN EASIER THAN USING @item)<br/>
<div style="height: 1.00em;">
&#160;</div>
The results of named subrules are stored in the hash under each subrule's name (including the repetition specifier, if any), whilst all other items are stored under a &quot;named positional&quot; key that indictates their ordinal position within their item type: __STRING <i>n</i>__, __PATTERN<i>n</i>__, __DIRECTIVE<i>n</i>__, __ACTION<i>n</i>__:<div style="height: 1.00em;">
&#160;</div>
<br/>
    stuff: /various/ bits 'and' pieces &quot;then&quot; data 'end' { save }<br/>
        { print $item{__PATTERN1__}, # PRINTS 'various'<br/>
        $item{__STRING2__},  # PRINTS 'then'<br/>
        $item{__ACTION1__},  # PRINTS RETURN<br/>
                 # VALUE OF save<br/>
        }<br/>
<div style="height: 1.00em;">
&#160;</div>
If you want proper <i>named</i> access to patterns or literals, you need to turn them into separate rules:<div style="height: 1.00em;">
&#160;</div>
<br/>
    stuff: various bits 'and' pieces &quot;then&quot; data 'end'<br/>
        { print $item{various}  # PRINTS various<br/>
        }<br/>
<br/>
    various: /various/<br/>
<div style="height: 1.00em;">
&#160;</div>
The special entry $item{__RULE__} stores the name of the current rule (i.e. the same value as $item[0].<div style="height: 1.00em;">
&#160;</div>
The advantage of using %item, instead of @items is that it removes the need to track items positions that may change as a grammar evolves. For example, adding an interim &quot;&lt;skip&gt;&quot; directive of action can silently ruin a trailing action, by moving an @item element &quot;down&quot; the array one place. In contrast, the named entry of %item is unaffected by such an insertion.<div style="height: 1.00em;">
&#160;</div>
A limitation of the %item hash is that it only records the <i>last</i> value of a particular subrule. For example:<div style="height: 1.00em;">
&#160;</div>
<br/>
    range: '(' number '..' number )'<br/>
        { $return = $item{number} }<br/>
<div style="height: 1.00em;">
&#160;</div>
will return only the value corresponding to the <i>second</i> match of the &quot;number&quot; subrule. In other words, successive calls to a subrule overwrite the corresponding entry in %item. Once again, the solution is to rename each subrule in its own rule:<div style="height: 1.00em;">
&#160;</div>
<br/>
    range: '(' from_num '..' to_num )'<br/>
        { $return = $item{from_num} }<br/>
<br/>
    from_num: number<br/>
    to_num:   number<br/>
</dd>
</dl>
<dl>
<dt>
@arg and %arg</dt>
<dd>
The array @arg and the hash %arg store any arguments passed to the rule from some other rule (see &quot;&quot;Subrule argument lists&quot;). Changes to the elements of either variable do not propagate back to the calling rule (data can be passed back from a subrule via the $return variable - see next item).</dd>
</dl>
<dl>
<dt>
$return</dt>
<dd>
If a value is assigned to $return within an action, that value is returned if the production containing the action eventually matches successfully. Note that setting $return  <i>doesn't</i> cause the current production to succeed. It merely tells it what to return if it  <i>does</i> succeed. Hence $return is analogous to $$ in a  <i>yacc</i> grammar.<div style="height: 1.00em;">
&#160;</div>
If $return is not assigned within a production, the value of the last component of the production (namely: $item[$#item]) is returned if the production succeeds.</dd>
</dl>
<dl>
<dt>
$commit</dt>
<dd>
The current state of commitment to the current production (see &quot;Directives&quot; below).</dd>
</dl>
<dl>
<dt>
$skip</dt>
<dd>
The current terminal prefix (see &quot;Directives&quot; below).</dd>
</dl>
<dl>
<dt>
$text</dt>
<dd>
The remaining (unparsed) text. Changes to $text <i>do not</i>  <i>propagate</i> out of unsuccessful productions, but <i>do</i> survive successful productions. Hence it is possible to dynamically alter the text being parsed - for example, to provide a &quot;#include&quot;-like facility:<div style="height: 1.00em;">
&#160;</div>
<br/>
    hash_include: '#include' filename<br/>
        { $text = ::loadfile($item[2]) . $text }<br/>
<br/>
    filename: '&lt;' /[a-z0-9._-]+/i '&gt;'  { $return = $item[2] }<br/>
    | '&quot;' /[a-z0-9._-]+/i '&quot;'  { $return = $item[2] }<br/>
</dd>
</dl>
<dl>
<dt>
$thisline and $prevline</dt>
<dd>
$thisline stores the current line number within the current parse (starting from 1). $prevline stores the line number for the last character which was already successfully parsed (this will be different from $thisline at the end of each line).<div style="height: 1.00em;">
&#160;</div>
For efficiency, $thisline and $prevline are actually tied hashes, and only recompute the required line number when the variable's value is used.<div style="height: 1.00em;">
&#160;</div>
Assignment to $thisline adjusts the line number calculator, so that it believes that the current line number is the value being assigned. Note that this adjustment will be reflected in all subsequent line numbers calculations.<div style="height: 1.00em;">
&#160;</div>
Modifying the value of the variable $text (as in the previous &quot;hash_include&quot; example, for instance) will confuse the line counting mechanism. To prevent this, you should call &quot;Parse::RecDescent::LineCounter::resync($thisline)&quot;  <i>immediately</i> after any assignment to the variable $text (or, at least, before the next attempt to use $thisline).<div style="height: 1.00em;">
&#160;</div>
Note that if a production fails after assigning to or resync'ing $thisline, the parser's line counter mechanism will usually be corrupted.<div style="height: 1.00em;">
&#160;</div>
Also see the entry for @itempos.<div style="height: 1.00em;">
&#160;</div>
The line number can be set to values other than 1, by calling the start rule with a second argument. For example:<div style="height: 1.00em;">
&#160;</div>
<br/>
    $parser = new Parse::RecDescent ($grammar);<br/>
<br/>
    $parser-&gt;input($text, 10);  # START LINE NUMBERS AT 10<br/>
</dd>
</dl>
<dl>
<dt>
$thiscolumn and $prevcolumn</dt>
<dd>
$thiscolumn stores the current column number within the current line being parsed (starting from 1). $prevcolumn stores the column number of the last character which was actually successfully parsed. Usually &quot;$prevcolumn == $thiscolumn-1&quot;, but not at the end of lines.<div style="height: 1.00em;">
&#160;</div>
For efficiency, $thiscolumn and $prevcolumn are actually tied hashes, and only recompute the required column number when the variable's value is used.<div style="height: 1.00em;">
&#160;</div>
Assignment to $thiscolumn or $prevcolumn is a fatal error.<div style="height: 1.00em;">
&#160;</div>
Modifying the value of the variable $text (as in the previous &quot;hash_include&quot; example, for instance) may confuse the column counting mechanism.<div style="height: 1.00em;">
&#160;</div>
Note that $thiscolumn reports the column number <i>before</i> any whitespace that might be skipped before reading a token. Hence if you wish to know where a token started (and ended) use something like this:<div style="height: 1.00em;">
&#160;</div>
<br/>
    rule: token1 token2 startcol token3 endcol token4<br/>
        { print &quot;token3: columns $item[3] to $item[5]&quot;; }<br/>
<br/>
    startcol: '' { $thiscolumn }    # NEED THE '' TO STEP PAST TOKEN SEP<br/>
    endcol:  { $prevcolumn }<br/>
<div style="height: 1.00em;">
&#160;</div>
Also see the entry for @itempos.</dd>
</dl>
<dl>
<dt>
$thisoffset and $prevoffset</dt>
<dd>
$thisoffset stores the offset of the current parsing position within the complete text being parsed (starting from 0). $prevoffset stores the offset of the last character which was actually successfully parsed. In all cases &quot;$prevoffset == $thisoffset-1&quot;.<div style="height: 1.00em;">
&#160;</div>
For efficiency, $thisoffset and $prevoffset are actually tied hashes, and only recompute the required offset when the variable's value is used.<div style="height: 1.00em;">
&#160;</div>
Assignment to $thisoffset or &lt;$prevoffset&gt; is a fatal error.<div style="height: 1.00em;">
&#160;</div>
Modifying the value of the variable $text will <i>not</i> affect the offset counting mechanism.<div style="height: 1.00em;">
&#160;</div>
Also see the entry for @itempos.</dd>
</dl>
<dl>
<dt>
@itempos</dt>
<dd>
The array @itempos stores a hash reference corresponding to each element of @item. The elements of the hash provide the following:<div style="height: 1.00em;">
&#160;</div>
<br/>
    $itempos[$n]{offset}{from}  # VALUE OF $thisoffset BEFORE $item[$n]<br/>
    $itempos[$n]{offset}{to}    # VALUE OF $prevoffset AFTER $item[$n]<br/>
    $itempos[$n]{line}{from}    # VALUE OF $thisline BEFORE $item[$n]<br/>
    $itempos[$n]{line}{to}  # VALUE OF $prevline AFTER $item[$n]<br/>
    $itempos[$n]{column}{from}  # VALUE OF $thiscolumn BEFORE $item[$n]<br/>
    $itempos[$n]{column}{to}    # VALUE OF $prevcolumn AFTER $item[$n]<br/>
<div style="height: 1.00em;">
&#160;</div>
Note that the various &quot;$itempos[$n]...{from}&quot; values record the appropriate value  <i>after</i> any token prefix has been skipped.<div style="height: 1.00em;">
&#160;</div>
Hence, instead of the somewhat tedious and error-prone:<div style="height: 1.00em;">
&#160;</div>
<br/>
    rule: startcol token1 endcol<br/>
      startcol token2 endcol<br/>
      startcol token3 endcol<br/>
        { print &quot;token1: columns $item[1]<br/>
              to $item[3]<br/>
         token2: columns $item[4]<br/>
              to $item[6]<br/>
         token3: columns $item[7]<br/>
              to $item[9]&quot; }<br/>
<br/>
    startcol: '' { $thiscolumn }    # NEED THE '' TO STEP PAST TOKEN SEP<br/>
    endcol:  { $prevcolumn }<br/>
<div style="height: 1.00em;">
&#160;</div>
it is possible to write:<div style="height: 1.00em;">
&#160;</div>
<br/>
    rule: token1 token2 token3<br/>
        { print &quot;token1: columns $itempos[1]{column}{from}<br/>
              to $itempos[1]{column}{to}<br/>
         token2: columns $itempos[2]{column}{from}<br/>
              to $itempos[2]{column}{to}<br/>
         token3: columns $itempos[3]{column}{from}<br/>
              to $itempos[3]{column}{to}&quot; }<br/>
<div style="height: 1.00em;">
&#160;</div>
Note however that (in the current implementation) the use of @itempos anywhere in a grammar implies that item positioning information is collected  <i>everywhere</i> during the parse. Depending on the grammar and the size of the text to be parsed, this may be prohibitively expensive and the explicit use of $thisline, $thiscolumn, etc. may be a better choice.</dd>
</dl>
<dl>
<dt>
$thisparser</dt>
<dd>
A reference to the &quot;Parse::RecDescent&quot; object through which parsing was initiated.<div style="height: 1.00em;">
&#160;</div>
The value of $thisparser propagates down the subrules of a parse but not back up. Hence, you can invoke subrules from another parser for the scope of the current rule as follows:<div style="height: 1.00em;">
&#160;</div>
<br/>
    rule: subrule1 subrule2<br/>
    | { $thisparser = $::otherparser } &lt;reject&gt;<br/>
    | subrule3 subrule4<br/>
    | subrule5<br/>
<div style="height: 1.00em;">
&#160;</div>
The result is that the production calls &quot;subrule1&quot; and &quot;subrule2&quot; of the current parser, and the remaining productions call the named subrules from $::otherparser. Note, however that &quot;Bad Things&quot; will happen if &quot;::otherparser&quot; isn't a blessed reference and/or doesn't have methods with the same names as the required subrules!</dd>
</dl>
<dl>
<dt>
$thisrule</dt>
<dd>
A reference to the &quot;Parse::RecDescent::Rule&quot; object corresponding to the rule currently being matched.</dd>
</dl>
<dl>
<dt>
$thisprod</dt>
<dd>
A reference to the &quot;Parse::RecDescent::Production&quot; object corresponding to the production currently being matched.</dd>
</dl>
<dl>
<dt>
$score and $score_return</dt>
<dd>
$score stores the best production score to date, as specified by an earlier &quot;&lt;score:...&gt;&quot; directive. $score_return stores the corresponding return value for the successful production.<div style="height: 1.00em;">
&#160;</div>
See &quot;Scored productions&quot;.</dd>
</dl>
<div class="spacer">
</div>
<b>Warning:</b> the parser relies on the information in the various &quot;this...&quot; objects in some non-obvious ways. Tinkering with the other members of these objects will probably cause Bad Things to happen, unless you  <i>really</i> know what you're doing. The only exception to this advice is that the use of &quot;$this...-&gt;{local}&quot; is always safe.</div>
<div class="subsection">
<h2>Start-up Actions</h2> Any actions which appear  <i>before</i> the first rule definition in a grammar are treated as &quot;start-up&quot; actions. Each such action is stripped of its outermost brackets and then evaluated (in the parser's special namespace) just before the rules of the grammar are first compiled.<div class="spacer">
</div>
The main use of start-up actions is to declare local variables within the parser's special namespace:<div class="spacer">
</div>
<br/>
    { my $lastitem = '???'; }<br/>
<br/>
    list: item(s)   { $return = $lastitem }<br/>
<br/>
    item: book  { $lastitem = 'book'; }<br/>
      bell  { $lastitem = 'bell'; }<br/>
      candle    { $lastitem = 'candle'; }<br/>
<div class="spacer">
</div>
but start-up actions can be used to execute <i>any</i> valid Perl code within a parser's special namespace.<div class="spacer">
</div>
Start-up actions can appear within a grammar extension or replacement (that is, a partial grammar installed via &quot;Parse::RecDescent::Extend()&quot; or &quot;Parse::RecDescent::Replace()&quot; - see &quot;Incremental Parsing&quot;), and will be executed before the new grammar is installed. Note, however, that a particular start-up action is only ever executed once.</div>
<div class="subsection">
<h2>Autoactions</h2> It is sometimes desirable to be able to specify a default action to be taken at the end of every production (for example, in order to easily build a parse tree). If the variable $::RD_AUTOACTION is defined when &quot;Parse::RecDescent::new()&quot; is called, the contents of that variable are treated as a specification of an action which is to appended to each production in the corresponding grammar.<div class="spacer">
</div>
Alternatively, you can hard-code the autoaction within a grammar, using the &quot;&lt;autoaction:...&gt;&quot; directive.<div class="spacer">
</div>
So, for example, to construct a simple parse tree you could write:<div class="spacer">
</div>
<br/>
    $::RD_AUTOACTION = q { [@item] };<br/>
<br/>
    parser = Parse::RecDescent-&gt;new(q{<br/>
    expression: and_expr '||' expression | and_expr<br/>
    and_expr:   not_expr '&amp;&amp;' and_expr   | not_expr<br/>
    not_expr:   '!' brack_expr       | brack_expr<br/>
    brack_expr: '(' expression ')'       | identifier<br/>
    identifier: /[a-z]+/i<br/>
    });<br/>
<div class="spacer">
</div>
or:<div class="spacer">
</div>
<br/>
    parser = Parse::RecDescent-&gt;new(q{<br/>
    &lt;autoaction: { [@item] } &gt;<br/>
<br/>
    expression: and_expr '||' expression | and_expr<br/>
    and_expr:   not_expr '&amp;&amp;' and_expr   | not_expr<br/>
    not_expr:   '!' brack_expr       | brack_expr<br/>
    brack_expr: '(' expression ')'       | identifier<br/>
    identifier: /[a-z]+/i<br/>
    });<br/>
<div class="spacer">
</div>
Either of these is equivalent to:<div class="spacer">
</div>
<br/>
    parser = new Parse::RecDescent (q{<br/>
    expression: and_expr '||' expression<br/>
        { [@item] }<br/>
      | and_expr<br/>
        { [@item] }<br/>
<br/>
    and_expr:   not_expr '&amp;&amp;' and_expr  <br/>
        { [@item] }<br/>
    |   not_expr<br/>
        { [@item] }<br/>
<br/>
    not_expr:   '!' brack_expr      <br/>
        { [@item] }<br/>
    |   brack_expr<br/>
        { [@item] }<br/>
<br/>
    brack_expr: '(' expression ')'  <br/>
        { [@item] }<br/>
      | identifier<br/>
        { [@item] }<br/>
<br/>
    identifier: /[a-z]+/i<br/>
        { [@item] }<br/>
    });<br/>
<div class="spacer">
</div>
Alternatively, we could take an object-oriented approach, use different classes for each node (and also eliminating redundant intermediate nodes):<div class="spacer">
</div>
<br/>
    $::RD_AUTOACTION = q<br/>
      { $#item==1 ? $item[1] : &quot;$item[0]_node&quot;-&gt;new(@item[1..$#item]) };<br/>
<br/>
    parser = Parse::RecDescent-&gt;new(q{<br/>
        expression: and_expr '||' expression | and_expr<br/>
        and_expr:   not_expr '&amp;&amp;' and_expr   | not_expr<br/>
        not_expr:   '!' brack_expr           | brack_expr<br/>
        brack_expr: '(' expression ')'       | identifier<br/>
        identifier: /[a-z]+/i<br/>
    });<br/>
<div class="spacer">
</div>
or:<div class="spacer">
</div>
<br/>
    parser = Parse::RecDescent-&gt;new(q{<br/>
        &lt;autoaction:<br/>
          $#item==1 ? $item[1] : &quot;$item[0]_node&quot;-&gt;new(@item[1..$#item])<br/>
        &gt;<br/>
<br/>
        expression: and_expr '||' expression | and_expr<br/>
        and_expr:   not_expr '&amp;&amp;' and_expr   | not_expr<br/>
        not_expr:   '!' brack_expr           | brack_expr<br/>
        brack_expr: '(' expression ')'       | identifier<br/>
        identifier: /[a-z]+/i<br/>
    });<br/>
<div class="spacer">
</div>
which are equivalent to:<div class="spacer">
</div>
<br/>
    parser = Parse::RecDescent-&gt;new(q{<br/>
        expression: and_expr '||' expression<br/>
            { &quot;expression_node&quot;-&gt;new(@item[1..3]) }<br/>
        | and_expr<br/>
<br/>
        and_expr:   not_expr '&amp;&amp;' and_expr  <br/>
            { &quot;and_expr_node&quot;-&gt;new(@item[1..3]) }<br/>
        |   not_expr<br/>
<br/>
        not_expr:   '!' brack_expr      <br/>
            { &quot;not_expr_node&quot;-&gt;new(@item[1..2]) }<br/>
        |   brack_expr<br/>
<br/>
        brack_expr: '(' expression ')'  <br/>
            { &quot;brack_expr_node&quot;-&gt;new(@item[1..3]) }<br/>
        | identifier<br/>
<br/>
        identifier: /[a-z]+/i<br/>
            { &quot;identifer_node&quot;-&gt;new(@item[1]) }<br/>
    });<br/>
<div class="spacer">
</div>
Note that, if a production already ends in an action, no autoaction is appended to it. For example, in this version:<div class="spacer">
</div>
<br/>
    $::RD_AUTOACTION = q<br/>
      { $#item==1 ? $item[1] : &quot;$item[0]_node&quot;-&gt;new(@item[1..$#item]) };<br/>
<br/>
    parser = Parse::RecDescent-&gt;new(q{<br/>
        expression: and_expr '&amp;&amp;' expression | and_expr<br/>
        and_expr:   not_expr '&amp;&amp;' and_expr   | not_expr<br/>
        not_expr:   '!' brack_expr           | brack_expr<br/>
        brack_expr: '(' expression ')'       | identifier<br/>
        identifier: /[a-z]+/i<br/>
            { 'terminal_node'-&gt;new($item[1]) }<br/>
    });<br/>
<div class="spacer">
</div>
each &quot;identifier&quot; match produces a &quot;terminal_node&quot; object, <i>not</i> an &quot;identifier_node&quot; object.<div class="spacer">
</div>
A level 1 warning is issued each time an &quot;autoaction&quot; is added to some production.</div>
<div class="subsection">
<h2>Autotrees</h2> A commonly needed autoaction is one that builds a parse-tree. It is moderately tricky to set up such an action (which must treat terminals differently from non-terminals), so Parse::RecDescent simplifies the process by providing the &quot;&lt;autotree&gt;&quot; directive.<div class="spacer">
</div>
If this directive appears at the start of grammar, it causes Parse::RecDescent to insert autoactions at the end of any rule except those which already end in an action. The action inserted depends on whether the production is an intermediate rule (two or more items), or a terminal of the grammar (i.e. a single pattern or string item).<div class="spacer">
</div>
So, for example, the following grammar:<div class="spacer">
</div>
<br/>
    &lt;autotree&gt;<br/>
<br/>
    file    : command(s)<br/>
    command : get | set | vet<br/>
    get : 'get' ident ';'<br/>
    set : 'set' ident 'to' value ';'<br/>
    vet : 'check' ident 'is' value ';'<br/>
    ident   : /\w+/<br/>
    value   : /\d+/<br/>
<div class="spacer">
</div>
is equivalent to:<div class="spacer">
</div>
<br/>
    file    : command(s)        { bless \%item, $item[0] }<br/>
    command : get       { bless \%item, $item[0] }<br/>
    | set           { bless \%item, $item[0] }<br/>
    | vet           { bless \%item, $item[0] }<br/>
    get : 'get' ident ';'   { bless \%item, $item[0] }<br/>
    set : 'set' ident 'to' value ';'    { bless \%item, $item[0] }<br/>
    vet : 'check' ident 'is' value ';'  { bless \%item, $item[0] }<br/>
<br/>
    ident   : /\w+/  { bless {__VALUE__=&gt;$item[1]}, $item[0] }<br/>
    value   : /\d+/  { bless {__VALUE__=&gt;$item[1]}, $item[0] }<br/>
<div class="spacer">
</div>
Note that each node in the tree is blessed into a class of the same name as the rule itself. This makes it easy to build object-oriented processors for the parse-trees that the grammar produces. Note too that the last two rules produce special objects with the single attribute '__VALUE__'. This is because they consist solely of a single terminal.<div class="spacer">
</div>
This autoaction-ed grammar would then produce a parse tree in a data structure like this:<div class="spacer">
</div>
<br/>
    {<br/>
      file =&gt; {<br/>
        command =&gt; {<br/>
         [ get =&gt; {<br/>
            identifier =&gt; { __VALUE__ =&gt; 'a' },<br/>
              },<br/>
           set =&gt; {<br/>
            identifier =&gt; { __VALUE__ =&gt; 'b' },<br/>
            value      =&gt; { __VALUE__ =&gt; '7' },<br/>
              },<br/>
           vet =&gt; {<br/>
            identifier =&gt; { __VALUE__ =&gt; 'b' },<br/>
            value      =&gt; { __VALUE__ =&gt; '7' },<br/>
              },<br/>
          ],<br/>
           },<br/>
      }<br/>
    }<br/>
<div class="spacer">
</div>
(except, of course, that each nested hash would also be blessed into the appropriate class).</div>
<div class="subsection">
<h2>Autostubbing</h2> Normally, if a subrule appears in some production, but no rule of that name is ever defined in the grammar, the production which refers to the non-existent subrule fails immediately. This typically occurs as a result of misspellings, and is a sufficiently common occurance that a warning is generated for such situations.<div class="spacer">
</div>
However, when prototyping a grammar it is sometimes useful to be able to use subrules before a proper specification of them is really possible.  For example, a grammar might include a section like:<div class="spacer">
</div>
<br/>
    function_call: identifier '(' arg(s?) ')'<br/>
<br/>
    identifier: /[a-z]\w*/i<br/>
<div class="spacer">
</div>
where the possible format of an argument is sufficiently complex that it is not worth specifying in full until the general function call syntax has been debugged. In this situation it is convenient to leave the real rule &quot;arg&quot; undefined and just slip in a placeholder (or &quot;stub&quot;):<div class="spacer">
</div>
<br/>
    arg: 'arg'<br/>
<div class="spacer">
</div>
so that the function call syntax can be tested with dummy input such as:<div class="spacer">
</div>
<br/>
    f0()<br/>
    f1(arg)<br/>
    f2(arg arg)<br/>
    f3(arg arg arg)<br/>
<div class="spacer">
</div>
et cetera.<div class="spacer">
</div>
Early in prototyping, many such &quot;stubs&quot; may be required, so &quot;Parse::RecDescent&quot; provides a means of automating their definition. If the variable $::RD_AUTOSTUB is defined when a parser is built, a subrule reference to any non-existent rule (say, &quot;sr&quot;), causes a &quot;stub&quot; rule of the form:<div class="spacer">
</div>
<br/>
    sr: 'sr'<br/>
<div class="spacer">
</div>
to be automatically defined in the generated parser. A level 1 warning is issued for each such &quot;autostubbed&quot; rule.<div class="spacer">
</div>
Hence, with $::AUTOSTUB defined, it is possible to only partially specify a grammar, and then &quot;fake&quot; matches of the unspecified (sub)rules by just typing in their name.</div>
<div class="subsection">
<h2>Look-ahead</h2> If a subrule, token, or action is prefixed by &quot;...&quot;, then it is treated as a &quot;look-ahead&quot; request. That means that the current production can (as usual) only succeed if the specified item is matched, but that the matching  <i>does not consume any of the text being parsed</i>. This is very similar to the &quot;/(?=...)/&quot; look-ahead construct in Perl patterns. Thus, the rule:<div class="spacer">
</div>
<br/>
    inner_word: word ...word<br/>
<div class="spacer">
</div>
will match whatever the subrule &quot;word&quot; matches, provided that match is followed by some more text which subrule &quot;word&quot; would also match (although this second substring is not actually consumed by &quot;inner_word&quot;)<div class="spacer">
</div>
Likewise, a &quot;...!&quot; prefix, causes the following item to succeed (without consuming any text) if and only if it would normally fail. Hence, a rule such as:<div class="spacer">
</div>
<br/>
    identifier: ...!keyword ...!'_' /[A-Za-z_]\w*/<br/>
<div class="spacer">
</div>
matches a string of characters which satisfies the pattern &quot;/[A-Za-z_]\w*/&quot;, but only if the same sequence of characters would not match either subrule &quot;keyword&quot; or the literal token '_'.<div class="spacer">
</div>
Sequences of look-ahead prefixes accumulate, multiplying their positive and/or negative senses. Hence:<div class="spacer">
</div>
<br/>
    inner_word: word ...!......!word<br/>
<div class="spacer">
</div>
is exactly equivalent the the original example above (a warning is issued in cases like these, since they often indicate something left out, or misunderstood).<div class="spacer">
</div>
Note that actions can also be treated as look-aheads. In such cases, the state of the parser text (in the local variable $text)  <i>after</i> the look-ahead action is guaranteed to be identical to its state  <i>before</i> the action, regardless of how it's changed <i>within</i> the action (unless you actually undefine $text, in which case you get the disaster you deserve :-).</div>
<div class="subsection">
<h2>Directives</h2> Directives are special pre-defined actions which may be used to alter the behaviour of the parser. There are currently twenty-three directives: &quot;&lt;commit&gt;&quot;, &quot;&lt;uncommit&gt;&quot;, &quot;&lt;reject&gt;&quot;, &quot;&lt;score&gt;&quot;, &quot;&lt;autoscore&gt;&quot;, &quot;&lt;skip&gt;&quot;, &quot;&lt;resync&gt;&quot;, &quot;&lt;error&gt;&quot;, &quot;&lt;warn&gt;&quot;, &quot;&lt;hint&gt;&quot;, &quot;&lt;trace_build&gt;&quot;, &quot;&lt;trace_parse&gt;&quot;, &quot;&lt;nocheck&gt;&quot;, &quot;&lt;rulevar&gt;&quot;, &quot;&lt;matchrule&gt;&quot;, &quot;&lt;leftop&gt;&quot;, &quot;&lt;rightop&gt;&quot;, &quot;&lt;defer&gt;&quot;, &quot;&lt;nocheck&gt;&quot;, &quot;&lt;perl_quotelike&gt;&quot;, &quot;&lt;perl_codeblock&gt;&quot;, &quot;&lt;perl_variable&gt;&quot;, and &quot;&lt;token&gt;&quot;.<dl>
<dt>
Committing and uncommitting</dt>
<dd>
The &quot;&lt;commit&gt;&quot; and &quot;&lt;uncommit&gt;&quot; directives permit the recursive descent of the parse tree to be pruned (or &quot;cut&quot;) for efficiency. Within a rule, a &quot;&lt;commit&gt;&quot; directive instructs the rule to ignore subsequent productions if the current production fails. For example:<div style="height: 1.00em;">
&#160;</div>
<br/>
    command: 'find' &lt;commit&gt; filename<br/>
       | 'open' &lt;commit&gt; filename<br/>
       | 'move' filename filename<br/>
<div style="height: 1.00em;">
&#160;</div>
Clearly, if the leading token 'find' is matched in the first production but that production fails for some other reason, then the remaining productions cannot possibly match. The presence of the &quot;&lt;commit&gt;&quot; causes the &quot;command&quot; rule to fail immediately if an invalid &quot;find&quot; command is found, and likewise if an invalid &quot;open&quot; command is encountered.<div style="height: 1.00em;">
&#160;</div>
It is also possible to revoke a previous commitment. For example:<div style="height: 1.00em;">
&#160;</div>
<br/>
    if_statement: 'if' &lt;commit&gt; condition<br/>
        'then' block &lt;uncommit&gt;<br/>
        'else' block<br/>
        | 'if' &lt;commit&gt; condition<br/>
        'then' block<br/>
<div style="height: 1.00em;">
&#160;</div>
In this case, a failure to find an &quot;else&quot; block in the first production shouldn't preclude trying the second production, but a failure to find a &quot;condition&quot; certainly should.<div style="height: 1.00em;">
&#160;</div>
As a special case, any production in which the <i>first</i> item is an &quot;&lt;uncommit&gt;&quot; immediately revokes a preceding &quot;&lt;commit&gt;&quot; (even though the production would not otherwise have been tried). For example, in the rule:<div style="height: 1.00em;">
&#160;</div>
<br/>
    request: 'explain' expression<br/>
       | 'explain' &lt;commit&gt; keyword<br/>
       | 'save'<br/>
       | 'quit'<br/>
       | &lt;uncommit&gt; term '?'<br/>
<div style="height: 1.00em;">
&#160;</div>
if the text being matched was &quot;explain?&quot;, and the first two productions failed, then the &quot;&lt;commit&gt;&quot; in production two would cause productions three and four to be skipped, but the leading &quot;&lt;uncommit&gt;&quot; in the production five would allow that production to attempt a match.<div style="height: 1.00em;">
&#160;</div>
Note in the preceding example, that the &quot;&lt;commit&gt;&quot; was only placed in production two. If production one had been:<div style="height: 1.00em;">
&#160;</div>
<br/>
    request: 'explain' &lt;commit&gt; expression<br/>
<div style="height: 1.00em;">
&#160;</div>
then production two would be (inappropriately) skipped if a leading &quot;explain...&quot; was encountered.<div style="height: 1.00em;">
&#160;</div>
Both &quot;&lt;commit&gt;&quot; and &quot;&lt;uncommit&gt;&quot; directives always succeed, and their value is always 1.</dd>
</dl>
<dl>
<dt>
Rejecting a production</dt>
<dd>
The &quot;&lt;reject&gt;&quot; directive immediately causes the current production to fail (it is exactly equivalent to, but more obvious than, the action &quot;{undef}&quot;). A &quot;&lt;reject&gt;&quot; is useful when it is desirable to get the side effects of the actions in one production, without prejudicing a match by some other production later in the rule. For example, to insert tracing code into the parse:<div style="height: 1.00em;">
&#160;</div>
<br/>
    complex_rule: { print &quot;In complex rule...\n&quot;; } &lt;reject&gt;<br/>
        <br/>
    complex_rule: simple_rule '+' 'i' '*' simple_rule<br/>
        | 'i' '*' simple_rule<br/>
        | simple_rule<br/>
<div style="height: 1.00em;">
&#160;</div>
It is also possible to specify a conditional rejection, using the form &quot;&lt;reject: <i>condition</i>&gt;&quot;, which only rejects if the specified condition is true. This form of rejection is exactly equivalent to the action &quot;{( <i>condition</i>)?undef:1}&gt;&quot;. For example:<div style="height: 1.00em;">
&#160;</div>
<br/>
    command: save_command<br/>
       | restore_command<br/>
       | &lt;reject: defined $::tolerant&gt; { exit }<br/>
       | &lt;error: Unknown command. Ignored.&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
A &quot;&lt;reject&gt;&quot; directive never succeeds (and hence has no associated value). A conditional rejection may succeed (if its condition is not satisfied), in which case its value is 1.<div style="height: 1.00em;">
&#160;</div>
As an extra optimization, &quot;Parse::RecDescent&quot; ignores any production which  <i>begins</i> with an unconditional &quot;&lt;reject&gt;&quot; directive, since any such production can never successfully match or have any useful side-effects. A level 1 warning is issued in all such cases.<div style="height: 1.00em;">
&#160;</div>
Note that productions beginning with conditional &quot;&lt;reject:...&gt;&quot; directives are  <i>never</i> &quot;optimized away&quot; in this manner, even if they are always guaranteed to fail (for example: &quot;&lt;reject:1&gt;&quot;)<div style="height: 1.00em;">
&#160;</div>
Due to the way grammars are parsed, there is a minor restriction on the condition of a conditional &quot;&lt;reject:...&gt;&quot;: it cannot contain any raw '&lt;' or '&gt;' characters. For example:<div style="height: 1.00em;">
&#160;</div>
<br/>
    line: cmd &lt;reject: $thiscolumn &gt; max&gt; data<br/>
<div style="height: 1.00em;">
&#160;</div>
results in an error when a parser is built from this grammar (since the grammar parser has no way of knowing whether the first &gt; is a &quot;less than&quot; or the end of the &quot;&lt;reject:...&gt;&quot;.<div style="height: 1.00em;">
&#160;</div>
To overcome this problem, put the condition inside a do{} block:<div style="height: 1.00em;">
&#160;</div>
<br/>
    line: cmd &lt;reject: do{$thiscolumn &gt; max}&gt; data<br/>
<div style="height: 1.00em;">
&#160;</div>
Note that the same problem may occur in other directives that take arguments. The same solution will work in all cases.</dd>
</dl>
<dl>
<dt>
Skipping between terminals</dt>
<dd>
The &quot;&lt;skip&gt;&quot; directive enables the terminal prefix used in a production to be changed. For example:<div style="height: 1.00em;">
&#160;</div>
<br/>
    OneLiner: Command &lt;skip:'[ \t]*'&gt; Arg(s) /;/<br/>
<div style="height: 1.00em;">
&#160;</div>
causes only blanks and tabs to be skipped before terminals in the &quot;Arg&quot; subrule (and any of  <i>its</i> subrules&gt;, and also before the final &quot;/;/&quot; terminal. Once the production is complete, the previous terminal prefix is reinstated. Note that this implies that distinct productions of a rule must reset their terminal prefixes individually.<div style="height: 1.00em;">
&#160;</div>
The &quot;&lt;skip&gt;&quot; directive evaluates to the <i>previous</i> terminal prefix, so it's easy to reinstate a prefix later in a production:<div style="height: 1.00em;">
&#160;</div>
<br/>
    Command: &lt;skip:&quot;,&quot;&gt; CSV(s) &lt;skip:$item[1]&gt; Modifier<br/>
<div style="height: 1.00em;">
&#160;</div>
The value specified after the colon is interpolated into a pattern, so all of the following are equivalent (though their efficiency increases down the list):<div style="height: 1.00em;">
&#160;</div>
<br/>
    &lt;skip: &quot;$colon|$comma&quot;&gt;   # ASSUMING THE VARS HOLD THE OBVIOUS VALUES<br/>
<br/>
    &lt;skip: ':|,'&gt;<br/>
<br/>
    &lt;skip: q{[:,]}&gt;<br/>
<br/>
    &lt;skip: qr/[:,]/&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
There is no way of directly setting the prefix for an entire rule, except as follows:<div style="height: 1.00em;">
&#160;</div>
<br/>
    Rule: &lt;skip: '[ \t]*'&gt; Prod1<br/>
    | &lt;skip: '[ \t]*'&gt; Prod2a Prod2b<br/>
    | &lt;skip: '[ \t]*'&gt; Prod3<br/>
<div style="height: 1.00em;">
&#160;</div>
or, better:<div style="height: 1.00em;">
&#160;</div>
<br/>
    Rule: &lt;skip: '[ \t]*'&gt;<br/>
    (<br/>
    Prod1<br/>
      | Prod2a Prod2b<br/>
      | Prod3<br/>
    )<br/>
<div style="height: 1.00em;">
&#160;</div>
<b>Note: Up to release 1.51 of Parse::RecDescent, an entirely different</b>  <b>mechanism was used for specifying terminal prefixes. The current method</b>  <b>is not backwards-compatible with that early approach. The current approach</b>  <b>is stable and will not to change again.</b></dd>
</dl>
<dl>
<dt>
Resynchronization</dt>
<dd>
The &quot;&lt;resync&gt;&quot; directive provides a visually distinctive means of consuming some of the text being parsed, usually to skip an erroneous input. In its simplest form &quot;&lt;resync&gt;&quot; simply consumes text up to and including the next newline (&quot;\n&quot;) character, succeeding only if the newline is found, in which case it causes its surrounding rule to return zero on success.<div style="height: 1.00em;">
&#160;</div>
In other words, a &quot;&lt;resync&gt;&quot; is exactly equivalent to the token &quot;/[^\n]*\n/&quot; followed by the action &quot;{&#160;$return&#160;=&#160;0&#160;}&quot; (except that productions beginning with a &quot;&lt;resync&gt;&quot; are ignored when generating error messages). A typical use might be:<div style="height: 1.00em;">
&#160;</div>
<br/>
    script : command(s)<br/>
<br/>
    command: save_command<br/>
       | restore_command<br/>
       | &lt;resync&gt; # TRY NEXT LINE, IF POSSIBLE<br/>
<div style="height: 1.00em;">
&#160;</div>
It is also possible to explicitly specify a resynchronization pattern, using the &quot;&lt;resync: <i>pattern</i>&gt;&quot; variant. This version succeeds only if the specified pattern matches (and consumes) the parsed text. In other words, &quot;&lt;resync: <i>pattern</i>&gt;&quot; is exactly equivalent to the token &quot;/ <i>pattern</i>/&quot; (followed by a &quot;{&#160;$return&#160;=&#160;0&#160;}&quot; action). For example, if commands were terminated by newlines or semi-colons:<div style="height: 1.00em;">
&#160;</div>
<br/>
    command: save_command<br/>
       | restore_command<br/>
       | &lt;resync:[^;\n]*[;\n]&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
The value of a successfully matched &quot;&lt;resync&gt;&quot; directive (of either type) is the text that it consumed. Note, however, that since the directive also sets $return, a production consisting of a lone &quot;&lt;resync&gt;&quot; succeeds but returns the value zero (which a calling rule may find useful to distinguish between &quot;true&quot; matches and &quot;tolerant&quot; matches). Remember that returning a zero value indicates that the rule  <i>succeeded</i> (since only an &quot;undef&quot; denotes failure within &quot;Parse::RecDescent&quot; parsers.</dd>
</dl>
<dl>
<dt>
Error handling</dt>
<dd>
The &quot;&lt;error&gt;&quot; directive provides automatic or user-defined generation of error messages during a parse. In its simplest form &quot;&lt;error&gt;&quot; prepares an error message based on the mismatch between the last item expected and the text which cause it to fail. For example, given the rule:<div style="height: 1.00em;">
&#160;</div>
<br/>
    McCoy: curse ',' name ', I'm a doctor, not a' a_profession '!'<br/>
     | pronoun 'dead,' name '!'<br/>
     | &lt;error&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
the following strings would produce the following messages:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
&quot;Amen, Jim!&quot;</dt>
<dd>
<br/>
       ERROR (line 1): Invalid McCoy: Expected curse or pronoun<br/>
           not found<br/>
</dd>
</dl>
<dl>
<dt>
&quot;Dammit, Jim, I'm a doctor!&quot;</dt>
<dd>
<br/>
       ERROR (line 1): Invalid McCoy: Expected &quot;, I'm a doctor, not a&quot;<br/>
           but found &quot;, I'm a doctor!&quot; instead<br/>
</dd>
</dl>
<dl>
<dt>
&quot;He's dead,\n&quot;</dt>
<dd>
<br/>
       ERROR (line 2): Invalid McCoy: Expected name not found<br/>
</dd>
</dl>
<dl>
<dt>
&quot;He's alive!&quot;</dt>
<dd>
<br/>
       ERROR (line 1): Invalid McCoy: Expected 'dead,' but found<br/>
           &quot;alive!&quot; instead<br/>
</dd>
</dl>
<dl>
<dt>
&quot;Dammit, Jim, I'm a doctor, not a pointy-eared Vulcan!&quot;</dt>
<dd>
<br/>
       ERROR (line 1): Invalid McCoy: Expected a profession but found<br/>
           &quot;pointy-eared Vulcan!&quot; instead<br/>
</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">
&#160;</div>
Note that, when autogenerating error messages, all underscores in any rule name used in a message are replaced by single spaces (for example &quot;a_production&quot; becomes &quot;a production&quot;). Judicious choice of rule names can therefore considerably improve the readability of automatic error messages (as well as the maintainability of the original grammar).<div style="height: 1.00em;">
&#160;</div>
If the automatically generated error is not sufficient, it is possible to provide an explicit message as part of the error directive. For example:<div style="height: 1.00em;">
&#160;</div>
<br/>
    Spock: &quot;Fascinating ',' (name | 'Captain') '.'<br/>
     | &quot;Highly illogical, doctor.&quot;<br/>
     | &lt;error: He never said that!&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
which would result in <i>all</i> failures to parse a &quot;Spock&quot; subrule printing the following message:<div style="height: 1.00em;">
&#160;</div>
<br/>
       ERROR (line &lt;N&gt;): Invalid Spock:  He never said that!<br/>
<div style="height: 1.00em;">
&#160;</div>
The error message is treated as a &quot;qq{...}&quot; string and interpolated when the error is generated ( <i>not</i> when the directive is specified!). Hence:<div style="height: 1.00em;">
&#160;</div>
<br/>
    &lt;error: Mystical error near &quot;$text&quot;&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
would correctly insert the ambient text string which caused the error.<div style="height: 1.00em;">
&#160;</div>
There are two other forms of error directive: &quot;&lt;error?&gt;&quot; and &quot;&lt;error?:&#160;msg&gt;&quot;. These behave just like &quot;&lt;error&gt;&quot; and &quot;&lt;error:&#160;msg&gt;&quot; respectively, except that they are only triggered if the rule is &quot;committed&quot; at the time they are encountered. For example:<div style="height: 1.00em;">
&#160;</div>
<br/>
    Scotty: &quot;Ya kenna change the Laws of Phusics,&quot; &lt;commit&gt; name<br/>
      | name &lt;commit&gt; ',' 'she's goanta blaw!'<br/>
      | &lt;error?&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
will only generate an error for a string beginning with &quot;Ya kenna change the Laws o' Phusics,&quot; or a valid name, but which still fails to match the corresponding production. That is, &quot;$parser-&gt;Scotty(&quot;Aye, Cap'ain&quot;)&quot; will fail silently (since neither production will &quot;commit&quot; the rule on that input), whereas &quot;$parser-&gt;Scotty(&quot;Mr&#160;Spock,&#160;ah&#160;jest&#160;kenna&#160;do'ut!&quot;)&quot; will fail with the error message:<div style="height: 1.00em;">
&#160;</div>
<br/>
       ERROR (line 1): Invalid Scotty: expected 'she's goanta blaw!'<br/>
           but found 'I jest kenna do'ut!' instead.<br/>
<div style="height: 1.00em;">
&#160;</div>
since in that case the second production would commit after matching the leading name.<div style="height: 1.00em;">
&#160;</div>
Note that to allow this behaviour, all &quot;&lt;error&gt;&quot; directives which are the first item in a production automatically uncommit the rule just long enough to allow their production to be attempted (that is, when their production fails, the commitment is reinstated so that subsequent productions are skipped).<div style="height: 1.00em;">
&#160;</div>
In order to <i>permanently</i> uncommit the rule before an error message, it is necessary to put an explicit &quot;&lt;uncommit&gt;&quot; before the &quot;&lt;error&gt;&quot;. For example:<div style="height: 1.00em;">
&#160;</div>
<br/>
    line: 'Kirk:'  &lt;commit&gt; Kirk<br/>
    | 'Spock:' &lt;commit&gt; Spock<br/>
    | 'McCoy:' &lt;commit&gt; McCoy<br/>
    | &lt;uncommit&gt; &lt;error?&gt; &lt;reject&gt;<br/>
    | &lt;resync&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
Error messages generated by the various &quot;&lt;error...&gt;&quot; directives are not displayed immediately. Instead, they are &quot;queued&quot; in a buffer and are only displayed once parsing ultimately fails. Moreover, &quot;&lt;error...&gt;&quot; directives that cause one production of a rule to fail are automatically removed from the message queue if another production subsequently causes the entire rule to succeed. This means that you can put &quot;&lt;error...&gt;&quot; directives wherever useful diagnosis can be done, and only those associated with actual parser failure will ever be displayed. Also see &quot;Gotchas&quot;.<div style="height: 1.00em;">
&#160;</div>
As a general rule, the most useful diagnostics are usually generated either at the very lowest level within the grammar, or at the very highest. A good rule of thumb is to identify those subrules which consist mainly (or entirely) of terminals, and then put an &quot;&lt;error...&gt;&quot; directive at the end of any other rule which calls one or more of those subrules.<div style="height: 1.00em;">
&#160;</div>
There is one other situation in which the output of the various types of error directive is suppressed; namely, when the rule containing them is being parsed as part of a &quot;look-ahead&quot; (see &quot;Look-ahead&quot;). In this case, the error directive will still cause the rule to fail, but will do so silently.<div style="height: 1.00em;">
&#160;</div>
An unconditional &quot;&lt;error&gt;&quot; directive always fails (and hence has no associated value). This means that encountering such a directive always causes the production containing it to fail. Hence an &quot;&lt;error&gt;&quot; directive will inevitably be the last (useful) item of a rule (a level 3 warning is issued if a production contains items after an unconditional &quot;&lt;error&gt;&quot; directive).<div style="height: 1.00em;">
&#160;</div>
An &quot;&lt;error?&gt;&quot; directive will <i>succeed</i> (that is: fail to fail :-), if the current rule is uncommitted when the directive is encountered. In that case the directive's associated value is zero. Hence, this type of error directive  <i>can</i> be used before the end of a production. For example:<div style="height: 1.00em;">
&#160;</div>
<br/>
    command: 'do' &lt;commit&gt; something<br/>
       | 'report' &lt;commit&gt; something<br/>
       | &lt;error?: Syntax error&gt; &lt;error: Unknown command&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
<b>Warning:</b> The &quot;&lt;error?&gt;&quot; directive does <i>not</i> mean &quot;always fail (but do so silently unless committed)&quot;. It actually means &quot;only fail (and report) if committed, otherwise  <i>succeed</i>&quot;. To achieve the &quot;fail silently if uncommitted&quot; semantics, it is necessary to use:<div style="height: 1.00em;">
&#160;</div>
<br/>
    rule: item &lt;commit&gt; item(s)<br/>
    | &lt;error?&gt; &lt;reject&gt;  # FAIL SILENTLY UNLESS COMMITTED<br/>
<div style="height: 1.00em;">
&#160;</div>
However, because people seem to expect a lone &quot;&lt;error?&gt;&quot; directive to work like this:<div style="height: 1.00em;">
&#160;</div>
<br/>
    rule: item &lt;commit&gt; item(s)<br/>
    | &lt;error?: Error message if committed&gt;<br/>
    | &lt;error:  Error message if uncommitted&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
Parse::RecDescent automatically appends a &quot;&lt;reject&gt;&quot; directive if the &quot;&lt;error?&gt;&quot; directive is the only item in a production. A level 2 warning (see below) is issued when this happens.<div style="height: 1.00em;">
&#160;</div>
The level of error reporting during both parser construction and parsing is controlled by the presence or absence of four global variables: $::RD_ERRORS, $::RD_WARN, $::RD_HINT, and &lt;$::RD_TRACE&gt;. If $::RD_ERRORS is defined (and, by default, it is) then fatal errors are reported.<div style="height: 1.00em;">
&#160;</div>
Whenever $::RD_WARN is defined, certain non-fatal problems are also reported.<div style="height: 1.00em;">
&#160;</div>
Warnings have an associated &quot;level&quot;: 1, 2, or 3. The higher the level, the more serious the warning. The value of the corresponding global variable ($::RD_WARN) determines the  <i>lowest</i> level of warning to be displayed. Hence, to see  <i>all</i> warnings, set $::RD_WARN to 1. To see only the most serious warnings set $::RD_WARN to 3. By default $::RD_WARN is initialized to 3, ensuring that serious but non-fatal errors are automatically reported.<div style="height: 1.00em;">
&#160;</div>
There is also a grammar directive to turn on warnings from within the grammar: &quot;&lt;warn&gt;&quot;. It takes an optional argument, which specifies the warning level: &quot;&lt;warn: 2&gt;&quot;.<div style="height: 1.00em;">
&#160;</div>
See <i>&quot;DIAGNOSTICS&quot;</i> for a list of the varous error and warning messages that Parse::RecDescent generates when these two variables are defined.<div style="height: 1.00em;">
&#160;</div>
Defining any of the remaining variables (which are not defined by default) further increases the amount of information reported. Defining $::RD_HINT causes the parser generator to offer more detailed analyses and hints on both errors and warnings. Note that setting $::RD_HINT at any point automagically sets $::RD_WARN to 1. There is also a &quot;&lt;hint&gt;&quot; directive, which can be hard-coded into a grammar.<div style="height: 1.00em;">
&#160;</div>
Defining $::RD_TRACE causes the parser generator and the parser to report their progress to STDERR in excruciating detail (although, without hints unless $::RD_HINT is separately defined). This detail can be moderated in only one respect: if $::RD_TRACE has an integer value ( <i>N</i>) greater than 1, only the <i>N</i> characters of the &quot;current parsing context&quot; (that is, where in the input string we are at any point in the parse) is reported at any time.<br/>
   &gt; $::RD_TRACE is mainly useful for debugging a grammar that isn't behaving as you expected it to. To this end, if $::RD_TRACE is defined when a parser is built, any actual parser code which is generated is also written to a file named &quot;RD_TRACE&quot; in the local directory.<div style="height: 1.00em;">
&#160;</div>
There are two directives associated with the $::RD_TRACE variable. If a grammar contains a &quot;&lt;trace_build&gt;&quot; directive anywhere in its specification, $::RD_TRACE is turned on during the parser construction phase.  If a grammar contains a &quot;&lt;trace_parse&gt;&quot; directive anywhere in its specification, $::RD_TRACE is turned on during any parse the parser performs.<div style="height: 1.00em;">
&#160;</div>
Note that the four variables belong to the &quot;main&quot; package, which makes them easier to refer to in the code controlling the parser, and also makes it easy to turn them into command line flags (&quot;-RD_ERRORS&quot;, &quot;-RD_WARN&quot;, &quot;-RD_HINT&quot;, &quot;-RD_TRACE&quot;) under  <b>perl -s</b>.<div style="height: 1.00em;">
&#160;</div>
The corresponding directives are useful to &quot;hardwire&quot; the various debugging features into a particular grammar (rather than having to set and reset external variables).</div>
<dl>
<dt>
Redirecting diagnostics</dt>
<dd>
The diagnostics provided by the tracing mechanism go to STDERR by default, but can be directed to a specific filehandle by calling the &quot;Parse::RecDescent::redirect_reporting_to()&quot; subroutine (which must be fully qualified, as it is not exported).<div style="height: 1.00em;">
&#160;</div>
This subroutine expects either one or two arguments. The first is the filehandle you want all diagnostics redirected to. It must already be open for output, and may be specified as a typeglob, or as a reference to a filehandle:<div style="height: 1.00em;">
&#160;</div>
<br/>
    Parse::RecDescent::redirect_reporting_to(*STDOUT);<br/>
    Parse::RecDescent::redirect_reporting_to($fh);<br/>
<div style="height: 1.00em;">
&#160;</div>
The optional second argument specifies the mode in which data is to be written to the handle. By default the &quot;overwrite&quot; mode ('&gt;') is used, but you can explicitly pass '&gt;&gt;' to select &quot;append&quot; mode:<div style="height: 1.00em;">
&#160;</div>
<br/>
    # Append reports to my log file...<br/>
    Parse::RecDescent::redirect_reporting_to($my_log_file, '&gt;&gt;');<br/>
<div style="height: 1.00em;">
&#160;</div>
The subroutine returns true if it successfully redirects all reporting streams, or false if it is not able to do so (typically because you gave it an invalid filehandle).</dd>
</dl>
<dl>
<dt>
Consistency checks</dt>
<dd>
Whenever a parser is build, Parse::RecDescent carries out a number of (potentially expensive) consistency checks. These include: verifying that the grammar is not left-recursive and that no rules have been left undefined.<div style="height: 1.00em;">
&#160;</div>
These checks are important safeguards during development, but unnecessary overheads when the grammar is stable and ready to be deployed. So Parse::RecDescent provides a directive to disable them: &quot;&lt;nocheck&gt;&quot;.<div style="height: 1.00em;">
&#160;</div>
If a grammar contains a &quot;&lt;nocheck&gt;&quot; directive anywhere in its specification, the extra compile-time checks are by-passed.</dd>
</dl>
<dl>
<dt>
Specifying local variables</dt>
<dd>
It is occasionally convenient to specify variables which are local to a single rule. This may be achieved by including a &quot;&lt;rulevar:...&gt;&quot; directive anywhere in the rule. For example:<div style="height: 1.00em;">
&#160;</div>
<br/>
    markup: &lt;rulevar: $tag&gt;<br/>
<br/>
    markup: tag {($tag=$item[1]) =~ s/^&lt;|&gt;$//g} body[$tag]<br/>
<div style="height: 1.00em;">
&#160;</div>
The example &quot;&lt;rulevar: $tag&gt;&quot; directive causes a &quot;my&quot; variable named $tag to be declared at the start of the subroutine implementing the &quot;markup&quot; rule (that is,  <i>before</i> the first production, regardless of where in the rule it is specified).<div style="height: 1.00em;">
&#160;</div>
Specifically, any directive of the form: &quot;&lt;rulevar: <i>text</i>&gt;&quot; causes a line of the form &quot;my <i>text</i>;&quot; to be added at the beginning of the rule subroutine, immediately after the definitions of the following local variables:<div style="height: 1.00em;">
&#160;</div>
<br/>
    $thisparser $commit<br/>
    $thisrule   @item<br/>
    $thisline   @arg<br/>
    $text   %arg<br/>
<div style="height: 1.00em;">
&#160;</div>
This means that the following &quot;&lt;rulevar&gt;&quot; directives work as expected:<div style="height: 1.00em;">
&#160;</div>
<br/>
    &lt;rulevar: $count = 0 &gt;<br/>
<br/>
    &lt;rulevar: $firstarg = $arg[0] || '' &gt;<br/>
<br/>
    &lt;rulevar: $myItems = \@item &gt;<br/>
<br/>
    &lt;rulevar: @context = ( $thisline, $text, @arg ) &gt;<br/>
<br/>
    &lt;rulevar: ($name,$age) = $arg{&quot;name&quot;,&quot;age&quot;} &gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
If a variable that is also visible to subrules is required, it needs to be &quot;local&quot;'d, not &quot;my&quot;'d. &quot;rulevar&quot; defaults to &quot;my&quot;, but if &quot;local&quot; is explicitly specified:<div style="height: 1.00em;">
&#160;</div>
<br/>
    &lt;rulevar: local $count = 0 &gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
then a &quot;local&quot;-ized variable is declared instead, and will be available within subrules.<div style="height: 1.00em;">
&#160;</div>
Note however that, because all such variables are &quot;my&quot; variables, their values  <i>do not persist</i> between match attempts on a given rule. To preserve values between match attempts, values can be stored within the &quot;local&quot; member of the $thisrule object:<div style="height: 1.00em;">
&#160;</div>
<br/>
    countedrule: { $thisrule-&gt;{&quot;local&quot;}{&quot;count&quot;}++ }<br/>
         &lt;reject&gt;<br/>
       | subrule1<br/>
       | subrule2<br/>
       | &lt;reject: $thisrule-&gt;{&quot;local&quot;}{&quot;count&quot;} == 1&gt;<br/>
         subrule3<br/>
<div style="height: 1.00em;">
&#160;</div>
When matching a rule, each &quot;&lt;rulevar&gt;&quot; directive is matched as if it were an unconditional &quot;&lt;reject&gt;&quot; directive (that is, it causes any production in which it appears to immediately fail to match). For this reason (and to improve readability) it is usual to specify any &quot;&lt;rulevar&gt;&quot; directive in a separate production at the start of the rule (this has the added advantage that it enables &quot;Parse::RecDescent&quot; to optimize away such productions, just as it does for the &quot;&lt;reject&gt;&quot; directive).</dd>
</dl>
<dl>
<dt>
Dynamically matched rules</dt>
<dd>
Because regexes and double-quoted strings are interpolated, it is relatively easy to specify productions with &quot;context sensitive&quot; tokens. For example:<div style="height: 1.00em;">
&#160;</div>
<br/>
    command:  keyword  body  &quot;end $item[1]&quot;<br/>
<div style="height: 1.00em;">
&#160;</div>
which ensures that a command block is bounded by a &quot; <i>&lt;keyword&gt;</i>...end <i>&lt;same keyword&gt;</i>&quot; pair.<div style="height: 1.00em;">
&#160;</div>
Building productions in which subrules are context sensitive is also possible, via the &quot;&lt;matchrule:...&gt;&quot; directive. This directive behaves identically to a subrule item, except that the rule which is invoked to match it is determined by the string specified after the colon. For example, we could rewrite the &quot;command&quot; rule like this:<div style="height: 1.00em;">
&#160;</div>
<br/>
    command:  keyword  &lt;matchrule:body&gt;  &quot;end $item[1]&quot;<br/>
<div style="height: 1.00em;">
&#160;</div>
Whatever appears after the colon in the directive is treated as an interpolated string (that is, as if it appeared in &quot;qq{...}&quot; operator) and the value of that interpolated string is the name of the subrule to be matched.<div style="height: 1.00em;">
&#160;</div>
Of course, just putting a constant string like &quot;body&quot; in a &quot;&lt;matchrule:...&gt;&quot; directive is of little interest or benefit. The power of directive is seen when we use a string that interpolates to something interesting. For example:<div style="height: 1.00em;">
&#160;</div>
<br/>
    command:    keyword &lt;matchrule:$item[1]_body&gt; &quot;end $item[1]&quot;<br/>
<br/>
    keyword:    'while' | 'if' | 'function'<br/>
<br/>
    while_body: condition block<br/>
<br/>
    if_body:    condition block ('else' block)(?)<br/>
<br/>
    function_body:  arglist block<br/>
<div style="height: 1.00em;">
&#160;</div>
Now the &quot;command&quot; rule selects how to proceed on the basis of the keyword that is found. It is as if &quot;command&quot; were declared:<div style="height: 1.00em;">
&#160;</div>
<br/>
    command:    'while'    while_body    &quot;end while&quot; <br/>
       |    'if'       if_body   &quot;end if&quot; <br/>
       |    'function' function_body &quot;end function&quot;<br/>
<div style="height: 1.00em;">
&#160;</div>
When a &quot;&lt;matchrule:...&gt;&quot; directive is used as a repeated subrule, the rule name expression is &quot;late-bound&quot;. That is, the name of the rule to be called is re-evaluated  <i>each time</i> a match attempt is made. Hence, the following grammar:<div style="height: 1.00em;">
&#160;</div>
<br/>
    { $::species = 'dogs' }<br/>
<br/>
    pair:   'two' &lt;matchrule:$::species&gt;(s)<br/>
<br/>
    dogs:   /dogs/ { $::species = 'cats' }<br/>
<br/>
    cats:   /cats/<br/>
<div style="height: 1.00em;">
&#160;</div>
will match the string &quot;two dogs cats cats&quot; completely, whereas it will only match the string &quot;two dogs dogs dogs&quot; up to the eighth letter. If the rule name were &quot;early bound&quot; (that is, evaluated only the first time the directive is encountered in a production), the reverse behaviour would be expected.<div style="height: 1.00em;">
&#160;</div>
Note that the &quot;matchrule&quot; directive takes a string that is to be treated as a rule name,  <i>not</i> as a rule invocation. That is, it's like a Perl symbolic reference, not an &quot;eval&quot;. Just as you can say:<div style="height: 1.00em;">
&#160;</div>
<br/>
    $subname = 'foo';<br/>
<br/>
    # and later...<br/>
<br/>
    &amp;{$foo}(@args);<br/>
<div style="height: 1.00em;">
&#160;</div>
but not:<div style="height: 1.00em;">
&#160;</div>
<br/>
    $subname = 'foo(@args)';<br/>
<br/>
    # and later...<br/>
<br/>
    &amp;{$foo};<br/>
<div style="height: 1.00em;">
&#160;</div>
likewise you can say:<div style="height: 1.00em;">
&#160;</div>
<br/>
    $rulename = 'foo';<br/>
<br/>
    # and in the grammar...<br/>
<br/>
    &lt;matchrule:$rulename&gt;[@args]<br/>
<div style="height: 1.00em;">
&#160;</div>
but not:<div style="height: 1.00em;">
&#160;</div>
<br/>
    $rulename = 'foo[@args]';<br/>
<br/>
    # and in the grammar...<br/>
<br/>
    &lt;matchrule:$rulename&gt;<br/>
</dd>
</dl>
<dl>
<dt>
Deferred actions</dt>
<dd>
The &quot;&lt;defer:...&gt;&quot; directive is used to specify an action to be performed when (and only if!) the current production ultimately succeeds.<div style="height: 1.00em;">
&#160;</div>
Whenever a &quot;&lt;defer:...&gt;&quot; directive appears, the code it specifies is converted to a closure (an anonymous subroutine reference) which is queued within the active parser object. Note that, because the deferred code is converted to a closure, the values of any &quot;local&quot; variable (such as $text, &lt;@item&gt;, etc.) are preserved until the deferred code is actually executed.<div style="height: 1.00em;">
&#160;</div>
If the parse ultimately succeeds  <i>and</i> the production in which the &quot;&lt;defer:...&gt;&quot; directive was evaluated formed part of the successful parse, then the deferred code is executed immediately before the parse returns. If however the production which queued a deferred action fails, or one of the higher-level rules which called that production fails, then the deferred action is removed from the queue, and hence is never executed.<div style="height: 1.00em;">
&#160;</div>
For example, given the grammar:<div style="height: 1.00em;">
&#160;</div>
<br/>
    sentence: noun trans noun<br/>
    | noun intrans<br/>
<br/>
    noun:     'the dog'<br/>
        { print &quot;$item[1]\t(noun)\n&quot; }<br/>
    |     'the meat'<br/>
        { print &quot;$item[1]\t(noun)\n&quot; }<br/>
<br/>
    trans:    'ate'<br/>
        { print &quot;$item[1]\t(transitive)\n&quot; }<br/>
<br/>
    intrans:  'ate'<br/>
        { print &quot;$item[1]\t(intransitive)\n&quot; }<br/>
       |  'barked'<br/>
        { print &quot;$item[1]\t(intransitive)\n&quot; }<br/>
<div style="height: 1.00em;">
&#160;</div>
then parsing the sentence &quot;the dog ate&quot; would produce the output:<div style="height: 1.00em;">
&#160;</div>
<br/>
    the dog  (noun)<br/>
    ate  (transitive)<br/>
    the dog  (noun)<br/>
    ate  (intransitive)<br/>
<div style="height: 1.00em;">
&#160;</div>
This is because, even though the first production of &quot;sentence&quot; ultimately fails, its initial subrules &quot;noun&quot; and &quot;trans&quot; do match, and hence they execute their associated actions. Then the second production of &quot;sentence&quot; succeeds, causing the actions of the subrules &quot;noun&quot; and &quot;intrans&quot; to be executed as well.<div style="height: 1.00em;">
&#160;</div>
On the other hand, if the actions were replaced by &quot;&lt;defer:...&gt;&quot; directives:<div style="height: 1.00em;">
&#160;</div>
<br/>
    sentence: noun trans noun<br/>
    | noun intrans<br/>
<br/>
    noun:     'the dog'<br/>
        &lt;defer: print &quot;$item[1]\t(noun)\n&quot; &gt;<br/>
    |     'the meat'<br/>
        &lt;defer: print &quot;$item[1]\t(noun)\n&quot; &gt;<br/>
<br/>
    trans:    'ate'<br/>
        &lt;defer: print &quot;$item[1]\t(transitive)\n&quot; &gt;<br/>
<br/>
    intrans:  'ate'<br/>
        &lt;defer: print &quot;$item[1]\t(intransitive)\n&quot; &gt;<br/>
       |  'barked'<br/>
        &lt;defer: print &quot;$item[1]\t(intransitive)\n&quot; &gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
the output would be:<div style="height: 1.00em;">
&#160;</div>
<br/>
    the dog  (noun)<br/>
    ate  (intransitive)<br/>
<div style="height: 1.00em;">
&#160;</div>
since deferred actions are only executed if they were evaluated in a production which ultimately contributes to the successful parse.<div style="height: 1.00em;">
&#160;</div>
In this case, even though the first production of &quot;sentence&quot; caused the subrules &quot;noun&quot; and &quot;trans&quot; to match, that production ultimately failed and so the deferred actions queued by those subrules were subsequently disgarded. The second production then succeeded, causing the entire parse to succeed, and so the deferred actions queued by the (second) match of the &quot;noun&quot; subrule and the subsequent match of &quot;intrans&quot;  <i>are</i> preserved and eventually executed.<div style="height: 1.00em;">
&#160;</div>
Deferred actions provide a means of improving the performance of a parser, by only executing those actions which are part of the final parse-tree for the input data.<div style="height: 1.00em;">
&#160;</div>
Alternatively, deferred actions can be viewed as a mechanism for building (and executing) a customized subroutine corresponding to the given input data, much in the same way that autoactions (see &quot;Autoactions&quot;) can be used to build a customized data structure for specific input.<div style="height: 1.00em;">
&#160;</div>
Whether or not the action it specifies is ever executed, a &quot;&lt;defer:...&gt;&quot; directive always succeeds, returning the number of deferred actions currently queued at that point.</dd>
</dl>
<dl>
<dt>
Parsing Perl</dt>
<dd>
Parse::RecDescent provides limited support for parsing subsets of Perl, namely: quote-like operators, Perl variables, and complete code blocks.<div style="height: 1.00em;">
&#160;</div>
The &quot;&lt;perl_quotelike&gt;&quot; directive can be used to parse any Perl quote-like operator: 'a string', &quot;m/a pattern/&quot;, &quot;tr{ans}{lation}&quot;, etc.  It does this by calling  <i>Text::Balanced::quotelike()</i>.<div style="height: 1.00em;">
&#160;</div>
If a quote-like operator is found, a reference to an array of eight elements is returned. Those elements are identical to the last eight elements returned by  <i>Text::Balanced::extract_quotelike()</i> in an array context, namely:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
[0]</dt>
<dd>
the name of the quotelike operator -- 'q', 'qq', 'm', 's', 'tr' -- if the operator was named; otherwise &quot;undef&quot;,</dd>
</dl>
<dl>
<dt>
[1]</dt>
<dd>
the left delimiter of the first block of the operation,</dd>
</dl>
<dl>
<dt>
[2]</dt>
<dd>
the text of the first block of the operation (that is, the contents of a quote, the regex of a match, or substitution or the target list of a translation),</dd>
</dl>
<dl>
<dt>
[3]</dt>
<dd>
the right delimiter of the first block of the operation,</dd>
</dl>
<dl>
<dt>
[4]</dt>
<dd>
the left delimiter of the second block of the operation if there is one (that is, if it is a &quot;s&quot;, &quot;tr&quot;, or &quot;y&quot;); otherwise &quot;undef&quot;,</dd>
</dl>
<dl>
<dt>
[5]</dt>
<dd>
the text of the second block of the operation if there is one (that is, the replacement of a substitution or the translation list of a translation); otherwise &quot;undef&quot;,</dd>
</dl>
<dl>
<dt>
[6]</dt>
<dd>
the right delimiter of the second block of the operation (if any); otherwise &quot;undef&quot;,</dd>
</dl>
<dl>
<dt>
[7]</dt>
<dd>
the trailing modifiers on the operation (if any); otherwise &quot;undef&quot;.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">
&#160;</div>
If a quote-like expression is not found, the directive fails with the usual &quot;undef&quot; value.<div style="height: 1.00em;">
&#160;</div>
The &quot;&lt;perl_variable&gt;&quot; directive can be used to parse any Perl variable: $scalar, @array, %hash, $ref-&gt;{field}[$index], etc. It does this by calling  <i>Text::Balanced::extract_variable()</i>.<div style="height: 1.00em;">
&#160;</div>
If the directive matches text representing a valid Perl variable specification, it returns that text. Otherwise it fails with the usual &quot;undef&quot; value.<div style="height: 1.00em;">
&#160;</div>
The &quot;&lt;perl_codeblock&gt;&quot; directive can be used to parse curly-brace-delimited block of Perl code, such as: { $a = 1; f() =~ m/pat/; }. It does this by calling  <i>Text::Balanced::extract_codeblock()</i>.<div style="height: 1.00em;">
&#160;</div>
If the directive matches text representing a valid Perl code block, it returns that text. Otherwise it fails with the usual &quot;undef&quot; value.<div style="height: 1.00em;">
&#160;</div>
You can also tell it what kind of brackets to use as the outermost delimiters. For example:<div style="height: 1.00em;">
&#160;</div>
<br/>
    arglist: &lt;perl_codeblock ()&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
causes an arglist to match a perl code block whose outermost delimiters are &quot;(...)&quot; (rather than the default &quot;{...}&quot;).</div>
<dl>
<dt>
Constructing tokens</dt>
<dd>
Eventually, Parse::RecDescent will be able to parse tokenized input, as well as ordinary strings. In preparation for this joyous day, the &quot;&lt;token:...&gt;&quot; directive has been provided. This directive creates a token which will be suitable for input to a Parse::RecDescent parser (when it eventually supports tokenized input).<div style="height: 1.00em;">
&#160;</div>
The text of the token is the value of the immediately preceding item in the production. A &quot;&lt;token:...&gt;&quot; directive always succeeds with a return value which is the hash reference that is the new token. It also sets the return value for the production to that hash ref.<div style="height: 1.00em;">
&#160;</div>
The &quot;&lt;token:...&gt;&quot; directive makes it easy to build a Parse::RecDescent-compatible lexer in Parse::RecDescent:<div style="height: 1.00em;">
&#160;</div>
<br/>
    my $lexer = new Parse::RecDescent q<br/>
    {<br/>
    lex:    token(s)<br/>
<br/>
    token:  /a\b/          &lt;token:INDEF&gt;<br/>
         |  /the\b/        &lt;token:DEF&gt;<br/>
         |  /fly\b/        &lt;token:NOUN,VERB&gt;<br/>
         |  /[a-z]+/i { lc $item[1] }  &lt;token:ALPHA&gt;<br/>
         |  &lt;error: Unknown token&gt;<br/>
<br/>
    };<br/>
<div style="height: 1.00em;">
&#160;</div>
which will eventually be able to be used with a regular Parse::RecDescent grammar:<div style="height: 1.00em;">
&#160;</div>
<br/>
    my $parser = new Parse::RecDescent q<br/>
    {<br/>
    startrule: subrule1 subrule 2<br/>
    <br/>
    # ETC...<br/>
    };<br/>
<div style="height: 1.00em;">
&#160;</div>
either with a pre-lexing phase:<div style="height: 1.00em;">
&#160;</div>
<br/>
    $parser-&gt;startrule( $lexer-&gt;lex($data) );<br/>
<div style="height: 1.00em;">
&#160;</div>
or with a lex-on-demand approach:<div style="height: 1.00em;">
&#160;</div>
<br/>
    $parser-&gt;startrule( sub{$lexer-&gt;token(\$data)} );<br/>
<div style="height: 1.00em;">
&#160;</div>
But at present, only the &quot;&lt;token:...&gt;&quot; directive is actually implemented. The rest is vapourware.</dd>
</dl>
<dl>
<dt>
Specifying operations</dt>
<dd>
One of the commonest requirements when building a parser is to specify binary operators. Unfortunately, in a normal grammar, the rules for such things are awkward:<div style="height: 1.00em;">
&#160;</div>
<br/>
    disjunction:    conjunction ('or' conjunction)(s?)<br/>
        { $return = [ $item[1], @{$item[2]} ] }<br/>
<br/>
    conjunction:    atom ('and' atom)(s?)<br/>
        { $return = [ $item[1], @{$item[2]} ] }<br/>
<div style="height: 1.00em;">
&#160;</div>
or inefficient:<div style="height: 1.00em;">
&#160;</div>
<br/>
    disjunction:    conjunction 'or' disjunction<br/>
        { $return = [ $item[1], @{$item[2]} ] }<br/>
       |    conjunction<br/>
        { $return = [ $item[1] ] }<br/>
<br/>
    conjunction:    atom 'and' conjunction<br/>
        { $return = [ $item[1], @{$item[2]} ] }<br/>
       |    atom<br/>
        { $return = [ $item[1] ] }<br/>
<div style="height: 1.00em;">
&#160;</div>
and either way is ugly and hard to get right.<div style="height: 1.00em;">
&#160;</div>
The &quot;&lt;leftop:...&gt;&quot; and &quot;&lt;rightop:...&gt;&quot; directives provide an easier way of specifying such operations. Using &quot;&lt;leftop:...&gt;&quot; the above examples become:<div style="height: 1.00em;">
&#160;</div>
<br/>
    disjunction:    &lt;leftop: conjunction 'or' conjunction&gt;<br/>
    conjunction:    &lt;leftop: atom 'and' atom&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
The &quot;&lt;leftop:...&gt;&quot; directive specifies a left-associative binary operator. It is specified around three other grammar elements (typically subrules or terminals), which match the left operand, the operator itself, and the right operand respectively.<div style="height: 1.00em;">
&#160;</div>
A &quot;&lt;leftop:...&gt;&quot; directive such as:<div style="height: 1.00em;">
&#160;</div>
<br/>
    disjunction:    &lt;leftop: conjunction 'or' conjunction&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
is converted to the following:<div style="height: 1.00em;">
&#160;</div>
<br/>
    disjunction:    ( conjunction ('or' conjunction)(s?)<br/>
        { $return = [ $item[1], @{$item[2]} ] } )<br/>
<div style="height: 1.00em;">
&#160;</div>
In other words, a &quot;&lt;leftop:...&gt;&quot; directive matches the left operand followed by zero or more repetitions of both the operator and the right operand. It then flattens the matched items into an anonymous array which becomes the (single) value of the entire &quot;&lt;leftop:...&gt;&quot; directive.<div style="height: 1.00em;">
&#160;</div>
For example, an &quot;&lt;leftop:...&gt;&quot; directive such as:<div style="height: 1.00em;">
&#160;</div>
<br/>
    output:  &lt;leftop: ident '&lt;&lt;' expr &gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
when given a string such as:<div style="height: 1.00em;">
&#160;</div>
<br/>
    cout &lt;&lt; var &lt;&lt; &quot;str&quot; &lt;&lt; 3<br/>
<div style="height: 1.00em;">
&#160;</div>
would match, and $item[1] would be set to:<div style="height: 1.00em;">
&#160;</div>
<br/>
    [ 'cout', 'var', '&quot;str&quot;', '3' ]<br/>
<div style="height: 1.00em;">
&#160;</div>
In other words:<div style="height: 1.00em;">
&#160;</div>
<br/>
    output:  &lt;leftop: ident '&lt;&lt;' expr &gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
is equivalent to a left-associative operator:<div style="height: 1.00em;">
&#160;</div>
<br/>
    output:  ident          { $return = [$item[1]]   }<br/>
      |  ident '&lt;&lt;' expr        { $return = [@item[1,3]]     }<br/>
      |  ident '&lt;&lt;' expr '&lt;&lt;' expr      { $return = [@item[1,3,5]]   }<br/>
      |  ident '&lt;&lt;' expr '&lt;&lt;' expr '&lt;&lt;' expr    { $return = [@item[1,3,5,7]] }<br/>
      #  ...etc...<br/>
<div style="height: 1.00em;">
&#160;</div>
Similarly, the &quot;&lt;rightop:...&gt;&quot; directive takes a left operand, an operator, and a right operand:<div style="height: 1.00em;">
&#160;</div>
<br/>
    assign:  &lt;rightop: var '=' expr &gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
and converts them to:<div style="height: 1.00em;">
&#160;</div>
<br/>
    assign:  ( (var '=' {$return=$item[1]})(s?) expr<br/>
        { $return = [ @{$item[1]}, $item[2] ] } )<br/>
<div style="height: 1.00em;">
&#160;</div>
which is equivalent to a right-associative operator:<div style="height: 1.00em;">
&#160;</div>
<br/>
    assign:  var        { $return = [$item[1]]       }<br/>
      |  var '=' expr       { $return = [@item[1,3]]     }<br/>
      |  var '=' var '=' expr   { $return = [@item[1,3,5]]   }<br/>
      |  var '=' var '=' var '=' expr   { $return = [@item[1,3,5,7]] }<br/>
      #  ...etc...<br/>
<div style="height: 1.00em;">
&#160;</div>
Note that for both the &quot;&lt;leftop:...&gt;&quot; and &quot;&lt;rightop:...&gt;&quot; directives, the directive does not normally return the operator itself, just a list of the operands involved. This is particularly handy for specifying lists:<div style="height: 1.00em;">
&#160;</div>
<br/>
    list: '(' &lt;leftop: list_item ',' list_item&gt; ')' <br/>
        { $return = $item[2] }<br/>
<div style="height: 1.00em;">
&#160;</div>
There is, however, a problem: sometimes the operator is itself significant. For example, in a Perl list a comma and a &quot;=&gt;&quot; are both valid separators, but the &quot;=&gt;&quot; has additional stringification semantics. Hence it's important to know which was used in each case.<div style="height: 1.00em;">
&#160;</div>
To solve this problem the &quot;&lt;leftop:...&gt;&quot; and &quot;&lt;rightop:...&gt;&quot; directives  <i>do</i> return the operator(s) as well, under two circumstances. The first case is where the operator is specified as a subrule. In that instance, whatever the operator matches is returned (on the assumption that if the operator is important enough to have its own subrule, then it's important enough to return).<div style="height: 1.00em;">
&#160;</div>
The second case is where the operator is specified as a regular expression. In that case, if the first bracketed subpattern of the regular expression matches, that matching value is returned (this is analogous to the behaviour of the Perl &quot;split&quot; function, except that only the first subpattern is returned).<div style="height: 1.00em;">
&#160;</div>
In other words, given the input:<div style="height: 1.00em;">
&#160;</div>
<br/>
    ( a=&gt;1, b=&gt;2 )<br/>
<div style="height: 1.00em;">
&#160;</div>
the specifications:<div style="height: 1.00em;">
&#160;</div>
<br/>
    list:      '('  &lt;leftop: list_item separator list_item&gt;  ')' <br/>
<br/>
    separator: ',' | '=&gt;'<br/>
<div style="height: 1.00em;">
&#160;</div>
or:<div style="height: 1.00em;">
&#160;</div>
<br/>
    list:      '('  &lt;leftop: list_item /(,|=&gt;)/ list_item&gt;  ')'<br/>
<div style="height: 1.00em;">
&#160;</div>
cause the list separators to be interleaved with the operands in the anonymous array in $item[2]:<div style="height: 1.00em;">
&#160;</div>
<br/>
    [ 'a', '=&gt;', '1', ',', 'b', '=&gt;', '2' ]<br/>
<div style="height: 1.00em;">
&#160;</div>
But the following version:<div style="height: 1.00em;">
&#160;</div>
<br/>
    list:      '('  &lt;leftop: list_item /,|=&gt;/ list_item&gt;  ')'<br/>
<div style="height: 1.00em;">
&#160;</div>
returns only the operators:<div style="height: 1.00em;">
&#160;</div>
<br/>
    [ 'a', '1', 'b', '2' ]<br/>
<div style="height: 1.00em;">
&#160;</div>
Of course, none of the above specifications handle the case of an empty list, since the &quot;&lt;leftop:...&gt;&quot; and &quot;&lt;rightop:...&gt;&quot; directives require at least a single right or left operand to match. To specify that the operator can match &quot;trivially&quot;, it's necessary to add a &quot;(s?)&quot; qualifier to the directive:<div style="height: 1.00em;">
&#160;</div>
<br/>
    list:      '('  &lt;leftop: list_item /(,|=&gt;)/ list_item&gt;(s?)  ')'<br/>
<div style="height: 1.00em;">
&#160;</div>
Note that in almost all the above examples, the first and third arguments of the &quot;&lt;leftop:...&gt;&quot; directive were the same subrule. That is because &quot;&lt;leftop:...&gt;&quot;'s are frequently used to specify &quot;separated&quot; lists of the same type of item. To make such lists easier to specify, the following syntax:<div style="height: 1.00em;">
&#160;</div>
<br/>
    list:   element(s /,/)<br/>
<div style="height: 1.00em;">
&#160;</div>
is exactly equivalent to:<div style="height: 1.00em;">
&#160;</div>
<br/>
    list:   &lt;leftop: element /,/ element&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
Note that the separator must be specified as a raw pattern (i.e. not a string or subrule).</dd>
</dl>
<dl>
<dt>
Scored productions</dt>
<dd>
By default, Parse::RecDescent grammar rules always accept the first production that matches the input. But if two or more productions may potentially match the same input, choosing the first that does so may not be optimal.<div style="height: 1.00em;">
&#160;</div>
For example, if you were parsing the sentence &quot;time flies like an arrow&quot;, you might use a rule like this:<div style="height: 1.00em;">
&#160;</div>
<br/>
    sentence: verb noun preposition article noun { [@item] }<br/>
    | adjective noun verb article noun   { [@item] }<br/>
    | noun verb preposition article noun { [@item] }<br/>
<div style="height: 1.00em;">
&#160;</div>
Each of these productions matches the sentence, but the third one is the most likely interpretation. However, if the sentence had been &quot;fruit flies like a banana&quot;, then the second production is probably the right match.<div style="height: 1.00em;">
&#160;</div>
To cater for such situtations, the &quot;&lt;score:...&gt;&quot; can be used. The directive is equivalent to an unconditional &quot;&lt;reject&gt;&quot;, except that it allows you to specify a &quot;score&quot; for the current production. If that score is numerically greater than the best score of any preceding production, the current production is cached for later consideration. If no later production matches, then the cached production is treated as having matched, and the value of the item immediately before its &quot;&lt;score:...&gt;&quot; directive is returned as the result.<div style="height: 1.00em;">
&#160;</div>
In other words, by putting a &quot;&lt;score:...&gt;&quot; directive at the end of each production, you can select which production matches using criteria other than specification order. For example:<div style="height: 1.00em;">
&#160;</div>
<br/>
    sentence: verb noun preposition article noun { [@item] } &lt;score: sensible(@item)&gt;<br/>
    | adjective noun verb article noun   { [@item] } &lt;score: sensible(@item)&gt;<br/>
    | noun verb preposition article noun { [@item] } &lt;score: sensible(@item)&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
Now, when each production reaches its respective &quot;&lt;score:...&gt;&quot; directive, the subroutine &quot;sensible&quot; will be called to evaluate the matched items (somehow). Once all productions have been tried, the one which &quot;sensible&quot; scored most highly will be the one that is accepted as a match for the rule.<div style="height: 1.00em;">
&#160;</div>
The variable $score always holds the current best score of any production, and the variable $score_return holds the corresponding return value.<div style="height: 1.00em;">
&#160;</div>
As another example, the following grammar matches lines that may be separated by commas, colons, or semi-colons. This can be tricky if a colon-separated line also contains commas, or vice versa. The grammar resolves the ambiguity by selecting the rule that results in the fewest fields:<div style="height: 1.00em;">
&#160;</div>
<br/>
    line: seplist[sep=&gt;',']  &lt;score: -@{$item[1]}&gt;<br/>
    | seplist[sep=&gt;':']  &lt;score: -@{$item[1]}&gt;<br/>
    | seplist[sep=&gt;&quot; &quot;]  &lt;score: -@{$item[1]}&gt;<br/>
<br/>
    seplist: &lt;skip:&quot;&quot;&gt; &lt;leftop: /[^$arg{sep}]*/ &quot;$arg{sep}&quot; /[^$arg{sep}]*/&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
Note the use of negation within the &quot;&lt;score:...&gt;&quot; directive to ensure that the seplist with the most items gets the lowest score.<div style="height: 1.00em;">
&#160;</div>
As the above examples indicate, it is often the case that all productions in a rule use exactly the same &quot;&lt;score:...&gt;&quot; directive. It is tedious to have to repeat this identical directive in every production, so Parse::RecDescent also provides the &quot;&lt;autoscore:...&gt;&quot; directive.<div style="height: 1.00em;">
&#160;</div>
If an &quot;&lt;autoscore:...&gt;&quot; directive appears in any production of a rule, the code it specifies is used as the scoring code for every production of that rule, except productions that already end with an explicit &quot;&lt;score:...&gt;&quot; directive. Thus the rules above could be rewritten:<div style="height: 1.00em;">
&#160;</div>
<br/>
    line: &lt;autoscore: -@{$item[1]}&gt;<br/>
    line: seplist[sep=&gt;','] <br/>
    | seplist[sep=&gt;':']<br/>
    | seplist[sep=&gt;&quot; &quot;]<br/>
    <br/>
<br/>
    sentence: &lt;autoscore: sensible(@item)&gt;<br/>
    | verb noun preposition article noun { [@item] }<br/>
    | adjective noun verb article noun   { [@item] }<br/>
    | noun verb preposition article noun { [@item] }<br/>
<div style="height: 1.00em;">
&#160;</div>
Note that the &quot;&lt;autoscore:...&gt;&quot; directive itself acts as an unconditional &quot;&lt;reject&gt;&quot;, and (like the &quot;&lt;rulevar:...&gt;&quot; directive) is pruned at compile-time wherever possible.</dd>
</dl>
<dl>
<dt>
Dispensing with grammar checks</dt>
<dd>
During the compilation phase of parser construction, Parse::RecDescent performs a small number of checks on the grammar it's given. Specifically it checks that the grammar is not left-recursive, that there are no &quot;insatiable&quot; constructs of the form:<div style="height: 1.00em;">
&#160;</div>
<br/>
    rule: subrule(s) subrule<br/>
<div style="height: 1.00em;">
&#160;</div>
and that there are no rules missing (i.e. referred to, but never defined).<div style="height: 1.00em;">
&#160;</div>
These checks are important during development, but can slow down parser construction in stable code. So Parse::RecDescent provides the &lt;nocheck&gt; directive to turn them off. The directive can only appear before the first rule definition, and switches off checking throughout the rest of the current grammar.<div style="height: 1.00em;">
&#160;</div>
Typically, this directive would be added when a parser has been thoroughly tested and is ready for release.</dd>
</dl>
</div>
<div class="subsection">
<h2>Subrule argument lists</h2> It is occasionally useful to pass data to a subrule which is being invoked. For example, consider the following grammar fragment:<div class="spacer">
</div>
<br/>
    classdecl: keyword decl<br/>
<br/>
    keyword:   'struct' | 'class';<br/>
<br/>
    decl:      # WHATEVER<br/>
<div class="spacer">
</div>
The &quot;decl&quot; rule might wish to know which of the two keywords was used (since it may affect some aspect of the way the subsequent declaration is interpreted). &quot;Parse::RecDescent&quot; allows the grammar designer to pass data into a rule, by placing that data in an  <i>argument list</i> (that is, in square brackets) immediately after any subrule item in a production. Hence, we could pass the keyword to &quot;decl&quot; as follows:<div class="spacer">
</div>
<br/>
    classdecl: keyword decl[ $item[1] ]<br/>
<br/>
    keyword:   'struct' | 'class';<br/>
<br/>
    decl:      # WHATEVER<br/>
<div class="spacer">
</div>
The argument list can consist of any number (including zero!) of comma-separated Perl expressions. In other words, it looks exactly like a Perl anonymous array reference. For example, we could pass the keyword, the name of the surrounding rule, and the literal 'keyword' to &quot;decl&quot; like so:<div class="spacer">
</div>
<br/>
    classdecl: keyword decl[$item[1],$item[0],'keyword']<br/>
<br/>
    keyword:   'struct' | 'class';<br/>
<br/>
    decl:      # WHATEVER<br/>
<div class="spacer">
</div>
Within the rule to which the data is passed (&quot;decl&quot; in the above examples) that data is available as the elements of a local variable @arg. Hence &quot;decl&quot; might report its intentions as follows:<div class="spacer">
</div>
<br/>
    classdecl: keyword decl[$item[1],$item[0],'keyword']<br/>
<br/>
    keyword:   'struct' | 'class';<br/>
<br/>
    decl:      { print &quot;Declaring $arg[0] (a $arg[2])\n&quot;;<br/>
         print &quot;(this rule called by $arg[1])&quot; }<br/>
<div class="spacer">
</div>
Subrule argument lists can also be interpreted as hashes, simply by using the local variable %arg instead of @arg. Hence we could rewrite the previous example:<div class="spacer">
</div>
<br/>
    classdecl: keyword decl[keyword =&gt; $item[1],<br/>
        caller  =&gt; $item[0],<br/>
        type    =&gt; 'keyword']<br/>
<br/>
    keyword:   'struct' | 'class';<br/>
<br/>
    decl:      { print &quot;Declaring $arg{keyword} (a $arg{type})\n&quot;;<br/>
         print &quot;(this rule called by $arg{caller})&quot; }<br/>
<div class="spacer">
</div>
Both @arg and %arg are always available, so the grammar designer may choose whichever convention (or combination of conventions) suits best.<div class="spacer">
</div>
Subrule argument lists are also useful for creating &quot;rule templates&quot; (especially when used in conjunction with the &quot;&lt;matchrule:...&gt;&quot; directive). For example, the subrule:<div class="spacer">
</div>
<br/>
    list:     &lt;matchrule:$arg{rule}&gt; /$arg{sep}/ list[%arg]<br/>
        { $return = [ $item[1], @{$item[3]} ] }<br/>
    |     &lt;matchrule:$arg{rule}&gt;<br/>
        { $return = [ $item[1]] }<br/>
<div class="spacer">
</div>
is a handy template for the common problem of matching a separated list. For example:<div class="spacer">
</div>
<br/>
    function: 'func' name '(' list[rule=&gt;'param',sep=&gt;';'] ')'<br/>
<br/>
    param:    list[rule=&gt;'name',sep=&gt;','] ':' typename<br/>
<br/>
    name:     /\w+/<br/>
<br/>
    typename: name<br/>
<div class="spacer">
</div>
When a subrule argument list is used with a repeated subrule, the argument list goes  <i>before</i> the repetition specifier:<div class="spacer">
</div>
<br/>
    list:   /some|many/ thing[ $item[1] ](s)<br/>
<div class="spacer">
</div>
The argument list is &quot;late bound&quot;. That is, it is re-evaluated for every repetition of the repeated subrule. This means that each repeated attempt to match the subrule may be passed a completely different set of arguments if the value of the expression in the argument list changes between attempts. So, for example, the grammar:<div class="spacer">
</div>
<br/>
    { $::species = 'dogs' }<br/>
<br/>
    pair:   'two' animal[$::species](s)<br/>
<br/>
    animal: /$arg[0]/ { $::species = 'cats' }<br/>
<div class="spacer">
</div>
will match the string &quot;two dogs cats cats&quot; completely, whereas it will only match the string &quot;two dogs dogs dogs&quot; up to the eighth letter. If the value of the argument list were &quot;early bound&quot; (that is, evaluated only the first time a repeated subrule match is attempted), one would expect the matching behaviours to be reversed.<div class="spacer">
</div>
Of course, it is possible to effectively &quot;early bind&quot; such argument lists by passing them a value which does not change on each repetition. For example:<div class="spacer">
</div>
<br/>
    { $::species = 'dogs' }<br/>
<br/>
    pair:   'two' { $::species } animal[$item[2]](s)<br/>
<br/>
    animal: /$arg[0]/ { $::species = 'cats' }<br/>
<div class="spacer">
</div>
Arguments can also be passed to the start rule, simply by appending them to the argument list with which the start rule is called ( <i>after</i> the &quot;line number&quot; parameter). For example, given:<div class="spacer">
</div>
<br/>
    $parser = new Parse::RecDescent ( $grammar );<br/>
<br/>
    $parser-&gt;data($text, 1, &quot;str&quot;, 2, \@arr);<br/>
<br/>
    #         ^^^^^  ^  ^^^^^^^^^^^^^^^<br/>
    #       |    |     |<br/>
    # TEXT TO BE PARSED  |     |<br/>
    # STARTING LINE NUMBER     |<br/>
    # ELEMENTS OF @arg WHICH IS PASSED TO RULE data<br/>
<div class="spacer">
</div>
then within the productions of the rule &quot;data&quot;, the array @arg will contain &quot;(&quot;str&quot;, 2, \@arr)&quot;.</div>
<div class="subsection">
<h2>Alternations</h2> Alternations are implicit (unnamed) rules defined as part of a production. An alternation is defined as a series of '|'-separated productions inside a pair of round brackets. For example:<div class="spacer">
</div>
<br/>
    character: 'the' ( good | bad | ugly ) /dude/<br/>
<div class="spacer">
</div>
Every alternation implicitly defines a new subrule, whose automatically-generated name indicates its origin: &quot;_alternation_&lt;I&gt;_of_production_&lt;P&gt;_of_rule&lt;R&gt;&quot; for the appropriate values of &lt;I&gt;, &lt;P&gt;, and &lt;R&gt;. A call to this implicit subrule is then inserted in place of the brackets. Hence the above example is merely a convenient short-hand for:<div class="spacer">
</div>
<br/>
    character: 'the'<br/>
       _alternation_1_of_production_1_of_rule_character<br/>
       /dude/<br/>
<br/>
    _alternation_1_of_production_1_of_rule_character:<br/>
       good | bad | ugly<br/>
<div class="spacer">
</div>
Since alternations are parsed by recursively calling the parser generator, any type(s) of item can appear in an alternation. For example:<div class="spacer">
</div>
<br/>
    character: 'the' ( 'high' &quot;plains&quot;  # Silent, with poncho<br/>
         | /no[- ]name/ # Silent, no poncho<br/>
         | vengeance_seeking    # Poncho-optional<br/>
         | &lt;error&gt;      <br/>
         ) drifter<br/>
<div class="spacer">
</div>
In this case, if an error occurred, the automatically generated message would be:<div class="spacer">
</div>
<br/>
    ERROR (line &lt;N&gt;): Invalid implicit subrule: Expected<br/>
          'high' or /no[- ]name/ or generic,<br/>
          but found &quot;pacifist&quot; instead<br/>
<div class="spacer">
</div>
Since every alternation actually has a name, it's even possible to extend or replace them:<div class="spacer">
</div>
<br/>
    parser-&gt;Replace(<br/>
    &quot;_alternation_1_of_production_1_of_rule_character:<br/>
        'generic Eastwood'&quot;<br/>
        );<br/>
<div class="spacer">
</div>
More importantly, since alternations are a form of subrule, they can be given repetition specifiers:<div class="spacer">
</div>
<br/>
    character: 'the' ( good | bad | ugly )(?) /dude/<br/>
</div>
<div class="subsection">
<h2>Incremental Parsing</h2> &quot;Parse::RecDescent&quot; provides two methods - &quot;Extend&quot; and &quot;Replace&quot; - which can be used to alter the grammar matched by a parser. Both methods take the same argument as &quot;Parse::RecDescent::new&quot;, namely a grammar specification string<div class="spacer">
</div>
&quot;Parse::RecDescent::Extend&quot; interprets the grammar specification and adds any productions it finds to the end of the rules for which they are specified. For example:<div class="spacer">
</div>
<br/>
    $add = &quot;name: 'Jimmy-Bob' | 'Bobby-Jim'\ndesc: colour /necks?/&quot;;<br/>
    parser-&gt;Extend($add);<br/>
<div class="spacer">
</div>
adds two productions to the rule &quot;name&quot; (creating it if necessary) and one production to the rule &quot;desc&quot;.<div class="spacer">
</div>
&quot;Parse::RecDescent::Replace&quot; is identical, except that it first resets are rule specified in the additional grammar, removing any existing productions. Hence after:<div class="spacer">
</div>
<br/>
    $add = &quot;name: 'Jimmy-Bob' | 'Bobby-Jim'\ndesc: colour /necks?/&quot;;<br/>
    parser-&gt;Replace($add);<br/>
<div class="spacer">
</div>
are are <i>only</i> valid &quot;name&quot;s and the one possible description.<div class="spacer">
</div>
A more interesting use of the &quot;Extend&quot; and &quot;Replace&quot; methods is to call them inside the action of an executing parser. For example:<div class="spacer">
</div>
<br/>
    typedef: 'typedef' type_name identifier ';'<br/>
           { $thisparser-&gt;Extend(&quot;type_name: '$item[3]'&quot;) }<br/>
       | &lt;error&gt;<br/>
<br/>
    identifier: ...!type_name /[A-Za-z_]w*/<br/>
<div class="spacer">
</div>
which automatically prevents type names from being typedef'd, or:<div class="spacer">
</div>
<br/>
    command: 'map' key_name 'to' abort_key<br/>
           { $thisparser-&gt;Replace(&quot;abort_key: '$item[2]'&quot;) }<br/>
       | 'map' key_name 'to' key_name<br/>
           { map_key($item[2],$item[4]) }<br/>
       | abort_key<br/>
           { exit if confirm(&quot;abort?&quot;) }<br/>
<br/>
    abort_key: 'q'<br/>
<br/>
    key_name: ...!abort_key /[A-Za-z]/<br/>
<div class="spacer">
</div>
which allows the user to change the abort key binding, but not to unbind it.<div class="spacer">
</div>
The careful use of such constructs makes it possible to reconfigure a a running parser, eliminating the need for semantic feedback by providing syntactic feedback instead. However, as currently implemented, &quot;Replace()&quot; and &quot;Extend()&quot; have to regenerate and re-&quot;eval&quot; the entire parser whenever they are called. This makes them quite slow for large grammars.<div class="spacer">
</div>
In such cases, the judicious use of an interpolated regex is likely to be far more efficient:<div class="spacer">
</div>
<br/>
    typedef: 'typedef' type_name/ identifier ';'<br/>
           { $thisparser-&gt;{local}{type_name} .= &quot;|$item[3]&quot; }<br/>
       | &lt;error&gt;<br/>
<br/>
    identifier: ...!type_name /[A-Za-z_]w*/<br/>
<br/>
    type_name: /$thisparser-&gt;{local}{type_name}/<br/>
</div>
<div class="subsection">
<h2>Precompiling parsers</h2> Normally Parse::RecDescent builds a parser from a grammar at run-time. That approach simplifies the design and implementation of parsing code, but has the disadvantage that it slows the parsing process down - you have to wait for Parse::RecDescent to build the parser every time the program runs. Long or complex grammars can be particularly slow to build, leading to unacceptable delays at start-up.<div class="spacer">
</div>
To overcome this, the module provides a way of &quot;pre-building&quot; a parser object and saving it in a separate module. That module can then be used to create clones of the original parser.<div class="spacer">
</div>
A grammar may be precompiled using the &quot;Precompile&quot; class method. For example, to precompile a grammar stored in the scalar $grammar, and produce a class named PreGrammar in a module file named PreGrammar.pm, you could use:<div class="spacer">
</div>
<br/>
    use Parse::RecDescent;<br/>
<br/>
    Parse::RecDescent-&gt;Precompile($grammar, &quot;PreGrammar&quot;);<br/>
<div class="spacer">
</div>
The first argument is the grammar string, the second is the name of the class to be built. The name of the module file is generated automatically by appending &quot;.pm&quot; to the last element of the class name. Thus<div class="spacer">
</div>
<br/>
    Parse::RecDescent-&gt;Precompile($grammar, &quot;My::New::Parser&quot;);<br/>
<div class="spacer">
</div>
would produce a module file named Parser.pm.<div class="spacer">
</div>
It is somewhat tedious to have to write a small Perl program just to generate a precompiled grammar class, so Parse::RecDescent has some special magic that allows you to do the job directly from the command-line.<div class="spacer">
</div>
If your grammar is specified in a file named <i>grammar</i>, you can generate a class named Yet::Another::Grammar like so:<div class="spacer">
</div>
<br/>
    &gt; perl -MParse::RecDescent - grammar Yet::Another::Grammar<br/>
<div class="spacer">
</div>
This would produce a file named <i>Grammar.pm</i> containing the full definition of a class called Yet::Another::Grammar. Of course, to use that class, you would need to put the  <i>Grammar.pm</i> file in a directory named  <i>Yet/Another</i>, somewhere in your Perl include path.<div class="spacer">
</div>
Having created the new class, it's very easy to use it to build a parser. You simply &quot;use&quot; the new module, and then call its &quot;new&quot; method to create a parser object. For example:<div class="spacer">
</div>
<br/>
    use Yet::Another::Grammar;<br/>
    my $parser = Yet::Another::Grammar-&gt;new();<br/>
<div class="spacer">
</div>
The effect of these two lines is exactly the same as:<div class="spacer">
</div>
<br/>
    use Parse::RecDescent;<br/>
<br/>
    open GRAMMAR_FILE, &quot;grammar&quot; or die;<br/>
    local $/;<br/>
    my $grammar = &lt;GRAMMAR_FILE&gt;;<br/>
<br/>
    my $parser = Parse::RecDescent-&gt;new($grammar);<br/>
<div class="spacer">
</div>
only considerably faster.<div class="spacer">
</div>
Note however that the parsers produced by either approach are exactly the same, so whilst precompilation has an effect on  <i>set-up</i> speed, it has no effect on  <i>parsing</i> speed. RecDescent 2.0 will address that problem.</div>
</div>
<div class="section">
<h1>GOTCHAS</h1> This section describes common mistakes that grammar writers seem to make on a regular basis.<div class="subsection">
<h2>1. Expecting an error to always invalidate a parse</h2> A common mistake when using error messages is to write the grammar like this:<div class="spacer">
</div>
<br/>
    file: line(s)<br/>
<br/>
    line: line_type_1<br/>
    | line_type_2<br/>
    | line_type_3<br/>
    | &lt;error&gt;<br/>
<div class="spacer">
</div>
The expectation seems to be that any line that is not of type 1, 2 or 3 will invoke the &quot;&lt;error&gt;&quot; directive and thereby cause the parse to fail.<div class="spacer">
</div>
Unfortunately, that only happens if the error occurs in the very first line. The first rule states that a &quot;file&quot; is matched by one or more lines, so if even a single line succeeds, the first rule is completely satisfied and the parse as a whole succeeds. That means that any error messages generated by subsequent failures in the &quot;line&quot; rule are quietly ignored.<div class="spacer">
</div>
Typically what's really needed is this:<div class="spacer">
</div>
<br/>
    file: line(s) eofile    { $return = $item[1] }<br/>
<br/>
    line: line_type_1<br/>
    | line_type_2<br/>
    | line_type_3<br/>
    | &lt;error&gt;<br/>
<br/>
    eofile: /^\Z/<br/>
<div class="spacer">
</div>
The addition of the &quot;eofile&quot; subrule  to the first production means that a file only matches a series of successful &quot;line&quot; matches  <i>that consume the</i>  <i>complete input text</i>. If any input text remains after the lines are matched, there must have been an error in the last &quot;line&quot;. In that case the &quot;eofile&quot; rule will fail, causing the entire &quot;file&quot; rule to fail too.<div class="spacer">
</div>
Note too that &quot;eofile&quot; must match &quot;/^\Z/&quot; (end-of-text), <i>not</i> &quot;/^\cZ/&quot; or &quot;/^\cD/&quot; (end-of-file).<div class="spacer">
</div>
And don't forget the action at the end of the production. If you just write:<div class="spacer">
</div>
<br/>
    file: line(s) eofile<br/>
<div class="spacer">
</div>
then the value returned by the &quot;file&quot; rule will be the value of its last item: &quot;eofile&quot;. Since &quot;eofile&quot; always returns an empty string on success, that will cause the &quot;file&quot; rule to return that empty string. Apart from returning the wrong value, returning an empty string will trip up code such as:<div class="spacer">
</div>
<br/>
    $parser-&gt;file($filetext) || die;<br/>
<div class="spacer">
</div>
(since &quot;&quot; is false).<div class="spacer">
</div>
Remember that Parse::RecDescent returns undef on failure, so the only safe test for failure is:<div class="spacer">
</div>
<br/>
    defined($parser-&gt;file($filetext)) || die;<br/>
</div>
<div class="subsection">
<h2>2. Using a &quot;return&quot; in an action</h2> An action is like a &quot;do&quot; block inside the subroutine implementing the surrounding rule. So if you put a &quot;return&quot; statement in an action:<div class="spacer">
</div>
<br/>
    range: '(' start '..' end )'<br/>
        { return $item{end} }<br/>
       /\s+/<br/>
<div class="spacer">
</div>
that subroutine will immediately return, without checking the rest of the items in the current production (e.g. the &quot;/\s+/&quot;) and without setting up the necessary data structures to tell the parser that the rule has succeeded.<div class="spacer">
</div>
The correct way to set a return value in an action is to set the $return variable:<div class="spacer">
</div>
<br/>
    range: '(' start '..' end )'<br/>
        { $return = $item{end} }<br/>
       /\s+/<br/>
</div>
</div>
<div class="section">
<h1>DIAGNOSTICS</h1> Diagnostics are intended to be self-explanatory (particularly if you use  <b>-RD_HINT</b> (under <b>perl -s</b>) or define $::RD_HINT inside the program).<div class="spacer">
</div>
&quot;Parse::RecDescent&quot; currently diagnoses the following:<dl>
<dt>
&#8226;</dt>
<dd>
Invalid regular expressions used as pattern terminals (fatal error).</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Invalid Perl code in code blocks (fatal error).</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Lookahead used in the wrong place or in a nonsensical way (fatal error).</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;Obvious&quot; cases of left-recursion (fatal error).</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Missing or extra components in a &quot;&lt;leftop&gt;&quot; or &quot;&lt;rightop&gt;&quot; directive.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Unrecognisable components in the grammar specification (fatal error).</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;Orphaned&quot; rule components specified before the first rule (fatal error) or after an &quot;&lt;error&gt;&quot; directive (level 3 warning).</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Missing rule definitions (this only generates a level 3 warning, since you may be providing them later via &quot;Parse::RecDescent::Extend()&quot;).</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Instances where greedy repetition behaviour will almost certainly cause the failure of a production (a level 3 warning - see &quot;ON-GOING ISSUES AND FUTURE DIRECTIONS&quot; below).</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Attempts to define rules named 'Replace' or 'Extend', which cannot be called directly through the parser object because of the predefined meaning of &quot;Parse::RecDescent::Replace&quot; and &quot;Parse::RecDescent::Extend&quot;. (Only a level 2 warning is generated, since such rules  <i>can</i> still be used as subrules).</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Productions which consist of a single &quot;&lt;error?&gt;&quot; directive, and which therefore may succeed unexpectedly (a level 2 warning, since this might conceivably be the desired effect).</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Multiple consecutive lookahead specifiers (a level 1 warning only, since their effects simply accumulate).</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Productions which start with a &quot;&lt;reject&gt;&quot; or &quot;&lt;rulevar:...&gt;&quot; directive. Such productions are optimized away (a level 1 warning).</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Rules which are autogenerated under $::AUTOSTUB (a level 1 warning).</dd>
</dl>
</div>
<div class="section">
<h1>AUTHOR</h1> Damian Conway (damian@conway.org)</div>
<div class="section">
<h1>BUGS AND IRRITATIONS</h1> There are undoubtedly serious bugs lurking somewhere in this much code :-) Bug reports and other feedback are most welcome.<div class="spacer">
</div>
Ongoing annoyances include:<dl>
<dt>
&#8226;</dt>
<dd>
There's no support for parsing directly from an input stream. If and when the Perl Gods give us regular expressions on streams, this should be trivial (ahem!) to implement.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
The parser generator can get confused if actions aren't properly closed or if they contain particularly nasty Perl syntax errors (especially unmatched curly brackets).</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
The generator only detects the most obvious form of left recursion (potential recursion on the first subrule in a rule). More subtle forms of left recursion (for example, through the second item in a rule after a &quot;zero&quot; match of a preceding &quot;zero-or-more&quot; repetition, or after a match of a subrule with an empty production) are not found.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Instead of complaining about left-recursion, the generator should silently transform the grammar to remove it. Don't expect this feature any time soon as it would require a more sophisticated approach to parser generation than is currently used.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
The generated parsers don't always run as fast as might be wished.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
The meta-parser should be bootstrapped using &quot;Parse::RecDescent&quot; :-)</dd>
</dl>
</div>
<div class="section">
<h1>ON-GOING ISSUES AND FUTURE DIRECTIONS</h1><dl>
<dt>
1.</dt>
<dd>
Repetitions are &quot;incorrigibly greedy&quot; in that they will eat everything they can and won't backtrack if that behaviour causes a production to fail needlessly. So, for example:<div style="height: 1.00em;">
&#160;</div>
<br/>
    rule: subrule(s) subrule<br/>
<div style="height: 1.00em;">
&#160;</div>
will <i>never</i> succeed, because the repetition will eat all the subrules it finds, leaving none to match the second item. Such constructions are relatively rare (and &quot;Parse::RecDescent::new&quot; generates a warning whenever they occur) so this may not be a problem, especially since the insatiable behaviour can be overcome &quot;manually&quot; by writing:<div style="height: 1.00em;">
&#160;</div>
<br/>
    rule: penultimate_subrule(s) subrule<br/>
<br/>
    penultimate_subrule: subrule ...subrule<br/>
<div style="height: 1.00em;">
&#160;</div>
The issue is that this construction is exactly twice as expensive as the original, whereas backtracking would add only 1/ <i>N</i> to the cost (for matching  <i>N</i> repetitions of &quot;subrule&quot;). I would welcome feedback on the need for backtracking; particularly on cases where the lack of it makes parsing performance problematical.</dd>
</dl>
<dl>
<dt>
2.</dt>
<dd>
Having opened that can of worms, it's also necessary to consider whether there is a need for non-greedy repetition specifiers. Again, it's possible (at some cost) to manually provide the required functionality:<div style="height: 1.00em;">
&#160;</div>
<br/>
    rule: nongreedy_subrule(s) othersubrule<br/>
<br/>
    nongreedy_subrule: subrule ...!othersubrule<br/>
<div style="height: 1.00em;">
&#160;</div>
Overall, the issue is whether the benefit of this extra functionality outweighs the drawbacks of further complicating the (currently minimalist) grammar specification syntax, and (worse) introducing more overhead into the generated parsers.</dd>
</dl>
<dl>
<dt>
3.</dt>
<dd>
An &quot;&lt;autocommit&gt;&quot; directive would be nice. That is, it would be useful to be able to say:<div style="height: 1.00em;">
&#160;</div>
<br/>
    command: &lt;autocommit&gt;<br/>
    command: 'find' name<br/>
       | 'find' address<br/>
       | 'do' command 'at' time 'if' condition<br/>
       | 'do' command 'at' time<br/>
       | 'do' command<br/>
       | unusual_command<br/>
<div style="height: 1.00em;">
&#160;</div>
and have the generator work out that this should be &quot;pruned&quot; thus:<div style="height: 1.00em;">
&#160;</div>
<br/>
    command: 'find' name<br/>
       | 'find' &lt;commit&gt; address<br/>
       | 'do' &lt;commit&gt; command &lt;uncommit&gt;<br/>
        'at' time<br/>
        'if' &lt;commit&gt; condition<br/>
       | 'do' &lt;commit&gt; command &lt;uncommit&gt;<br/>
        'at' &lt;commit&gt; time<br/>
       | 'do' &lt;commit&gt; command<br/>
       | unusual_command<br/>
<div style="height: 1.00em;">
&#160;</div>
There are several issues here. Firstly, should the &quot;&lt;autocommit&gt;&quot; automatically install an &quot;&lt;uncommit&gt;&quot; at the start of the last production (on the grounds that the &quot;command&quot; rule doesn't know whether an &quot;unusual_command&quot; might start with &quot;find&quot; or &quot;do&quot;) or should the &quot;unusual_command&quot; subgraph be analysed (to see if it  <i>might</i> be viable after a &quot;find&quot; or &quot;do&quot;)?<div style="height: 1.00em;">
&#160;</div>
The second issue is how regular expressions should be treated. The simplest approach would be simply to uncommit before them (on the grounds that they  <i>might</i> match). Better efficiency would be obtained by analyzing all preceding literal tokens to determine whether the pattern would match them.<div style="height: 1.00em;">
&#160;</div>
Overall, the issues are: can such automated &quot;pruning&quot; approach a hand-tuned version sufficiently closely to warrant the extra set-up expense, and (more importantly) is the problem important enough to even warrant the non-trivial effort of building an automated solution?</dd>
</dl>
</div>
<div class="section">
<h1>SUPPORT</h1><div class="subsection">
<h2>Mailing List</h2> Visit &lt;http://www.perlfoundation.org/perl5/index.cgi?parse_recdescent&gt; to sign up for the mailing list.<div class="spacer">
</div>
&lt;http://www.PerlMonks.org&gt; is also a good place to ask questions.</div>
<div class="subsection">
<h2>FAQ</h2> Visit Parse::RecDescent::FAQ for answers to frequently (and not so frequently) asked questions about Parse::RecDescent</div>
</div>
<div class="section">
<h1>SEE ALSO</h1> Regexp::Grammars provides Parse::RecDescent style parsing using native Perl 5.10 regular expressions.</div>
<div class="section">
<h1>LICENCE AND COPYRIGHT</h1> Copyright (c) 1997-2007, Damian Conway &quot;&lt;DCONWAY@CPAN.org&gt;&quot;. All rights reserved.<div class="spacer">
</div>
This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself. See perlartistic.</div>
<div class="section">
<h1>DISCLAIMER OF WARRANTY</h1> BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE SOFTWARE &quot;AS IS&quot; WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR, OR CORRECTION.<div class="spacer">
</div>
IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.</div>
<table class="foot">
<tr>
<td class="foot-date">
2010-04-04</td>
<td class="foot-os">
perl v5.10.1</td>
</tr>
</table>
</div>
</body>
</html>

