<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Module::Build::Cookbook(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Module::Build::Cookbook(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
Module::Build::Cookbook(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Module::Build::Cookbook - Examples of Module::Build Usage</div>
<div class="section">
<h1>DESCRIPTION</h1> &quot;Module::Build&quot; isn't conceptually very complicated, but examples are always helpful.  The following recipes should help developers and/or installers put together the pieces from the other parts of the documentation.</div>
<div class="section">
<h1>BASIC RECIPES</h1><div class="subsection">
<h2>Installing modules that use Module::Build</h2> In most cases, you can just issue the following commands:<div class="spacer">
</div>
<br/>
  perl Build.PL<br/>
  ./Build<br/>
  ./Build test<br/>
  ./Build install<br/>
<div class="spacer">
</div>
There's nothing complicated here - first you're running a script called  <i>Build.PL</i>, then you're running a (newly-generated) script called  <i>Build</i> and passing it various arguments.<div class="spacer">
</div>
The exact commands may vary a bit depending on how you invoke perl scripts on your system.  For instance, if you have multiple versions of perl installed, you can install to one particular perl's library directories like so:<div class="spacer">
</div>
<br/>
  /usr/bin/perl5.8.1 Build.PL<br/>
  ./Build<br/>
  ./Build test<br/>
  ./Build install<br/>
<div class="spacer">
</div>
If you're on Windows where the current directory is always searched first for scripts, you'll probably do something like this:<div class="spacer">
</div>
<br/>
  perl Build.PL<br/>
  Build<br/>
  Build test<br/>
  Build install<br/>
<div class="spacer">
</div>
On the old Mac OS (version 9 or lower) using MacPerl, you can double-click on the  <i>Build.PL</i> script to create the <i>Build</i> script, then double-click on the  <i>Build</i> script to run its &quot;build&quot;, &quot;test&quot;, and &quot;install&quot; actions.<div class="spacer">
</div>
The <i>Build</i> script knows what perl was used to run <i>Build.PL</i>, so you don't need to re-invoke the  <i>Build</i> script with the complete perl path each time.  If you invoke it with the  <i>wrong</i> perl path, you'll get a warning or a fatal error.</div>
<div class="subsection">
<h2>Modifying Config.pm values</h2> &quot;Module::Build&quot; relies heavily on various values from perl's &quot;Config.pm&quot; to do its work.  For example, default installation paths are given by &quot;installsitelib&quot; and &quot;installvendorman3dir&quot; and friends, C linker &amp; compiler settings are given by &quot;ld&quot;, &quot;lddlflags&quot;, &quot;cc&quot;, &quot;ccflags&quot;, and so on.   <i>If you're pretty sure</i>  <i>you know what you're doing</i>, you can tell &quot;Module::Build&quot; to pretend there are different values in  <i>Config.pm</i> than what's really there, by passing arguments for the &quot;--config&quot; parameter on the command line:<div class="spacer">
</div>
<br/>
  perl Build.PL --config cc=gcc --config ld=gcc<br/>
<div class="spacer">
</div>
Inside the &quot;Build.PL&quot; script the same thing can be accomplished by passing values for the &quot;config&quot; parameter to &quot;new()&quot;:<div class="spacer">
</div>
<br/>
 my $build = Module::Build-&gt;new<br/>
   (<br/>
    ...<br/>
    config =&gt; { cc =&gt; 'gcc', ld =&gt; 'gcc' },<br/>
    ...<br/>
   );<br/>
<div class="spacer">
</div>
In custom build code, the same thing can be accomplished by calling the &quot;config&quot; in Module::Build method:<div class="spacer">
</div>
<br/>
 $build-&gt;config( cc =&gt; 'gcc' );     # Set<br/>
 $build-&gt;config( ld =&gt; 'gcc' );     # Set<br/>
 ...<br/>
 my $linker = $build-&gt;config('ld'); # Get<br/>
</div>
<div class="subsection">
<h2>Installing modules using the programmatic interface</h2> If you need to build, test, and/or install modules from within some other perl code (as opposed to having the user type installation commands at the shell), you can use the programmatic interface. Create a Module::Build object (or an object of a custom Module::Build subclass) and then invoke its &quot;dispatch()&quot; method to run various actions.<div class="spacer">
</div>
<br/>
  my $build = Module::Build-&gt;new<br/>
    (<br/>
     module_name =&gt; 'Foo::Bar',<br/>
     license     =&gt; 'perl',<br/>
     requires    =&gt; { 'Some::Module'   =&gt; '1.23' },<br/>
    );<br/>
  $build-&gt;dispatch('build');<br/>
  $build-&gt;dispatch('test', verbose =&gt; 1);<br/>
  $build-&gt;dispatch('install');<br/>
<div class="spacer">
</div>
The first argument to &quot;dispatch()&quot; is the name of the action, and any following arguments are named parameters.<div class="spacer">
</div>
This is the interface we use to test Module::Build itself in the regression tests.</div>
<div class="subsection">
<h2>Installing to a temporary directory</h2> To create packages for package managers like RedHat's &quot;rpm&quot; or Debian's &quot;deb&quot;, you may need to install to a temporary directory first and then create the package from that temporary installation. To do this, specify the &quot;destdir&quot; parameter to the &quot;install&quot; action:<div class="spacer">
</div>
<br/>
  ./Build install --destdir /tmp/my-package-1.003<br/>
<div class="spacer">
</div>
This essentially just prepends all the installation paths with the  <i>/tmp/my-package-1.003</i> directory.</div>
<div class="subsection">
<h2>Installing to a non-standard directory</h2> To install to a non-standard directory (for example, if you don't have permission to install in the system-wide directories), you can use the &quot;install_base&quot; or &quot;prefix&quot; parameters:<div class="spacer">
</div>
<br/>
  ./Build install --install_base /foo/bar<br/>
<div class="spacer">
</div>
See &quot;INSTALL PATHS&quot; in Module::Build for a much more complete discussion of how installation paths are determined.</div>
<div class="subsection">
<h2>Installing in the same location as ExtUtils::MakeMaker</h2> With the introduction of &quot;--prefix&quot; in Module::Build 0.28 and &quot;INSTALL_BASE&quot; in &quot;ExtUtils::MakeMaker&quot; 6.31 its easy to get them both to install to the same locations.<div class="spacer">
</div>
First, ensure you have at least version 0.28 of Module::Build installed and 6.31 of &quot;ExtUtils::MakeMaker&quot;.  Prior versions have differing (and in some cases quite strange) installation behaviors.<div class="spacer">
</div>
The following installation flags are equivalent between &quot;ExtUtils::MakeMaker&quot; and &quot;Module::Build&quot;.<div class="spacer">
</div>
<br/>
    MakeMaker             Module::Build<br/>
    PREFIX=...            --prefix ...<br/>
    INSTALL_BASE=...      --install_base ...<br/>
    DESTDIR=...           --destdir ...<br/>
    LIB=...               --install_path lib=...<br/>
    INSTALLDIRS=...       --installdirs ...<br/>
    INSTALLDIRS=perl      --installdirs core<br/>
    UNINST=...            --uninst ...<br/>
    INC=...               --extra_compiler_flags ...<br/>
    POLLUTE=1             --extra_compiler_flags -DPERL_POLLUTE<br/>
<div class="spacer">
</div>
For example, if you are currently installing &quot;MakeMaker&quot; modules with this command:<div class="spacer">
</div>
<br/>
    perl Makefile.PL PREFIX=~<br/>
    make test<br/>
    make install UNINST=1<br/>
<div class="spacer">
</div>
You can install into the same location with Module::Build using this:<div class="spacer">
</div>
<br/>
    perl Build.PL --prefix ~<br/>
    ./Build test<br/>
    ./Build install --uninst 1<br/>
<div class="spacer">
</div>
<i></i><i>&quot;prefix&quot;</i><i> vs </i><i>&quot;install_base&quot;</i><i></i><div class="spacer">
</div>
The behavior of &quot;prefix&quot; is complicated and depends on how your Perl is configured.  The resulting installation locations will vary from machine to machine and even different installations of Perl on the same machine.  Because of this, it's difficult to document where &quot;prefix&quot; will place your modules.<div class="spacer">
</div>
In contrast, &quot;install_base&quot; has predictable, easy to explain installation locations.  Now that &quot;Module::Build&quot; and &quot;MakeMaker&quot; both have &quot;install_base&quot; there is little reason to use &quot;prefix&quot; other than to preserve your existing installation locations.  If you are starting a fresh Perl installation we encourage you to use &quot;install_base&quot;.  If you have an existing installation installed via &quot;prefix&quot;, consider moving it to an installation structure matching &quot;install_base&quot; and using that instead.</div>
<div class="subsection">
<h2>Running a single test file</h2> &quot;Module::Build&quot; supports running a single test, which enables you to track down errors more quickly.  Use the following format:<div class="spacer">
</div>
<br/>
  ./Build test --test_files t/mytest.t<br/>
<div class="spacer">
</div>
In addition, you may want to run the test in verbose mode to get more informative output:<div class="spacer">
</div>
<br/>
  ./Build test --test_files t/mytest.t --verbose 1<br/>
<div class="spacer">
</div>
I run this so frequently that I define the following shell alias:<div class="spacer">
</div>
<br/>
  alias t './Build test --verbose 1 --test_files'<br/>
<div class="spacer">
</div>
So then I can just execute &quot;t t/mytest.t&quot; to run a single test.</div>
</div>
<div class="section">
<h1>ADVANCED RECIPES</h1><div class="subsection">
<h2>Making a CPAN.pm-compatible distribution</h2> New versions of CPAN.pm understand how to use a  <i>Build.PL</i> script, but old versions don't.  If authors want to help users who have old versions, some form of  <i>Makefile.PL</i> should be supplied.  The easiest way to accomplish this is to use the &quot;create_makefile_pl&quot; parameter to &quot;Module::Build-&gt;new()&quot; in the &quot;Build.PL&quot; script, which can create various flavors of  <i>Makefile.PL</i> during the &quot;dist&quot; action.<div class="spacer">
</div>
As a best practice, we recommend using the &quot;traditional&quot; style of  <i>Makefile.PL</i> unless your distribution has needs that can't be accomplished that way.<div class="spacer">
</div>
The &quot;Module::Build::Compat&quot; module, which is part of &quot;Module::Build&quot;'s distribution, is responsible for creating these  <i>Makefile.PL</i>s.  Please see Module::Build::Compat for the details.</div>
<div class="subsection">
<h2>Changing the order of the build process</h2> The &quot;build_elements&quot; property specifies the steps &quot;Module::Build&quot; will take when building a distribution.  To change the build order, change the order of the entries in that property:<div class="spacer">
</div>
<br/>
  # Process pod files first<br/>
  my @e = @{$build-&gt;build_elements};<br/>
  my ($i) = grep {$e[$_] eq 'pod'} 0..$#e;<br/>
  unshift @e, splice @e, $i, 1;<br/>
<div class="spacer">
</div>
Currently, &quot;build_elements&quot; has the following default value:<div class="spacer">
</div>
<br/>
  [qw( PL support pm xs pod script )]<br/>
<div class="spacer">
</div>
Do take care when altering this property, since there may be non-obvious (and non-documented!) ordering dependencies in the &quot;Module::Build&quot; code.</div>
<div class="subsection">
<h2>Adding new file types to the build process</h2> Sometimes you might have extra types of files that you want to install alongside the standard types like  <i>.pm</i> and <i>.pod</i> files.  For instance, you might have a  <i>Bar.dat</i> file containing some data related to the &quot;Foo::Bar&quot; module and you'd like for it to end up as  <i>Foo/Bar.dat</i> somewhere in perl's @INC path so &quot;Foo::Bar&quot; can access it easily at runtime.  The following code from a sample &quot;Build.PL&quot; file demonstrates how to accomplish this:<div class="spacer">
</div>
<br/>
  use Module::Build;<br/>
  my $build = Module::Build-&gt;new<br/>
    (<br/>
     module_name =&gt; 'Foo::Bar',<br/>
     ...other stuff here...<br/>
    );<br/>
  $build-&gt;add_build_element('dat');<br/>
  $build-&gt;create_build_script;<br/>
<div class="spacer">
</div>
This will find all <i>.dat</i> files in the <i>lib/</i> directory, copy them to the  <i>blib/lib/</i> directory during the &quot;build&quot; action, and install them during the &quot;install&quot; action.<div class="spacer">
</div>
If your extra files aren't located in the &quot;lib/&quot; directory in your distribution, you can explicitly say where they are, just as you'd do with  <i>.pm</i> or <i>.pod</i> files:<div class="spacer">
</div>
<br/>
  use Module::Build;<br/>
  my $build = new Module::Build<br/>
    (<br/>
     module_name =&gt; 'Foo::Bar',<br/>
     dat_files =&gt; {'some/dir/Bar.dat' =&gt; 'lib/Foo/Bar.dat'},<br/>
     ...other stuff here...<br/>
    );<br/>
  $build-&gt;add_build_element('dat');<br/>
  $build-&gt;create_build_script;<br/>
<div class="spacer">
</div>
If your extra files actually need to be created on the user's machine, or if they need some other kind of special processing, you'll probably want to subclass &quot;Module::Build&quot; and create a special method to process them, named &quot;process_${kind}_files()&quot;:<div class="spacer">
</div>
<br/>
  use Module::Build;<br/>
  my $class = Module::Build-&gt;subclass(code =&gt; &lt;&lt;'EOF');<br/>
    sub process_dat_files {<br/>
      my $self = shift;<br/>
      ... locate and process *.dat files,<br/>
      ... and create something in blib/lib/<br/>
    }<br/>
  EOF<br/>
  my $build = $class-&gt;new<br/>
    (<br/>
     module_name =&gt; 'Foo::Bar',<br/>
     ...other stuff here...<br/>
    );<br/>
  $build-&gt;add_build_element('dat');<br/>
  $build-&gt;create_build_script;<br/>
<div class="spacer">
</div>
If your extra files don't go in <i>lib/</i> but in some other place, see &quot;Adding new elements to the install process&quot; for how to actually get them installed.<div class="spacer">
</div>
Please note that these examples use some capabilities of Module::Build that first appeared in version 0.26.  Before that it could still be done, but the simple cases took a bit more work.</div>
<div class="subsection">
<h2>Adding new elements to the install process</h2> By default, Module::Build creates seven subdirectories of the  <i>blib</i> directory during the build process:  <i>lib</i>, <i>arch</i>, <i>bin</i>,  <i>script</i>, <i>bindoc</i>, <i>libdoc</i>, and <i>html</i> (some of these may be missing or empty if there's nothing to go in them).  Anything copied to these directories during the build will eventually be installed during the &quot;install&quot; action (see &quot;INSTALL PATHS&quot; in Module::Build.<div class="spacer">
</div>
If you need to create a new custom type of installable element, e.g. &quot;conf&quot;, then you need to tell Module::Build where things in  <i>blib/conf/</i> should be installed.  To do this, use the &quot;install_path&quot; parameter to the &quot;new()&quot; method:<div class="spacer">
</div>
<br/>
  my $build = Module::Build-&gt;new<br/>
    (<br/>
     ...other stuff here...<br/>
     install_path =&gt; { conf =&gt; $installation_path }<br/>
    );<br/>
<div class="spacer">
</div>
Or you can call the &quot;install_path()&quot; method later:<div class="spacer">
</div>
<br/>
  $build-&gt;install_path(conf =&gt; $installation_path);<br/>
<div class="spacer">
</div>
The user may also specify the path on the command line:<div class="spacer">
</div>
<br/>
  perl Build.PL --install_path conf=/foo/path/etc<br/>
<div class="spacer">
</div>
The important part, though, is that <i>somehow</i> the install path needs to be set, or else nothing in the  <i>blib/conf/</i> directory will get installed, and a runtime error during the &quot;install&quot; action will result.<div class="spacer">
</div>
See also &quot;Adding new file types to the build process&quot; for how to create the stuff in  <i>blib/conf/</i> in the first place.</div>
</div>
<div class="section">
<h1>EXAMPLES ON CPAN</h1> Several distributions on CPAN are making good use of various features of Module::Build.  They can serve as real-world examples for others.<div class="subsection">
<h2>SVN-Notify-Mirror</h2> http://search.cpan.org/~jpeacock/SVN-Notify-Mirror/ &lt;http://search.cpan.org/~jpeacock/SVN-Notify-Mirror/&gt;<div class="spacer">
</div>
John Peacock, author of the &quot;SVN-Notify-Mirror&quot; distribution, says:<dl>
<dt>
1. Using &quot;auto_features&quot;, I check to see whether two optional modules are available - SVN::Notify::Config and Net::SSH;</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
2. If the S::N::Config module is loaded, I automatically generate test files for it during Build (using the &quot;PL_files&quot; property).</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
3. If the &quot;ssh_feature&quot; is available, I ask if the user wishes to perform the ssh tests (since it requires a little preliminary setup);</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
4. Only if the user has &quot;ssh_feature&quot; and answers yes to the testing, do I generate a test file.</dt>
<dd>
I'm sure I could not have handled this complexity with EU::MM, but it was very easy to do with M::B.</dd>
</dl>
</div>
<div class="subsection">
<h2>Modifying an action</h2> Sometimes you might need an to have an action, say &quot;./Build install&quot;, do something unusual.  For instance, you might need to change the ownership of a file or do something else peculiar to your application.<div class="spacer">
</div>
You can subclass &quot;Module::Build&quot; on the fly using the &quot;subclass()&quot; method and override the methods that perform the actions.  You may need to read through &quot;Module::Build::Authoring&quot; and &quot;Module::Build::API&quot; to find the methods you want to override.  All &quot;action&quot; methods are implemented by a method called &quot;ACTION_&quot; followed by the action's name, so here's an example of how it would work for the &quot;install&quot; action:<div class="spacer">
</div>
<br/>
  # Build.PL<br/>
  use Module::Build;<br/>
  my $class = Module::Build-&gt;subclass(<br/>
      class =&gt; &quot;Module::Build::Custom&quot;,<br/>
      code =&gt; &lt;&lt;'SUBCLASS' );<br/>
<br/>
  sub ACTION_install {<br/>
      my $self = shift;<br/>
      # YOUR CODE HERE<br/>
      $self-&gt;SUPER::ACTION_install;<br/>
  }<br/>
  SUBCLASS<br/>
<br/>
  $class-&gt;new(<br/>
      module_name =&gt; 'Your::Module',<br/>
      # rest of the usual Module::Build parameters<br/>
  )-&gt;create_build_script;<br/>
</div>
<div class="subsection">
<h2>Adding an action</h2> You can add a new &quot;./Build&quot; action simply by writing the method for it in your subclass.  Use &quot;depends_on&quot; to declare that another action must have been run before your action.<div class="spacer">
</div>
For example, let's say you wanted to be able to write &quot;./Build commit&quot; to test your code and commit it to Subversion.<div class="spacer">
</div>
<br/>
  # Build.PL<br/>
  use Module::Build;<br/>
  my $class = Module::Build-&gt;subclass(<br/>
      class =&gt; &quot;Module::Build::Custom&quot;,<br/>
      code =&gt; &lt;&lt;'SUBCLASS' );<br/>
<br/>
  sub ACTION_commit {<br/>
      my $self = shift;<br/>
<br/>
      $self-&gt;depends_on(&quot;test&quot;);<br/>
      $self-&gt;do_system(qw(svn commit));<br/>
  }<br/>
  SUBCLASS<br/>
</div>
<div class="subsection">
<h2>Bundling Module::Build</h2> Note: This section probably needs an update as the technology improves (see contrib/bundle.pl in the distribution).<div class="spacer">
</div>
Suppose you want to use some new-ish features of Module::Build, e.g. newer than the version of Module::Build your users are likely to already have installed on their systems.  The first thing you should do is set &quot;configure_requires&quot; to your minimum version of Module::Build.  See Module::Build::Authoring.<div class="spacer">
</div>
But not every build system honors &quot;configure_requires&quot; yet.  Here's how you can ship a copy of Module::Build, but still use a newer installed version to take advantage of any bug fixes and upgrades.<div class="spacer">
</div>
First, install Module::Build into <i>Your-Project/inc/Module-Build</i>. CPAN will not index anything in the  <i>inc</i> directory so this copy will not show up in CPAN searches.<div class="spacer">
</div>
<br/>
    cd Module-Build<br/>
    perl Build.PL --install_base /path/to/Your-Project/inc/Module-Build<br/>
    ./Build test<br/>
    ./Build install<br/>
<div class="spacer">
</div>
You should now have all the Module::Build .pm files in  <i>Your-Project/inc/Module-Build/lib/perl5</i>.<div class="spacer">
</div>
Next, add this to the top of your <i>Build.PL</i>.<div class="spacer">
</div>
<br/>
    my $Bundled_MB = 0.30;  # or whatever version it was.<br/>
<br/>
    # Find out what version of Module::Build is installed or fail quietly.<br/>
    # This should be cross-platform.<br/>
    my $Installed_MB =<br/>
        `$^X -e &quot;eval q{require Module::Build; print Module::Build-&gt;VERSION} or exit 1&quot;;<br/>
<br/>
    # some operating systems put a newline at the end of every print.<br/>
    chomp $Installed_MB;<br/>
<br/>
    $Installed_MB = 0 if $?;<br/>
<br/>
    # Use our bundled copy of Module::Build if it's newer than the installed.<br/>
    unshift @INC, &quot;inc/Module-Build/lib/perl5&quot; if $Bundled_MB &gt; $Installed_MB;<br/>
<br/>
    require Module::Build;<br/>
<div class="spacer">
</div>
And write the rest of your <i>Build.PL</i> normally.  Module::Build will remember your change to @INC and use it when you run  <i>./Build</i>.<div class="spacer">
</div>
In the future, we hope to provide a more automated solution for this scenario; see &quot;inc/latest.pm&quot; in the Module::Build distribution for one indication of the direction we're moving.</div>
</div>
<div class="section">
<h1>AUTHOR</h1> Ken Williams &lt;kwilliams@cpan.org&gt;</div>
<div class="section">
<h1>COPYRIGHT</h1> Copyright (c) 2001-2008 Ken Williams.  All rights reserved.<div class="spacer">
</div>
This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</div>
<div class="section">
<h1>SEE ALSO</h1>  <i>perl</i>(1), Module::Build(3), Module::Build::Authoring(3), Module::Build::API(3)</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-09-26</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

