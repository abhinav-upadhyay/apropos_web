<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Gc(3)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Gc(3)</td>
<td class="head-vol">
OCaml library</td>
<td class="head-rtitle">
Gc(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Gc - Memory management control and statistics; finalised values.</div>
<div class="section">
<h1>Module</h1> Module   Gc</div>
<div class="section">
<h1>Documentation</h1> Module <b>Gc</b><br/>
 : <b>sig end</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
Memory management control and statistics; finalised values.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>type stat</i> = {<br/>
 minor_words : <b>float</b> ;  (* Number of words allocated in the minor heap since the program was started.  This number is accurate in byte-code programs, but only an approximation in programs compiled to native code.<br/>
 *)<br/>
 promoted_words : <b>float</b> ;  (* Number of words allocated in the minor heap that survived a minor collection and were moved to the major heap since the program was started.<br/>
 *)<br/>
 major_words : <b>float</b> ;  (* Number of words allocated in the major heap, including the promoted words, since the program was started.<br/>
 *)<br/>
 minor_collections : <b>int</b> ;  (* Number of minor collections since the program was started.<br/>
 *)<br/>
 major_collections : <b>int</b> ;  (* Number of major collection cycles completed since the program was started.<br/>
 *)<br/>
 heap_words : <b>int</b> ;  (* Total size of the major heap, in words.<br/>
 *)<br/>
 heap_chunks : <b>int</b> ;  (* Number of contiguous pieces of memory that make up the major heap.<br/>
 *)<br/>
 live_words : <b>int</b> ;  (* Number of words of live data in the major heap, including the header words.<br/>
 *)<br/>
 live_blocks : <b>int</b> ;  (* Number of live blocks in the major heap.<br/>
 *)<br/>
 free_words : <b>int</b> ;  (* Number of words in the free list.<br/>
 *)<br/>
 free_blocks : <b>int</b> ;  (* Number of blocks in the free list.<br/>
 *)<br/>
 largest_free : <b>int</b> ;  (* Size (in words) of the largest block in the free list.<br/>
 *)<br/>
 fragments : <b>int</b> ;  (* Number of wasted words due to fragmentation.  These are 1-words free blocks placed between two live blocks.  They are not available for allocation.<br/>
 *)<br/>
 compactions : <b>int</b> ;  (* Number of heap compactions since the program was started.<br/>
 *)<br/>
 top_heap_words : <b>int</b> ;  (* Maximum size reached by the major heap, in words.<br/>
 *)<br/>
 stack_size : <b>int</b> ;  (* Current size of the stack, in words.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>Since</b> 3.12.0<br/>
 *)<br/>
 }<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
The memory management counters are returned in a <b>stat</b> record.<div style="height: 1.00em;">
&#160;</div>
The total amount of memory allocated by the program since it was started is (in words) <b>minor_words + major_words - promoted_words</b> .  Multiply by the word size (4 on a 32-bit machine, 8 on a 64-bit machine) to get the number of bytes.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>type control</i> = {<div style="height: 1.00em;">
&#160;</div>
<b>mutable</b> minor_heap_size : <b>int</b> ;  (* The size (in words) of the minor heap.  Changing this parameter will trigger a minor collection.  Default: 256k.<br/>
 *)<div style="height: 1.00em;">
&#160;</div>
<b>mutable</b> major_heap_increment : <b>int</b> ;  (* How much to add to the major heap when increasing it. If this number is less than or equal to 1000, it is a percentage of the current heap size (i.e. setting it to 100 will double the heap size at each increase). If it is more than 1000, it is a fixed number of words that will be added to the heap. Default: 15.<br/>
 *)<div style="height: 1.00em;">
&#160;</div>
<b>mutable</b> space_overhead : <b>int</b> ;  (* The major GC speed is computed from this parameter. This is the memory that will be &quot;wasted&quot; because the GC does not immediatly collect unreachable blocks.  It is expressed as a percentage of the memory used for live data. The GC will work more (use more CPU time and collect blocks more eagerly) if <b>space_overhead</b> is smaller. Default: 80.<br/>
 *)<div style="height: 1.00em;">
&#160;</div>
<b>mutable</b> verbose : <b>int</b> ;  (* This value controls the GC messages on standard error output. It is a sum of some of the following flags, to print messages on the corresponding events:<div style="height: 1.00em;">
&#160;</div>
- <b>0x001</b> Start of major GC cycle.<div style="height: 1.00em;">
&#160;</div>
- <b>0x002</b> Minor collection and major GC slice.<div style="height: 1.00em;">
&#160;</div>
- <b>0x004</b> Growing and shrinking of the heap.<div style="height: 1.00em;">
&#160;</div>
- <b>0x008</b> Resizing of stacks and memory manager tables.<div style="height: 1.00em;">
&#160;</div>
- <b>0x010</b> Heap compaction.<div style="height: 1.00em;">
&#160;</div>
- <b>0x020</b> Change of GC parameters.<div style="height: 1.00em;">
&#160;</div>
- <b>0x040</b> Computation of major GC slice size.<div style="height: 1.00em;">
&#160;</div>
- <b>0x080</b> Calling of finalisation functions.<div style="height: 1.00em;">
&#160;</div>
- <b>0x100</b> Bytecode executable and shared library search at start-up.<div style="height: 1.00em;">
&#160;</div>
- <b>0x200</b> Computation of compaction-triggering condition. Default: 0.<div style="height: 1.00em;">
&#160;</div>
<br/>
 *)<div style="height: 1.00em;">
&#160;</div>
<b>mutable</b> max_overhead : <b>int</b> ;  (* Heap compaction is triggered when the estimated amount of &quot;wasted&quot; memory is more than <b>max_overhead</b> percent of the amount of live data.  If <b>max_overhead</b> is set to 0, heap compaction is triggered at the end of each major GC cycle (this setting is intended for testing purposes only). If <b>max_overhead &gt;= 1000000</b> , compaction is never triggered. If compaction is permanently disabled, it is strongly suggested to set <b>allocation_policy</b> to 1. Default: 500.<br/>
 *)<div style="height: 1.00em;">
&#160;</div>
<b>mutable</b> stack_limit : <b>int</b> ;  (* The maximum size of the stack (in words).  This is only relevant to the byte-code runtime, as the native code runtime uses the operating system's stack.  Default: 1024k.<br/>
 *)<div style="height: 1.00em;">
&#160;</div>
<b>mutable</b> allocation_policy : <b>int</b> ;  (* The policy used for allocating in the heap.  Possible values are 0 and 1.  0 is the next-fit policy, which is quite fast but can result in fragmentation.  1 is the first-fit policy, which can be slower in some cases but can be better for programs with fragmentation problems. Default: 0.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>Since</b> 3.11.0<br/>
 *)<br/>
 }<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
The GC parameters are given as a <b>control</b> record.  Note that these parameters can also be initialised by setting the OCAMLRUNPARAM environment variable.  See the documentation of <b>ocamlrun</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val stat</i> : <b>unit -&gt; stat</b><div style="height: 1.00em;">
&#160;</div>
Return the current values of the memory management counters in a <b>stat</b> record.  This function examines every heap block to get the statistics.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val quick_stat</i> : <b>unit -&gt; stat</b><div style="height: 1.00em;">
&#160;</div>
Same as <b>stat</b> except that <b>live_words</b> , <b>live_blocks</b> , <b>free_words</b> , <b>free_blocks</b> , <b>largest_free</b> , and <b>fragments</b> are set to 0.  This function is much faster than <b>stat</b> because it does not need to go through the heap.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val counters</i> : <b>unit -&gt; float * float * float</b><div style="height: 1.00em;">
&#160;</div>
Return <b>(minor_words, promoted_words, major_words)</b> .  This function is as fast as <b>quick_stat</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val get</i> : <b>unit -&gt; control</b><div style="height: 1.00em;">
&#160;</div>
Return the current values of the GC parameters in a <b>control</b> record.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val set</i> : <b>control -&gt; unit</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>set r</b> changes the GC parameters according to the <b>control</b> record <b>r</b> . The normal usage is: <b>Gc.set { (Gc.get()) with Gc.verbose = 0x00d }</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val minor</i> : <b>unit -&gt; unit</b><div style="height: 1.00em;">
&#160;</div>
Trigger a minor collection.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val major_slice</i> : <b>int -&gt; int</b><div style="height: 1.00em;">
&#160;</div>
Do a minor collection and a slice of major collection.  The argument is the size of the slice, 0 to use the automatically-computed slice size.  In all cases, the result is the computed slice size.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val major</i> : <b>unit -&gt; unit</b><div style="height: 1.00em;">
&#160;</div>
Do a minor collection and finish the current major collection cycle.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val full_major</i> : <b>unit -&gt; unit</b><div style="height: 1.00em;">
&#160;</div>
Do a minor collection, finish the current major collection cycle, and perform a complete new cycle.  This will collect all currently unreachable blocks.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val compact</i> : <b>unit -&gt; unit</b><div style="height: 1.00em;">
&#160;</div>
Perform a full major collection and compact the heap.  Note that heap compaction is a lengthy operation.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val print_stat</i> : <b>Pervasives.out_channel -&gt; unit</b><div style="height: 1.00em;">
&#160;</div>
Print the current values of the memory management counters (in human-readable form) into the channel argument.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val allocated_bytes</i> : <b>unit -&gt; float</b><div style="height: 1.00em;">
&#160;</div>
Return the total number of bytes allocated since the program was started.  It is returned as a <b>float</b> to avoid overflow problems with <b>int</b> on 32-bit machines.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val finalise</i> : <b>('a -&gt; unit) -&gt; 'a -&gt; unit</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>finalise f v</b> registers <b>f</b> as a finalisation function for <b>v</b> . <b>v</b> must be heap-allocated. <b>f</b> will be called with <b>v</b> as argument at some point between the first time <b>v</b> becomes unreachable and the time <b>v</b> is collected by the GC.  Several functions can be registered for the same value, or even several instances of the same function.  Each instance will be called once (or never, if the program terminates before <b>v</b> becomes unreachable).<div style="height: 1.00em;">
&#160;</div>
The GC will call the finalisation functions in the order of deallocation.  When several values become unreachable at the same time (i.e. during the same GC cycle), the finalisation functions will be called in the reverse order of the corresponding calls to <b>finalise</b> .  If <b>finalise</b> is called in the same order as the values are allocated, that means each value is finalised before the values it depends upon.  Of course, this becomes false if additional dependencies are introduced by assignments.<div style="height: 1.00em;">
&#160;</div>
In the presence of multiple OCaml threads it should be assumed that any particular finaliser may be executed in any of the threads.<div style="height: 1.00em;">
&#160;</div>
Anything reachable from the closure of finalisation functions is considered reachable, so the following code will not work as expected:<div style="height: 1.00em;">
&#160;</div>
- <b>let v = ... in Gc.finalise (fun x -&gt; ... v ...) v</b><div style="height: 1.00em;">
&#160;</div>
Instead you should make sure that <b>v</b> is not in the closure of the finalisation function by writing:<div style="height: 1.00em;">
&#160;</div>
- <b>let f = fun x -&gt; ... ;; let v = ... in Gc.finalise f v</b><div style="height: 1.00em;">
&#160;</div>
The <b>f</b> function can use all features of OCaml, including assignments that make the value reachable again.  It can also loop forever (in this case, the other finalisation functions will not be called during the execution of f, unless it calls <b>finalise_release</b> ). It can call <b>finalise</b> on <b>v</b> or other values to register other functions or even itself.  It can raise an exception; in this case the exception will interrupt whatever the program was doing when the function was called.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>finalise</b> will raise <b>Invalid_argument</b> if <b>v</b> is not heap-allocated.  Some examples of values that are not heap-allocated are integers, constant constructors, booleans, the empty array, the empty list, the unit value.  The exact list of what is heap-allocated or not is implementation-dependent. Some constant values can be heap-allocated but never deallocated during the lifetime of the program, for example a list of integer constants; this is also implementation-dependent. You should also be aware that compiler optimisations may duplicate some immutable values, for example floating-point numbers when stored into arrays, so they can be finalised and collected while another copy is still in use by the program.<div style="height: 1.00em;">
&#160;</div>
The results of calling <b>String.make</b> , <b>Bytes.make</b> , <b>Bytes.create</b> , <b>Array.make</b> , and <b>Pervasives.ref</b> are guaranteed to be heap-allocated and non-constant except when the length argument is <b>0</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val finalise_release</i> : <b>unit -&gt; unit</b><div style="height: 1.00em;">
&#160;</div>
A finalisation function may call <b>finalise_release</b> to tell the GC that it can launch the next finalisation function without waiting for the current one to return.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>type alarm</i><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
An alarm is a piece of data that calls a user function at the end of each major GC cycle.  The following functions are provided to create and delete alarms.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val create_alarm</i> : <b>(unit -&gt; unit) -&gt; alarm</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>create_alarm f</b> will arrange for <b>f</b> to be called at the end of each major GC cycle, starting with the current cycle or the next one. A value of type <b>alarm</b> is returned that you can use to call <b>delete_alarm</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val delete_alarm</i> : <b>alarm -&gt; unit</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>delete_alarm a</b> will stop the calls to the function associated to <b>a</b> .  Calling <b>delete_alarm a</b> again has no effect.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<table class="foot">
<tr>
<td class="foot-date">
2015-08-12</td>
<td class="foot-os">
OCamldoc</td>
</tr>
</table>
</div>
</body>
</html>

