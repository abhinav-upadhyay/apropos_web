<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Carp::Assert(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Carp::Assert(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
Carp::Assert(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Carp::Assert - executable comments</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
    # Assertions are on.<br/>
    use Carp::Assert;<br/>
<br/>
    $next_sunrise_time = sunrise();<br/>
<br/>
    # Assert that the sun must rise in the next 24 hours.<br/>
    assert(($next_sunrise_time - time) &lt; 24*60*60) if DEBUG;<br/>
<br/>
    # Assert that your customer's primary credit card is active<br/>
    affirm {<br/>
        my @cards = @{$customer-&gt;credit_cards};<br/>
        $cards[0]-&gt;is_active;<br/>
    };<br/>
<br/>
<br/>
    # Assertions are off.<br/>
    no Carp::Assert;<br/>
<br/>
    $next_pres = divine_next_president();<br/>
<br/>
    # Assert that if you predict Dan Quayle will be the next president<br/>
    # your crystal ball might need some polishing.  However, since<br/>
    # assertions are off, IT COULD HAPPEN!<br/>
    shouldnt($next_pres, 'Dan Quayle') if DEBUG;<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1><br/>
    &quot;We are ready for any unforseen event that may or may not <br/>
    occur.&quot;<br/>
        - Dan Quayle<br/>
<div class="spacer">
</div>
Carp::Assert is intended for a purpose like the ANSI C library assert.h.  If you're already familiar with assert.h, then you can probably skip this and go straight to the FUNCTIONS section.<div class="spacer">
</div>
Assertions are the explict expressions of your assumptions about the reality your program is expected to deal with, and a declaration of those which it is not.  They are used to prevent your program from blissfully processing garbage inputs (garbage in, garbage out becomes garbage in, error out) and to tell you when you've produced garbage output.  (If I was going to be a cynic about Perl and the user nature, I'd say there are no user inputs but garbage, and Perl produces nothing but...)<div class="spacer">
</div>
An assertion is used to prevent the impossible from being asked of your code, or at least tell you when it does.  For example:<div class="spacer">
</div>
<br/>
    # Take the square root of a number.<br/>
    sub my_sqrt {<br/>
        my($num) = shift;<br/>
<br/>
        # the square root of a negative number is imaginary.<br/>
        assert($num &gt;= 0);<br/>
<br/>
        return sqrt $num;<br/>
    }<br/>
<div class="spacer">
</div>
The assertion will warn you if a negative number was handed to your subroutine, a reality the routine has no intention of dealing with.<div class="spacer">
</div>
An assertion should also be used as something of a reality check, to make sure what your code just did really did happen:<div class="spacer">
</div>
<br/>
    open(FILE, $filename) || die $!;<br/>
    @stuff = &lt;FILE&gt;;<br/>
    @stuff = do_something(@stuff);<br/>
<br/>
    # I should have some stuff.<br/>
    assert(@stuff &gt; 0);<br/>
<div class="spacer">
</div>
The assertion makes sure you have some @stuff at the end.  Maybe the file was empty, maybe  <i>do_something()</i> returned an empty list... either way, the  <i>assert()</i> will give you a clue as to where the problem lies, rather than 50 lines down at when you wonder why your program isn't printing anything.<div class="spacer">
</div>
Since assertions are designed for debugging and will remove themelves from production code, your assertions should be carefully crafted so as to not have any side-effects, change any variables, or otherwise have any effect on your program.  Here is an example of a bad assertation:<div class="spacer">
</div>
<br/>
    assert($error = 1 if $king ne 'Henry');  # Bad!<br/>
<div class="spacer">
</div>
It sets an error flag which may then be used somewhere else in your program. When you shut off your assertions with the $DEBUG flag, $error will no longer be set.<div class="spacer">
</div>
Here's another example of <b>bad</b> use:<div class="spacer">
</div>
<br/>
    assert($next_pres ne 'Dan Quayle' or goto Canada);  # Bad!<br/>
<div class="spacer">
</div>
This assertion has the side effect of moving to Canada should it fail. This is a very bad assertion since error handling should not be placed in an assertion, nor should it have side-effects.<div class="spacer">
</div>
In short, an assertion is an executable comment.  For instance, instead of writing this<div class="spacer">
</div>
<br/>
    # $life ends with a '!'<br/>
    $life = begin_life();<br/>
<div class="spacer">
</div>
you'd replace the comment with an assertion which <b>enforces</b> the comment.<div class="spacer">
</div>
<br/>
    $life = begin_life();<br/>
    assert( $life =~ /!$/ );<br/>
</div>
<div class="section">
<h1>FUNCTIONS</h1><dl>
<dt>
<b>assert</b></dt>
<dd>
<br/>
    assert(EXPR) if DEBUG;<br/>
    assert(EXPR, $name) if DEBUG;<br/>
<div style="height: 1.00em;">
&#160;</div>
assert's functionality is effected by compile time value of the DEBUG constant, controlled by saying &quot;use Carp::Assert&quot; or &quot;no Carp::Assert&quot;.  In the former case, assert will function as below. Otherwise, the assert function will compile itself out of the program. See &quot;Debugging vs Production&quot; for details.<div style="height: 1.00em;">
&#160;</div>
Give assert an expression, assert will <i>Carp::confess()</i> if that expression is false, otherwise it does nothing.  (DO NOT use the return value of assert for anything, I mean it... really!).<div style="height: 1.00em;">
&#160;</div>
The error from assert will look something like this:<div style="height: 1.00em;">
&#160;</div>
<br/>
    Assertion failed!<br/>
            Carp::Assert::assert(0) called at prog line 23<br/>
            main::foo called at prog line 50<br/>
<div style="height: 1.00em;">
&#160;</div>
Indicating that in the file &quot;prog&quot; an assert failed inside the function  <i>main::foo()</i> on line 23 and that <i>foo()</i> was in turn called from line 50 in the same file.<div style="height: 1.00em;">
&#160;</div>
If given a $name, <i>assert()</i> will incorporate this into your error message, giving users something of a better idea what's going on.<div style="height: 1.00em;">
&#160;</div>
<br/>
    assert( Dogs-&gt;isa('People'), 'Dogs are people, too!' ) if DEBUG;<br/>
    # Result - &quot;Assertion (Dogs are people, too!) failed!&quot;<br/>
</dd>
</dl>
<dl>
<dt>
<b>affirm</b></dt>
<dd>
<br/>
    affirm BLOCK if DEBUG;<br/>
    affirm BLOCK $name if DEBUG;<br/>
<div style="height: 1.00em;">
&#160;</div>
Very similar to <i>assert()</i>, but instead of taking just a simple expression it takes an entire block of code and evaluates it to make sure its true.  This can allow more complicated assertions than  <i>assert()</i> can without letting the debugging code leak out into production and without having to smash together several statements into one.<div style="height: 1.00em;">
&#160;</div>
<br/>
    affirm {<br/>
        my $customer = Customer-&gt;new($customerid);<br/>
        my @cards = $customer-&gt;credit_cards;<br/>
        grep { $_-&gt;is_active } @cards;<br/>
    } &quot;Our customer has an active credit card&quot;;<br/>
<div style="height: 1.00em;">
&#160;</div>
<i>affirm()</i> also has the nice side effect that if you forgot the &quot;if DEBUG&quot; suffix its arguments will not be evaluated at all.  This can be nice if you stick  <i>affirm()</i>s with expensive checks into hot loops and other time-sensitive parts of your program.<div style="height: 1.00em;">
&#160;</div>
If the $name is left off and your Perl version is 5.6 or higher the  <i>affirm()</i> diagnostics will include the code begin affirmed.</dd>
</dl>
<dl>
<dt>
<b>should</b></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<b>shouldnt</b></dt>
<dd>
<br/>
    should  ($this, $shouldbe)   if DEBUG;<br/>
    shouldnt($this, $shouldntbe) if DEBUG;<br/>
<div style="height: 1.00em;">
&#160;</div>
Similar to <i>assert()</i>, it is specially for simple &quot;this should be that&quot; or &quot;this should be anything but that&quot; style of assertions.<div style="height: 1.00em;">
&#160;</div>
Due to Perl's lack of a good macro system, <i>assert()</i> can only report where something failed, but it can't report  <i>what</i> failed or <i>how</i>.  <i>should()</i> and <i>shouldnt()</i> can produce more informative error messages:<div style="height: 1.00em;">
&#160;</div>
<br/>
    Assertion ('this' should be 'that'!) failed!<br/>
            Carp::Assert::should('this', 'that') called at moof line 29<br/>
            main::foo() called at moof line 58<br/>
<div style="height: 1.00em;">
&#160;</div>
So this:<div style="height: 1.00em;">
&#160;</div>
<br/>
    should($this, $that) if DEBUG;<br/>
<div style="height: 1.00em;">
&#160;</div>
is similar to this:<div style="height: 1.00em;">
&#160;</div>
<br/>
    assert($this eq $that) if DEBUG;<br/>
<div style="height: 1.00em;">
&#160;</div>
except for the better error message.<div style="height: 1.00em;">
&#160;</div>
Currently, <i>should()</i> and <i>shouldnt()</i> can only do simple eq and ne tests (respectively).  Future versions may allow regexes.</dd>
</dl>
</div>
<div class="section">
<h1>Debugging vs Production</h1> Because assertions are extra code and because it is sometimes necessary to place them in 'hot' portions of your code where speed is paramount, Carp::Assert provides the option to remove its  <i>assert()</i> calls from your program.<div class="spacer">
</div>
So, we provide a way to force Perl to inline the switched off <i>assert()</i> routine, thereby removing almost all performance impact on your production code.<div class="spacer">
</div>
<br/>
    no Carp::Assert;  # assertions are off.<br/>
    assert(1==1) if DEBUG;<br/>
<div class="spacer">
</div>
DEBUG is a constant set to 0.  Adding the 'if DEBUG' condition on your  <i>assert()</i> call gives perl the cue to go ahead and remove <i>assert()</i> call from your program entirely, since the if conditional will always be false.<div class="spacer">
</div>
<br/>
    # With C&lt;no Carp::Assert&gt; the assert() has no impact.<br/>
    for (1..100) {<br/>
        assert( do_some_really_time_consuming_check ) if DEBUG;<br/>
    }<br/>
<div class="spacer">
</div>
If &quot;if DEBUG&quot; gets too annoying, you can always use <i>affirm()</i>.<div class="spacer">
</div>
<br/>
    # Once again, affirm() has (almost) no impact with C&lt;no Carp::Assert&gt;<br/>
    for (1..100) {<br/>
        affirm { do_some_really_time_consuming_check };<br/>
    }<br/>
<div class="spacer">
</div>
Another way to switch off all asserts, system wide, is to define the NDEBUG or the PERL_NDEBUG environment variable.<div class="spacer">
</div>
You can safely leave out the &quot;if DEBUG&quot; part, but then your <i>assert()</i> function will always execute (and its arguments evaluated and time spent).  To get around this, use  <i>affirm()</i>.  You still have the overhead of calling a function but at least its arguments will not be evaluated.</div>
<div class="section">
<h1>Differences from ANSI C</h1>  <i>assert()</i> is intended to act like the function from ANSI C fame. Unfortunately, due to Perl's lack of macros or strong inlining, it's not nearly as unobtrusive.<div class="spacer">
</div>
Well, the obvious one is the &quot;if DEBUG&quot; part.  This is cleanest way I could think of to cause each  <i>assert()</i> call and its arguments to be removed from the program at compile-time, like the ANSI C macro does.<div class="spacer">
</div>
Also, this version of assert does not report the statement which failed, just the line number and call frame via Carp::confess.  You can't do &quot;assert('$a == $b')&quot; because $a and $b will probably be lexical, and thus unavailable to  <i>assert()</i>.  But with Perl, unlike C, you always have the source to look through, so the need isn't as great.</div>
<div class="section">
<h1>EFFICIENCY</h1> With &quot;no Carp::Assert&quot; (or NDEBUG) and using the &quot;if DEBUG&quot; suffixes on all your assertions, Carp::Assert has almost no impact on your production code.  I say almost because it does still add some load-time to your code (I've tried to reduce this as much as possible).<div class="spacer">
</div>
If you forget the &quot;if DEBUG&quot; on an &quot;assert()&quot;, &quot;should()&quot; or &quot;shouldnt()&quot;, its arguments are still evaluated and thus will impact your code.  You'll also have the extra overhead of calling a subroutine (even if that subroutine does nothing).<div class="spacer">
</div>
Forgetting the &quot;if DEBUG&quot; on an &quot;affirm()&quot; is not so bad.  While you still have the overhead of calling a subroutine (one that does nothing) it will  <b>not</b> evaluate its code block and that can save alot.<div class="spacer">
</div>
Try to remember the <b>if DEBUG</b>.</div>
<div class="section">
<h1>ENVIRONMENT</h1><dl>
<dt>
NDEBUG</dt>
<dd>
Defining NDEBUG switches off all assertions.  It has the same effect as changing &quot;use Carp::Assert&quot; to &quot;no Carp::Assert&quot; but it effects all code.</dd>
</dl>
<dl>
<dt>
PERL_NDEBUG</dt>
<dd>
Same as NDEBUG and will override it.  Its provided to give you something which won't conflict with any C programs you might be working on at the same time.</dd>
</dl>
</div>
<div class="section">
<h1>BUGS, CAVETS and other MUSINGS</h1>  <b>Conflicts with &quot;POSIX.pm&quot;</b><div class="spacer">
</div>
The &quot;POSIX&quot; module exports an &quot;assert&quot; routine which will conflict with &quot;Carp::Assert&quot; if both are used in the same namespace.  If you are using both together, prevent &quot;POSIX&quot; from exporting like so:<div class="spacer">
</div>
<br/>
    use POSIX ();<br/>
    use Carp::Assert;<br/>
<div class="spacer">
</div>
Since &quot;POSIX&quot; exports way too much, you should be using it like that anyway.<div style="height: 0.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>&quot;affirm&quot;</b> and $^S<div class="spacer">
</div>
<i>affirm()</i> mucks with the expression's caller and it is run in an eval so anything that checks $^S will be wrong.<div style="height: 0.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>&quot;shouldn't&quot;</b><div class="spacer">
</div>
Yes, there is a &quot;shouldn't&quot; routine.  It mostly works, but you <b>must</b> put the &quot;if DEBUG&quot; after it.<div style="height: 0.00em;">
&#160;</div>
<div class="spacer">
</div>
<b>missing &quot;if DEBUG&quot;</b><div class="spacer">
</div>
It would be nice if we could warn about missing &quot;if DEBUG&quot;.</div>
<div class="section">
<h1>SEE ALSO</h1> assertions is a new module available in 5.9.0 which provides assertions which can be enabled/disabled at compile time for real, no &quot;if DEBUG&quot; necessary.</div>
<div class="section">
<h1>COPYRIGHT</h1> Copyright 2001-2007 by Michael G Schwern &lt;schwern@pobox.com&gt;.<div class="spacer">
</div>
This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.<div class="spacer">
</div>
See <i>http://dev.perl.org/licenses/</i></div>
<div class="section">
<h1>AUTHOR</h1> Michael G Schwern &lt;schwern@pobox.com&gt;</div>
<table class="foot">
<tr>
<td class="foot-date">
2007-01-05</td>
<td class="foot-os">
perl v5.10.0</td>
</tr>
</table>
</div>
</body>
</html>

