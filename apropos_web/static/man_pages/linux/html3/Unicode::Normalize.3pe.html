<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Unicode::Normalize(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Unicode::Normalize(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
Unicode::Normalize(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Unicode::Normalize - Unicode Normalization Forms</div>
<div class="section">
<h1>SYNOPSIS</h1> (1) using function names exported by default:<div class="spacer">
</div>
<br/>
  use Unicode::Normalize;<br/>
<br/>
  $NFD_string  = NFD($string);  # Normalization Form D<br/>
  $NFC_string  = NFC($string);  # Normalization Form C<br/>
  $NFKD_string = NFKD($string); # Normalization Form KD<br/>
  $NFKC_string = NFKC($string); # Normalization Form KC<br/>
<div class="spacer">
</div>
(2) using function names exported on request:<div class="spacer">
</div>
<br/>
  use Unicode::Normalize 'normalize';<br/>
<br/>
  $NFD_string  = normalize('D',  $string);  # Normalization Form D<br/>
  $NFC_string  = normalize('C',  $string);  # Normalization Form C<br/>
  $NFKD_string = normalize('KD', $string);  # Normalization Form KD<br/>
  $NFKC_string = normalize('KC', $string);  # Normalization Form KC<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> Parameters:<div class="spacer">
</div>
$string is used as a string under character semantics (see <i>perlunicode</i>).<div class="spacer">
</div>
$code_point should be an unsigned integer representing a Unicode code point.<div class="spacer">
</div>
Note: Between XSUB and pure Perl, there is an incompatibility about the interpretation of $code_point as a decimal number. XSUB converts $code_point to an unsigned integer, but pure Perl does not. Do not use a floating point nor a negative sign in $code_point.<div class="subsection">
<h2>Normalization Forms</h2><dl>
<dt>
&quot;$NFD_string = NFD($string)&quot;</dt>
<dd>
It returns the Normalization Form D (formed by canonical decomposition).</dd>
</dl>
<dl>
<dt>
&quot;$NFC_string = NFC($string)&quot;</dt>
<dd>
It returns the Normalization Form C (formed by canonical decomposition followed by canonical composition).</dd>
</dl>
<dl>
<dt>
&quot;$NFKD_string = NFKD($string)&quot;</dt>
<dd>
It returns the Normalization Form KD (formed by compatibility decomposition).</dd>
</dl>
<dl>
<dt>
&quot;$NFKC_string = NFKC($string)&quot;</dt>
<dd>
It returns the Normalization Form KC (formed by compatibility decomposition followed by  <b>canonical</b> composition).</dd>
</dl>
<dl>
<dt>
&quot;$FCD_string = FCD($string)&quot;</dt>
<dd>
If the given string is in FCD (&quot;Fast C or D&quot; form; cf. UTN #5), it returns the string without modification; otherwise it returns an FCD string.<div style="height: 1.00em;">
&#160;</div>
Note: FCD is not always unique, then plural forms may be equivalent each other. &quot;FCD()&quot; will return one of these equivalent forms.</dd>
</dl>
<dl>
<dt>
&quot;$FCC_string = FCC($string)&quot;</dt>
<dd>
It returns the FCC form (&quot;Fast C Contiguous&quot;; cf. UTN #5).<div style="height: 1.00em;">
&#160;</div>
Note: FCC is unique, as well as four normalization forms (NF*).</dd>
</dl>
<dl>
<dt>
&quot;$normalized_string = normalize($form_name, $string)&quot;</dt>
<dd>
It returns the normalization form of $form_name.<div style="height: 1.00em;">
&#160;</div>
As $form_name, one of the following names must be given.<div style="height: 1.00em;">
&#160;</div>
<br/>
  'C'  or 'NFC'  for Normalization Form C  (UAX #15)<br/>
  'D'  or 'NFD'  for Normalization Form D  (UAX #15)<br/>
  'KC' or 'NFKC' for Normalization Form KC (UAX #15)<br/>
  'KD' or 'NFKD' for Normalization Form KD (UAX #15)<br/>
<br/>
  'FCD'          for &quot;Fast C or D&quot; Form  (UTN #5)<br/>
  'FCC'          for &quot;Fast C Contiguous&quot; (UTN #5)<br/>
</dd>
</dl>
</div>
<div class="subsection">
<h2>Decomposition and Composition</h2><dl>
<dt>
&quot;$decomposed_string = decompose($string [, $useCompatMapping])&quot;</dt>
<dd>
It returns the concatenation of the decomposition of each character in the string.<div style="height: 1.00em;">
&#160;</div>
If the second parameter (a boolean) is omitted or false, the decomposition is canonical decomposition; if the second parameter (a boolean) is true, the decomposition is compatibility decomposition.<div style="height: 1.00em;">
&#160;</div>
The string returned is not always in NFD/NFKD. Reordering may be required.<div style="height: 1.00em;">
&#160;</div>
<br/>
    $NFD_string  = reorder(decompose($string));       # eq. to NFD()<br/>
    $NFKD_string = reorder(decompose($string, TRUE)); # eq. to NFKD()<br/>
</dd>
</dl>
<dl>
<dt>
&quot;$reordered_string = reorder($string)&quot;</dt>
<dd>
It returns the result of reordering the combining characters according to Canonical Ordering Behavior.<div style="height: 1.00em;">
&#160;</div>
For example, when you have a list of NFD/NFKD strings, you can get the concatenated NFD/NFKD string from them, by saying<div style="height: 1.00em;">
&#160;</div>
<br/>
    $concat_NFD  = reorder(join '', @NFD_strings);<br/>
    $concat_NFKD = reorder(join '', @NFKD_strings);<br/>
</dd>
</dl>
<dl>
<dt>
&quot;$composed_string = compose($string)&quot;</dt>
<dd>
It returns the result of canonical composition without applying any decomposition.<div style="height: 1.00em;">
&#160;</div>
For example, when you have a NFD/NFKD string, you can get its NFC/NFKC string, by saying<div style="height: 1.00em;">
&#160;</div>
<br/>
    $NFC_string  = compose($NFD_string);<br/>
    $NFKC_string = compose($NFKD_string);<br/>
</dd>
</dl>
<dl>
<dt>
&quot;($processed, $unprocessed) = splitOnLastStarter($normalized)&quot;</dt>
<dd>
It returns two strings: the first one, $processed, is a part before the last starter, and the second one, $unprocessed is another part after the first part. A starter is a character having a combining class of zero (see UAX #15).<div style="height: 1.00em;">
&#160;</div>
Note that $processed may be empty (when $normalized contains no starter or starts with the last starter), and then $unprocessed should be equal to the entire $normalized.<div style="height: 1.00em;">
&#160;</div>
When you have a $normalized string and an $unnormalized string following it, a simple concatenation is wrong:<div style="height: 1.00em;">
&#160;</div>
<br/>
    $concat = $normalized . normalize($form, $unnormalized); # wrong!<br/>
<div style="height: 1.00em;">
&#160;</div>
Instead of it, do like this:<div style="height: 1.00em;">
&#160;</div>
<br/>
    ($processed, $unprocessed) = splitOnLastStarter($normalized);<br/>
     $concat = $processed . normalize($form, $unprocessed.$unnormalized);<br/>
<div style="height: 1.00em;">
&#160;</div>
&quot;splitOnLastStarter()&quot; should be called with a pre-normalized parameter $normalized, that is in the same form as $form you want.<div style="height: 1.00em;">
&#160;</div>
If you have an array of @string that should be concatenated and then normalized, you can do like this:<div style="height: 1.00em;">
&#160;</div>
<br/>
    my $result = &quot;&quot;;<br/>
    my $unproc = &quot;&quot;;<br/>
    foreach my $str (@string) {<br/>
        $unproc .= $str;<br/>
        my $n = normalize($form, $unproc);<br/>
        my($p, $u) = splitOnLastStarter($n);<br/>
        $result .= $p;<br/>
        $unproc  = $u;<br/>
    }<br/>
    $result .= $unproc;<br/>
    # instead of normalize($form, join('', @string))<br/>
</dd>
</dl>
<dl>
<dt>
&quot;$processed = normalize_partial($form, $unprocessed)&quot;</dt>
<dd>
A wrapper for the combination of &quot;normalize()&quot; and &quot;splitOnLastStarter()&quot;. Note that $unprocessed will be modified as a side-effect.<div style="height: 1.00em;">
&#160;</div>
If you have an array of @string that should be concatenated and then normalized, you can do like this:<div style="height: 1.00em;">
&#160;</div>
<br/>
    my $result = &quot;&quot;;<br/>
    my $unproc = &quot;&quot;;<br/>
    foreach my $str (@string) {<br/>
        $unproc .= $str;<br/>
        $result .= normalize_partial($form, $unproc);<br/>
    }<br/>
    $result .= $unproc;<br/>
    # instead of normalize($form, join('', @string))<br/>
</dd>
</dl>
<dl>
<dt>
&quot;$processed = NFD_partial($unprocessed)&quot;</dt>
<dd>
It does like &quot;normalize_partial('NFD', $unprocessed)&quot;. Note that $unprocessed will be modified as a side-effect.</dd>
</dl>
<dl>
<dt>
&quot;$processed = NFC_partial($unprocessed)&quot;</dt>
<dd>
It does like &quot;normalize_partial('NFC', $unprocessed)&quot;. Note that $unprocessed will be modified as a side-effect.</dd>
</dl>
<dl>
<dt>
&quot;$processed = NFKD_partial($unprocessed)&quot;</dt>
<dd>
It does like &quot;normalize_partial('NFKD', $unprocessed)&quot;. Note that $unprocessed will be modified as a side-effect.</dd>
</dl>
<dl>
<dt>
&quot;$processed = NFKC_partial($unprocessed)&quot;</dt>
<dd>
It does like &quot;normalize_partial('NFKC', $unprocessed)&quot;. Note that $unprocessed will be modified as a side-effect.</dd>
</dl>
</div>
<div class="subsection">
<h2>Quick Check</h2> (see Annex 8, UAX #15; and  <i>DerivedNormalizationProps.txt</i>)<div class="spacer">
</div>
The following functions check whether the string is in that normalization form.<div class="spacer">
</div>
The result returned will be one of the following:<div class="spacer">
</div>
<br/>
    YES     The string is in that normalization form.<br/>
    NO      The string is not in that normalization form.<br/>
    MAYBE   Dubious. Maybe yes, maybe no.<br/>
<dl>
<dt>
&quot;$result = checkNFD($string)&quot;</dt>
<dd>
It returns true (1) if &quot;YES&quot;; false (&quot;empty string&quot;) if &quot;NO&quot;.</dd>
</dl>
<dl>
<dt>
&quot;$result = checkNFC($string)&quot;</dt>
<dd>
It returns true (1) if &quot;YES&quot;; false (&quot;empty string&quot;) if &quot;NO&quot;; &quot;undef&quot; if &quot;MAYBE&quot;.</dd>
</dl>
<dl>
<dt>
&quot;$result = checkNFKD($string)&quot;</dt>
<dd>
It returns true (1) if &quot;YES&quot;; false (&quot;empty string&quot;) if &quot;NO&quot;.</dd>
</dl>
<dl>
<dt>
&quot;$result = checkNFKC($string)&quot;</dt>
<dd>
It returns true (1) if &quot;YES&quot;; false (&quot;empty string&quot;) if &quot;NO&quot;; &quot;undef&quot; if &quot;MAYBE&quot;.</dd>
</dl>
<dl>
<dt>
&quot;$result = checkFCD($string)&quot;</dt>
<dd>
It returns true (1) if &quot;YES&quot;; false (&quot;empty string&quot;) if &quot;NO&quot;.</dd>
</dl>
<dl>
<dt>
&quot;$result = checkFCC($string)&quot;</dt>
<dd>
It returns true (1) if &quot;YES&quot;; false (&quot;empty string&quot;) if &quot;NO&quot;; &quot;undef&quot; if &quot;MAYBE&quot;.<div style="height: 1.00em;">
&#160;</div>
Note: If a string is not in FCD, it must not be in FCC. So &quot;checkFCC($not_FCD_string)&quot; should return &quot;NO&quot;.</dd>
</dl>
<dl>
<dt>
&quot;$result = check($form_name, $string)&quot;</dt>
<dd>
It returns true (1) if &quot;YES&quot;; false (&quot;empty string&quot;) if &quot;NO&quot;; &quot;undef&quot; if &quot;MAYBE&quot;.<div style="height: 1.00em;">
&#160;</div>
As $form_name, one of the following names must be given.<div style="height: 1.00em;">
&#160;</div>
<br/>
  'C'  or 'NFC'  for Normalization Form C  (UAX #15)<br/>
  'D'  or 'NFD'  for Normalization Form D  (UAX #15)<br/>
  'KC' or 'NFKC' for Normalization Form KC (UAX #15)<br/>
  'KD' or 'NFKD' for Normalization Form KD (UAX #15)<br/>
<br/>
  'FCD'          for &quot;Fast C or D&quot; Form  (UTN #5)<br/>
  'FCC'          for &quot;Fast C Contiguous&quot; (UTN #5)<br/>
</dd>
</dl>
<div class="spacer">
</div>
<b>Note</b><div class="spacer">
</div>
In the cases of NFD, NFKD, and FCD, the answer must be either &quot;YES&quot; or &quot;NO&quot;. The answer &quot;MAYBE&quot; may be returned in the cases of NFC, NFKC, and FCC.<div class="spacer">
</div>
A &quot;MAYBE&quot; string should contain at least one combining character or the like. For example, &quot;COMBINING ACUTE ACCENT&quot; has the MAYBE_NFC/MAYBE_NFKC property.<div class="spacer">
</div>
Both &quot;checkNFC(&quot;A\N{COMBINING ACUTE ACCENT}&quot;)&quot; and &quot;checkNFC(&quot;B\N{COMBINING ACUTE ACCENT}&quot;)&quot; will return &quot;MAYBE&quot;. &quot;A\N{COMBINING ACUTE ACCENT}&quot; is not in NFC (its NFC is &quot;\N{LATIN CAPITAL LETTER A WITH ACUTE}&quot;), while &quot;B\N{COMBINING ACUTE ACCENT}&quot; is in NFC.<div class="spacer">
</div>
If you want to check exactly, compare the string with its NFC/NFKC/FCC.<div class="spacer">
</div>
<br/>
    if ($string eq NFC($string)) {<br/>
        # $string is exactly normalized in NFC;<br/>
    } else {<br/>
        # $string is not normalized in NFC;<br/>
    }<br/>
<br/>
    if ($string eq NFKC($string)) {<br/>
        # $string is exactly normalized in NFKC;<br/>
    } else {<br/>
        # $string is not normalized in NFKC;<br/>
    }<br/>
</div>
<div class="subsection">
<h2>Character Data</h2> These functions are interface of character data used internally. If you want only to get Unicode normalization forms, you don't need call them yourself.<dl>
<dt>
&quot;$canonical_decomposition = getCanon($code_point)&quot;</dt>
<dd>
If the character is canonically decomposable (including Hangul Syllables), it returns the (full) canonical decomposition as a string. Otherwise it returns &quot;undef&quot;.<div style="height: 1.00em;">
&#160;</div>
<b>Note:</b> According to the Unicode standard, the canonical decomposition of the character that is not canonically decomposable is same as the character itself.</dd>
</dl>
<dl>
<dt>
&quot;$compatibility_decomposition = getCompat($code_point)&quot;</dt>
<dd>
If the character is compatibility decomposable (including Hangul Syllables), it returns the (full) compatibility decomposition as a string. Otherwise it returns &quot;undef&quot;.<div style="height: 1.00em;">
&#160;</div>
<b>Note:</b> According to the Unicode standard, the compatibility decomposition of the character that is not compatibility decomposable is same as the character itself.</dd>
</dl>
<dl>
<dt>
&quot;$code_point_composite = getComposite($code_point_here, $code_point_next)&quot;</dt>
<dd>
If two characters here and next (as code points) are composable (including Hangul Jamo/Syllables and Composition Exclusions), it returns the code point of the composite.<div style="height: 1.00em;">
&#160;</div>
If they are not composable, it returns &quot;undef&quot;.</dd>
</dl>
<dl>
<dt>
&quot;$combining_class = getCombinClass($code_point)&quot;</dt>
<dd>
It returns the combining class (as an integer) of the character.</dd>
</dl>
<dl>
<dt>
&quot;$may_be_composed_with_prev_char = isComp2nd($code_point)&quot;</dt>
<dd>
It returns a boolean whether the character of the specified codepoint may be composed with the previous one in a certain composition (including Hangul Compositions, but excluding Composition Exclusions and Non-Starter Decompositions).</dd>
</dl>
<dl>
<dt>
&quot;$is_exclusion = isExclusion($code_point)&quot;</dt>
<dd>
It returns a boolean whether the code point is a composition exclusion.</dd>
</dl>
<dl>
<dt>
&quot;$is_singleton = isSingleton($code_point)&quot;</dt>
<dd>
It returns a boolean whether the code point is a singleton</dd>
</dl>
<dl>
<dt>
&quot;$is_non_starter_decomposition = isNonStDecomp($code_point)&quot;</dt>
<dd>
It returns a boolean whether the code point has Non-Starter Decomposition.</dd>
</dl>
<dl>
<dt>
&quot;$is_Full_Composition_Exclusion = isComp_Ex($code_point)&quot;</dt>
<dd>
It returns a boolean of the derived property Comp_Ex (Full_Composition_Exclusion). This property is generated from Composition Exclusions + Singletons + Non-Starter Decompositions.</dd>
</dl>
<dl>
<dt>
&quot;$NFD_is_NO = isNFD_NO($code_point)&quot;</dt>
<dd>
It returns a boolean of the derived property NFD_NO (NFD_Quick_Check=No).</dd>
</dl>
<dl>
<dt>
&quot;$NFC_is_NO = isNFC_NO($code_point)&quot;</dt>
<dd>
It returns a boolean of the derived property NFC_NO (NFC_Quick_Check=No).</dd>
</dl>
<dl>
<dt>
&quot;$NFC_is_MAYBE = isNFC_MAYBE($code_point)&quot;</dt>
<dd>
It returns a boolean of the derived property NFC_MAYBE (NFC_Quick_Check=Maybe).</dd>
</dl>
<dl>
<dt>
&quot;$NFKD_is_NO = isNFKD_NO($code_point)&quot;</dt>
<dd>
It returns a boolean of the derived property NFKD_NO (NFKD_Quick_Check=No).</dd>
</dl>
<dl>
<dt>
&quot;$NFKC_is_NO = isNFKC_NO($code_point)&quot;</dt>
<dd>
It returns a boolean of the derived property NFKC_NO (NFKC_Quick_Check=No).</dd>
</dl>
<dl>
<dt>
&quot;$NFKC_is_MAYBE = isNFKC_MAYBE($code_point)&quot;</dt>
<dd>
It returns a boolean of the derived property NFKC_MAYBE (NFKC_Quick_Check=Maybe).</dd>
</dl>
</div>
</div>
<div class="section">
<h1>EXPORT</h1> &quot;NFC&quot;, &quot;NFD&quot;, &quot;NFKC&quot;, &quot;NFKD&quot;: by default.<div class="spacer">
</div>
&quot;normalize&quot; and other some functions: on request.</div>
<div class="section">
<h1>CAVEATS</h1><dl>
<dt>
Perl's version vs. Unicode version</dt>
<dd>
Since this module refers to perl core's Unicode database in the directory  <i>/lib/unicore</i> (or formerly <i>/lib/unicode</i>), the Unicode version of normalization implemented by this module depends on your perl's version.<div style="height: 1.00em;">
&#160;</div>
<br/>
    perl's version     implemented Unicode version<br/>
       5.6.1              3.0.1<br/>
       5.7.2              3.1.0<br/>
       5.7.3              3.1.1 (normalization is same as 3.1.0)<br/>
       5.8.0              3.2.0<br/>
     5.8.1-5.8.3          4.0.0<br/>
     5.8.4-5.8.6          4.0.1 (normalization is same as 4.0.0)<br/>
     5.8.7-5.8.8          4.1.0<br/>
       5.10.0             5.0.0<br/>
    5.8.9, 5.10.1         5.1.0<br/>
    5.12.0-5.12.2         5.2.0<br/>
   (5.13.7-5.13.11)        6.0.0<br/>
</dd>
</dl>
<dl>
<dt>
Correction of decomposition mapping</dt>
<dd>
In older Unicode versions, a small number of characters (all of which are CJK compatibility ideographs as far as they have been found) may have an erroneous decomposition mapping (see  <i>NormalizationCorrections.txt</i>). Anyhow, this module will neither refer to  <i>NormalizationCorrections.txt</i> nor provide any specific version of normalization. Therefore this module running on an older perl with an older Unicode database may use the erroneous decomposition mapping blindly conforming to the Unicode database.</dd>
</dl>
<dl>
<dt>
Revised definition of canonical composition</dt>
<dd>
In Unicode 4.1.0, the definition D2 of canonical composition (which affects NFC and NFKC) has been changed (see Public Review Issue #29 and recent UAX #15). This module has used the newer definition since the version 0.07 (Oct 31, 2001). This module will not support the normalization according to the older definition, even if the Unicode version implemented by perl is lower than 4.1.0.</dd>
</dl>
</div>
<div class="section">
<h1>AUTHOR</h1> SADAHIRO Tomoyuki &lt;SADAHIRO@cpan.org&gt;<div class="spacer">
</div>
Copyright(C) 2001-2011, SADAHIRO Tomoyuki. Japan. All rights reserved.<div class="spacer">
</div>
This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</div>
<div class="section">
<h1>SEE ALSO</h1><dl>
<dt>
http://www.unicode.org/reports/tr15/</dt>
<dd>
Unicode Normalization Forms - UAX #15</dd>
</dl>
<dl>
<dt>
http://www.unicode.org/Public/UNIDATA/CompositionExclusions.txt</dt>
<dd>
Composition Exclusion Table</dd>
</dl>
<dl>
<dt>
http://www.unicode.org/Public/UNIDATA/DerivedNormalizationProps.txt</dt>
<dd>
Derived Normalization Properties</dd>
</dl>
<dl>
<dt>
http://www.unicode.org/Public/UNIDATA/NormalizationCorrections.txt</dt>
<dd>
Normalization Corrections</dd>
</dl>
<dl>
<dt>
http://www.unicode.org/review/pr-29.html</dt>
<dd>
Public Review Issue #29: Normalization Issue</dd>
</dl>
<dl>
<dt>
http://www.unicode.org/notes/tn5/</dt>
<dd>
Canonical Equivalence in Applications - UTN #5</dd>
</dl>
</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-09-26</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

