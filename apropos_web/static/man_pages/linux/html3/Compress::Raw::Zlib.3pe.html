<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Compress::Raw::Zlib(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Compress::Raw::Zlib(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
Compress::Raw::Zlib(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Compress::Raw::Zlib - Low-Level Interface to zlib compression library</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
    use Compress::Raw::Zlib ;<br/>
<br/>
    ($d, $status) = new Compress::Raw::Zlib::Deflate( [OPT] ) ;<br/>
    $status = $d-&gt;deflate($input, $output) ;<br/>
    $status = $d-&gt;flush($output [, $flush_type]) ;<br/>
    $d-&gt;deflateReset() ;<br/>
    $d-&gt;deflateParams(OPTS) ;<br/>
    $d-&gt;deflateTune(OPTS) ;<br/>
    $d-&gt;dict_adler() ;<br/>
    $d-&gt;crc32() ;<br/>
    $d-&gt;adler32() ;<br/>
    $d-&gt;total_in() ;<br/>
    $d-&gt;total_out() ;<br/>
    $d-&gt;msg() ;<br/>
    $d-&gt;get_Strategy();<br/>
    $d-&gt;get_Level();<br/>
    $d-&gt;get_BufSize();<br/>
<br/>
    ($i, $status) = new Compress::Raw::Zlib::Inflate( [OPT] ) ;<br/>
    $status = $i-&gt;inflate($input, $output [, $eof]) ;<br/>
    $status = $i-&gt;inflateSync($input) ;<br/>
    $i-&gt;inflateReset() ;<br/>
    $i-&gt;dict_adler() ;<br/>
    $d-&gt;crc32() ;<br/>
    $d-&gt;adler32() ;<br/>
    $i-&gt;total_in() ;<br/>
    $i-&gt;total_out() ;<br/>
    $i-&gt;msg() ;<br/>
    $d-&gt;get_BufSize();<br/>
<br/>
    $crc = adler32($buffer [,$crc]) ;<br/>
    $crc = crc32($buffer [,$crc]) ;<br/>
<br/>
    $crc = adler32_combine($crc1, $crc2, $len2)l<br/>
    $crc = crc32_combine($adler1, $adler2, $len2)<br/>
<br/>
    my $version = Compress::Raw::Zlib::zlib_version();<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> The  <i>Compress::Raw::Zlib</i> module provides a Perl interface to the <i>zlib</i> compression library (see &quot;AUTHOR&quot; for details about where to get  <i>zlib</i>).</div>
<div class="section">
<h1>Compress::Raw::Zlib::Deflate</h1> This section defines an interface that allows in-memory compression using the  <i>deflate</i> interface provided by zlib.<div class="spacer">
</div>
Here is a definition of the interface available:<div class="subsection">
<h2><b>($d, </b><b>$status</b><b>) = new Compress::Raw::Zlib::Deflate( [OPT] ) </b></h2> Initialises a deflation object.<div class="spacer">
</div>
If you are familiar with the <i>zlib</i> library, it combines the features of the  <i>zlib</i> functions &quot;deflateInit&quot;, &quot;deflateInit2&quot; and &quot;deflateSetDictionary&quot;.<div class="spacer">
</div>
If successful, it will return the initialised deflation object, $d and a $status of &quot;Z_OK&quot; in a list context. In scalar context it returns the deflation object, $d, only.<div class="spacer">
</div>
If not successful, the returned deflation object, $d, will be  <i>undef</i> and $status will hold the a <i>zlib</i> error code.<div class="spacer">
</div>
The function optionally takes a number of named options specified as &quot;Name =&gt; value&quot; pairs. This allows individual options to be tailored without having to specify them all in the parameter list.<div class="spacer">
</div>
For backward compatibility, it is also possible to pass the parameters as a reference to a hash containing the name=&gt;value pairs.<div class="spacer">
</div>
Below is a list of the valid options:<dl>
<dt>
<b>-Level</b></dt>
<dd>
Defines the compression level. Valid values are 0 through 9, &quot;Z_NO_COMPRESSION&quot;, &quot;Z_BEST_SPEED&quot;, &quot;Z_BEST_COMPRESSION&quot;, and &quot;Z_DEFAULT_COMPRESSION&quot;.<div style="height: 1.00em;">
&#160;</div>
The default is &quot;Z_DEFAULT_COMPRESSION&quot;.</dd>
</dl>
<dl>
<dt>
<b>-Method</b></dt>
<dd>
Defines the compression method. The only valid value at present (and the default) is &quot;Z_DEFLATED&quot;.</dd>
</dl>
<dl>
<dt>
<b>-WindowBits</b></dt>
<dd>
To compress an RFC 1950 data stream, set &quot;WindowBits&quot; to a positive number between 8 and 15.<div style="height: 1.00em;">
&#160;</div>
To compress an RFC 1951 data stream, set &quot;WindowBits&quot; to &quot;-MAX_WBITS&quot;.<div style="height: 1.00em;">
&#160;</div>
To compress an RFC 1952 data stream (i.e. gzip), set &quot;WindowBits&quot; to &quot;WANT_GZIP&quot;.<div style="height: 1.00em;">
&#160;</div>
For a definition of the meaning and valid values for &quot;WindowBits&quot; refer to the  <i>zlib</i> documentation for <i>deflateInit2</i>.<div style="height: 1.00em;">
&#160;</div>
Defaults to &quot;MAX_WBITS&quot;.</dd>
</dl>
<dl>
<dt>
<b>-MemLevel</b></dt>
<dd>
For a definition of the meaning and valid values for &quot;MemLevel&quot; refer to the  <i>zlib</i> documentation for <i>deflateInit2</i>.<div style="height: 1.00em;">
&#160;</div>
Defaults to MAX_MEM_LEVEL.</dd>
</dl>
<dl>
<dt>
<b>-Strategy</b></dt>
<dd>
Defines the strategy used to tune the compression. The valid values are &quot;Z_DEFAULT_STRATEGY&quot;, &quot;Z_FILTERED&quot;, &quot;Z_RLE&quot;, &quot;Z_FIXED&quot; and &quot;Z_HUFFMAN_ONLY&quot;.<div style="height: 1.00em;">
&#160;</div>
The default is &quot;Z_DEFAULT_STRATEGY&quot;.</dd>
</dl>
<dl>
<dt>
<b>-Dictionary</b></dt>
<dd>
When a dictionary is specified <i>Compress::Raw::Zlib</i> will automatically call &quot;deflateSetDictionary&quot; directly after calling &quot;deflateInit&quot;. The Adler32 value for the dictionary can be obtained by calling the method &quot;$d-&gt;dict_adler()&quot;.<div style="height: 1.00em;">
&#160;</div>
The default is no dictionary.</dd>
</dl>
<dl>
<dt>
<b>-Bufsize</b></dt>
<dd>
Sets the initial size for the output buffer used by the &quot;$d-&gt;deflate&quot; and &quot;$d-&gt;flush&quot; methods. If the buffer has to be reallocated to increase the size, it will grow in increments of &quot;Bufsize&quot;.<div style="height: 1.00em;">
&#160;</div>
The default buffer size is 4096.</dd>
</dl>
<dl>
<dt>
<b>-AppendOutput</b></dt>
<dd>
This option controls how data is written to the output buffer by the &quot;$d-&gt;deflate&quot; and &quot;$d-&gt;flush&quot; methods.<div style="height: 1.00em;">
&#160;</div>
If the &quot;AppendOutput&quot; option is set to false, the output buffers in the &quot;$d-&gt;deflate&quot; and &quot;$d-&gt;flush&quot;  methods will be truncated before uncompressed data is written to them.<div style="height: 1.00em;">
&#160;</div>
If the option is set to true, uncompressed data will be appended to the output buffer in the &quot;$d-&gt;deflate&quot; and &quot;$d-&gt;flush&quot; methods.<div style="height: 1.00em;">
&#160;</div>
This option defaults to false.</dd>
</dl>
<dl>
<dt>
<b>-CRC32</b></dt>
<dd>
If set to true, a crc32 checksum of the uncompressed data will be calculated. Use the &quot;$d-&gt;crc32&quot; method to retrieve this value.<div style="height: 1.00em;">
&#160;</div>
This option defaults to false.</dd>
</dl>
<dl>
<dt>
<b>-ADLER32</b></dt>
<dd>
If set to true, an adler32 checksum of the uncompressed data will be calculated. Use the &quot;$d-&gt;adler32&quot; method to retrieve this value.<div style="height: 1.00em;">
&#160;</div>
This option defaults to false.</dd>
</dl>
<div class="spacer">
</div>
Here is an example of using the &quot;Compress::Raw::Zlib::Deflate&quot; optional parameter list to override the default buffer size and compression level. All other options will take their default values.<div class="spacer">
</div>
<br/>
    my $d = new Compress::Raw::Zlib::Deflate ( -Bufsize =&gt; 300, <br/>
                                               -Level   =&gt; Z_BEST_SPEED ) ;<br/>
</div>
<div class="subsection">
<h2><b></b><b>$status</b><b> = </b><b>$d</b><b>-&gt;deflate($input, </b><b>$output</b><b>)</b></h2> Deflates the contents of $input and writes the compressed data to $output.<div class="spacer">
</div>
The $input and $output parameters can be either scalars or scalar references.<div class="spacer">
</div>
When finished, $input will be completely processed (assuming there were no errors). If the deflation was successful it writes the deflated data to $output and returns a status value of &quot;Z_OK&quot;.<div class="spacer">
</div>
On error, it returns a <i>zlib</i> error code.<div class="spacer">
</div>
If the &quot;AppendOutput&quot; option is set to true in the constructor for the $d object, the compressed data will be appended to $output. If it is false, $output will be truncated before any compressed data is written to it.<div class="spacer">
</div>
<b>Note</b>: This method will not necessarily write compressed data to $output every time it is called. So do not assume that there has been an error if the contents of $output is empty on returning from this method. As long as the return code from the method is &quot;Z_OK&quot;, the deflate has succeeded.</div>
<div class="subsection">
<h2><b></b><b>$status</b><b> = </b><b>$d</b><b>-&gt;flush($output [, </b><b>$flush_type</b><b>]) </b></h2> Typically used to finish the deflation. Any pending output will be written to $output.<div class="spacer">
</div>
Returns &quot;Z_OK&quot; if successful.<div class="spacer">
</div>
Note that flushing can seriously degrade the compression ratio, so it should only be used to terminate a decompression (using &quot;Z_FINISH&quot;) or when you want to create a  <i>full flush point</i> (using &quot;Z_FULL_FLUSH&quot;).<div class="spacer">
</div>
By default the &quot;flush_type&quot; used is &quot;Z_FINISH&quot;. Other valid values for &quot;flush_type&quot; are &quot;Z_NO_FLUSH&quot;, &quot;Z_PARTIAL_FLUSH&quot;, &quot;Z_SYNC_FLUSH&quot; and &quot;Z_FULL_FLUSH&quot;. It is strongly recommended that you only set the &quot;flush_type&quot; parameter if you fully understand the implications of what it does. See the &quot;zlib&quot; documentation for details.<div class="spacer">
</div>
If the &quot;AppendOutput&quot; option is set to true in the constructor for the $d object, the compressed data will be appended to $output. If it is false, $output will be truncated before any compressed data is written to it.</div>
<div class="subsection">
<h2><b></b><b>$status</b><b> = </b><b>$d</b><b>-&gt;</b><b><i>deflateReset()</i></b><b> </b></h2> This method will reset the deflation object $d. It can be used when you are compressing multiple data streams and want to use the same object to compress each of them. It should only be used once the previous data stream has been flushed successfully, i.e. a call to &quot;$d-&gt;flush(Z_FINISH)&quot; has returned &quot;Z_OK&quot;.<div class="spacer">
</div>
Returns &quot;Z_OK&quot; if successful.</div>
<div class="subsection">
<h2><b></b><b>$status</b><b> = </b><b>$d</b><b>-&gt;deflateParams([OPT])</b></h2> Change settings for the deflate object $d.<div class="spacer">
</div>
The list of the valid options is shown below. Options not specified will remain unchanged.<dl>
<dt>
<b>-Level</b></dt>
<dd>
Defines the compression level. Valid values are 0 through 9, &quot;Z_NO_COMPRESSION&quot;, &quot;Z_BEST_SPEED&quot;, &quot;Z_BEST_COMPRESSION&quot;, and &quot;Z_DEFAULT_COMPRESSION&quot;.</dd>
</dl>
<dl>
<dt>
<b>-Strategy</b></dt>
<dd>
Defines the strategy used to tune the compression. The valid values are &quot;Z_DEFAULT_STRATEGY&quot;, &quot;Z_FILTERED&quot; and &quot;Z_HUFFMAN_ONLY&quot;.</dd>
</dl>
<dl>
<dt>
<b>-BufSize</b></dt>
<dd>
Sets the initial size for the output buffer used by the &quot;$d-&gt;deflate&quot; and &quot;$d-&gt;flush&quot; methods. If the buffer has to be reallocated to increase the size, it will grow in increments of &quot;Bufsize&quot;.</dd>
</dl>
</div>
<div class="subsection">
<h2><b></b><b>$status</b><b> = </b><b>$d</b><b>-&gt;deflateTune($good_length, </b><b>$max_lazy</b><b>, </b><b>$nice_length</b><b>, </b><b>$max_chain</b><b>)</b></h2> Tune the internal settings for the deflate object $d. This option is only available if you are running zlib 1.2.2.3 or better.<div class="spacer">
</div>
Refer to the documentation in zlib.h for instructions on how to fly &quot;deflateTune&quot;.</div>
<div class="subsection">
<h2><b></b><b>$d</b><b>-&gt;</b><b><i>dict_adler()</i></b><b></b></h2> Returns the adler32 value for the dictionary.</div>
<div class="subsection">
<h2><b></b><b>$d</b><b>-&gt;</b><b><i>crc32()</i></b><b></b></h2> Returns the crc32 value for the uncompressed data to date.<div class="spacer">
</div>
If the &quot;CRC32&quot; option is not enabled in the constructor for this object, this method will always return 0;</div>
<div class="subsection">
<h2><b></b><b>$d</b><b>-&gt;</b><b><i>adler32()</i></b><b></b></h2> Returns the adler32 value for the uncompressed data to date.</div>
<div class="subsection">
<h2><b></b><b>$d</b><b>-&gt;</b><b><i>msg()</i></b><b></b></h2> Returns the last error message generated by zlib.</div>
<div class="subsection">
<h2><b></b><b>$d</b><b>-&gt;</b><b><i>total_in()</i></b><b></b></h2> Returns the total number of bytes uncompressed bytes input to deflate.</div>
<div class="subsection">
<h2><b></b><b>$d</b><b>-&gt;</b><b><i>total_out()</i></b><b></b></h2> Returns the total number of compressed bytes output from deflate.</div>
<div class="subsection">
<h2><b></b><b>$d</b><b>-&gt;</b><b><i>get_Strategy()</i></b><b></b></h2> Returns the deflation strategy currently used. Valid values are &quot;Z_DEFAULT_STRATEGY&quot;, &quot;Z_FILTERED&quot; and &quot;Z_HUFFMAN_ONLY&quot;.</div>
<div class="subsection">
<h2><b></b><b>$d</b><b>-&gt;</b><b><i>get_Level()</i></b><b></b></h2> Returns the compression level being used.</div>
<div class="subsection">
<h2><b></b><b>$d</b><b>-&gt;</b><b><i>get_BufSize()</i></b><b></b></h2> Returns the buffer size used to carry out the compression.</div>
<div class="subsection">
<h2>Example</h2> Here is a trivial example of using &quot;deflate&quot;. It simply reads standard input, deflates it and writes it to standard output.<div class="spacer">
</div>
<br/>
    use strict ;<br/>
    use warnings ;<br/>
<br/>
    use Compress::Raw::Zlib ;<br/>
<br/>
    binmode STDIN;<br/>
    binmode STDOUT;<br/>
    my $x = new Compress::Raw::Zlib::Deflate<br/>
       or die &quot;Cannot create a deflation stream\n&quot; ;<br/>
<br/>
    my ($output, $status) ;<br/>
    while (&lt;&gt;)<br/>
    {<br/>
        $status = $x-&gt;deflate($_, $output) ;<br/>
    <br/>
        $status == Z_OK<br/>
            or die &quot;deflation failed\n&quot; ;<br/>
    <br/>
        print $output ;<br/>
    }<br/>
    <br/>
    $status = $x-&gt;flush($output) ;<br/>
    <br/>
    $status == Z_OK<br/>
        or die &quot;deflation failed\n&quot; ;<br/>
    <br/>
    print $output ;<br/>
</div>
</div>
<div class="section">
<h1>Compress::Raw::Zlib::Inflate</h1> This section defines an interface that allows in-memory uncompression using the  <i>inflate</i> interface provided by zlib.<div class="spacer">
</div>
Here is a definition of the interface:<div class="subsection">
<h2><b> ($i, </b><b>$status</b><b>) = new Compress::Raw::Zlib::Inflate( [OPT] ) </b></h2> Initialises an inflation object.<div class="spacer">
</div>
In a list context it returns the inflation object, $i, and the  <i>zlib</i> status code ($status). In a scalar context it returns the inflation object only.<div class="spacer">
</div>
If successful, $i will hold the inflation object and $status will be &quot;Z_OK&quot;.<div class="spacer">
</div>
If not successful, $i will be <i>undef</i> and $status will hold the  <i>zlib</i> error code.<div class="spacer">
</div>
The function optionally takes a number of named options specified as &quot;-Name =&gt; value&quot; pairs. This allows individual options to be tailored without having to specify them all in the parameter list.<div class="spacer">
</div>
For backward compatibility, it is also possible to pass the parameters as a reference to a hash containing the &quot;name=&gt;value&quot; pairs.<div class="spacer">
</div>
Here is a list of the valid options:<dl>
<dt>
<b>-WindowBits</b></dt>
<dd>
To uncompress an RFC 1950 data stream, set &quot;WindowBits&quot; to a positive number between 8 and 15.<div style="height: 1.00em;">
&#160;</div>
To uncompress an RFC 1951 data stream, set &quot;WindowBits&quot; to &quot;-MAX_WBITS&quot;.<div style="height: 1.00em;">
&#160;</div>
To uncompress an RFC 1952 data stream (i.e. gzip), set &quot;WindowBits&quot; to &quot;WANT_GZIP&quot;.<div style="height: 1.00em;">
&#160;</div>
To auto-detect and uncompress an RFC 1950 or RFC 1952 data stream (i.e. gzip), set &quot;WindowBits&quot; to &quot;WANT_GZIP_OR_ZLIB&quot;.<div style="height: 1.00em;">
&#160;</div>
For a full definition of the meaning and valid values for &quot;WindowBits&quot; refer to the  <i>zlib</i> documentation for <i>inflateInit2</i>.<div style="height: 1.00em;">
&#160;</div>
Defaults to &quot;MAX_WBITS&quot;.</dd>
</dl>
<dl>
<dt>
<b>-Bufsize</b></dt>
<dd>
Sets the initial size for the output buffer used by the &quot;$i-&gt;inflate&quot; method. If the output buffer in this method has to be reallocated to increase the size, it will grow in increments of &quot;Bufsize&quot;.<div style="height: 1.00em;">
&#160;</div>
Default is 4096.</dd>
</dl>
<dl>
<dt>
<b>-Dictionary</b></dt>
<dd>
The default is no dictionary.</dd>
</dl>
<dl>
<dt>
<b>-AppendOutput</b></dt>
<dd>
This option controls how data is written to the output buffer by the &quot;$i-&gt;inflate&quot; method.<div style="height: 1.00em;">
&#160;</div>
If the option is set to false, the output buffer in the &quot;$i-&gt;inflate&quot; method will be truncated before uncompressed data is written to it.<div style="height: 1.00em;">
&#160;</div>
If the option is set to true, uncompressed data will be appended to the output buffer by the &quot;$i-&gt;inflate&quot; method.<div style="height: 1.00em;">
&#160;</div>
This option defaults to false.</dd>
</dl>
<dl>
<dt>
<b>-CRC32</b></dt>
<dd>
If set to true, a crc32 checksum of the uncompressed data will be calculated. Use the &quot;$i-&gt;crc32&quot; method to retrieve this value.<div style="height: 1.00em;">
&#160;</div>
This option defaults to false.</dd>
</dl>
<dl>
<dt>
<b>-ADLER32</b></dt>
<dd>
If set to true, an adler32 checksum of the uncompressed data will be calculated. Use the &quot;$i-&gt;adler32&quot; method to retrieve this value.<div style="height: 1.00em;">
&#160;</div>
This option defaults to false.</dd>
</dl>
<dl>
<dt>
<b>-ConsumeInput</b></dt>
<dd>
If set to true, this option will remove compressed data from the input buffer of the &quot;$i-&gt;inflate&quot; method as the inflate progresses.<div style="height: 1.00em;">
&#160;</div>
This option can be useful when you are processing compressed data that is embedded in another file/buffer. In this case the data that immediately follows the compressed stream will be left in the input buffer.<div style="height: 1.00em;">
&#160;</div>
This option defaults to true.</dd>
</dl>
<dl>
<dt>
<b>-LimitOutput</b></dt>
<dd>
The &quot;LimitOutput&quot; option changes the behavior of the &quot;$i-&gt;inflate&quot; method so that the amount of memory used by the output buffer can be limited.<div style="height: 1.00em;">
&#160;</div>
When &quot;LimitOutput&quot; is used the size of the output buffer used will either be the value of the &quot;Bufsize&quot; option or the amount of memory already allocated to $output, whichever is larger. Predicting the output size available is tricky, so don't rely on getting an exact output buffer size.<div style="height: 1.00em;">
&#160;</div>
When &quot;LimitOutout&quot; is not specified &quot;$i-&gt;inflate&quot; will use as much memory as it takes to write all the uncompressed data it creates by uncompressing the input buffer.<div style="height: 1.00em;">
&#160;</div>
If &quot;LimitOutput&quot; is enabled, the &quot;ConsumeInput&quot; option will also be enabled.<div style="height: 1.00em;">
&#160;</div>
This option defaults to false.<div style="height: 1.00em;">
&#160;</div>
See &quot;The LimitOutput option&quot; for a discussion on why &quot;LimitOutput&quot; is needed and how to use it.</dd>
</dl>
<div class="spacer">
</div>
Here is an example of using an optional parameter to override the default buffer size.<div class="spacer">
</div>
<br/>
    my ($i, $status) = new Compress::Raw::Zlib::Inflate( -Bufsize =&gt; 300 ) ;<br/>
</div>
<div class="subsection">
<h2><b> </b><b>$status</b><b> = </b><b>$i</b><b>-&gt;inflate($input, </b><b>$output</b><b> [,$eof]) </b></h2> Inflates the complete contents of $input and writes the uncompressed data to $output. The $input and $output parameters can either be scalars or scalar references.<div class="spacer">
</div>
Returns &quot;Z_OK&quot; if successful and &quot;Z_STREAM_END&quot; if the end of the compressed data has been successfully reached.<div class="spacer">
</div>
If not successful $status will hold the <i>zlib</i> error code.<div class="spacer">
</div>
If the &quot;ConsumeInput&quot; option has been set to true when the &quot;Compress::Raw::Zlib::Inflate&quot; object is created, the $input parameter is modified by &quot;inflate&quot;. On completion it will contain what remains of the input buffer after inflation. In practice, this means that when the return status is &quot;Z_OK&quot; the $input parameter will contain an empty string, and when the return status is &quot;Z_STREAM_END&quot; the $input parameter will contains what (if anything) was stored in the input buffer after the deflated data stream.<div class="spacer">
</div>
This feature is useful when processing a file format that encapsulates a compressed data stream (e.g. gzip, zip) and there is useful data immediately after the deflation stream.<div class="spacer">
</div>
If the &quot;AppendOutput&quot; option is set to true in the constructor for this object, the uncompressed data will be appended to $output. If it is false, $output will be truncated before any uncompressed data is written to it.<div class="spacer">
</div>
The $eof parameter needs a bit of explanation.<div class="spacer">
</div>
Prior to version 1.2.0, zlib assumed that there was at least one trailing byte immediately after the compressed data stream when it was carrying out decompression. This normally isn't a problem because the majority of zlib applications guarantee that there will be data directly after the compressed data stream.  For example, both gzip (RFC 1950) and zip both define trailing data that follows the compressed data stream.<div class="spacer">
</div>
The $eof parameter only needs to be used if <b>all</b> of the following conditions apply<dl>
<dt>
1.</dt>
<dd>
You are either using a copy of zlib that is older than version 1.2.0 or you want your application code to be able to run with as many different versions of zlib as possible.</dd>
</dl>
<dl>
<dt>
2.</dt>
<dd>
You have set the &quot;WindowBits&quot; parameter to &quot;-MAX_WBITS&quot; in the constructor for this object, i.e. you are uncompressing a raw deflated data stream (RFC 1951).</dd>
</dl>
<dl>
<dt>
3.</dt>
<dd>
There is no data immediately after the compressed data stream.</dd>
</dl>
<div class="spacer">
</div>
If <b>all</b> of these are the case, then you need to set the $eof parameter to true on the final call (and only the final call) to &quot;$i-&gt;inflate&quot;.<div class="spacer">
</div>
If you have built this module with zlib &gt;= 1.2.0, the $eof parameter is ignored. You can still set it if you want, but it won't be used behind the scenes.</div>
<div class="subsection">
<h2><b></b><b>$status</b><b> = </b><b>$i</b><b>-&gt;inflateSync($input)</b></h2> This method can be used to attempt to recover good data from a compressed data stream that is partially corrupt. It scans $input until it reaches either a  <i>full flush point</i> or the end of the buffer.<div class="spacer">
</div>
If a <i>full flush point</i> is found, &quot;Z_OK&quot; is returned and $input will be have all data up to the flush point removed. This data can then be passed to the &quot;$i-&gt;inflate&quot; method to be uncompressed.<div class="spacer">
</div>
Any other return code means that a flush point was not found. If more data is available, &quot;inflateSync&quot; can be called repeatedly with more compressed data until the flush point is found.<div class="spacer">
</div>
Note <i>full flush points</i> are not present by default in compressed data streams. They must have been added explicitly when the data stream was created by calling &quot;Compress::Deflate::flush&quot;  with &quot;Z_FULL_FLUSH&quot;.</div>
<div class="subsection">
<h2><b></b><b>$status</b><b> = </b><b>$i</b><b>-&gt;</b><b><i>inflateReset()</i></b><b> </b></h2> This method will reset the inflation object $i. It can be used when you are uncompressing multiple data streams and want to use the same object to uncompress each of them.<div class="spacer">
</div>
Returns &quot;Z_OK&quot; if successful.</div>
<div class="subsection">
<h2><b></b><b>$i</b><b>-&gt;</b><b><i>dict_adler()</i></b><b></b></h2> Returns the adler32 value for the dictionary.</div>
<div class="subsection">
<h2><b></b><b>$i</b><b>-&gt;</b><b><i>crc32()</i></b><b></b></h2> Returns the crc32 value for the uncompressed data to date.<div class="spacer">
</div>
If the &quot;CRC32&quot; option is not enabled in the constructor for this object, this method will always return 0;</div>
<div class="subsection">
<h2><b></b><b>$i</b><b>-&gt;</b><b><i>adler32()</i></b><b></b></h2> Returns the adler32 value for the uncompressed data to date.<div class="spacer">
</div>
If the &quot;ADLER32&quot; option is not enabled in the constructor for this object, this method will always return 0;</div>
<div class="subsection">
<h2><b></b><b>$i</b><b>-&gt;</b><b><i>msg()</i></b><b></b></h2> Returns the last error message generated by zlib.</div>
<div class="subsection">
<h2><b></b><b>$i</b><b>-&gt;</b><b><i>total_in()</i></b><b></b></h2> Returns the total number of bytes compressed bytes input to inflate.</div>
<div class="subsection">
<h2><b></b><b>$i</b><b>-&gt;</b><b><i>total_out()</i></b><b></b></h2> Returns the total number of uncompressed bytes output from inflate.</div>
<div class="subsection">
<h2><b></b><b>$d</b><b>-&gt;</b><b><i>get_BufSize()</i></b><b></b></h2> Returns the buffer size used to carry out the decompression.</div>
<div class="subsection">
<h2>Examples</h2> Here is an example of using &quot;inflate&quot;.<div class="spacer">
</div>
<br/>
    use strict ;<br/>
    use warnings ;<br/>
    <br/>
    use Compress::Raw::Zlib;<br/>
    <br/>
    my $x = new Compress::Raw::Zlib::Inflate()<br/>
       or die &quot;Cannot create a inflation stream\n&quot; ;<br/>
    <br/>
    my $input = '' ;<br/>
    binmode STDIN;<br/>
    binmode STDOUT;<br/>
    <br/>
    my ($output, $status) ;<br/>
    while (read(STDIN, $input, 4096))<br/>
    {<br/>
        $status = $x-&gt;inflate($input, $output) ;<br/>
    <br/>
        print $output ;<br/>
    <br/>
        last if $status != Z_OK ;<br/>
    }<br/>
    <br/>
    die &quot;inflation failed\n&quot;<br/>
        unless $status == Z_STREAM_END ;<br/>
<div class="spacer">
</div>
The next example show how to use the &quot;LimitOutput&quot; option. Notice the use of two nested loops in this case. The outer loop reads the data from the input source - STDIN and the inner loop repeatedly calls &quot;inflate&quot; until $input is exhausted, we get an error, or the end of the stream is reached. One point worth remembering is by using the &quot;LimitOutput&quot; option you also get &quot;ConsumeInput&quot; set as well - this makes the code below much simpler.<div class="spacer">
</div>
<br/>
    use strict ;<br/>
    use warnings ;<br/>
    <br/>
    use Compress::Raw::Zlib;<br/>
    <br/>
    my $x = new Compress::Raw::Zlib::Inflate(LimitOutput =&gt; 1)<br/>
       or die &quot;Cannot create a inflation stream\n&quot; ;<br/>
    <br/>
    my $input = '' ;<br/>
    binmode STDIN;<br/>
    binmode STDOUT;<br/>
    <br/>
    my ($output, $status) ;<br/>
<br/>
  OUTER:<br/>
    while (read(STDIN, $input, 4096))<br/>
    {<br/>
        do<br/>
        {<br/>
            $status = $x-&gt;inflate($input, $output) ;<br/>
<br/>
            print $output ;<br/>
<br/>
            last OUTER<br/>
                unless $status == Z_OK || $status == Z_BUF_ERROR ;<br/>
        }<br/>
        while ($status == Z_OK &amp;&amp; length $input);<br/>
    }<br/>
    <br/>
    die &quot;inflation failed\n&quot;<br/>
        unless $status == Z_STREAM_END ;<br/>
</div>
</div>
<div class="section">
<h1>CHECKSUM FUNCTIONS</h1> Two functions are provided by  <i>zlib</i> to calculate checksums. For the Perl interface, the order of the two parameters in both functions has been reversed. This allows both running checksums and one off calculations to be done.<div class="spacer">
</div>
<br/>
    $crc = adler32($buffer [,$crc]) ;<br/>
    $crc = crc32($buffer [,$crc]) ;<br/>
<div class="spacer">
</div>
The buffer parameters can either be a scalar or a scalar reference.<div class="spacer">
</div>
If the $crc parameters is &quot;undef&quot;, the crc value will be reset.<div class="spacer">
</div>
If you have built this module with zlib 1.2.3 or better, two more CRC-related functions are available.<div class="spacer">
</div>
<br/>
    $crc = adler32_combine($crc1, $crc2, $len2)l<br/>
    $crc = crc32_combine($adler1, $adler2, $len2)<br/>
<div class="spacer">
</div>
These functions allow checksums to be merged.</div>
<div class="section">
<h1>Misc</h1><div class="subsection">
<h2>my $version = <i>Compress::Raw::Zlib::zlib_version()</i>;</h2> Returns the version of the zlib library.</div>
</div>
<div class="section">
<h1>The LimitOutput option.</h1> By default &quot;$i-&gt;inflate($input, $output)&quot; will uncompress  <i>all</i> data in $input and write  <i>all</i> of the uncompressed data it has generated to $output. This makes the interface to &quot;inflate&quot; much simpler - if the method has uncompressed $input successfully  <i>all</i> compressed data in $input will have been dealt with. So if you are reading from an input source and uncompressing as you go the code will look something like this<div class="spacer">
</div>
<br/>
    use strict ;<br/>
    use warnings ;<br/>
    <br/>
    use Compress::Raw::Zlib;<br/>
    <br/>
    my $x = new Compress::Raw::Zlib::Inflate()<br/>
       or die &quot;Cannot create a inflation stream\n&quot; ;<br/>
    <br/>
    my $input = '' ;<br/>
    <br/>
    my ($output, $status) ;<br/>
    while (read(STDIN, $input, 4096))<br/>
    {<br/>
        $status = $x-&gt;inflate($input, $output) ;<br/>
    <br/>
        print $output ;<br/>
    <br/>
        last if $status != Z_OK ;<br/>
    }<br/>
    <br/>
    die &quot;inflation failed\n&quot;<br/>
        unless $status == Z_STREAM_END ;<br/>
<div class="spacer">
</div>
The points to note are<dl>
<dt>
&#8226;</dt>
<dd>
The main processing loop in the code handles reading of compressed data from STDIN.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
The status code returned from &quot;inflate&quot; will only trigger termination of the main processing loop if it isn't &quot;Z_OK&quot;. When &quot;LimitOutput&quot; has not been used the &quot;Z_OK&quot; status means means that the end of the compressed data stream has been reached or there has been an error in uncompression.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
After the call to &quot;inflate&quot; <i>all</i> of the uncompressed data in $input will have been processed. This means the subsequent call to &quot;read&quot; can overwrite it's contents without any problem.</dd>
</dl>
<div class="spacer">
</div>
For most use-cases the behavior described above is acceptable (this module and it's predecessor, &quot;Compress::Zlib&quot;, have used it for over 10 years without an issue), but in a few very specific use-cases the amount of memory required for $output can prohibitively large. For example, if the compressed data stream contains the same pattern repeated thousands of times, a relatively small compressed data stream can uncompress into hundreds of megabytes.  Remember &quot;inflate&quot; will keep allocating memory until  <i>all</i> the uncompressed data has been written to the output buffer - the size of $output is unbounded.<div class="spacer">
</div>
The &quot;LimitOutput&quot; option is designed to help with this use-case.<div class="spacer">
</div>
The main difference in your code when using &quot;LimitOutput&quot; is having to deal with cases where the $input parameter still contains some uncompressed data that &quot;inflate&quot; hasn't processed yet. The status code returned from &quot;inflate&quot; will be &quot;Z_OK&quot; if uncompression took place and &quot;Z_BUF_ERROR&quot; if the output buffer is full.<div class="spacer">
</div>
Below is typical code that shows how to use &quot;LimitOutput&quot;.<div class="spacer">
</div>
<br/>
    use strict ;<br/>
    use warnings ;<br/>
    <br/>
    use Compress::Raw::Zlib;<br/>
    <br/>
    my $x = new Compress::Raw::Zlib::Inflate(LimitOutput =&gt; 1)<br/>
       or die &quot;Cannot create a inflation stream\n&quot; ;<br/>
    <br/>
    my $input = '' ;<br/>
    binmode STDIN;<br/>
    binmode STDOUT;<br/>
    <br/>
    my ($output, $status) ;<br/>
<br/>
  OUTER:<br/>
    while (read(STDIN, $input, 4096))<br/>
    {<br/>
        do<br/>
        {<br/>
            $status = $x-&gt;inflate($input, $output) ;<br/>
<br/>
            print $output ;<br/>
<br/>
            last OUTER<br/>
                unless $status == Z_OK || $status == Z_BUF_ERROR ;<br/>
        }<br/>
        while ($status == Z_OK &amp;&amp; length $input);<br/>
    }<br/>
    <br/>
    die &quot;inflation failed\n&quot;<br/>
        unless $status == Z_STREAM_END ;<br/>
<div class="spacer">
</div>
Points to note this time:<dl>
<dt>
&#8226;</dt>
<dd>
There are now two nested loops in the code: the outer loop for reading the compressed data from STDIN, as before; and the inner loop to carry out the uncompression.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
There are two exit points from the inner uncompression loop.<div style="height: 1.00em;">
&#160;</div>
Firstly when &quot;inflate&quot; has returned a status other than &quot;Z_OK&quot; or &quot;Z_BUF_ERROR&quot;.  This means that either the end of the compressed data stream has been reached (&quot;Z_STREAM_END&quot;) or there is an error in the compressed data. In either of these cases there is no point in continuing with reading the compressed data, so both loops are terminated.<div style="height: 1.00em;">
&#160;</div>
The second exit point tests if there is any data left in the input buffer, $input - remember that the &quot;ConsumeInput&quot; option is automatically enabled when &quot;LimitOutput&quot; is used.  When the input buffer has been exhausted, the outer loop can run again and overwrite a now empty $input.</dd>
</dl>
</div>
<div class="section">
<h1>ACCESSING ZIP FILES</h1> Although it is possible (with some effort on your part) to use this module to access .zip files, there are other perl modules available that will do all the hard work for you. Check out &quot;Archive::Zip&quot;, &quot;IO::Compress::Zip&quot; and &quot;IO::Uncompress::Unzip&quot;.</div>
<div class="section">
<h1>CONSTANTS</h1> All the  <i>zlib</i> constants are automatically imported when you make use of  <i>Compress::Raw::Zlib</i>.</div>
<div class="section">
<h1>SEE ALSO</h1> Compress::Zlib, IO::Compress::Gzip, IO::Uncompress::Gunzip, IO::Compress::Deflate, IO::Uncompress::Inflate, IO::Compress::RawDeflate, IO::Uncompress::RawInflate, IO::Compress::Bzip2, IO::Uncompress::Bunzip2, IO::Compress::Lzma, IO::Uncompress::UnLzma, IO::Compress::Xz, IO::Uncompress::UnXz, IO::Compress::Lzop, IO::Uncompress::UnLzop, IO::Compress::Lzf, IO::Uncompress::UnLzf, IO::Uncompress::AnyInflate, IO::Uncompress::AnyUncompress<div class="spacer">
</div>
Compress::Zlib::FAQ<div class="spacer">
</div>
File::GlobMapper, Archive::Zip, Archive::Tar, IO::Zlib<div class="spacer">
</div>
For RFC 1950, 1951 and 1952 see  <i>http://www.faqs.org/rfcs/rfc1950.html</i>,  <i>http://www.faqs.org/rfcs/rfc1951.html</i> and  <i>http://www.faqs.org/rfcs/rfc1952.html</i><div class="spacer">
</div>
The <i>zlib</i> compression library was written by Jean-loup Gailly  <i>gzip@prep.ai.mit.edu</i> and Mark Adler <i>madler@alumni.caltech.edu</i>.<div class="spacer">
</div>
The primary site for the <i>zlib</i> compression library is  <i>http://www.zlib.org</i>.<div class="spacer">
</div>
The primary site for gzip is <i>http://www.gzip.org</i>.</div>
<div class="section">
<h1>AUTHOR</h1> This module was written by Paul Marquess,  <i>pmqs@cpan.org</i>.</div>
<div class="section">
<h1>MODIFICATION HISTORY</h1> See the Changes file.</div>
<div class="section">
<h1>COPYRIGHT AND LICENSE</h1> Copyright (c) 2005-2011 Paul Marquess. All rights reserved.<div class="spacer">
</div>
This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-09-26</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

