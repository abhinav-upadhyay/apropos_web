<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Moose(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Moose(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
Moose(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Moose - A postmodern object system for Perl 5</div>
<div class="section">
<h1>VERSION</h1> version 2.0401</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
  package Point;<br/>
  use Moose; # automatically turns on strict and warnings<br/>
<br/>
  has 'x' =&gt; (is =&gt; 'rw', isa =&gt; 'Int');<br/>
  has 'y' =&gt; (is =&gt; 'rw', isa =&gt; 'Int');<br/>
<br/>
  sub clear {<br/>
      my $self = shift;<br/>
      $self-&gt;x(0);<br/>
      $self-&gt;y(0);<br/>
  }<br/>
<br/>
  package Point3D;<br/>
  use Moose;<br/>
<br/>
  extends 'Point';<br/>
<br/>
  has 'z' =&gt; (is =&gt; 'rw', isa =&gt; 'Int');<br/>
<br/>
  after 'clear' =&gt; sub {<br/>
      my $self = shift;<br/>
      $self-&gt;z(0);<br/>
  };<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> Moose is an extension of the Perl 5 object system.<div class="spacer">
</div>
The main goal of Moose is to make Perl 5 Object Oriented programming easier, more consistent, and less tedious. With Moose you can think more about what you want to do and less about the mechanics of OOP.<div class="spacer">
</div>
Additionally, Moose is built on top of Class::MOP, which is a metaclass system for Perl 5. This means that Moose not only makes building normal Perl 5 objects better, but it provides the power of metaclass programming as well.<div class="subsection">
<h2>New to Moose?</h2> If you're new to Moose, the best place to start is the Moose::Manual docs, followed by the Moose::Cookbook. The intro will show you what Moose is, and how it makes Perl 5 OO better.<div class="spacer">
</div>
The cookbook recipes on Moose basics will get you up to speed with many of Moose's features quickly. Once you have an idea of what Moose can do, you can use the API documentation to get more detail on features which interest you.</div>
<div class="subsection">
<h2>Moose Extensions</h2> The &quot;MooseX::&quot; namespace is the official place to find Moose extensions. These extensions can be found on the CPAN.  The easiest way to find them is to search for them (&lt;http://search.cpan.org/search?query=MooseX::&gt;), or to examine Task::Moose which aims to keep an up-to-date, easily installable list of Moose extensions.</div>
</div>
<div class="section">
<h1>TRANSLATIONS</h1> Much of the Moose documentation has been translated into other languages.<dl>
<dt>
Japanese</dt>
<dd>
Japanese docs can be found at http://perldoc.perlassociation.org/pod/Moose-Doc-JA/index.html &lt;http://perldoc.perlassociation.org/pod/Moose-Doc-JA/index.html&gt;. The source POD files can be found in GitHub: http://github.com/jpa/Moose-Doc-JA &lt;http://github.com/jpa/Moose-Doc-JA&gt;</dd>
</dl>
</div>
<div class="section">
<h1>BUILDING CLASSES WITH MOOSE</h1> Moose makes every attempt to provide as much convenience as possible during class construction/definition, but still stay out of your way if you want it to. Here are a few items to note when building classes with Moose.<div class="spacer">
</div>
When you &quot;use Moose&quot;, Moose will set the class's parent class to Moose::Object,  <i>unless</i> the class using Moose already has a parent class. In addition, specifying a parent with &quot;extends&quot; will change the parent class.<div class="spacer">
</div>
Moose will also manage all attributes (including inherited ones) that are defined with &quot;has&quot;. And (assuming you call &quot;new&quot;, which is inherited from Moose::Object) this includes properly initializing all instance slots, setting defaults where appropriate, and performing any type constraint checking or coercion.</div>
<div class="section">
<h1>PROVIDED METHODS</h1> Moose provides a number of methods to all your classes, mostly through the inheritance of Moose::Object. There is however, one exception.<dl>
<dt>
<b>meta</b></dt>
<dd>
This is a method which provides access to the current class's metaclass.</dd>
</dl>
</div>
<div class="section">
<h1>EXPORTED FUNCTIONS</h1> Moose will export a number of functions into the class's namespace which may then be used to set up the class. These functions all work directly on the current class.<dl>
<dt>
<b>extends (@superclasses)</b></dt>
<dd>
This function will set the superclass(es) for the current class.<div style="height: 1.00em;">
&#160;</div>
This approach is recommended instead of &quot;use base&quot;, because &quot;use base&quot; actually &quot;push&quot;es onto the class's @ISA, whereas &quot;extends&quot; will replace it. This is important to ensure that classes which do not have superclasses still properly inherit from Moose::Object.<div style="height: 1.00em;">
&#160;</div>
Each superclass can be followed by a hash reference with options. Currently, only -version is recognized:<div style="height: 1.00em;">
&#160;</div>
<br/>
    extends 'My::Parent'      =&gt; { -version =&gt; 0.01 },<br/>
            'My::OtherParent' =&gt; { -version =&gt; 0.03 };<br/>
<div style="height: 1.00em;">
&#160;</div>
An exception will be thrown if the version requirements are not satisfied.</dd>
</dl>
<dl>
<dt>
<b>with (@roles)</b></dt>
<dd>
This will apply a given set of @roles to the local class.<div style="height: 1.00em;">
&#160;</div>
Like with &quot;extends&quot;, each specified role can be followed by a hash reference with a -version option:<div style="height: 1.00em;">
&#160;</div>
<br/>
    with 'My::Role'      =&gt; { -version =&gt; 0.32 },<br/>
         'My::Otherrole' =&gt; { -version =&gt; 0.23 };<br/>
<div style="height: 1.00em;">
&#160;</div>
The specified version requirements must be satisfied, otherwise an exception will be thrown.<div style="height: 1.00em;">
&#160;</div>
If your role takes options or arguments, they can be passed along in the hash reference as well.</dd>
</dl>
<dl>
<dt>
<b>has </b><b>$name</b><b>|@$names =&gt; </b><b><i>%options</i></b><b></b></dt>
<dd>
This will install an attribute of a given $name into the current class. If the first parameter is an array reference, it will create an attribute for every $name in the list. The %options will be passed to the constructor for Moose::Meta::Attribute (which inherits from Class::MOP::Attribute), so the full documentation for the valid options can be found there. These are the most commonly used options:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
<i>is =&gt; 'rw'|'ro'</i></dt>
<dd>
The <i>is</i> option accepts either <i>rw</i> (for read/write) or <i>ro</i> (for read only). These will create either a read/write accessor or a read-only accessor respectively, using the same name as the $name of the attribute.<div style="height: 1.00em;">
&#160;</div>
If you need more control over how your accessors are named, you can use the reader, writer and accessor options inherited from Class::MOP::Attribute, however if you use those, you won't need the  <i>is</i> option.</dd>
</dl>
<dl>
<dt>
<i>isa =&gt; </i><i>$type_name</i><i></i></dt>
<dd>
The <i>isa</i> option uses Moose's type constraint facilities to set up runtime type checking for this attribute. Moose will perform the checks during class construction, and within any accessors. The $type_name argument must be a string. The string may be either a class name or a type defined using Moose's type definition features. (Refer to Moose::Util::TypeConstraints for information on how to define a new type, and how to retrieve type meta-data).</dd>
</dl>
<dl>
<dt>
<i>coerce =&gt; (1|0)</i></dt>
<dd>
This will attempt to use coercion with the supplied type constraint to change the value passed into any accessors or constructors. You  <b>must</b> supply a type constraint, and that type constraint  <b>must</b> define a coercion. See Moose::Cookbook::Basics::Recipe5 for an example.</dd>
</dl>
<dl>
<dt>
<i>does =&gt; </i><i>$role_name</i><i></i></dt>
<dd>
This will accept the name of a role which the value stored in this attribute is expected to have consumed.</dd>
</dl>
<dl>
<dt>
<i>required =&gt; (1|0)</i></dt>
<dd>
This marks the attribute as being required. This means a value must be supplied during class construction,  <i>or</i> the attribute must be lazy and have either a default or a builder. Note that c&lt;required&gt; does not say anything about the attribute's value, which can be &quot;undef&quot;.</dd>
</dl>
<dl>
<dt>
<i>weak_ref =&gt; (1|0)</i></dt>
<dd>
This will tell the class to store the value of this attribute as a weakened reference. If an attribute is a weakened reference, it  <b>cannot</b> also be coerced. Note that when a weak ref expires, the attribute's value becomes undefined, and is still considered to be set for purposes of predicate, default, etc.</dd>
</dl>
<dl>
<dt>
<i>lazy =&gt; (1|0)</i></dt>
<dd>
This will tell the class to not create this slot until absolutely necessary. If an attribute is marked as lazy it  <b>must</b> have a default or builder supplied.</dd>
</dl>
<dl>
<dt>
<i>trigger =&gt; </i><i>$code</i><i></i></dt>
<dd>
The <i>trigger</i> option is a CODE reference which will be called after the value of the attribute is set. The CODE ref is passed the instance itself, the updated value, and the original value if the attribute was already set.<div style="height: 1.00em;">
&#160;</div>
You <b>can</b> have a trigger on a read-only attribute.<div style="height: 1.00em;">
&#160;</div>
<b>NOTE:</b> Triggers will only fire when you <b>assign</b> to the attribute, either in the constructor, or using the writer. Default and built values will  <b>not</b> cause the trigger to be fired.</dd>
</dl>
<dl>
<dt>
<i>handles =&gt; ARRAY | HASH | REGEXP | ROLE | ROLETYPE | DUCKTYPE | CODE</i></dt>
<dd>
The <i>handles</i> option provides Moose classes with automated delegation features. This is a pretty complex and powerful option. It accepts many different option formats, each with its own benefits and drawbacks.<div style="height: 1.00em;">
&#160;</div>
<b>NOTE:</b> The class being delegated to does not need to be a Moose based class, which is why this feature is especially useful when wrapping non-Moose classes.<div style="height: 1.00em;">
&#160;</div>
All <i>handles</i> option formats share the following traits:<div style="height: 1.00em;">
&#160;</div>
You cannot override a locally defined method with a delegated method; an exception will be thrown if you try. That is to say, if you define &quot;foo&quot; in your class, you cannot override it with a delegated &quot;foo&quot;. This is almost never something you would want to do, and if it is, you should do it by hand and not use Moose.<div style="height: 1.00em;">
&#160;</div>
You cannot override any of the methods found in Moose::Object, or the &quot;BUILD&quot; and &quot;DEMOLISH&quot; methods. These will not throw an exception, but will silently move on to the next method in the list. My reasoning for this is that you would almost never want to do this, since it usually breaks your class. As with overriding locally defined methods, if you do want to do this, you should do it manually, not with Moose.<div style="height: 1.00em;">
&#160;</div>
You do not <i>need</i> to have a reader (or accessor) for the attribute in order to delegate to it. Moose will create a means of accessing the value for you, however this will be several times  <b>less</b> efficient then if you had given the attribute a reader (or accessor) to use.<div style="height: 1.00em;">
&#160;</div>
Below is the documentation for each option format:<div style="margin-left: 4.00ex;">
<dl>
<dt>
&quot;ARRAY&quot;</dt>
<dd>
This is the most common usage for <i>handles</i>. You basically pass a list of method names to be delegated, and Moose will install a delegation method for each one.</dd>
</dl>
<dl>
<dt>
&quot;HASH&quot;</dt>
<dd>
This is the second most common usage for <i>handles</i>. Instead of a list of method names, you pass a HASH ref where each key is the method name you want installed locally, and its value is the name of the original method in the class being delegated to.<div style="height: 1.00em;">
&#160;</div>
This can be very useful for recursive classes like trees. Here is a quick example (soon to be expanded into a Moose::Cookbook recipe):<div style="height: 1.00em;">
&#160;</div>
<br/>
  package Tree;<br/>
  use Moose;<br/>
<br/>
  has 'node' =&gt; (is =&gt; 'rw', isa =&gt; 'Any');<br/>
<br/>
  has 'children' =&gt; (<br/>
      is      =&gt; 'ro',<br/>
      isa     =&gt; 'ArrayRef',<br/>
      default =&gt; sub { [] }<br/>
  );<br/>
<br/>
  has 'parent' =&gt; (<br/>
      is          =&gt; 'rw',<br/>
      isa         =&gt; 'Tree',<br/>
      weak_ref    =&gt; 1,<br/>
      handles     =&gt; {<br/>
          parent_node =&gt; 'node',<br/>
          siblings    =&gt; 'children',<br/>
      }<br/>
  );<br/>
<div style="height: 1.00em;">
&#160;</div>
In this example, the Tree package gets &quot;parent_node&quot; and &quot;siblings&quot; methods, which delegate to the &quot;node&quot; and &quot;children&quot; methods (respectively) of the Tree instance stored in the &quot;parent&quot; slot.<div style="height: 1.00em;">
&#160;</div>
You may also use an array reference to curry arguments to the original method.<div style="height: 1.00em;">
&#160;</div>
<br/>
  has 'thing' =&gt; (<br/>
      ...<br/>
      handles =&gt; { set_foo =&gt; [ set =&gt; 'foo' ] },<br/>
  );<br/>
<br/>
  # $self-&gt;set_foo(...) calls $self-&gt;thing-&gt;set('foo', ...)<br/>
<div style="height: 1.00em;">
&#160;</div>
The first element of the array reference is the original method name, and the rest is a list of curried arguments.</dd>
</dl>
<dl>
<dt>
&quot;REGEXP&quot;</dt>
<dd>
The regexp option works very similar to the ARRAY option, except that it builds the list of methods for you. It starts by collecting all possible methods of the class being delegated to, then filters that list using the regexp supplied here.<div style="height: 1.00em;">
&#160;</div>
<b>NOTE:</b> An <i>isa</i> option is required when using the regexp option format. This is so that we can determine (at compile time) the method list from the class. Without an  <i>isa</i> this is just not possible.</dd>
</dl>
<dl>
<dt>
&quot;ROLE&quot; or &quot;ROLETYPE&quot;</dt>
<dd>
With the role option, you specify the name of a role or a role type whose &quot;interface&quot; then becomes the list of methods to handle. The &quot;interface&quot; can be defined as; the methods of the role and any required methods of the role. It should be noted that this does  <b>not</b> include any method modifiers or generated attribute methods (which is consistent with role composition).</dd>
</dl>
<dl>
<dt>
&quot;DUCKTYPE&quot;</dt>
<dd>
With the duck type option, you pass a duck type object whose &quot;interface&quot; then becomes the list of methods to handle. The &quot;interface&quot; can be defined as the list of methods passed to &quot;duck_type&quot; to create a duck type object. For more information on &quot;duck_type&quot; please check Moose::Util::TypeConstraints.</dd>
</dl>
<dl>
<dt>
&quot;CODE&quot;</dt>
<dd>
This is the option to use when you really want to do something funky. You should only use it if you really know what you are doing, as it involves manual metaclass twiddling.<div style="height: 1.00em;">
&#160;</div>
This takes a code reference, which should expect two arguments. The first is the attribute meta-object this  <i>handles</i> is attached to. The second is the metaclass of the class being delegated to. It expects you to return a hash (not a HASH ref) of the methods you want mapped.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
</div>
</dd>
</dl>
<dl>
<dt>
<i>traits =&gt; [ </i><i>@role_names</i><i> ]</i></dt>
<dd>
This tells Moose to take the list of @role_names and apply them to the attribute meta-object. Custom attribute metaclass traits are useful for extending the capabilities of the  <i>has</i> keyword: they are the simplest way to extend the MOP, but they are still a fairly advanced topic and too much to cover here.<div style="height: 1.00em;">
&#160;</div>
See &quot;Metaclass and Trait Name Resolution&quot; for details on how a trait name is resolved to a role name.<div style="height: 1.00em;">
&#160;</div>
Also see Moose::Cookbook::Meta::Recipe3 for a metaclass trait example.</dd>
</dl>
<dl>
<dt>
<i>builder</i> =&gt; Str</dt>
<dd>
The value of this key is the name of the method that will be called to obtain the value used to initialize the attribute. See the builder option docs in Class::MOP::Attribute and/or Moose::Cookbook::Basics::Recipe8 for more information.</dd>
</dl>
<dl>
<dt>
<i>default</i> =&gt; SCALAR | CODE</dt>
<dd>
The value of this key is the default value which will initialize the attribute.<div style="height: 1.00em;">
&#160;</div>
NOTE: If the value is a simple scalar (string or number), then it can be just passed as is.  However, if you wish to initialize it with a HASH or ARRAY ref, then you need to wrap that inside a CODE reference. See the default option docs in Class::MOP::Attribute for more information.</dd>
</dl>
<dl>
<dt>
<i>clearer</i> =&gt; Str</dt>
<dd>
Creates a method allowing you to clear the value. See the clearer option docs in Class::MOP::Attribute for more information.</dd>
</dl>
<dl>
<dt>
<i>predicate</i> =&gt; Str</dt>
<dd>
Creates a method to perform a basic test to see if a value has been set in the attribute. See the predicate option docs in Class::MOP::Attribute for more information.<div style="height: 1.00em;">
&#160;</div>
Note that the predicate will return true even for a &quot;weak_ref&quot; attribute whose value has expired.</dd>
</dl>
<dl>
<dt>
<i>documentation</i> =&gt; $string</dt>
<dd>
An arbitrary string that can be retrieved later by calling &quot;$attr-&gt;documentation&quot;.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
</div>
<dl>
<dt>
<b>has +$name =&gt; </b><b>%options</b><b></b></dt>
<dd>
This is variation on the normal attribute creator &quot;has&quot; which allows you to clone and extend an attribute from a superclass or from a role. Here is an example of the superclass usage:<div style="height: 1.00em;">
&#160;</div>
<br/>
  package Foo;<br/>
  use Moose;<br/>
<br/>
  has 'message' =&gt; (<br/>
      is      =&gt; 'rw',<br/>
      isa     =&gt; 'Str',<br/>
      default =&gt; 'Hello, I am a Foo'<br/>
  );<br/>
<br/>
  package My::Foo;<br/>
  use Moose;<br/>
<br/>
  extends 'Foo';<br/>
<br/>
  has '+message' =&gt; (default =&gt; 'Hello I am My::Foo');<br/>
<div style="height: 1.00em;">
&#160;</div>
What is happening here is that <b>My::Foo</b> is cloning the &quot;message&quot; attribute from its parent class  <b>Foo</b>, retaining the &quot;is =&gt; 'rw'&quot; and &quot;isa =&gt; 'Str'&quot; characteristics, but changing the value in &quot;default&quot;.<div style="height: 1.00em;">
&#160;</div>
Here is another example, but within the context of a role:<div style="height: 1.00em;">
&#160;</div>
<br/>
  package Foo::Role;<br/>
  use Moose::Role;<br/>
<br/>
  has 'message' =&gt; (<br/>
      is      =&gt; 'rw',<br/>
      isa     =&gt; 'Str',<br/>
      default =&gt; 'Hello, I am a Foo'<br/>
  );<br/>
<br/>
  package My::Foo;<br/>
  use Moose;<br/>
<br/>
  with 'Foo::Role';<br/>
<br/>
  has '+message' =&gt; (default =&gt; 'Hello I am My::Foo');<br/>
<div style="height: 1.00em;">
&#160;</div>
In this case, we are basically taking the attribute which the role supplied and altering it within the bounds of this feature.<div style="height: 1.00em;">
&#160;</div>
Note that you can only extend an attribute from either a superclass or a role, you cannot extend an attribute in a role that composes over an attribute from another role.<div style="height: 1.00em;">
&#160;</div>
Aside from where the attributes come from (one from superclass, the other from a role), this feature works exactly the same. This feature is restricted somewhat, so as to try and force at least  <i>some</i> sanity into it. Most options work the same, but there are some exceptions:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
<i>reader</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>writer</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>accessor</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>clearer</i></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<i>predicate</i></dt>
<dd>
These options can be added, but cannot override a superclass definition.</dd>
</dl>
<dl>
<dt>
<i>traits</i></dt>
<dd>
You are allowed to <b>add</b> additional traits to the &quot;traits&quot; definition. These traits will be composed into the attribute, but preexisting traits  <b>are not</b> overridden, or removed.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
</div>
<dl>
<dt>
<b>before </b><b>$name</b><b>|@names|\@names|qr/.../ =&gt; sub { ... }</b></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<b>after </b><b>$name</b><b>|@names|\@names|qr/.../ =&gt; sub { ... }</b></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<b>around </b><b>$name</b><b>|@names|\@names|qr/.../ =&gt; sub { ... }</b></dt>
<dd>
These three items are syntactic sugar for the before, after, and around method modifier features that Class::MOP provides. More information on these may be found in Moose::Manual::MethodModifiers and the Class::MOP::Class documentation.</dd>
</dl>
<dl>
<dt>
<b>override ($name, &amp;sub)</b></dt>
<dd>
An &quot;override&quot; method is a way of explicitly saying &quot;I am overriding this method from my superclass&quot;. You can call &quot;super&quot; within this method, and it will work as expected. The same thing  <i>can</i> be accomplished with a normal method call and the &quot;SUPER::&quot; pseudo-package; it is really your choice.</dd>
</dl>
<dl>
<dt>
<b>super</b></dt>
<dd>
The keyword &quot;super&quot; is a no-op when called outside of an &quot;override&quot; method. In the context of an &quot;override&quot; method, it will call the next most appropriate superclass method with the same arguments as the original method.</dd>
</dl>
<dl>
<dt>
<b>augment ($name, &amp;sub)</b></dt>
<dd>
An &quot;augment&quot; method, is a way of explicitly saying &quot;I am augmenting this method from my superclass&quot;. Once again, the details of how &quot;inner&quot; and &quot;augment&quot; work is best described in the Moose::Cookbook::Basics::Recipe6.</dd>
</dl>
<dl>
<dt>
<b>inner</b></dt>
<dd>
The keyword &quot;inner&quot;, much like &quot;super&quot;, is a no-op outside of the context of an &quot;augment&quot; method. You can think of &quot;inner&quot; as being the inverse of &quot;super&quot;; the details of how &quot;inner&quot; and &quot;augment&quot; work is best described in the Moose::Cookbook::Basics::Recipe6.</dd>
</dl>
<dl>
<dt>
<b>blessed</b></dt>
<dd>
This is the &quot;Scalar::Util::blessed&quot; function. It is highly recommended that this is used instead of &quot;ref&quot; anywhere you need to test for an object's class name.</dd>
</dl>
<dl>
<dt>
<b>confess</b></dt>
<dd>
This is the &quot;Carp::confess&quot; function, and exported here for historical reasons.</dd>
</dl>
</div>
<div class="section">
<h1>METACLASS</h1> When you use Moose, you can specify traits which will be applied to your metaclass:<div class="spacer">
</div>
<br/>
    use Moose -traits =&gt; 'My::Trait';<br/>
<div class="spacer">
</div>
This is very similar to the attribute traits feature. When you do this, your class's &quot;meta&quot; object will have the specified traits applied to it. See &quot;Metaclass and Trait Name Resolution&quot; for more details.<div class="subsection">
<h2>Metaclass and Trait Name Resolution</h2> By default, when given a trait name, Moose simply tries to load a class of the same name. If such a class does not exist, it then looks for for a class matching  <b>Moose::Meta::$type::Custom::Trait::$trait_name</b>. The $type variable here will be one of  <b>Attribute</b> or <b>Class</b>, depending on what the trait is being applied to.<div class="spacer">
</div>
If a class with this long name exists, Moose checks to see if it has the method &quot;register_implementation&quot;. This method is expected to return the  <i>real</i> class name of the trait. If there is no &quot;register_implementation&quot; method, it will fall back to using  <b>Moose::Meta::$type::Custom::Trait::$trait</b> as the trait name.<div class="spacer">
</div>
The lookup method for metaclasses is the same, except that it looks for a class matching  <b>Moose::Meta::$type::Custom::$metaclass_name</b>.<div class="spacer">
</div>
If all this is confusing, take a look at Moose::Cookbook::Meta::Recipe3, which demonstrates how to create an attribute trait.</div>
</div>
<div class="section">
<h1>UNIMPORTING FUNCTIONS</h1><div class="subsection">
<h2><b>unimport</b></h2> Moose offers a way to remove the keywords it exports, through the &quot;unimport&quot; method. You simply have to say &quot;no Moose&quot; at the bottom of your code for this to work. Here is an example:<div class="spacer">
</div>
<br/>
    package Person;<br/>
    use Moose;<br/>
<br/>
    has 'first_name' =&gt; (is =&gt; 'rw', isa =&gt; 'Str');<br/>
    has 'last_name'  =&gt; (is =&gt; 'rw', isa =&gt; 'Str');<br/>
<br/>
    sub full_name {<br/>
        my $self = shift;<br/>
        $self-&gt;first_name . ' ' . $self-&gt;last_name<br/>
    }<br/>
<br/>
    no Moose; # keywords are removed from the Person package<br/>
</div>
</div>
<div class="section">
<h1>EXTENDING AND EMBEDDING MOOSE</h1> To learn more about extending Moose, we recommend checking out the &quot;Extending&quot; recipes in the Moose::Cookbook, starting with Moose::Cookbook::Extending::Recipe1, which provides an overview of all the different ways you might extend Moose. Moose::Exporter and Moose::Util::MetaRole are the modules which provide the majority of the extension functionality, so reading their documentation should also be helpful.<div class="subsection">
<h2>The MooseX:: namespace</h2> Generally if you're writing an extension  <i>for</i> Moose itself you'll want to put your extension in the &quot;MooseX::&quot; namespace. This namespace is specifically for extensions that make Moose better or different in some fundamental way. It is traditionally  <b>not</b> for a package that just happens to use Moose. This namespace follows from the examples of the &quot;LWPx::&quot; and &quot;DBIx::&quot; namespaces that perform the same function for &quot;LWP&quot; and &quot;DBI&quot; respectively.</div>
</div>
<div class="section">
<h1>METACLASS COMPATIBILITY AND MOOSE</h1> Metaclass compatibility is a thorny subject. You should start by reading the &quot;About Metaclass compatibility&quot; section in the &quot;Class::MOP&quot; docs.<div class="spacer">
</div>
Moose will attempt to resolve a few cases of metaclass incompatibility when you set the superclasses for a class, in addition to the cases that &quot;Class::MOP&quot; handles.<div class="spacer">
</div>
Moose tries to determine if the metaclasses only &quot;differ by roles&quot;. This means that the parent and child's metaclass share a common ancestor in their respective hierarchies, and that the subclasses under the common ancestor are only different because of role applications. This case is actually fairly common when you mix and match various &quot;MooseX::*&quot; modules, many of which apply roles to the metaclass.<div class="spacer">
</div>
If the parent and child do differ by roles, Moose replaces the metaclass in the child with a newly created metaclass. This metaclass is a subclass of the parent's metaclass which does all of the roles that the child's metaclass did before being replaced. Effectively, this means the new metaclass does all of the roles done by both the parent's and child's original metaclasses.<div class="spacer">
</div>
Ultimately, this is all transparent to you except in the case of an unresolvable conflict.</div>
<div class="section">
<h1>CAVEATS</h1><dl>
<dt>
&#8226;</dt>
<dd>
It should be noted that &quot;super&quot; and &quot;inner&quot; <b>cannot</b> be used in the same method. However, they may be combined within the same class hierarchy; see  <i>t/basics/override_augment_inner_super.t</i> for an example.<div style="height: 1.00em;">
&#160;</div>
The reason for this is that &quot;super&quot; is only valid within a method with the &quot;override&quot; modifier, and &quot;inner&quot; will never be valid within an &quot;override&quot; method. In fact, &quot;augment&quot; will skip over any &quot;override&quot; methods when searching for its appropriate &quot;inner&quot;.<div style="height: 1.00em;">
&#160;</div>
This might seem like a restriction, but I am of the opinion that keeping these two features separate (yet interoperable) actually makes them easy to use, since their behavior is then easier to predict. Time will tell whether I am right or not (UPDATE: so far so good).</dd>
</dl>
</div>
<div class="section">
<h1>GETTING HELP</h1> We offer both a mailing list and a very active IRC channel.<div class="spacer">
</div>
The mailing list is moose@perl.org. You must be subscribed to send a message. To subscribe, send an empty message to moose-subscribe@perl.org<div class="spacer">
</div>
You can also visit us at &quot;#moose&quot; on &lt;irc://irc.perl.org/#moose&gt; This channel is quite active, and questions at all levels (on Moose-related topics ;) are welcome.</div>
<div class="section">
<h1>ACKNOWLEDGEMENTS</h1><dl>
<dt>
I blame Sam Vilain for introducing me to the insanity that is meta-models.</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
I blame Audrey Tang for then encouraging my meta-model habit in #perl6.</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Without Yuval &quot;nothingmuch&quot; Kogman this module would not be possible, and it certainly wouldn't have this name ;P</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
The basis of the TypeContraints module was Rob Kinyon's idea originally, I just ran with it.</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Thanks to mst &amp; chansen and the whole #moose posse for all the early ideas/feature-requests/encouragement/bug-finding.</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Thanks to David &quot;Theory&quot; Wheeler for meta-discussions and spelling fixes.</dt>
<dd>
</dd>
</dl>
</div>
<div class="section">
<h1>SEE ALSO</h1><dl>
<dt>
&lt;http://www.iinteractive.com/moose&gt;</dt>
<dd>
This is the official web home of Moose. It contains links to our public git repository, as well as links to a number of talks and articles on Moose and Moose related technologies.</dd>
</dl>
<dl>
<dt>
the Moose manual</dt>
<dd>
This is an introduction to Moose which covers most of the basics.</dd>
</dl>
<dl>
<dt>
Modern Perl, by chromatic</dt>
<dd>
This is an introduction to modern Perl programming, which includes a section on Moose. It is available in print and as a free download from &lt;http://onyxneon.com/books/modern_perl/&gt;.</dd>
</dl>
<dl>
<dt>
The Moose is flying, a tutorial by Randal Schwartz</dt>
<dd>
Part 1 - &lt;http://www.stonehenge.com/merlyn/LinuxMag/col94.html&gt;<div style="height: 1.00em;">
&#160;</div>
Part 2 - &lt;http://www.stonehenge.com/merlyn/LinuxMag/col95.html&gt;</dd>
</dl>
<dl>
<dt>
Several Moose extension modules in the &quot;MooseX::&quot; namespace.</dt>
<dd>
See &lt;http://search.cpan.org/search?query=MooseX::&gt; for extensions.</dd>
</dl>
<div class="subsection">
<h2>Books</h2><dl>
<dt>
The Art of the MetaObject Protocol</dt>
<dd>
I mention this in the Class::MOP docs too, as this book was critical in the development of both modules and is highly recommended.</dd>
</dl>
</div>
<div class="subsection">
<h2>Papers</h2><dl>
<dt>
http://www.cs.utah.edu/plt/publications/oopsla04-gff.pdf &lt;http://www.cs.utah.edu/plt/publications/oopsla04-gff.pdf&gt;</dt>
<dd>
This paper (suggested by lbr on #moose) was what lead to the implementation of the &quot;super&quot;/&quot;override&quot; and &quot;inner&quot;/&quot;augment&quot; features. If you really want to understand them, I suggest you read this.</dd>
</dl>
</div>
</div>
<div class="section">
<h1>BUGS</h1> All complex software has bugs lurking in it, and this module is no exception.<div class="spacer">
</div>
Please report any bugs to &quot;bug-moose@rt.cpan.org&quot;, or through the web interface at &lt;http://rt.cpan.org&gt;.<div class="spacer">
</div>
You can also discuss feature requests or possible bugs on the Moose mailing list (moose@perl.org) or on IRC at &lt;irc://irc.perl.org/#moose&gt;.</div>
<div class="section">
<h1>FEATURE REQUESTS</h1> We are very strict about what features we add to the Moose core, especially the user-visible features. Instead we have made sure that the underlying meta-system of Moose is as extensible as possible so that you can add your own features easily.<div class="spacer">
</div>
That said, occasionally there is a feature needed in the meta-system to support your planned extension, in which case you should either email the mailing list (moose@perl.org) or join us on IRC at &lt;irc://irc.perl.org/#moose&gt; to discuss. The Moose::Manual::Contributing has more detail about how and when you can contribute.</div>
<div class="section">
<h1>CABAL</h1> There are only a few people with the rights to release a new version of Moose. The Moose Cabal are the people to go to with questions regarding the wider purview of Moose. They help maintain not just the code but the community as well.<div class="spacer">
</div>
Stevan (stevan) Little &lt;stevan@iinteractive.com&gt;<div class="spacer">
</div>
Jesse (doy) Luehrs &lt;doy at tozt dot net&gt;<div class="spacer">
</div>
Yuval (nothingmuch) Kogman<div class="spacer">
</div>
Shawn (sartak) Moore &lt;sartak@bestpractical.com&gt;<div class="spacer">
</div>
Hans Dieter (confound) Pearcey &lt;hdp@pobox.com&gt;<div class="spacer">
</div>
Chris (perigrin) Prather<div class="spacer">
</div>
Florian Ragwitz &lt;rafl@debian.org&gt;<div class="spacer">
</div>
Dave (autarch) Rolsky &lt;autarch@urth.org&gt;</div>
<div class="section">
<h1>CONTRIBUTORS</h1> Moose is a community project, and as such, involves the work of many, many members of the community beyond just the members in the cabal. In particular:<div class="spacer">
</div>
Dave (autarch) Rolsky wrote most of the documentation in Moose::Manual.<div class="spacer">
</div>
John (jgoulah) Goulah wrote Moose::Cookbook::Snack::Keywords.<div class="spacer">
</div>
Jess (castaway) Robinson wrote Moose::Cookbook::Snack::Types.<div class="spacer">
</div>
Aran (bluefeet) Clary Deltac wrote Moose::Cookbook::Basics::Recipe9.<div class="spacer">
</div>
Anders (Debolaz) Nor Berle contributed Test::Moose and Moose::Util.<div class="spacer">
</div>
Also, the code in Moose::Meta::Attribute::Native is based on code from the MooseX::AttributeHelpers distribution, which had contributions from:<div class="spacer">
</div>
Chris (perigrin) Prather<div class="spacer">
</div>
Cory (gphat) Watson<div class="spacer">
</div>
Evan Carroll<div class="spacer">
</div>
Florian (rafl) Ragwitz<div class="spacer">
</div>
Jason May<div class="spacer">
</div>
Jay Hannah<div class="spacer">
</div>
Jesse (doy) Luehrs<div class="spacer">
</div>
Paul (frodwith) Driver<div class="spacer">
</div>
Robert (rlb3) Boone<div class="spacer">
</div>
Robert Buels<div class="spacer">
</div>
Robert (phaylon) Sedlacek<div class="spacer">
</div>
Shawn (Sartak) Moore<div class="spacer">
</div>
Stevan Little<div class="spacer">
</div>
Tom (dec) Lanyon<div class="spacer">
</div>
Yuval Kogman<div class="spacer">
</div>
Finally, these people also contributed various tests, bug fixes, documentation, and features to the Moose codebase:<div class="spacer">
</div>
Aankhen<div class="spacer">
</div>
Adam (Alias) Kennedy<div class="spacer">
</div>
Christian (chansen) Hansen<div class="spacer">
</div>
Cory (gphat) Watson<div class="spacer">
</div>
Dylan Hardison (doc fixes)<div class="spacer">
</div>
Eric (ewilhelm) Wilhelm<div class="spacer">
</div>
Evan Carroll<div class="spacer">
</div>
Guillermo (groditi) Roditi<div class="spacer">
</div>
Jason May<div class="spacer">
</div>
Jay Hannah<div class="spacer">
</div>
Jonathan (jrockway) Rockway<div class="spacer">
</div>
Matt (mst) Trout<div class="spacer">
</div>
Nathan (kolibrie) Gray<div class="spacer">
</div>
Paul (frodwith) Driver<div class="spacer">
</div>
Piotr (dexter) Roszatycki<div class="spacer">
</div>
Robert Buels<div class="spacer">
</div>
Robert (phaylon) Sedlacek<div class="spacer">
</div>
Robert (rlb3) Boone<div class="spacer">
</div>
Sam (mugwump) Vilain<div class="spacer">
</div>
Scott (konobi) McWhirter<div class="spacer">
</div>
Shlomi (rindolf) Fish<div class="spacer">
</div>
Tom (dec) Lanyon<div class="spacer">
</div>
Wallace (wreis) Reis<div class="spacer">
</div>
... and many other #moose folks</div>
<div class="section">
<h1>AUTHOR</h1> Moose is maintained by the Moose Cabal, along with the help of many contributors. See &quot;CABAL&quot; in Moose and &quot;CONTRIBUTORS&quot; in Moose for details.</div>
<div class="section">
<h1>COPYRIGHT AND LICENSE</h1> This software is copyright (c) 2011 by Infinity Interactive, Inc..<div class="spacer">
</div>
This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5 programming language system itself.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-11-17</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

