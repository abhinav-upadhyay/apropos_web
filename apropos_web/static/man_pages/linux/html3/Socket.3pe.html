<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Socket(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Socket(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
Socket(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Socket, sockaddr_in, sockaddr_un, inet_aton, inet_ntoa, inet_pton, inet_ntop - load the C socket.h defines and structure manipulators</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
    use Socket;<br/>
<br/>
    $proto = getprotobyname('udp');<br/>
    socket(Socket_Handle, PF_INET, SOCK_DGRAM, $proto);<br/>
    $iaddr = gethostbyname('hishost.com');<br/>
    $port = getservbyname('time', 'udp');<br/>
    $sin = sockaddr_in($port, $iaddr);<br/>
    send(Socket_Handle, 0, 0, $sin);<br/>
<br/>
    $proto = getprotobyname('tcp');<br/>
    socket(Socket_Handle, PF_INET, SOCK_STREAM, $proto);<br/>
    $port = getservbyname('smtp', 'tcp');<br/>
    $sin = sockaddr_in($port,inet_aton(&quot;127.1&quot;));<br/>
    $sin = sockaddr_in(7,inet_aton(&quot;localhost&quot;));<br/>
    $sin = sockaddr_in(7,INADDR_LOOPBACK);<br/>
    connect(Socket_Handle,$sin);<br/>
<br/>
    ($port, $iaddr) = sockaddr_in(getpeername(Socket_Handle));<br/>
    $peer_host = gethostbyaddr($iaddr, AF_INET);<br/>
    $peer_addr = inet_ntoa($iaddr);<br/>
<br/>
    $proto = getprotobyname('tcp');<br/>
    socket(Socket_Handle, PF_UNIX, SOCK_STREAM, $proto);<br/>
    unlink('/var/run/usock');<br/>
    $sun = sockaddr_un('/var/run/usock');<br/>
    connect(Socket_Handle,$sun);<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> This module is just a translation of the C  <i>socket.h</i> file. Unlike the old mechanism of requiring a translated  <i>socket.ph</i> file, this uses the  <b>h2xs</b> program (see the Perl source distribution) and your native C compiler.  This means that it has a far more likely chance of getting the numbers right.  This includes all of the commonly used pound-defines like AF_INET, SOCK_STREAM, etc.<div class="spacer">
</div>
Also, some common socket &quot;newline&quot; constants are provided: the constants &quot;CR&quot;, &quot;LF&quot;, and &quot;CRLF&quot;, as well as $CR, $LF, and $CRLF, which map to &quot;\015&quot;, &quot;\012&quot;, and &quot;\015\012&quot;.  If you do not want to use the literal characters in your programs, then use the constants provided here.  They are not exported by default, but can be imported individually, and with the &quot;:crlf&quot; export tag:<div class="spacer">
</div>
<br/>
    use Socket qw(:DEFAULT :crlf);<br/>
<div class="spacer">
</div>
In addition, some structure manipulation functions are available:<dl>
<dt>
inet_aton HOSTNAME</dt>
<dd>
Takes a string giving the name of a host, and translates that to an opaque string (if programming in C, struct in_addr). Takes arguments of both the 'rtfm.mit.edu' type and '18.181.0.24'. If the host name cannot be resolved, returns undef.  For multi-homed hosts (hosts with more than one address), the first address found is returned.<div style="height: 1.00em;">
&#160;</div>
For portability do not assume that the result of <i>inet_aton()</i> is 32 bits wide, in other words, that it would contain only the IPv4 address in network order.</dd>
</dl>
<dl>
<dt>
inet_ntoa IP_ADDRESS</dt>
<dd>
Takes a string (an opaque string as returned by <i>inet_aton()</i>, or a v-string representing the four octets of the IPv4 address in network order) and translates it into a string of the form 'd.d.d.d' where the 'd's are numbers less than 256 (the normal human-readable four dotted number notation for Internet addresses).</dd>
</dl>
<dl>
<dt>
INADDR_ANY</dt>
<dd>
Note: does not return a number, but a packed string.<div style="height: 1.00em;">
&#160;</div>
Returns the 4-byte wildcard ip address which specifies any of the hosts ip addresses.  (A particular machine can have more than one ip address, each address corresponding to a particular network interface. This wildcard address allows you to bind to all of them simultaneously.) Normally equivalent to inet_aton('0.0.0.0').</dd>
</dl>
<dl>
<dt>
INADDR_BROADCAST</dt>
<dd>
Note: does not return a number, but a packed string.<div style="height: 1.00em;">
&#160;</div>
Returns the 4-byte 'this-lan' ip broadcast address. This can be useful for some protocols to solicit information from all servers on the same LAN cable. Normally equivalent to inet_aton('255.255.255.255').</dd>
</dl>
<dl>
<dt>
INADDR_LOOPBACK</dt>
<dd>
Note - does not return a number.<div style="height: 1.00em;">
&#160;</div>
Returns the 4-byte loopback address.  Normally equivalent to inet_aton('localhost').</dd>
</dl>
<dl>
<dt>
INADDR_NONE</dt>
<dd>
Note - does not return a number.<div style="height: 1.00em;">
&#160;</div>
Returns the 4-byte 'invalid' ip address.  Normally equivalent to inet_aton('255.255.255.255').</dd>
</dl>
<dl>
<dt>
IN6ADDR_ANY</dt>
<dd>
Returns the 16-byte wildcard IPv6 address. Normally equivalent to inet_pton(AF_INET6, &quot;::&quot;)</dd>
</dl>
<dl>
<dt>
IN6ADDR_LOOPBACK</dt>
<dd>
Returns the 16-byte loopback IPv6 address. Normally equivalent to inet_pton(AF_INET6, &quot;::1&quot;)</dd>
</dl>
<dl>
<dt>
sockaddr_family SOCKADDR</dt>
<dd>
Takes a sockaddr structure (as returned by <i>pack_sockaddr_in()</i>,  <i>pack_sockaddr_un()</i> or the perl builtin functions <i>getsockname()</i> and  <i>getpeername()</i>) and returns the address family tag.  It will match the constant AF_INET for a sockaddr_in and AF_UNIX for a sockaddr_un.  It can be used to figure out what unpacker to use for a sockaddr of unknown type.</dd>
</dl>
<dl>
<dt>
sockaddr_in PORT, ADDRESS</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
sockaddr_in SOCKADDR_IN</dt>
<dd>
In a list context, unpacks its SOCKADDR_IN argument and returns an array consisting of (PORT, ADDRESS).  In a scalar context, packs its (PORT, ADDRESS) arguments as a SOCKADDR_IN and returns it.  If this is confusing, use  <i>pack_sockaddr_in()</i> and <i>unpack_sockaddr_in()</i> explicitly.</dd>
</dl>
<dl>
<dt>
pack_sockaddr_in PORT, IP_ADDRESS</dt>
<dd>
Takes two arguments, a port number and an opaque string, IP_ADDRESS (as returned by  <i>inet_aton()</i>, or a v-string).  Returns the sockaddr_in structure with those arguments packed in with AF_INET filled in.  For Internet domain sockets, this structure is normally what you need for the arguments in  <i>bind()</i>, <i>connect()</i>, and <i>send()</i>, and is also returned by  <i>getpeername()</i>, <i>getsockname()</i> and <i>recv()</i>.</dd>
</dl>
<dl>
<dt>
unpack_sockaddr_in SOCKADDR_IN</dt>
<dd>
Takes a sockaddr_in structure (as returned by <i>pack_sockaddr_in()</i>) and returns an array of two elements: the port and an opaque string representing the IP address (you can use  <i>inet_ntoa()</i> to convert the address to the four-dotted numeric format).  Will croak if the structure does not have AF_INET in the right place.</dd>
</dl>
<dl>
<dt>
sockaddr_in6 PORT, IP6_ADDRESS, [ SCOPE_ID, [ FLOWINFO ] ]</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
sockaddr_in6 SOCKADDR_IN6</dt>
<dd>
In list context, unpacks its SOCKADDR_IN6 argument according to  <i>unpack_sockaddr_in6()</i>. In scalar context, packs its arguments according to  <i>pack_sockaddr_in6()</i>.</dd>
</dl>
<dl>
<dt>
pack_sockaddr_in6 PORT, IP6_ADDRESS, [ SCOPE_ID, [ FLOWINFO ] ]</dt>
<dd>
Takes two to four arguments, a port number, an opaque string (as returned by  <i>inet_pton()</i>), optionally a scope ID number, and optionally a flow label number. Returns the sockaddr_in6 structure with those arguments packed in with AF_INET6 filled in. IPv6 equivalent of  <i>pack_sockaddr_in()</i>.</dd>
</dl>
<dl>
<dt>
unpack_sockaddr_in6 SOCKADDR_IN6</dt>
<dd>
Takes a sockaddr_in6 structure (as returned by <i>pack_sockaddr_in6()</i>) and returns an array of four elements: the port number, an opaque string representing the IPv6 address, the scope ID, and the flow label. (You can use  <i>inet_ntop()</i> to convert the address to the usual string format). Will croak if the structure does not have AF_INET6 in the right place.</dd>
</dl>
<dl>
<dt>
sockaddr_un PATHNAME</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
sockaddr_un SOCKADDR_UN</dt>
<dd>
In a list context, unpacks its SOCKADDR_UN argument and returns an array consisting of (PATHNAME).  In a scalar context, packs its PATHNAME arguments as a SOCKADDR_UN and returns it.  If this is confusing, use  <i>pack_sockaddr_un()</i> and <i>unpack_sockaddr_un()</i> explicitly. These are only supported if your system has &lt; <i>sys/un.h</i>&gt;.</dd>
</dl>
<dl>
<dt>
pack_sockaddr_un PATH</dt>
<dd>
Takes one argument, a pathname. Returns the sockaddr_un structure with that path packed in with AF_UNIX filled in. For unix domain sockets, this structure is normally what you need for the arguments in  <i>bind()</i>,  <i>connect()</i>, and <i>send()</i>, and is also returned by <i>getpeername()</i>,  <i>getsockname()</i> and <i>recv()</i>.</dd>
</dl>
<dl>
<dt>
unpack_sockaddr_un SOCKADDR_UN</dt>
<dd>
Takes a sockaddr_un structure (as returned by <i>pack_sockaddr_un()</i>) and returns the pathname.  Will croak if the structure does not have AF_UNIX in the right place.</dd>
</dl>
<dl>
<dt>
inet_pton ADDRESS_FAMILY, HOSTNAME</dt>
<dd>
Takes an address family, either AF_INET or AF_INET6, and a string giving the name of a host, and translates that to an opaque string (if programming in C, struct in_addr or struct in6_addr depending on the address family passed in).  The host string may be a string hostname, such as 'www.perl.org', or an IP address.  If using an IP address, the type of IP address must be consistent with the address family passed into the function.<div style="height: 1.00em;">
&#160;</div>
This function is not exported by default.</dd>
</dl>
<dl>
<dt>
inet_ntop ADDRESS_FAMILY, IP_ADDRESS</dt>
<dd>
Takes an address family, either AF_INET or AF_INET6, and a string (an opaque string as returned by  <i>inet_aton()</i> or <i>inet_pton()</i>) and translates it to an IPv4 or IPv6 address string.<div style="height: 1.00em;">
&#160;</div>
This function is not exported by default.</dd>
</dl>
<dl>
<dt>
getaddrinfo HOST, SERVICE, [ HINTS ]</dt>
<dd>
Given at least one of a hostname and a service name, returns a list of address structures to listen on or connect to. HOST and SERVICE should be plain strings (or a numerical port number for SERVICE). If present, HINTS should be a reference to a HASH, where the following keys are recognised:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
flags =&gt; INT</dt>
<dd>
A bitfield containing &quot;AI_*&quot; constants</dd>
</dl>
<dl>
<dt>
family =&gt; INT</dt>
<dd>
Restrict to only generating addresses in this address family</dd>
</dl>
<dl>
<dt>
socktype =&gt; INT</dt>
<dd>
Restrict to only generating addresses of this socket type</dd>
</dl>
<dl>
<dt>
protocol =&gt; INT</dt>
<dd>
Restrict to only generating addresses for this protocol</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">
&#160;</div>
The return value will be a list; the first value being an error indication, followed by a list of address structures (if no error occured).<div style="height: 1.00em;">
&#160;</div>
<br/>
 my ( $err, @results ) = getaddrinfo( ... );<br/>
<div style="height: 1.00em;">
&#160;</div>
The error value will be a dualvar; comparable to the &quot;EI_*&quot; error constants, or printable as a human-readable error message string. Each value in the results list will be a HASH reference containing the following fields:<dl>
<dt>
family =&gt; INT</dt>
<dd>
The address family (e.g. AF_INET)</dd>
</dl>
<dl>
<dt>
socktype =&gt; INT</dt>
<dd>
The socket type (e.g. SOCK_STREAM)</dd>
</dl>
<dl>
<dt>
protocol =&gt; INT</dt>
<dd>
The protocol (e.g. IPPROTO_TCP)</dd>
</dl>
<dl>
<dt>
addr =&gt; STRING</dt>
<dd>
The address in a packed string (such as would be returned by pack_sockaddr_in)</dd>
</dl>
<dl>
<dt>
canonname =&gt; STRING</dt>
<dd>
The canonical name for the host if the &quot;AI_CANONNAME&quot; flag was provided, or &quot;undef&quot; otherwise. This field will only be present on the first returned address.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
</div>
<dl>
<dt>
getnameinfo ADDR, FLAGS</dt>
<dd>
Given a packed socket address (such as from &quot;getsockname&quot;, &quot;getpeername&quot;, or returned by &quot;getaddrinfo&quot; in a &quot;addr&quot; field), returns the hostname and symbolic service name it represents. FLAGS may be a bitmask of &quot;NI_*&quot; constants, or defaults to 0 if unspecified.<div style="height: 1.00em;">
&#160;</div>
The return value will be a list; the first value being an error condition, followed by the hostname and service name.<div style="height: 1.00em;">
&#160;</div>
<br/>
 my ( $err, $host, $service ) = getnameinfo( ... );<br/>
<div style="height: 1.00em;">
&#160;</div>
The error value will be a dualvar; comparable to the &quot;EI_*&quot; error constants, or printable as a human-readable error message string. The host and service names will be plain strings.</dd>
</dl>
</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-09-26</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

