<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Moose::Spec::Role(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Moose::Spec::Role(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
Moose::Spec::Role(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Moose::Spec::Role - Formal spec for Role behavior</div>
<div class="section">
<h1>VERSION</h1> version 2.0401</div>
<div class="section">
<h1>DESCRIPTION</h1>  <b>NOTE:</b> This document is currently incomplete.<div class="subsection">
<h2>Components of a Role</h2><dl>
<dt>
Excluded Roles</dt>
<dd>
A role can have a list of excluded roles, these are basically roles that they shouldn't be composed with. This is not just direct composition either, but also &quot;inherited&quot; composition.<div style="height: 1.00em;">
&#160;</div>
This feature was taken from the Fortress language and is really of most use when building a large set of role &quot;building blocks&quot; some of which should never be used together.</dd>
</dl>
<dl>
<dt>
Attributes</dt>
<dd>
A roles attributes are similar to those of a class, except that they are not actually applied. This means that methods that are generated by an attributes accessor will not be generated in the role, but only created once the role is applied to a class.</dd>
</dl>
<dl>
<dt>
Methods</dt>
<dd>
These are the methods defined within the role. Simple as that.</dd>
</dl>
<dl>
<dt>
Required Methods</dt>
<dd>
A role can require a consuming class (or role) to provide a given method. Failure to do so for classes is a fatal error, while for roles it simply passes on the method requirement to the consuming role.</dd>
</dl>
<dl>
<dt>
Required Attributes</dt>
<dd>
Just as a role can require methods, it can also require attributes. The requirement fulfilling attribute must implement at least as much as is required. That means, for instance, that if the role requires that the attribute be read-only, then it must at least have a reader and can also have a writer. It means that if the role requires that the attribute be an ArrayRef, then it must either be an ArrayRef or a subtype of an ArrayRef.</dd>
</dl>
<dl>
<dt>
Overridden Methods</dt>
<dd>
The &quot;override&quot; and &quot;super&quot; keywords are allowed in roles, but their behavior is different from that of its class counterparts. The &quot;super&quot; in a class refers directly to that class's superclass, while the &quot;super&quot; in a role is deferred and only has meaning once the role is composed into a class. Once that composition occurs, &quot;super&quot; then refers to that class's superclass.<div style="height: 1.00em;">
&#160;</div>
It is key to remember that roles do not have hierarchy, so they can never have a  <i>super</i> role.</dd>
</dl>
<dl>
<dt>
Method Modifiers</dt>
<dd>
These are the &quot;before&quot;, &quot;around&quot; and &quot;after&quot; modifiers provided in Moose classes. The difference here is that the modifiers are not actually applied until the role is composed into a class (this is just like attributes and the &quot;override&quot; keyword).</dd>
</dl>
</div>
<div class="subsection">
<h2>Role Composition</h2>  <i>Composing into a Class</i><dl>
<dt>
Excluded Roles</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Required Methods</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Required Attributes</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Attributes</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Methods</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Overridden methods</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Method Modifiers (before, around, after)</dt>
<dd>
</dd>
</dl>
<div class="spacer">
</div>
<i>Composing into a Instance</i><div class="spacer">
</div>
<i>Composing into a Role</i><dl>
<dt>
Excluded Roles</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Required Methods</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Required Attributes</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Attributes</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Methods</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Overridden methods</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Method Modifiers (before, around, after)</dt>
<dd>
</dd>
</dl>
<div class="spacer">
</div>
<i>Role Summation</i><div class="spacer">
</div>
When multiple roles are added to another role (using the &quot;with @roles&quot; keyword) the roles are composed symmetrically. The product of the composition is a composite role (Moose::Meta::Role::Composite).<dl>
<dt>
Excluded Roles</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Required Methods</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Required Attributes</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Attributes</dt>
<dd>
Attributes with the same name will conflict and are considered a unrecoverable error. No other aspect of the attribute is examined, it is enough that just the attribute names conflict.<div style="height: 1.00em;">
&#160;</div>
The reason for such early and harsh conflicts with attributes is because there is so much room for variance between two attributes that the problem quickly explodes and rules get very complex. It is my opinion that this complexity is not worth the trouble.</dd>
</dl>
<dl>
<dt>
Methods</dt>
<dd>
Methods with the same name will conflict, but no error is thrown, instead the method name is added to the list of  <i>required</i> methods for the new composite role.<div style="height: 1.00em;">
&#160;</div>
To look at this in terms of set theory, each role can be said to have a set of methods. The symmetric difference of these two sets is the new set of methods for the composite role, while the intersection of these two sets are the conflicts. This can be illustrated like so:<div style="height: 1.00em;">
&#160;</div>
<br/>
   Role A has method set { a, b, c }<br/>
   Role B has method set { c, d, e }<br/>
<br/>
   The composite role (A,B) has<br/>
       method   set { a, b, d, e }<br/>
       conflict set { c }<br/>
</dd>
</dl>
<dl>
<dt>
Overridden methods</dt>
<dd>
An overridden method can conflict in one of two ways.<div style="height: 1.00em;">
&#160;</div>
The first way is with another overridden method of the same name, and this is considered an unrecoverable error. This is an obvious error since you cannot override a method twice in the same class.<div style="height: 1.00em;">
&#160;</div>
The second way for conflict is for an overridden method and a regular method to have the same name. This is also an unrecoverable error since there is no way to combine these two, nor is it okay for both items to be composed into a single class at some point.<div style="height: 1.00em;">
&#160;</div>
The use of override in roles can be tricky, but if used carefully they can be a very powerful tool.</dd>
</dl>
<dl>
<dt>
Method Modifiers (before, around, after)</dt>
<dd>
Method modifiers are the only place where the ordering of role composition matters. This is due to the nature of method modifiers themselves.<div style="height: 1.00em;">
&#160;</div>
Since a method can have multiple method modifiers, these are just collected in order to be later applied to the class in that same order.<div style="height: 1.00em;">
&#160;</div>
In general, great care should be taken in using method modifiers in roles. The order sensitivity can possibly lead to subtle and difficult to find bugs if they are overused. As with all good things in life, moderation is the key.</dd>
</dl>
<div class="spacer">
</div>
<i>Composition Edge Cases</i><div class="spacer">
</div>
This is a just a set of complex edge cases which can easily get confused. This attempts to clarify those cases and provide an explanation of what is going on in them.<dl>
<dt>
Role Method Overriding</dt>
<dd>
Many people want to &quot;override&quot; methods in roles they are consuming. This works fine for classes, since the local class method is favored over the role method. However in roles it is trickier, this is because conflicts result in neither method being chosen and the method being &quot;required&quot; instead.<div style="height: 1.00em;">
&#160;</div>
Here is an example of this (incorrect) type of overriding.<div style="height: 1.00em;">
&#160;</div>
<br/>
    package Role::Foo;<br/>
    use Moose::Role;<br/>
<br/>
    sub foo { ... }<br/>
<br/>
    package Role::FooBar;<br/>
    use Moose::Role;<br/>
<br/>
    with 'Role::Foo';<br/>
<br/>
    sub foo { ... }<br/>
    sub bar { ... }<br/>
<div style="height: 1.00em;">
&#160;</div>
Here the &quot;foo&quot; methods conflict and the Role::FooBar now requires a class or role consuming it to implement &quot;foo&quot;. This is very often not what the user wants.<div style="height: 1.00em;">
&#160;</div>
Now here is an example of the (correct) type of overriding, only it is not overriding at all, as is explained in the text below.<div style="height: 1.00em;">
&#160;</div>
<br/>
    package Role::Foo;<br/>
    use Moose::Role;<br/>
<br/>
    sub foo { ... }<br/>
<br/>
    package Role::Bar;<br/>
    use Moose::Role;<br/>
<br/>
    sub foo { ... }<br/>
    sub bar { ... }<br/>
<br/>
    package Role::FooBar;<br/>
    use Moose::Role;<br/>
<br/>
    with 'Role::Foo', 'Role::Bar';<br/>
<br/>
    sub foo { ... }<br/>
<div style="height: 1.00em;">
&#160;</div>
This works because the combination of Role::Foo and Role::Bar produce a conflict with the &quot;foo&quot; method. This conflict results in the composite role (that was created by the combination of Role::Foo and Role::Bar using the  <i>with</i> keyword) having a method requirement of &quot;foo&quot;. The Role::FooBar then fulfills this requirement.<div style="height: 1.00em;">
&#160;</div>
It is important to note that Role::FooBar is simply fulfilling the required &quot;foo&quot; method, and **NOT** overriding &quot;foo&quot;. This is an important distinction to make.<div style="height: 1.00em;">
&#160;</div>
Now here is another example of a (correct) type of overriding, this time using the  <i>excludes</i> option.<div style="height: 1.00em;">
&#160;</div>
<br/>
    package Role::Foo;<br/>
    use Moose::Role;<br/>
<br/>
    sub foo { ... }<br/>
<br/>
    package Role::FooBar;<br/>
    use Moose::Role;<br/>
<br/>
    with 'Role::Foo' =&gt; { excludes =&gt; 'foo' };<br/>
<br/>
    sub foo { ... }<br/>
    sub bar { ... }<br/>
<div style="height: 1.00em;">
&#160;</div>
By specifically excluding the &quot;foo&quot; method during composition, we allow  <b>Role::FooBar</b> to define its own version of &quot;foo&quot;.</dd>
</dl>
</div>
</div>
<div class="section">
<h1>SEE ALSO</h1><dl>
<dt>
Traits</dt>
<dd>
Roles are based on Traits, which originated in the Smalltalk community.</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
&lt;http://www.iam.unibe.ch/~scg/Research/Traits/&gt;</dt>
<dd>
This is the main site for the original Traits papers.</dd>
</dl>
<dl>
<dt>
Class::Trait</dt>
<dd>
I created this implementation of traits several years ago, after reading the papers linked above. (This module is now maintained by Ovid and I am no longer involved with it).</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
</div>
<dl>
<dt>
Roles</dt>
<dd>
Since they are relatively new, and the Moose implementation is probably the most mature out there, roles don't have much to link to. However, here is some bits worth looking at (mostly related to Perl 6)</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
&lt;http://www.oreillynet.com/onlamp/blog/2006/08/roles_composable_units_of_obje.html&gt;</dt>
<dd>
This is chromatic's take on roles, which is worth reading since he was/is one of the big proponents of them.</dd>
</dl>
<dl>
<dt>
&lt;http://svn.perl.org/perl6/doc/trunk/design/syn/S12.pod&gt;</dt>
<dd>
This is Synopsis 12, which is all about the Perl 6 Object System. Which, of course, includes roles.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
</div>
</div>
<div class="section">
<h1>AUTHOR</h1> Moose is maintained by the Moose Cabal, along with the help of many contributors. See &quot;CABAL&quot; in Moose and &quot;CONTRIBUTORS&quot; in Moose for details.</div>
<div class="section">
<h1>COPYRIGHT AND LICENSE</h1> This software is copyright (c) 2011 by Infinity Interactive, Inc..<div class="spacer">
</div>
This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5 programming language system itself.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-11-17</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

