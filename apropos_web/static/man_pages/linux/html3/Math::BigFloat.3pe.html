<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Math::BigFloat(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Math::BigFloat(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
Math::BigFloat(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Math::BigFloat - Arbitrary size floating point math package</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
  use Math::BigFloat;<br/>
<br/>
  # Number creation<br/>
  my $x = Math::BigFloat-&gt;new($str);    # defaults to 0<br/>
  my $y = $x-&gt;copy();                   # make a true copy<br/>
  my $nan  = Math::BigFloat-&gt;bnan();    # create a NotANumber<br/>
  my $zero = Math::BigFloat-&gt;bzero();   # create a +0<br/>
  my $inf = Math::BigFloat-&gt;binf();     # create a +inf<br/>
  my $inf = Math::BigFloat-&gt;binf('-');  # create a -inf<br/>
  my $one = Math::BigFloat-&gt;bone();     # create a +1<br/>
  my $mone = Math::BigFloat-&gt;bone('-'); # create a -1<br/>
<br/>
  my $pi = Math::BigFloat-&gt;bpi(100);    # PI to 100 digits<br/>
<br/>
  # the following examples compute their result to 100 digits accuracy:<br/>
  my $cos  = Math::BigFloat-&gt;new(1)-&gt;bcos(100);         # cosinus(1)<br/>
  my $sin  = Math::BigFloat-&gt;new(1)-&gt;bsin(100);         # sinus(1)<br/>
  my $atan = Math::BigFloat-&gt;new(1)-&gt;batan(100);        # arcus tangens(1)<br/>
<br/>
  my $atan2 = Math::BigFloat-&gt;new(  1 )-&gt;batan2( 1 ,100); # batan(1)<br/>
  my $atan2 = Math::BigFloat-&gt;new(  1 )-&gt;batan2( 8 ,100); # batan(1/8)<br/>
  my $atan2 = Math::BigFloat-&gt;new( -2 )-&gt;batan2( 1 ,100); # batan(-2)<br/>
<br/>
  # Testing<br/>
  $x-&gt;is_zero();                # true if arg is +0<br/>
  $x-&gt;is_nan();                 # true if arg is NaN<br/>
  $x-&gt;is_one();                 # true if arg is +1<br/>
  $x-&gt;is_one('-');              # true if arg is -1<br/>
  $x-&gt;is_odd();                 # true if odd, false for even<br/>
  $x-&gt;is_even();                # true if even, false for odd<br/>
  $x-&gt;is_pos();                 # true if &gt;= 0<br/>
  $x-&gt;is_neg();                 # true if &lt;  0<br/>
  $x-&gt;is_inf(sign);             # true if +inf, or -inf (default is '+')<br/>
<br/>
  $x-&gt;bcmp($y);                 # compare numbers (undef,&lt;0,=0,&gt;0)<br/>
  $x-&gt;bacmp($y);                # compare absolutely (undef,&lt;0,=0,&gt;0)<br/>
  $x-&gt;sign();                   # return the sign, either +,- or NaN<br/>
  $x-&gt;digit($n);                # return the nth digit, counting from right<br/>
  $x-&gt;digit(-$n);               # return the nth digit, counting from left <br/>
<br/>
  # The following all modify their first argument. If you want to preserve<br/>
  # $x, use $z = $x-&gt;copy()-&gt;bXXX($y); See under L&lt;CAVEATS&gt; for why this is<br/>
  # necessary when mixing $a = $b assignments with non-overloaded math.<br/>
<br/>
  # set <br/>
  $x-&gt;bzero();                  # set $i to 0<br/>
  $x-&gt;bnan();                   # set $i to NaN<br/>
  $x-&gt;bone();                   # set $x to +1<br/>
  $x-&gt;bone('-');                # set $x to -1<br/>
  $x-&gt;binf();                   # set $x to inf<br/>
  $x-&gt;binf('-');                # set $x to -inf<br/>
<br/>
  $x-&gt;bneg();                   # negation<br/>
  $x-&gt;babs();                   # absolute value<br/>
  $x-&gt;bnorm();                  # normalize (no-op)<br/>
  $x-&gt;bnot();                   # two's complement (bit wise not)<br/>
  $x-&gt;binc();                   # increment x by 1<br/>
  $x-&gt;bdec();                   # decrement x by 1<br/>
<br/>
  $x-&gt;badd($y);                 # addition (add $y to $x)<br/>
  $x-&gt;bsub($y);                 # subtraction (subtract $y from $x)<br/>
  $x-&gt;bmul($y);                 # multiplication (multiply $x by $y)<br/>
  $x-&gt;bdiv($y);                 # divide, set $x to quotient<br/>
                                # return (quo,rem) or quo if scalar<br/>
<br/>
  $x-&gt;bmod($y);                 # modulus ($x % $y)<br/>
  $x-&gt;bpow($y);                 # power of arguments ($x ** $y)<br/>
  $x-&gt;bmodpow($exp,$mod);       # modular exponentiation (($num**$exp) % $mod))<br/>
  $x-&gt;blsft($y, $n);            # left shift by $y places in base $n<br/>
  $x-&gt;brsft($y, $n);            # right shift by $y places in base $n<br/>
                                # returns (quo,rem) or quo if in scalar context<br/>
<br/>
  $x-&gt;blog();                   # logarithm of $x to base e (Euler's number)<br/>
  $x-&gt;blog($base);              # logarithm of $x to base $base (f.i. 2)<br/>
  $x-&gt;bexp();                   # calculate e ** $x where e is Euler's number<br/>
<br/>
  $x-&gt;band($y);                 # bit-wise and<br/>
  $x-&gt;bior($y);                 # bit-wise inclusive or<br/>
  $x-&gt;bxor($y);                 # bit-wise exclusive or<br/>
  $x-&gt;bnot();                   # bit-wise not (two's complement)<br/>
<br/>
  $x-&gt;bsqrt();                  # calculate square-root<br/>
  $x-&gt;broot($y);                # $y'th root of $x (e.g. $y == 3 =&gt; cubic root)<br/>
  $x-&gt;bfac();                   # factorial of $x (1*2*3*4*..$x)<br/>
<br/>
  $x-&gt;bround($N);               # accuracy: preserve $N digits<br/>
  $x-&gt;bfround($N);              # precision: round to the $Nth digit<br/>
<br/>
  $x-&gt;bfloor();                 # return integer less or equal than $x<br/>
  $x-&gt;bceil();                  # return integer greater or equal than $x<br/>
<br/>
  # The following do not modify their arguments:<br/>
<br/>
  bgcd(@values);                # greatest common divisor<br/>
  blcm(@values);                # lowest common multiplicator<br/>
<br/>
  $x-&gt;bstr();                   # return string<br/>
  $x-&gt;bsstr();                  # return string in scientific notation<br/>
<br/>
  $x-&gt;as_int();                 # return $x as BigInt <br/>
  $x-&gt;exponent();               # return exponent as BigInt<br/>
  $x-&gt;mantissa();               # return mantissa as BigInt<br/>
  $x-&gt;parts();                  # return (mantissa,exponent) as BigInt<br/>
<br/>
  $x-&gt;length();                 # number of digits (w/o sign and '.')<br/>
  ($l,$f) = $x-&gt;length();       # number of digits, and length of fraction<br/>
<br/>
  $x-&gt;precision();              # return P of $x (or global, if P of $x undef)<br/>
  $x-&gt;precision($n);            # set P of $x to $n<br/>
  $x-&gt;accuracy();               # return A of $x (or global, if A of $x undef)<br/>
  $x-&gt;accuracy($n);             # set A $x to $n<br/>
<br/>
  # these get/set the appropriate global value for all BigFloat objects<br/>
  Math::BigFloat-&gt;precision();  # Precision<br/>
  Math::BigFloat-&gt;accuracy();   # Accuracy<br/>
  Math::BigFloat-&gt;round_mode(); # rounding mode<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> All operators (including basic math operations) are overloaded if you declare your big floating point numbers as<div class="spacer">
</div>
<br/>
  $i = new Math::BigFloat '12_3.456_789_123_456_789E-2';<br/>
<div class="spacer">
</div>
Operations with overloaded operators preserve the arguments, which is exactly what you expect.<div class="subsection">
<h2>Canonical notation</h2> Input to these routines are either BigFloat objects, or strings of the following four forms:<dl>
<dt>
&#8226;</dt>
<dd>
&quot;/^[+-]\d+$/&quot;</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;/^[+-]\d+\.\d*$/&quot;</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;/^[+-]\d+E[+-]?\d+$/&quot;</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;/^[+-]\d*\.\d+E[+-]?\d+$/&quot;</dd>
</dl>
<div class="spacer">
</div>
all with optional leading and trailing zeros and/or spaces. Additionally, numbers are allowed to have an underscore between any two digits.<div class="spacer">
</div>
Empty strings as well as other illegal numbers results in 'NaN'.<div class="spacer">
</div>
<i>bnorm()</i> on a BigFloat object is now effectively a no-op, since the numbers are always stored in normalized form. On a string, it creates a BigFloat object.</div>
<div class="subsection">
<h2>Output</h2> Output values are BigFloat objects (normalized), except for  <i>bstr()</i> and <i>bsstr()</i>.<div class="spacer">
</div>
The string output will always have leading and trailing zeros stripped and drop a plus sign. &quot;bstr()&quot; will give you always the form with a decimal point, while &quot;bsstr()&quot; (s for scientific) gives you the scientific notation.<div class="spacer">
</div>
<br/>
        Input                   bstr()          bsstr()<br/>
        '-0'                    '0'             '0E1'<br/>
        '  -123 123 123'        '-123123123'    '-123123123E0'<br/>
        '00.0123'               '0.0123'        '123E-4'<br/>
        '123.45E-2'             '1.2345'        '12345E-4'<br/>
        '10E+3'                 '10000'         '1E4'<br/>
<div class="spacer">
</div>
Some routines (&quot;is_odd()&quot;, &quot;is_even()&quot;, &quot;is_zero()&quot;, &quot;is_one()&quot;, &quot;is_nan()&quot;) return true or false, while others (&quot;bcmp()&quot;, &quot;bacmp()&quot;) return either undef, &lt;0, 0 or &gt;0 and are suited for sort.<div class="spacer">
</div>
Actual math is done by using the class defined with &quot;with =&gt; Class;&quot; (which defaults to BigInts) to represent the mantissa and exponent.<div class="spacer">
</div>
The sign &quot;/^[+-]$/&quot; is stored separately. The string 'NaN' is used to represent the result when input arguments are not numbers, as well as the result of dividing by zero.</div>
<div class="subsection">
<h2>&quot;mantissa()&quot;, &quot;exponent()&quot; and &quot;parts()&quot;</h2> &quot;mantissa()&quot; and &quot;exponent()&quot; return the said parts of the BigFloat as BigInts such that:<div class="spacer">
</div>
<br/>
        $m = $x-&gt;mantissa();<br/>
        $e = $x-&gt;exponent();<br/>
        $y = $m * ( 10 ** $e );<br/>
        print &quot;ok\n&quot; if $x == $y;<br/>
<div class="spacer">
</div>
&quot;($m,$e) = $x-&gt;parts();&quot; is just a shortcut giving you both of them.<div class="spacer">
</div>
A zero is represented and returned as 0E1, <b>not</b> 0E0 (after Knuth).<div class="spacer">
</div>
Currently the mantissa is reduced as much as possible, favouring higher exponents over lower ones (e.g. returning 1e7 instead of 10e6 or 10000000e0). This might change in the future, so do not depend on it.</div>
<div class="subsection">
<h2>Accuracy vs. Precision</h2> See also: Rounding.<div class="spacer">
</div>
Math::BigFloat supports both precision (rounding to a certain place before or after the dot) and accuracy (rounding to a certain number of digits). For a full documentation, examples and tips on these topics please see the large section about rounding in Math::BigInt.<div class="spacer">
</div>
Since things like sqrt(2) or &quot;1 / 3&quot; must presented with a limited accuracy lest a operation consumes all resources, each operation produces no more than the requested number of digits.<div class="spacer">
</div>
If there is no global precision or accuracy set, <b>and</b> the operation in question was not called with a requested precision or accuracy,  <b>and</b> the input $x has no accuracy or precision set, then a fallback parameter will be used. For historical reasons, it is called &quot;div_scale&quot; and can be accessed via:<div class="spacer">
</div>
<br/>
        $d = Math::BigFloat-&gt;div_scale();               # query<br/>
        Math::BigFloat-&gt;div_scale($n);                  # set to $n digits<br/>
<div class="spacer">
</div>
The default value for &quot;div_scale&quot; is 40.<div class="spacer">
</div>
In case the result of one operation has more digits than specified, it is rounded. The rounding mode taken is either the default mode, or the one supplied to the operation after the  <i>scale</i>:<div class="spacer">
</div>
<br/>
        $x = Math::BigFloat-&gt;new(2);<br/>
        Math::BigFloat-&gt;accuracy(5);            # 5 digits max<br/>
        $y = $x-&gt;copy()-&gt;bdiv(3);               # will give 0.66667<br/>
        $y = $x-&gt;copy()-&gt;bdiv(3,6);             # will give 0.666667<br/>
        $y = $x-&gt;copy()-&gt;bdiv(3,6,undef,'odd'); # will give 0.666667<br/>
        Math::BigFloat-&gt;round_mode('zero');<br/>
        $y = $x-&gt;copy()-&gt;bdiv(3,6);             # will also give 0.666667<br/>
<div class="spacer">
</div>
Note that &quot;Math::BigFloat-&gt;accuracy()&quot; and &quot;Math::BigFloat-&gt;precision()&quot; set the global variables, and thus  <b>any</b> newly created number will be subject to the global rounding  <b>immediately</b>. This means that in the examples above, the 3 as argument to &quot;bdiv()&quot; will also get an accuracy of  <b>5</b>.<div class="spacer">
</div>
It is less confusing to either calculate the result fully, and afterwards round it explicitly, or use the additional parameters to the math functions like so:<div class="spacer">
</div>
<br/>
        use Math::BigFloat;<br/>
        $x = Math::BigFloat-&gt;new(2);<br/>
        $y = $x-&gt;copy()-&gt;bdiv(3);<br/>
        print $y-&gt;bround(5),&quot;\n&quot;;               # will give 0.66667<br/>
<br/>
        or<br/>
<br/>
        use Math::BigFloat;<br/>
        $x = Math::BigFloat-&gt;new(2);<br/>
        $y = $x-&gt;copy()-&gt;bdiv(3,5);             # will give 0.66667<br/>
        print &quot;$y\n&quot;;<br/>
</div>
<div class="subsection">
<h2>Rounding</h2><dl>
<dt>
ffround ( +$scale )</dt>
<dd>
Rounds to the $scale'th place left from the '.', counting from the dot. The first digit is numbered 1.</dd>
</dl>
<dl>
<dt>
ffround ( -$scale )</dt>
<dd>
Rounds to the $scale'th place right from the '.', counting from the dot.</dd>
</dl>
<dl>
<dt>
ffround ( 0 )</dt>
<dd>
Rounds to an integer.</dd>
</dl>
<dl>
<dt>
fround  ( +$scale )</dt>
<dd>
Preserves accuracy to $scale digits from the left (aka significant digits) and pads the rest with zeros. If the number is between 1 and -1, the significant digits count from the first non-zero after the '.'</dd>
</dl>
<dl>
<dt>
fround  ( -$scale ) and fround ( 0 )</dt>
<dd>
These are effectively no-ops.</dd>
</dl>
<div class="spacer">
</div>
All rounding functions take as a second parameter a rounding mode from one of the following: 'even', 'odd', '+inf', '-inf', 'zero', 'trunc' or 'common'.<div class="spacer">
</div>
The default rounding mode is 'even'. By using &quot;Math::BigFloat-&gt;round_mode($round_mode);&quot; you can get and set the default mode for subsequent rounding. The usage of &quot;$Math::BigFloat::$round_mode&quot; is no longer supported. The second parameter to the round functions then overrides the default temporarily.<div class="spacer">
</div>
The &quot;as_number()&quot; function returns a BigInt from a Math::BigFloat. It uses 'trunc' as rounding mode to make it equivalent to:<div class="spacer">
</div>
<br/>
        $x = 2.5;<br/>
        $y = int($x) + 2;<br/>
<div class="spacer">
</div>
You can override this by passing the desired rounding mode as parameter to &quot;as_number()&quot;:<div class="spacer">
</div>
<br/>
        $x = Math::BigFloat-&gt;new(2.5);<br/>
        $y = $x-&gt;as_number('odd');      # $y = 3<br/>
</div>
</div>
<div class="section">
<h1>METHODS</h1> Math::BigFloat supports all methods that Math::BigInt supports, except it calculates non-integer results when possible. Please see Math::BigInt for a full description of each method. Below are just the most important differences:<div class="subsection">
<h2>accuracy</h2><br/>
        $x-&gt;accuracy(5);                # local for $x<br/>
        CLASS-&gt;accuracy(5);             # global for all members of CLASS<br/>
                                        # Note: This also applies to new()!<br/>
<br/>
        $A = $x-&gt;accuracy();            # read out accuracy that affects $x<br/>
        $A = CLASS-&gt;accuracy();         # read out global accuracy<br/>
<div class="spacer">
</div>
Set or get the global or local accuracy, aka how many significant digits the results have. If you set a global accuracy, then this also applies to  <i>new()</i>!<div class="spacer">
</div>
Warning! The accuracy <i>sticks</i>, e.g. once you created a number under the influence of &quot;CLASS-&gt;accuracy($A)&quot;, all results from math operations with that number will also be rounded.<div class="spacer">
</div>
In most cases, you should probably round the results explicitly using one of  <i>round()</i>, <i>bround()</i> or <i>bfround()</i> or by passing the desired accuracy to the math operation as additional parameter:<div class="spacer">
</div>
<br/>
        my $x = Math::BigInt-&gt;new(30000);<br/>
        my $y = Math::BigInt-&gt;new(7);<br/>
        print scalar $x-&gt;copy()-&gt;bdiv($y, 2);           # print 4300<br/>
        print scalar $x-&gt;copy()-&gt;bdiv($y)-&gt;bround(2);   # print 4300<br/>
</div>
<div class="subsection">
<h2><i>precision()</i></h2><br/>
        $x-&gt;precision(-2);      # local for $x, round at the second digit right of the dot<br/>
        $x-&gt;precision(2);       # ditto, round at the second digit left of the dot<br/>
<br/>
        CLASS-&gt;precision(5);    # Global for all members of CLASS<br/>
                                # This also applies to new()!<br/>
        CLASS-&gt;precision(-5);   # ditto<br/>
<br/>
        $P = CLASS-&gt;precision();        # read out global precision<br/>
        $P = $x-&gt;precision();           # read out precision that affects $x<br/>
<div class="spacer">
</div>
Note: You probably want to use <i>accuracy()</i> instead. With accuracy you set the number of digits each result should have, with precision you set the place where to round!</div>
<div class="subsection">
<h2><i>bexp()</i></h2><br/>
        $x-&gt;bexp($accuracy);            # calculate e ** X<br/>
<div class="spacer">
</div>
Calculates the expression &quot;e ** $x&quot; where &quot;e&quot; is Euler's number.<div class="spacer">
</div>
This method was added in v1.82 of Math::BigInt (April 2007).</div>
<div class="subsection">
<h2><i>bnok()</i></h2><br/>
        $x-&gt;bnok($y);              # x over y (binomial coefficient n over k)<br/>
<div class="spacer">
</div>
Calculates the binomial coefficient n over k, also called the &quot;choose&quot; function. The result is equivalent to:<div class="spacer">
</div>
<br/>
        ( n )      n!<br/>
        | - |  = -------<br/>
        ( k )    k!(n-k)!<br/>
<div class="spacer">
</div>
This method was added in v1.84 of Math::BigInt (April 2007).</div>
<div class="subsection">
<h2><i>bpi()</i></h2><br/>
        print Math::BigFloat-&gt;bpi(100), &quot;\n&quot;;<br/>
<div class="spacer">
</div>
Calculate PI to N digits (including the 3 before the dot). The result is rounded according to the current rounding mode, which defaults to &quot;even&quot;.<div class="spacer">
</div>
This method was added in v1.87 of Math::BigInt (June 2007).</div>
<div class="subsection">
<h2><i>bcos()</i></h2><br/>
        my $x = Math::BigFloat-&gt;new(1);<br/>
        print $x-&gt;bcos(100), &quot;\n&quot;;<br/>
<div class="spacer">
</div>
Calculate the cosinus of $x, modifying $x in place.<div class="spacer">
</div>
This method was added in v1.87 of Math::BigInt (June 2007).</div>
<div class="subsection">
<h2><i>bsin()</i></h2><br/>
        my $x = Math::BigFloat-&gt;new(1);<br/>
        print $x-&gt;bsin(100), &quot;\n&quot;;<br/>
<div class="spacer">
</div>
Calculate the sinus of $x, modifying $x in place.<div class="spacer">
</div>
This method was added in v1.87 of Math::BigInt (June 2007).</div>
<div class="subsection">
<h2><i>batan2()</i></h2><br/>
        my $y = Math::BigFloat-&gt;new(2);<br/>
        my $x = Math::BigFloat-&gt;new(3);<br/>
        print $y-&gt;batan2($x), &quot;\n&quot;;<br/>
<div class="spacer">
</div>
Calculate the arcus tanges of $y divided by $x, modifying $y in place. See also  <i>batan()</i>.<div class="spacer">
</div>
This method was added in v1.87 of Math::BigInt (June 2007).</div>
<div class="subsection">
<h2><i>batan()</i></h2><br/>
        my $x = Math::BigFloat-&gt;new(1);<br/>
        print $x-&gt;batan(100), &quot;\n&quot;;<br/>
<div class="spacer">
</div>
Calculate the arcus tanges of $x, modifying $x in place. See also <i>batan2()</i>.<div class="spacer">
</div>
This method was added in v1.87 of Math::BigInt (June 2007).</div>
<div class="subsection">
<h2><i>bmuladd()</i></h2><br/>
        $x-&gt;bmuladd($y,$z);<br/>
<div class="spacer">
</div>
Multiply $x by $y, and then add $z to the result.<div class="spacer">
</div>
This method was added in v1.87 of Math::BigInt (June 2007).</div>
</div>
<div class="section">
<h1>Autocreating constants</h1> After &quot;use Math::BigFloat ':constant'&quot; all the floating point constants in the given scope are converted to &quot;Math::BigFloat&quot;. This conversion happens at compile time.<div class="spacer">
</div>
In particular<div class="spacer">
</div>
<br/>
  perl -MMath::BigFloat=:constant -e 'print 2E-100,&quot;\n&quot;'<br/>
<div class="spacer">
</div>
prints the value of &quot;2E-100&quot;. Note that without conversion of constants the expression 2E-100 will be calculated as normal floating point number.<div class="spacer">
</div>
Please note that ':constant' does not affect integer constants, nor binary nor hexadecimal constants. Use bignum or Math::BigInt to get this to work.<div class="subsection">
<h2>Math library</h2> Math with the numbers is done (by default) by a module called Math::BigInt::Calc. This is equivalent to saying:<div class="spacer">
</div>
<br/>
        use Math::BigFloat lib =&gt; 'Calc';<br/>
<div class="spacer">
</div>
You can change this by using:<div class="spacer">
</div>
<br/>
        use Math::BigFloat lib =&gt; 'GMP';<br/>
<div class="spacer">
</div>
<b>Note</b>: General purpose packages should not be explicit about the library to use; let the script author decide which is best.<div class="spacer">
</div>
Note: The keyword 'lib' will warn when the requested library could not be loaded. To suppress the warning use 'try' instead:<div class="spacer">
</div>
<br/>
        use Math::BigFloat try =&gt; 'GMP';<br/>
<div class="spacer">
</div>
If your script works with huge numbers and Calc is too slow for them, you can also for the loading of one of these libraries and if none of them can be used, the code will die:<div class="spacer">
</div>
<br/>
        use Math::BigFloat only =&gt; 'GMP,Pari';<br/>
<div class="spacer">
</div>
The following would first try to find Math::BigInt::Foo, then Math::BigInt::Bar, and when this also fails, revert to Math::BigInt::Calc:<div class="spacer">
</div>
<br/>
        use Math::BigFloat lib =&gt; 'Foo,Math::BigInt::Bar';<br/>
<div class="spacer">
</div>
See the respective low-level library documentation for further details.<div class="spacer">
</div>
Please note that Math::BigFloat does <b>not</b> use the denoted library itself, but it merely passes the lib argument to Math::BigInt. So, instead of the need to do:<div class="spacer">
</div>
<br/>
        use Math::BigInt lib =&gt; 'GMP';<br/>
        use Math::BigFloat;<br/>
<div class="spacer">
</div>
you can roll it all into one line:<div class="spacer">
</div>
<br/>
        use Math::BigFloat lib =&gt; 'GMP';<br/>
<div class="spacer">
</div>
It is also possible to just require Math::BigFloat:<div class="spacer">
</div>
<br/>
        require Math::BigFloat;<br/>
<div class="spacer">
</div>
This will load the necessary things (like BigInt) when they are needed, and automatically.<div class="spacer">
</div>
See Math::BigInt for more details than you ever wanted to know about using a different low-level library.</div>
<div class="subsection">
<h2>Using Math::BigInt::Lite</h2> For backwards compatibility reasons it is still possible to request a different storage class for use with Math::BigFloat:<div class="spacer">
</div>
<br/>
        use Math::BigFloat with =&gt; 'Math::BigInt::Lite';<br/>
<div class="spacer">
</div>
However, this request is ignored, as the current code now uses the low-level math library for directly storing the number parts.</div>
</div>
<div class="section">
<h1>EXPORTS</h1> &quot;Math::BigFloat&quot; exports nothing by default, but can export the &quot;bpi()&quot; method:<div class="spacer">
</div>
<br/>
        use Math::BigFloat qw/bpi/;<br/>
<br/>
        print bpi(10), &quot;\n&quot;;<br/>
</div>
<div class="section">
<h1>BUGS</h1> Please see the file BUGS in the CPAN distribution Math::BigInt for known bugs.</div>
<div class="section">
<h1>CAVEATS</h1> Do not try to be clever to insert some operations in between switching libraries:<div class="spacer">
</div>
<br/>
        require Math::BigFloat;<br/>
        my $matter = Math::BigFloat-&gt;bone() + 4;        # load BigInt and Calc<br/>
        Math::BigFloat-&gt;import( lib =&gt; 'Pari' );        # load Pari, too<br/>
        my $anti_matter = Math::BigFloat-&gt;bone()+4;     # now use Pari<br/>
<div class="spacer">
</div>
This will create objects with numbers stored in two different backend libraries, and  <b>VERY BAD THINGS</b> will happen when you use these together:<div class="spacer">
</div>
<br/>
        my $flash_and_bang = $matter + $anti_matter;    # Don't do this!<br/>
<dl>
<dt>
stringify, <i>bstr()</i></dt>
<dd>
Both stringify and <i>bstr()</i> now drop the leading '+'. The old code would return '+1.23', the new returns '1.23'. See the documentation in Math::BigInt for reasoning and details.</dd>
</dl>
<dl>
<dt>
bdiv</dt>
<dd>
The following will probably not print what you expect:<div style="height: 1.00em;">
&#160;</div>
<br/>
        print $c-&gt;bdiv(123.456),&quot;\n&quot;;<br/>
<div style="height: 1.00em;">
&#160;</div>
It prints both quotient and remainder since print works in list context. Also,  <i>bdiv()</i> will modify $c, so be careful. You probably want to use<div style="height: 1.00em;">
&#160;</div>
<br/>
        print $c / 123.456,&quot;\n&quot;;<br/>
        print scalar $c-&gt;bdiv(123.456),&quot;\n&quot;;  # or if you want to modify $c<br/>
<div style="height: 1.00em;">
&#160;</div>
instead.</dd>
</dl>
<dl>
<dt>
brsft</dt>
<dd>
The following will probably not print what you expect:<div style="height: 1.00em;">
&#160;</div>
<br/>
        my $c = Math::BigFloat-&gt;new('3.14159');<br/>
        print $c-&gt;brsft(3,10),&quot;\n&quot;;     # prints 0.00314153.1415<br/>
<div style="height: 1.00em;">
&#160;</div>
It prints both quotient and remainder, since print calls &quot;brsft()&quot; in list context. Also, &quot;$c-&gt;brsft()&quot; will modify $c, so be careful. You probably want to use<div style="height: 1.00em;">
&#160;</div>
<br/>
        print scalar $c-&gt;copy()-&gt;brsft(3,10),&quot;\n&quot;;<br/>
        # or if you really want to modify $c<br/>
        print scalar $c-&gt;brsft(3,10),&quot;\n&quot;;<br/>
<div style="height: 1.00em;">
&#160;</div>
instead.</dd>
</dl>
<dl>
<dt>
Modifying and =</dt>
<dd>
Beware of:<div style="height: 1.00em;">
&#160;</div>
<br/>
        $x = Math::BigFloat-&gt;new(5);<br/>
        $y = $x;<br/>
<div style="height: 1.00em;">
&#160;</div>
It will not do what you think, e.g. making a copy of $x. Instead it just makes a second reference to the  <b>same</b> object and stores it in $y. Thus anything that modifies $x will modify $y (except overloaded math operators), and vice versa. See Math::BigInt for details and how to avoid that.</dd>
</dl>
<dl>
<dt>
bpow</dt>
<dd>
&quot;bpow()&quot; now modifies the first argument, unlike the old code which left it alone and only returned the result. This is to be consistent with &quot;badd()&quot; etc. The first will modify $x, the second one won't:<div style="height: 1.00em;">
&#160;</div>
<br/>
        print bpow($x,$i),&quot;\n&quot;;         # modify $x<br/>
        print $x-&gt;bpow($i),&quot;\n&quot;;        # ditto<br/>
        print $x ** $i,&quot;\n&quot;;            # leave $x alone<br/>
</dd>
</dl>
<dl>
<dt>
<i>precision()</i> vs. <i>accuracy()</i></dt>
<dd>
A common pitfall is to use <i>precision()</i> when you want to round a result to a certain number of digits:<div style="height: 1.00em;">
&#160;</div>
<br/>
        use Math::BigFloat;<br/>
<br/>
        Math::BigFloat-&gt;precision(4);           # does not do what you think it does<br/>
        my $x = Math::BigFloat-&gt;new(12345);     # rounds $x to &quot;12000&quot;!<br/>
        print &quot;$x\n&quot;;                           # print &quot;12000&quot;<br/>
        my $y = Math::BigFloat-&gt;new(3);         # rounds $y to &quot;0&quot;!<br/>
        print &quot;$y\n&quot;;                           # print &quot;0&quot;<br/>
        $z = $x / $y;                           # 12000 / 0 =&gt; NaN!<br/>
        print &quot;$z\n&quot;;<br/>
        print $z-&gt;precision(),&quot;\n&quot;;             # 4<br/>
<div style="height: 1.00em;">
&#160;</div>
Replacing precision with accuracy is probably not what you want, either:<div style="height: 1.00em;">
&#160;</div>
<br/>
        use Math::BigFloat;<br/>
<br/>
        Math::BigFloat-&gt;accuracy(4);            # enables global rounding:<br/>
        my $x = Math::BigFloat-&gt;new(123456);    # rounded immediately to &quot;12350&quot;<br/>
        print &quot;$x\n&quot;;                           # print &quot;123500&quot;<br/>
        my $y = Math::BigFloat-&gt;new(3);         # rounded to &quot;3<br/>
        print &quot;$y\n&quot;;                           # print &quot;3&quot;<br/>
        print $z = $x-&gt;copy()-&gt;bdiv($y),&quot;\n&quot;;   # 41170<br/>
        print $z-&gt;accuracy(),&quot;\n&quot;;              # 4<br/>
<div style="height: 1.00em;">
&#160;</div>
What you want to use instead is:<div style="height: 1.00em;">
&#160;</div>
<br/>
        use Math::BigFloat;<br/>
<br/>
        my $x = Math::BigFloat-&gt;new(123456);    # no rounding<br/>
        print &quot;$x\n&quot;;                           # print &quot;123456&quot;<br/>
        my $y = Math::BigFloat-&gt;new(3);         # no rounding<br/>
        print &quot;$y\n&quot;;                           # print &quot;3&quot;<br/>
        print $z = $x-&gt;copy()-&gt;bdiv($y,4),&quot;\n&quot;; # 41150<br/>
        print $z-&gt;accuracy(),&quot;\n&quot;;              # undef<br/>
<div style="height: 1.00em;">
&#160;</div>
In addition to computing what you expected, the last example also does <b>not</b> &quot;taint&quot; the result with an accuracy or precision setting, which would influence any further operation.</dd>
</dl>
</div>
<div class="section">
<h1>SEE ALSO</h1> Math::BigInt, Math::BigRat and Math::Big as well as Math::BigInt::BitVect, Math::BigInt::Pari and  Math::BigInt::GMP.<div class="spacer">
</div>
The pragmas bignum, bigint and bigrat might also be of interest because they solve the autoupgrading/downgrading issue, at least partly.<div class="spacer">
</div>
The package at http://search.cpan.org/~tels/Math-BigInt &lt;http://search.cpan.org/~tels/Math-BigInt&gt; contains more documentation including a full version history, testcases, empty subclass files and benchmarks.</div>
<div class="section">
<h1>LICENSE</h1> This program is free software; you may redistribute it and/or modify it under the same terms as Perl itself.</div>
<div class="section">
<h1>AUTHORS</h1> Mark Biggar, overloaded interface by Ilya Zakharevich. Completely rewritten by Tels &lt;http://bloodgate.com&gt; in 2001 - 2006, and still at it in 2007.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-09-26</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

