<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Config::Model::AnyId(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Config::Model::AnyId(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
Config::Model::AnyId(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Config::Model::AnyId - Base class for hash or list element</div>
<div class="section">
<h1>VERSION</h1> version 2.005</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
 use Config::Model;<br/>
 use Log::Log4perl qw(:easy);<br/>
 Log::Log4perl-&gt;easy_init($WARN);<br/>
<br/>
 # define configuration tree object<br/>
 my $model = Config::Model-&gt;new;<br/>
 $model-&gt;create_config_class(<br/>
    name    =&gt; &quot;Foo&quot;,<br/>
    element =&gt; [<br/>
        [qw/foo bar/] =&gt; {<br/>
            type       =&gt; 'leaf',<br/>
            value_type =&gt; 'string'<br/>
        },<br/>
    ]<br/>
 );<br/>
<br/>
 $model-&gt;create_config_class(<br/>
    name    =&gt; &quot;MyClass&quot;,<br/>
    element =&gt; [<br/>
        plain_hash =&gt; {<br/>
            type       =&gt; 'hash',<br/>
            index_type =&gt; 'string',<br/>
            cargo      =&gt; {<br/>
                type       =&gt; 'leaf',<br/>
                value_type =&gt; 'string',<br/>
            },<br/>
        },<br/>
        bounded_hash =&gt; {<br/>
            type       =&gt; 'hash',      # hash id<br/>
            index_type =&gt; 'integer',<br/>
<br/>
            # hash boundaries<br/>
            min_index =&gt; 1, max_index =&gt; 123, max_nb =&gt; 2,<br/>
<br/>
            # specify cargo held by hash<br/>
            cargo =&gt; {<br/>
                type       =&gt; 'leaf',<br/>
                value_type =&gt; 'string'<br/>
            },<br/>
        },<br/>
        bounded_list =&gt; {<br/>
            type =&gt; 'list',    # list id<br/>
<br/>
            max_index =&gt; 123,<br/>
            cargo     =&gt; {<br/>
                type       =&gt; 'leaf',<br/>
                value_type =&gt; 'string'<br/>
            },<br/>
        },<br/>
        hash_of_nodes =&gt; {<br/>
            type       =&gt; 'hash',     # hash id<br/>
            index_type =&gt; 'string',<br/>
            cargo      =&gt; {<br/>
                type              =&gt; 'node',<br/>
                config_class_name =&gt; 'Foo'<br/>
            },<br/>
        },<br/>
    ],<br/>
 );<br/>
<br/>
 my $inst = $model-&gt;instance( root_class_name =&gt; 'MyClass' );<br/>
<br/>
 my $root = $inst-&gt;config_root;<br/>
<br/>
 # put data<br/>
 my $step = 'plain_hash:foo=boo bounded_list=foo,bar,baz<br/>
   bounded_hash:3=foo bounded_hash:30=baz <br/>
   hash_of_nodes:&quot;foo node&quot; foo=&quot;in foo node&quot; -<br/>
   hash_of_nodes:&quot;bar node&quot; bar=&quot;in bar node&quot; ';<br/>
 $root-&gt;load( step =&gt; $step );<br/>
<br/>
 # dump resulting tree<br/>
 print $root-&gt;dump_tree;<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> This class provides hash or list elements for a Config::Model::Node.<div class="spacer">
</div>
The hash index can either be en enumerated type, a boolean, an integer or a string.</div>
<div class="section">
<h1>CONSTRUCTOR</h1> AnyId object should not be created directly.</div>
<div class="section">
<h1>Hash or list model declaration</h1> A hash or list element must be declared with the following parameters:<dl>
<dt>
type</dt>
<dd>
Mandatory element type. Must be &quot;hash&quot; or &quot;list&quot; to have a collection element.  The actual element type must be specified by &quot;cargo =&quot; type&gt; (See &quot;CAVEATS&quot;).</dd>
</dl>
<dl>
<dt>
index_type</dt>
<dd>
Either &quot;integer&quot; or &quot;string&quot;. Mandatory for hash.</dd>
</dl>
<dl>
<dt>
ordered</dt>
<dd>
Whether to keep the order of the hash keys (default no). (a bit like Tie::IxHash).  The hash keys are ordered along their creation. The order can be modified with swap, move_up or move_down.</dd>
</dl>
<dl>
<dt>
duplicates</dt>
<dd>
Specify the policy regarding duplicated values stored in the list or as hash values (valid only when cargo type is &quot;leaf&quot;). The policy can be &quot;allow&quot; (default), &quot;suppress&quot;, &quot;warn&quot; (which offers the possibility to apply a fix), &quot;forbid&quot;. Note that duplicates  <i>check cannot be</i>  <i>performed when the duplicated value is stored</i>: this happens outside of this object. Duplicates can be check only after when the value is read.</dd>
</dl>
<dl>
<dt>
cargo</dt>
<dd>
Hash ref specifying the cargo held by the hash of list. This has must contain:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
type</dt>
<dd>
Can be &quot;node&quot; or &quot;leaf&quot; (default).</dd>
</dl>
<dl>
<dt>
config_class_name</dt>
<dd>
Specifies the type of configuration object held in the hash. Only valid when &quot;cargo&quot; &quot;type&quot; is &quot;node&quot;.</dd>
</dl>
<dl>
<dt>
&lt;other&gt;</dt>
<dd>
Constructor arguments passed to the cargo object. See Config::Model::Node when &quot;cargo-&gt;type&quot; is &quot;node&quot;. See Config::Model::Value when &quot;cargo-&gt;type&quot; is &quot;leaf&quot;.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
</div>
<dl>
<dt>
min_index</dt>
<dd>
Specify the minimum value (optional, only for hash and for integer index)</dd>
</dl>
<dl>
<dt>
max_index</dt>
<dd>
Specify the maximum value (optional, only for list or for hash with integer index)</dd>
</dl>
<dl>
<dt>
max_nb</dt>
<dd>
Specify the maximum number of indexes. (hash only, optional, may also be used with string index type)</dd>
</dl>
<dl>
<dt>
default_keys</dt>
<dd>
When set, the default parameter (or set of parameters) are used as default keys hashes and created automatically when the &quot;keys&quot; or &quot;exists&quot; functions are used on an  <i>empty</i> hash..<div style="height: 1.00em;">
&#160;</div>
You can use &quot;default_keys =&gt; 'foo'&quot;, or &quot;default_keys =&gt; ['foo', 'bar']&quot;.</dd>
</dl>
<dl>
<dt>
default_with_init</dt>
<dd>
To perform special set-up on children nodes you can also use<div style="height: 1.00em;">
&#160;</div>
<br/>
   default_with_init =&gt;  { 'foo' =&gt; 'X=Av Y=Bv' ,<br/>
                           'bar' =&gt; 'Y=Av Z=Cv' }<br/>
<div style="height: 1.00em;">
&#160;</div>
When the hash contains leaves, you can also use:<div style="height: 1.00em;">
&#160;</div>
<br/>
   default_with_init =&gt; { 'def_1' =&gt; 'def_1 stuff' ,<br/>
                          'def_2' =&gt; 'def_2 stuff' }<br/>
</dd>
</dl>
<dl>
<dt>
migrate_keys_from</dt>
<dd>
Specifies that the keys of the hash or list are copied from another hash or list in the configuration tree only when the hash is created.<div style="height: 1.00em;">
&#160;</div>
<br/>
   migrate_keys_from =&gt; '- another_hash_or_list'<br/>
</dd>
</dl>
<dl>
<dt>
follow_keys_from</dt>
<dd>
Specifies that the keys of the hash follow the keys of another hash in the configuration tree. In other words, the hash you're creating will always have the same keys as the other hash.<div style="height: 1.00em;">
&#160;</div>
<br/>
   follow_keys_from =&gt; '- another_hash'<br/>
</dd>
</dl>
<dl>
<dt>
allow_keys</dt>
<dd>
Specifies authorized keys:<div style="height: 1.00em;">
&#160;</div>
<br/>
  allow_keys =&gt; ['foo','bar','baz']<br/>
</dd>
</dl>
<dl>
<dt>
allow_keys_from</dt>
<dd>
A bit like the &quot;follow_keys_from&quot; parameters. Except that the hash pointed to by &quot;allow_keys_from&quot; specified the authorized keys for this hash.<div style="height: 1.00em;">
&#160;</div>
<br/>
  allow_keys_from =&gt; '- another_hash'<br/>
</dd>
</dl>
<dl>
<dt>
allow_keys_matching</dt>
<dd>
Keys must match the specified regular expression. For instance:<div style="height: 1.00em;">
&#160;</div>
<br/>
  allow_keys_matching =&gt; '^foo\d\d$'<br/>
</dd>
</dl>
<dl>
<dt>
auto_create_keys</dt>
<dd>
When set, the default parameter (or set of parameters) are used as keys hashes and created automatically. (valid only for hash elements)<div style="height: 1.00em;">
&#160;</div>
Called with &quot;auto_create_keys =&gt; ['foo']&quot;, or &quot;auto_create_keys =&gt; ['foo', 'bar']&quot;.</dd>
</dl>
<dl>
<dt>
warn_if_key_match</dt>
<dd>
Issue a warning if the key matches the specified regular expression</dd>
</dl>
<dl>
<dt>
warn_unless_key_match</dt>
<dd>
Issue a warning unless the key matches the specified regular expression</dd>
</dl>
<dl>
<dt>
auto_create_ids</dt>
<dd>
Specifies the number of elements to create automatically. E.g.  &quot;auto_create_ids =&gt; 4&quot; will initialize the list with 4 undef elements. (valid only for list elements)</dd>
</dl>
<dl>
<dt>
convert =&gt; [uc | lc ]</dt>
<dd>
The hash key will be converted to uppercase (uc) or lowercase (lc).</dd>
</dl>
<dl>
<dt>
warp</dt>
<dd>
See &quot;Warp: dynamic value configuration&quot; below.</dd>
</dl>
</div>
<div class="section">
<h1>Warp: dynamic value configuration</h1> The Warp functionality enables an HashId or ListId object to change its default settings (e.g. &quot;min_index&quot;, &quot;max_index&quot; or &quot;max_nb&quot; parameters) dynamically according to the value of another &quot;Value&quot; object. (See Config::Model::WarpedThing for explanation on warp mechanism)<div class="spacer">
</div>
For instance, with this model:<div class="spacer">
</div>
<br/>
 $model -&gt;create_config_class <br/>
  (<br/>
   name =&gt; 'Root',<br/>
   'element'<br/>
   =&gt; [<br/>
       macro =&gt; { type =&gt; 'leaf',<br/>
                  value_type =&gt; 'enum',<br/>
                  name       =&gt; 'macro',<br/>
                  choice     =&gt; [qw/A B C/],<br/>
                },<br/>
       warped_hash =&gt; { type =&gt; 'hash',<br/>
                        index_type =&gt; 'integer',<br/>
                        max_nb     =&gt; 3,<br/>
                        warp       =&gt; {<br/>
                                       follow =&gt; '- macro',<br/>
                                       rules =&gt; { A =&gt; { max_nb =&gt; 1 },<br/>
                                                  B =&gt; { max_nb =&gt; 2 }<br/>
                                                }<br/>
                                      },<br/>
                        cargo =&gt; { type =&gt; 'node',<br/>
                                   config_class_name =&gt; 'Dummy'<br/>
                                 }<br/>
                      },<br/>
     ]<br/>
  );<br/>
<div class="spacer">
</div>
Setting &quot;macro&quot; to &quot;A&quot; will mean that &quot;warped_hash&quot; can only accept one instance of &quot;Dummy&quot;.<div class="spacer">
</div>
Setting &quot;macro&quot; to &quot;B&quot; will mean that &quot;warped_hash&quot; will accept two instances of &quot;Dummy&quot;.<div class="spacer">
</div>
Like other warped class, a HashId or ListId can have multiple warp masters (See &quot;Warp follow argument&quot; in Config::Model::WarpedThing:<div class="spacer">
</div>
<br/>
  warp =&gt; { follow =&gt; { m1 =&gt; '- macro1', <br/>
                        m2 =&gt; '- macro2' <br/>
                      },<br/>
            rules  =&gt; [ '$m1 eq &quot;A&quot; and $m2 eq &quot;A2&quot;' =&gt; { max_nb =&gt; 1},<br/>
                        '$m1 eq &quot;A&quot; and $m2 eq &quot;B2&quot;' =&gt; { max_nb =&gt; 2}<br/>
                      ],<br/>
          }<br/>
<div class="subsection">
<h2>Warp and auto_create_ids or auto_create_keys</h2> When a warp is applied with &quot;auto_create_keys&quot; or &quot;auto_create_ids&quot; parameter, the auto_created items are created if they are not already present. But this warp will never remove items that were previously auto created.<div class="spacer">
</div>
For instance, if a tied hash is created with &quot;auto_create =&gt; [a,b,c]&quot;, the hash contains &quot;(a,b,c)&quot;.<div class="spacer">
</div>
Then if a warp is applied with &quot;auto_create_keys =&gt; [c,d,e]&quot;, the hash will contain &quot;(a,b,c,d,e)&quot;. The items created by the first auto_create_keys are not removed.</div>
<div class="subsection">
<h2>Warp and max_nb</h2> When a warp is applied, the items that do not fit the constraint (e.g. min_index, max_index) are removed.<div class="spacer">
</div>
For the max_nb constraint, an exception will be raised if a warp leads to a number of items greater than the max_nb constraint.</div>
</div>
<div class="section">
<h1>Introspection methods</h1> The following methods returns the current value stored in the Id object (as declared in the model unless they were warped):<dl>
<dt>
min_index</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
max_index</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
max_nb</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
index_type</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
default_keys</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
default_with_init</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
follow_keys_from</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
auto_create_ids</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
auto_create_keys</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
ordered</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
morph</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
config_model</dt>
<dd>
</dd>
</dl>
<div class="subsection">
<h2><i>get_cargo_type()</i></h2> Returns the object type contained by the hash or list (i.e. returns &quot;cargo -&gt; type&quot;).</div>
<div class="subsection">
<h2>get_cargo_info( &lt; what &gt; )</h2> Returns more info on the cargo contained by the hash or list. &quot;what&quot; may be &quot;value_type&quot; or any other cargo info stored in the model. Will return undef if the requested info was not provided in the model.</div>
<div class="subsection">
<h2>get_default_keys</h2> Returns a list (or a list ref) of the current default keys. These keys can be set by the &quot;default_keys&quot; or &quot;default_with_init&quot; parameters or by the other hash pointed by &quot;follow_keys_from&quot; parameter.</div>
<div class="subsection">
<h2><i>name()</i></h2> Returns the object name. The name finishes with ' id'.</div>
<div class="subsection">
<h2><i>config_class_name()</i></h2> Returns the config_class_name of collected elements. Valid only for collection of nodes.<div class="spacer">
</div>
This method will return undef if &quot;cargo&quot; &quot;type&quot; is not &quot;node&quot;.</div>
<div class="subsection">
<h2>has_fixes</h2> Returns the number of fixes that can be applied to the current value.</div>
</div>
<div class="section">
<h1>Information management</h1><div class="subsection">
<h2>fetch_with_id ( index =&gt; $idx , [ check =&gt; 'no' ])</h2> Fetch the collected element held by the hash or list. Index check is 'yes' by default. Can be called with one parameter which will be used as index.</div>
<div class="subsection">
<h2>&quot;get( path =&quot; ..., mode =&gt; ... ,  check =&gt; ... , get_obj =&gt; 1|0, autoadd =&gt; 1|0)&gt;</h2> Get a value from a directory like path.</div>
<div class="subsection">
<h2>set( path, value )</h2> Set a value with a directory like path.</div>
<div class="subsection">
<h2>copy ( from_index, to_index )</h2> Deep copy an element within the hash or list. If the element contained by the hash or list is a node, all configuration information is copied from one node to another.</div>
<div class="subsection">
<h2><i>fetch_all()</i></h2> Returns an array containing all elements held by the hash or list.</div>
<div class="subsection">
<h2>fetch_all_values( mode =&gt; ..., check =&gt; ...)</h2> Returns an array containing all defined values held by the hash or list. (undefined values are simply discarded). This method is only valid for hash or list containing leaves.<div class="spacer">
</div>
With &quot;mode&quot; parameter, this method will return either:<dl>
<dt>
custom</dt>
<dd>
The value entered by the user</dd>
</dl>
<dl>
<dt>
preset</dt>
<dd>
The value entered in preset mode</dd>
</dl>
<dl>
<dt>
standard</dt>
<dd>
The value entered in preset mode or checked by default.</dd>
</dl>
<dl>
<dt>
default</dt>
<dd>
The default value (defined by the configuration model)</dd>
</dl>
</div>
<div class="subsection">
<h2><i>get_all_indexes()</i></h2> Returns an array containing all indexes of the hash or list. Hash keys are sorted alphabetically, except for ordered hashed.</div>
<div class="subsection">
<h2>children</h2> Like get_all_indexes. This method is polymorphic for all non-leaf objects of the configuration tree.</div>
<div class="subsection">
<h2>defined ( index )</h2> Returns true if the value held at &quot;index&quot; is defined.</div>
<div class="subsection">
<h2>exists ( index )</h2> Returns true if the value held at &quot;index&quot; exists (i.e the key exists but the value may be undefined). This method may not make sense for list element.</div>
<div class="subsection">
<h2>delete ( index )</h2> Delete the &quot;index&quot;ed value</div>
<div class="subsection">
<h2><i>clear()</i></h2> Delete all values (also delete underlying value or node objects).</div>
<div class="subsection">
<h2><i>clear_values()</i></h2> Delete all values (without deleting underlying value objects).</div>
<div class="subsection">
<h2>warning_msg ( [index] )</h2> Returns warnings concerning indexes of this hash. Without parameter, returns a string containing all warnings or undef. With an index, return the warnings concerning this index or undef.</div>
<div class="subsection">
<h2>error_msg</h2> Returns the error messages of this object (if any)</div>
</div>
<div class="section">
<h1>AUTHOR</h1> Dominique Dumont, ddumont [AT] cpan [DOT] org</div>
<div class="section">
<h1>SEE ALSO</h1> Config::Model, Config::Model::Instance, Config::Model::Node, Config::Model::WarpedNode, Config::Model::HashId, Config::Model::ListId, Config::Model::CheckList, Config::Model::Value</div>
<table class="foot">
<tr>
<td class="foot-date">
2012-02-24</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

