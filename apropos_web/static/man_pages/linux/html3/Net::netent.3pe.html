<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Net::netent(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Net::netent(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
Net::netent(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Net::netent - by-name interface to Perl's built-in getnet*() functions</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
 use Net::netent qw(:FIELDS);<br/>
 getnetbyname(&quot;loopback&quot;)               or die &quot;bad net&quot;;<br/>
 printf &quot;%s is %08X\n&quot;, $n_name, $n_net;<br/>
<br/>
 use Net::netent;<br/>
<br/>
 $n = getnetbyname(&quot;loopback&quot;)          or die &quot;bad net&quot;;<br/>
 { # there's gotta be a better way, eh?<br/>
     @bytes = unpack(&quot;C4&quot;, pack(&quot;N&quot;, $n-&gt;net));<br/>
     shift @bytes while @bytes &amp;&amp; $bytes[0] == 0;<br/>
 }<br/>
 printf &quot;%s is %08X [%d.%d.%d.%d]\n&quot;, $n-&gt;name, $n-&gt;net, @bytes;<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> This module's default exports override the core  <i>getnetbyname()</i> and  <i>getnetbyaddr()</i> functions, replacing them with versions that return &quot;Net::netent&quot; objects.  This object has methods that return the similarly named structure field name from the C's netent structure from  <i>netdb.h</i>; namely name, aliases, addrtype, and net.  The aliases method returns an array reference, the rest scalars.<div class="spacer">
</div>
You may also import all the structure fields directly into your namespace as regular variables using the :FIELDS import tag.  (Note that this still overrides your core functions.)  Access these fields as variables named with a preceding &quot;n_&quot;.  Thus, &quot;$net_obj-&gt;name()&quot; corresponds to $n_name if you import the fields.  Array references are available as regular array variables, so for example &quot;@{ $net_obj-&gt;aliases() }&quot; would be simply @n_aliases.<div class="spacer">
</div>
The <i>getnet()</i> function is a simple front-end that forwards a numeric argument to  <i>getnetbyaddr()</i>, and the rest to  <i>getnetbyname()</i>.<div class="spacer">
</div>
To access this functionality without the core overrides, pass the &quot;use&quot; an empty import list, and then access function functions with their full qualified names. On the other hand, the built-ins are still available via the &quot;CORE::&quot; pseudo-package.</div>
<div class="section">
<h1>EXAMPLES</h1> The  <i>getnet()</i> functions do this in the Perl core:<div class="spacer">
</div>
<br/>
    sv_setiv(sv, (I32)nent-&gt;n_net);<br/>
<div class="spacer">
</div>
The <i>gethost()</i> functions do this in the Perl core:<div class="spacer">
</div>
<br/>
    sv_setpvn(sv, hent-&gt;h_addr, len);<br/>
<div class="spacer">
</div>
That means that the address comes back in binary for the host functions, and as a regular perl integer for the net ones. This seems a bug, but here's how to deal with it:<div class="spacer">
</div>
<br/>
 use strict;<br/>
 use Socket;<br/>
 use Net::netent;<br/>
<br/>
 @ARGV = ('loopback') unless @ARGV;<br/>
<br/>
 my($n, $net);<br/>
<br/>
 for $net ( @ARGV ) {<br/>
<br/>
     unless ($n = getnetbyname($net)) {<br/>
        warn &quot;$0: no such net: $net\n&quot;;<br/>
        next;<br/>
     }<br/>
<br/>
     printf &quot;\n%s is %s%s\n&quot;, <br/>
            $net, <br/>
            lc($n-&gt;name) eq lc($net) ? &quot;&quot; : &quot;*really* &quot;,<br/>
            $n-&gt;name;<br/>
<br/>
     print &quot;\taliases are &quot;, join(&quot;, &quot;, @{$n-&gt;aliases}), &quot;\n&quot;<br/>
                if @{$n-&gt;aliases};     <br/>
<br/>
     # this is stupid; first, why is this not in binary?<br/>
     # second, why am i going through these convolutions<br/>
     # to make it looks right<br/>
     {<br/>
        my @a = unpack(&quot;C4&quot;, pack(&quot;N&quot;, $n-&gt;net));<br/>
        shift @a while @a &amp;&amp; $a[0] == 0;<br/>
        printf &quot;\taddr is %s [%d.%d.%d.%d]\n&quot;, $n-&gt;net, @a;<br/>
     }<br/>
<br/>
     if ($n = getnetbyaddr($n-&gt;net)) {<br/>
        if (lc($n-&gt;name) ne lc($net)) {<br/>
            printf &quot;\tThat addr reverses to net %s!\n&quot;, $n-&gt;name;<br/>
            $net = $n-&gt;name;<br/>
            redo;<br/>
        } <br/>
     }<br/>
 }<br/>
</div>
<div class="section">
<h1>NOTE</h1> While this class is currently implemented using the Class::Struct module to build a struct-like class, you shouldn't rely upon this.</div>
<div class="section">
<h1>AUTHOR</h1> Tom Christiansen</div>
<table class="foot">
<tr>
<td class="foot-date">
2010-12-30</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

