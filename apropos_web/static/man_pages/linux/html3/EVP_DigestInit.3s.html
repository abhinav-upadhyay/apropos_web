<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
EVP_DigestInit(3SSL)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
EVP_DigestInit(3SSL)</td>
<td class="head-vol">
OpenSSL</td>
<td class="head-rtitle">
EVP_DigestInit(3SSL)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> EVP_MD_CTX_init, EVP_MD_CTX_create, EVP_DigestInit_ex, EVP_DigestUpdate, EVP_DigestFinal_ex, EVP_MD_CTX_cleanup, EVP_MD_CTX_destroy, EVP_MAX_MD_SIZE, EVP_MD_CTX_copy_ex, EVP_MD_CTX_copy, EVP_MD_type, EVP_MD_pkey_type, EVP_MD_size, EVP_MD_block_size, EVP_MD_CTX_md, EVP_MD_CTX_size, EVP_MD_CTX_block_size, EVP_MD_CTX_type, EVP_md_null, EVP_md2, EVP_md5, EVP_sha, EVP_sha1, EVP_dss, EVP_dss1, EVP_mdc2, EVP_ripemd160, EVP_get_digestbyname, EVP_get_digestbynid, EVP_get_digestbyobj - EVP digest routines</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
 #include &lt;openssl/evp.h&gt;<br/>
<br/>
 void EVP_MD_CTX_init(EVP_MD_CTX *ctx);<br/>
 EVP_MD_CTX *EVP_MD_CTX_create(void);<br/>
<br/>
 int EVP_DigestInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, ENGINE *impl);<br/>
 int EVP_DigestUpdate(EVP_MD_CTX *ctx, const void *d, size_t cnt);<br/>
 int EVP_DigestFinal_ex(EVP_MD_CTX *ctx, unsigned char *md,<br/>
        unsigned int *s);<br/>
<br/>
 int EVP_MD_CTX_cleanup(EVP_MD_CTX *ctx);<br/>
 void EVP_MD_CTX_destroy(EVP_MD_CTX *ctx);<br/>
<br/>
 int EVP_MD_CTX_copy_ex(EVP_MD_CTX *out,const EVP_MD_CTX *in);  <br/>
<br/>
 int EVP_DigestInit(EVP_MD_CTX *ctx, const EVP_MD *type);<br/>
 int EVP_DigestFinal(EVP_MD_CTX *ctx, unsigned char *md,<br/>
        unsigned int *s);<br/>
<br/>
 int EVP_MD_CTX_copy(EVP_MD_CTX *out,EVP_MD_CTX *in);  <br/>
<br/>
 #define EVP_MAX_MD_SIZE (16+20) /* The SSLv3 md5+sha1 type */<br/>
<br/>
<br/>
 #define EVP_MD_type(e)                 ((e)-&gt;type)<br/>
 #define EVP_MD_pkey_type(e)            ((e)-&gt;pkey_type)<br/>
 #define EVP_MD_size(e)                 ((e)-&gt;md_size)<br/>
 #define EVP_MD_block_size(e)           ((e)-&gt;block_size)<br/>
<br/>
 #define EVP_MD_CTX_md(e)               (e)-&gt;digest)<br/>
 #define EVP_MD_CTX_size(e)             EVP_MD_size((e)-&gt;digest)<br/>
 #define EVP_MD_CTX_block_size(e)       EVP_MD_block_size((e)-&gt;digest)<br/>
 #define EVP_MD_CTX_type(e)             EVP_MD_type((e)-&gt;digest)<br/>
<br/>
 const EVP_MD *EVP_md_null(void);<br/>
 const EVP_MD *EVP_md2(void);<br/>
 const EVP_MD *EVP_md5(void);<br/>
 const EVP_MD *EVP_sha(void);<br/>
 const EVP_MD *EVP_sha1(void);<br/>
 const EVP_MD *EVP_dss(void);<br/>
 const EVP_MD *EVP_dss1(void);<br/>
 const EVP_MD *EVP_mdc2(void);<br/>
 const EVP_MD *EVP_ripemd160(void);<br/>
<br/>
 const EVP_MD *EVP_get_digestbyname(const char *name);<br/>
 #define EVP_get_digestbynid(a) EVP_get_digestbyname(OBJ_nid2sn(a))<br/>
 #define EVP_get_digestbyobj(a) EVP_get_digestbynid(OBJ_obj2nid(a))<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> The EVP digest routines are a high level interface to message digests.<div class="spacer">
</div>
<i>EVP_MD_CTX_init()</i> initializes digest context <b>ctx</b>.<div class="spacer">
</div>
<i>EVP_MD_CTX_create()</i> allocates, initializes and returns a digest context.<div class="spacer">
</div>
<i>EVP_DigestInit_ex()</i> sets up digest context <b>ctx</b> to use a digest  <b>type</b> from ENGINE <b>impl</b>. <b>ctx</b> must be initialized before calling this function.  <b>type</b> will typically be supplied by a functionsuch as <i>EVP_sha1()</i>. If  <b>impl</b> is NULL then the default implementation of digest <b>type</b> is used.<div class="spacer">
</div>
<i>EVP_DigestUpdate()</i> hashes <b>cnt</b> bytes of data at <b>d</b> into the digest context  <b>ctx</b>. This function can be called several times on the same  <b>ctx</b> to hash additional data.<div class="spacer">
</div>
<i>EVP_DigestFinal_ex()</i> retrieves the digest value from <b>ctx</b> and places it in  <b>md</b>. If the <b>s</b> parameter is not NULL then the number of bytes of data written (i.e. the length of the digest) will be written to the integer at  <b>s</b>, at most <b>EVP_MAX_MD_SIZE</b> bytes will be written. After calling  <i>EVP_DigestFinal_ex()</i> no additional calls to <i>EVP_DigestUpdate()</i> can be made, but  <i>EVP_DigestInit_ex()</i> can be called to initialize a new digest operation.<div class="spacer">
</div>
<i>EVP_MD_CTX_cleanup()</i> cleans up digest context <b>ctx</b>, it should be called after a digest context is no longer needed.<div class="spacer">
</div>
<i>EVP_MD_CTX_destroy()</i> cleans up digest context <b>ctx</b> and frees up the space allocated to it, it should be called only on a context created using  <i>EVP_MD_CTX_create()</i>.<div class="spacer">
</div>
<i>EVP_MD_CTX_copy_ex()</i> can be used to copy the message digest state from  <b>in</b> to <b>out</b>. This is useful if large amounts of data are to be hashed which only differ in the last few bytes.  <b>out</b> must be initialized before calling this function.<div class="spacer">
</div>
<i>EVP_DigestInit()</i> behaves in the same way as <i>EVP_DigestInit_ex()</i> except the passed context  <b>ctx</b> does not have to be initialized, and it always uses the default digest implementation.<div class="spacer">
</div>
<i>EVP_DigestFinal()</i> is similar to <i>EVP_DigestFinal_ex()</i> except the digest context  <b>ctx</b> is automatically cleaned up.<div class="spacer">
</div>
<i>EVP_MD_CTX_copy()</i> is similar to <i>EVP_MD_CTX_copy_ex()</i> except the destination  <b>out</b> does not have to be initialized.<div class="spacer">
</div>
<i>EVP_MD_size()</i> and <i>EVP_MD_CTX_size()</i> return the size of the message digest when passed an  <b>EVP_MD</b> or an <b>EVP_MD_CTX</b> structure, i.e. the size of the hash.<div class="spacer">
</div>
<i>EVP_MD_block_size()</i> and <i>EVP_MD_CTX_block_size()</i> return the block size of the message digest when passed an  <b>EVP_MD</b> or an <b>EVP_MD_CTX</b> structure.<div class="spacer">
</div>
<i>EVP_MD_type()</i> and <i>EVP_MD_CTX_type()</i> return the NID of the OBJECT IDENTIFIER representing the given message digest when passed an  <b>EVP_MD</b> structure. For example EVP_MD_type( <i>EVP_sha1()</i>) returns <b>NID_sha1</b>. This function is normally used when setting ASN1 OIDs.<div class="spacer">
</div>
<i>EVP_MD_CTX_md()</i> returns the <b>EVP_MD</b> structure corresponding to the passed  <b>EVP_MD_CTX</b>.<div class="spacer">
</div>
<i>EVP_MD_pkey_type()</i> returns the NID of the public key signing algorithm associated with this digest. For example  <i>EVP_sha1()</i> is associated with RSA so this will return  <b>NID_sha1WithRSAEncryption</b>. This &quot;link&quot; between digests and signature algorithms may not be retained in future versions of OpenSSL.<div class="spacer">
</div>
<i>EVP_md2()</i>, <i>EVP_md5()</i>, <i>EVP_sha()</i>, <i>EVP_sha1()</i>, <i>EVP_mdc2()</i> and <i>EVP_ripemd160()</i> return  <b>EVP_MD</b> structures for the MD2, MD5, SHA, SHA1, MDC2 and RIPEMD160 digest algorithms respectively. The associated signature algorithm is RSA in each case.<div class="spacer">
</div>
<i>EVP_dss()</i> and <i>EVP_dss1()</i> return <b>EVP_MD</b> structures for SHA and SHA1 digest algorithms but using DSS (DSA) for the signature algorithm. Note: there is no need to use these pseudo-digests in OpenSSL 1.0.0 and later, they are however retained for compatibility.<div class="spacer">
</div>
<i>EVP_md_null()</i> is a &quot;null&quot; message digest that does nothing: i.e. the hash it returns is of zero length.<div class="spacer">
</div>
<i>EVP_get_digestbyname()</i>, <i>EVP_get_digestbynid()</i> and <i>EVP_get_digestbyobj()</i> return an  <b>EVP_MD</b> structure when passed a digest name, a digest NID or an ASN1_OBJECT structure respectively. The digest table must be initialized using, for example,  <i>OpenSSL_add_all_digests()</i> for these functions to work.</div>
<div class="section">
<h1>RETURN VALUES</h1>  <i>EVP_DigestInit_ex()</i>, <i>EVP_DigestUpdate()</i> and <i>EVP_DigestFinal_ex()</i> return 1 for success and 0 for failure.<div class="spacer">
</div>
<i>EVP_MD_CTX_copy_ex()</i> returns 1 if successful or 0 for failure.<div class="spacer">
</div>
<i>EVP_MD_type()</i>, <i>EVP_MD_pkey_type()</i> and <i>EVP_MD_type()</i> return the NID of the corresponding OBJECT IDENTIFIER or NID_undef if none exists.<div class="spacer">
</div>
<i>EVP_MD_size()</i>, <i>EVP_MD_block_size()</i>, EVP_MD_CTX_size(e), <i>EVP_MD_size()</i>,  <i>EVP_MD_CTX_block_size()</i>	and <i>EVP_MD_block_size()</i> return the digest or block size in bytes.<div class="spacer">
</div>
<i>EVP_md_null()</i>, <i>EVP_md2()</i>, <i>EVP_md5()</i>, <i>EVP_sha()</i>, <i>EVP_sha1()</i>, <i>EVP_dss()</i>,  <i>EVP_dss1()</i>, <i>EVP_mdc2()</i> and <i>EVP_ripemd160()</i> return pointers to the corresponding EVP_MD structures.<div class="spacer">
</div>
<i>EVP_get_digestbyname()</i>, <i>EVP_get_digestbynid()</i> and <i>EVP_get_digestbyobj()</i> return either an  <b>EVP_MD</b> structure or NULL if an error occurs.</div>
<div class="section">
<h1>NOTES</h1> The  <b>EVP</b> interface to message digests should almost always be used in preference to the low level interfaces. This is because the code then becomes transparent to the digest used and much more flexible.<div class="spacer">
</div>
SHA1 is the digest of choice for new applications. The other digest algorithms are still in common use.<div class="spacer">
</div>
For most applications the <b>impl</b> parameter to <i>EVP_DigestInit_ex()</i> will be set to NULL to use the default digest implementation.<div class="spacer">
</div>
The functions <i>EVP_DigestInit()</i>, <i>EVP_DigestFinal()</i> and <i>EVP_MD_CTX_copy()</i> are obsolete but are retained to maintain compatibility with existing code. New applications should use  <i>EVP_DigestInit_ex()</i>, <i>EVP_DigestFinal_ex()</i> and  <i>EVP_MD_CTX_copy_ex()</i> because they can efficiently reuse a digest context instead of initializing and cleaning it up on each call and allow non default implementations of digests to be specified.<div class="spacer">
</div>
In OpenSSL 0.9.7 and later if digest contexts are not cleaned up after use memory leaks will occur.</div>
<div class="section">
<h1>EXAMPLE</h1> This example digests the data &quot;Test Message\n&quot; and &quot;Hello World\n&quot;, using the digest name passed on the command line.<div class="spacer">
</div>
<br/>
 #include &lt;stdio.h&gt;<br/>
 #include &lt;openssl/evp.h&gt;<br/>
<br/>
 main(int argc, char *argv[])<br/>
 {<br/>
 EVP_MD_CTX mdctx;<br/>
 const EVP_MD *md;<br/>
 char mess1[] = &quot;Test Message\n&quot;;<br/>
 char mess2[] = &quot;Hello World\n&quot;;<br/>
 unsigned char md_value[EVP_MAX_MD_SIZE];<br/>
 int md_len, i;<br/>
<br/>
 OpenSSL_add_all_digests();<br/>
<br/>
 if(!argv[1]) {<br/>
        printf(&quot;Usage: mdtest digestname\n&quot;);<br/>
        exit(1);<br/>
 }<br/>
<br/>
 md = EVP_get_digestbyname(argv[1]);<br/>
<br/>
 if(!md) {<br/>
        printf(&quot;Unknown message digest %s\n&quot;, argv[1]);<br/>
        exit(1);<br/>
 }<br/>
<br/>
 EVP_MD_CTX_init(&amp;mdctx);<br/>
 EVP_DigestInit_ex(&amp;mdctx, md, NULL);<br/>
 EVP_DigestUpdate(&amp;mdctx, mess1, strlen(mess1));<br/>
 EVP_DigestUpdate(&amp;mdctx, mess2, strlen(mess2));<br/>
 EVP_DigestFinal_ex(&amp;mdctx, md_value, &amp;md_len);<br/>
 EVP_MD_CTX_cleanup(&amp;mdctx);<br/>
<br/>
 printf(&quot;Digest is: &quot;);<br/>
 for(i = 0; i &lt; md_len; i++) printf(&quot;%02x&quot;, md_value[i]);<br/>
 printf(&quot;\n&quot;);<br/>
 }<br/>
</div>
<div class="section">
<h1>SEE ALSO</h1>  <i>evp</i>(3), <i>hmac</i>(3), <i>md2</i>(3),  <i>md5</i>(3), <i>mdc2</i>(3), <i>ripemd</i>(3),  <i>sha</i>(3), <i>dgst</i>(1)</div>
<div class="section">
<h1>HISTORY</h1>  <i>EVP_DigestInit()</i>, <i>EVP_DigestUpdate()</i> and <i>EVP_DigestFinal()</i> are available in all versions of SSLeay and OpenSSL.<div class="spacer">
</div>
<i>EVP_MD_CTX_init()</i>, <i>EVP_MD_CTX_create()</i>, <i>EVP_MD_CTX_copy_ex()</i>,  <i>EVP_MD_CTX_cleanup()</i>, <i>EVP_MD_CTX_destroy()</i>, <i>EVP_DigestInit_ex()</i> and  <i>EVP_DigestFinal_ex()</i> were added in OpenSSL 0.9.7.<div class="spacer">
</div>
<i>EVP_md_null()</i>, <i>EVP_md2()</i>, <i>EVP_md5()</i>, <i>EVP_sha()</i>, <i>EVP_sha1()</i>,  <i>EVP_dss()</i>, <i>EVP_dss1()</i>, <i>EVP_mdc2()</i> and <i>EVP_ripemd160()</i> were changed to return truely const EVP_MD * in OpenSSL 0.9.7.<div class="spacer">
</div>
The link between digests and signing algorithms was fixed in OpenSSL 1.0 and later, so now  <i>EVP_sha1()</i> can be used with RSA and DSA, there is no need to use  <i>EVP_dss1()</i> any more.<div class="spacer">
</div>
OpenSSL 1.0 and later does not include the MD2 digest algorithm in the default configuration due to its security weaknesses.</div>
<table class="foot">
<tr>
<td class="foot-date">
2009-10-16</td>
<td class="foot-os">
1.0.1</td>
</tr>
</table>
</div>
</body>
</html>

