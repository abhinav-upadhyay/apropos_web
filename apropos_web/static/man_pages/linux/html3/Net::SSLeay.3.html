<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Net::SSLeay(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Net::SSLeay(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
Net::SSLeay(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Net::SSLeay - Perl extension for using OpenSSL</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
  use Net::SSLeay qw(get_https post_https sslcat make_headers make_form);<br/>
<br/>
  ($page) = get_https('www.bacus.pt', 443, '/');                 # 1<br/>
<br/>
  ($page, $response, %reply_headers)<br/>
         = get_https('www.bacus.pt', 443, '/',                   # 2<br/>
                make_headers(User-Agent =&gt; 'Cryptozilla/5.0b1',<br/>
                             Referer    =&gt; 'https://www.bacus.pt'<br/>
                ));<br/>
<br/>
  ($page, $result, %headers) =                                   # 2b<br/>
         = get_https('www.bacus.pt', 443, '/protected.html',<br/>
              make_headers(Authorization =&gt;<br/>
                           'Basic ' . MIME::Base64::encode(&quot;$user:$pass&quot;,''))<br/>
              );<br/>
<br/>
  ($page, $response, %reply_headers)<br/>
         = post_https('www.bacus.pt', 443, '/foo.cgi', '',       # 3<br/>
                make_form(OK   =&gt; '1',<br/>
                          name =&gt; 'Sampo'<br/>
                ));<br/>
<br/>
  $reply = sslcat($host, $port, $request);                       # 4<br/>
<br/>
  ($reply, $err, $server_cert) = sslcat($host, $port, $request); # 5<br/>
<br/>
  $Net::SSLeay::trace = 2;  # 0=no debugging, 1=ciphers, 2=trace, 3=dump data<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> There is a related module called &quot;Net::SSLeay::Handle&quot; included in this distribution that you might want to use instead. It has its own pod documentation.<div class="spacer">
</div>
This module offers some high level convenience functions for accessing web pages on SSL servers (for symmetry, the same API is offered for accessing http servers, too), an &quot;sslcat()&quot; function for writing your own clients, and finally access to the SSL api of the SSLeay/OpenSSL package so you can write servers or clients for more complicated applications.<div class="spacer">
</div>
For high level functions it is most convenient to import them into your main namespace as indicated in the synopsis.<div class="spacer">
</div>
Case 1 demonstrates the typical invocation of <i>get_https()</i> to fetch an HTML page from secure server. The first argument provides the hostname or IP in dotted decimal notation of the remote server to contact. The second argument is the TCP port at the remote end (your own port is picked arbitrarily from high numbered ports as usual for TCP). The third argument is the URL of the page without the host name part. If in doubt consult the HTTP specifications at &lt;http://www.w3c.org&gt;.<div class="spacer">
</div>
Case 2 demonstrates full fledged use of &quot;get_https()&quot;. As can be seen, &quot;get_https()&quot; parses the response and response headers and returns them as a list, which can be captured in a hash for later reference. Also a fourth argument to &quot;get_https()&quot; is used to insert some additional headers in the request. &quot;make_headers()&quot; is a function that will convert a list or hash to such headers. By default &quot;get_https()&quot; supplies &quot;Host&quot; (to make virtual hosting easy) and &quot;Accept&quot; (reportedly needed by IIS) headers.<div class="spacer">
</div>
Case 2b demonstrates how to get a password protected page. Refer to the HTTP protocol specifications for further details (e.g. RFC-2617).<div class="spacer">
</div>
Case 3 invokes &quot;post_https()&quot; to submit a HTML/CGI form to a secure server. The first four arguments are equal to &quot;get_https()&quot; (note that the empty string ('') is passed as header argument). The fifth argument is the contents of the form formatted according to CGI specification. In this case the helper function &quot;make_https()&quot; is used to do the formatting, but you could pass any string. &quot;post_https()&quot; automatically adds &quot;Content-Type&quot; and &quot;Content-Length&quot; headers to the request.<div class="spacer">
</div>
Case 4 shows the fundamental &quot;sslcat()&quot; function (inspired in spirit by the &quot;netcat&quot; utility :-). It's your swiss army knife that allows you to easily contact servers, send some data, and then get the response. You are responsible for formatting the data and parsing the response - &quot;sslcat()&quot; is just a transport.<div class="spacer">
</div>
Case 5 is a full invocation of &quot;sslcat()&quot; which allows the return of errors as well as the server (peer) certificate.<div class="spacer">
</div>
The $trace global variable can be used to control the verbosity of the high level functions. Level 0 guarantees silence, level 1 (the default) only emits error messages.<div class="subsection">
<h2>Alternate versions of the API</h2> The above mentioned functions actually return the response headers as a list, which only gets converted to hash upon assignment (this assignment looses information if the same header occurs twice, as may be the case with cookies). There are also other variants of the functions that return unprocessed headers and that return a reference to a hash.<div class="spacer">
</div>
<br/>
  ($page, $response, @headers) = get_https('www.bacus.pt', 443, '/');<br/>
  for ($i = 0; $i &lt; $#headers; $i+=2) {<br/>
      print &quot;$headers[$i] = &quot; . $headers[$i+1] . &quot;\n&quot;;<br/>
  }<br/>
<br/>
  ($page, $response, $headers, $server_cert)<br/>
    = get_https3('www.bacus.pt', 443, '/');<br/>
  print &quot;$headers\n&quot;;<br/>
<br/>
  ($page, $response, %headers_ref, $server_cert)<br/>
    = get_https4('www.bacus.pt', 443, '/');<br/>
  for $k (sort keys %{headers_ref}) {<br/>
      for $v (@{$headers_ref{$k}}) {<br/>
          print &quot;$k = $v\n&quot;;<br/>
      }<br/>
  }<br/>
<div class="spacer">
</div>
All of the above code fragments accomplish the same thing: display all values of all headers. The API functions ending in &quot;3&quot; return the headers simply as a scalar string and it is up to the application to split them up. The functions ending in &quot;4&quot; return a reference to a hash of arrays (see perlref and perllol if you are not familiar with complex perl data structures). To access a single value of such a header hash you would do something like<div class="spacer">
</div>
<br/>
  print $headers_ref{COOKIE}[0];<br/>
<div class="spacer">
</div>
Variants 3 and 4 also allow you to discover the server certificate in case you would like to store or display it, e.g.<div class="spacer">
</div>
<br/>
  ($p, $resp, $hdrs, $server_cert) = get_https3('www.bacus.pt', 443, '/');<br/>
  if (!defined($server_cert) || ($server_cert == 0)) {<br/>
      warn &quot;Subject Name: undefined, Issuer  Name: undefined&quot;;<br/>
  } else {<br/>
      warn 'Subject Name: '<br/>
          . Net::SSLeay::X509_NAME_oneline(<br/>
                 Net::SSLeay::X509_get_subject_name($server_cert))<br/>
              . 'Issuer  Name: '<br/>
                  . Net::SSLeay::X509_NAME_oneline(<br/>
                         Net::SSLeay::X509_get_issuer_name($server_cert));<br/>
  }<br/>
<div class="spacer">
</div>
Beware that this method only allows after the fact verification of the certificate: by the time &quot;get_https3()&quot; has returned the https request has already been sent to the server, whether you decide to trust it or not. To do the verification correctly you must either employ the OpenSSL certificate verification framework or use the lower level API to first connect and verify the certificate and only then send the http data. See the implementation of &quot;ds_https3()&quot; for guidance on how to do this.</div>
<div class="subsection">
<h2>Using client certificates</h2> Secure web communications are encrypted using symmetric crypto keys exchanged using encryption based on the certificate of the server. Therefore in all SSL connections the server must have a certificate. This serves both to authenticate the server to the clients and to perform the key exchange.<div class="spacer">
</div>
Sometimes it is necessary to authenticate the client as well. Two options are available: HTTP basic authentication and a client side certificate. The basic authentication over HTTPS is actually quite safe because HTTPS guarantees that the password will not travel in the clear. Never-the-less, problems like easily guessable passwords remain. The client certificate method involves authentication of the client at the SSL level using a certificate. For this to work, both the client and the server have certificates (which typically are different) and private keys.<div class="spacer">
</div>
The API functions outlined above accept additional arguments that allow one to supply the client side certificate and key files. The format of these files is the same as used for server certificates and the caveat about encrypting private keys applies.<div class="spacer">
</div>
<br/>
  ($page, $result, %headers) =                                   # 2c<br/>
         = get_https('www.bacus.pt', 443, '/protected.html',<br/>
              make_headers(Authorization =&gt;<br/>
                           'Basic ' . MIME::Base64::encode(&quot;$user:$pass&quot;,'')),<br/>
              '', $mime_type6, $path_to_crt7, $path_to_key8);<br/>
<br/>
  ($page, $response, %reply_headers)<br/>
         = post_https('www.bacus.pt', 443, '/foo.cgi',           # 3b<br/>
              make_headers('Authorization' =&gt;<br/>
                           'Basic ' . MIME::Base64::encode(&quot;$user:$pass&quot;,'')),<br/>
              make_form(OK   =&gt; '1', name =&gt; 'Sampo'),<br/>
              $mime_type6, $path_to_crt7, $path_to_key8);<br/>
<div class="spacer">
</div>
Case 2c demonstrates getting a password protected page that also requires a client certificate, i.e. it is possible to use both authentication methods simultaneously.<div class="spacer">
</div>
Case 3b is a full blown POST to a secure server that requires both password authentication and a client certificate, just like in case 2c.<div class="spacer">
</div>
Note: The client will not send a certificate unless the server requests one. This is typically achieved by setting the verify mode to &quot;VERIFY_PEER&quot; on the server:<div class="spacer">
</div>
<br/>
  Net::SSLeay::set_verify(ssl, Net::SSLeay::VERIFY_PEER, 0);<br/>
<div class="spacer">
</div>
See &quot;perldoc ~openssl/doc/ssl/SSL_CTX_set_verify.pod&quot; for a full description.</div>
<div class="subsection">
<h2>Working through a web proxy</h2> &quot;Net::SSLeay&quot; can use a web proxy to make its connections. You need to first set the proxy host and port using &quot;set_proxy()&quot; and then just use the normal API functions, e.g:<div class="spacer">
</div>
<br/>
  Net::SSLeay::set_proxy('gateway.myorg.com', 8080);<br/>
  ($page) = get_https('www.bacus.pt', 443, '/');<br/>
<div class="spacer">
</div>
If your proxy requires authentication, you can supply a username and password as well<div class="spacer">
</div>
<br/>
  Net::SSLeay::set_proxy('gateway.myorg.com', 8080, 'joe', 'salainen');<br/>
  ($page, $result, %headers) =<br/>
         = get_https('www.bacus.pt', 443, '/protected.html',<br/>
              make_headers(Authorization =&gt;<br/>
                           'Basic ' . MIME::Base64::encode(&quot;susie:pass&quot;,''))<br/>
              );<br/>
<div class="spacer">
</div>
This example demonstrates the case where we authenticate to the proxy as &quot;joe&quot; and to the final web server as &quot;susie&quot;. Proxy authentication requires the &quot;MIME::Base64&quot; module to work.</div>
<div class="subsection">
<h2>Certificate verification and Certificate Revoocation Lists (CRLs)</h2> OpenSSL supports the ability to verify peer certificates. It can also optionally check the peer certificate against a Certificate Revocation List (CRL) from the certificates issuer. A CRL is a file, created by the certificate issuer that lists all the certificates that it previously signed, but which it now revokes. CRLs are in PEM format.<div class="spacer">
</div>
You can enable &quot;Net::SSLeay CRL&quot; checking like this:<div class="spacer">
</div>
<br/>
            &amp;Net::SSLeay::X509_STORE_set_flags<br/>
                (&amp;Net::SSLeay::CTX_get_cert_store($ssl), <br/>
                 &amp;Net::SSLeay::X509_V_FLAG_CRL_CHECK);<br/>
<div class="spacer">
</div>
After setting this flag, if OpenSSL checks a peer's certificate, then it will attempt to find a CRL for the issuer. It does this by looking for a specially named file in the search directory specified by CTX_load_verify_locations.  CRL files are named with the hash of the issuer's subject name, followed by &quot;.r0&quot;, &quot;.r1&quot; etc.  For example &quot;ab1331b2.r0&quot;, &quot;ab1331b2.r1&quot;. It will read all the .r files for the issuer, and then check for a revocation of the peer cerificate in all of them.  (You can also force it to look in a specific named CRL file., see below).  You can find out the hash of the issuer subject name in a CRL with<div class="spacer">
</div>
<br/>
        openssl crl -in crl.pem -hash -noout<br/>
<div class="spacer">
</div>
If the peer certificate does not pass the revocation list, or if no CRL is found, then the handshaking fails with an error.<div class="spacer">
</div>
You can also force OpenSSL to look for CRLs in one or more arbitrarily named files.<div class="spacer">
</div>
<br/>
    my $bio = Net::SSLeay::BIO_new_file($crlfilename, 'r');<br/>
    my $crl = Net::SSLeay::PEM_read_bio_X509_CRL($bio);<br/>
    if ($crl) {<br/>
        Net::SSLeay::X509_STORE_add_crl(<br/>
            Net::SSLeay::CTX_get_cert_store($ssl, $crl);<br/>
    } else {<br/>
        error reading CRL....<br/>
    }<br/>
</div>
<div class="subsection">
<h2>Convenience routines</h2> To be used with Low level API<div class="spacer">
</div>
<br/>
    Net::SSLeay::randomize($rn_seed_file,$additional_seed);<br/>
    Net::SSLeay::set_cert_and_key($ctx, $cert_path, $key_path);<br/>
    $cert = Net::SSLeay::dump_peer_certificate($ssl);<br/>
    Net::SSLeay::ssl_write_all($ssl, $message) or die &quot;ssl write failure&quot;;<br/>
    $got = Net::SSLeay::ssl_read_all($ssl) or die &quot;ssl read failure&quot;;<br/>
<br/>
    $got = Net::SSLeay::ssl_read_CRLF($ssl [, $max_length]);<br/>
    $got = Net::SSLeay::ssl_read_until($ssl [, $delimit [, $max_length]]);<br/>
    Net::SSLeay::ssl_write_CRLF($ssl, $message);<br/>
<div class="spacer">
</div>
&quot;randomize()&quot; seeds the openssl PRNG with &quot;/dev/urandom&quot; (see the top of &quot;SSLeay.pm&quot; for how to change or configure this) and optionally with user provided data. It is very important to properly seed your random numbers, so do not forget to call this. The high level API functions automatically call &quot;randomize()&quot; so it is not needed with them. See also caveats.<div class="spacer">
</div>
&quot;set_cert_and_key()&quot; takes two file names as arguments and sets the certificate and private key to those. This can be used to set either cerver certificates or client certificates.<div class="spacer">
</div>
&quot;dump_peer_certificate()&quot; allows you to get a plaintext description of the certificate the peer (usually the server) presented to us.<div class="spacer">
</div>
&quot;ssl_read_all()&quot; and &quot;ssl_write_all()&quot; provide true blocking semantics for these operations (see limitation, below, for explanation). These are much preferred to the low level API equivalents (which implement BSD blocking semantics). The message argument to &quot;ssl_write_all()&quot; can be a reference. This is helpful to avoid unnecessary copying when writing something big, e.g:<div class="spacer">
</div>
<br/>
    $data = 'A' x 1000000000;<br/>
    Net::SSLeay::ssl_write_all($ssl, \$data) or die &quot;ssl write failed&quot;;<br/>
<div class="spacer">
</div>
&quot;ssl_read_CRLF()&quot; uses &quot;ssl_read_all()&quot; to read in a line terminated with a carriage return followed by a linefeed (CRLF).  The CRLF is included in the returned scalar.<div class="spacer">
</div>
&quot;ssl_read_until()&quot; uses &quot;ssl_read_all()&quot; to read from the SSL input stream until it encounters a programmer specified delimiter. If the delimiter is undefined, $/ is used.  If $/ is undefined, &quot;\n&quot; is used.  One can optionally set a maximum length of bytes to read from the SSL input stream.<div class="spacer">
</div>
&quot;ssl_write_CRLF()&quot; writes $message and appends CRLF to the SSL output stream.</div>
<div class="subsection">
<h2>Low level API</h2> In addition to the high level functions outlined above, this module contains straight-forward access to SSL part of OpenSSL C api. Only the SSL subpart of OpenSSL is implemented (if anyone wants to implement other parts, feel free to submit patches).<div class="spacer">
</div>
See the &quot;ssl.h&quot; header from OpenSSL C distribution for a list of low level SSLeay functions to call (check SSLeay.xs to see if some function has been implemented). The module strips the initial &quot;SSL_&quot; off of the SSLeay names. Generally you should use &quot;Net::SSLeay::&quot; in its place. For example:<div class="spacer">
</div>
In C:<div class="spacer">
</div>
<br/>
        #include &lt;ssl.h&gt;<br/>
<br/>
        err = SSL_set_verify (ssl, SSL_VERIFY_CLIENT_ONCE,<br/>
                                   &amp;your_call_back_here);<br/>
<div class="spacer">
</div>
In Perl:<div class="spacer">
</div>
<br/>
        use Net::SSLeay;<br/>
<br/>
        $err = Net::SSLeay::set_verify ($ssl,<br/>
                                        Net::SSLeay::VERIFY_CLIENT_ONCE,<br/>
                                        \&amp;your_call_back_here);<br/>
<div class="spacer">
</div>
If the function does not start with &quot;SSL_&quot; you should use the full function name, e.g.:<div class="spacer">
</div>
<br/>
        $err = Net::SSLeay::ERR_get_error;<br/>
<div class="spacer">
</div>
The following new functions behave in perlish way:<div class="spacer">
</div>
<br/>
        $got = Net::SSLeay::read($ssl);<br/>
                                    # Performs SSL_read, but returns $got<br/>
                                    # resized according to data received.<br/>
                                    # Returns undef on failure.<br/>
<br/>
        Net::SSLeay::write($ssl, $foo) || die;<br/>
                                    # Performs SSL_write, but automatically<br/>
                                    # figures out the size of $foo<br/>
<div class="spacer">
</div>
In order to use the low level API you should start your programs with the following incantation:<div class="spacer">
</div>
<br/>
        use Net::SSLeay qw(die_now die_if_ssl_error);<br/>
        Net::SSLeay::load_error_strings();<br/>
        Net::SSLeay::SSLeay_add_ssl_algorithms();    # Important!<br/>
        Net::SSLeay::ENGINE_load_builtin_engines();  # If you want built-in engines<br/>
        Net::SSLeay::ENGINE_register_all_complete(); # If you want built-in engines<br/>
        Net::SSLeay::randomize();<br/>
<div class="spacer">
</div>
&quot;die_now()&quot; and &quot;die_if_ssl_error()&quot; are used to conveniently print the SSLeay error stack when something goes wrong, thusly:<div class="spacer">
</div>
<br/>
        Net::SSLeay::connect($ssl) or die_now(&quot;Failed SSL connect ($!)&quot;);<br/>
        Net::SSLeay::write($ssl, &quot;foo&quot;) or die_if_ssl_error(&quot;SSL write ($!)&quot;);<br/>
<div class="spacer">
</div>
You can also use &quot;Net::SSLeay::print_errs()&quot; to dump the error stack without exiting the program. As can be seen, your code becomes much more readable if you import the error reporting functions into your main name space.<div class="spacer">
</div>
I can not emphasize the need to check for error enough. Use these functions even in the most simple programs, they will reduce debugging time greatly. Do not ask questions on the mailing list without having first sprinkled these in your code.</div>
<div class="subsection">
<h2>Sockets</h2> Perl uses file handles for all I/O. While SSLeay has a quite flexible BIO mechanism and perl has an evolved PerlIO mechanism, this module still sticks to using file descriptors. Thus to attach SSLeay to a socket you should use &quot;fileno()&quot; to extract the underlying file descriptor:<div class="spacer">
</div>
<br/>
    Net::SSLeay::set_fd($ssl, fileno(S));   # Must use fileno<br/>
<div class="spacer">
</div>
You should also set $| to 1 to eliminate STDIO buffering so you do not get confused if you use perl I/O functions to manipulate your socket handle.<div class="spacer">
</div>
If you need to select(2) on the socket, go right ahead, but be warned that OpenSSL does some internal buffering so SSL_read does not always return data even if the socket selected for reading (just keep on selecting and trying to read). &quot;Net::SSLeay&quot; is no different from the C language OpenSSL in this respect.</div>
<div class="subsection">
<h2>Callbacks</h2> You can establish a per-context verify callback function something like this:<div class="spacer">
</div>
<br/>
        sub verify {<br/>
            my ($ok, $x509_store_ctx) = @_;<br/>
            print &quot;Verifying certificate...\n&quot;;<br/>
                ...<br/>
            return $ok;<br/>
        }<br/>
<div class="spacer">
</div>
It is used like this:<div class="spacer">
</div>
<br/>
        Net::SSLeay::set_verify ($ssl, Net::SSLeay::VERIFY_PEER, \&amp;verify);<br/>
<div class="spacer">
</div>
Per-context callbacks for decrypting private keys are implemented.<div class="spacer">
</div>
<br/>
        Net::SSLeay::CTX_set_default_passwd_cb($ctx, sub { &quot;top-secret&quot; });<br/>
        Net::SSLeay::CTX_use_PrivateKey_file($ctx, &quot;key.pem&quot;,<br/>
                                             Net::SSLeay::FILETYPE_PEM)<br/>
            or die &quot;Error reading private key&quot;;<br/>
        Net::SSLeay::CTX_set_default_passwd_cb($ctx, undef);<br/>
<div class="spacer">
</div>
If Hello Extensions are supported by your OpenSSL, a session secret callback can be set up to be called when a session secret is set by openssl.<div class="spacer">
</div>
Establish it like this:<br/>
    Net::SSLeay::set_session_secret_cb($ssl, \&amp;session_secret_cb, $somedata);<div class="spacer">
</div>
It will be called like this:<div class="spacer">
</div>
<br/>
    sub session_secret_cb<br/>
    {<br/>
        my ($secret, \@cipherlist, \$preferredcipher, $somedata) = @_;<br/>
    }<br/>
<div class="spacer">
</div>
No other callbacks are implemented. You do not need to use any callback for simple (i.e. normal) cases where the SSLeay built-in verify mechanism satisfies your needs.<div class="spacer">
</div>
It is required to reset these callbacks to undef immediately after use to prevent memory leaks, thread safety problems and crashes on exit that can occur if different threads set different callbacks.<div class="spacer">
</div>
If you want to use callback stuff, see examples/callback.pl! Its the only one I am able to make work reliably.</div>
<div class="subsection">
<h2>X509 and RAND stuff</h2> This module largely lacks interface to the X509 and RAND routines, but as I was lazy and needed them, the following kludges are implemented:<div class="spacer">
</div>
<br/>
    $x509_name = Net::SSLeay::X509_get_subject_name($x509_cert);<br/>
    $x509_name = Net::SSLeay::X509_get_issuer_name($x509_cert);<br/>
    print Net::SSLeay::X509_NAME_oneline($x509_name);<br/>
    $text = Net::SSLeay::X509_NAME_get_text_by_NID($name, $nid);<br/>
<br/>
    ($type1, $subject1, $type2, $subject2, ...) =<br/>
       Net::SSLeay::X509_get_subjectAltNames($x509_cert)<br/>
<br/>
    subjectAltName types as per x509v3.h GEN_*, for example<br/>
    GEN_DNS or GEN_IPADD which can be imported.<br/>
<br/>
    Net::SSLeay::RAND_seed($buf);   # Perlishly figures out buf size<br/>
    Net::SSLeay::RAND_bytes($buf, $num);<br/>
    Net::SSLeay::RAND_pseudo_bytes($buf, $num);<br/>
    Net::SSLeay::RAND_add($buf, $num, $entropy);<br/>
    Net::SSLeay::RAND_poll();<br/>
    Net::SSLeay::RAND_status();<br/>
    Net::SSLeay::RAND_cleanup();<br/>
    Net::SSLeay::RAND_file_name($num);<br/>
    Net::SSLeay::RAND_load_file($file_name, $how_many_bytes);<br/>
    Net::SSLeay::RAND_write_file($file_name);<br/>
    Net::SSLeay::RAND_egd($path);<br/>
    Net::SSLeay::RAND_egd_bytes($path, $bytes);<br/>
<div class="spacer">
</div>
Actually you should consider using the following helper functions:<div class="spacer">
</div>
<br/>
    print Net::SSLeay::dump_peer_certificate($ssl);<br/>
    Net::SSLeay::randomize();<br/>
</div>
<div class="subsection">
<h2>RSA interface</h2> Some RSA functions are available:<div class="spacer">
</div>
<br/>
    $rsakey = Net::SSLeay::RSA_generate_key();<br/>
    Net::SSLeay::CTX_set_tmp_rsa($ctx, $rsakey);<br/>
    Net::SSLeay::RSA_free($rsakey);<br/>
</div>
<div class="subsection">
<h2>Digests</h2> Some Digest functions are available if supported by the underlying library.  These may include MD2, MD4, MD5, and RIPEMD160:<div class="spacer">
</div>
<br/>
    $hash = Net::SSLeay::MD5($foo);<br/>
    print unpack('H*', $hash);<br/>
</div>
<div class="subsection">
<h2>BIO interface</h2> Some BIO functions are available:<div class="spacer">
</div>
<br/>
    Net::SSLeay::BIO_s_mem();<br/>
    $bio = Net::SSLeay::BIO_new(BIO_s_mem())<br/>
    $bio = Net::SSLeay::BIO_new_file($filename, $mode);<br/>
    Net::SSLeay::BIO_free($bio)<br/>
    $count = Net::SSLeay::BIO_write($data);<br/>
    $data = Net::SSLeay::BIO_read($bio);<br/>
    $data = Net::SSLeay::BIO_read($bio, $maxbytes);<br/>
    $is_eof = Net::SSLeay::BIO_eof($bio);<br/>
    $count = Net::SSLeay::BIO_pending($bio);<br/>
    $count = Net::SSLeay::BIO_wpending ($bio);<br/>
</div>
<div class="subsection">
<h2>Low level API</h2> Some very low level API functions are available:<div class="spacer">
</div>
<br/>
    $client_random = Net::SSLeay::get_client_random($ssl);<br/>
    $server_random = Net::SSLeay::get_server_random($ssl);<br/>
    $session = Net::SSLeay::get_session($ssl);<br/>
    $master_key = Net::SSLeay::SESSION_get_master_key($session);<br/>
    Net::SSLeay::SESSION_set_master_key($session, $master_secret);<br/>
    $keyblocksize = Net::SSLeay::get_keyblock_size($session);<br/>
</div>
<div class="subsection">
<h2>HTTP (without S) API</h2> Over the years it has become clear that it would be convenient to use the light-weight flavour API of &quot;Net::SSLeay&quot; for normal HTTP as well (see &quot;LWP&quot; for the heavy-weight object-oriented approach). In fact it would be nice to be able to flip https on and off on the fly. Thus regular HTTP support was evolved.<div class="spacer">
</div>
<br/>
  use Net::SSLeay qw(get_http post_http tcpcat<br/>
                      get_httpx post_httpx tcpxcat<br/>
                      make_headers make_form);<br/>
<br/>
  ($page, $result, %headers) =<br/>
         = get_http('www.bacus.pt', 443, '/protected.html',<br/>
              make_headers(Authorization =&gt;<br/>
                           'Basic ' . MIME::Base64::encode(&quot;$user:$pass&quot;,''))<br/>
              );<br/>
<br/>
  ($page, $response, %reply_headers)<br/>
         = post_http('www.bacus.pt', 443, '/foo.cgi', '',<br/>
                make_form(OK   =&gt; '1',<br/>
                          name =&gt; 'Sampo'<br/>
                ));<br/>
<br/>
  ($reply, $err) = tcpcat($host, $port, $request);<br/>
<br/>
  ($page, $result, %headers) =<br/>
         = get_httpx($usessl, 'www.bacus.pt', 443, '/protected.html',<br/>
              make_headers(Authorization =&gt;<br/>
                           'Basic ' . MIME::Base64::encode(&quot;$user:$pass&quot;,''))<br/>
              );<br/>
<br/>
  ($page, $response, %reply_headers)<br/>
         = post_httpx($usessl, 'www.bacus.pt', 443, '/foo.cgi', '',<br/>
                make_form(OK   =&gt; '1',  name =&gt; 'Sampo' ));<br/>
<br/>
  ($reply, $err, $server_cert) = tcpxcat($usessl, $host, $port, $request);<br/>
<div class="spacer">
</div>
As can be seen, the &quot;x&quot; family of APIs takes as the first argument a flag which indicates whether SSL is used or not.</div>
</div>
<div class="section">
<h1>EXAMPLES</h1> One very good example to look at is the implementation of &quot;sslcat()&quot; in the &quot;SSLeay.pm&quot; file.<div class="spacer">
</div>
The following is a simple SSLeay client (with too little error checking :-(<div class="spacer">
</div>
<br/>
    #!/usr/local/bin/perl<br/>
    use Socket;<br/>
    use Net::SSLeay qw(die_now die_if_ssl_error) ;<br/>
    Net::SSLeay::load_error_strings();<br/>
    Net::SSLeay::SSLeay_add_ssl_algorithms();<br/>
    Net::SSLeay::randomize();<br/>
<br/>
    ($dest_serv, $port, $msg) = @ARGV;      # Read command line<br/>
    $port = getservbyname ($port, 'tcp') unless $port =~ /^\d+$/;<br/>
    $dest_ip = gethostbyname ($dest_serv);<br/>
    $dest_serv_params  = sockaddr_in($port, $dest_ip);<br/>
<br/>
    socket  (S, &amp;AF_INET, &amp;SOCK_STREAM, 0)  or die &quot;socket: $!&quot;;<br/>
    connect (S, $dest_serv_params)          or die &quot;connect: $!&quot;;<br/>
    select  (S); $| = 1; select (STDOUT);   # Eliminate STDIO buffering<br/>
<br/>
    # The network connection is now open, lets fire up SSL    <br/>
<br/>
    $ctx = Net::SSLeay::CTX_new() or die_now(&quot;Failed to create SSL_CTX $!&quot;);<br/>
    Net::SSLeay::CTX_set_options($ctx, &amp;Net::SSLeay::OP_ALL)<br/>
         and die_if_ssl_error(&quot;ssl ctx set options&quot;);<br/>
    $ssl = Net::SSLeay::new($ctx) or die_now(&quot;Failed to create SSL $!&quot;);<br/>
    Net::SSLeay::set_fd($ssl, fileno(S));   # Must use fileno<br/>
    $res = Net::SSLeay::connect($ssl) and die_if_ssl_error(&quot;ssl connect&quot;);<br/>
    print &quot;Cipher `&quot; . Net::SSLeay::get_cipher($ssl) . &quot;'\n&quot;;<br/>
<br/>
    # Exchange data<br/>
<br/>
    $res = Net::SSLeay::write($ssl, $msg);  # Perl knows how long $msg is<br/>
    die_if_ssl_error(&quot;ssl write&quot;);<br/>
    CORE::shutdown S, 1;  # Half close --&gt; No more output, sends EOF to server<br/>
    $got = Net::SSLeay::read($ssl);         # Perl returns undef on failure<br/>
    die_if_ssl_error(&quot;ssl read&quot;);<br/>
    print $got;<br/>
<br/>
    Net::SSLeay::free ($ssl);               # Tear down connection<br/>
    Net::SSLeay::CTX_free ($ctx);<br/>
    close S;<br/>
<div class="spacer">
</div>
The following is a simple SSLeay echo server (non forking):<div class="spacer">
</div>
<br/>
    #!/usr/local/bin/perl -w<br/>
    use Socket;<br/>
    use Net::SSLeay qw(die_now die_if_ssl_error);<br/>
    Net::SSLeay::load_error_strings();<br/>
    Net::SSLeay::SSLeay_add_ssl_algorithms();<br/>
    Net::SSLeay::randomize();<br/>
<br/>
    $our_ip = &quot;\0\0\0\0&quot;; # Bind to all interfaces<br/>
    $port = 1235;                                                        <br/>
    $sockaddr_template = 'S n a4 x8';<br/>
    $our_serv_params = pack ($sockaddr_template, &amp;AF_INET, $port, $our_ip);<br/>
<br/>
    socket (S, &amp;AF_INET, &amp;SOCK_STREAM, 0)  or die &quot;socket: $!&quot;;<br/>
    bind (S, $our_serv_params)             or die &quot;bind:   $!&quot;;<br/>
    listen (S, 5)                          or die &quot;listen: $!&quot;;<br/>
    $ctx = Net::SSLeay::CTX_new ()         or die_now(&quot;CTX_new ($ctx): $!&quot;);<br/>
    Net::SSLeay::CTX_set_options($ctx, &amp;Net::SSLeay::OP_ALL)<br/>
         and die_if_ssl_error(&quot;ssl ctx set options&quot;);<br/>
<br/>
    # Following will ask password unless private key is not encrypted<br/>
    Net::SSLeay::CTX_use_RSAPrivateKey_file ($ctx, 'plain-rsa.pem',<br/>
                                             &amp;Net::SSLeay::FILETYPE_PEM);<br/>
    die_if_ssl_error(&quot;private key&quot;);<br/>
    Net::SSLeay::CTX_use_certificate_file ($ctx, 'plain-cert.pem',<br/>
                                           &amp;Net::SSLeay::FILETYPE_PEM);<br/>
    die_if_ssl_error(&quot;certificate&quot;);<br/>
<br/>
    while (1) {    <br/>
        print &quot;Accepting connections...\n&quot;;<br/>
        ($addr = accept (NS, S))           or die &quot;accept: $!&quot;;<br/>
        select (NS); $| = 1; select (STDOUT);  # Piping hot!<br/>
<br/>
        ($af,$client_port,$client_ip) = unpack($sockaddr_template,$addr);<br/>
        @inetaddr = unpack('C4',$client_ip);<br/>
        print &quot;$af connection from &quot; .<br/>
        join ('.', @inetaddr) . &quot;:$client_port\n&quot;;<br/>
<br/>
        # We now have a network connection, lets fire up SSLeay...<br/>
<br/>
        $ssl = Net::SSLeay::new($ctx)      or die_now(&quot;SSL_new ($ssl): $!&quot;);<br/>
        Net::SSLeay::set_fd($ssl, fileno(NS));<br/>
<br/>
        $err = Net::SSLeay::accept($ssl) and die_if_ssl_error('ssl accept');<br/>
        print &quot;Cipher `&quot; . Net::SSLeay::get_cipher($ssl) . &quot;'\n&quot;;<br/>
<br/>
        # Connected. Exchange some data.<br/>
<br/>
        $got = Net::SSLeay::read($ssl);     # Returns undef on fail<br/>
        die_if_ssl_error(&quot;ssl read&quot;);<br/>
        print &quot;Got `$got' (&quot; . length ($got) . &quot; chars)\n&quot;;<br/>
<br/>
        Net::SSLeay::write ($ssl, uc ($got)) or die &quot;write: $!&quot;;<br/>
        die_if_ssl_error(&quot;ssl write&quot;);<br/>
<br/>
        Net::SSLeay::free ($ssl);           # Tear down connection<br/>
        close NS;<br/>
    }<br/>
<div class="spacer">
</div>
Yet another echo server. This one runs from &quot;/etc/inetd.conf&quot; so it avoids all the socket code overhead. Only caveat is opening an rsa key file - it had better be without any encryption or else it will not know where to ask for the password. Note how &quot;STDIN&quot; and &quot;STDOUT&quot; are wired to SSL.<div class="spacer">
</div>
<br/>
    #!/usr/local/bin/perl<br/>
    # /etc/inetd.conf<br/>
    #    ssltst stream tcp nowait root /path/to/server.pl server.pl<br/>
    # /etc/services<br/>
    #    ssltst         1234/tcp<br/>
<br/>
    use Net::SSLeay qw(die_now die_if_ssl_error);<br/>
    Net::SSLeay::load_error_strings();<br/>
    Net::SSLeay::SSLeay_add_ssl_algorithms();<br/>
    Net::SSLeay::randomize();<br/>
<br/>
    chdir '/key/dir' or die &quot;chdir: $!&quot;;<br/>
    $| = 1;  # Piping hot!<br/>
    open LOG, &quot;&gt;&gt;/dev/console&quot; or die &quot;Can't open log file $!&quot;;<br/>
    select LOG; print &quot;server.pl started\n&quot;;<br/>
<br/>
    $ctx = Net::SSLeay::CTX_new()     or die_now &quot;CTX_new ($ctx) ($!)&quot;;<br/>
    $ssl = Net::SSLeay::new($ctx)     or die_now &quot;new ($ssl) ($!)&quot;;<br/>
    Net::SSLeay::set_options($ssl, &amp;Net::SSLeay::OP_ALL)<br/>
         and die_if_ssl_error(&quot;ssl set options&quot;);<br/>
<br/>
    # We get already open network connection from inetd, now we just<br/>
    # need to attach SSLeay to STDIN and STDOUT<br/>
    Net::SSLeay::set_rfd($ssl, fileno(STDIN));<br/>
    Net::SSLeay::set_wfd($ssl, fileno(STDOUT));<br/>
<br/>
    Net::SSLeay::use_RSAPrivateKey_file ($ssl, 'plain-rsa.pem',<br/>
                                         Net::SSLeay::FILETYPE_PEM);<br/>
    die_if_ssl_error(&quot;private key&quot;);<br/>
    Net::SSLeay::use_certificate_file ($ssl, 'plain-cert.pem',<br/>
                                       Net::SSLeay::FILETYPE_PEM);<br/>
    die_if_ssl_error(&quot;certificate&quot;);<br/>
<br/>
    Net::SSLeay::accept($ssl) and die_if_ssl_err(&quot;ssl accept: $!&quot;);<br/>
    print &quot;Cipher `&quot; . Net::SSLeay::get_cipher($ssl) . &quot;'\n&quot;;<br/>
<br/>
    $got = Net::SSLeay::read($ssl);<br/>
    die_if_ssl_error(&quot;ssl read&quot;);<br/>
    print &quot;Got `$got' (&quot; . length ($got) . &quot; chars)\n&quot;;<br/>
<br/>
    Net::SSLeay::write ($ssl, uc($got)) or die &quot;write: $!&quot;;<br/>
    die_if_ssl_error(&quot;ssl write&quot;);<br/>
<br/>
    Net::SSLeay::free ($ssl);         # Tear down the connection<br/>
    Net::SSLeay::CTX_free ($ctx);<br/>
    close LOG;<br/>
<div class="spacer">
</div>
There are also a number of example/test programs in the examples directory:<div class="spacer">
</div>
<br/>
    sslecho.pl   -  A simple server, not unlike the one above<br/>
    minicli.pl   -  Implements a client using low level SSLeay routines<br/>
    sslcat.pl    -  Demonstrates using high level sslcat utility function<br/>
    get_page.pl  -  Is a utility for getting html pages from secure servers<br/>
    callback.pl  -  Demonstrates certificate verification and callback usage<br/>
    stdio_bulk.pl       - Does SSL over Unix pipes<br/>
    ssl-inetd-serv.pl   - SSL server that can be invoked from inetd.conf<br/>
    httpd-proxy-snif.pl - Utility that allows you to see how a browser<br/>
                          sends https request to given server and what reply<br/>
                          it gets back (very educative :-)<br/>
    makecert.pl  -  Creates a self signed cert (does not use this module)<br/>
</div>
<div class="section">
<h1>LIMITATIONS</h1> &quot;Net::SSLeay::read()&quot; uses an internal buffer of 32KB, thus no single read will return more. In practice one read returns much less, usually as much as fits in one network packet. To work around this, you should use a loop like this:<div class="spacer">
</div>
<br/>
    $reply = '';<br/>
    while ($got = Net::SSLeay::read($ssl)) {<br/>
        last if print_errs('SSL_read');<br/>
        $reply .= $got;<br/>
    }<br/>
<div class="spacer">
</div>
Although there is no built-in limit in &quot;Net::SSLeay::write()&quot;, the network packet size limitation applies here as well, thus use:<div class="spacer">
</div>
<br/>
    $written = 0;<br/>
<br/>
    while ($written &lt; length($message)) {<br/>
        $written += Net::SSLeay::write($ssl, substr($message, $written));<br/>
        last if print_errs('SSL_write');<br/>
    }<br/>
<div class="spacer">
</div>
Or alternatively you can just use the following convenience functions:<div class="spacer">
</div>
<br/>
    Net::SSLeay::ssl_write_all($ssl, $message) or die &quot;ssl write failure&quot;;<br/>
    $got = Net::SSLeay::ssl_read_all($ssl) or die &quot;ssl read failure&quot;;<br/>
</div>
<div class="section">
<h1>KNOWN BUGS AND CAVEATS</h1> Autoloader emits a<div class="spacer">
</div>
<br/>
    Argument &quot;xxx&quot; isn't numeric in entersub at blib/lib/Net/SSLeay.pm'<br/>
<div class="spacer">
</div>
warning if die_if_ssl_error is made autoloadable. If you figure out why, drop me a line.<div class="spacer">
</div>
Callback set using &quot;SSL_set_verify()&quot; does not appear to work. This may well be an openssl problem (e.g. see &quot;ssl/ssl_lib.c&quot; line 1029). Try using &quot;SSL_CTX_set_verify()&quot; instead and do not be surprised if even this stops working in future versions.<div class="spacer">
</div>
Callback and certificate verification stuff is generally too little tested.<div class="spacer">
</div>
Random numbers are not initialized randomly enough, especially if you do not have &quot;/dev/random&quot; and/or &quot;/dev/urandom&quot; (such as in Solaris platforms - but I've been suggested that cryptorand daemon from the SUNski package solves this). In this case you should investigate third party software that can emulate these devices, e.g. by way of a named pipe to some program.<div class="spacer">
</div>
Another gotcha with random number initialization is randomness depletion. This phenomenon, which has been extensively discussed in OpenSSL, Apache-SSL, and Apache-mod_ssl forums, can cause your script to block if you use &quot;/dev/random&quot; or to operate insecurely if you use &quot;/dev/urandom&quot;. What happens is that when too much randomness is drawn from the operating system's randomness pool then randomness can temporarily be unavailable. &quot;/dev/random&quot; solves this problem by waiting until enough randomness can be gathered - and this can take a long time since blocking reduces activity in the machine and less activity provides less random events: a vicious circle. &quot;/dev/urandom&quot; solves this dilemma more pragmatically by simply returning predictable &quot;random&quot; numbers. Some&quot; /dev/urandom&quot; emulation software however actually seems to implement &quot;/dev/random&quot; semantics. Caveat emptor.<div class="spacer">
</div>
I've been pointed to two such daemons by Mik Firestone &lt;mik@@speed.stdio._com&gt; who has used them on Solaris 8:<dl>
<dt>
1.</dt>
<dd>
Entropy Gathering Daemon (EGD) at &lt;http://www.lothar.com/tech/crypto/&gt;</dd>
</dl>
<dl>
<dt>
2.</dt>
<dd>
Pseudo-random number generating daemon (PRNGD) at http://www.aet.tu-cottbus.de/personen/jaenicke/postfix_tls/prngd.html &lt;http://www.aet.tu-cottbus.de/personen/jaenicke/postfix_tls/prngd.html&gt;</dd>
</dl>
<div class="spacer">
</div>
If you are using the low level API functions to communicate with other SSL implementations, you would do well to call<div class="spacer">
</div>
<br/>
    Net::SSLeay::CTX_set_options($ctx, &amp;Net::SSLeay::OP_ALL)<br/>
         and die_if_ssl_error(&quot;ssl ctx set options&quot;);<br/>
<div class="spacer">
</div>
to cope with some well know bugs in some other SSL implementations. The high level API functions always set all known compatibility options.<div class="spacer">
</div>
Sometimes &quot;sslcat()&quot; (and the high level HTTPS functions that build on it) is too fast in signaling the EOF to legacy HTTPS servers. This causes the server to return empty page. To work around this problem you can set the global variable<div class="spacer">
</div>
<br/>
    $Net::SSLeay::slowly = 1;   # Add sleep so broken servers can keep up<br/>
<div class="spacer">
</div>
HTTP/1.1 is not supported. Specifically this module does not know to issue or serve multiple http requests per connection. This is a serious shortcoming, but using the SSL session cache on your server helps to alleviate the CPU load somewhat.<div class="spacer">
</div>
As of version 1.09 many newer OpenSSL auxiliary functions were added (from &quot;REM_AUTOMATICALLY_GENERATED_1_09&quot; onwards in &quot;SSLeay.xs&quot;). Unfortunately I have not had any opportunity to test these. Some of them are trivial enough that I believe they &quot;just work&quot;, but others have rather complex interfaces with function pointers and all. In these cases you should proceed wit great caution.<div class="spacer">
</div>
This module defaults to using OpenSSL automatic protocol negotiation code for automatically detecting the version of the SSL protocol that the other end talks. With most web servers this works just fine, but once in a while I get complaints from people that the module does not work with some web servers. Usually this can be solved by explicitly setting the protocol version, e.g.<div class="spacer">
</div>
<br/>
   $Net::SSLeay::ssl_version = 2;  # Insist on SSLv2<br/>
   $Net::SSLeay::ssl_version = 3;  # Insist on SSLv3<br/>
   $Net::SSLeay::ssl_version = 10; # Insist on TLSv1<br/>
<div class="spacer">
</div>
Although the autonegotiation is nice to have, the SSL standards do not formally specify any such mechanism. Most of the world has accepted the SSLeay/OpenSSL way of doing it as the de facto standard. But for the few that think differently, you have to explicitly speak the correct version. This is not really a bug, but rather a deficiency in the standards. If a site refuses to respond or sends back some nonsensical error codes (at the SSL handshake level), try this option before mailing me.<div class="spacer">
</div>
On some systems, OpenSSL may be compiled without support for SSLv2. If this is the case, Net::SSLeay will warn if ssl_version has been set to 2.<div class="spacer">
</div>
The high level API returns the certificate of the peer, thus allowing one to check what certificate was supplied. However, you will only be able to check the certificate after the fact, i.e. you already sent your form data by the time you find out that you did not trust them, oops.<div class="spacer">
</div>
So, while being able to know the certificate after the fact is surely useful, the security minded would still choose to do the connection and certificate verification first and only then exchange data with the site. Currently none of the high level API functions do this, thus you would have to program it using the low level API. A good place to start is to see how the &quot;Net::SSLeay::http_cat()&quot; function is implemented.<div class="spacer">
</div>
The high level API functions use a global file handle &quot;SSLCAT_S&quot; internally. This really should not be a problem because there is no way to interleave the high level API functions, unless you use threads (but threads are not very well supported in perl anyway (as of version 5.6.1). However, you may run into problems if you call undocumented internal functions in an interleaved fashion. The best solution is to &quot;require Net::SSLeay&quot; in one thread after all the threads have been created.</div>
<div class="section">
<h1>DIAGNOSTICS</h1><dl>
<dt>
Random number generator not seeded!!!</dt>
<dd>
<b>(W)</b> This warning indicates that &quot;randomize()&quot; was not able to read &quot;/dev/random&quot; or &quot;/dev/urandom&quot;, possibly because your system does not have them or they are differently named. You can still use SSL, but the encryption will not be as strong.</dd>
</dl>
<dl>
<dt>
open_tcp_connection: destination host not found:`server' (port 123) ($!)</dt>
<dd>
Name lookup for host named &quot;server&quot; failed.</dd>
</dl>
<dl>
<dt>
open_tcp_connection: failed `server', 123 ($!)</dt>
<dd>
The name was resolved, but establising the TCP connection failed.</dd>
</dl>
<dl>
<dt>
msg 123: 1 - error:140770F8:SSL routines:SSL23_GET_SERVER_HELLO:unknown proto</dt>
<dd>
SSLeay error string. The first number (123) is the PID, the second number (1) indicates the position of the error message in SSLeay error stack. You often see a pile of these messages as errors cascade.</dd>
</dl>
<dl>
<dt>
msg 123: 1 - <i>error:02001002::lib</i>(2) :<i>func</i>(1) :<i>reason</i>(2)</dt>
<dd>
The same as above, but you didn't call <i>load_error_strings()</i> so SSLeay couldn't verbosely explain the error. You can still find out what it means with this command:<div style="height: 1.00em;">
&#160;</div>
<br/>
    /usr/local/ssl/bin/ssleay errstr 02001002<br/>
</dd>
</dl>
<dl>
<dt>
Password is being asked for private key</dt>
<dd>
This is normal behaviour if your private key is encrypted. Either you have to supply the password or you have to use an unencrypted private key. Scan OpenSSL.org for the FAQ that explains how to do this (or just study examples/makecert.pl which is used during &quot;make test&quot; to do just that).</dd>
</dl>
</div>
<div class="section">
<h1>BUGS AND SUPPORT</h1> Please report any bugs or feature requests to &quot;bug-Net-SSLeay at rt.cpan.org&quot;, or through the web interface at http://rt.cpan.org/Public/Dist/Display.html?Name=Net-SSLeay &lt;http://rt.cpan.org/Public/Dist/Display.html?Name=Net-SSLeay&gt;. I will be notified, and then you'll automatically be notified of progress on your bug as I make changes.<div class="spacer">
</div>
Subversion access to the latest source code etc can be obtained at http://alioth.debian.org/projects/net-ssleay &lt;http://alioth.debian.org/projects/net-ssleay&gt;<div class="spacer">
</div>
The developer mailing list (for people interested in contributing to the source code) can be found at http://lists.alioth.debian.org/mailman/listinfo/net-ssleay-devel &lt;http://lists.alioth.debian.org/mailman/listinfo/net-ssleay-devel&gt;<div class="spacer">
</div>
You can find documentation for this module with the &quot;perldoc&quot; command.<div class="spacer">
</div>
<br/>
    perldoc Net::SSLeay<br/>
<div class="spacer">
</div>
You can also look for information at:<dl>
<dt>
&#8226;</dt>
<dd>
AnnoCPAN: Annotated CPAN documentation<div style="height: 1.00em;">
&#160;</div>
http://annocpan.org/dist/Net-SSLeay &lt;http://annocpan.org/dist/Net-SSLeay&gt;</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
CPAN Ratings<div style="height: 1.00em;">
&#160;</div>
http://cpanratings.perl.org/d/Net-SSLeay &lt;http://cpanratings.perl.org/d/Net-SSLeay&gt;</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Search CPAN<div style="height: 1.00em;">
&#160;</div>
http://search.cpan.org/dist/Net-SSLeay &lt;http://search.cpan.org/dist/Net-SSLeay&gt;</dd>
</dl>
<div class="spacer">
</div>
Commercial support for Net::SSLeay may be obtained from<div class="spacer">
</div>
<br/>
   Symlabs (netssleay@symlabs.com)<br/>
   Tel: +351-214.222.630<br/>
   Fax: +351-214.222.637<br/>
</div>
<div class="section">
<h1>AUTHOR</h1> Maintained by Mike McCauley and Florian Ragwitz since November 2005<div class="spacer">
</div>
Originally written by Sampo Kellomaeki &lt;sampo@symlabs.com&gt;</div>
<div class="section">
<h1>COPYRIGHT</h1> Copyright (c) 1996-2003 Sampo Kellomaeki &lt;sampo@symlabs.com&gt;<div class="spacer">
</div>
Copyright (C) 2005-2006 Florian Ragwitz &lt;rafl@debian.org&gt;<div class="spacer">
</div>
Copyright (C) 2005 Mike McCauley &lt;mikem@open.com.au&gt;<div class="spacer">
</div>
All Rights Reserved.<div class="spacer">
</div>
Distribution and use of this module is under the same terms as the OpenSSL package itself (i.e. free, but mandatory attribution; NO WARRANTY). Please consult LICENSE file in the root of the OpenSSL distribution.<div class="spacer">
</div>
While the source distribution of this perl module does not contain Eric's or OpenSSL's code, if you use this module you will use OpenSSL library. Please give Eric and OpenSSL team credit (as required by their licenses).<div class="spacer">
</div>
And remember, you, and nobody else but you, are responsible for auditing this module and OpenSSL library for security problems, backdoors, and general suitability for your application.</div>
<div class="section">
<h1>SEE ALSO</h1><br/>
  Net::SSLeay::Handle                      - File handle interface<br/>
  ./examples                               - Example servers and a clients<br/>
  &lt;http://www.openssl.org/&gt;                - OpenSSL source, documentation, etc<br/>
  openssl-users-request@openssl.org        - General OpenSSL mailing list<br/>
  &lt;http://www.ietf.org/rfc/rfc2246.txt&gt;    - TLS 1.0 specification<br/>
  &lt;http://www.w3c.org&gt;                     - HTTP specifications<br/>
  &lt;http://www.ietf.org/rfc/rfc2617.txt&gt;    - How to send password<br/>
  &lt;http://www.lothar.com/tech/crypto/&gt;     - Entropy Gathering Daemon (EGD)<br/>
  &lt;http://www.aet.tu-cottbus.de/personen/jaenicke/postfix_tls/prngd.html&gt;<br/>
                           - pseudo-random number generating daemon (PRNGD)<br/>
  perl(1)<br/>
  perlref(1)<br/>
  perllol(1)<br/>
  perldoc ~openssl/doc/ssl/SSL_CTX_set_verify.pod<br/>
</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-11-15</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

