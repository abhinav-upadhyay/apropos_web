<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Pod::Simple::Subclassing(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Pod::Simple::Subclassing(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
Pod::Simple::Subclassing(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Pod::Simple::Subclassing -- write a formatter as a Pod::Simple subclass</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
  package Pod::SomeFormatter;<br/>
  use Pod::Simple;<br/>
  @ISA = qw(Pod::Simple);<br/>
  $VERSION = '1.01';<br/>
  use strict;<br/>
<br/>
  sub _handle_element_start {<br/>
    my($parser, $element_name, $attr_hash_r) = @_;<br/>
    ...<br/>
  }<br/>
<br/>
  sub _handle_element_end {<br/>
    my($parser, $element_name) = @_;<br/>
    ...<br/>
  }<br/>
<br/>
  sub _handle_text {<br/>
    my($parser, $text) = @_;<br/>
    ...<br/>
  }<br/>
  1;<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> This document is about using Pod::Simple to write a Pod processor, generally a Pod formatter. If you just want to know about using an existing Pod formatter, instead see its documentation and see also the docs in Pod::Simple.<div class="spacer">
</div>
The zeroeth step in writing a Pod formatter is to make sure that there isn't already a decent one in CPAN. See &lt;http://search.cpan.org/&gt;, and run a search on the name of the format you want to render to. Also consider joining the Pod People list http://lists.perl.org/showlist.cgi?name=pod-people &lt;http://lists.perl.org/showlist.cgi?name=pod-people&gt; and asking whether anyone has a formatter for that format -- maybe someone cobbled one together but just hasn't released it.<div class="spacer">
</div>
The first step in writing a Pod processor is to read perlpodspec, which contains notes information on writing a Pod parser (which has been largely taken care of by Pod::Simple), but also a lot of requirements and recommendations for writing a formatter.<div class="spacer">
</div>
The second step is to actually learn the format you're planning to format to -- or at least as much as you need to know to represent Pod, which probably isn't much.<div class="spacer">
</div>
The third step is to pick which of Pod::Simple's interfaces you want to use -- the basic interface via Pod::Simple or Pod::Simple::Methody is event-based, sort of like HTML::Parser's interface, or sort of like XML::Parser's &quot;Handlers&quot; interface), but Pod::Simple::PullParser provides a token-stream interface, sort of like HTML::TokeParser's interface; Pod::Simple::SimpleTree provides a simple tree interface, rather like XML::Parser's &quot;Tree&quot; interface. Users familiar with XML-handling will find one of these styles relatively familiar; but if you would be even more at home with XML, there are classes that produce an XML representation of the Pod stream, notably Pod::Simple::XMLOutStream; you can feed the output of such a class to whatever XML parsing system you are most at home with.<div class="spacer">
</div>
The last step is to write your code based on how the events (or tokens, or tree-nodes, or the XML, or however you're parsing) will map to constructs in the output format. Also sure to consider how to escape text nodes containing arbitrary text, and also what to do with text nodes that represent preformatted text (from verbatim sections).</div>
<div class="section">
<h1>Events</h1> TODO intro... mention that events are supplied for implicits, like for missing &gt;'s<div class="spacer">
</div>
In the following section, we use XML to represent the event structure associated with a particular construct.  That is, TODO<dl>
<dt>
&quot;$parser-&gt;_handle_element_start( <i>element_name</i>, <i>attr_hashref</i> )&quot;</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
&quot;$parser-&gt;_handle_element_end( <i>element_name</i>  )&quot;</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
&quot;$parser-&gt;_handle_text(  <i>text_string</i>  )&quot;</dt>
<dd>
</dd>
</dl>
<div class="spacer">
</div>
TODO describe<dl>
<dt>
events with an element_name of Document</dt>
<dd>
Parsing a document produces this event structure:<div style="height: 1.00em;">
&#160;</div>
<br/>
  &lt;Document start_line=&quot;543&quot;&gt;<br/>
    ...all events...<br/>
  &lt;/Document&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
The value of the <i>start_line</i> attribute will be the line number of the first Pod directive in the document.<div style="height: 1.00em;">
&#160;</div>
If there is no Pod in the given document, then the event structure will be this:<div style="height: 1.00em;">
&#160;</div>
<br/>
  &lt;Document contentless=&quot;1&quot; start_line=&quot;543&quot;&gt;<br/>
  &lt;/Document&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
In that case, the value of the <i>start_line</i> attribute will not be meaningful; under current implementations, it will probably be the line number of the last line in the file.</dd>
</dl>
<dl>
<dt>
events with an element_name of Para</dt>
<dd>
Parsing a plain (non-verbatim, non-directive, non-data) paragraph in a Pod document produces this event structure:<div style="height: 1.00em;">
&#160;</div>
<br/>
    &lt;Para start_line=&quot;543&quot;&gt;<br/>
      ...all events in this paragraph...<br/>
    &lt;/Para&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
The value of the <i>start_line</i> attribute will be the line number of the start of the paragraph.<div style="height: 1.00em;">
&#160;</div>
For example, parsing this paragraph of Pod:<div style="height: 1.00em;">
&#160;</div>
<br/>
  The value of the I&lt;start_line&gt; attribute will be the<br/>
  line number of the start of the paragraph.<br/>
<div style="height: 1.00em;">
&#160;</div>
produces this event structure:<div style="height: 1.00em;">
&#160;</div>
<br/>
    &lt;Para start_line=&quot;129&quot;&gt;<br/>
      The value of the <br/>
      &lt;I&gt;<br/>
        start_line<br/>
      &lt;/I&gt;<br/>
       attribute will be the line number of the first Pod directive<br/>
      in the document.<br/>
    &lt;/Para&gt;<br/>
</dd>
</dl>
<dl>
<dt>
events with an element_name of B, C, F, or I.</dt>
<dd>
Parsing a B&lt;...&gt; formatting code (or of course any of its semantically identical syntactic variants B&lt;&lt;&#160;...&#160;&gt;&gt;, or B&lt;&lt;&lt;&lt;&#160;...&#160;&gt;&gt;&gt;&gt;, etc.) produces this event structure:<div style="height: 1.00em;">
&#160;</div>
<br/>
      &lt;B&gt;<br/>
        ...stuff...<br/>
      &lt;/B&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
Currently, there are no attributes conveyed.<div style="height: 1.00em;">
&#160;</div>
Parsing C, F, or I codes produce the same structure, with only a different element name.<div style="height: 1.00em;">
&#160;</div>
If your parser object has been set to accept other formatting codes, then they will be presented like these B/C/F/I codes -- i.e., without any attributes.</dd>
</dl>
<dl>
<dt>
events with an element_name of S</dt>
<dd>
Normally, parsing an S&lt;...&gt; sequence produces this event structure, just as if it were a B/C/F/I code:<div style="height: 1.00em;">
&#160;</div>
<br/>
      &lt;S&gt;<br/>
        ...stuff...<br/>
      &lt;/S&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
However, Pod::Simple (and presumably all derived parsers) offers the &quot;nbsp_for_S&quot; option which, if enabled, will suppress all S events, and instead change all spaces in the content to non-breaking spaces. This is intended for formatters that output to a format that has no code that means the same as S&lt;...&gt;, but which has a code/character that means non-breaking space.</dd>
</dl>
<dl>
<dt>
events with an element_name of X</dt>
<dd>
Normally, parsing an X&lt;...&gt; sequence produces this event structure, just as if it were a B/C/F/I code:<div style="height: 1.00em;">
&#160;</div>
<br/>
      &lt;X&gt;<br/>
        ...stuff...<br/>
      &lt;/X&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
However, Pod::Simple (and presumably all derived parsers) offers the &quot;nix_X_codes&quot; option which, if enabled, will suppress all X events and ignore their content.  For formatters/processors that don't use X events, this is presumably quite useful.</dd>
</dl>
<dl>
<dt>
events with an element_name of L</dt>
<dd>
Because the L&lt;...&gt; is the most complex construct in the language, it should not surprise you that the events it generates are the most complex in the language. Most of complexity is hidden away in the attribute values, so for those of you writing a Pod formatter that produces a non-hypertextual format, you can just ignore the attributes and treat an L event structure like a formatting element that (presumably) doesn't actually produce a change in formatting.  That is, the content of the L event structure (as opposed to its attributes) is always what text should be displayed.<div style="height: 1.00em;">
&#160;</div>
There are, at first glance, three kinds of L links: URL, man, and pod.<div style="height: 1.00em;">
&#160;</div>
When a L&lt;<i>some_url</i>&gt; code is parsed, it produces this event structure:<div style="height: 1.00em;">
&#160;</div>
<br/>
  &lt;L content-implicit=&quot;yes&quot; to=&quot;that_url&quot; type=&quot;url&quot;&gt;<br/>
    that_url<br/>
  &lt;/L&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
The &quot;type=&quot;url&quot;&quot; attribute is always specified for this type of L code.<div style="height: 1.00em;">
&#160;</div>
For example, this Pod source:<div style="height: 1.00em;">
&#160;</div>
<br/>
  L&lt;http://www.perl.com/CPAN/authors/&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
produces this event structure:<div style="height: 1.00em;">
&#160;</div>
<br/>
  &lt;L content-implicit=&quot;yes&quot; to=&quot;http://www.perl.com/CPAN/authors/&quot; type=&quot;url&quot;&gt;<br/>
    http://www.perl.com/CPAN/authors/<br/>
  &lt;/L&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
When a L&lt;<i>manpage(section)</i>&gt; code is parsed (and these are fairly rare and not terribly useful), it produces this event structure:<div style="height: 1.00em;">
&#160;</div>
<br/>
  &lt;L content-implicit=&quot;yes&quot; to=&quot;manpage(section)&quot; type=&quot;man&quot;&gt;<br/>
    manpage(section)<br/>
  &lt;/L&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
The &quot;type=&quot;man&quot;&quot; attribute is always specified for this type of L code.<div style="height: 1.00em;">
&#160;</div>
For example, this Pod source:<div style="height: 1.00em;">
&#160;</div>
<br/>
  L&lt;crontab(5)&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
produces this event structure:<div style="height: 1.00em;">
&#160;</div>
<br/>
  &lt;L content-implicit=&quot;yes&quot; to=&quot;crontab(5)&quot; type=&quot;man&quot;&gt;<br/>
    crontab(5)<br/>
  &lt;/L&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
In the rare cases where a man page link has a specified, that text appears in a  <i>section</i> attribute. For example, this Pod source:<div style="height: 1.00em;">
&#160;</div>
<br/>
  L&lt;crontab(5)/&quot;ENVIRONMENT&quot;&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
will produce this event structure:<div style="height: 1.00em;">
&#160;</div>
<br/>
  &lt;L content-implicit=&quot;yes&quot; section=&quot;ENVIRONMENT&quot; to=&quot;crontab(5)&quot; type=&quot;man&quot;&gt;<br/>
    &quot;ENVIRONMENT&quot; in crontab(5)<br/>
  &lt;/L&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
In the rare case where the Pod document has code like L&lt; <i>sometext</i>|<i>manpage(section)</i>&gt;, then the <i>sometext</i> will appear as the content of the element, the  <i>manpage(section)</i> text will appear only as the value of the  <i>to</i> attribute, and there will be no &quot;content-implicit=&quot;yes&quot;&quot; attribute (whose presence means that the Pod parser had to infer what text should appear as the link text -- as opposed to cases where that attribute is absent, which means that the Pod parser did  <i>not</i> have to infer the link text, because that L code explicitly specified some link text.)<div style="height: 1.00em;">
&#160;</div>
For example, this Pod source:<div style="height: 1.00em;">
&#160;</div>
<br/>
  L&lt;hell itself!|crontab(5)&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
will produce this event structure:<div style="height: 1.00em;">
&#160;</div>
<br/>
  &lt;L to=&quot;crontab(5)&quot; type=&quot;man&quot;&gt;<br/>
    hell itself!<br/>
  &lt;/L&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
The last type of L structure is for links to/within Pod documents. It is the most complex because it can have a  <i>to</i> attribute, <i>or</i> a  <i>section</i> attribute, or both. The &quot;type=&quot;pod&quot;&quot; attribute is always specified for this type of L code.<div style="height: 1.00em;">
&#160;</div>
In the most common case, the simple case of a L&lt;podpage&gt; code produces this event structure:<div style="height: 1.00em;">
&#160;</div>
<br/>
  &lt;L content-implicit=&quot;yes&quot; to=&quot;Net::Ping&quot; type=&quot;pod&quot;&gt;<br/>
    podpage<br/>
  &lt;/L&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
For example, this Pod source:<div style="height: 1.00em;">
&#160;</div>
<br/>
  L&lt;Net::Ping&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
produces this event structure:<div style="height: 1.00em;">
&#160;</div>
<br/>
  &lt;L content-implicit=&quot;yes&quot; to=&quot;Net::Ping&quot; type=&quot;pod&quot;&gt;<br/>
    Net::Ping<br/>
  &lt;/L&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
In cases where there is link-text explicitly specified, it is to be found in the content of the element (and not the attributes), just as with the L&lt; <i>sometext</i>|<i>manpage(section)</i>&gt; case discussed above.  For example, this Pod source:<div style="height: 1.00em;">
&#160;</div>
<br/>
  L&lt;Perl Error Messages|perldiag&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
produces this event structure:<div style="height: 1.00em;">
&#160;</div>
<br/>
  &lt;L to=&quot;perldiag&quot; type=&quot;pod&quot;&gt;<br/>
    Perl Error Messages<br/>
  &lt;/L&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
In cases of links to a section in the current Pod document, there is a  <i>section</i> attribute instead of a <i>to</i> attribute. For example, this Pod source:<div style="height: 1.00em;">
&#160;</div>
<br/>
  L&lt;/&quot;Member Data&quot;&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
produces this event structure:<div style="height: 1.00em;">
&#160;</div>
<br/>
  &lt;L content-implicit=&quot;yes&quot; section=&quot;Member Data&quot; type=&quot;pod&quot;&gt;<br/>
    &quot;Member Data&quot;<br/>
  &lt;/L&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
As another example, this Pod source:<div style="height: 1.00em;">
&#160;</div>
<br/>
  L&lt;the various attributes|/&quot;Member Data&quot;&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
produces this event structure:<div style="height: 1.00em;">
&#160;</div>
<br/>
  &lt;L section=&quot;Member Data&quot; type=&quot;pod&quot;&gt;<br/>
    the various attributes<br/>
  &lt;/L&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
In cases of links to a section in a different Pod document, there are both a  <i>section</i> attribute and a to attribute. For example, this Pod source:<div style="height: 1.00em;">
&#160;</div>
<br/>
  L&lt;perlsyn/&quot;Basic BLOCKs and Switch Statements&quot;&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
produces this event structure:<div style="height: 1.00em;">
&#160;</div>
<br/>
  &lt;L content-implicit=&quot;yes&quot; section=&quot;Basic BLOCKs and Switch Statements&quot; to=&quot;perlsyn&quot; type=&quot;pod&quot;&gt;<br/>
    &quot;Basic BLOCKs and Switch Statements&quot; in perlsyn<br/>
  &lt;/L&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
As another example, this Pod source:<div style="height: 1.00em;">
&#160;</div>
<br/>
  L&lt;SWITCH statements|perlsyn/&quot;Basic BLOCKs and Switch Statements&quot;&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
produces this event structure:<div style="height: 1.00em;">
&#160;</div>
<br/>
  &lt;L section=&quot;Basic BLOCKs and Switch Statements&quot; to=&quot;perlsyn&quot; type=&quot;pod&quot;&gt;<br/>
    SWITCH statements<br/>
  &lt;/L&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
Incidentally, note that we do not distinguish between these syntaxes:<div style="height: 1.00em;">
&#160;</div>
<br/>
  L&lt;/&quot;Member Data&quot;&gt;<br/>
  L&lt;&quot;Member Data&quot;&gt;<br/>
  L&lt;/Member Data&gt;<br/>
  L&lt;Member Data&gt;    [deprecated syntax]<br/>
<div style="height: 1.00em;">
&#160;</div>
That is, they all produce the same event structure, namely:<div style="height: 1.00em;">
&#160;</div>
<br/>
  &lt;L content-implicit=&quot;yes&quot; section=&quot;Member Data&quot; type=&quot;pod&quot;&gt;<br/>
    &amp;#34;Member Data&amp;#34;<br/>
  &lt;/L&gt;<br/>
</dd>
</dl>
<dl>
<dt>
events with an element_name of E or Z</dt>
<dd>
While there are Pod codes E&lt;...&gt; and Z&lt;&gt;, these  <i>do not</i> produce any E or Z events -- that is, there are no such events as E or Z.</dd>
</dl>
<dl>
<dt>
events with an element_name of Verbatim</dt>
<dd>
When a Pod verbatim paragraph (AKA &quot;codeblock&quot;) is parsed, it produces this event structure:<div style="height: 1.00em;">
&#160;</div>
<br/>
  &lt;Verbatim start_line=&quot;543&quot; xml:space=&quot;preserve&quot;&gt;<br/>
    ...text...<br/>
  &lt;/Verbatim&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
The value of the <i>start_line</i> attribute will be the line number of the first line of this verbatim block.  The  <i>xml:space</i> attribute is always present, and always has the value &quot;preserve&quot;.<div style="height: 1.00em;">
&#160;</div>
The text content will have tabs already expanded.</dd>
</dl>
<dl>
<dt>
events with an element_name of head1 .. head4</dt>
<dd>
When a &quot;=head1 ...&quot; directive is parsed, it produces this event structure:<div style="height: 1.00em;">
&#160;</div>
<br/>
  &lt;head1&gt;<br/>
    ...stuff...<br/>
  &lt;/head1&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
For example, a directive consisting of this:<div style="height: 1.00em;">
&#160;</div>
<br/>
  =head1 Options to C&lt;new&gt; et al.<br/>
<div style="height: 1.00em;">
&#160;</div>
will produce this event structure:<div style="height: 1.00em;">
&#160;</div>
<br/>
  &lt;head1 start_line=&quot;543&quot;&gt;<br/>
    Options to <br/>
    &lt;C&gt;<br/>
      new<br/>
    &lt;/C&gt;<br/>
     et al.<br/>
  &lt;/head1&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
&quot;=head2&quot; thru &quot;=head4&quot; directives are the same, except for the element names in the event structure.</dd>
</dl>
<dl>
<dt>
events with an element_name of over-bullet</dt>
<dd>
When an &quot;=over ... =back&quot; block is parsed where the items are a bulleted list, it will produce this event structure:<div style="height: 1.00em;">
&#160;</div>
<br/>
  &lt;over-bullet indent=&quot;4&quot; start_line=&quot;543&quot;&gt;<br/>
    &lt;item-bullet start_line=&quot;545&quot;&gt;<br/>
      ...Stuff...<br/>
    &lt;/item-bullet&gt;<br/>
    ...more item-bullets...<br/>
  &lt;/over-bullet&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
The value of the <i>indent</i> attribute is whatever value is after the &quot;=over&quot; directive, as in &quot;=over 8&quot;.  If no such value is specified in the directive, then the  <i>indent</i> attribute has the value &quot;4&quot;.<div style="height: 1.00em;">
&#160;</div>
For example, this Pod source:<div style="height: 1.00em;">
&#160;</div>
<br/>
  =over<br/>
<br/>
  =item *<br/>
<br/>
  Stuff<br/>
<br/>
  =item *<br/>
<br/>
  Bar I&lt;baz&gt;!<br/>
<br/>
  =back<br/>
<div style="height: 1.00em;">
&#160;</div>
produces this event structure:<div style="height: 1.00em;">
&#160;</div>
<br/>
  &lt;over-bullet indent=&quot;4&quot; start_line=&quot;10&quot;&gt;<br/>
    &lt;item-bullet start_line=&quot;12&quot;&gt;<br/>
      Stuff<br/>
    &lt;/item-bullet&gt;<br/>
    &lt;item-bullet start_line=&quot;14&quot;&gt;<br/>
      Bar &lt;I&gt;baz&lt;/I&gt;!<br/>
    &lt;/item-bullet&gt;<br/>
  &lt;/over-bullet&gt;<br/>
</dd>
</dl>
<dl>
<dt>
events with an element_name of over-number</dt>
<dd>
When an &quot;=over ... =back&quot; block is parsed where the items are a numbered list, it will produce this event structure:<div style="height: 1.00em;">
&#160;</div>
<br/>
  &lt;over-number indent=&quot;4&quot; start_line=&quot;543&quot;&gt;<br/>
    &lt;item-number number=&quot;1&quot; start_line=&quot;545&quot;&gt;<br/>
      ...Stuff...<br/>
    &lt;/item-number&gt;<br/>
    ...more item-number...<br/>
  &lt;/over-bullet&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
This is like the &quot;over-bullet&quot; event structure; but note that the contents are &quot;item-number&quot; instead of &quot;item-bullet&quot;, and note that they will have a &quot;number&quot; attribute, which some formatters/processors may ignore (since, for example, there's no need for it in HTML when producing an &quot;&lt;UL&gt;&lt;LI&gt;...&lt;/LI&gt;...&lt;/UL&gt;&quot; structure), but which any processor may use.<div style="height: 1.00em;">
&#160;</div>
Note that the values for the <i>number</i> attributes of &quot;item-number&quot; elements in a given &quot;over-number&quot; area  <i>will</i> start at 1 and go up by one each time.  If the Pod source doesn't follow that order (even though it really should should!), whatever numbers it has will be ignored (with the correct values being put in the  <i>number</i> attributes), and an error message might be issued to the user.</dd>
</dl>
<dl>
<dt>
events with an element_name of over-text</dt>
<dd>
These events are are somewhat unlike the other over-* structures, as far as what their contents are.  When an &quot;=over ... =back&quot; block is parsed where the items are a list of text &quot;subheadings&quot;, it will produce this event structure:<div style="height: 1.00em;">
&#160;</div>
<br/>
  &lt;over-text indent=&quot;4&quot; start_line=&quot;543&quot;&gt;<br/>
    &lt;item-text&gt;<br/>
      ...stuff...<br/>
    &lt;/item-text&gt;<br/>
    ...stuff (generally Para or Verbatim elements)...<br/>
    &lt;item-text&gt;<br/>
    ...more item-text and/or stuff...<br/>
  &lt;/over-text&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
The <i>indent</i> attribute is as with the other over-* events.<div style="height: 1.00em;">
&#160;</div>
For example, this Pod source:<div style="height: 1.00em;">
&#160;</div>
<br/>
  =over<br/>
<br/>
  =item Foo<br/>
<br/>
  Stuff<br/>
<br/>
  =item Bar I&lt;baz&gt;!<br/>
<br/>
  Quux<br/>
<br/>
  =back<br/>
<div style="height: 1.00em;">
&#160;</div>
produces this event structure:<div style="height: 1.00em;">
&#160;</div>
<br/>
  &lt;over-text indent=&quot;4&quot; start_line=&quot;20&quot;&gt;<br/>
    &lt;item-text start_line=&quot;22&quot;&gt;<br/>
      Foo<br/>
    &lt;/item-text&gt;<br/>
    &lt;Para start_line=&quot;24&quot;&gt;<br/>
      Stuff<br/>
    &lt;/Para&gt;<br/>
    &lt;item-text start_line=&quot;26&quot;&gt;<br/>
      Bar<br/>
        &lt;I&gt;<br/>
          baz<br/>
        &lt;/I&gt;<br/>
      !<br/>
    &lt;/item-text&gt;<br/>
    &lt;Para start_line=&quot;28&quot;&gt;<br/>
      Quux<br/>
    &lt;/Para&gt;<br/>
  &lt;/over-text&gt;<br/>
</dd>
</dl>
<dl>
<dt>
events with an element_name of over-block</dt>
<dd>
These events are are somewhat unlike the other over-* structures, as far as what their contents are.  When an &quot;=over ... =back&quot; block is parsed where there are no items, it will produce this event structure:<div style="height: 1.00em;">
&#160;</div>
<br/>
  &lt;over-block indent=&quot;4&quot; start_line=&quot;543&quot;&gt;<br/>
    ...stuff (generally Para or Verbatim elements)...<br/>
  &lt;/over-block&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
The <i>indent</i> attribute is as with the other over-* events.<div style="height: 1.00em;">
&#160;</div>
For example, this Pod source:<div style="height: 1.00em;">
&#160;</div>
<br/>
  =over<br/>
<br/>
  For cutting off our trade with all parts of the world<br/>
<br/>
  For transporting us beyond seas to be tried for pretended offenses<br/>
<br/>
  He is at this time transporting large armies of foreign mercenaries to<br/>
  complete the works of death, desolation and tyranny, already begun with<br/>
  circumstances of cruelty and perfidy scarcely paralleled in the most<br/>
  barbarous ages, and totally unworthy the head of a civilized nation.<br/>
<br/>
  =cut<br/>
<div style="height: 1.00em;">
&#160;</div>
will produce this event structure:<div style="height: 1.00em;">
&#160;</div>
<br/>
  &lt;over-block indent=&quot;4&quot; start_line=&quot;2&quot;&gt;<br/>
    &lt;Para start_line=&quot;4&quot;&gt;<br/>
      For cutting off our trade with all parts of the world<br/>
    &lt;/Para&gt;<br/>
    &lt;Para start_line=&quot;6&quot;&gt;<br/>
      For transporting us beyond seas to be tried for pretended offenses<br/>
    &lt;/Para&gt;<br/>
    &lt;Para start_line=&quot;8&quot;&gt;<br/>
      He is at this time transporting large armies of [...more text...]<br/>
    &lt;/Para&gt;<br/>
  &lt;/over-block&gt;<br/>
</dd>
</dl>
<dl>
<dt>
events with an element_name of item-bullet</dt>
<dd>
See &quot;events with an element_name of over-bullet&quot;, above.</dd>
</dl>
<dl>
<dt>
events with an element_name of item-number</dt>
<dd>
See &quot;events with an element_name of over-number&quot;, above.</dd>
</dl>
<dl>
<dt>
events with an element_name of item-text</dt>
<dd>
See &quot;events with an element_name of over-text&quot;, above.</dd>
</dl>
<dl>
<dt>
events with an element_name of for</dt>
<dd>
TODO...</dd>
</dl>
<dl>
<dt>
events with an element_name of Data</dt>
<dd>
TODO...</dd>
</dl>
</div>
<div class="section">
<h1>More Pod::Simple Methods</h1> Pod::Simple provides a lot of methods that aren't generally interesting to the end user of an existing Pod formatter, but some of which you might find useful in writing a Pod formatter. They are listed below. The first several methods (the accept_* methods) are for declaring the capabilities of your parser, notably what &quot;=for  <i>targetname</i>&quot; sections it's interested in, what extra N&lt;...&gt; codes it accepts beyond the ones described in the  <i>perlpod</i>.<dl>
<dt>
&quot;$parser-&gt;accept_targets( <i>SOMEVALUE</i> )&quot;</dt>
<dd>
As the parser sees sections like:<div style="height: 1.00em;">
&#160;</div>
<br/>
    =for html  &lt;img src=&quot;fig1.jpg&quot;&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
or<div style="height: 1.00em;">
&#160;</div>
<br/>
    =begin html<br/>
<br/>
      &lt;img src=&quot;fig1.jpg&quot;&gt;<br/>
<br/>
    =end html<br/>
<div style="height: 1.00em;">
&#160;</div>
...the parser will ignore these sections unless your subclass has specified that it wants to see sections targetted to &quot;html&quot; (or whatever the formatter name is).<div style="height: 1.00em;">
&#160;</div>
If you want to process all sections, even if they're not targetted for you, call this before you start parsing:<div style="height: 1.00em;">
&#160;</div>
<br/>
  $parser-&gt;accept_targets('*');<br/>
</dd>
</dl>
<dl>
<dt>
&quot;$parser-&gt;accept_targets_as_text(  <i>SOMEVALUE</i>  )&quot;</dt>
<dd>
This is like accept_targets, except that it specifies also that the content of sections for this target should be treated as Pod text even if the target name in &quot;=for  <i>targetname</i>&quot; doesn't start with a &quot;:&quot;.<div style="height: 1.00em;">
&#160;</div>
At time of writing, I don't think you'll need to use this.</dd>
</dl>
<dl>
<dt>
&quot;$parser-&gt;accept_codes( <i>Codename</i>, <i>Codename</i>...  )&quot;</dt>
<dd>
This tells the parser that you accept additional formatting codes, beyond just the standard ones (I B C L F S X, plus the two weird ones you don't actually see in the parse tree, Z and E). For example, to also accept codes &quot;N&quot;, &quot;R&quot;, and &quot;W&quot;:<div style="height: 1.00em;">
&#160;</div>
<br/>
    $parser-&gt;accept_codes( qw( N R W ) );<br/>
<div style="height: 1.00em;">
&#160;</div>
<b>TODO: document how this interacts with =extend, and long element names</b></dd>
</dl>
<dl>
<dt>
&quot;$parser-&gt;accept_directive_as_data( <i>directive_name</i> )&quot;</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
&quot;$parser-&gt;accept_directive_as_verbatim( <i>directive_name</i> )&quot;</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
&quot;$parser-&gt;accept_directive_as_processed( <i>directive_name</i> )&quot;</dt>
<dd>
In the unlikely situation that you need to tell the parser that you will accept additional directives (&quot;=foo&quot; things), you need to first set the parset to treat its content as data (i.e., not really processed at all), or as verbatim (mostly just expanding tabs), or as processed text (parsing formatting codes like B&lt;...&gt;).<div style="height: 1.00em;">
&#160;</div>
For example, to accept a new directive &quot;=method&quot;, you'd presumably use:<div style="height: 1.00em;">
&#160;</div>
<br/>
    $parser-&gt;accept_directive_as_processed(&quot;method&quot;);<br/>
<div style="height: 1.00em;">
&#160;</div>
so that you could have Pod lines like:<div style="height: 1.00em;">
&#160;</div>
<br/>
    =method I&lt;$whatever&gt; thing B&lt;um&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
Making up your own directives breaks compatibility with other Pod formatters, in a way that using &quot;=for  <i>target</i> ...&quot; lines doesn't; however, you may find this useful if you're making a Pod superset format where you don't need to worry about compatibility.</dd>
</dl>
<dl>
<dt>
&quot;$parser-&gt;nbsp_for_S( <i>BOOLEAN</i> );&quot;</dt>
<dd>
Setting this attribute to a true value (and by default it is false) will turn &quot;S&lt;...&gt;&quot; sequences into sequences of words separated by &quot;\xA0&quot; (non-breaking space) characters. For example, it will take this:<div style="height: 1.00em;">
&#160;</div>
<br/>
    I like S&lt;Dutch apple pie&gt;, don't you?<br/>
<div style="height: 1.00em;">
&#160;</div>
and treat it as if it were:<div style="height: 1.00em;">
&#160;</div>
<br/>
    I like DutchE&lt;nbsp&gt;appleE&lt;nbsp&gt;pie, don't you?<br/>
<div style="height: 1.00em;">
&#160;</div>
This is handy for output formats that don't have anything quite like an &quot;S&lt;...&gt;&quot; code, but which do have a code for non-breaking space.<div style="height: 1.00em;">
&#160;</div>
There is currently no method for going the other way; but I can probably provide one upon request.</dd>
</dl>
<dl>
<dt>
&quot;$parser-&gt;version_report()&quot;</dt>
<dd>
This returns a string reporting the $VERSION value from your module (and its classname) as well as the $VERSION value of Pod::Simple.  Note that perlpodspec requires output formats (wherever possible) to note this detail in a comment in the output format.  For example, for some kind of SGML output format:<div style="height: 1.00em;">
&#160;</div>
<br/>
    print OUT &quot;&lt;!-- \n&quot;, $parser-&gt;version_report, &quot;\n --&gt;&quot;;<br/>
</dd>
</dl>
<dl>
<dt>
&quot;$parser-&gt;pod_para_count()&quot;</dt>
<dd>
This returns the count of Pod paragraphs seen so far.</dd>
</dl>
<dl>
<dt>
&quot;$parser-&gt;line_count()&quot;</dt>
<dd>
This is the current line number being parsed. But you might find the &quot;line_number&quot; event attribute more accurate, when it is present.</dd>
</dl>
<dl>
<dt>
&quot;$parser-&gt;nix_X_codes(  <i>SOMEVALUE</i>  )&quot;</dt>
<dd>
This attribute, when set to a true value (and it is false by default) ignores any &quot;X&lt;...&gt;&quot; sequences in the document being parsed. Many formats don't actually use the content of these codes, so have no reason to process them.</dd>
</dl>
<dl>
<dt>
&quot;$parser-&gt;merge_text(  <i>SOMEVALUE</i>  )&quot;</dt>
<dd>
This attribute, when set to a true value (and it is false by default) makes sure that only one event (or token, or node) will be created for any single contiguous sequence of text.  For example, consider this somewhat contrived example:<div style="height: 1.00em;">
&#160;</div>
<br/>
    I just LOVE Z&lt;&gt;hotE&lt;32&gt;apple pie!<br/>
<div style="height: 1.00em;">
&#160;</div>
When that is parsed and events are about to be called on it, it may actually seem to be four different text events, one right after another: one event for &quot;I just LOVE &quot;, one for &quot;hot&quot;, one for &quot; &quot;, and one for &quot;apple pie!&quot;. But if you have merge_text on, then you're guaranteed that it will be fired as one text event:  &quot;I just LOVE hot apple pie!&quot;.</dd>
</dl>
<dl>
<dt>
&quot;$parser-&gt;code_handler(  <i>CODE_REF</i>  )&quot;</dt>
<dd>
This specifies code that should be called when a code line is seen (i.e., a line outside of the Pod).  Normally this is undef, meaning that no code should be called.  If you provide a routine, it should start out like this:<div style="height: 1.00em;">
&#160;</div>
<br/>
    sub get_code_line {  # or whatever you'll call it<br/>
      my($line, $line_number, $parser) = @_;<br/>
      ...<br/>
    }<br/>
<div style="height: 1.00em;">
&#160;</div>
Note, however, that sometimes the Pod events aren't processed in exactly the same order as the code lines are -- i.e., if you have a file with Pod, then code, then more Pod, sometimes the code will be processed (via whatever you have code_handler call) before the all of the preceding Pod has been processed.</dd>
</dl>
<dl>
<dt>
&quot;$parser-&gt;cut_handler(  <i>CODE_REF</i>  )&quot;</dt>
<dd>
This is just like the code_handler attribute, except that it's for &quot;=cut&quot; lines, not code lines. The same caveats apply. &quot;=cut&quot; lines are unlikely to be interesting, but this is included for completeness.</dd>
</dl>
<dl>
<dt>
&quot;$parser-&gt;whine( <i>linenumber</i>, <i>complaint string</i> )&quot;</dt>
<dd>
This notes a problem in the Pod, which will be reported to in the &quot;Pod Errors&quot; section of the document and/or send to STDERR, depending on the values of the attributes &quot;no_whining&quot;, &quot;no_errata_section&quot;, and &quot;complain_stderr&quot;.</dd>
</dl>
<dl>
<dt>
&quot;$parser-&gt;scream( <i>linenumber</i>, <i>complaint string</i> )&quot;</dt>
<dd>
This notes an error like &quot;whine&quot; does, except that it is not suppressible with &quot;no_whining&quot;. This should be used only for very serious errors.</dd>
</dl>
<dl>
<dt>
&quot;$parser-&gt;source_dead(1)&quot;</dt>
<dd>
This aborts parsing of the current document, by switching on the flag that indicates that EOF has been seen.  In particularly drastic cases, you might want to do this.  It's rather nicer than just calling &quot;die&quot;!</dd>
</dl>
<dl>
<dt>
&quot;$parser-&gt;hide_line_numbers( <i>SOMEVALUE</i> )&quot;</dt>
<dd>
Some subclasses that indiscriminately dump event attributes (well, except for ones beginning with &quot;~&quot;) can use this object attribute for refraining to dump the &quot;start_line&quot; attribute.</dd>
</dl>
<dl>
<dt>
&quot;$parser-&gt;no_whining( <i>SOMEVALUE</i> )&quot;</dt>
<dd>
This attribute, if set to true, will suppress reports of non-fatal error messages.  The default value is false, meaning that complaints  <i>are</i> reported.  How they get reported depends on the values of the attributes &quot;no_errata_section&quot; and &quot;complain_stderr&quot;.</dd>
</dl>
<dl>
<dt>
&quot;$parser-&gt;no_errata_section( <i>SOMEVALUE</i> )&quot;</dt>
<dd>
This attribute, if set to true, will suppress generation of an errata section.  The default value is false -- i.e., an errata section will be generated.</dd>
</dl>
<dl>
<dt>
&quot;$parser-&gt;complain_stderr( <i>SOMEVALUE</i> )&quot;</dt>
<dd>
This attribute, if set to true will send complaints to STDERR.  The default value is false -- i.e., complaints do not go to STDERR.</dd>
</dl>
<dl>
<dt>
&quot;$parser-&gt;bare_output( <i>SOMEVALUE</i> )&quot;</dt>
<dd>
Some formatter subclasses use this as a flag for whether output should have prologue and epilogue code omitted. For example, setting this to true for an HTML formatter class should omit the &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;...&lt;/title&gt;&lt;body&gt;...&quot; prologue and the &quot;&lt;/body&gt;&lt;/html&gt;&quot; epilogue.<div style="height: 1.00em;">
&#160;</div>
If you want to set this to true, you should probably also set &quot;no_whining&quot; or at least &quot;no_errata_section&quot; to true.</dd>
</dl>
<dl>
<dt>
&quot;$parser-&gt;preserve_whitespace( <i>SOMEVALUE</i> )&quot;</dt>
<dd>
If you set this attribute to a true value, the parser will try to preserve whitespace in the output.  This means that such formatting conventions as two spaces after periods will be preserved by the parser. This is primarily useful for output formats that treat whitespace as significant (such as text or *roff, but not HTML).</dd>
</dl>
</div>
<div class="section">
<h1>SEE ALSO</h1> Pod::Simple -- event-based Pod-parsing framework<div class="spacer">
</div>
Pod::Simple::Methody -- like Pod::Simple, but each sort of event calls its own method (like &quot;start_head3&quot;)<div class="spacer">
</div>
Pod::Simple::PullParser -- a Pod-parsing framework like Pod::Simple, but with a token-stream interface<div class="spacer">
</div>
Pod::Simple::SimpleTree -- a Pod-parsing framework like Pod::Simple, but with a tree interface<div class="spacer">
</div>
Pod::Simple::Checker -- a simple Pod::Simple subclass that reads documents, and then makes a plaintext report of any errors found in the document<div class="spacer">
</div>
Pod::Simple::DumpAsXML -- for dumping Pod documents as tidily indented XML, showing each event on its own line<div class="spacer">
</div>
Pod::Simple::XMLOutStream -- dumps a Pod document as XML (without introducing extra whitespace as Pod::Simple::DumpAsXML does).<div class="spacer">
</div>
Pod::Simple::DumpAsText -- for dumping Pod documents as tidily indented text, showing each event on its own line<div class="spacer">
</div>
Pod::Simple::LinkSection -- class for objects representing the values of the TODO and TODO attributes of L&lt;...&gt; elements<div class="spacer">
</div>
Pod::Escapes -- the module the Pod::Simple uses for evaluating E&lt;...&gt; content<div class="spacer">
</div>
Pod::Simple::Text -- a simple plaintext formatter for Pod<div class="spacer">
</div>
Pod::Simple::TextContent -- like Pod::Simple::Text, but makes no effort for indent or wrap the text being formatted<div class="spacer">
</div>
Pod::Simple::HTML -- a simple HTML formatter for Pod<div class="spacer">
</div>
perlpod<div class="spacer">
</div>
perlpodspec<div class="spacer">
</div>
perldoc</div>
<div class="section">
<h1>SUPPORT</h1> Questions or discussion about POD and Pod::Simple should be sent to the pod-people@perl.org mail list. Send an empty email to pod-people-subscribe@perl.org to subscribe.<div class="spacer">
</div>
This module is managed in an open GitHub repository, http://github.com/theory/pod-simple/ &lt;http://github.com/theory/pod-simple/&gt;. Feel free to fork and contribute, or to clone git://github.com/theory/pod-simple.git &lt;git://github.com/theory/pod-simple.git&gt; and send patches!<div class="spacer">
</div>
Patches against Pod::Simple are welcome. Please send bug reports to &lt;bug-pod-simple@rt.cpan.org&gt;.</div>
<div class="section">
<h1>COPYRIGHT AND DISCLAIMERS</h1> Copyright (c) 2002 Sean M. Burke.<div class="spacer">
</div>
This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.<div class="spacer">
</div>
This program is distributed in the hope that it will be useful, but without any warranty; without even the implied warranty of merchantability or fitness for a particular purpose.</div>
<div class="section">
<h1>AUTHOR</h1> Pod::Simple was created by Sean M. Burke &lt;sburke@cpan.org&gt;. But don't bother him, he's retired.<div class="spacer">
</div>
Pod::Simple is maintained by:<dl>
<dt>
&#8226;</dt>
<dd>
Allison Randal &quot;allison@perl.org&quot;</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Hans Dieter Pearcey &quot;hdp@cpan.org&quot;</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
David E. Wheeler &quot;dwheeler@cpan.org&quot;</dd>
</dl>
</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-09-26</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

