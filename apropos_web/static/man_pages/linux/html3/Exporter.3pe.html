<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Exporter(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Exporter(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
Exporter(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Exporter - Implements default import method for modules</div>
<div class="section">
<h1>SYNOPSIS</h1> In module  <i>YourModule.pm</i>:<div class="spacer">
</div>
<br/>
  package YourModule;<br/>
  require Exporter;<br/>
  @ISA = qw(Exporter);<br/>
  @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request<br/>
<div class="spacer">
</div>
or<div class="spacer">
</div>
<br/>
  package YourModule;<br/>
  use Exporter 'import'; # gives you Exporter's import() method directly<br/>
  @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request<br/>
<div class="spacer">
</div>
In other files which wish to use &quot;YourModule&quot;:<div class="spacer">
</div>
<br/>
  use YourModule qw(frobnicate);      # import listed symbols<br/>
  frobnicate ($left, $right)          # calls YourModule::frobnicate<br/>
<div class="spacer">
</div>
Take a look at &quot;Good Practices&quot; for some variants you will like to use in modern Perl code.</div>
<div class="section">
<h1>DESCRIPTION</h1> The Exporter module implements an &quot;import&quot; method which allows a module to export functions and variables to its users' namespaces. Many modules use Exporter rather than implementing their own &quot;import&quot; method because Exporter provides a highly flexible interface, with an implementation optimised for the common case.<div class="spacer">
</div>
Perl automatically calls the &quot;import&quot; method when processing a &quot;use&quot; statement for a module. Modules and &quot;use&quot; are documented in perlfunc and perlmod. Understanding the concept of modules and how the &quot;use&quot; statement operates is important to understanding the Exporter.<div class="subsection">
<h2>How to Export</h2> The arrays @EXPORT and @EXPORT_OK in a module hold lists of symbols that are going to be exported into the users name space by default, or which they can request to be exported, respectively.  The symbols can represent functions, scalars, arrays, hashes, or typeglobs. The symbols must be given by full name with the exception that the ampersand in front of a function is optional, e.g.<div class="spacer">
</div>
<br/>
    @EXPORT    = qw(afunc $scalar @array);   # afunc is a function<br/>
    @EXPORT_OK = qw(&amp;bfunc %hash *typeglob); # explicit prefix on &amp;bfunc<br/>
<div class="spacer">
</div>
If you are only exporting function names it is recommended to omit the ampersand, as the implementation is faster this way.</div>
<div class="subsection">
<h2>Selecting What To Export</h2> Do  <b>not</b> export method names!<div class="spacer">
</div>
Do <b>not</b> export anything else by default without a good reason!<div class="spacer">
</div>
Exports pollute the namespace of the module user.  If you must export try to use @EXPORT_OK in preference to @EXPORT and avoid short or common symbol names to reduce the risk of name clashes.<div class="spacer">
</div>
Generally anything not exported is still accessible from outside the module using the &quot;YourModule::item_name&quot; (or &quot;$blessed_ref-&gt;method&quot;) syntax.  By convention you can use a leading underscore on names to informally indicate that they are 'internal' and not for public use.<div class="spacer">
</div>
(It is actually possible to get private functions by saying:<div class="spacer">
</div>
<br/>
  my $subref = sub { ... };<br/>
  $subref-&gt;(@args);            # Call it as a function<br/>
  $obj-&gt;$subref(@args);        # Use it as a method<br/>
<div class="spacer">
</div>
However if you use them for methods it is up to you to figure out how to make inheritance work.)<div class="spacer">
</div>
As a general rule, if the module is trying to be object oriented then export nothing. If it's just a collection of functions then @EXPORT_OK anything but use @EXPORT with caution. For function and method names use barewords in preference to names prefixed with ampersands for the export lists.<div class="spacer">
</div>
Other module design guidelines can be found in perlmod.</div>
<div class="subsection">
<h2>How to Import</h2> In other files which wish to use your module there are three basic ways for them to load your module and import its symbols:<dl>
<dt>
&quot;use YourModule;&quot;</dt>
<dd>
This imports all the symbols from YourModule's @EXPORT into the namespace of the &quot;use&quot; statement.</dd>
</dl>
<dl>
<dt>
&quot;use YourModule ();&quot;</dt>
<dd>
This causes perl to load your module but does not import any symbols.</dd>
</dl>
<dl>
<dt>
&quot;use YourModule qw(...);&quot;</dt>
<dd>
This imports only the symbols listed by the caller into their namespace. All listed symbols must be in your @EXPORT or @EXPORT_OK, else an error occurs. The advanced export features of Exporter are accessed like this, but with list entries that are syntactically distinct from symbol names.</dd>
</dl>
<div class="spacer">
</div>
Unless you want to use its advanced features, this is probably all you need to know to use Exporter.</div>
</div>
<div class="section">
<h1>Advanced features</h1><div class="subsection">
<h2>Specialised Import Lists</h2> If any of the entries in an import list begins with !, : or / then the list is treated as a series of specifications which either add to or delete from the list of names to import. They are processed left to right. Specifications are in the form:<div class="spacer">
</div>
<br/>
    [!]name         This name only<br/>
    [!]:DEFAULT     All names in @EXPORT<br/>
    [!]:tag         All names in $EXPORT_TAGS{tag} anonymous list<br/>
    [!]/pattern/    All names in @EXPORT and @EXPORT_OK which match<br/>
<div class="spacer">
</div>
A leading ! indicates that matching names should be deleted from the list of names to import.  If the first specification is a deletion it is treated as though preceded by :DEFAULT. If you just want to import extra names in addition to the default set you will still need to include :DEFAULT explicitly.<div class="spacer">
</div>
e.g., <i>Module.pm</i> defines:<div class="spacer">
</div>
<br/>
    @EXPORT      = qw(A1 A2 A3 A4 A5);<br/>
    @EXPORT_OK   = qw(B1 B2 B3 B4 B5);<br/>
    %EXPORT_TAGS = (T1 =&gt; [qw(A1 A2 B1 B2)], T2 =&gt; [qw(A1 A2 B3 B4)]);<br/>
<br/>
    Note that you cannot use tags in @EXPORT or @EXPORT_OK.<br/>
    Names in EXPORT_TAGS must also appear in @EXPORT or @EXPORT_OK.<br/>
<div class="spacer">
</div>
An application using Module can say something like:<div class="spacer">
</div>
<br/>
    use Module qw(:DEFAULT :T2 !B3 A3);<br/>
<div class="spacer">
</div>
Other examples include:<div class="spacer">
</div>
<br/>
    use Socket qw(!/^[AP]F_/ !SOMAXCONN !SOL_SOCKET);<br/>
    use POSIX  qw(:errno_h :termios_h !TCSADRAIN !/^EXIT/);<br/>
<div class="spacer">
</div>
Remember that most patterns (using //) will need to be anchored with a leading ^, e.g., &quot;/^EXIT/&quot; rather than &quot;/EXIT/&quot;.<div class="spacer">
</div>
You can say &quot;BEGIN { $Exporter::Verbose=1 }&quot; to see how the specifications are being processed and what is actually being imported into modules.</div>
<div class="subsection">
<h2>Exporting without using Exporter's import method</h2> Exporter has a special method, 'export_to_level' which is used in situations where you can't directly call Exporter's import method. The export_to_level method looks like:<div class="spacer">
</div>
<br/>
    MyPackage-&gt;export_to_level($where_to_export, $package, @what_to_export);<br/>
<div class="spacer">
</div>
where $where_to_export is an integer telling how far up the calling stack to export your symbols, and @what_to_export is an array telling what symbols *to* export (usually this is @_).  The $package argument is currently unused.<div class="spacer">
</div>
For example, suppose that you have a module, A, which already has an import function:<div class="spacer">
</div>
<br/>
    package A;<br/>
<br/>
    @ISA = qw(Exporter);<br/>
    @EXPORT_OK = qw ($b);<br/>
<br/>
    sub import<br/>
    {<br/>
        $A::b = 1;     # not a very useful import method<br/>
    }<br/>
<div class="spacer">
</div>
and you want to Export symbol $A::b back to the module that called package A. Since Exporter relies on the import method to work, via inheritance, as it stands  <i>Exporter::import()</i> will never get called. Instead, say the following:<div class="spacer">
</div>
<br/>
    package A;<br/>
    @ISA = qw(Exporter);<br/>
    @EXPORT_OK = qw ($b);<br/>
<br/>
    sub import<br/>
    {<br/>
        $A::b = 1;<br/>
        A-&gt;export_to_level(1, @_);<br/>
    }<br/>
<div class="spacer">
</div>
This will export the symbols one level 'above' the current package - ie: to the program or module that used package A.<div class="spacer">
</div>
Note: Be careful not to modify @_ at all before you call export_to_level - or people using your package will get very unexplained results!</div>
<div class="subsection">
<h2>Exporting without inheriting from Exporter</h2> By including Exporter in your @ISA you inherit an Exporter's  <i>import()</i> method but you also inherit several other helper methods which you probably don't want. To avoid this you can do<div class="spacer">
</div>
<br/>
  package YourModule;<br/>
  use Exporter qw( import );<br/>
<div class="spacer">
</div>
which will export Exporter's own <i>import()</i> method into YourModule. Everything will work as before but you won't need to include Exporter in @YourModule::ISA.<div class="spacer">
</div>
Note: This feature was introduced in version 5.57 of Exporter, released with perl 5.8.3.</div>
<div class="subsection">
<h2>Module Version Checking</h2> The Exporter module will convert an attempt to import a number from a module into a call to &quot;$module_name-&gt;require_version($value)&quot;. This can be used to validate that the version of the module being used is greater than or equal to the required version.<div class="spacer">
</div>
The Exporter module supplies a default &quot;require_version&quot; method which checks the value of $VERSION in the exporting module.<div class="spacer">
</div>
Since the default &quot;require_version&quot; method treats the $VERSION number as a simple numeric value it will regard version 1.10 as lower than 1.9. For this reason it is strongly recommended that you use numbers with at least two decimal places, e.g., 1.09.</div>
<div class="subsection">
<h2>Managing Unknown Symbols</h2> In some situations you may want to prevent certain symbols from being exported. Typically this applies to extensions which have functions or constants that may not exist on some systems.<div class="spacer">
</div>
The names of any symbols that cannot be exported should be listed in the @EXPORT_FAIL array.<div class="spacer">
</div>
If a module attempts to import any of these symbols the Exporter will give the module an opportunity to handle the situation before generating an error. The Exporter will call an export_fail method with a list of the failed symbols:<div class="spacer">
</div>
<br/>
  @failed_symbols = $module_name-&gt;export_fail(@failed_symbols);<br/>
<div class="spacer">
</div>
If the &quot;export_fail&quot; method returns an empty list then no error is recorded and all the requested symbols are exported. If the returned list is not empty then an error is generated for each symbol and the export fails. The Exporter provides a default &quot;export_fail&quot; method which simply returns the list unchanged.<div class="spacer">
</div>
Uses for the &quot;export_fail&quot; method include giving better error messages for some symbols and performing lazy architectural checks (put more symbols into @EXPORT_FAIL by default and then take them out if someone actually tries to use them and an expensive check shows that they are usable on that platform).</div>
<div class="subsection">
<h2>Tag Handling Utility Functions</h2> Since the symbols listed within %EXPORT_TAGS must also appear in either @EXPORT or @EXPORT_OK, two utility functions are provided which allow you to easily add tagged sets of symbols to @EXPORT or @EXPORT_OK:<div class="spacer">
</div>
<br/>
  %EXPORT_TAGS = (foo =&gt; [qw(aa bb cc)], bar =&gt; [qw(aa cc dd)]);<br/>
<br/>
  Exporter::export_tags('foo');     # add aa, bb and cc to @EXPORT<br/>
  Exporter::export_ok_tags('bar');  # add aa, cc and dd to @EXPORT_OK<br/>
<div class="spacer">
</div>
Any names which are not tags are added to @EXPORT or @EXPORT_OK unchanged but will trigger a warning (with &quot;-w&quot;) to avoid misspelt tags names being silently added to @EXPORT or @EXPORT_OK. Future versions may make this a fatal error.</div>
<div class="subsection">
<h2>Generating combined tags</h2> If several symbol categories exist in %EXPORT_TAGS, it's usually useful to create the utility &quot;:all&quot; to simplify &quot;use&quot; statements.<div class="spacer">
</div>
The simplest way to do this is:<div class="spacer">
</div>
<br/>
  %EXPORT_TAGS = (foo =&gt; [qw(aa bb cc)], bar =&gt; [qw(aa cc dd)]);<br/>
<br/>
  # add all the other &quot;:class&quot; tags to the &quot;:all&quot; class,<br/>
  # deleting duplicates<br/>
  {<br/>
    my %seen;<br/>
<br/>
    push @{$EXPORT_TAGS{all}},<br/>
      grep {!$seen{$_}++} @{$EXPORT_TAGS{$_}} foreach keys %EXPORT_TAGS;<br/>
  }<br/>
<div class="spacer">
</div>
<i>CGI.pm</i> creates an &quot;:all&quot; tag which contains some (but not really all) of its categories.  That could be done with one small change:<div class="spacer">
</div>
<br/>
  # add some of the other &quot;:class&quot; tags to the &quot;:all&quot; class,<br/>
  # deleting duplicates<br/>
  {<br/>
    my %seen;<br/>
<br/>
    push @{$EXPORT_TAGS{all}},<br/>
      grep {!$seen{$_}++} @{$EXPORT_TAGS{$_}}<br/>
        foreach qw/html2 html3 netscape form cgi internal/;<br/>
  }<br/>
<div class="spacer">
</div>
Note that the tag names in %EXPORT_TAGS don't have the leading ':'.</div>
<div class="subsection">
<h2>&quot;AUTOLOAD&quot;ed Constants</h2> Many modules make use of &quot;AUTOLOAD&quot;ing for constant subroutines to avoid having to compile and waste memory on rarely used values (see perlsub for details on constant subroutines).  Calls to such constant subroutines are not optimized away at compile time because they can't be checked at compile time for constancy.<div class="spacer">
</div>
Even if a prototype is available at compile time, the body of the subroutine is not (it hasn't been &quot;AUTOLOAD&quot;ed yet). perl needs to examine both the &quot;()&quot; prototype and the body of a subroutine at compile time to detect that it can safely replace calls to that subroutine with the constant value.<div class="spacer">
</div>
A workaround for this is to call the constants once in a &quot;BEGIN&quot; block:<div class="spacer">
</div>
<br/>
   package My ;<br/>
<br/>
   use Socket ;<br/>
<br/>
   foo( SO_LINGER );     ## SO_LINGER NOT optimized away; called at runtime<br/>
   BEGIN { SO_LINGER }<br/>
   foo( SO_LINGER );     ## SO_LINGER optimized away at compile time.<br/>
<div class="spacer">
</div>
This forces the &quot;AUTOLOAD&quot; for &quot;SO_LINGER&quot; to take place before SO_LINGER is encountered later in &quot;My&quot; package.<div class="spacer">
</div>
If you are writing a package that &quot;AUTOLOAD&quot;s, consider forcing an &quot;AUTOLOAD&quot; for any constants explicitly imported by other packages or which are usually used when your package is &quot;use&quot;d.</div>
</div>
<div class="section">
<h1>Good Practices</h1><div class="subsection">
<h2>Declaring @EXPORT_OK and Friends</h2> When using &quot;Exporter&quot; with the standard &quot;strict&quot; and &quot;warnings&quot; pragmas, the &quot;our&quot; keyword is needed to declare the package variables @EXPORT_OK, @EXPORT, @ISA, etc.<div class="spacer">
</div>
<br/>
  our @ISA = qw(Exporter);<br/>
  our @EXPORT_OK = qw(munge frobnicate);<br/>
<div class="spacer">
</div>
If backward compatibility for Perls under 5.6 is important, one must write instead a &quot;use vars&quot; statement.<div class="spacer">
</div>
<br/>
  use vars qw(@ISA @EXPORT_OK);<br/>
  @ISA = qw(Exporter);<br/>
  @EXPORT_OK = qw(munge frobnicate);<br/>
</div>
<div class="subsection">
<h2>Playing Safe</h2> There are some caveats with the use of runtime statements like &quot;require Exporter&quot; and the assignment to package variables, which can very subtle for the unaware programmer. This may happen for instance with mutually recursive modules, which are affected by the time the relevant constructions are executed.<div class="spacer">
</div>
The ideal (but a bit ugly) way to never have to think about that is to use &quot;BEGIN&quot; blocks. So the first part of the &quot;SYNOPSIS&quot; code could be rewritten as:<div class="spacer">
</div>
<br/>
  package YourModule;<br/>
<br/>
  use strict;<br/>
  use warnings;<br/>
<br/>
  our (@ISA, @EXPORT_OK);<br/>
  BEGIN {<br/>
     require Exporter;<br/>
     @ISA = qw(Exporter);<br/>
     @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request<br/>
  }<br/>
<div class="spacer">
</div>
The &quot;BEGIN&quot; will assure that the loading of <i>Exporter.pm</i> and the assignments to @ISA and @EXPORT_OK happen immediately, leaving no room for something to get awry or just plain wrong.<div class="spacer">
</div>
With respect to loading &quot;Exporter&quot; and inheriting, there are alternatives with the use of modules like &quot;base&quot; and &quot;parent&quot;.<div class="spacer">
</div>
<br/>
  use base qw( Exporter );<br/>
  # or<br/>
  use parent qw( Exporter );<br/>
<div class="spacer">
</div>
Any of these statements are nice replacements for &quot;BEGIN { require Exporter; @ISA = qw(Exporter); }&quot; with the same compile-time effect. The basic difference is that &quot;base&quot; code interacts with declared &quot;fields&quot; while &quot;parent&quot; is a streamlined version of the older &quot;base&quot; code to just establish the IS-A relationship.<div class="spacer">
</div>
For more details, see the documentation and code of base and parent.<div class="spacer">
</div>
Another thorough remedy to that runtime vs. compile-time trap is to use Exporter::Easy, which is a wrapper of Exporter that allows all boilerplate code at a single gulp in the use statement.<div class="spacer">
</div>
<br/>
   use Exporter::Easy (<br/>
       OK =&gt; [ qw(munge frobnicate) ],<br/>
   );<br/>
   # @ISA setup is automatic<br/>
   # all assignments happen at compile time<br/>
</div>
<div class="subsection">
<h2>What not to Export</h2> You have been warned already in &quot;Selecting What To Export&quot; to not export:<dl>
<dt>
&#8226;</dt>
<dd>
method names (because you don't need to and that's likely to not do what you want),</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
anything by default (because you don't want to surprise your users... badly)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
anything you don't need to (because less is more)</dd>
</dl>
<div class="spacer">
</div>
There's one more item to add to this list. Do <b>not</b> export variable names. Just because &quot;Exporter&quot; lets you do that, it does not mean you should.<div class="spacer">
</div>
<br/>
  @EXPORT_OK = qw( $svar @avar %hvar ); # DON'T!<br/>
<div class="spacer">
</div>
Exporting variables is not a good idea. They can change under the hood, provoking horrible effects at-a-distance, that are too hard to track and to fix. Trust me: they are not worth it.<div class="spacer">
</div>
To provide the capability to set/get class-wide settings, it is best instead to provide accessors as subroutines or class methods instead.</div>
</div>
<div class="section">
<h1>SEE ALSO</h1> &quot;Exporter&quot; is definitely not the only module with symbol exporter capabilities. At CPAN, you may find a bunch of them. Some are lighter. Some provide improved APIs and features. Peek the one that fits your needs. The following is a sample list of such modules.<div class="spacer">
</div>
<br/>
    Exporter::Easy<br/>
    Exporter::Lite<br/>
    Exporter::Renaming<br/>
    Exporter::Tidy<br/>
    Sub::Exporter / Sub::Installer<br/>
    Perl6::Export / Perl6::Export::Attrs<br/>
</div>
<div class="section">
<h1>LICENSE</h1> This library is free software. You can redistribute it and/or modify it under the same terms as Perl itself.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-09-26</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

