<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Config::Model(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Config::Model(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
Config::Model(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Config::Model - Create tools to validate, migrate and edit configuration files</div>
<div class="section">
<h1>VERSION</h1> version 2.005</div>
<div class="section">
<h1>SYNOPSIS</h1><div class="subsection">
<h2>Perl program</h2><br/>
 use Config::Model;<br/>
 use Log::Log4perl qw(:easy) ;<br/>
 Log::Log4perl-&gt;easy_init($WARN);<br/>
<br/>
 # create new Model object<br/>
 my $model = Config::Model-&gt;new() ; # Config::Model object<br/>
<br/>
 # create config model. Most users will want to store the model<br/>
 # in lib/Config/Model/models and run &quot;config-edit -model MiniModel&quot;<br/>
 # See below for details<br/>
 $model -&gt;create_config_class (<br/>
   name =&gt; &quot;MiniModel&quot;,<br/>
   element =&gt; [ [qw/foo bar baz/ ] =&gt; { type =&gt; 'leaf', value_type =&gt; 'uniline' }, ],<br/>
   read_config =&gt; { backend =&gt; 'IniFile', auto_create =&gt; 1,<br/>
                    config_dir =&gt; '.', file =&gt; 'mini.ini',<br/>
                  }<br/>
 ) ;<br/>
<br/>
 # create instance (Config::Model::Instance object)<br/>
 my $instance = $model-&gt;instance (root_class_name =&gt; 'MiniModel');<br/>
<br/>
 # get configuration tree root<br/>
 my $cfg_root = $instance -&gt; config_root ; # C::M:Node object<br/>
<br/>
 # load some dummy data<br/>
 $cfg_root -&gt; load(&quot;bar=BARV foo=FOOV baz=BAZV&quot;) ;<br/>
<br/>
 # write new ini file<br/>
 $instance -&gt; write_back;<br/>
<br/>
 # now look for new mini.ini file un current directory<br/>
</div>
<div class="subsection">
<h2>More convenient</h2><br/>
 $ mkdir -p lib/Config/Model/models/<br/>
 $ echo &quot;[ { name =&gt; 'MiniModel',<br/>
             element =&gt; [ [qw/foo bar baz/ ] =&gt; { type =&gt; 'leaf', value_type =&gt; 'uniline' }, ],<br/>
             read_config =&gt; { backend =&gt; 'IniFile', auto_create =&gt; 1,<br/>
                              config_dir =&gt; '.', file =&gt; 'mini.ini',<br/>
                            }<br/>
           }<br/>
         ] ; &quot; &gt; lib/Config/Model/models/MiniModel.pl<br/>
 $ config-edit -model MiniModel -model_dir lib/Config/Model/models/ -ui none bar=BARV foo=FOOV baz=BAZV<br/>
 $ cat mini.ini<br/>
</div>
<div class="subsection">
<h2>Look Ma, no Perl</h2><br/>
 $ echo &quot;Make sure that Config::Model::Itself is installed&quot;<br/>
 $ mkdir -p lib/Config/Model/models/<br/>
 $ config-model-edit -model MiniModel -save \<br/>
   class:MiniModel element:foo type=leaf value_type=uniline - \<br/>
                   element:bar type=leaf value_type=uniline - \<br/>
                   element:baz type=leaf value_type=uniline - \<br/>
   read_config:0 backend=IniFile file=mini.ini config_dir=. auto_create=1 - - -<br/>
 $ config-edit -model MiniModel -model_dir lib/Config/Model/models/ -ui none bar=BARV foo=FOOV baz=BAZV<br/>
 $ cat mini.ini<br/>
</div>
</div>
<div class="section">
<h1>DESCRIPTION</h1> Config::Model enables a project developer to provide an interactive configuration editor (graphical, curses based or plain terminal) to his users. For this he must:<dl>
<dt>
&#8226;</dt>
<dd>
Describe the structure and constraints of his project's configuration (fear not, a GUI is available)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Find a way to read and write configuration data using read/write backend provided by Config::Model or other Perl modules.</dd>
</dl>
<div class="spacer">
</div>
With the elements above, Config::Model will generate interactive configuration editors (with integrated help and data validation). These editors can be graphical (with Config::Model::TkUI), curses based (with Config::Model::CursesUI) or based on ReadLine.<div class="spacer">
</div>
Smaller models targeted for configuration upgrades can also be created:<dl>
<dt>
&#8226;</dt>
<dd>
only upgrade and migration specifications are required</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
unknown parameters can be accepted</dd>
</dl>
<div class="spacer">
</div>
A command line is provided to perform configuration upgrade with a single command.<div class="subsection">
<h2>How does this work ?</h2> Using this project, a typical configuration editor/validator/upgrader will be made of 3 parts :<div class="spacer">
</div>
<br/>
  GUI &lt;--------&gt; |---------------|<br/>
  CursesUI &lt;---&gt; | |---------|   |<br/>
                 | | Model   |   |<br/>
  ShellUI &lt;----&gt; | |---------|   |&lt;-----read-backend------- |-------------|<br/>
                 |               |----write-backend-------&gt; | config file |<br/>
  FuseUI &lt;-----&gt; | Config::Model |                          |-------------|<br/>
                 |---------------|<br/>
<dl>
<dt>
1.</dt>
<dd>
A reader and writer that will parse the configuration file and transform in a tree representation within Config::Model. The values contained in this configuration tree can be written back in the configuration file(s).</dd>
</dl>
<dl>
<dt>
2.</dt>
<dd>
A validation engine which is in charge of validating the content and structure of configuration stored in the configuration tree. This validation engine will follow the structure and constraint declared in a configuration model. This model is a kind of schema for the configuration tree.</dd>
</dl>
<dl>
<dt>
3.</dt>
<dd>
A user interface to modify the content of the configuration tree. A modification will be validated instantly by the validation engine.</dd>
</dl>
<div class="spacer">
</div>
The important part is the configuration model used by the validation engine. This model can be created or modified with a graphical editor (Config::Model::Iself).</div>
</div>
<div class="section">
<h1>Question you may ask yourself</h1><div class="subsection">
<h2>Don't we already have some configuration validation tools ?</h2> You're probably thinking of tools like webmin. Yes, these tools exist and work fine, but they have their set of drawbacks.<div class="spacer">
</div>
Usually, the validation of configuration data is done with a script which performs semantic validation and often ends up being quite complex (e.g. 2500 lines for Debian's xserver-xorg.config script which handles &quot;xorg.conf&quot; file).<div class="spacer">
</div>
In most cases, the configuration model is expressed in instructions (whatever programming language is used) and interspersed with a lot of processing to handle the actual configuration data.</div>
<div class="subsection">
<h2>What's the advantage of this project ?</h2> Config::Model projects provide a way to get a validation engine where the configuration model is completely separated from the actual processing instructions.<div class="spacer">
</div>
A configuration model can be created and modified with the graphical interface provide by Config::Model::Itself. The model is saved in a declarative form (currently, a Perl data structure). Such a model is easier to maintain than a lot of code.<div class="spacer">
</div>
The model specifies:<dl>
<dt>
&#8226;</dt>
<dd>
The structure of the configuration data (which can be queried by generic user interfaces)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
The properties of each element (boundaries check, integer or string, enum like type, default value ...)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
The targeted audience (beginner, advanced, master)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
The on-line help</dd>
</dl>
<div class="spacer">
</div>
So, in the end:<dl>
<dt>
&#8226;</dt>
<dd>
Maintenance and evolution of the configuration content is easier</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
User will see a *common* interface for *all* programs using this project.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Beginners will not see advanced parameters (advanced and master parameters are hidden from beginners)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Upgrade of configuration data is easier and sanity check is performed during the upgrade.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Audit of configuration is possible to check what was modified by the user compared to default values</dd>
</dl>
</div>
<div class="subsection">
<h2>What about the user interface ?</h2> Config::Model interface can be:<dl>
<dt>
&#8226;</dt>
<dd>
a shell-like interface (plain or based on Term::ReadLine).</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Graphical with Config::Model::TkUI (Perl/Tk interface).</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
based on curses with Config::Model::CursesUI. This interface can be handy if your X server is down.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Through a virtual file system where every configuration parameter is mapped to a file. (Linux only)</dd>
</dl>
<div class="spacer">
</div>
All these interfaces are generated from the configuration model.<div class="spacer">
</div>
And configuration model can be created or modified with a graphical user interface (with Config::Model::Itself)</div>
<div class="subsection">
<h2>What about configuration data storage ?</h2> Since the syntax of configuration files vary wildly form one application to another, people who want to use this framework may have to provide a dedicated parser/writer.<div class="spacer">
</div>
To help with this task, this project provides writer/parsers for common format: INI style file and perl file. With the additional Config::Model::Backend::Augeas, Augeas library can be used to read and write some configuration files. See http://augeas.net for more details.</div>
<div class="subsection">
<h2>Is there an example of a configuration model ?</h2> The &quot;example&quot; directory contains a configuration model example for &quot;/etc/fstab&quot; file. This example includes a small program that use this model to show some ways to extract configuration information.</div>
</div>
<div class="section">
<h1>Mailing lists</h1> For more question, please send a mail to:<div class="spacer">
</div>
<br/>
 config-model-users at lists.sourceforge.net<br/>
</div>
<div class="section">
<h1>Suggested reads to start</h1><div class="subsection">
<h2>Beginners</h2><dl>
<dt>
&#8226;</dt>
<dd>
Config::Model::Manual::ModelCreationIntroduction:</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Config::Model::Cookbook::CreateModelFromDoc</dd>
</dl>
</div>
<div class="subsection">
<h2>Advanced</h2><dl>
<dt>
&#8226;</dt>
<dd>
Config::Model::Manual::ModelCreationAdvanced</dd>
</dl>
</div>
<div class="subsection">
<h2>Masters</h2> use the source, Luke</div>
</div>
<div class="section">
<h1>STOP</h1> The documentation below is quite detailed and is more a reference doc regarding &quot;Config::Model&quot; class.<div class="spacer">
</div>
For an introduction to model creation, please check: http://sourceforge.net/apps/mediawiki/config-model/index.php?title=Creating_a_model &lt;http://sourceforge.net/apps/mediawiki/config-model/index.php?title=Creating_a_model&gt;<div class="spacer">
</div>
Dedicated Config::Model::Manual pages will follow soon.</div>
<div class="section">
<h1>Storage backend, configuration reader and writer</h1> See Config::Model::AutoRead for details</div>
<div class="section">
<h1>Validation engine</h1> &quot;Config::Model&quot; provides a way to get a validation engine from a set of rules. This set of rules is called the configuration model.</div>
<div class="section">
<h1>User interface</h1> The user interface will use some parts of the API to set and get configuration values. More importantly, a generic user interface will need to explore the configuration model to be able to generate at run-time relevant configuration screens.<div class="spacer">
</div>
Simple text interface if provided in this module. Curses and Tk interfaces are provided by Config::Model::CursesUI and Config::Model::TkUI.</div>
<div class="section">
<h1>Constructor</h1> Simply call new without parameters:<div class="spacer">
</div>
<br/>
 my $model = Config::Model -&gt; new ;<br/>
<div class="spacer">
</div>
This will create an empty shell for your model.</div>
<div class="section">
<h1>Configuration Model</h1> To validate a configuration tree, we must create a configuration model that will set all the properties of the validation engine you want to create.<div class="spacer">
</div>
The configuration model is expressed in a declarative form (i.e. a Perl data structure which is always easier to maintain than a lot of code)<div class="spacer">
</div>
Each configuration class contains a set of:<dl>
<dt>
&#8226;</dt>
<dd>
node element that will refer to another configuration class</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
value element that will contains actual configuration data</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
List or hash of node or value elements</dd>
</dl>
<div class="spacer">
</div>
By declaring a set of configuration classes and referring them in node element, you will shape the structure of your configuration tree.<div class="spacer">
</div>
The structure of the configuration data must be based on a tree structure. This structure has several advantages:<dl>
<dt>
&#8226;</dt>
<dd>
Unique path to get to a node or a leaf.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Simpler exploration and query</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Simple hierarchy. Deletion of configuration items is simpler to grasp: when you cut a branch, all the leaves attaches to that branch go down.</dd>
</dl>
<div class="spacer">
</div>
But using a tree has also some drawbacks:<dl>
<dt>
&#8226;</dt>
<dd>
A complex configuration cannot be mapped on a simple tree.  Some more relation between nodes and leaves must be added.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Some configuration part are actually graph instead of a tree (for instance, any configuration that will map a service to a resource). The graph relation must be decomposed in a tree with special  <i>reference</i> relation. See &quot;Value Reference&quot; in Config::Model::Value</dd>
</dl>
<div class="spacer">
</div>
Note: a configuration tree is a tree of objects. The model is declared with classes. The classes themselves have relations that closely match the relation of the object of the configuration tree. But the class need not to be declared in a tree structure (always better to reuse classes). But they must be declared as a DAG (directed acyclic graph).<div class="spacer">
</div>
Each configuration class declaration specifies:<dl>
<dt>
&#8226;</dt>
<dd>
The &quot;name&quot; of the class (mandatory)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
A &quot;class_description&quot; used in user interfaces (optional)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Optional include specification to avoid duplicate declaration of elements.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
The class elements</dd>
</dl>
<div class="spacer">
</div>
Each element will specify:<dl>
<dt>
&#8226;</dt>
<dd>
Most importantly, the type of the element (mostly &quot;leaf&quot;, or &quot;node&quot;)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
The properties of each element (boundaries, check, integer or string, enum like type ...)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
The default values of parameters (if any)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Whether the parameter is mandatory</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Targeted audience (beginner, advance, master), i.e. the level of expertise required to tinker a parameter (to hide expert parameters from newbie eyes)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
On-line help (for each parameter or value of parameter)</dd>
</dl>
<div class="spacer">
</div>
See Config::Model::Node for details on how to declare a configuration class.<div class="spacer">
</div>
Example:<div class="spacer">
</div>
<br/>
 $ cat lib/Config/Model/models/Xorg.pl<br/>
 [<br/>
   {<br/>
     name =&gt; 'Xorg',<br/>
     class_description =&gt; 'Top level Xorg configuration.',<br/>
     include =&gt; [ 'Xorg::ConfigDir'],<br/>
     element =&gt; [<br/>
                 Files =&gt; {<br/>
                           type =&gt; 'node',<br/>
                           description =&gt; 'File pathnames',<br/>
                           config_class_name =&gt; 'Xorg::Files'<br/>
                          },<br/>
                 # snip<br/>
                ]<br/>
   },<br/>
   {<br/>
     name =&gt; 'Xorg::DRI',<br/>
     element =&gt; [<br/>
                 Mode =&gt; {<br/>
                          type =&gt; 'leaf',<br/>
                          value_type =&gt; 'uniline',<br/>
                          description =&gt; 'DRI mode, usually set to 0666'<br/>
                         }<br/>
                ]<br/>
   }<br/>
 ];<br/>
</div>
<div class="section">
<h1>Configuration instance</h1> A configuration instance if the staring point of a configuration tree. When creating a model instance, you must specify the root class name, I.e. the configuration class that is used by the root node of the tree.<div class="spacer">
</div>
<br/>
 my $model = Config::Model-&gt;new() ;<br/>
 $model -&gt;create_config_class<br/>
  (<br/>
   name =&gt; &quot;SomeRootClass&quot;,<br/>
   element =&gt; [ ...  ]<br/>
  ) ;<br/>
<br/>
 # instance name is 'default'<br/>
 my $inst = $model-&gt;instance (root_class_name =&gt; 'SomeRootClass');<br/>
<div class="spacer">
</div>
You can create several separated instances from a model using &quot;name&quot; option:<div class="spacer">
</div>
<br/>
 # instance name is 'default'<br/>
 my $inst = $model-&gt;instance (root_class_name =&gt; 'SomeRootClass',<br/>
                              name            =&gt; 'test1');<br/>
<div class="spacer">
</div>
Usually, model files will be loaded automatically depending on &quot;root_class_name&quot;. But you can choose to specify the file containing the model with &quot;model_file&quot; parameter. This is mostly useful for tests.</div>
<div class="section">
<h1>Configuration class</h1> A configuration class is made of series of elements which are detailed in Config::Model::Node.<div class="spacer">
</div>
Whatever its type (node, leaf,... ), each element of a node has several other properties:<dl>
<dt>
experience</dt>
<dd>
By using the &quot;experience&quot; parameter, you can change the experience level of each element. Possible experience levels are &quot;master&quot;, &quot;advanced&quot; and &quot;beginner&quot; (default).</dd>
</dl>
<dl>
<dt>
level</dt>
<dd>
Level is &quot;important&quot;, &quot;normal&quot; or &quot;hidden&quot;.<div style="height: 1.00em;">
&#160;</div>
The level is used to set how configuration data is presented to the user in browsing mode. &quot;Important&quot; elements will be shown to the user no matter what. &quot;hidden&quot; elements will be explained with the  <i>warp</i> notion.</dd>
</dl>
<dl>
<dt>
status</dt>
<dd>
Status is &quot;obsolete&quot;, &quot;deprecated&quot; or &quot;standard&quot; (default).<div style="height: 1.00em;">
&#160;</div>
Using a deprecated element will issue a warning. Using an obsolete element will raise an exception.</dd>
</dl>
<dl>
<dt>
description</dt>
<dd>
Description of the element. This description will be used when generating user interfaces.</dd>
</dl>
<dl>
<dt>
summary</dt>
<dd>
Summary of the element. This description will be used when generating user interfaces and may be used in comments when writing the configuration file.</dd>
</dl>
<dl>
<dt>
class_description</dt>
<dd>
Description of the configuration class. This description will be used when generating user interfaces.</dd>
</dl>
<dl>
<dt>
generated_by</dt>
<dd>
Mention with a descriptive string if this class was generated by a program.  This parameter is currently reserved for Config::Model::Itself model editor.</dd>
</dl>
<dl>
<dt>
include</dt>
<dd>
Include element description from another class.<div style="height: 1.00em;">
&#160;</div>
<br/>
  include =&gt; 'AnotherClass' ,<br/>
<div style="height: 1.00em;">
&#160;</div>
or<div style="height: 1.00em;">
&#160;</div>
<br/>
  include =&gt; [qw/ClassOne ClassTwo/]<br/>
<div style="height: 1.00em;">
&#160;</div>
In a configuration class, the order of the element is important. For instance if &quot;foo&quot; is warped by &quot;bar&quot;, you must declare &quot;bar&quot; element before &quot;foo&quot;.<div style="height: 1.00em;">
&#160;</div>
When including another class, you may wish to insert the included elements after a specific element of your including class:<div style="height: 1.00em;">
&#160;</div>
<br/>
  # say AnotherClass contains element xyz<br/>
  include =&gt; 'AnotherClass' ,<br/>
  include_after =&gt; &quot;foo&quot; ,<br/>
  element =&gt; [ bar =&gt; ... , foo =&gt; ... , baz =&gt; ... ]<br/>
<div style="height: 1.00em;">
&#160;</div>
Now the element of your class will be:<div style="height: 1.00em;">
&#160;</div>
<br/>
  ( bar , foo , xyz , baz )<br/>
</dd>
</dl>
<div class="spacer">
</div>
Example:<div class="spacer">
</div>
<br/>
  my $model = Config::Model -&gt; new ;<br/>
<br/>
  $model-&gt;create_config_class<br/>
  (<br/>
   config_class_name =&gt; 'SomeRootClass',<br/>
   experience        =&gt; [ [ qw/tree_macro warp/ ] =&gt; 'advanced'] ,<br/>
   description       =&gt; [ X =&gt; 'X-ray' ],<br/>
   level             =&gt; [ 'tree_macro' =&gt; 'important' ] ,<br/>
   class_description =&gt; &quot;SomeRootClass description&quot;,<br/>
   element           =&gt; [ ... ]<br/>
  ) ;<br/>
<div class="spacer">
</div>
Again, see Config::Model::Node for more details on configuration class declaration.<div class="spacer">
</div>
For convenience, &quot;experience&quot;, &quot;level&quot; and &quot;description&quot; parameters can also be declared within the element declaration:<div class="spacer">
</div>
<br/>
  $model-&gt;create_config_class<br/>
  (<br/>
   config_class_name =&gt; 'SomeRootClass',<br/>
   class_description =&gt; &quot;SomeRootClass description&quot;,<br/>
   'element'<br/>
   =&gt; [<br/>
        tree_macro =&gt; { level =&gt; 'important',<br/>
                        experience =&gt; 'advanced',<br/>
                      },<br/>
        warp       =&gt; { experience =&gt; 'advanced', } ,<br/>
        X          =&gt; { description =&gt; 'X-ray', } ,<br/>
      ]<br/>
  ) ;<br/>
</div>
<div class="section">
<h1>Load predeclared model</h1> You can also load predeclared model.<div class="subsection">
<h2>load( &lt;model_name&gt; )</h2> This method will open the model directory and execute a &quot;.pl&quot; file containing the model declaration,<div class="spacer">
</div>
This perl file must return an array ref to declare models. E.g.:<div class="spacer">
</div>
<br/>
 [<br/>
  [<br/>
   name =&gt; 'Class_1',<br/>
   element =&gt; [ ... ]<br/>
  ],<br/>
  [<br/>
   name =&gt; 'Class_2',<br/>
   element =&gt; [ ... ]<br/>
  ]<br/>
 ];<br/>
<div class="spacer">
</div>
do not put &quot;1;&quot; at the end or &quot;load&quot; will not work<div class="spacer">
</div>
If a model name contain a &quot;::&quot; (e.g &quot;Foo::Bar&quot;), &quot;load&quot; will look for a file named &quot;Foo/Bar.pl&quot;.<div class="spacer">
</div>
This method will also look in &quot;Foo/Bar.d&quot; directory for additional model information. Model snippet found there will be loaded with augment_config_class.<div class="spacer">
</div>
Returns a list containing the names of the loaded classes. For instance, if &quot;Foo/Bar.pl&quot; contains a model for &quot;Foo::Bar&quot; and &quot;Foo::Bar2&quot;, &quot;load&quot; will return &quot;( 'Foo::Bar' , 'Foo::Bar2' )&quot;.</div>
</div>
<div class="section">
<h1>Model plugin</h1> Config::Model can also use model plugins. Each model can be augmented by model snippets stored into directory &quot;&lt;model_name&gt;.d&quot;. All files found there will be merged to existing model.<div class="spacer">
</div>
For instance, this model:<div class="spacer">
</div>
<br/>
 {<br/>
    name =&gt; &quot;Master&quot;,<br/>
    element =&gt; [<br/>
        fs_vfstype =&gt; {<br/>
            type =&gt; 'leaf',<br/>
            value_type =&gt; 'enum',<br/>
            choice =&gt; [ qw/ext2 ext3/ ],<br/>
        },<br/>
        fs_mntopts =&gt; {<br/>
            type =&gt; 'warped_node',<br/>
            follow =&gt; { 'f1' =&gt; '- fs_vfstype' },<br/>
            rules =&gt; [<br/>
                '$f1 eq \'ext2\'', { 'config_class_name' =&gt; 'Fstab::Ext2FsOpt' },<br/>
                '$f1 eq \'ext3\'', { 'config_class_name' =&gt; 'Fstab::Ext3FsOpt' }, <br/>
            ],<br/>
        }<br/>
    ]<br/>
 }<br/>
<div class="spacer">
</div>
can be augmented with:<div class="spacer">
</div>
<br/>
 {<br/>
    name =&gt; &quot;Fstab::Fsline&quot;,<br/>
    element =&gt; [<br/>
        fs_vfstype =&gt; { choice =&gt; [ qw/ext4/ ], },<br/>
        fs_mntopts =&gt; {<br/>
            rules =&gt; [<br/>
                q!$f1 eq 'ext4'!, { 'config_class_name' =&gt; 'Fstab::Ext4FsOpt' }, <br/>
            ],<br/>
        },<br/>
    ]<br/>
 } ;<br/>
<div class="spacer">
</div>
Then, the merged model will feature &quot;fs_vfstype&quot; with choice &quot;ext2 ext4 ext4&quot;. Likewise, &quot;fs_mntopts&quot; will feature rules for the 3 filesystems.<div class="subsection">
<h2>augment_config_class (name =&gt; '...', class_data )</h2> Enhance the feature of a configuration class. This method uses the same parameters as create_config_class.</div>
</div>
<div class="section">
<h1>Model query</h1><div class="subsection">
<h2>get_model( config_class_name )</h2> Return a hash containing the model declaration (in a deep clone copy of the hash). You may modify the hash at leisure.</div>
<div class="subsection">
<h2>get_model_doc</h2> Generate POD document for configuration class.</div>
<div class="subsection">
<h2>generate_doc ( top_class_name , [ directory ] )</h2> Generate POD document for configuration class top_class_name and write them on STDOUT or in specified directory.<div class="spacer">
</div>
Returns a list of written file names.</div>
<div class="subsection">
<h2>get_element_model( config_class_name , element)</h2> Return a hash containing the model declaration for the specified class and element.</div>
<div class="subsection">
<h2>get_element_name( class =&gt; Foo, for =&gt; advanced )</h2> Get all names of the elements of class &quot;Foo&quot; that are accessible for experience level &quot;advanced&quot;.<div class="spacer">
</div>
Level can be &quot;master&quot; (default), &quot;advanced&quot; or &quot;beginner&quot;.</div>
<div class="subsection">
<h2>get_element_property</h2> Returns the property of an element from the model.<div class="spacer">
</div>
Parameters are:<dl>
<dt>
class</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
element</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
property</dt>
<dd>
</dd>
</dl>
</div>
<div class="subsection">
<h2>list_class_element</h2> Returns a string listing all the class and elements. Useful for debugging your configuration model.</div>
</div>
<div class="section">
<h1>Error handling</h1> Errors are handled with an exception mechanism (See Exception::Class).<div class="spacer">
</div>
When a strongly typed Value object gets an authorized value, it raises an exception. If this exception is not caught, the programs exits.<div class="spacer">
</div>
See Config::Model::Exception for details on the various exception classes provided with &quot;Config::Model&quot;.</div>
<div class="section">
<h1>Logging</h1> See &quot;Logging&quot; in config-edit</div>
<div class="section">
<h1>BUGS</h1> Given Murphy's law, the author is fairly confident that you will find bugs or miss some features. Please report them to config-model at rt.cpan.org, or through the web interface at https://rt.cpan.org/Public/Bug/Report.html?Queue=config-model . The author will be notified, and then you'll automatically be notified of progress on your bug.</div>
<div class="section">
<h1>FEEDBACK</h1> Feedback from users are highly desired. If you find this module useful, please share your use cases, success stories with the author or with the config-model- users mailing list.</div>
<div class="section">
<h1>AUTHOR</h1> Dominique Dumont, (ddumont at cpan dot org)</div>
<div class="section">
<h1>LICENSE</h1><br/>
    Copyright (c) 2005-2012 Dominique Dumont.<br/>
<br/>
    This file is part of Config-Model.<br/>
<br/>
    Config-Model is free software; you can redistribute it and/or<br/>
    modify it under the terms of the GNU Lesser General Public License as<br/>
    published by the Free Software Foundation; either version 2.1 of<br/>
    the License, or (at your option) any later version.<br/>
<br/>
    Config-Model is distributed in the hope that it will be useful,<br/>
    but WITHOUT ANY WARRANTY; without even the implied warranty of<br/>
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU<br/>
    Lesser Public License for more details.<br/>
<br/>
    You should have received a copy of the GNU Lesser General Public License<br/>
    along with Config-Model; if not, write to the Free Software<br/>
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA<br/>
    02110-1301 USA<br/>
</div>
<div class="section">
<h1>SEE ALSO</h1> Config::Model::Instance,<div class="spacer">
</div>
http://sourceforge.net/apps/mediawiki/config-model/index.php?title=Creating_a_model &lt;http://sourceforge.net/apps/mediawiki/config-model/index.php?title=Creating_a_model&gt;<div class="subsection">
<h2>Model elements</h2> The arrow shows the inheritance of the classes<dl>
<dt>
&#8226;</dt>
<dd>
Config::Model::Node &lt;- Config::Model::AnyThing</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Config::Model::HashId &lt;- Config::Model::AnyId &lt;- Config::Model::AnyThing</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Config::Model::ListId &lt;- Config::Model::AnyId &lt;- Config::Model::AnyThing</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Config::Model::Value &lt;- Config::Model::AnyThing</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Config::Model::CheckList &lt;- Config::Model::AnyThing</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Config::Model::WarpedNode &lt;- Config::Model::AnyThing</dd>
</dl>
</div>
<div class="subsection">
<h2>command line</h2> cme. config-edit is now deprecated.</div>
<div class="subsection">
<h2>Read and write backends</h2><dl>
<dt>
&#8226;</dt>
<dd>
Config::Model::Backend::Fstab &lt;- Config::Model::Backend::Any</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Config::Model::Backend::IniFile &lt;- Config::Model::Backend::Any</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Config::Model::Backend::PlainFile &lt;- Config::Model::Backend::Any</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Config::Model::Backend::ShellVar &lt;- Config::Model::Backend::Any</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Config::Model::Backend::Yaml &lt;- Config::Model::Backend::Any</dd>
</dl>
</div>
<div class="subsection">
<h2>Model utilities</h2><dl>
<dt>
&#8226;</dt>
<dd>
Config::Model::Annotation</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Config::Model::BackendMgr: Used by &quot;Config::Model::Node&quot; object</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Config::Model::Describe</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Config::Model::Dumper</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Config::Model::DumpAsData</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Config::Model::IdElementReference</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Config::Model::Iterator</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Config::Model::Loader</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Config::Model::ObjTreeScanner</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Config::Model::Report</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Config::Model::Searcher: Search element in configuration model.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Config::Model::SimpleUI</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Config::Model::TreeSearcher: Search string or regexp in configuration tree.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Config::Model::TermUI</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Config::Model::Iterator</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Config::Model::AutoRead</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Config::Model::ValueComputer</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Config::Model::Warper</dd>
</dl>
</div>
<div class="subsection">
<h2>Test framework</h2><dl>
<dt>
&#8226;</dt>
<dd>
Config::Model::Tester</dd>
</dl>
</div>
</div>
<table class="foot">
<tr>
<td class="foot-date">
2012-02-24</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

