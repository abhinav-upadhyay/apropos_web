<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
namespace::clean(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
namespace::clean(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
namespace::clean(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> namespace::clean - Keep imports and functions out of your namespace</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
  package Foo;<br/>
  use warnings;<br/>
  use strict;<br/>
<br/>
  use Carp qw(croak);   # 'croak' will be removed<br/>
<br/>
  sub bar { 23 }        # 'bar' will be removed<br/>
<br/>
  # remove all previously defined functions<br/>
  use namespace::clean;<br/>
<br/>
  sub baz { bar() }     # 'baz' still defined, 'bar' still bound<br/>
<br/>
  # begin to collection function names from here again<br/>
  no namespace::clean;<br/>
<br/>
  sub quux { baz() }    # 'quux' will be removed<br/>
<br/>
  # remove all functions defined after the 'no' unimport<br/>
  use namespace::clean;<br/>
<br/>
  # Will print: 'No', 'No', 'Yes' and 'No'<br/>
  print +(__PACKAGE__-&gt;can('croak') ? 'Yes' : 'No'), &quot;\n&quot;;<br/>
  print +(__PACKAGE__-&gt;can('bar')   ? 'Yes' : 'No'), &quot;\n&quot;;<br/>
  print +(__PACKAGE__-&gt;can('baz')   ? 'Yes' : 'No'), &quot;\n&quot;;<br/>
  print +(__PACKAGE__-&gt;can('quux')  ? 'Yes' : 'No'), &quot;\n&quot;;<br/>
<br/>
  1;<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1><div class="subsection">
<h2>Keeping packages clean</h2> When you define a function, or import one, into a Perl package, it will naturally also be available as a method. This does not per se cause problems, but it can complicate subclassing and, for example, plugin classes that are included via multiple inheritance by loading them as base classes.<div class="spacer">
</div>
The &quot;namespace::clean&quot; pragma will remove all previously declared or imported symbols at the end of the current package's compile cycle. Functions called in the package itself will still be bound by their name, but they won't show up as methods on your class or instances.<div class="spacer">
</div>
By unimporting via &quot;no&quot; you can tell &quot;namespace::clean&quot; to start collecting functions for the next &quot;use namespace::clean;&quot; specification.<div class="spacer">
</div>
You can use the &quot;-except&quot; flag to tell &quot;namespace::clean&quot; that you don't want it to remove a certain function or method. A common use would be a module exporting an &quot;import&quot; method along with some functions:<div class="spacer">
</div>
<br/>
  use ModuleExportingImport;<br/>
  use namespace::clean -except =&gt; [qw( import )];<br/>
<div class="spacer">
</div>
If you just want to &quot;-except&quot; a single sub, you can pass it directly. For more than one value you have to use an array reference.</div>
<div class="subsection">
<h2>Explicitly removing functions when your scope is compiled</h2> It is also possible to explicitly tell &quot;namespace::clean&quot; what packages to remove when the surrounding scope has finished compiling. Here is an example:<div class="spacer">
</div>
<br/>
  package Foo;<br/>
  use strict;<br/>
<br/>
  # blessed NOT available<br/>
<br/>
  sub my_class {<br/>
      use Scalar::Util qw( blessed );<br/>
      use namespace::clean qw( blessed );<br/>
<br/>
      # blessed available<br/>
      return blessed shift;<br/>
  }<br/>
<br/>
  # blessed NOT available<br/>
</div>
<div class="subsection">
<h2>Moose</h2> When using &quot;namespace::clean&quot; together with Moose you want to keep the installed &quot;meta&quot; method. So your classes should look like:<div class="spacer">
</div>
<br/>
  package Foo;<br/>
  use Moose;<br/>
  use namespace::clean -except =&gt; 'meta';<br/>
  ...<br/>
<div class="spacer">
</div>
Same goes for Moose::Role.</div>
<div class="subsection">
<h2>Cleaning other packages</h2> You can tell &quot;namespace::clean&quot; that you want to clean up another package instead of the one importing. To do this you have to pass in the &quot;-cleanee&quot; option like this:<div class="spacer">
</div>
<br/>
  package My::MooseX::namespace::clean;<br/>
  use strict;<br/>
<br/>
  use namespace::clean (); # no cleanup, just load<br/>
<br/>
  sub import {<br/>
      namespace::clean-&gt;import(<br/>
        -cleanee =&gt; scalar(caller),<br/>
        -except  =&gt; 'meta',<br/>
      );<br/>
  }<br/>
<div class="spacer">
</div>
If you don't care about &quot;namespace::clean&quot;s discover-and-&quot;-except&quot; logic, and just want to remove subroutines, try &quot;clean_subroutines&quot;.</div>
</div>
<div class="section">
<h1>METHODS</h1><div class="subsection">
<h2>clean_subroutines</h2> This exposes the actual subroutine-removal logic.<div class="spacer">
</div>
<br/>
  namespace::clean-&gt;clean_subroutines($cleanee, qw( subA subB ));<br/>
<div class="spacer">
</div>
will remove &quot;subA&quot; and &quot;subB&quot; from $cleanee. Note that this will remove the subroutines  <b>immediately</b> and not wait for scope end. If you want to have this effect at a specific time (e.g. &quot;namespace::clean&quot; acts on scope compile end) it is your responsibility to make sure it runs at that time.</div>
<div class="subsection">
<h2>import</h2> Makes a snapshot of the current defined functions and installs a B::Hooks::EndOfScope hook in the current scope to invoke the cleanups.</div>
<div class="subsection">
<h2>unimport</h2> This method will be called when you do a<div class="spacer">
</div>
<br/>
  no namespace::clean;<br/>
<div class="spacer">
</div>
It will start a new section of code that defines functions to clean up.</div>
<div class="subsection">
<h2>get_class_store</h2> This returns a reference to a hash in a passed package containing information about function names included and excluded from removal.</div>
<div class="subsection">
<h2>get_functions</h2> Takes a class as argument and returns all currently defined functions in it as a hash reference with the function name as key and a typeglob reference to the symbol as value.</div>
</div>
<div class="section">
<h1>IMPLEMENTATION DETAILS</h1> This module works through the effect that a<div class="spacer">
</div>
<br/>
  delete $SomePackage::{foo};<br/>
<div class="spacer">
</div>
will remove the &quot;foo&quot; symbol from $SomePackage for run time lookups (e.g., method calls) but will leave the entry alive to be called by already resolved names in the package itself. &quot;namespace::clean&quot; will restore and therefor in effect keep all glob slots that aren't &quot;CODE&quot;.<div class="spacer">
</div>
A test file has been added to the perl core to ensure that this behaviour will be stable in future releases.<div class="spacer">
</div>
Just for completeness sake, if you want to remove the symbol completely, use &quot;undef&quot; instead.</div>
<div class="section">
<h1>SEE ALSO</h1> B::Hooks::EndOfScope</div>
<div class="section">
<h1>THANKS</h1> Many thanks to Matt S Trout for the inspiration on the whole idea.</div>
<div class="section">
<h1>AUTHORS</h1><dl>
<dt>
&#8226;</dt>
<dd>
Robert 'phaylon' Sedlacek &lt;rs@474.at&gt;</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Florian Ragwitz &lt;rafl@debian.org&gt;</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Jesse Luehrs &lt;doy@tozt.net&gt;</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Peter Rabbitson &lt;ribasushi@cpan.org&gt;</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Father Chrysostomos &lt;sprout@cpan.org&gt;</dd>
</dl>
</div>
<div class="section">
<h1>COPYRIGHT AND LICENSE</h1> This software is copyright (c) 2011 by &quot;AUTHORS&quot;<div class="spacer">
</div>
This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5 programming language system itself.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-12-26</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

