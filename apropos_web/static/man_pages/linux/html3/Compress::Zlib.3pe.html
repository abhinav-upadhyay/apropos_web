<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Compress::Zlib(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Compress::Zlib(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
Compress::Zlib(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Compress::Zlib - Interface to zlib compression library</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
    use Compress::Zlib ;<br/>
<br/>
    ($d, $status) = deflateInit( [OPT] ) ;<br/>
    $status = $d-&gt;deflate($input, $output) ;<br/>
    $status = $d-&gt;flush([$flush_type]) ;<br/>
    $d-&gt;deflateParams(OPTS) ;<br/>
    $d-&gt;deflateTune(OPTS) ;<br/>
    $d-&gt;dict_adler() ;<br/>
    $d-&gt;crc32() ;<br/>
    $d-&gt;adler32() ;<br/>
    $d-&gt;total_in() ;<br/>
    $d-&gt;total_out() ;<br/>
    $d-&gt;msg() ;<br/>
    $d-&gt;get_Strategy();<br/>
    $d-&gt;get_Level();<br/>
    $d-&gt;get_BufSize();<br/>
<br/>
    ($i, $status) = inflateInit( [OPT] ) ;<br/>
    $status = $i-&gt;inflate($input, $output [, $eof]) ;<br/>
    $status = $i-&gt;inflateSync($input) ;<br/>
    $i-&gt;dict_adler() ;<br/>
    $d-&gt;crc32() ;<br/>
    $d-&gt;adler32() ;<br/>
    $i-&gt;total_in() ;<br/>
    $i-&gt;total_out() ;<br/>
    $i-&gt;msg() ;<br/>
    $d-&gt;get_BufSize();<br/>
<br/>
    $dest = compress($source) ;<br/>
    $dest = uncompress($source) ;<br/>
<br/>
    $gz = gzopen($filename or filehandle, $mode) ;<br/>
    $bytesread = $gz-&gt;gzread($buffer [,$size]) ;<br/>
    $bytesread = $gz-&gt;gzreadline($line) ;<br/>
    $byteswritten = $gz-&gt;gzwrite($buffer) ;<br/>
    $status = $gz-&gt;gzflush($flush) ;<br/>
    $offset = $gz-&gt;gztell() ;<br/>
    $status = $gz-&gt;gzseek($offset, $whence) ;<br/>
    $status = $gz-&gt;gzclose() ;<br/>
    $status = $gz-&gt;gzeof() ;<br/>
    $status = $gz-&gt;gzsetparams($level, $strategy) ;<br/>
    $errstring = $gz-&gt;gzerror() ; <br/>
    $gzerrno<br/>
<br/>
    $dest = Compress::Zlib::memGzip($buffer) ;<br/>
    $dest = Compress::Zlib::memGunzip($buffer) ;<br/>
<br/>
    $crc = adler32($buffer [,$crc]) ;<br/>
    $crc = crc32($buffer [,$crc]) ;<br/>
<br/>
    $crc = adler32_combine($crc1, $crc2, $len2)l<br/>
    $crc = crc32_combine($adler1, $adler2, $len2)<br/>
<br/>
    my $version = Compress::Raw::Zlib::zlib_version();<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> The  <i>Compress::Zlib</i> module provides a Perl interface to the <i>zlib</i> compression library (see &quot;AUTHOR&quot; for details about where to get  <i>zlib</i>).<div class="spacer">
</div>
The &quot;Compress::Zlib&quot; module can be split into two general areas of functionality, namely a simple read/write interface to  <i>gzip</i> files and a low-level in-memory compression/decompression interface.<div class="spacer">
</div>
Each of these areas will be discussed in the following sections.<div class="subsection">
<h2>Notes for users of Compress::Zlib version 1</h2> The main change in &quot;Compress::Zlib&quot; version 2.x is that it does not now interface directly to the zlib library. Instead it uses the &quot;IO::Compress::Gzip&quot; and &quot;IO::Uncompress::Gunzip&quot; modules for reading/writing gzip files, and the &quot;Compress::Raw::Zlib&quot; module for some low-level zlib access.<div class="spacer">
</div>
The interface provided by version 2 of this module should be 100% backward compatible with version 1. If you find a difference in the expected behaviour please contact the author (See &quot;AUTHOR&quot;). See &quot;GZIP INTERFACE&quot;<div class="spacer">
</div>
With the creation of the &quot;IO::Compress&quot; and &quot;IO::Uncompress&quot; modules no new features are planned for &quot;Compress::Zlib&quot; - the new modules do everything that &quot;Compress::Zlib&quot; does and then some. Development on &quot;Compress::Zlib&quot; will be limited to bug fixes only.<div class="spacer">
</div>
If you are writing new code, your first port of call should be one of the new &quot;IO::Compress&quot; or &quot;IO::Uncompress&quot; modules.</div>
</div>
<div class="section">
<h1>GZIP INTERFACE</h1> A number of functions are supplied in  <i>zlib</i> for reading and writing  <i>gzip</i> files that conform to RFC 1952. This module provides an interface to most of them.<div class="spacer">
</div>
If you have previously used &quot;Compress::Zlib&quot; 1.x, the following enhancements/changes have been made to the &quot;gzopen&quot; interface:<dl>
<dt>
1.</dt>
<dd>
If you want to to open either STDIN or STDOUT with &quot;gzopen&quot;, you can now optionally use the special filename &quot;&quot;-&quot;&quot; as a synonym for &quot;\*STDIN&quot; and &quot;\*STDOUT&quot;.</dd>
</dl>
<dl>
<dt>
2.</dt>
<dd>
In &quot;Compress::Zlib&quot; version 1.x, &quot;gzopen&quot; used the zlib library to open the underlying file. This made things especially tricky when a Perl filehandle was passed to &quot;gzopen&quot;. Behind the scenes the numeric C file descriptor had to be extracted from the Perl filehandle and this passed to the zlib library.<div style="height: 1.00em;">
&#160;</div>
Apart from being non-portable to some operating systems, this made it difficult to use &quot;gzopen&quot; in situations where you wanted to extract/create a gzip data stream that is embedded in a larger file, without having to resort to opening and closing the file multiple times.<div style="height: 1.00em;">
&#160;</div>
It also made it impossible to pass a perl filehandle that wasn't associated with a real filesystem file, like, say, an &quot;IO::String&quot;.<div style="height: 1.00em;">
&#160;</div>
In &quot;Compress::Zlib&quot; version 2.x, the &quot;gzopen&quot; interface has been completely rewritten to use the IO::Compress::Gzip for writing gzip files and IO::Uncompress::Gunzip for reading gzip files. None of the limitations mentioned above apply.</dd>
</dl>
<dl>
<dt>
3.</dt>
<dd>
Addition of &quot;gzseek&quot; to provide a restricted &quot;seek&quot; interface.</dd>
</dl>
<dl>
<dt>
4.</dt>
<dd>
Added &quot;gztell&quot;.</dd>
</dl>
<div class="spacer">
</div>
A more complete and flexible interface for reading/writing gzip files/buffers is included with the module &quot;IO-Compress-Zlib&quot;. See IO::Compress::Gzip and IO::Uncompress::Gunzip for more details.<dl>
<dt>
<b></b><b>$gz</b><b> = gzopen($filename, </b><b><i>$mode</i></b><b>)</b></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<b></b><b>$gz</b><b> = gzopen($filehandle, </b><b><i>$mode</i></b><b>)</b></dt>
<dd>
This function opens either the <i>gzip</i> file $filename for reading or writing or attaches to the opened filehandle, $filehandle. It returns an object on success and &quot;undef&quot; on failure.<div style="height: 1.00em;">
&#160;</div>
When writing a gzip file this interface will <i>always</i> create the smallest possible gzip header (exactly 10 bytes). If you want greater control over what gets stored in the gzip header (like the original filename or a comment) use IO::Compress::Gzip instead. Similarly if you want to read the contents of the gzip header use IO::Uncompress::Gunzip.<div style="height: 1.00em;">
&#160;</div>
The second parameter, $mode, is used to specify whether the file is opened for reading or writing and to optionally specify a compression level and compression strategy when writing. The format of the $mode parameter is similar to the mode parameter to the 'C' function &quot;fopen&quot;, so &quot;rb&quot; is used to open for reading, &quot;wb&quot; for writing and &quot;ab&quot; for appending (writing at the end of the file).<div style="height: 1.00em;">
&#160;</div>
To specify a compression level when writing, append a digit between 0 and 9 to the mode string -- 0 means no compression and 9 means maximum compression. If no compression level is specified Z_DEFAULT_COMPRESSION is used.<div style="height: 1.00em;">
&#160;</div>
To specify the compression strategy when writing, append 'f' for filtered data, 'h' for Huffman only compression, or 'R' for run-length encoding. If no strategy is specified Z_DEFAULT_STRATEGY is used.<div style="height: 1.00em;">
&#160;</div>
So, for example, &quot;wb9&quot; means open for writing with the maximum compression using the default strategy and &quot;wb4R&quot; means open for writing with compression level 4 and run-length encoding.<div style="height: 1.00em;">
&#160;</div>
Refer to the <i>zlib</i> documentation for the exact format of the $mode parameter.</dd>
</dl>
<dl>
<dt>
<b></b><b>$bytesread</b><b> = </b><b><i>$gz</i></b><b>-&gt;gzread($buffer [, </b><b>$size</b><b>]) ;</b></dt>
<dd>
Reads $size bytes from the compressed file into $buffer. If $size is not specified, it will default to 4096. If the scalar $buffer is not large enough, it will be extended automatically.<div style="height: 1.00em;">
&#160;</div>
Returns the number of bytes actually read. On EOF it returns 0 and in the case of an error, -1.</dd>
</dl>
<dl>
<dt>
<b></b><b>$bytesread</b><b> = </b><b><i>$gz</i></b><b>-&gt;gzreadline($line) ;</b></dt>
<dd>
Reads the next line from the compressed file into $line.<div style="height: 1.00em;">
&#160;</div>
Returns the number of bytes actually read. On EOF it returns 0 and in the case of an error, -1.<div style="height: 1.00em;">
&#160;</div>
It is legal to intermix calls to &quot;gzread&quot; and &quot;gzreadline&quot;.<div style="height: 1.00em;">
&#160;</div>
To maintain backward compatibility with version 1.x of this module &quot;gzreadline&quot; ignores the $/ variable - it  <i>always</i> uses the string &quot;\n&quot; as the line delimiter.<div style="height: 1.00em;">
&#160;</div>
If you want to read a gzip file a line at a time and have it respect the $/ variable (or $INPUT_RECORD_SEPARATOR, or $RS when &quot;English&quot; is in use) see IO::Uncompress::Gunzip.</dd>
</dl>
<dl>
<dt>
<b></b><b>$byteswritten</b><b> = </b><b><i>$gz</i></b><b>-&gt;gzwrite($buffer) ;</b></dt>
<dd>
Writes the contents of $buffer to the compressed file. Returns the number of bytes actually written, or 0 on error.</dd>
</dl>
<dl>
<dt>
<b></b><b>$status</b><b> = </b><b><i>$gz</i></b><b>-&gt;gzflush($flush_type) ;</b></dt>
<dd>
Flushes all pending output into the compressed file.<div style="height: 1.00em;">
&#160;</div>
This method takes an optional parameter, $flush_type, that controls how the flushing will be carried out. By default the $flush_type used is &quot;Z_FINISH&quot;. Other valid values for $flush_type are &quot;Z_NO_FLUSH&quot;, &quot;Z_SYNC_FLUSH&quot;, &quot;Z_FULL_FLUSH&quot; and &quot;Z_BLOCK&quot;. It is strongly recommended that you only set the &quot;flush_type&quot; parameter if you fully understand the implications of what it does - overuse of &quot;flush&quot; can seriously degrade the level of compression achieved. See the &quot;zlib&quot; documentation for details.<div style="height: 1.00em;">
&#160;</div>
Returns 0 on success.</dd>
</dl>
<dl>
<dt>
<b></b><b>$offset</b><b> = </b><b><i>$gz</i></b><b>-&gt;</b><b><i>gztell()</i></b><b> ;</b></dt>
<dd>
Returns the uncompressed file offset.</dd>
</dl>
<dl>
<dt>
<b></b><b>$status</b><b> = </b><b><i>$gz</i></b><b>-&gt;gzseek($offset, </b><b>$whence</b><b>) ;</b></dt>
<dd>
Provides a sub-set of the &quot;seek&quot; functionality, with the restriction that it is only legal to seek forward in the compressed file. It is a fatal error to attempt to seek backward.<div style="height: 1.00em;">
&#160;</div>
When opened for writing, empty parts of the file will have NULL (0x00) bytes written to them.<div style="height: 1.00em;">
&#160;</div>
The $whence parameter should be one of SEEK_SET, SEEK_CUR or SEEK_END.<div style="height: 1.00em;">
&#160;</div>
Returns 1 on success, 0 on failure.</dd>
</dl>
<dl>
<dt>
<b></b><b>$gz</b><b>-&gt;gzclose</b></dt>
<dd>
Closes the compressed file. Any pending data is flushed to the file before it is closed.<div style="height: 1.00em;">
&#160;</div>
Returns 0 on success.</dd>
</dl>
<dl>
<dt>
<b></b><b>$gz</b><b>-&gt;gzsetparams($level, </b><b><i>$strategy</i></b><b></b></dt>
<dd>
Change settings for the deflate stream $gz.<div style="height: 1.00em;">
&#160;</div>
The list of the valid options is shown below. Options not specified will remain unchanged.<div style="height: 1.00em;">
&#160;</div>
Note: This method is only available if you are running zlib 1.0.6 or better.</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl>
<dt>
<b></b><b>$level</b><b></b></dt>
<dd>
Defines the compression level. Valid values are 0 through 9, &quot;Z_NO_COMPRESSION&quot;, &quot;Z_BEST_SPEED&quot;, &quot;Z_BEST_COMPRESSION&quot;, and &quot;Z_DEFAULT_COMPRESSION&quot;.</dd>
</dl>
<dl>
<dt>
<b></b><b>$strategy</b><b></b></dt>
<dd>
Defines the strategy used to tune the compression. The valid values are &quot;Z_DEFAULT_STRATEGY&quot;, &quot;Z_FILTERED&quot; and &quot;Z_HUFFMAN_ONLY&quot;.</dd>
</dl>
</div>
<div style="margin-left: 5.00ex;">
</div>
<dl>
<dt>
<b></b><b>$gz</b><b>-&gt;gzerror</b></dt>
<dd>
Returns the <i>zlib</i> error message or number for the last operation associated with $gz. The return value will be the  <i>zlib</i> error number when used in a numeric context and the  <i>zlib</i> error message when used in a string context. The  <i>zlib</i> error number constants, shown below, are available for use.<div style="height: 1.00em;">
&#160;</div>
<br/>
    Z_OK<br/>
    Z_STREAM_END<br/>
    Z_ERRNO<br/>
    Z_STREAM_ERROR<br/>
    Z_DATA_ERROR<br/>
    Z_MEM_ERROR<br/>
    Z_BUF_ERROR<br/>
</dd>
</dl>
<dl>
<dt>
<b></b><b>$gzerrno</b><b></b></dt>
<dd>
The $gzerrno scalar holds the error code associated with the most recent  <i>gzip</i> routine. Note that unlike &quot;gzerror()&quot;, the error is  <i>not</i> associated with a particular file.<div style="height: 1.00em;">
&#160;</div>
As with &quot;gzerror()&quot; it returns an error number in numeric context and an error message in string context. Unlike &quot;gzerror()&quot; though, the error message will correspond to the  <i>zlib</i> message when the error is associated with  <i>zlib</i> itself, or the UNIX error message when it is not (i.e.  <i>zlib</i> returned &quot;Z_ERRORNO&quot;).<div style="height: 1.00em;">
&#160;</div>
As there is an overlap between the error numbers used by <i>zlib</i> and UNIX, $gzerrno should only be used to check for the presence of  <i>an</i> error in numeric context. Use &quot;gzerror()&quot; to check for specific  <i>zlib</i> errors. The <i>gzcat</i> example below shows how the variable can be used safely.</dd>
</dl>
<div class="subsection">
<h2>Examples</h2> Here is an example script which uses the interface. It implements a  <i>gzcat</i> function.<div class="spacer">
</div>
<br/>
    use strict ;<br/>
    use warnings ;<br/>
    <br/>
    use Compress::Zlib ;<br/>
    <br/>
    # use stdin if no files supplied<br/>
    @ARGV = '-' unless @ARGV ;<br/>
    <br/>
    foreach my $file (@ARGV) {<br/>
        my $buffer ;<br/>
    <br/>
        my $gz = gzopen($file, &quot;rb&quot;) <br/>
             or die &quot;Cannot open $file: $gzerrno\n&quot; ;<br/>
    <br/>
        print $buffer while $gz-&gt;gzread($buffer) &gt; 0 ;<br/>
    <br/>
        die &quot;Error reading from $file: $gzerrno&quot; . ($gzerrno+0) . &quot;\n&quot; <br/>
            if $gzerrno != Z_STREAM_END ;<br/>
        <br/>
        $gz-&gt;gzclose() ;<br/>
    }<br/>
<div class="spacer">
</div>
Below is a script which makes use of &quot;gzreadline&quot;. It implements a very simple  <i>grep</i> like script.<div class="spacer">
</div>
<br/>
    use strict ;<br/>
    use warnings ;<br/>
    <br/>
    use Compress::Zlib ;<br/>
    <br/>
    die &quot;Usage: gzgrep pattern [file...]\n&quot;<br/>
        unless @ARGV &gt;= 1;<br/>
    <br/>
    my $pattern = shift ;<br/>
    <br/>
    # use stdin if no files supplied<br/>
    @ARGV = '-' unless @ARGV ;<br/>
    <br/>
    foreach my $file (@ARGV) {<br/>
        my $gz = gzopen($file, &quot;rb&quot;) <br/>
             or die &quot;Cannot open $file: $gzerrno\n&quot; ;<br/>
    <br/>
        while ($gz-&gt;gzreadline($_) &gt; 0) {<br/>
            print if /$pattern/ ;<br/>
        }<br/>
    <br/>
        die &quot;Error reading from $file: $gzerrno\n&quot; <br/>
            if $gzerrno != Z_STREAM_END ;<br/>
        <br/>
        $gz-&gt;gzclose() ;<br/>
    }<br/>
<div class="spacer">
</div>
This script, <i>gzstream</i>, does the opposite of the <i>gzcat</i> script above. It reads from standard input and writes a gzip data stream to standard output.<div class="spacer">
</div>
<br/>
    use strict ;<br/>
    use warnings ;<br/>
    <br/>
    use Compress::Zlib ;<br/>
    <br/>
    binmode STDOUT;  # gzopen only sets it on the fd<br/>
    <br/>
    my $gz = gzopen(\*STDOUT, &quot;wb&quot;)<br/>
          or die &quot;Cannot open stdout: $gzerrno\n&quot; ;<br/>
    <br/>
    while (&lt;&gt;) {<br/>
        $gz-&gt;gzwrite($_) <br/>
          or die &quot;error writing: $gzerrno\n&quot; ;<br/>
    }<br/>
<br/>
    $gz-&gt;gzclose ;<br/>
</div>
<div class="subsection">
<h2>Compress::Zlib::memGzip</h2> This function is used to create an in-memory gzip file with the minimum possible gzip header (exactly 10 bytes).<div class="spacer">
</div>
<br/>
    $dest = Compress::Zlib::memGzip($buffer) <br/>
        or die &quot;Cannot compress: $gzerrno\n&quot;;<br/>
<div class="spacer">
</div>
If successful, it returns the in-memory gzip file. Otherwise it returns &quot;undef&quot; and the $gzerrno variable will store the zlib error code.<div class="spacer">
</div>
The $buffer parameter can either be a scalar or a scalar reference.<div class="spacer">
</div>
See IO::Compress::Gzip for an alternative way to carry out in-memory gzip compression.</div>
<div class="subsection">
<h2>Compress::Zlib::memGunzip</h2> This function is used to uncompress an in-memory gzip file.<div class="spacer">
</div>
<br/>
    $dest = Compress::Zlib::memGunzip($buffer) <br/>
        or die &quot;Cannot uncompress: $gzerrno\n&quot;;<br/>
<div class="spacer">
</div>
If successful, it returns the uncompressed gzip file. Otherwise it returns &quot;undef&quot; and the $gzerrno variable will store the zlib error code.<div class="spacer">
</div>
The $buffer parameter can either be a scalar or a scalar reference. The contents of the $buffer parameter are destroyed after calling this function.<div class="spacer">
</div>
If $buffer consists of multiple concatenated gzip data streams only the first will be uncompressed. Use &quot;gunzip&quot; with the &quot;MultiStream&quot; option in the &quot;IO::Uncompress::Gunzip&quot; module if you need to deal with concatenated data streams.<div class="spacer">
</div>
See IO::Uncompress::Gunzip for an alternative way to carry out in-memory gzip uncompression.</div>
</div>
<div class="section">
<h1>COMPRESS/UNCOMPRESS</h1> Two functions are provided to perform in-memory compression/uncompression of RFC 1950 data streams. They are called &quot;compress&quot; and &quot;uncompress&quot;.<dl>
<dt>
<b></b><b>$dest</b><b> = compress($source [, </b><b><i>$level</i></b><b>] ) ;</b></dt>
<dd>
Compresses $source. If successful it returns the compressed data. Otherwise it returns  <i>undef</i>.<div style="height: 1.00em;">
&#160;</div>
The source buffer, $source, can either be a scalar or a scalar reference.<div style="height: 1.00em;">
&#160;</div>
The $level parameter defines the compression level. Valid values are 0 through 9, &quot;Z_NO_COMPRESSION&quot;, &quot;Z_BEST_SPEED&quot;, &quot;Z_BEST_COMPRESSION&quot;, and &quot;Z_DEFAULT_COMPRESSION&quot;. If $level is not specified &quot;Z_DEFAULT_COMPRESSION&quot; will be used.</dd>
</dl>
<dl>
<dt>
<b></b><b>$dest</b><b> = uncompress($source) ;</b></dt>
<dd>
Uncompresses $source. If successful it returns the uncompressed data. Otherwise it returns  <i>undef</i>.<div style="height: 1.00em;">
&#160;</div>
The source buffer can either be a scalar or a scalar reference.</dd>
</dl>
<div class="spacer">
</div>
Please note: the two functions defined above are <i>not</i> compatible with the Unix commands of the same name.<div class="spacer">
</div>
See IO::Deflate and IO::Inflate included with this distribution for an alternative interface for reading/writing RFC 1950 files/buffers.</div>
<div class="section">
<h1>Deflate Interface</h1> This section defines an interface that allows in-memory compression using the  <i>deflate</i> interface provided by zlib.<div class="spacer">
</div>
Here is a definition of the interface available:<div class="subsection">
<h2><b>($d, </b><b>$status</b><b>) = deflateInit( [OPT] )</b></h2> Initialises a deflation stream.<div class="spacer">
</div>
It combines the features of the <i>zlib</i> functions &quot;deflateInit&quot;, &quot;deflateInit2&quot; and &quot;deflateSetDictionary&quot;.<div class="spacer">
</div>
If successful, it will return the initialised deflation stream, $d and $status of &quot;Z_OK&quot; in a list context. In scalar context it returns the deflation stream, $d, only.<div class="spacer">
</div>
If not successful, the returned deflation stream ($d) will be  <i>undef</i> and $status will hold the exact <i>zlib</i> error code.<div class="spacer">
</div>
The function optionally takes a number of named options specified as &quot;-Name=&gt;value&quot; pairs. This allows individual options to be tailored without having to specify them all in the parameter list.<div class="spacer">
</div>
For backward compatibility, it is also possible to pass the parameters as a reference to a hash containing the name=&gt;value pairs.<div class="spacer">
</div>
The function takes one optional parameter, a reference to a hash.  The contents of the hash allow the deflation interface to be tailored.<div class="spacer">
</div>
Here is a list of the valid options:<dl>
<dt>
<b>-Level</b></dt>
<dd>
Defines the compression level. Valid values are 0 through 9, &quot;Z_NO_COMPRESSION&quot;, &quot;Z_BEST_SPEED&quot;, &quot;Z_BEST_COMPRESSION&quot;, and &quot;Z_DEFAULT_COMPRESSION&quot;.<div style="height: 1.00em;">
&#160;</div>
The default is Z_DEFAULT_COMPRESSION.</dd>
</dl>
<dl>
<dt>
<b>-Method</b></dt>
<dd>
Defines the compression method. The only valid value at present (and the default) is Z_DEFLATED.</dd>
</dl>
<dl>
<dt>
<b>-WindowBits</b></dt>
<dd>
To create an RFC 1950 data stream, set &quot;WindowBits&quot; to a positive number.<div style="height: 1.00em;">
&#160;</div>
To create an RFC 1951 data stream, set &quot;WindowBits&quot; to &quot;-MAX_WBITS&quot;.<div style="height: 1.00em;">
&#160;</div>
For a full definition of the meaning and valid values for &quot;WindowBits&quot; refer to the  <i>zlib</i> documentation for <i>deflateInit2</i>.<div style="height: 1.00em;">
&#160;</div>
Defaults to MAX_WBITS.</dd>
</dl>
<dl>
<dt>
<b>-MemLevel</b></dt>
<dd>
For a definition of the meaning and valid values for &quot;MemLevel&quot; refer to the  <i>zlib</i> documentation for <i>deflateInit2</i>.<div style="height: 1.00em;">
&#160;</div>
Defaults to MAX_MEM_LEVEL.</dd>
</dl>
<dl>
<dt>
<b>-Strategy</b></dt>
<dd>
Defines the strategy used to tune the compression. The valid values are &quot;Z_DEFAULT_STRATEGY&quot;, &quot;Z_FILTERED&quot; and &quot;Z_HUFFMAN_ONLY&quot;.<div style="height: 1.00em;">
&#160;</div>
The default is Z_DEFAULT_STRATEGY.</dd>
</dl>
<dl>
<dt>
<b>-Dictionary</b></dt>
<dd>
When a dictionary is specified <i>Compress::Zlib</i> will automatically call &quot;deflateSetDictionary&quot; directly after calling &quot;deflateInit&quot;. The Adler32 value for the dictionary can be obtained by calling the method &quot;$d-&quot; <i>dict_adler()</i>&gt;.<div style="height: 1.00em;">
&#160;</div>
The default is no dictionary.</dd>
</dl>
<dl>
<dt>
<b>-Bufsize</b></dt>
<dd>
Sets the initial size for the deflation buffer. If the buffer has to be reallocated to increase the size, it will grow in increments of &quot;Bufsize&quot;.<div style="height: 1.00em;">
&#160;</div>
The default is 4096.</dd>
</dl>
<div class="spacer">
</div>
Here is an example of using the &quot;deflateInit&quot; optional parameter list to override the default buffer size and compression level. All other options will take their default values.<div class="spacer">
</div>
<br/>
    deflateInit( -Bufsize =&gt; 300, <br/>
                 -Level =&gt; Z_BEST_SPEED  ) ;<br/>
</div>
<div class="subsection">
<h2><b>($out, </b><b>$status</b><b>) = </b><b>$d</b><b>-&gt;deflate($buffer)</b></h2> Deflates the contents of $buffer. The buffer can either be a scalar or a scalar reference.  When finished, $buffer will be completely processed (assuming there were no errors). If the deflation was successful it returns the deflated output, $out, and a status value, $status, of &quot;Z_OK&quot;.<div class="spacer">
</div>
On error, $out will be <i>undef</i> and $status will contain the  <i>zlib</i> error code.<div class="spacer">
</div>
In a scalar context &quot;deflate&quot; will return $out only.<div class="spacer">
</div>
As with the <i>deflate</i> function in <i>zlib</i>, it is not necessarily the case that any output will be produced by this method. So don't rely on the fact that $out is empty for an error test.</div>
<div class="subsection">
<h2><b>($out, </b><b>$status</b><b>) = </b><b>$d</b><b>-&gt;</b><b><i>flush()</i></b><b></b> =head2 <b>($out, </b><b>$status</b><b>) = </b><b>$d</b><b>-&gt;flush($flush_type)</b></h2> Typically used to finish the deflation. Any pending output will be returned via $out. $status will have a value &quot;Z_OK&quot; if successful.<div class="spacer">
</div>
In a scalar context &quot;flush&quot; will return $out only.<div class="spacer">
</div>
Note that flushing can seriously degrade the compression ratio, so it should only be used to terminate a decompression (using &quot;Z_FINISH&quot;) or when you want to create a  <i>full flush point</i> (using &quot;Z_FULL_FLUSH&quot;).<div class="spacer">
</div>
By default the &quot;flush_type&quot; used is &quot;Z_FINISH&quot;. Other valid values for &quot;flush_type&quot; are &quot;Z_NO_FLUSH&quot;, &quot;Z_PARTIAL_FLUSH&quot;, &quot;Z_SYNC_FLUSH&quot; and &quot;Z_FULL_FLUSH&quot;. It is strongly recommended that you only set the &quot;flush_type&quot; parameter if you fully understand the implications of what it does. See the &quot;zlib&quot; documentation for details.</div>
<div class="subsection">
<h2><b></b><b>$status</b><b> = </b><b>$d</b><b>-&gt;deflateParams([OPT])</b></h2> Change settings for the deflate stream $d.<div class="spacer">
</div>
The list of the valid options is shown below. Options not specified will remain unchanged.<dl>
<dt>
<b>-Level</b></dt>
<dd>
Defines the compression level. Valid values are 0 through 9, &quot;Z_NO_COMPRESSION&quot;, &quot;Z_BEST_SPEED&quot;, &quot;Z_BEST_COMPRESSION&quot;, and &quot;Z_DEFAULT_COMPRESSION&quot;.</dd>
</dl>
<dl>
<dt>
<b>-Strategy</b></dt>
<dd>
Defines the strategy used to tune the compression. The valid values are &quot;Z_DEFAULT_STRATEGY&quot;, &quot;Z_FILTERED&quot; and &quot;Z_HUFFMAN_ONLY&quot;.</dd>
</dl>
</div>
<div class="subsection">
<h2><b></b><b>$d</b><b>-&gt;</b><b><i>dict_adler()</i></b><b></b></h2> Returns the adler32 value for the dictionary.</div>
<div class="subsection">
<h2><b></b><b>$d</b><b>-&gt;</b><b><i>msg()</i></b><b></b></h2> Returns the last error message generated by zlib.</div>
<div class="subsection">
<h2><b></b><b>$d</b><b>-&gt;</b><b><i>total_in()</i></b><b></b></h2> Returns the total number of bytes uncompressed bytes input to deflate.</div>
<div class="subsection">
<h2><b></b><b>$d</b><b>-&gt;</b><b><i>total_out()</i></b><b></b></h2> Returns the total number of compressed bytes output from deflate.</div>
<div class="subsection">
<h2>Example</h2> Here is a trivial example of using &quot;deflate&quot;. It simply reads standard input, deflates it and writes it to standard output.<div class="spacer">
</div>
<br/>
    use strict ;<br/>
    use warnings ;<br/>
<br/>
    use Compress::Zlib ;<br/>
<br/>
    binmode STDIN;<br/>
    binmode STDOUT;<br/>
    my $x = deflateInit()<br/>
       or die &quot;Cannot create a deflation stream\n&quot; ;<br/>
<br/>
    my ($output, $status) ;<br/>
    while (&lt;&gt;)<br/>
    {<br/>
        ($output, $status) = $x-&gt;deflate($_) ;<br/>
    <br/>
        $status == Z_OK<br/>
            or die &quot;deflation failed\n&quot; ;<br/>
    <br/>
        print $output ;<br/>
    }<br/>
    <br/>
    ($output, $status) = $x-&gt;flush() ;<br/>
    <br/>
    $status == Z_OK<br/>
        or die &quot;deflation failed\n&quot; ;<br/>
    <br/>
    print $output ;<br/>
</div>
</div>
<div class="section">
<h1>Inflate Interface</h1> This section defines the interface available that allows in-memory uncompression using the  <i>deflate</i> interface provided by zlib.<div class="spacer">
</div>
Here is a definition of the interface:<div class="subsection">
<h2><b>($i, </b><b>$status</b><b>) = </b><b><i>inflateInit()</i></b><b></b></h2> Initialises an inflation stream.<div class="spacer">
</div>
In a list context it returns the inflation stream, $i, and the  <i>zlib</i> status code in $status. In a scalar context it returns the inflation stream only.<div class="spacer">
</div>
If successful, $i will hold the inflation stream and $status will be &quot;Z_OK&quot;.<div class="spacer">
</div>
If not successful, $i will be <i>undef</i> and $status will hold the  <i>zlib</i> error code.<div class="spacer">
</div>
The function optionally takes a number of named options specified as &quot;-Name=&gt;value&quot; pairs. This allows individual options to be tailored without having to specify them all in the parameter list.<div class="spacer">
</div>
For backward compatibility, it is also possible to pass the parameters as a reference to a hash containing the name=&gt;value pairs.<div class="spacer">
</div>
The function takes one optional parameter, a reference to a hash.  The contents of the hash allow the deflation interface to be tailored.<div class="spacer">
</div>
Here is a list of the valid options:<dl>
<dt>
<b>-WindowBits</b></dt>
<dd>
To uncompress an RFC 1950 data stream, set &quot;WindowBits&quot; to a positive number.<div style="height: 1.00em;">
&#160;</div>
To uncompress an RFC 1951 data stream, set &quot;WindowBits&quot; to &quot;-MAX_WBITS&quot;.<div style="height: 1.00em;">
&#160;</div>
For a full definition of the meaning and valid values for &quot;WindowBits&quot; refer to the  <i>zlib</i> documentation for <i>inflateInit2</i>.<div style="height: 1.00em;">
&#160;</div>
Defaults to MAX_WBITS.</dd>
</dl>
<dl>
<dt>
<b>-Bufsize</b></dt>
<dd>
Sets the initial size for the inflation buffer. If the buffer has to be reallocated to increase the size, it will grow in increments of &quot;Bufsize&quot;.<div style="height: 1.00em;">
&#160;</div>
Default is 4096.</dd>
</dl>
<dl>
<dt>
<b>-Dictionary</b></dt>
<dd>
The default is no dictionary.</dd>
</dl>
<div class="spacer">
</div>
Here is an example of using the &quot;inflateInit&quot; optional parameter to override the default buffer size.<div class="spacer">
</div>
<br/>
    inflateInit( -Bufsize =&gt; 300 ) ;<br/>
</div>
<div class="subsection">
<h2><b>($out, </b><b>$status</b><b>) = </b><b>$i</b><b>-&gt;inflate($buffer)</b></h2> Inflates the complete contents of $buffer. The buffer can either be a scalar or a scalar reference.<div class="spacer">
</div>
Returns &quot;Z_OK&quot; if successful and &quot;Z_STREAM_END&quot; if the end of the compressed data has been successfully reached. If not successful, $out will be  <i>undef</i> and $status will hold the  <i>zlib</i> error code.<div class="spacer">
</div>
The $buffer parameter is modified by &quot;inflate&quot;. On completion it will contain what remains of the input buffer after inflation. This means that $buffer will be an empty string when the return status is &quot;Z_OK&quot;. When the return status is &quot;Z_STREAM_END&quot; the $buffer parameter will contains what (if anything) was stored in the input buffer after the deflated data stream.<div class="spacer">
</div>
This feature is useful when processing a file format that encapsulates a  compressed data stream (e.g. gzip, zip).</div>
<div class="subsection">
<h2><b></b><b>$status</b><b> = </b><b>$i</b><b>-&gt;inflateSync($buffer)</b></h2> Scans $buffer until it reaches either a  <i>full flush point</i> or the end of the buffer.<div class="spacer">
</div>
If a <i>full flush point</i> is found, &quot;Z_OK&quot; is returned and $buffer will be have all data up to the flush point removed. This can then be passed to the &quot;deflate&quot; method.<div class="spacer">
</div>
Any other return code means that a flush point was not found. If more data is available, &quot;inflateSync&quot; can be called repeatedly with more compressed data until the flush point is found.</div>
<div class="subsection">
<h2><b></b><b>$i</b><b>-&gt;</b><b><i>dict_adler()</i></b><b></b></h2> Returns the adler32 value for the dictionary.</div>
<div class="subsection">
<h2><b></b><b>$i</b><b>-&gt;</b><b><i>msg()</i></b><b></b></h2> Returns the last error message generated by zlib.</div>
<div class="subsection">
<h2><b></b><b>$i</b><b>-&gt;</b><b><i>total_in()</i></b><b></b></h2> Returns the total number of bytes compressed bytes input to inflate.</div>
<div class="subsection">
<h2><b></b><b>$i</b><b>-&gt;</b><b><i>total_out()</i></b><b></b></h2> Returns the total number of uncompressed bytes output from inflate.</div>
<div class="subsection">
<h2>Example</h2> Here is an example of using &quot;inflate&quot;.<div class="spacer">
</div>
<br/>
    use strict ;<br/>
    use warnings ;<br/>
    <br/>
    use Compress::Zlib ;<br/>
    <br/>
    my $x = inflateInit()<br/>
       or die &quot;Cannot create a inflation stream\n&quot; ;<br/>
    <br/>
    my $input = '' ;<br/>
    binmode STDIN;<br/>
    binmode STDOUT;<br/>
    <br/>
    my ($output, $status) ;<br/>
    while (read(STDIN, $input, 4096))<br/>
    {<br/>
        ($output, $status) = $x-&gt;inflate(\$input) ;<br/>
    <br/>
        print $output <br/>
            if $status == Z_OK or $status == Z_STREAM_END ;<br/>
    <br/>
        last if $status != Z_OK ;<br/>
    }<br/>
    <br/>
    die &quot;inflation failed\n&quot;<br/>
        unless $status == Z_STREAM_END ;<br/>
</div>
</div>
<div class="section">
<h1>CHECKSUM FUNCTIONS</h1> Two functions are provided by  <i>zlib</i> to calculate checksums. For the Perl interface, the order of the two parameters in both functions has been reversed. This allows both running checksums and one off calculations to be done.<div class="spacer">
</div>
<br/>
    $crc = adler32($buffer [,$crc]) ;<br/>
    $crc = crc32($buffer [,$crc]) ;<br/>
<div class="spacer">
</div>
The buffer parameters can either be a scalar or a scalar reference.<div class="spacer">
</div>
If the $crc parameters is &quot;undef&quot;, the crc value will be reset.<div class="spacer">
</div>
If you have built this module with zlib 1.2.3 or better, two more CRC-related functions are available.<div class="spacer">
</div>
<br/>
    $crc = adler32_combine($crc1, $crc2, $len2)l<br/>
    $crc = crc32_combine($adler1, $adler2, $len2)<br/>
<div class="spacer">
</div>
These functions allow checksums to be merged.</div>
<div class="section">
<h1>Misc</h1><div class="subsection">
<h2>my $version = <i>Compress::Zlib::zlib_version()</i>;</h2> Returns the version of the zlib library.</div>
</div>
<div class="section">
<h1>CONSTANTS</h1> All the  <i>zlib</i> constants are automatically imported when you make use of  <i>Compress::Zlib</i>.</div>
<div class="section">
<h1>SEE ALSO</h1> IO::Compress::Gzip, IO::Uncompress::Gunzip, IO::Compress::Deflate, IO::Uncompress::Inflate, IO::Compress::RawDeflate, IO::Uncompress::RawInflate, IO::Compress::Bzip2, IO::Uncompress::Bunzip2, IO::Compress::Lzma, IO::Uncompress::UnLzma, IO::Compress::Xz, IO::Uncompress::UnXz, IO::Compress::Lzop, IO::Uncompress::UnLzop, IO::Compress::Lzf, IO::Uncompress::UnLzf, IO::Uncompress::AnyInflate, IO::Uncompress::AnyUncompress<div class="spacer">
</div>
Compress::Zlib::FAQ<div class="spacer">
</div>
File::GlobMapper, Archive::Zip, Archive::Tar, IO::Zlib<div class="spacer">
</div>
For RFC 1950, 1951 and 1952 see  <i>http://www.faqs.org/rfcs/rfc1950.html</i>,  <i>http://www.faqs.org/rfcs/rfc1951.html</i> and  <i>http://www.faqs.org/rfcs/rfc1952.html</i><div class="spacer">
</div>
The <i>zlib</i> compression library was written by Jean-loup Gailly  <i>gzip@prep.ai.mit.edu</i> and Mark Adler <i>madler@alumni.caltech.edu</i>.<div class="spacer">
</div>
The primary site for the <i>zlib</i> compression library is  <i>http://www.zlib.org</i>.<div class="spacer">
</div>
The primary site for gzip is <i>http://www.gzip.org</i>.</div>
<div class="section">
<h1>AUTHOR</h1> This module was written by Paul Marquess,  <i>pmqs@cpan.org</i>.</div>
<div class="section">
<h1>MODIFICATION HISTORY</h1> See the Changes file.</div>
<div class="section">
<h1>COPYRIGHT AND LICENSE</h1> Copyright (c) 1995-2011 Paul Marquess. All rights reserved.<div class="spacer">
</div>
This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-09-26</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

