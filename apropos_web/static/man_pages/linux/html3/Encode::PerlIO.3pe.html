<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Encode::PerlIO(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Encode::PerlIO(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
Encode::PerlIO(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Encode::PerlIO -- a detailed document on Encode and PerlIO</div>
<div class="section">
<h1>Overview</h1> It is very common to want to do encoding transformations when reading or writing files, network connections, pipes etc. If Perl is configured to use the new 'perlio' IO system then &quot;Encode&quot; provides a &quot;layer&quot; (see PerlIO) which can transform data as it is read or written.<div class="spacer">
</div>
Here is how the blind poet would modernise the encoding:<div class="spacer">
</div>
<br/>
    use Encode;<br/>
    open(my $iliad,'&lt;:encoding(iso-8859-7)','iliad.greek');<br/>
    open(my $utf8,'&gt;:utf8','iliad.utf8');<br/>
    my @epic = &lt;$iliad&gt;;<br/>
    print $utf8 @epic;<br/>
    close($utf8);<br/>
    close($illiad);<br/>
<div class="spacer">
</div>
In addition, the new IO system can also be configured to read/write UTF-8 encoded characters (as noted above, this is efficient):<div class="spacer">
</div>
<br/>
    open(my $fh,'&gt;:utf8','anything');<br/>
    print $fh &quot;Any \x{0021} string \N{SMILEY FACE}\n&quot;;<br/>
<div class="spacer">
</div>
Either of the above forms of &quot;layer&quot; specifications can be made the default for a lexical scope with the &quot;use open ...&quot; pragma. See open.<div class="spacer">
</div>
Once a handle is open, its layers can be altered using &quot;binmode&quot;.<div class="spacer">
</div>
Without any such configuration, or if Perl itself is built using the system's own IO, then write operations assume that the file handle accepts only  <i>bytes</i> and will &quot;die&quot; if a character larger than 255 is written to the handle. When reading, each octet from the handle becomes a byte-in-a-character. Note that this default is the same behaviour as bytes-only languages (including Perl before v5.6) would have, and is sufficient to handle native 8-bit encodings e.g. iso-8859-1, EBCDIC etc. and any legacy mechanisms for handling other encodings and binary data.<div class="spacer">
</div>
In other cases, it is the program's responsibility to transform characters into bytes using the API above before doing writes, and to transform the bytes read from a handle into characters before doing &quot;character operations&quot; (e.g. &quot;lc&quot;, &quot;/\W+/&quot;, ...).<div class="spacer">
</div>
You can also use PerlIO to convert larger amounts of data you don't want to bring into memory.  For example, to convert between ISO-8859-1 (Latin 1) and UTF-8 (or UTF-EBCDIC in EBCDIC machines):<div class="spacer">
</div>
<br/>
    open(F, &quot;&lt;:encoding(iso-8859-1)&quot;, &quot;data.txt&quot;) or die $!;<br/>
    open(G, &quot;&gt;:utf8&quot;,                 &quot;data.utf&quot;) or die $!;<br/>
    while (&lt;F&gt;) { print G }<br/>
<br/>
    # Could also do &quot;print G &lt;F&gt;&quot; but that would pull<br/>
    # the whole file into memory just to write it out again.<br/>
<div class="spacer">
</div>
More examples:<div class="spacer">
</div>
<br/>
    open(my $f, &quot;&lt;:encoding(cp1252)&quot;)<br/>
    open(my $g, &quot;&gt;:encoding(iso-8859-2)&quot;)<br/>
    open(my $h, &quot;&gt;:encoding(latin9)&quot;)       # iso-8859-15<br/>
<div class="spacer">
</div>
See also encoding for how to change the default encoding of the data in your script.</div>
<div class="section">
<h1>How does it work?</h1> Here is a crude diagram of how filehandle, PerlIO, and Encode interact.<div class="spacer">
</div>
<br/>
  filehandle &lt;-&gt; PerlIO        PerlIO &lt;-&gt; scalar (read/printed)<br/>
                       \      /<br/>
                        Encode<br/>
<div class="spacer">
</div>
When PerlIO receives data from either direction, it fills a buffer (currently with 1024 bytes) and passes the buffer to Encode. Encode tries to convert the valid part and passes it back to PerlIO, leaving invalid parts (usually a partial character) in the buffer. PerlIO then appends more data to the buffer, calls Encode again, and so on until the data stream ends.<div class="spacer">
</div>
To do so, PerlIO always calls (de|en)code methods with CHECK set to 1. This ensures that the method stops at the right place when it encounters partial character.  The following is what happens when PerlIO and Encode tries to encode (from utf8) more than 1024 bytes and the buffer boundary happens to be in the middle of a character.<div class="spacer">
</div>
<br/>
   A   B   C   ....   ~     \x{3000}    ....<br/>
  41  42  43   ....  7E   e3   80   80  ....<br/>
  &lt;- buffer ---------------&gt;<br/>
  &lt;&lt; encoded &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br/>
                       &lt;- next buffer ------<br/>
<div class="spacer">
</div>
Encode converts from the beginning to \x7E, leaving \xe3 in the buffer because it is invalid (partial character).<div class="spacer">
</div>
Unfortunately, this scheme does not work well with escape-based encodings such as ISO-2022-JP.</div>
<div class="section">
<h1>Line Buffering</h1> Now let's see what happens when you try to decode from ISO-2022-JP and the buffer ends in the middle of a character.<div class="spacer">
</div>
<br/>
              JIS208-ESC   \x{5f3e}<br/>
   A   B   C   ....   ~   \e   $   B  |DAN | ....<br/>
  41  42  43   ....  7E   1b  24  41  43  46 ....<br/>
  &lt;- buffer ---------------------------&gt;<br/>
  &lt;&lt; encoded &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br/>
<div class="spacer">
</div>
As you see, the next buffer begins with \x43.  But \x43 is 'C' in ASCII, which is wrong in this case because we are now in JISX 0208 area so it has to convert \x43\x46, not \x43.  Unlike utf8 and EUC, in escape-based encodings you can't tell if a given octet is a whole character or just part of it.<div class="spacer">
</div>
Fortunately PerlIO also supports line buffer if you tell PerlIO to use one instead of fixed buffer.  Since ISO-2022-JP is guaranteed to revert to ASCII at the end of the line, partial character will never happen when line buffer is used.<div class="spacer">
</div>
To tell PerlIO to use line buffer, implement -&gt;needs_lines method for your encoding object.  See  Encode::Encoding for details.<div class="spacer">
</div>
Thanks to these efforts most encodings that come with Encode support PerlIO but that still leaves following encodings.<div class="spacer">
</div>
<br/>
  iso-2022-kr<br/>
  MIME-B<br/>
  MIME-Header<br/>
  MIME-Q<br/>
<div class="spacer">
</div>
Fortunately iso-2022-kr is hardly used (according to Jungshik) and MIME-* are very unlikely to be fed to PerlIO because they are for mail headers.  See Encode::MIME::Header for details.<div class="subsection">
<h2>How can I tell whether my encoding fully supports PerlIO ?</h2> As of this writing, any encoding whose class belongs to Encode::XS and Encode::Unicode works.  The Encode module has a &quot;perlio_ok&quot; method which you can use before applying PerlIO encoding to the filehandle. Here is an example:<div class="spacer">
</div>
<br/>
  my $use_perlio = perlio_ok($enc);<br/>
  my $layer = $use_perlio ? &quot;&lt;:raw&quot; : &quot;&lt;:encoding($enc)&quot;;<br/>
  open my $fh, $layer, $file or die &quot;$file : $!&quot;;<br/>
  while(&lt;$fh&gt;){<br/>
    $_ = decode($enc, $_) unless $use_perlio;<br/>
    # .... <br/>
  }<br/>
</div>
</div>
<div class="section">
<h1>SEE ALSO</h1> Encode::Encoding, Encode::Supported, Encode::PerlIO, encoding, perlebcdic, &quot;open&quot; in perlfunc, perlunicode, utf8, the Perl Unicode Mailing List &lt;perl-unicode@perl.org&gt;</div>
<table class="foot">
<tr>
<td class="foot-date">
2010-12-30</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

