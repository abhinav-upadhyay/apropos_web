<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Ast_mapper(3)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Ast_mapper(3)</td>
<td class="head-vol">
OCaml library</td>
<td class="head-rtitle">
Ast_mapper(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Ast_mapper - The interface of a -ppx rewriter</div>
<div class="section">
<h1>Module</h1> Module   Ast_mapper</div>
<div class="section">
<h1>Documentation</h1> Module <b>Ast_mapper</b><br/>
 : <b>sig end</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
The interface of a -ppx rewriter<div style="height: 1.00em;">
&#160;</div>
A -ppx rewriter is a program that accepts a serialized abstract syntax tree and outputs another, possibly modified, abstract syntax tree. This module encapsulates the interface between the compiler and the -ppx rewriters, handling such details as the serialization format, forwarding of command-line flags, and storing state.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>Ast_mapper.mapper</b> allows to implement AST rewriting using open recursion. A typical mapper would be based on <b>Ast_mapper.default_mapper</b> , a deep identity mapper, and will fall back on it for handling the syntax it does not modify. For example:<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>open Asttypes</b> <b>open Parsetree</b> <b>open Ast_mapper</b> <b>let test_mapper argv =</b> <b>{ default_mapper with</b> <b>expr = fun mapper expr -&gt;</b> <b>match expr with</b> <b>| { pexp_desc = Pexp_extension ({ txt = test }, PStr [])} -&gt;</b> <b>Ast_helper.Exp.constant (Const_int 42)</b> <b>| other -&gt; default_mapper.expr mapper other; }</b> <b>let () =</b> <b>register ppx_test test_mapper</b><div style="height: 1.00em;">
&#160;</div>
This -ppx rewriter, which replaces <b>[%test]</b> in expressions with the constant <b>42</b> , can be compiled using <b>ocamlc -o ppx_test -I +compiler-libs ocamlcommon.cma ppx_test.ml</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>A generic Parsetree mapper</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<i>type mapper</i> = {<br/>
 attribute : <b>mapper -&gt; Parsetree.attribute -&gt; Parsetree.attribute</b> ;<br/>
 attributes : <b>mapper -&gt; Parsetree.attribute list -&gt; Parsetree.attribute list</b> ;<br/>
 case : <b>mapper -&gt; Parsetree.case -&gt; Parsetree.case</b> ;<br/>
 cases : <b>mapper -&gt; Parsetree.case list -&gt; Parsetree.case list</b> ;<br/>
 class_declaration : <b>mapper -&gt;</b> <b>Parsetree.class_declaration -&gt; Parsetree.class_declaration</b> ;<br/>
 class_description : <b>mapper -&gt;</b> <b>Parsetree.class_description -&gt; Parsetree.class_description</b> ;<br/>
 class_expr : <b>mapper -&gt; Parsetree.class_expr -&gt; Parsetree.class_expr</b> ;<br/>
 class_field : <b>mapper -&gt; Parsetree.class_field -&gt; Parsetree.class_field</b> ;<br/>
 class_signature : <b>mapper -&gt; Parsetree.class_signature -&gt; Parsetree.class_signature</b> ;<br/>
 class_structure : <b>mapper -&gt; Parsetree.class_structure -&gt; Parsetree.class_structure</b> ;<br/>
 class_type : <b>mapper -&gt; Parsetree.class_type -&gt; Parsetree.class_type</b> ;<br/>
 class_type_declaration : <b>mapper -&gt;</b> <b>Parsetree.class_type_declaration -&gt; Parsetree.class_type_declaration</b> ;<br/>
 class_type_field : <b>mapper -&gt; Parsetree.class_type_field -&gt; Parsetree.class_type_field</b> ;<br/>
 constructor_declaration : <b>mapper -&gt;</b> <b>Parsetree.constructor_declaration -&gt; Parsetree.constructor_declaration</b> ;<br/>
 expr : <b>mapper -&gt; Parsetree.expression -&gt; Parsetree.expression</b> ;<br/>
 extension : <b>mapper -&gt; Parsetree.extension -&gt; Parsetree.extension</b> ;<br/>
 extension_constructor : <b>mapper -&gt;</b> <b>Parsetree.extension_constructor -&gt; Parsetree.extension_constructor</b> ;<br/>
 include_declaration : <b>mapper -&gt;</b> <b>Parsetree.include_declaration -&gt; Parsetree.include_declaration</b> ;<br/>
 include_description : <b>mapper -&gt;</b> <b>Parsetree.include_description -&gt; Parsetree.include_description</b> ;<br/>
 label_declaration : <b>mapper -&gt;</b> <b>Parsetree.label_declaration -&gt; Parsetree.label_declaration</b> ;<br/>
 location : <b>mapper -&gt; Location.t -&gt; Location.t</b> ;<br/>
 module_binding : <b>mapper -&gt; Parsetree.module_binding -&gt; Parsetree.module_binding</b> ;<br/>
 module_declaration : <b>mapper -&gt;</b> <b>Parsetree.module_declaration -&gt; Parsetree.module_declaration</b> ;<br/>
 module_expr : <b>mapper -&gt; Parsetree.module_expr -&gt; Parsetree.module_expr</b> ;<br/>
 module_type : <b>mapper -&gt; Parsetree.module_type -&gt; Parsetree.module_type</b> ;<br/>
 module_type_declaration : <b>mapper -&gt;</b> <b>Parsetree.module_type_declaration -&gt; Parsetree.module_type_declaration</b> ;<br/>
 open_description : <b>mapper -&gt; Parsetree.open_description -&gt; Parsetree.open_description</b> ;<br/>
 pat : <b>mapper -&gt; Parsetree.pattern -&gt; Parsetree.pattern</b> ;<br/>
 payload : <b>mapper -&gt; Parsetree.payload -&gt; Parsetree.payload</b> ;<br/>
 signature : <b>mapper -&gt; Parsetree.signature -&gt; Parsetree.signature</b> ;<br/>
 signature_item : <b>mapper -&gt; Parsetree.signature_item -&gt; Parsetree.signature_item</b> ;<br/>
 structure : <b>mapper -&gt; Parsetree.structure -&gt; Parsetree.structure</b> ;<br/>
 structure_item : <b>mapper -&gt; Parsetree.structure_item -&gt; Parsetree.structure_item</b> ;<br/>
 typ : <b>mapper -&gt; Parsetree.core_type -&gt; Parsetree.core_type</b> ;<br/>
 type_declaration : <b>mapper -&gt; Parsetree.type_declaration -&gt; Parsetree.type_declaration</b> ;<br/>
 type_extension : <b>mapper -&gt; Parsetree.type_extension -&gt; Parsetree.type_extension</b> ;<br/>
 type_kind : <b>mapper -&gt; Parsetree.type_kind -&gt; Parsetree.type_kind</b> ;<br/>
 value_binding : <b>mapper -&gt; Parsetree.value_binding -&gt; Parsetree.value_binding</b> ;<br/>
 value_description : <b>mapper -&gt;</b> <b>Parsetree.value_description -&gt; Parsetree.value_description</b> ;<br/>
 with_constraint : <b>mapper -&gt; Parsetree.with_constraint -&gt; Parsetree.with_constraint</b> ;<br/>
 }<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
A mapper record implements one &quot;method&quot; per syntactic category, using an open recursion style: each method takes as its first argument the mapper to be applied to children in the syntax tree.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val default_mapper</i> : <b>mapper</b><div style="height: 1.00em;">
&#160;</div>
A default mapper, which implements a &quot;deep identity&quot; mapping.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Apply mappers to compilation units</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val tool_name</i> : <b>unit -&gt; string</b><div style="height: 1.00em;">
&#160;</div>
Can be used within a ppx preprocessor to know which tool is calling it <b>ocamlc</b> , <b>ocamlopt</b> , <b>ocamldoc</b> , <b>ocamldep</b> , <b>ocaml</b> , ...  Some global variables that reflect command-line options are automatically synchronized between the calling tool and the ppx preprocessor: <b>Clflags.include_dirs</b> , <b>Config.load_path</b> , <b>Clflags.open_modules</b> , <b>Clflags.for_package</b> , <b>Clflags.debug</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val apply</i> : <b>source:string -&gt; target:string -&gt; mapper -&gt; unit</b><div style="height: 1.00em;">
&#160;</div>
Apply a mapper (parametrized by the unit name) to a dumped parsetree found in the <b>source</b> file and put the result in the <b>target</b> file. The <b>structure</b> or <b>signature</b> field of the mapper is applied to the implementation or interface.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val run_main</i> : <b>(string list -&gt; mapper) -&gt; unit</b><div style="height: 1.00em;">
&#160;</div>
Entry point to call to implement a standalone -ppx rewriter from a mapper, parametrized by the command line arguments.  The current unit name can be obtained from <b>Location.input_name</b> .  This function implements proper error reporting for uncaught exceptions.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Registration API</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val register_function</i> : <b>(string -&gt; (string list -&gt; mapper) -&gt; unit) Pervasives.ref</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val register</i> : <b>string -&gt; (string list -&gt; mapper) -&gt; unit</b><div style="height: 1.00em;">
&#160;</div>
Apply the <b>register_function</b> .  The default behavior is to run the mapper immediately, taking arguments from the process command line.  This is to support a scenario where a mapper is linked as a stand-alone executable.<div style="height: 1.00em;">
&#160;</div>
It is possible to overwrite the <b>register_function</b> to define &quot;-ppx drivers&quot;, which combine several mappers in a single process. Typically, a driver starts by defining <b>register_function</b> to a custom implementation, then lets ppx rewriters (linked statically or dynamically) register themselves, and then run all or some of them.  It is also possible to have -ppx drivers apply rewriters to only specific parts of an AST.<div style="height: 1.00em;">
&#160;</div>
The first argument to <b>register</b> is a symbolic name to be used by the ppx driver.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Convenience functions to write mappers</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val map_opt</i> : <b>('a -&gt; 'b) -&gt; 'a option -&gt; 'b option</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val extension_of_error</i> : <b>Location.error -&gt; Parsetree.extension</b><div style="height: 1.00em;">
&#160;</div>
Encode an error into an 'ocaml.error' extension node which can be inserted in a generated Parsetree.  The compiler will be responsible for reporting the error.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val attribute_of_warning</i> : <b>Location.t -&gt; string -&gt; Parsetree.attribute</b><div style="height: 1.00em;">
&#160;</div>
Encode a warning message into an 'ocaml.ppwarning' attribute which can be inserted in a generated Parsetree.  The compiler will be responsible for reporting the warning.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Helper functions to call external mappers</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val add_ppx_context_str</i> : <b>tool_name:string -&gt; Parsetree.structure -&gt; Parsetree.structure</b><div style="height: 1.00em;">
&#160;</div>
Extract information from the current environment and encode it into an attribute which is prepended to the list of structure items in order to pass the information to an external processor.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val add_ppx_context_sig</i> : <b>tool_name:string -&gt; Parsetree.signature -&gt; Parsetree.signature</b><div style="height: 1.00em;">
&#160;</div>
Same as <b>add_ppx_context_str</b> , but for signatures.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val drop_ppx_context_str</i> : <b>restore:bool -&gt; Parsetree.structure -&gt; Parsetree.structure</b><div style="height: 1.00em;">
&#160;</div>
Drop the ocaml.ppx.context attribute from a structure.  If <b>restore</b> is true, also restore the associated data in the current process.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val drop_ppx_context_sig</i> : <b>restore:bool -&gt; Parsetree.signature -&gt; Parsetree.signature</b><div style="height: 1.00em;">
&#160;</div>
Same as <b>drop_ppx_context_str</b> , but for signatures.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Cookies</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>===</b> <b>Cookies</b> <b>===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<b>=== Cookies are used to pass information from a ppx processor to</b> <b>a further invocation of itself, when called from the OCaml</b> <b>toplevel (or other tools that support cookies). ===</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val set_cookie</i> : <b>string -&gt; Parsetree.expression -&gt; unit</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val get_cookie</i> : <b>string -&gt; Parsetree.expression option</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<table class="foot">
<tr>
<td class="foot-date">
2015-08-12</td>
<td class="foot-os">
OCamldoc</td>
</tr>
</table>
</div>
</body>
</html>

