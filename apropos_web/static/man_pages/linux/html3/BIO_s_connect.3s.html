<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
BIO_s_connect(3SSL)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
BIO_s_connect(3SSL)</td>
<td class="head-vol">
OpenSSL</td>
<td class="head-rtitle">
BIO_s_connect(3SSL)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> BIO_s_connect, BIO_set_conn_hostname, BIO_set_conn_port, BIO_set_conn_ip, BIO_set_conn_int_port, BIO_get_conn_hostname, BIO_get_conn_port, BIO_get_conn_ip, BIO_get_conn_int_port, BIO_set_nbio, BIO_do_connect - connect BIO</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
 #include &lt;openssl/bio.h&gt;<br/>
<br/>
 BIO_METHOD * BIO_s_connect(void);<br/>
<br/>
 BIO *BIO_new_connect(char *name);<br/>
<br/>
 long BIO_set_conn_hostname(BIO *b, char *name);<br/>
 long BIO_set_conn_port(BIO *b, char *port);<br/>
 long BIO_set_conn_ip(BIO *b, char *ip);<br/>
 long BIO_set_conn_int_port(BIO *b, char *port);<br/>
 char *BIO_get_conn_hostname(BIO *b);<br/>
 char *BIO_get_conn_port(BIO *b);<br/>
 char *BIO_get_conn_ip(BIO *b, dummy);<br/>
 long BIO_get_conn_int_port(BIO *b, int port);<br/>
<br/>
 long BIO_set_nbio(BIO *b, long n);<br/>
<br/>
 int BIO_do_connect(BIO *b);<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1>  <i>BIO_s_connect()</i> returns the connect BIO method. This is a wrapper round the platform's TCP/IP socket connection routines.<div class="spacer">
</div>
Using connect BIOs, TCP/IP connections can be made and data transferred using only BIO routines. In this way any platform specific operations are hidden by the BIO abstraction.<div class="spacer">
</div>
Read and write operations on a connect BIO will perform I/O on the underlying connection. If no connection is established and the port and hostname (see below) is set up properly then a connection is established first.<div class="spacer">
</div>
Connect BIOs support <i>BIO_puts()</i> but not <i>BIO_gets()</i>.<div class="spacer">
</div>
If the close flag is set on a connect BIO then any active connection is shutdown and the socket closed when the BIO is freed.<div class="spacer">
</div>
Calling <i>BIO_reset()</i> on a connect BIO will close any active connection and reset the BIO into a state where it can connect to the same host again.<div class="spacer">
</div>
<i>BIO_get_fd()</i> places the underlying socket in <b>c</b> if it is not NULL, it also returns the socket . If  <b>c</b> is not NULL it should be of type (int *).<div class="spacer">
</div>
<i>BIO_set_conn_hostname()</i> uses the string <b>name</b> to set the hostname. The hostname can be an IP address. The hostname can also include the port in the form hostname:port . It is also acceptable to use the form &quot;hostname/any/other/path&quot; or &quot;hostname:port/any/other/path&quot;.<div class="spacer">
</div>
<i>BIO_set_conn_port()</i> sets the port to <b>port</b>. <b>port</b> can be the numerical form or a string such as &quot;http&quot;. A string will be looked up first using  <i>getservbyname()</i> on the host platform but if that fails a standard table of port names will be used. Currently the list is http, telnet, socks, https, ssl, ftp, gopher and wais.<div class="spacer">
</div>
<i>BIO_set_conn_ip()</i> sets the IP address to <b>ip</b> using binary form, that is four bytes specifying the IP address in big-endian form.<div class="spacer">
</div>
<i>BIO_set_conn_int_port()</i> sets the port using <b>port</b>. <b>port</b> should be of type (int *).<div class="spacer">
</div>
<i>BIO_get_conn_hostname()</i> returns the hostname of the connect BIO or NULL if the BIO is initialized but no hostname is set. This return value is an internal pointer which should not be modified.<div class="spacer">
</div>
<i>BIO_get_conn_port()</i> returns the port as a string.<div class="spacer">
</div>
<i>BIO_get_conn_ip()</i> returns the IP address in binary form.<div class="spacer">
</div>
<i>BIO_get_conn_int_port()</i> returns the port as an int.<div class="spacer">
</div>
<i>BIO_set_nbio()</i> sets the non blocking I/O flag to <b>n</b>. If <b>n</b> is zero then blocking I/O is set. If  <b>n</b> is 1 then non blocking I/O is set. Blocking I/O is the default. The call to  <i>BIO_set_nbio()</i> should be made before the connection is established because non blocking I/O is set during the connect process.<div class="spacer">
</div>
<i>BIO_new_connect()</i> combines <i>BIO_new()</i> and <i>BIO_set_conn_hostname()</i> into a single call: that is it creates a new connect BIO with  <b>name</b>.<div class="spacer">
</div>
<i>BIO_do_connect()</i> attempts to connect the supplied BIO. It returns 1 if the connection was established successfully. A zero or negative value is returned if the connection could not be established, the call  <i>BIO_should_retry()</i> should be used for non blocking connect BIOs to determine if the call should be retried.</div>
<div class="section">
<h1>NOTES</h1> If blocking I/O is set then a non positive return value from any I/O call is caused by an error condition, although a zero return will normally mean that the connection was closed.<div class="spacer">
</div>
If the port name is supplied as part of the host name then this will override any value set with  <i>BIO_set_conn_port()</i>. This may be undesirable if the application does not wish to allow connection to arbitrary ports. This can be avoided by checking for the presence of the ':' character in the passed hostname and either indicating an error or truncating the string at that point.<div class="spacer">
</div>
The values returned by <i>BIO_get_conn_hostname()</i>, <i>BIO_get_conn_port()</i>,  <i>BIO_get_conn_ip()</i> and <i>BIO_get_conn_int_port()</i> are updated when a connection attempt is made. Before any connection attempt the values returned are those set by the application itself.<div class="spacer">
</div>
Applications do not have to call <i>BIO_do_connect()</i> but may wish to do so to separate the connection process from other I/O processing.<div class="spacer">
</div>
If non blocking I/O is set then retries will be requested as appropriate.<div class="spacer">
</div>
It addition to <i>BIO_should_read()</i> and <i>BIO_should_write()</i> it is also possible for  <i>BIO_should_io_special()</i> to be true during the initial connection process with the reason BIO_RR_CONNECT. If this is returned then this is an indication that a connection attempt would block, the application should then take appropriate action to wait until the underlying socket has connected and retry the call.<div class="spacer">
</div>
<i>BIO_set_conn_hostname()</i>, <i>BIO_set_conn_port()</i>, <i>BIO_set_conn_ip()</i>,  <i>BIO_set_conn_int_port()</i>, <i>BIO_get_conn_hostname()</i>, <i>BIO_get_conn_port()</i>,  <i>BIO_get_conn_ip()</i>, <i>BIO_get_conn_int_port()</i>, <i>BIO_set_nbio()</i> and  <i>BIO_do_connect()</i> are macros.</div>
<div class="section">
<h1>RETURN VALUES</h1>  <i>BIO_s_connect()</i> returns the connect BIO method.<div class="spacer">
</div>
<i>BIO_get_fd()</i> returns the socket or -1 if the BIO has not been initialized.<div class="spacer">
</div>
<i>BIO_set_conn_hostname()</i>, <i>BIO_set_conn_port()</i>, <i>BIO_set_conn_ip()</i> and  <i>BIO_set_conn_int_port()</i> always return 1.<div class="spacer">
</div>
<i>BIO_get_conn_hostname()</i> returns the connected hostname or NULL is none was set.<div class="spacer">
</div>
<i>BIO_get_conn_port()</i> returns a string representing the connected port or NULL if not set.<div class="spacer">
</div>
<i>BIO_get_conn_ip()</i> returns a pointer to the connected IP address in binary form or all zeros if not set.<div class="spacer">
</div>
<i>BIO_get_conn_int_port()</i> returns the connected port or 0 if none was set.<div class="spacer">
</div>
<i>BIO_set_nbio()</i> always returns 1.<div class="spacer">
</div>
<i>BIO_do_connect()</i> returns 1 if the connection was successfully established and 0 or -1 if the connection failed.</div>
<div class="section">
<h1>EXAMPLE</h1> This is example connects to a webserver on the local host and attempts to retrieve a page and copy the result to standard output.<div class="spacer">
</div>
<br/>
 BIO *cbio, *out;<br/>
 int len;<br/>
 char tmpbuf[1024];<br/>
 ERR_load_crypto_strings();<br/>
 cbio = BIO_new_connect(&quot;localhost:http&quot;);<br/>
 out = BIO_new_fp(stdout, BIO_NOCLOSE);<br/>
 if(BIO_do_connect(cbio) &lt;= 0) {<br/>
        fprintf(stderr, &quot;Error connecting to server\n&quot;);<br/>
        ERR_print_errors_fp(stderr);<br/>
        /* whatever ... */<br/>
        }<br/>
 BIO_puts(cbio, &quot;GET / HTTP/1.0\n\n&quot;);<br/>
 for(;;) {      <br/>
        len = BIO_read(cbio, tmpbuf, 1024);<br/>
        if(len &lt;= 0) break;<br/>
        BIO_write(out, tmpbuf, len);<br/>
 }<br/>
 BIO_free(cbio);<br/>
 BIO_free(out);<br/>
</div>
<div class="section">
<h1>SEE ALSO</h1> TBA</div>
<table class="foot">
<tr>
<td class="foot-date">
2000-10-19</td>
<td class="foot-os">
1.0.1</td>
</tr>
</table>
</div>
</body>
</html>

