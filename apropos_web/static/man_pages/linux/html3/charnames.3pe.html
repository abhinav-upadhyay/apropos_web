<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
charnames(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
charnames(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
charnames(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> charnames - access to Unicode character names and named character sequences; also define character names</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
 use charnames ':full';<br/>
 print &quot;\N{GREEK SMALL LETTER SIGMA} is called sigma.\n&quot;;<br/>
 print &quot;\N{LATIN CAPITAL LETTER E WITH VERTICAL LINE BELOW}&quot;,<br/>
       &quot; is an officially named sequence of two Unicode characters\n&quot;;<br/>
<br/>
 use charnames ':short';<br/>
 print &quot;\N{greek:Sigma} is an upper-case sigma.\n&quot;;<br/>
<br/>
 use charnames qw(cyrillic greek);<br/>
 print &quot;\N{sigma} is Greek sigma, and \N{be} is Cyrillic b.\n&quot;;<br/>
<br/>
 use charnames &quot;:full&quot;, &quot;:alias&quot; =&gt; {<br/>
   e_ACUTE =&gt; &quot;LATIN SMALL LETTER E WITH ACUTE&quot;,<br/>
   mychar =&gt; 0xE8000,  # Private use area<br/>
 };<br/>
 print &quot;\N{e_ACUTE} is a small letter e with an acute.\n&quot;;<br/>
 print &quot;\\N{mychar} allows me to name private use characters.\n&quot;;<br/>
<br/>
 use charnames ();<br/>
 print charnames::viacode(0x1234); # prints &quot;ETHIOPIC SYLLABLE SEE&quot;<br/>
 printf &quot;%04X&quot;, charnames::vianame(&quot;GOTHIC LETTER AHSA&quot;); # prints<br/>
                                                          # &quot;10330&quot;<br/>
 print charnames::vianame(&quot;LATIN CAPITAL LETTER A&quot;); # prints 65 on<br/>
                                                     # ASCII platforms;<br/>
                                                     # 193 on EBCDIC<br/>
 print charnames::string_vianame(&quot;LATIN CAPITAL LETTER A&quot;); # prints &quot;A&quot;<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> Pragma &quot;use charnames&quot; is used to gain access to the names of the Unicode characters and named character sequences, and to allow you to define your own character and character sequence names.<div class="spacer">
</div>
All forms of the pragma enable use of the following 3 functions:<dl>
<dt>
&#8226;</dt>
<dd>
&quot;charnames::string_vianame(<i>name</i>)&quot; for run-time lookup of a either a character name or a named character sequence, returning its string representation</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;charnames::vianame(<i>name</i>)&quot; for run-time lookup of a character name (but not a named character sequence) to get its ordinal value (code point)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;charnames::viacode(<i>code</i>)&quot; for run-time lookup of a code point to get its Unicode name.</dd>
</dl>
<div class="spacer">
</div>
All forms other than &quot;use&#160;charnames&#160;();&quot; also enable the use of &quot;\N{ <i>CHARNAME</i>}&quot; sequences to compile a Unicode character into a string, based on its name.<div class="spacer">
</div>
Note that &quot;\N{U+<i>...</i>}&quot;, where the <i>...</i> is a hexadecimal number, also inserts a character into a string, but doesn't require the use of this pragma.  The character it inserts is the one whose code point (ordinal value) is equal to the number.  For example, &quot;\N{U+263a}&quot; is the Unicode (white background, black foreground) smiley face; it doesn't require this pragma, whereas the equivalent, &quot;\N{WHITE SMILING FACE}&quot; does. Also, &quot;\N{ <i>...</i>}&quot; can mean a regex quantifier instead of a character name, when the  <i>...</i> is a number (or comma separated pair of numbers (see &quot;QUANTIFIERS&quot; in perlreref), and is not related to this pragma.<div class="spacer">
</div>
The &quot;charnames&quot; pragma supports arguments &quot;:full&quot;, &quot;:short&quot;, script names and customized aliases.  If &quot;:full&quot; is present, for expansion of &quot;\N{ <i>CHARNAME</i>}&quot;, the string <i>CHARNAME</i> is first looked up in the list of standard Unicode character names.  If &quot;:short&quot; is present, and  <i>CHARNAME</i> has the form &quot;<i>SCRIPT</i>:<i>CNAME</i>&quot;, then <i>CNAME</i> is looked up as a letter in script  <i>SCRIPT</i>.  If &quot;use charnames&quot; is used with script name arguments, then for &quot;\N{ <i>CHARNAME</i>}&quot; the name  <i>CHARNAME</i> is looked up as a letter in the given scripts (in the specified order). Customized aliases can override these, and are explained in &quot;CUSTOM ALIASES&quot;.<div class="spacer">
</div>
For lookup of <i>CHARNAME</i> inside a given script <i>SCRIPTNAME</i> this pragma looks for the names<div class="spacer">
</div>
<br/>
  SCRIPTNAME CAPITAL LETTER CHARNAME<br/>
  SCRIPTNAME SMALL LETTER CHARNAME<br/>
  SCRIPTNAME LETTER CHARNAME<br/>
<div class="spacer">
</div>
in the table of standard Unicode names.  If <i>CHARNAME</i> is lowercase, then the &quot;CAPITAL&quot; variant is ignored, otherwise the &quot;SMALL&quot; variant is ignored.<div class="spacer">
</div>
Note that &quot;\N{...}&quot; is compile-time; it's a special form of string constant used inside double-quotish strings; this means that you cannot use variables inside the &quot;\N{...}&quot;.  If you want similar run-time functionality, use  <i>charnames::string_vianame()</i>.<div class="spacer">
</div>
For the C0 and C1 control characters (U+0000..U+001F, U+0080..U+009F) there are no official Unicode names but you can use instead the ISO 6429 names (LINE FEED, ESCAPE, and so forth, and their abbreviations, LF, ESC, ...).  In Unicode 3.2 (as of Perl 5.8) some naming changes took place, and ISO 6429 was updated, see &quot;ALIASES&quot;.<div class="spacer">
</div>
If the input name is unknown, &quot;\N{NAME}&quot; raises a warning and substitutes the Unicode REPLACEMENT CHARACTER (U+FFFD).<div class="spacer">
</div>
For &quot;\N{NAME}&quot;, it is a fatal error if &quot;use bytes&quot; is in effect and the input name is that of a character that won't fit into a byte (i.e., whose ordinal is above 255).<div class="spacer">
</div>
Otherwise, any string that includes a &quot;\N{<i>charname</i>}&quot; or &quot;\N{U+ <i>code&#160;point</i>}&quot; will automatically have Unicode semantics (see &quot;Byte and Character Semantics&quot; in perlunicode).</div>
<div class="section">
<h1>ALIASES</h1> A few aliases have been defined for convenience: instead of having to use the official names<div class="spacer">
</div>
<br/>
    LINE FEED (LF)<br/>
    FORM FEED (FF)<br/>
    CARRIAGE RETURN (CR)<br/>
    NEXT LINE (NEL)<br/>
<div class="spacer">
</div>
(yes, with parentheses), one can use<div class="spacer">
</div>
<br/>
    LINE FEED<br/>
    FORM FEED<br/>
    CARRIAGE RETURN<br/>
    NEXT LINE<br/>
    LF<br/>
    FF<br/>
    CR<br/>
    NEL<br/>
<div class="spacer">
</div>
All the other standard abbreviations for the controls, such as &quot;ACK&quot; for &quot;ACKNOWLEDGE&quot; also can be used.<div class="spacer">
</div>
One can also use<div class="spacer">
</div>
<br/>
    BYTE ORDER MARK<br/>
    BOM<br/>
<div class="spacer">
</div>
and these abbreviations<div class="spacer">
</div>
<br/>
    Abbreviation        Full Name<br/>
<br/>
    CGJ                 COMBINING GRAPHEME JOINER<br/>
    FVS1                MONGOLIAN FREE VARIATION SELECTOR ONE<br/>
    FVS2                MONGOLIAN FREE VARIATION SELECTOR TWO<br/>
    FVS3                MONGOLIAN FREE VARIATION SELECTOR THREE<br/>
    LRE                 LEFT-TO-RIGHT EMBEDDING<br/>
    LRM                 LEFT-TO-RIGHT MARK<br/>
    LRO                 LEFT-TO-RIGHT OVERRIDE<br/>
    MMSP                MEDIUM MATHEMATICAL SPACE<br/>
    MVS                 MONGOLIAN VOWEL SEPARATOR<br/>
    NBSP                NO-BREAK SPACE<br/>
    NNBSP               NARROW NO-BREAK SPACE<br/>
    PDF                 POP DIRECTIONAL FORMATTING<br/>
    RLE                 RIGHT-TO-LEFT EMBEDDING<br/>
    RLM                 RIGHT-TO-LEFT MARK<br/>
    RLO                 RIGHT-TO-LEFT OVERRIDE<br/>
    SHY                 SOFT HYPHEN<br/>
    VS1                 VARIATION SELECTOR-1<br/>
    .<br/>
    .<br/>
    .<br/>
    VS256               VARIATION SELECTOR-256<br/>
    WJ                  WORD JOINER<br/>
    ZWJ                 ZERO WIDTH JOINER<br/>
    ZWNJ                ZERO WIDTH NON-JOINER<br/>
    ZWSP                ZERO WIDTH SPACE<br/>
<div class="spacer">
</div>
For backward compatibility one can use the old names for certain C0 and C1 controls<div class="spacer">
</div>
<br/>
    old                         new<br/>
<br/>
    FILE SEPARATOR              INFORMATION SEPARATOR FOUR<br/>
    GROUP SEPARATOR             INFORMATION SEPARATOR THREE<br/>
    HORIZONTAL TABULATION       CHARACTER TABULATION<br/>
    HORIZONTAL TABULATION SET   CHARACTER TABULATION SET<br/>
    HORIZONTAL TABULATION WITH JUSTIFICATION    CHARACTER TABULATION<br/>
                                                WITH JUSTIFICATION<br/>
    PARTIAL LINE DOWN           PARTIAL LINE FORWARD<br/>
    PARTIAL LINE UP             PARTIAL LINE BACKWARD<br/>
    RECORD SEPARATOR            INFORMATION SEPARATOR TWO<br/>
    REVERSE INDEX               REVERSE LINE FEED<br/>
    UNIT SEPARATOR              INFORMATION SEPARATOR ONE<br/>
    VERTICAL TABULATION         LINE TABULATION<br/>
    VERTICAL TABULATION SET     LINE TABULATION SET<br/>
<div class="spacer">
</div>
but the old names in addition to giving the character will also give a warning about being deprecated.<div class="spacer">
</div>
And finally, certain published variants are usable, including some for controls that have no Unicode names:<div class="spacer">
</div>
<br/>
    name                                   character<br/>
<br/>
    END OF PROTECTED AREA                  END OF GUARDED AREA, U+0097<br/>
    HIGH OCTET PRESET                      U+0081<br/>
    HOP                                    U+0081<br/>
    IND                                    U+0084<br/>
    INDEX                                  U+0084<br/>
    PAD                                    U+0080<br/>
    PADDING CHARACTER                      U+0080<br/>
    PRIVATE USE 1                          PRIVATE USE ONE, U+0091<br/>
    PRIVATE USE 2                          PRIVATE USE TWO, U+0092<br/>
    SGC                                    U+0099<br/>
    SINGLE GRAPHIC CHARACTER INTRODUCER    U+0099<br/>
    SINGLE-SHIFT 2                         SINGLE SHIFT TWO, U+008E<br/>
    SINGLE-SHIFT 3                         SINGLE SHIFT THREE, U+008F<br/>
    START OF PROTECTED AREA                START OF GUARDED AREA, U+0096<br/>
</div>
<div class="section">
<h1>CUSTOM ALIASES</h1> You can add customized aliases to standard (&quot;:full&quot;) Unicode naming conventions.  The aliases override any standard definitions, so, if you're twisted enough, you can change &quot;\N{LATIN CAPITAL LETTER A}&quot; to mean &quot;B&quot;, etc.<div class="spacer">
</div>
Note that an alias should not be something that is a legal curly brace-enclosed quantifier (see &quot;QUANTIFIERS&quot; in perlreref).  For example &quot;\N{123}&quot; means to match 123 non-newline characters, and is not treated as a charnames alias.  Aliases are discouraged from beginning with anything other than an alphabetic character and from containing anything other than alphanumerics, spaces, dashes, parentheses, and underscores. Currently they must be ASCII.<div class="spacer">
</div>
An alias can map to either an official Unicode character name or to a numeric code point (ordinal).  The latter is useful for assigning names to code points in Unicode private use areas such as U+E800 through U+F8FF. A numeric code point must be a non-negative integer or a string beginning with &quot;U+&quot; or &quot;0x&quot; with the remainder considered to be a hexadecimal integer.  A literal numeric constant must be unsigned; it will be interpreted as hex if it has a leading zero or contains non-decimal hex digits; otherwise it will be interpreted as decimal.<div class="spacer">
</div>
Aliases are added either by the use of anonymous hashes:<div class="spacer">
</div>
<br/>
    use charnames &quot;:alias&quot; =&gt; {<br/>
        e_ACUTE =&gt; &quot;LATIN SMALL LETTER E WITH ACUTE&quot;,<br/>
        mychar1 =&gt; 0xE8000,<br/>
        };<br/>
    my $str = &quot;\N{e_ACUTE}&quot;;<br/>
<div class="spacer">
</div>
or by using a file containing aliases:<div class="spacer">
</div>
<br/>
    use charnames &quot;:alias&quot; =&gt; &quot;pro&quot;;<br/>
<div class="spacer">
</div>
This will try to read &quot;unicore/pro_alias.pl&quot; from the @INC path. This file should return a list in plain perl:<div class="spacer">
</div>
<br/>
    (<br/>
    A_GRAVE         =&gt; &quot;LATIN CAPITAL LETTER A WITH GRAVE&quot;,<br/>
    A_CIRCUM        =&gt; &quot;LATIN CAPITAL LETTER A WITH CIRCUMFLEX&quot;,<br/>
    A_DIAERES       =&gt; &quot;LATIN CAPITAL LETTER A WITH DIAERESIS&quot;,<br/>
    A_TILDE         =&gt; &quot;LATIN CAPITAL LETTER A WITH TILDE&quot;,<br/>
    A_BREVE         =&gt; &quot;LATIN CAPITAL LETTER A WITH BREVE&quot;,<br/>
    A_RING          =&gt; &quot;LATIN CAPITAL LETTER A WITH RING ABOVE&quot;,<br/>
    A_MACRON        =&gt; &quot;LATIN CAPITAL LETTER A WITH MACRON&quot;,<br/>
    mychar2         =&gt; &quot;U+E8001&quot;,<br/>
    );<br/>
<div class="spacer">
</div>
Both these methods insert &quot;:full&quot; automatically as the first argument (if no other argument is given), and you can give the &quot;:full&quot; explicitly as well, like<div class="spacer">
</div>
<br/>
    use charnames &quot;:full&quot;, &quot;:alias&quot; =&gt; &quot;pro&quot;;<br/>
<div class="spacer">
</div>
Also, both these methods currently allow only a single character to be named. To name a sequence of characters, use a custom translator (described below).</div>
<div class="section">
<h1>charnames::viacode(<i>code</i>)</h1> Returns the full name of the character indicated by the numeric code. For example,<div class="spacer">
</div>
<br/>
    print charnames::viacode(0x2722);<br/>
<div class="spacer">
</div>
prints &quot;FOUR TEARDROP-SPOKED ASTERISK&quot;.<div class="spacer">
</div>
The name returned is the official name for the code point, if available; otherwise your custom alias for it.  This means that your alias will only be returned for code points that don't have an official Unicode name (nor Unicode version 1 name), such as private use code points, and the 4 control characters U+0080, U+0081, U+0084, and U+0099. If you define more than one name for the code point, it is indeterminate which one will be returned.<div class="spacer">
</div>
The function returns &quot;undef&quot; if no name is known for the code point. In Unicode the proper name of these is the empty string, which &quot;undef&quot; stringifies to.  (If you ask for a code point past the legal Unicode maximum of U+10FFFF that you haven't assigned an alias to, you get &quot;undef&quot; plus a warning.)<div class="spacer">
</div>
The input number must be a non-negative integer or a string beginning with &quot;U+&quot; or &quot;0x&quot; with the remainder considered to be a hexadecimal integer.  A literal numeric constant must be unsigned; it will be interpreted as hex if it has a leading zero or contains non-decimal hex digits; otherwise it will be interpreted as decimal.<div class="spacer">
</div>
Notice that the name returned for of U+FEFF is &quot;ZERO WIDTH NO-BREAK SPACE&quot;, not &quot;BYTE ORDER MARK&quot;.</div>
<div class="section">
<h1>charnames::string_vianame(<i>name</i>)</h1> This is a runtime equivalent to &quot;\N{...}&quot;.   <i>name</i> can be any expression that evaluates to a name accepted by &quot;\N{...}&quot; under the &quot;:full&quot; option to &quot;charnames&quot;.  In addition, any other options for the controlling &quot;use charnames&quot; in the same scope apply, like any script list, &quot;:short&quot; option, or custom aliases you may have defined.<div class="spacer">
</div>
The only difference is that if the input name is unknown, &quot;string_vianame&quot; returns &quot;undef&quot; instead of the REPLACEMENT CHARACTER and does not raise a warning message.</div>
<div class="section">
<h1>charnames::vianame(<i>name</i>)</h1> This is similar to &quot;string_vianame&quot;.  The main difference is that under most circumstances (see &quot;BUGS&quot; for the others), vianame returns an ordinal code point, whereas &quot;string_vianame&quot; returns a string.  For example,<div class="spacer">
</div>
<br/>
   printf &quot;U+%04X&quot;, charnames::vianame(&quot;FOUR TEARDROP-SPOKED ASTERISK&quot;);<br/>
<div class="spacer">
</div>
prints &quot;U+2722&quot;.<div class="spacer">
</div>
This leads to the other two differences.  Since a single code point is returned, the function can't handle named character sequences, as these are composed of multiple characters.  And, the code point can be that of any character, even ones that aren't legal under the &quot;use&#160;bytes&quot; pragma,</div>
<div class="section">
<h1>CUSTOM TRANSLATORS</h1> The mechanism of translation of &quot;\N{...}&quot; escapes is general and not hardwired into  <i>charnames.pm</i>.  A module can install custom translations (inside the scope which &quot;use&quot;s the module) with the following magic incantation:<div class="spacer">
</div>
<br/>
    sub import {<br/>
        shift;<br/>
        $^H{charnames} = \&amp;translator;<br/>
    }<br/>
<div class="spacer">
</div>
Here <i>translator()</i> is a subroutine which takes <i>CHARNAME</i> as an argument, and returns text to insert into the string instead of the &quot;\N{ <i>CHARNAME</i>}&quot; escape.  Since the text to insert should be different in &quot;bytes&quot; mode and out of it, the function should check the current state of &quot;bytes&quot;-flag as in:<div class="spacer">
</div>
<br/>
    use bytes ();                      # for $bytes::hint_bits<br/>
    sub translator {<br/>
        if ($^H &amp; $bytes::hint_bits) {<br/>
            return bytes_translator(@_);<br/>
        }<br/>
        else {<br/>
            return utf8_translator(@_);<br/>
        }<br/>
    }<br/>
<div class="spacer">
</div>
See &quot;CUSTOM ALIASES&quot; above for restrictions on <i>CHARNAME</i>.<div class="spacer">
</div>
Of course, &quot;vianame&quot; and &quot;viacode&quot; would need to be overridden as well.</div>
<div class="section">
<h1>BUGS</h1> vianame normally returns an ordinal code point, but when the input name is of the form &quot;U+...&quot;, it returns a chr instead.  In this case, if &quot;use bytes&quot; is in effect and the character won't fit into a byte, it returns &quot;undef&quot; and raises a warning.<div class="spacer">
</div>
Names must be ASCII characters only, which means that you are out of luck if you want to create aliases in a language where some or all the characters of the desired aliases are non-ASCII.<div class="spacer">
</div>
Since evaluation of the translation function (see &quot;CUSTOM TRANSLATORS&quot;) happens in the middle of compilation (of a string literal), the translation function should not do any &quot;eval&quot;s or &quot;require&quot;s.  This restriction should be lifted (but is low priority) in a future version of Perl.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-09-26</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

