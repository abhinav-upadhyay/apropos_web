<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
HTML::HeadParser(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
HTML::HeadParser(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
HTML::HeadParser(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> HTML::HeadParser - Parse &lt;HEAD&gt; section of a HTML document</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
 require HTML::HeadParser;<br/>
 $p = HTML::HeadParser-&gt;new;<br/>
 $p-&gt;parse($text) and  print &quot;not finished&quot;;<br/>
<br/>
 $p-&gt;header('Title')          # to access &lt;title&gt;....&lt;/title&gt;<br/>
 $p-&gt;header('Content-Base')   # to access &lt;base href=&quot;http://...&quot;&gt;<br/>
 $p-&gt;header('Foo')            # to access &lt;meta http-equiv=&quot;Foo&quot; content=&quot;...&quot;&gt;<br/>
 $p-&gt;header('X-Meta-Author')  # to access &lt;meta name=&quot;author&quot; content=&quot;...&quot;&gt;<br/>
 $p-&gt;header('X-Meta-Charset') # to access &lt;meta charset=&quot;...&quot;&gt;<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> The &quot;HTML::HeadParser&quot; is a specialized (and lightweight) &quot;HTML::Parser&quot; that will only parse the &lt;HEAD&gt;...&lt;/HEAD&gt; section of an HTML document.  The  <i>parse()</i> method will return a FALSE value as soon as some &lt;BODY&gt; element or body text are found, and should not be called again after this.<div class="spacer">
</div>
Note that the &quot;HTML::HeadParser&quot; might get confused if raw undecoded UTF-8 is passed to the  <i>parse()</i> method.  Make sure the strings are properly decoded before passing them on.<div class="spacer">
</div>
The &quot;HTML::HeadParser&quot; keeps a reference to a header object, and the parser will update this header object as the various elements of the &lt;HEAD&gt; section of the HTML document are recognized.  The following header fields are affected:<dl>
<dt>
Content-Base:</dt>
<dd>
The <i>Content-Base</i> header is initialized from the &lt;base href=&quot;...&quot;&gt; element.</dd>
</dl>
<dl>
<dt>
Title:</dt>
<dd>
The <i>Title</i> header is initialized from the &lt;title&gt;...&lt;/title&gt; element.</dd>
</dl>
<dl>
<dt>
Isindex:</dt>
<dd>
The <i>Isindex</i> header will be added if there is a &lt;isindex&gt; element in the &lt;head&gt;.  The header value is initialized from the  <i>prompt</i> attribute if it is present.  If no <i>prompt</i> attribute is given it will have '?' as the value.</dd>
</dl>
<dl>
<dt>
X-Meta-Foo:</dt>
<dd>
All &lt;meta&gt; elements containing a &quot;name&quot; attribute will result in headers using the prefix &quot;X-Meta-&quot; appended with the value of the &quot;name&quot; attribute as the name of the header, and the value of the &quot;content&quot; attribute as the pushed header value.<div style="height: 1.00em;">
&#160;</div>
&lt;meta&gt; elements containing a &quot;http-equiv&quot; attribute will result in headers as in above, but without the &quot;X-Meta-&quot; prefix in the header name.<div style="height: 1.00em;">
&#160;</div>
&lt;meta&gt; elements containing a &quot;charset&quot; attribute will result in an &quot;X-Meta-Charset&quot; header, using the value of the &quot;charset&quot; attribute as the pushed header value.</dd>
</dl>
</div>
<div class="section">
<h1>METHODS</h1> The following methods (in addition to those provided by the superclass) are available:<dl>
<dt>
$hp = HTML::HeadParser-&gt;new</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$hp = HTML::HeadParser-&gt;new( $header )</dt>
<dd>
The object constructor.  The optional $header argument should be a reference to an object that implement the  <i>header()</i> and <i>push_header()</i> methods as defined by the &quot;HTTP::Headers&quot; class.  Normally it will be of some class that is a or delegates to the &quot;HTTP::Headers&quot; class.<div style="height: 1.00em;">
&#160;</div>
If no $header is given &quot;HTML::HeadParser&quot; will create an &quot;HTTP::Headers&quot; object by itself (initially empty).</dd>
</dl>
<dl>
<dt>
$hp-&gt;header;</dt>
<dd>
Returns a reference to the header object.</dd>
</dl>
<dl>
<dt>
$hp-&gt;header( $key )</dt>
<dd>
Returns a header value.  It is just a shorter way to write &quot;$hp-&gt;header-&gt;header($key)&quot;.</dd>
</dl>
</div>
<div class="section">
<h1>EXAMPLE</h1><br/>
 $h = HTTP::Headers-&gt;new;<br/>
 $p = HTML::HeadParser-&gt;new($h);<br/>
 $p-&gt;parse(&lt;&lt;EOT);<br/>
 &lt;title&gt;Stupid example&lt;/title&gt;<br/>
 &lt;base href=&quot;http://www.linpro.no/lwp/&quot;&gt;<br/>
 Normal text starts here.<br/>
 EOT<br/>
 undef $p;<br/>
 print $h-&gt;title;   # should print &quot;Stupid example&quot;<br/>
</div>
<div class="section">
<h1>SEE ALSO</h1> HTML::Parser, HTTP::Headers<div class="spacer">
</div>
The &quot;HTTP::Headers&quot; class is distributed as part of the  <i>libwww-perl</i> package.  If you don't have that distribution installed you need to provide the $header argument to the &quot;HTML::HeadParser&quot; constructor with your own object that implements the documented protocol.</div>
<div class="section">
<h1>COPYRIGHT</h1> Copyright 1996-2001 Gisle Aas. All rights reserved.<div class="spacer">
</div>
This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-10-15</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

