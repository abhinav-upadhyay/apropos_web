<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
LWP::Simple(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
LWP::Simple(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
LWP::Simple(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> LWP::Simple - simple procedural interface to LWP</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
 perl -MLWP::Simple -e 'getprint &quot;http://www.sn.no&quot;'<br/>
<br/>
 use LWP::Simple;<br/>
 $content = get(&quot;http://www.sn.no/&quot;);<br/>
 die &quot;Couldn't get it!&quot; unless defined $content;<br/>
<br/>
 if (mirror(&quot;http://www.sn.no/&quot;, &quot;foo&quot;) == RC_NOT_MODIFIED) {<br/>
     ...<br/>
 }<br/>
<br/>
 if (is_success(getprint(&quot;http://www.sn.no/&quot;))) {<br/>
     ...<br/>
 }<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> This module is meant for people who want a simplified view of the libwww-perl library.  It should also be suitable for one-liners.  If you need more control or access to the header fields in the requests sent and responses received, then you should use the full object-oriented interface provided by the &quot;LWP::UserAgent&quot; module.<div class="spacer">
</div>
The following functions are provided (and exported) by this module:<dl>
<dt>
get($url)</dt>
<dd>
The <i>get()</i> function will fetch the document identified by the given URL and return it.  It returns &quot;undef&quot; if it fails.  The $url argument can be either a string or a reference to a URI object.<div style="height: 1.00em;">
&#160;</div>
You will not be able to examine the response code or response headers (like 'Content-Type') when you are accessing the web using this function.  If you need that information you should use the full OO interface (see LWP::UserAgent).</dd>
</dl>
<dl>
<dt>
head($url)</dt>
<dd>
Get document headers. Returns the following 5 values if successful: ($content_type, $document_length, $modified_time, $expires, $server)<div style="height: 1.00em;">
&#160;</div>
Returns an empty list if it fails.  In scalar context returns TRUE if successful.</dd>
</dl>
<dl>
<dt>
getprint($url)</dt>
<dd>
Get and print a document identified by a URL. The document is printed to the selected default filehandle for output (normally STDOUT) as data is received from the network.  If the request fails, then the status code and message are printed on STDERR.  The return value is the HTTP response code.</dd>
</dl>
<dl>
<dt>
getstore($url, $file)</dt>
<dd>
Gets a document identified by a URL and stores it in the file. The return value is the HTTP response code.</dd>
</dl>
<dl>
<dt>
mirror($url, $file)</dt>
<dd>
Get and store a document identified by a URL, using  <i>If-modified-since</i>, and checking the <i>Content-Length</i>.  Returns the HTTP response code.</dd>
</dl>
<div class="spacer">
</div>
This module also exports the HTTP::Status constants and procedures. You can use them when you check the response code from  <i>getprint()</i>,  <i>getstore()</i> or <i>mirror()</i>.  The constants are:<div class="spacer">
</div>
<br/>
   RC_CONTINUE<br/>
   RC_SWITCHING_PROTOCOLS<br/>
   RC_OK<br/>
   RC_CREATED<br/>
   RC_ACCEPTED<br/>
   RC_NON_AUTHORITATIVE_INFORMATION<br/>
   RC_NO_CONTENT<br/>
   RC_RESET_CONTENT<br/>
   RC_PARTIAL_CONTENT<br/>
   RC_MULTIPLE_CHOICES<br/>
   RC_MOVED_PERMANENTLY<br/>
   RC_MOVED_TEMPORARILY<br/>
   RC_SEE_OTHER<br/>
   RC_NOT_MODIFIED<br/>
   RC_USE_PROXY<br/>
   RC_BAD_REQUEST<br/>
   RC_UNAUTHORIZED<br/>
   RC_PAYMENT_REQUIRED<br/>
   RC_FORBIDDEN<br/>
   RC_NOT_FOUND<br/>
   RC_METHOD_NOT_ALLOWED<br/>
   RC_NOT_ACCEPTABLE<br/>
   RC_PROXY_AUTHENTICATION_REQUIRED<br/>
   RC_REQUEST_TIMEOUT<br/>
   RC_CONFLICT<br/>
   RC_GONE<br/>
   RC_LENGTH_REQUIRED<br/>
   RC_PRECONDITION_FAILED<br/>
   RC_REQUEST_ENTITY_TOO_LARGE<br/>
   RC_REQUEST_URI_TOO_LARGE<br/>
   RC_UNSUPPORTED_MEDIA_TYPE<br/>
   RC_INTERNAL_SERVER_ERROR<br/>
   RC_NOT_IMPLEMENTED<br/>
   RC_BAD_GATEWAY<br/>
   RC_SERVICE_UNAVAILABLE<br/>
   RC_GATEWAY_TIMEOUT<br/>
   RC_HTTP_VERSION_NOT_SUPPORTED<br/>
<div class="spacer">
</div>
The HTTP::Status classification functions are:<dl>
<dt>
is_success($rc)</dt>
<dd>
True if response code indicated a successful request.</dd>
</dl>
<dl>
<dt>
is_error($rc)</dt>
<dd>
True if response code indicated that an error occurred.</dd>
</dl>
<div class="spacer">
</div>
The module will also export the LWP::UserAgent object as $ua if you ask for it explicitly.<div class="spacer">
</div>
The user agent created by this module will identify itself as &quot;LWP::Simple/#.##&quot; and will initialize its proxy defaults from the environment (by calling $ua-&gt;env_proxy).</div>
<div class="section">
<h1>CAVEAT</h1> Note that if you are using both LWP::Simple and the very popular CGI.pm module, you may be importing a &quot;head&quot; function from each module, producing a warning like &quot;Prototype mismatch: sub main::head ($) vs none&quot;. Get around this problem by just not importing LWP::Simple's &quot;head&quot; function, like so:<div class="spacer">
</div>
<br/>
        use LWP::Simple qw(!head);<br/>
        use CGI qw(:standard);  # then only CGI.pm defines a head()<br/>
<div class="spacer">
</div>
Then if you do need LWP::Simple's &quot;head&quot; function, you can just call it as &quot;LWP::Simple::head($url)&quot;.</div>
<div class="section">
<h1>SEE ALSO</h1> LWP, lwpcook, LWP::UserAgent, HTTP::Status, lwp-request, lwp-mirror</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-04-09</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

