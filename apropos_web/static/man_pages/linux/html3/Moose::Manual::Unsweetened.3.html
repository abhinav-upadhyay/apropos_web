<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Moose::Manual::Unsweetened(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Moose::Manual::Unsweetened(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
Moose::Manual::Unsweetened(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Moose::Manual::Unsweetened - Moose idioms in plain old Perl 5 without the sugar</div>
<div class="section">
<h1>VERSION</h1> version 2.0401</div>
<div class="section">
<h1>DESCRIPTION</h1> If you're trying to figure out just what the heck Moose does, and how it saves you time, you might find it helpful to see what Moose is  <i>really</i> doing for you. This document shows you the translation from Moose sugar back to plain old Perl 5.</div>
<div class="section">
<h1>CLASSES AND ATTRIBUTES</h1> First, we define two very small classes the Moose way.<div class="spacer">
</div>
<br/>
  package Person;<br/>
<br/>
  use DateTime;<br/>
  use DateTime::Format::Natural;<br/>
  use Moose;<br/>
  use Moose::Util::TypeConstraints;<br/>
<br/>
  has name =&gt; (<br/>
      is       =&gt; 'rw',<br/>
      isa      =&gt; 'Str',<br/>
      required =&gt; 1,<br/>
  );<br/>
<br/>
  # Moose doesn't know about non-Moose-based classes.<br/>
  class_type 'DateTime';<br/>
<br/>
  my $en_parser = DateTime::Format::Natural-&gt;new(<br/>
      lang      =&gt; 'en',<br/>
      time_zone =&gt; 'UTC',<br/>
  );<br/>
<br/>
  coerce 'DateTime'<br/>
      =&gt; from 'Str'<br/>
      =&gt; via { $en_parser-&gt;parse_datetime($_) };<br/>
<br/>
  has birth_date =&gt; (<br/>
      is      =&gt; 'rw',<br/>
      isa     =&gt; 'DateTime',<br/>
      coerce  =&gt; 1,<br/>
      handles =&gt; { birth_year =&gt; 'year' },<br/>
  );<br/>
<br/>
  enum 'ShirtSize' =&gt; qw( s m l xl xxl );<br/>
<br/>
  has shirt_size =&gt; (<br/>
      is      =&gt; 'rw',<br/>
      isa     =&gt; 'ShirtSize',<br/>
      default =&gt; 'l',<br/>
  );<br/>
<div class="spacer">
</div>
This is a fairly simple class with three attributes. We also define an enum type to validate t-shirt sizes because we don't want to end up with something like &quot;blue&quot; for the shirt size!<div class="spacer">
</div>
<br/>
  package User;<br/>
<br/>
  use Email::Valid;<br/>
  use Moose;<br/>
  use Moose::Util::TypeConstraints;<br/>
<br/>
  extends 'Person';<br/>
<br/>
  subtype 'Email'<br/>
      =&gt; as 'Str'<br/>
      =&gt; where { Email::Valid-&gt;address($_) }<br/>
      =&gt; message { &quot;$_ is not a valid email address&quot; };<br/>
<br/>
  has email_address =&gt; (<br/>
      is       =&gt; 'rw',<br/>
      isa      =&gt; 'Email',<br/>
      required =&gt; 1,<br/>
  );<br/>
<div class="spacer">
</div>
This class subclasses Person to add a single attribute, email address.<div class="spacer">
</div>
Now we will show what these classes would look like in plain old Perl 5. For the sake of argument, we won't use any base classes or any helpers like &quot;Class::Accessor&quot;.<div class="spacer">
</div>
<br/>
  package Person;<br/>
<br/>
  use strict;<br/>
  use warnings;<br/>
<br/>
  use Carp qw( confess );<br/>
  use DateTime;<br/>
  use DateTime::Format::Natural;<br/>
<br/>
  sub new {<br/>
      my $class = shift;<br/>
      my %p = ref $_[0] ? %{ $_[0] } : @_;<br/>
<br/>
      exists $p{name}<br/>
          or confess 'name is a required attribute';<br/>
      $class-&gt;_validate_name( $p{name} );<br/>
<br/>
      exists $p{birth_date}<br/>
          or confess 'birth_date is a required attribute';<br/>
<br/>
      $p{birth_date} = $class-&gt;_coerce_birth_date( $p{birth_date} );<br/>
      $class-&gt;_validate_birth_date( $p{birth_date} );<br/>
<br/>
      $p{shirt_size} = 'l'<br/>
          unless exists $p{shirt_size}:<br/>
<br/>
      $class-&gt;_validate_shirt_size( $p{shirt_size} );<br/>
<br/>
      return bless \%p, $class;<br/>
  }<br/>
<br/>
  sub _validate_name {<br/>
      shift;<br/>
      my $name = shift;<br/>
<br/>
      local $Carp::CarpLevel = $Carp::CarpLevel + 1;<br/>
<br/>
      defined $name<br/>
          or confess 'name must be a string';<br/>
  }<br/>
<br/>
  {<br/>
      my $en_parser = DateTime::Format::Natural-&gt;new(<br/>
          lang      =&gt; 'en',<br/>
          time_zone =&gt; 'UTC',<br/>
      );<br/>
<br/>
      sub _coerce_birth_date {<br/>
          shift;<br/>
          my $date = shift;<br/>
<br/>
          return $date unless defined $date &amp;&amp; ! ref $date;<br/>
<br/>
          my $dt = $en_parser-&gt;parse_datetime($date);<br/>
<br/>
          return $dt ? $dt : undef;<br/>
      }<br/>
  }<br/>
<br/>
  sub _validate_birth_date {<br/>
      shift;<br/>
      my $birth_date = shift;<br/>
<br/>
      local $Carp::CarpLevel = $Carp::CarpLevel + 1;<br/>
<br/>
      $birth_date-&gt;isa('DateTime')<br/>
          or confess 'birth_date must be a DateTime object';<br/>
  }<br/>
<br/>
  sub _validate_shirt_size {<br/>
      shift;<br/>
      my $shirt_size = shift;<br/>
<br/>
      local $Carp::CarpLevel = $Carp::CarpLevel + 1;<br/>
<br/>
      defined $shirt_size<br/>
          or confess 'shirt_size cannot be undef';<br/>
<br/>
      my %sizes = map { $_ =&gt; 1 } qw( s m l xl xxl );<br/>
<br/>
      $sizes{$shirt_size}<br/>
          or confess &quot;$shirt_size is not a valid shirt size (s, m, l, xl, xxl)&quot;;<br/>
  }<br/>
<br/>
  sub name {<br/>
      my $self = shift;<br/>
<br/>
      if (@_) {<br/>
          $self-&gt;_validate_name( $_[0] );<br/>
          $self-&gt;{name} = $_[0];<br/>
      }<br/>
<br/>
      return $self-&gt;{name};<br/>
  }<br/>
<br/>
  sub birth_date {<br/>
      my $self = shift;<br/>
<br/>
      if (@_) {<br/>
          my $date = $self-&gt;_coerce_birth_date( $_[0] );<br/>
          $self-&gt;_validate_birth_date( $date );<br/>
<br/>
          $self-&gt;{birth_date} = $date;<br/>
      }<br/>
<br/>
      return $self-&gt;{birth_date};<br/>
  }<br/>
<br/>
  sub birth_year {<br/>
      my $self = shift;<br/>
<br/>
      return $self-&gt;birth_date-&gt;year;<br/>
  }<br/>
<br/>
  sub shirt_size {<br/>
      my $self = shift;<br/>
<br/>
      if (@_) {<br/>
          $self-&gt;_validate_shirt_size( $_[0] );<br/>
          $self-&gt;{shirt_size} = $_[0];<br/>
      }<br/>
<br/>
      return $self-&gt;{shirt_size};<br/>
  }<br/>
<div class="spacer">
</div>
Wow, that was a mouthful! One thing to note is just how much space the data validation code consumes. As a result, it's pretty common for Perl 5 programmers to just not bother. Unfortunately, not validating arguments leads to surprises down the line (&quot;why is birth_date an email address?&quot;).<div class="spacer">
</div>
Also, did you spot the (intentional) bug?<div class="spacer">
</div>
It's in the &quot;_validate_birth_date()&quot; method. We should check that the value in $birth_date is actually defined and an object before we go and call &quot;isa()&quot; on it! Leaving out those checks means our data validation code could actually cause our program to die. Oops.<div class="spacer">
</div>
Note that if we add a superclass to Person we'll have to change the constructor to account for that.<div class="spacer">
</div>
(As an aside, getting all the little details of what Moose does for you just right in this example was really not easy, which emphasizes the point of the example. Moose saves you a lot of work!)<div class="spacer">
</div>
Now let's see User:<div class="spacer">
</div>
<br/>
  package User;<br/>
<br/>
  use strict;<br/>
  use warnings;<br/>
<br/>
  use Carp qw( confess );<br/>
  use Email::Valid;<br/>
  use Scalar::Util qw( blessed );<br/>
<br/>
  use base 'Person';<br/>
<br/>
  sub new {<br/>
      my $class = shift;<br/>
      my %p = ref $_[0] ? %{ $_[0] } : @_;<br/>
<br/>
      exists $p{email_address}<br/>
          or confess 'email_address is a required attribute';<br/>
      $class-&gt;_validate_email_address( $p{email_address} );<br/>
<br/>
      my $self = $class-&gt;SUPER::new(%p);<br/>
<br/>
      $self-&gt;{email_address} = $p{email_address};<br/>
<br/>
      return $self;<br/>
  }<br/>
<br/>
  sub _validate_email_address {<br/>
      shift;<br/>
      my $email_address = shift;<br/>
<br/>
      local $Carp::CarpLevel = $Carp::CarpLevel + 1;<br/>
<br/>
      defined $email_address<br/>
          or confess 'email_address must be a string';<br/>
<br/>
      Email::Valid-&gt;address($email_address)<br/>
          or confess &quot;$email_address is not a valid email address&quot;;<br/>
  }<br/>
<br/>
  sub email_address {<br/>
      my $self = shift;<br/>
<br/>
      if (@_) {<br/>
          $self-&gt;_validate_email_address( $_[0] );<br/>
          $self-&gt;{email_address} = $_[0];<br/>
      }<br/>
<br/>
      return $self-&gt;{email_address};<br/>
  }<br/>
<div class="spacer">
</div>
That one was shorter, but it only has one attribute.<div class="spacer">
</div>
Between the two classes, we have a whole lot of code that doesn't do much. We could probably simplify this by defining some sort of &quot;attribute and validation&quot; hash, like this:<div class="spacer">
</div>
<br/>
  package Person;<br/>
<br/>
  my %Attr = (<br/>
      name =&gt; {<br/>
          required =&gt; 1,<br/>
          validate =&gt; sub { defined $_ },<br/>
      },<br/>
      birth_date =&gt; {<br/>
          required =&gt; 1,<br/>
          validate =&gt; sub { blessed $_ &amp;&amp; $_-&gt;isa('DateTime') },<br/>
      },<br/>
      shirt_size =&gt; {<br/>
          required =&gt; 1,<br/>
          validate =&gt; sub { defined $_ &amp;&amp; $_ =~ /^(?:s|m|l|xl|xxl)$/i },<br/>
      }<br/>
  );<br/>
<div class="spacer">
</div>
Then we could define a base class that would accept such a definition, and do the right thing. Keep that sort of thing up and we're well on our way to writing a half-assed version of Moose!<div class="spacer">
</div>
Of course, there are CPAN modules that do some of what Moose does, like &quot;Class::Accessor&quot;, &quot;Class::Meta&quot;, and so on. But none of them put together all of Moose's features along with a layer of declarative sugar, nor are these other modules designed for extensibility in the same way as Moose. With Moose, it's easy to write a MooseX module to replace or extend a piece of built-in functionality.<div class="spacer">
</div>
Moose is a complete OO package in and of itself, and is part of a rich ecosystem of extensions. It also has an enthusiastic community of users, and is being actively maintained and developed.</div>
<div class="section">
<h1>AUTHOR</h1> Moose is maintained by the Moose Cabal, along with the help of many contributors. See &quot;CABAL&quot; in Moose and &quot;CONTRIBUTORS&quot; in Moose for details.</div>
<div class="section">
<h1>COPYRIGHT AND LICENSE</h1> This software is copyright (c) 2011 by Infinity Interactive, Inc..<div class="spacer">
</div>
This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5 programming language system itself.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-11-17</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

