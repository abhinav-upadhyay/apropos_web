<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Mail::Internet(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Mail::Internet(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
Mail::Internet(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Mail::Internet - manipulate email messages</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
  use Mail::Internet;<br/>
  my $msg = Mail::Internet-&gt;new(\*STDIN);<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> This package implements reading, creating, manipulating, and writing email messages.  Sometimes, the implementation tries to be too smart, but in the general case it works as expected.<div class="spacer">
</div>
If you start writing a <b>new application</b>, you should use the Mail::Box distribution, which has more features and handles messages much better according to the RFCs.  See &lt;http://perl.overmeer.net/mailbox/&gt;. You may also chose MIME::Entity, to get at least some multipart support in your application.</div>
<div class="section">
<h1>METHODS</h1><div class="subsection">
<h2>Constructors</h2><dl>
<dt>
$obj-&gt;<b>dup</b></dt>
<dd>
Duplicate the message as a whole.  Both header and body will be deep-copied: a new Mail::Internet object is returned.</dd>
</dl>
<dl>
<dt>
$obj-&gt;<b>extract</b>(ARRAY-of-LINES)</dt>
<dd>
Extract header and body from an ARRAY of message lines.  Requires an object already created with  <i>new()</i>, which contents will get overwritten.</dd>
</dl>
<dl>
<dt>
$obj-&gt;<b>new</b>([ARG], [OPTIONS])</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Mail::Internet-&gt;<b>new</b>([ARG], [OPTIONS])</dt>
<dd>
ARG is optional and may be either a file descriptor (reference to a GLOB) or a reference to an array. If given the new object will be initialized with headers and body either from the array of read from the file descriptor.<div style="height: 1.00em;">
&#160;</div>
The <i>Mail::Header::new()</i> OPTIONS &quot;Modify&quot;, &quot;MailFrom&quot; and &quot;FoldLength&quot; may also be given.<div style="height: 1.00em;">
&#160;</div>
<br/>
 -Option--Default<br/>
  Body    []<br/>
  Header  undef<br/>
</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
Body =&gt; ARRAY-of-LINES</dt>
<dd>
The value of this option should be a reference to an array which contains the lines for the body of the message. Each line should be terminated with &quot;\n&quot; (LF). If Body is given then &quot;Mail::Internet&quot; will not attempt to read the body from &quot;ARG&quot; (even if it is specified).</dd>
</dl>
<dl>
<dt>
Header =&gt; Mail::Header</dt>
<dd>
The value of this option should be a Mail::Header object. If given then &quot;Mail::Internet&quot; will not attempt to read a mail header from &quot;ARG&quot;, if it was specified.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
</div>
<dl>
<dt>
$obj-&gt;<b>read</b>(FILEHANDLE)</dt>
<dd>
Read a message from the FILEHANDLE into an already existing message object.  Better use  <i>new()</i> with the FILEHANDLE as first argument.</dd>
</dl>
</div>
<div class="subsection">
<h2>Accessors</h2><dl>
<dt>
$obj-&gt;<b>body</b>([BODY])</dt>
<dd>
Returns the body of the message. This is a reference to an array. Each entry in the array represents a single line in the message.<div style="height: 1.00em;">
&#160;</div>
If <i>BODY</i> is given, it can be a reference to an array or an array, then the body will be replaced. If a reference is passed, it is used directly and not copied, so any subsequent changes to the array will change the contents of the body.</dd>
</dl>
<dl>
<dt>
$obj-&gt;<b>head</b></dt>
<dd>
Returns the &quot;Mail::Header&quot; object which holds the headers for the current message</dd>
</dl>
</div>
<div class="subsection">
<h2>Processing the message as a whole</h2><dl>
<dt>
$obj-&gt;<b>as_mbox_string</b>([ALREADY_ESCAPED])</dt>
<dd>
Returns the message as a string in mbox format.  &quot;ALREADY_ESCAPED&quot;, if given and true, indicates that  <i>escape_from()</i> has already been called on this object.</dd>
</dl>
<dl>
<dt>
$obj-&gt;<b>as_string</b></dt>
<dd>
Returns the message as a single string.</dd>
</dl>
<dl>
<dt>
$obj-&gt;<b>print</b>([FILEHANDLE])</dt>
<dd>
Print the header, body or whole message to file descriptor <i>FILEHANDLE</i>.  <i></i><i>$fd</i><i></i> should be a reference to a GLOB. If <i>FILEHANDLE</i> is not given the output will be sent to STDOUT.<div style="height: 1.00em;">
&#160;</div>
example:<div style="height: 1.00em;">
&#160;</div>
<br/>
    $mail-&gt;print( \*STDOUT );  # Print message to STDOUT<br/>
</dd>
</dl>
<dl>
<dt>
$obj-&gt;<b>print_body</b>([FILEHANDLE])</dt>
<dd>
Print only the body to the FILEHANDLE (default STDOUT).</dd>
</dl>
<dl>
<dt>
$obj-&gt;<b>print_header</b>([FILEHANDLE])</dt>
<dd>
Print only the header to the FILEHANDLE (default STDOUT).</dd>
</dl>
</div>
<div class="subsection">
<h2>Processing the header</h2> Most of these methods are simply wrappers around methods provided by Mail::Header.<dl>
<dt>
$obj-&gt;<b>add</b>(PAIRS-of-FIELD)</dt>
<dd>
The PAIRS are field-name and field-content.  For each PAIR,  <i>Mail::Header::add()</i> is called.  All fields are added after existing fields.  The last addition is returned.</dd>
</dl>
<dl>
<dt>
$obj-&gt;<b>combine</b>(TAG, [WITH])</dt>
<dd>
See <i>Mail::Header::combine()</i>.</dd>
</dl>
<dl>
<dt>
$obj-&gt;<b>delete</b>(TAG, [TAGs])</dt>
<dd>
Delete all fields with the name TAG.  <i>Mail::Header::delete()</i> is doing the work.</dd>
</dl>
<dl>
<dt>
$obj-&gt;<b>fold</b>([LENGTH])</dt>
<dd>
See <i>Mail::Header::fold()</i>.</dd>
</dl>
<dl>
<dt>
$obj-&gt;<b>fold_length</b>([TAG], [LENGTH])</dt>
<dd>
See <i>Mail::Header::fold_length()</i>.</dd>
</dl>
<dl>
<dt>
$obj-&gt;<b>get</b>(TAG, [TAGs])</dt>
<dd>
In LIST context, all fields with the name TAG are returned.  In SCALAR context, only the first field which matches the earliest TAG is returned.  <i>Mail::Header::get()</i> is called to collect the data.</dd>
</dl>
<dl>
<dt>
$obj-&gt;<b>header</b>([ARRAY-of-LINES])</dt>
<dd>
See <i>Mail::Header::header()</i>.</dd>
</dl>
<dl>
<dt>
$obj-&gt;<b>replace</b>(PAIRS-of-FIELD)</dt>
<dd>
The PAIRS are field-name and field-content.  For each PAIR,  <i>Mail::Header::replace()</i> is called with INDEX 0. If a FIELD is already in the header, it will be removed first.  Do not specified the same field-name twice.</dd>
</dl>
</div>
<div class="subsection">
<h2>Processing the body</h2><dl>
<dt>
$obj-&gt;<b>remove_sig</b>([NLINES])</dt>
<dd>
Attempts to remove a users signature from the body of a message. It does this by looking for a line equal to '-- ' within the last &quot;NLINES&quot; of the message. If found then that line and all lines after it will be removed. If &quot;NLINES&quot; is not given a default value of 10 will be used. This would be of most use in auto-reply scripts.</dd>
</dl>
<dl>
<dt>
$obj-&gt;<b>sign</b>(OPTIONS)</dt>
<dd>
Add your signature to the body.  <i>remove_sig()</i> will strip existing signatures first.<div style="height: 1.00em;">
&#160;</div>
<br/>
 -Option   --Default<br/>
  File       undef<br/>
  Signature  []<br/>
</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
File =&gt; FILEHANDLE</dt>
<dd>
Take from the FILEHANDLE all lines starting from the first &quot;--&quot;.</dd>
</dl>
<dl>
<dt>
Signature =&gt; STRING|ARRAY-of-LINES</dt>
<dd>
</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
</div>
<dl>
<dt>
$obj-&gt;<b>tidy_body</b></dt>
<dd>
Removes all leading and trailing lines from the body that only contain white spaces.</dd>
</dl>
</div>
<div class="subsection">
<h2>High-level functionality</h2><dl>
<dt>
$obj-&gt;<b>escape_from</b></dt>
<dd>
It can cause problems with some applications if a message contains a line starting with `From ', in particular when attempting to split a folder. This method inserts a leading &quot;`&quot;'&gt; on anyline that matches the regular expression &quot;/^&quot;*From/&gt;</dd>
</dl>
<dl>
<dt>
$obj-&gt;<b>nntppost</b>([OPTIONS])</dt>
<dd>
Post an article via NNTP.  Requires Net::NNTP to be installed.<div style="height: 1.00em;">
&#160;</div>
<br/>
 -Option--Default<br/>
  Debug   &lt;false&gt;<br/>
  Host    &lt;required&gt;<br/>
  Port    119<br/>
</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
Debug =&gt; BOOLEAN</dt>
<dd>
Debug value to pass to Net::NNTP, see Net::NNTP</dd>
</dl>
<dl>
<dt>
Host =&gt; HOSTNAME|Net::NNTP object</dt>
<dd>
Name of NNTP server to connect to, or a Net::NNTP object to use.</dd>
</dl>
<dl>
<dt>
Port =&gt; INTEGER</dt>
<dd>
Port number to connect to on remote host</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
</div>
<dl>
<dt>
$obj-&gt;<b>reply</b>(OPTIONS)</dt>
<dd>
Create a new object with header initialised for a reply to the current object. And the body will be a copy of the current message indented.<div style="height: 1.00em;">
&#160;</div>
The &quot;.mailhdr&quot; file in your home directory (if exists) will be read first, to provide defaults.<div style="height: 1.00em;">
&#160;</div>
<br/>
 -Option  --Default<br/>
  Exclude   []<br/>
  Indent    '&gt;'<br/>
  Keep      []<br/>
  ReplyAll  false<br/>
</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
Exclude =&gt; ARRAY-of-FIELDS</dt>
<dd>
Remove the listed FIELDS from the produced message.</dd>
</dl>
<dl>
<dt>
Indent =&gt; STRING</dt>
<dd>
Use as indentation string.  The string may contain &quot;%%&quot; to get a single &quot;%&quot;, %f to get the first from name, %F is the first character of %f, %l is the last name, %L its first character, %n the whole from string, and %I the first character of each of the names in the from string.</dd>
</dl>
<dl>
<dt>
Keep =&gt; ARRAY-of-FIELDS</dt>
<dd>
Copy the listed FIELDS from the original message.</dd>
</dl>
<dl>
<dt>
ReplyAll =&gt; BOOLEAN</dt>
<dd>
Automatically include all To and Cc addresses of the original mail, excluding those mentioned in the Bcc list.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
</div>
<dl>
<dt>
$obj-&gt;<b>send</b>([TYPE, [ARGS...]])</dt>
<dd>
Send a Mail::Internet message using Mail::Mailer.  TYPE and ARGS are passed on to  <i>Mail::Mailer::new()</i>.</dd>
</dl>
<dl>
<dt>
$obj-&gt;<b>smtpsend</b>([OPTIONS])</dt>
<dd>
Send a Mail::Internet message using direct SMTP.  to the given ADDRESSES, each can be either a string or a reference to a list of email addresses. If none of &quot;To&quot;, &lt;Cc&gt; or &quot;Bcc&quot; are given then the addresses are extracted from the message being sent.<div style="height: 1.00em;">
&#160;</div>
The return value will be a list of email addresses that the message was sent to. If the message was not sent the list will be empty.<div style="height: 1.00em;">
&#160;</div>
Requires Net::SMTP and Net::Domain to be installed.<div style="height: 1.00em;">
&#160;</div>
<br/>
 -Option  --Default<br/>
  Bcc       undef<br/>
  Cc        undef<br/>
  Debug     &lt;false&gt;<br/>
  Hello     localhost.localdomain<br/>
  Host      $ENV{SMTPHOSTS}<br/>
  MailFrom  Mail::Util::mailaddress()<br/>
  Port      25<br/>
  To        undef<br/>
</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
Bcc =&gt; ADDRESSES</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Cc =&gt; ADDRESSES</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Debug =&gt; BOOLEAN</dt>
<dd>
Debug value to pass to Net::SMPT, see &lt;Net::SMTP&gt;</dd>
</dl>
<dl>
<dt>
Hello =&gt; STRING</dt>
<dd>
Send a HELO (or EHLO) command to the server with the given name.</dd>
</dl>
<dl>
<dt>
Host =&gt; HOSTNAME</dt>
<dd>
Name of the SMTP server to connect to, or a Net::SMTP object to use<div style="height: 1.00em;">
&#160;</div>
If &quot;Host&quot; is not given then the SMTP host is found by attempting connections first to hosts specified in $ENV{SMTPHOSTS}, a colon separated list, then &quot;mailhost&quot; and &quot;localhost&quot;.</dd>
</dl>
<dl>
<dt>
MailFrom =&gt; ADDRESS</dt>
<dd>
The e-mail address which is used as sender.  By default,  <i>Mail::Util::mailaddress()</i> provides the address of the sender.</dd>
</dl>
<dl>
<dt>
Port =&gt; INTEGER</dt>
<dd>
Port number to connect to on remote host</dd>
</dl>
<dl>
<dt>
To =&gt; ADDRESSES</dt>
<dd>
</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
</div>
<dl>
<dt>
$obj-&gt;<b>unescape_from</b>(())</dt>
<dd>
Remove the escaping added by <i>escape_from()</i>.</dd>
</dl>
</div>
</div>
<div class="section">
<h1>SEE ALSO</h1> This module is part of the MailTools distribution,  <i>http://perl.overmeer.net/mailtools/</i>.</div>
<div class="section">
<h1>AUTHORS</h1> The MailTools bundle was developed by Graham Barr.  Later, Mark Overmeer took over maintenance without commitment to further development.<div class="spacer">
</div>
Mail::Cap by Gisle Aas &lt;aas@oslonett.no&gt;. Mail::Field::AddrList by Peter Orbaek &lt;poe@cit.dk&gt;. Mail::Mailer and Mail::Send by Tim Bunce &lt;Tim.Bunce@ig.co.uk&gt;. For other contributors see ChangeLog.</div>
<div class="section">
<h1>LICENSE</h1> Copyrights 1995-2000 Graham Barr &lt;gbarr@pobox.com&gt; and 2001-2007 Mark Overmeer &lt;perl@overmeer.net&gt;.<div class="spacer">
</div>
This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself. See  <i>http://www.perl.com/perl/misc/Artistic.html</i></div>
<table class="foot">
<tr>
<td class="foot-date">
2011-06-01</td>
<td class="foot-os">
perl v5.12.3</td>
</tr>
</table>
</div>
</body>
</html>

