<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Config::Model::Backend::IniFile(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Config::Model::Backend::IniFile(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
Config::Model::Backend::IniFile(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Config::Model::Backend::IniFile - Read and write config as a INI file</div>
<div class="section">
<h1>VERSION</h1> version 2.005</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
 use Config::Model;<br/>
 use Log::Log4perl qw(:easy);<br/>
 Log::Log4perl-&gt;easy_init($WARN);<br/>
<br/>
 my $model = Config::Model-&gt;new;<br/>
 $model-&gt;create_config_class (<br/>
    name    =&gt; &quot;IniClass&quot;,<br/>
    element =&gt; [ <br/>
        [qw/foo bar/] =&gt; {<br/>
            type =&gt; 'list',<br/>
            cargo =&gt; {qw/type leaf value_type string/}<br/>
        } <br/>
    ]<br/>
 );<br/>
<br/>
 # model for free INI class name and constrained class parameters<br/>
 $model-&gt;create_config_class(<br/>
    name =&gt; &quot;MyClass&quot;,<br/>
<br/>
    element =&gt; [<br/>
        'ini_class' =&gt; {<br/>
            type   =&gt; 'hash',<br/>
            index_type =&gt; 'string',<br/>
            cargo =&gt; { <br/>
                type =&gt; 'node',<br/>
                config_class_name =&gt; 'IniClass' <br/>
                },<br/>
            },<br/>
    ],<br/>
<br/>
   read_config  =&gt; [<br/>
        { <br/>
            backend =&gt; 'IniFile',<br/>
            config_dir =&gt; '/tmp',<br/>
            file  =&gt; 'foo.conf',<br/>
            store_class_in_hash =&gt; 'ini_class',<br/>
            auto_create =&gt; 1,<br/>
        }<br/>
    ],<br/>
 );<br/>
<br/>
 my $inst = $model-&gt;instance(root_class_name =&gt; 'MyClass' );<br/>
 my $root = $inst-&gt;config_root ;<br/>
<br/>
 $root-&gt;load('ini_class:ONE foo=FOO1 bar=BAR1 - <br/>
              ini_class:TWO foo=FOO2' );<br/>
<br/>
 $inst-&gt;write_back ;<br/>
<div class="spacer">
</div>
Now &quot;/tmp/foo.conf&quot; will contain:<div class="spacer">
</div>
<br/>
 ## file written by Config::Model<br/>
 [ONE]<br/>
 foo=FOO1<br/>
<br/>
 bar=BAR1<br/>
<br/>
 [TWO]<br/>
 foo=FOO2<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> This module is used directly by Config::Model to read or write the content of a configuration tree written with INI syntax in &quot;Config::Model&quot; configuration tree.<div class="spacer">
</div>
This INI file can have arbitrary comment delimiter. See the example in the SYNOPSIS that sets a semi-column as comment delimiter. By default the comment delimiter is '#' like in Shell or Perl.<div class="spacer">
</div>
Note that undefined values are skipped for list element. I.e. if a list element contains &quot;('a',undef,'b')&quot;, the data structure will contain 'a','b'.</div>
<div class="section">
<h1>Comments</h1> This backend tries to read and write comments from configuration file. The comments are stored as annotation within the configuration tree. Bear in mind that comments extraction is based on best estimation as to which parameter the comment may apply. Wrong estimations are possible.</div>
<div class="section">
<h1>CONSTRUCTOR</h1><div class="subsection">
<h2>new ( node =&gt; $node_obj, name =&gt; 'inifile' ) ;</h2> Inherited from Config::Model::Backend::Any. The constructor will be called by Config::Model::AutoRead.</div>
</div>
<div class="section">
<h1>Parameters</h1> Optional parameters declared in the model:<dl>
<dt>
comment_delimiter</dt>
<dd>
Change the character that starts comments in the INI file. Default is '&quot;#&quot;'.</dd>
</dl>
<dl>
<dt>
store_class_in_hash</dt>
<dd>
See &quot;Arbitrary class name&quot;</dd>
</dl>
<dl>
<dt>
section_map</dt>
<dd>
Is a kind of exception of the above rule. See also &quot;Arbitrary class name&quot;</dd>
</dl>
<dl>
<dt>
force_lc_section</dt>
<dd>
Boolean. When set, sections names are converted to lowercase.</dd>
</dl>
<dl>
<dt>
force_lc_key</dt>
<dd>
Idem for key name</dd>
</dl>
<dl>
<dt>
force_lc_value</dt>
<dd>
Idem for all values.</dd>
</dl>
<dl>
<dt>
split_list_value</dt>
<dd>
Some INI values are in fact a list of items separated by a space or a comma. This parameter specifies the regex  to use to split the value into a list. This applies only to &quot;list&quot; elements.</dd>
</dl>
<dl>
<dt>
join_list_value</dt>
<dd>
Conversely, the list element split with &quot;split_list_value&quot; needs to be written back with a string to join them. Specify this string (usually ' ' or ', ') with &quot;join_list_value&quot;.</dd>
</dl>
<dl>
<dt>
write_boolean_as</dt>
<dd>
Array ref. Reserved for boolean value. Specify how to write a boolean value. Default is &quot;[0,1]&quot; which may not be the most readable. &quot;write_boolean_as&quot; can be specified as &quot;['false','true']&quot; or &quot;['no','yes']&quot;.</dd>
</dl>
</div>
<div class="section">
<h1>Mapping between INI structure and model</h1> INI file typically have the same structure with 2 different conventions. The class names can be imposed by the application or may be chosen by user.<div class="subsection">
<h2>Imposed class name</h2> In this case, the class names must match what is expected by the application. The elements of each class can be different. For instance:<div class="spacer">
</div>
<br/>
  foo = foo_v<br/>
  [ A ]<br/>
  bar = bar_v<br/>
  [ B ]<br/>
  baz = baz_v<br/>
<div class="spacer">
</div>
In this case, class &quot;A&quot; and class &quot;B&quot; will not use the same configuration class.<div class="spacer">
</div>
The model will have this structure:<div class="spacer">
</div>
<br/>
 Root class <br/>
 |- leaf element foo<br/>
 |- node element A of class_A<br/>
 |  \- leaf element bar<br/>
 \- node element B of class_B<br/>
    \-  leaf element baz<br/>
</div>
<div class="subsection">
<h2>Arbitrary class name</h2> In this case, the class names can be chosen by the end user. Each class will have the same elements. For instance:<div class="spacer">
</div>
<br/>
  foo = foo_v<br/>
  [ A ]<br/>
  bar = bar_v1<br/>
  [ B ]<br/>
  bar = bar_v2<br/>
<div class="spacer">
</div>
In this case, class &quot;A&quot; and class &quot;B&quot; will not use the same configuration class. The model will have this structure:<div class="spacer">
</div>
<br/>
 Root class <br/>
 |- leaf foo<br/>
 \- hash element my_class_holder<br/>
    |- key A (value is node of class_A)<br/>
    |  \- element-bar<br/>
    \- key B (value is node of class_A)<br/>
       \- element-bar<br/>
<div class="spacer">
</div>
In this case, the &quot;my_class_holder&quot; name is specified in &quot;read_config&quot; with &quot;store_class_in_hash&quot; parameter:<div class="spacer">
</div>
<br/>
    read_config  =&gt; [<br/>
        { <br/>
            backend =&gt; 'IniFile',<br/>
            config_dir =&gt; '/tmp',<br/>
            file  =&gt; 'foo.ini',<br/>
            store_class_in_hash =&gt; 'my_class_holder',<br/>
        }<br/>
    ],<br/>
<div class="spacer">
</div>
Of course they are exceptions. For instance, in &quot;Multistrap&quot;, the &quot;[General]&quot; INI class must be mapped to a specific node object. This can be specified with the &quot;section_map&quot; parameter:<div class="spacer">
</div>
<br/>
    read_config  =&gt; [<br/>
        { <br/>
            backend =&gt; 'IniFile',<br/>
            config_dir =&gt; '/tmp',<br/>
            file  =&gt; 'foo.ini',<br/>
            store_class_in_hash =&gt; 'my_class_holder',<br/>
            section_map =&gt; { <br/>
                General =&gt; 'general_node',<br/>
            }<br/>
        }<br/>
    ],<br/>
<div class="spacer">
</div>
&quot;section_map&quot; can also map an INI class to the root node:<div class="spacer">
</div>
<br/>
    read_config =&gt; [<br/>
        {<br/>
            backend =&gt; 'ini_file',<br/>
            store_class_in_hash =&gt; 'sections',<br/>
            section_map =&gt; {<br/>
                General =&gt; '!'<br/>
            },<br/>
        }<br/>
    ],<br/>
</div>
</div>
<div class="section">
<h1>Methods</h1><div class="subsection">
<h2>read ( io_handle =&gt; ... )</h2> Of all parameters passed to this read call-back, only &quot;io_handle&quot; is used. This parameter must be IO::File object already opened for read.<div class="spacer">
</div>
It can also be undef. In this case, &quot;read()&quot; will return 0.<div class="spacer">
</div>
When a file is read,  &quot;read()&quot; will return 1.</div>
<div class="subsection">
<h2>write ( io_handle =&gt; ... )</h2> Of all parameters passed to this write call-back, only &quot;io_handle&quot; is used. This parameter must be IO::File object already opened for write.<div class="spacer">
</div>
&quot;write()&quot; will return 1.</div>
</div>
<div class="section">
<h1>AUTHOR</h1> Dominique Dumont, (ddumont at cpan dot org); Krzysztof Tyszecki, (krzysztof.tyszecki at gmail dot com)</div>
<div class="section">
<h1>SEE ALSO</h1> Config::Model, Config::Model::AutoRead, Config::Model::Backend::Any,</div>
<table class="foot">
<tr>
<td class="foot-date">
2012-02-24</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

