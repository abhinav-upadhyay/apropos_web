<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Test::Tutorial(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Test::Tutorial(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
Test::Tutorial(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Test::Tutorial - A tutorial about writing really basic tests</div>
<div class="section">
<h1>DESCRIPTION</h1>  <i>AHHHHHHH!!!!  NOT TESTING!  Anything but testing!</i>  <i>Beat me, whip me, send me to Detroit, but don't make</i>  <i>me write tests!</i><div class="spacer">
</div>
<i>*sob*</i><div class="spacer">
</div>
<i>Besides, I don't know how to write the damned things.</i><div class="spacer">
</div>
Is this you?  Is writing tests right up there with writing documentation and having your fingernails pulled out?  Did you open up a test and read<div class="spacer">
</div>
<br/>
    ######## We start with some black magic<br/>
<div class="spacer">
</div>
and decide that's quite enough for you?<div class="spacer">
</div>
It's ok.  That's all gone now.  We've done all the black magic for you.  And here are the tricks...<div class="subsection">
<h2>Nuts and bolts of testing.</h2> Here's the most basic test program.<div class="spacer">
</div>
<br/>
    #!/usr/bin/perl -w<br/>
<br/>
    print &quot;1..1\n&quot;;<br/>
<br/>
    print 1 + 1 == 2 ? &quot;ok 1\n&quot; : &quot;not ok 1\n&quot;;<br/>
<div class="spacer">
</div>
since 1 + 1 is 2, it prints:<div class="spacer">
</div>
<br/>
    1..1<br/>
    ok 1<br/>
<div class="spacer">
</div>
What this says is: 1..1 &quot;I'm going to run one test.&quot; [1] &quot;ok 1&quot; &quot;The first test passed&quot;.  And that's about all magic there is to testing.  Your basic unit of testing is the  <i>ok</i>.  For each thing you test, an &quot;ok&quot; is printed.  Simple.   <b>Test::Harness</b> interprets your test results to determine if you succeeded or failed (more on that later).<div class="spacer">
</div>
Writing all these print statements rapidly gets tedious.  Fortunately, there's  <b>Test::Simple</b>.  It has one function, &quot;ok()&quot;.<div class="spacer">
</div>
<br/>
    #!/usr/bin/perl -w<br/>
<br/>
    use Test::Simple tests =&gt; 1;<br/>
<br/>
    ok( 1 + 1 == 2 );<br/>
<div class="spacer">
</div>
and that does the same thing as the code above.  &quot;ok()&quot; is the backbone of Perl testing, and we'll be using it instead of roll-your-own from here on.  If &quot;ok()&quot; gets a true value, the test passes.  False, it fails.<div class="spacer">
</div>
<br/>
    #!/usr/bin/perl -w<br/>
<br/>
    use Test::Simple tests =&gt; 2;<br/>
    ok( 1 + 1 == 2 );<br/>
    ok( 2 + 2 == 5 );<br/>
<div class="spacer">
</div>
from that comes<div class="spacer">
</div>
<br/>
    1..2<br/>
    ok 1<br/>
    not ok 2<br/>
    #     Failed test (test.pl at line 5)<br/>
    # Looks like you failed 1 tests of 2.<br/>
<div class="spacer">
</div>
1..2 &quot;I'm going to run two tests.&quot;  This number is used to ensure your test program ran all the way through and didn't die or skip some tests.  &quot;ok 1&quot; &quot;The first test passed.&quot;  &quot;not ok 2&quot; &quot;The second test failed&quot;.  Test::Simple helpfully prints out some extra commentary about your tests.<div class="spacer">
</div>
It's not scary.  Come, hold my hand.  We're going to give an example of testing a module.  For our example, we'll be testing a date library,  <b>Date::ICal</b>.  It's on CPAN, so download a copy and follow along. [2]</div>
<div class="subsection">
<h2>Where to start?</h2> This is the hardest part of testing, where do you start?  People often get overwhelmed at the apparent enormity of the task of testing a whole module.  Best place to start is at the beginning.  Date::ICal is an object-oriented module, and that means you start by making an object.  So we test &quot;new()&quot;.<div class="spacer">
</div>
<br/>
    #!/usr/bin/perl -w<br/>
<br/>
    use Test::Simple tests =&gt; 2;<br/>
<br/>
    use Date::ICal;<br/>
<br/>
    my $ical = Date::ICal-&gt;new;         # create an object<br/>
    ok( defined $ical );                # check that we got something<br/>
    ok( $ical-&gt;isa('Date::ICal') );     # and it's the right class<br/>
<div class="spacer">
</div>
run that and you should get:<div class="spacer">
</div>
<br/>
    1..2<br/>
    ok 1<br/>
    ok 2<br/>
<div class="spacer">
</div>
congratulations, you've written your first useful test.</div>
<div class="subsection">
<h2>Names</h2> That output isn't terribly descriptive, is it?  When you have two tests you can figure out which one is #2, but what if you have 102?<div class="spacer">
</div>
Each test can be given a little descriptive name as the second argument to &quot;ok()&quot;.<div class="spacer">
</div>
<br/>
    use Test::Simple tests =&gt; 2;<br/>
<br/>
    ok( defined $ical,              'new() returned something' );<br/>
    ok( $ical-&gt;isa('Date::ICal'),   &quot;  and it's the right class&quot; );<br/>
<div class="spacer">
</div>
So now you'd see...<div class="spacer">
</div>
<br/>
    1..2<br/>
    ok 1 - new() returned something<br/>
    ok 2 -   and it's the right class<br/>
</div>
<div class="subsection">
<h2>Test the manual</h2> Simplest way to build up a decent testing suite is to just test what the manual says it does. [3] Let's pull something out of the &quot;SYNOPSIS&quot; in Date::ICal and test that all its bits work.<div class="spacer">
</div>
<br/>
    #!/usr/bin/perl -w<br/>
<br/>
    use Test::Simple tests =&gt; 8;<br/>
<br/>
    use Date::ICal;<br/>
<br/>
    $ical = Date::ICal-&gt;new( year =&gt; 1964, month =&gt; 10, day =&gt; 16, <br/>
                             hour =&gt; 16, min =&gt; 12, sec =&gt; 47, <br/>
                             tz =&gt; '0530' );<br/>
<br/>
    ok( defined $ical,            'new() returned something' );<br/>
    ok( $ical-&gt;isa('Date::ICal'), &quot;  and it's the right class&quot; );<br/>
    ok( $ical-&gt;sec   == 47,       '  sec()'   );<br/>
    ok( $ical-&gt;min   == 12,       '  min()'   );    <br/>
    ok( $ical-&gt;hour  == 16,       '  hour()'  );<br/>
    ok( $ical-&gt;day   == 17,       '  day()'   );<br/>
    ok( $ical-&gt;month == 10,       '  month()' );<br/>
    ok( $ical-&gt;year  == 1964,     '  year()'  );<br/>
<div class="spacer">
</div>
run that and you get:<div class="spacer">
</div>
<br/>
    1..8<br/>
    ok 1 - new() returned something<br/>
    ok 2 -   and it's the right class<br/>
    ok 3 -   sec()<br/>
    ok 4 -   min()<br/>
    ok 5 -   hour()<br/>
    not ok 6 -   day()<br/>
    #     Failed test (- at line 16)<br/>
    ok 7 -   month()<br/>
    ok 8 -   year()<br/>
    # Looks like you failed 1 tests of 8.<br/>
<div class="spacer">
</div>
Whoops, a failure! [4] Test::Simple helpfully lets us know on what line the failure occurred, but not much else.  We were supposed to get 17, but we didn't.  What did we get??  Dunno.  We'll have to re-run the test in the debugger or throw in some print statements to find out.<div class="spacer">
</div>
Instead, we'll switch from <b>Test::Simple</b> to <b>Test::More</b>.  <b>Test::More</b> does everything  <b>Test::Simple</b> does, and more!  In fact, Test::More does things  <i>exactly</i> the way Test::Simple does.  You can literally swap Test::Simple out and put Test::More in its place.  That's just what we're going to do.<div class="spacer">
</div>
Test::More does more than Test::Simple.  The most important difference at this point is it provides more informative ways to say &quot;ok&quot;. Although you can write almost any test with a generic &quot;ok()&quot;, it can't tell you what went wrong.  Instead, we'll use the &quot;is()&quot; function, which lets us declare that something is supposed to be the same as something else:<div class="spacer">
</div>
<br/>
    #!/usr/bin/perl -w<br/>
<br/>
    use Test::More tests =&gt; 8;<br/>
<br/>
    use Date::ICal;<br/>
<br/>
    $ical = Date::ICal-&gt;new( year =&gt; 1964, month =&gt; 10, day =&gt; 16, <br/>
                             hour =&gt; 16, min =&gt; 12, sec =&gt; 47, <br/>
                             tz =&gt; '0530' );<br/>
<br/>
    ok( defined $ical,            'new() returned something' );<br/>
    ok( $ical-&gt;isa('Date::ICal'), &quot;  and it's the right class&quot; );<br/>
    is( $ical-&gt;sec,     47,       '  sec()'   );<br/>
    is( $ical-&gt;min,     12,       '  min()'   );    <br/>
    is( $ical-&gt;hour,    16,       '  hour()'  );<br/>
    is( $ical-&gt;day,     17,       '  day()'   );<br/>
    is( $ical-&gt;month,   10,       '  month()' );<br/>
    is( $ical-&gt;year,    1964,     '  year()'  );<br/>
<div class="spacer">
</div>
&quot;Is &quot;$ical-&gt;sec&quot; 47?&quot;  &quot;Is &quot;$ical-&gt;min&quot; 12?&quot;  With &quot;is()&quot; in place, you get some more information<div class="spacer">
</div>
<br/>
    1..8<br/>
    ok 1 - new() returned something<br/>
    ok 2 -   and it's the right class<br/>
    ok 3 -   sec()<br/>
    ok 4 -   min()<br/>
    ok 5 -   hour()<br/>
    not ok 6 -   day()<br/>
    #     Failed test (- at line 16)<br/>
    #          got: '16'<br/>
    #     expected: '17'<br/>
    ok 7 -   month()<br/>
    ok 8 -   year()<br/>
    # Looks like you failed 1 tests of 8.<br/>
<div class="spacer">
</div>
letting us know that &quot;$ical-&gt;day&quot; returned 16, but we expected 17.  A quick check shows that the code is working fine, we made a mistake when writing up the tests.  Just change it to:<div class="spacer">
</div>
<br/>
    is( $ical-&gt;day,     16,       '  day()'   );<br/>
<div class="spacer">
</div>
and everything works.<div class="spacer">
</div>
So any time you're doing a &quot;this equals that&quot; sort of test, use &quot;is()&quot;. It even works on arrays.  The test is always in scalar context, so you can test how many elements are in a list this way. [5]<div class="spacer">
</div>
<br/>
    is( @foo, 5, 'foo has 5 elements' );<br/>
</div>
<div class="subsection">
<h2>Sometimes the tests are wrong</h2> Which brings us to a very important lesson.  Code has bugs.  Tests are code.  Ergo, tests have bugs.  A failing test could mean a bug in the code, but don't discount the possibility that the test is wrong.<div class="spacer">
</div>
On the flip side, don't be tempted to prematurely declare a test incorrect just because you're having trouble finding the bug. Invalidating a test isn't something to be taken lightly, and don't use it as a cop out to avoid work.</div>
<div class="subsection">
<h2>Testing lots of values</h2> We're going to be wanting to test a lot of dates here, trying to trick the code with lots of different edge cases.  Does it work before 1970? After 2038?  Before 1904?  Do years after 10,000 give it trouble? Does it get leap years right?  We could keep repeating the code above, or we could set up a little try/expect loop.<div class="spacer">
</div>
<br/>
    use Test::More tests =&gt; 32;<br/>
    use Date::ICal;<br/>
<br/>
    my %ICal_Dates = (<br/>
            # An ICal string     And the year, month, day<br/>
            #                    hour, minute and second we expect.<br/>
            '19971024T120000' =&gt;    # from the docs.<br/>
                                [ 1997, 10, 24, 12,  0,  0 ],<br/>
            '20390123T232832' =&gt;    # after the Unix epoch<br/>
                                [ 2039,  1, 23, 23, 28, 32 ],<br/>
            '19671225T000000' =&gt;    # before the Unix epoch<br/>
                                [ 1967, 12, 25,  0,  0,  0 ],<br/>
            '18990505T232323' =&gt;    # before the MacOS epoch<br/>
                                [ 1899,  5,  5, 23, 23, 23 ],<br/>
    );<br/>
<br/>
<br/>
    while( my($ical_str, $expect) = each %ICal_Dates ) {<br/>
        my $ical = Date::ICal-&gt;new( ical =&gt; $ical_str );<br/>
<br/>
        ok( defined $ical,            &quot;new(ical =&gt; '$ical_str')&quot; );<br/>
        ok( $ical-&gt;isa('Date::ICal'), &quot;  and it's the right class&quot; );<br/>
<br/>
        is( $ical-&gt;year,    $expect-&gt;[0],     '  year()'  );<br/>
        is( $ical-&gt;month,   $expect-&gt;[1],     '  month()' );<br/>
        is( $ical-&gt;day,     $expect-&gt;[2],     '  day()'   );<br/>
        is( $ical-&gt;hour,    $expect-&gt;[3],     '  hour()'  );<br/>
        is( $ical-&gt;min,     $expect-&gt;[4],     '  min()'   );    <br/>
        is( $ical-&gt;sec,     $expect-&gt;[5],     '  sec()'   );<br/>
    }<br/>
<div class="spacer">
</div>
So now we can test bunches of dates by just adding them to %ICal_Dates.  Now that it's less work to test with more dates, you'll be inclined to just throw more in as you think of them. Only problem is, every time we add to that we have to keep adjusting the &quot;use Test::More tests =&gt; ##&quot; line.  That can rapidly get annoying.  There's two ways to make this work better.<div class="spacer">
</div>
First, we can calculate the plan dynamically using the &quot;plan()&quot; function.<div class="spacer">
</div>
<br/>
    use Test::More;<br/>
    use Date::ICal;<br/>
<br/>
    my %ICal_Dates = (<br/>
        ...same as before...<br/>
    );<br/>
<br/>
    # For each key in the hash we're running 8 tests.<br/>
    plan tests =&gt; keys(%ICal_Dates) * 8;<br/>
<br/>
    ...and then your tests...<br/>
<div class="spacer">
</div>
Or to be even more flexible, we use &quot;no_plan&quot;.  This means we're just running some tests, don't know how many. [6]<div class="spacer">
</div>
<br/>
    use Test::More 'no_plan';   # instead of tests =&gt; 32<br/>
<div class="spacer">
</div>
now we can just add tests and not have to do all sorts of math to figure out how many we're running.</div>
<div class="subsection">
<h2>Informative names</h2> Take a look at this line here<div class="spacer">
</div>
<br/>
    ok( defined $ical,            &quot;new(ical =&gt; '$ical_str')&quot; );<br/>
<div class="spacer">
</div>
we've added more detail about what we're testing and the ICal string itself we're trying out to the name.  So you get results like:<div class="spacer">
</div>
<br/>
    ok 25 - new(ical =&gt; '19971024T120000')<br/>
    ok 26 -   and it's the right class<br/>
    ok 27 -   year()<br/>
    ok 28 -   month()<br/>
    ok 29 -   day()<br/>
    ok 30 -   hour()<br/>
    ok 31 -   min()<br/>
    ok 32 -   sec()<br/>
<div class="spacer">
</div>
if something in there fails, you'll know which one it was and that will make tracking down the problem easier.  So try to put a bit of debugging information into the test names.<div class="spacer">
</div>
Describe what the tests test, to make debugging a failed test easier for you or for the next person who runs your test.</div>
<div class="subsection">
<h2>Skipping tests</h2> Poking around in the existing Date::ICal tests, I found this in  <i>t/01sanity.t</i> [7]<div class="spacer">
</div>
<br/>
    #!/usr/bin/perl -w<br/>
<br/>
    use Test::More tests =&gt; 7;<br/>
    use Date::ICal;<br/>
<br/>
    # Make sure epoch time is being handled sanely.<br/>
    my $t1 = Date::ICal-&gt;new( epoch =&gt; 0 );<br/>
    is( $t1-&gt;epoch, 0,          &quot;Epoch time of 0&quot; );<br/>
<br/>
    # XXX This will only work on unix systems.<br/>
    is( $t1-&gt;ical, '19700101Z', &quot;  epoch to ical&quot; );<br/>
<br/>
    is( $t1-&gt;year,  1970,       &quot;  year()&quot;  );<br/>
    is( $t1-&gt;month, 1,          &quot;  month()&quot; );<br/>
    is( $t1-&gt;day,   1,          &quot;  day()&quot;   );<br/>
<br/>
    # like the tests above, but starting with ical instead of epoch<br/>
    my $t2 = Date::ICal-&gt;new( ical =&gt; '19700101Z' );<br/>
    is( $t2-&gt;ical, '19700101Z', &quot;Start of epoch in ICal notation&quot; );<br/>
<br/>
    is( $t2-&gt;epoch, 0,          &quot;  and back to ICal&quot; );<br/>
<div class="spacer">
</div>
The beginning of the epoch is different on most non-Unix operating systems [8].  Even though Perl smooths out the differences for the most part, certain ports do it differently.  MacPerl is one off the top of my head. [9]  So rather than just putting a comment in the test, we can explicitly say it's never going to work and skip the test.<div class="spacer">
</div>
<br/>
    use Test::More tests =&gt; 7;<br/>
    use Date::ICal;<br/>
<br/>
    # Make sure epoch time is being handled sanely.<br/>
    my $t1 = Date::ICal-&gt;new( epoch =&gt; 0 );<br/>
    is( $t1-&gt;epoch, 0,          &quot;Epoch time of 0&quot; );<br/>
<br/>
    SKIP: {<br/>
        skip('epoch to ICal not working on MacOS', 6) <br/>
            if $^O eq 'MacOS';<br/>
<br/>
        is( $t1-&gt;ical, '19700101Z', &quot;  epoch to ical&quot; );<br/>
<br/>
        is( $t1-&gt;year,  1970,       &quot;  year()&quot;  );<br/>
        is( $t1-&gt;month, 1,          &quot;  month()&quot; );<br/>
        is( $t1-&gt;day,   1,          &quot;  day()&quot;   );<br/>
<br/>
        # like the tests above, but starting with ical instead of epoch<br/>
        my $t2 = Date::ICal-&gt;new( ical =&gt; '19700101Z' );<br/>
        is( $t2-&gt;ical, '19700101Z', &quot;Start of epoch in ICal notation&quot; );<br/>
<br/>
        is( $t2-&gt;epoch, 0,          &quot;  and back to ICal&quot; );<br/>
    }<br/>
<div class="spacer">
</div>
A little bit of magic happens here.  When running on anything but MacOS, all the tests run normally.  But when on MacOS, &quot;skip()&quot; causes the entire contents of the SKIP block to be jumped over.  It's never run.  Instead, it prints special output that tells Test::Harness that the tests have been skipped.<div class="spacer">
</div>
<br/>
    1..7<br/>
    ok 1 - Epoch time of 0<br/>
    ok 2 # skip epoch to ICal not working on MacOS<br/>
    ok 3 # skip epoch to ICal not working on MacOS<br/>
    ok 4 # skip epoch to ICal not working on MacOS<br/>
    ok 5 # skip epoch to ICal not working on MacOS<br/>
    ok 6 # skip epoch to ICal not working on MacOS<br/>
    ok 7 # skip epoch to ICal not working on MacOS<br/>
<div class="spacer">
</div>
This means your tests won't fail on MacOS.  This means less emails from MacPerl users telling you about failing tests that you know will never work.  You've got to be careful with skip tests.  These are for tests which don't work and  <i>never will</i>.  It is not for skipping genuine bugs (we'll get to that in a moment).<div class="spacer">
</div>
The tests are wholly and completely skipped. [10]  This will work.<div class="spacer">
</div>
<br/>
    SKIP: {<br/>
        skip(&quot;I don't wanna die!&quot;);<br/>
<br/>
        die, die, die, die, die;<br/>
    }<br/>
</div>
<div class="subsection">
<h2>Todo tests</h2> Thumbing through the Date::ICal man page, I came across this:<div class="spacer">
</div>
<br/>
   ical<br/>
<br/>
       $ical_string = $ical-&gt;ical;<br/>
<br/>
   Retrieves, or sets, the date on the object, using any<br/>
   valid ICal date/time string.<br/>
<div class="spacer">
</div>
&quot;Retrieves or sets&quot;.  Hmmm, didn't see a test for using &quot;ical()&quot; to set the date in the Date::ICal test suite.  So I'll write one.<div class="spacer">
</div>
<br/>
    use Test::More tests =&gt; 1;<br/>
    use Date::ICal;<br/>
<br/>
    my $ical = Date::ICal-&gt;new;<br/>
    $ical-&gt;ical('20201231Z');<br/>
    is( $ical-&gt;ical, '20201231Z',   'Setting via ical()' );<br/>
<div class="spacer">
</div>
run that and I get<div class="spacer">
</div>
<br/>
    1..1<br/>
    not ok 1 - Setting via ical()<br/>
    #     Failed test (- at line 6)<br/>
    #          got: '20010814T233649Z'<br/>
    #     expected: '20201231Z'<br/>
    # Looks like you failed 1 tests of 1.<br/>
<div class="spacer">
</div>
Whoops!  Looks like it's unimplemented.  Let's assume we don't have the time to fix this. [11] Normally, you'd just comment out the test and put a note in a todo list somewhere.  Instead, we're going to explicitly state &quot;this test will fail&quot; by wrapping it in a &quot;TODO&quot; block.<div class="spacer">
</div>
<br/>
    use Test::More tests =&gt; 1;<br/>
<br/>
    TODO: {<br/>
        local $TODO = 'ical($ical) not yet implemented';<br/>
<br/>
        my $ical = Date::ICal-&gt;new;<br/>
        $ical-&gt;ical('20201231Z');<br/>
<br/>
        is( $ical-&gt;ical, '20201231Z',   'Setting via ical()' );<br/>
    }<br/>
<div class="spacer">
</div>
Now when you run, it's a little different:<div class="spacer">
</div>
<br/>
    1..1<br/>
    not ok 1 - Setting via ical() # TODO ical($ical) not yet implemented<br/>
    #          got: '20010822T201551Z'<br/>
    #     expected: '20201231Z'<br/>
<div class="spacer">
</div>
Test::More doesn't say &quot;Looks like you failed 1 tests of 1&quot;.  That '# TODO' tells Test::Harness &quot;this is supposed to fail&quot; and it treats a failure as a successful test.  So you can write tests even before you've fixed the underlying code.<div class="spacer">
</div>
If a TODO test passes, Test::Harness will report it &quot;UNEXPECTEDLY SUCCEEDED&quot;.  When that happens, you simply remove the TODO block with &quot;local $TODO&quot; and turn it into a real test.</div>
<div class="subsection">
<h2>Testing with taint mode.</h2> Taint mode is a funny thing.  It's the globalest of all global features.  Once you turn it on, it affects  <i>all</i> code in your program and  <i>all</i> modules used (and all the modules they use).  If a single piece of code isn't taint clean, the whole thing explodes.  With that in mind, it's very important to ensure your module works under taint mode.<div class="spacer">
</div>
It's very simple to have your tests run under taint mode.  Just throw a &quot;-T&quot; into the &quot;#!&quot; line.  Test::Harness will read the switches in &quot;#!&quot; and use them to run your tests.<div class="spacer">
</div>
<br/>
    #!/usr/bin/perl -Tw<br/>
<br/>
    ...test normally here...<br/>
<div class="spacer">
</div>
So when you say &quot;make test&quot; it will be run with taint mode and warnings on.</div>
</div>
<div class="section">
<h1>FOOTNOTES</h1><dl>
<dt>
1.</dt>
<dd>
The first number doesn't really mean anything, but it has to be 1. It's the second number that's important.</dd>
</dl>
<dl>
<dt>
2.</dt>
<dd>
For those following along at home, I'm using version 1.31.  It has some bugs, which is good -- we'll uncover them with our tests.</dd>
</dl>
<dl>
<dt>
3.</dt>
<dd>
You can actually take this one step further and test the manual itself.  Have a look at  <b>Test::Inline</b> (formerly <b>Pod::Tests</b>).</dd>
</dl>
<dl>
<dt>
4.</dt>
<dd>
Yes, there's a mistake in the test suite.  What!  Me, contrived?</dd>
</dl>
<dl>
<dt>
5.</dt>
<dd>
We'll get to testing the contents of lists later.</dd>
</dl>
<dl>
<dt>
6.</dt>
<dd>
But what happens if your test program dies halfway through?!  Since we didn't say how many tests we're going to run, how can we know it failed?  No problem, Test::More employs some magic to catch that death and turn the test into a failure, even if every test passed up to that point.</dd>
</dl>
<dl>
<dt>
7.</dt>
<dd>
I cleaned it up a little.</dd>
</dl>
<dl>
<dt>
8.</dt>
<dd>
Most Operating Systems record time as the number of seconds since a certain date.  This date is the beginning of the epoch.  Unix's starts at midnight January 1st, 1970 GMT.</dd>
</dl>
<dl>
<dt>
9.</dt>
<dd>
MacOS's epoch is midnight January 1st, 1904.  VMS's is midnight, November 17th, 1858, but vmsperl emulates the Unix epoch so it's not a problem.</dd>
</dl>
<dl>
<dt>
10.</dt>
<dd>
As long as the code inside the SKIP block at least compiles.  Please don't ask how.  No, it's not a filter.</dd>
</dl>
<dl>
<dt>
11.</dt>
<dd>
Do NOT be tempted to use TODO tests as a way to avoid fixing simple bugs!</dd>
</dl>
</div>
<div class="section">
<h1>AUTHORS</h1> Michael G Schwern &lt;schwern@pobox.com&gt; and the perl-qa dancers!</div>
<div class="section">
<h1>COPYRIGHT</h1> Copyright 2001 by Michael G Schwern &lt;schwern@pobox.com&gt;.<div class="spacer">
</div>
This documentation is free; you can redistribute it and/or modify it under the same terms as Perl itself.<div class="spacer">
</div>
Irrespective of its distribution, all code examples in these files are hereby placed into the public domain.  You are permitted and encouraged to use this code in your own programs for fun or for profit as you see fit.  A simple comment in the code giving credit would be courteous but is not required.</div>
<table class="foot">
<tr>
<td class="foot-date">
2010-12-30</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

