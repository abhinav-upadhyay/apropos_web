<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Pod::POM(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Pod::POM(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
Pod::POM(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Pod::POM - POD Object Model</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
    use Pod::POM;<br/>
<br/>
    my $parser = Pod::POM-&gt;new(\%options);<br/>
<br/>
    # parse from a text string<br/>
    my $pom = $parser-&gt;parse_text($text)<br/>
        || die $parser-&gt;error();<br/>
<br/>
    # parse from a file specified by name or filehandle<br/>
    my $pom = $parser-&gt;parse_file($file)<br/>
        || die $parser-&gt;error();<br/>
<br/>
    # parse from text or file <br/>
    my $pom = $parser-&gt;parse($text_or_file)<br/>
        || die $parser-&gt;error();<br/>
<br/>
    # examine any warnings raised<br/>
    foreach my $warning ($parser-&gt;warnings()) {<br/>
        warn $warning, &quot;\n&quot;;<br/>
    }<br/>
<br/>
    # print table of contents using each =head1 title<br/>
    foreach my $head1 ($pom-&gt;head1()) {<br/>
        print $head1-&gt;title(), &quot;\n&quot;;<br/>
    }<br/>
<br/>
    # print each section<br/>
    foreach my $head1 ($pom-&gt;head1()) {<br/>
        print $head1-&gt;title(), &quot;\n&quot;;<br/>
        print $head1-&gt;content();<br/>
    }<br/>
<br/>
    # print the entire document as HTML<br/>
    use Pod::POM::View::HTML;<br/>
    print Pod::POM::View::HTML-&gt;print($pom);<br/>
<br/>
    # create custom view<br/>
    package My::View;<br/>
    use base qw( Pod::POM::View::HTML );<br/>
<br/>
    sub view_head1 {<br/>
        my ($self, $item) = @_;<br/>
        return '&lt;h1&gt;', <br/>
               $item-&gt;title-&gt;present($self), <br/>
               &quot;&lt;/h1&gt;\n&quot;,<br/>
               $item-&gt;content-&gt;present($self);<br/>
    }<br/>
    <br/>
    package main;<br/>
    print My::View-&gt;print($pom);<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> This module implements a parser to convert Pod documents into a simple object model form known hereafter as the Pod Object Model.  The object model is generated as a hierarchical tree of nodes, each of which represents a different element of the original document.  The tree can be walked manually and the nodes examined, printed or otherwise manipulated.  In addition, Pod::POM supports and provides view objects which can automatically traverse the tree, or section thereof, and generate an output representation in one form or another.<div class="spacer">
</div>
Let's look at a typical Pod document by way of example.<div class="spacer">
</div>
<br/>
    =head1 NAME<br/>
<br/>
    My::Module - just another My::Module<br/>
<br/>
    =head1 DESCRIPTION<br/>
<br/>
    This is My::Module, a deeply funky piece of Perl code.<br/>
<br/>
    =head2 METHODS<br/>
<br/>
    My::Module implements the following methods<br/>
<br/>
    =over 4<br/>
<br/>
    =item new(\%config)<br/>
<br/>
    This is the constructor method.  It accepts the following <br/>
    configuration options:<br/>
<br/>
    =over 4<br/>
<br/>
    =item name<br/>
<br/>
    The name of the thingy.<br/>
<br/>
    =item colour<br/>
<br/>
    The colour of the thingy.<br/>
<br/>
    =back<br/>
<br/>
    =item print()<br/>
<br/>
    This prints the thingy.<br/>
<br/>
    =back<br/>
<br/>
    =head1 AUTHOR<br/>
<br/>
    My::Module was written by me E&lt;lt&gt;me@here.orgE&lt;gt&gt;<br/>
<div class="spacer">
</div>
This document contains 3 main sections, NAME, DESCRIPTION and AUTHOR, each of which is delimited by an opening &quot;=head1&quot; tag. NAME and AUTHOR each contain only a single line of text, but DESCRIPTION is more interesting.  It contains a line of text followed by the &quot;=head2&quot; subsection, METHODS.  This contains a line of text and a list extending from the &quot;=over 4&quot; to the final &quot;=back&quot; just before the AUTHOR section starts.  The list contains 2 items, &quot;new(\%config)&quot;, which itself contains some text and a list of 2 items, and &quot;print()&quot;.<div class="spacer">
</div>
Presented as plain text and using indentation to indicate the element nesting, the model then looks something like this :<div class="spacer">
</div>
<br/>
    NAME<br/>
        My::Module - just another My::Module<br/>
<br/>
    DESCRIPTION<br/>
        This is My::Module, a deeply funky piece of Perl code.<br/>
<br/>
        METHODS<br/>
            My::Module implements the following methods<br/>
<br/>
            * new(\%config)<br/>
                This is the constructor method.  It accepts the <br/>
                following configuration options:<br/>
<br/>
                * name<br/>
                    The name of the thingy.<br/>
<br/>
                * colour<br/>
                    The colour of the thingy.<br/>
<br/>
            * item print()<br/>
                This prints the thingy.<br/>
<br/>
    AUTHOR<br/>
        My::Myodule was written by me &lt;me@here.org&gt;<br/>
<div class="spacer">
</div>
Those of you familiar with XML may prefer to think of it in the following way:<div class="spacer">
</div>
<br/>
    &lt;pod&gt;<br/>
      &lt;head1 title=&quot;NAME&quot;&gt;<br/>
        &lt;p&gt;My::Module - just another My::Module&lt;/p&gt;<br/>
      &lt;/head1&gt;<br/>
<br/>
      &lt;head1 title=&quot;DESCRIPTION&quot;&gt;<br/>
        &lt;p&gt;This is My::Module, a deeply funky piece of <br/>
           Perl code.&lt;/p&gt;<br/>
<br/>
        &lt;head2 title=&quot;METHODS&quot;&gt;<br/>
          &lt;p&gt;My::Module implements the following methods&lt;/p&gt;<br/>
<br/>
          &lt;over indent=4&gt;<br/>
            &lt;item title=&quot;item new(\%config)&quot;&gt;<br/>
              &lt;p&gt;This is the constructor method.  It accepts<br/>
                 the following configuration options:&lt;/p&gt;<br/>
<br/>
              &lt;over indent=4&gt;<br/>
                &lt;item title=&quot;name&quot;&gt;<br/>
                  &lt;p&gt;The name of the thingy.&lt;/p&gt;<br/>
                &lt;/item&gt;<br/>
<br/>
                &lt;item title=&quot;colour&quot;&gt;<br/>
                  &lt;p&gt;The colour of the thingy.&lt;/p&gt;<br/>
                &lt;/item&gt;<br/>
              &lt;/over&gt;<br/>
            &lt;/item&gt;<br/>
<br/>
            &lt;item title=&quot;print()&quot;&gt;<br/>
              &lt;p&gt;This prints the thingy.&lt;/p&gt;<br/>
            &lt;/item&gt;<br/>
          &lt;/over&gt;<br/>
        &lt;/head2&gt;<br/>
      &lt;/head1&gt;<br/>
<br/>
      &lt;head1 title=&quot;AUTHOR&quot;&gt;<br/>
        &lt;p&gt;My::Myodule was written by me &amp;lt;me@here.org&amp;gt;<br/>
      &lt;/head1&gt;<br/>
    &lt;/pod&gt;<br/>
<div class="spacer">
</div>
Notice how we can make certain assumptions about various elements. For example, we can assume that any &quot;=head1&quot; section we find begins a new section and implicitly ends any previous section.  Similarly, we can assume an &quot;=item&quot; ends when the next one begins, and so on.  In terms of the XML example shown above, we are saying that we're smart enough to add a &quot;&lt;/head1&gt;&quot; element to terminate any previously opened &quot;&lt;head1&gt;&quot; when we find a new &quot;=head1&quot; tag in the input document.<div class="spacer">
</div>
However you like to visualise the content, it all comes down to the same underlying model.  The job of the Pod::POM module is to read an input Pod document and build an object model to represent it in this structured form.<div class="spacer">
</div>
Each node in the tree (i.e. element in the document) is represented by a Pod::POM::Node::* object.  These encapsulate the attributes for an element (such as the title for a &quot;=head1&quot; tag) and also act as containers for further Pod::POM::Node::* objects representing the content of the element.  Right down at the leaf nodes, we have simple object types to represent formatted and verbatim text paragraphs and other basic elements like these.<div class="subsection">
<h2>Parsing Pod</h2> The Pod::POM module implements the methods parse_file($file), parse_text($text) and parse($file_or_text) to parse Pod files and input text.  They return a Pod::POM::Node::Pod object to represent the root of the Pod Object Model, effectively the &quot;&lt;pod&gt;&quot; element in the XML tree shown above.<div class="spacer">
</div>
<br/>
    use Pod::POM;<br/>
<br/>
    my $parser = Pod::POM-&gt;new();<br/>
    my $pom = $parser-&gt;parse_file($filename)<br/>
        || die $parser-&gt;error();<br/>
<div class="spacer">
</div>
The <i>parse()</i>, <i>parse_text()</i> and <i>parse_file()</i> methods return undef on error.  The  <i>error()</i> method can be called to retrieve the error message generated.  Parsing a document may also generate non-fatal warnings.  These can be retrieved via the  <i>warnings()</i> method which returns a reference to a list when called in scalar context or a list of warnings when called in list context.<div class="spacer">
</div>
<br/>
    foreach my $warn ($parser-&gt;warnings()) {<br/>
        warn $warn, &quot;\n&quot;;<br/>
    }<br/>
<div class="spacer">
</div>
Alternatively, the 'warn' configuration option can be set to have warnings automatically raised via &quot;warn()&quot; as they are encountered.<div class="spacer">
</div>
<br/>
    my $parser = Pod::POM-&gt;new( warn =&gt; 1 );<br/>
</div>
<div class="subsection">
<h2>Walking the Object Model</h2> Having parsed a document into an object model, we can then select various items from it.  Each node implements methods (via AUTOLOAD) which correspond to the attributes and content elements permitted within in.<div class="spacer">
</div>
So to fetch the list of '=head1' sections within our parsed document, we would do the following:<div class="spacer">
</div>
<br/>
    my $sections = $pom-&gt;head1();<br/>
<div class="spacer">
</div>
Methods like this will return a list of further Pod::POM::Node::* objects when called in list context or a reference to a list when called in scalar context.  In the latter case, the list is blessed into the Pod::POM::Node::Content class which gives it certain magical properties (more on that later).<div class="spacer">
</div>
Given the list of Pod::POM::Node::Head1 objects returned by the above, we can print the title attributes of each like this:<div class="spacer">
</div>
<br/>
    foreach my $s (@$sections) {<br/>
        print $s-&gt;title();<br/>
    }<br/>
<div class="spacer">
</div>
Let's look at the second section, DESCRIPTION.<div class="spacer">
</div>
<br/>
    my $desc = $sections-&gt;[1];<br/>
<div class="spacer">
</div>
We can print the title of each subsection within it:<div class="spacer">
</div>
<br/>
    foreach my $ss ($desc-&gt;head2()) {<br/>
        print $ss-&gt;title();<br/>
    }<br/>
<div class="spacer">
</div>
Hopefully you're getting the idea by now, so here's a more studly example to print the title for each item contained in the first list within the METHODS section:<div class="spacer">
</div>
<br/>
    foreach my $item ($desc-&gt;head2-&gt;[0]-&gt;over-&gt;[0]-&gt;item) {<br/>
        print $item-&gt;title(), &quot;\n&quot;;<br/>
    }<br/>
</div>
<div class="subsection">
<h2>Element Content</h2> This is all well and good if you know the precise structure of a document in advance.  For those more common cases when you don't, each node that can contain other nodes provides a 'content' method to return a complete list of all the other nodes that it contains. The 'type' method can be called on any node to return its element type (e.g. 'head1', 'head2', 'over', item', etc).<div class="spacer">
</div>
<br/>
    foreach my $item ($pom-&gt;content()) {<br/>
        my $type = $item-&gt;type();<br/>
        if ($type eq 'head1') {<br/>
            ...<br/>
        }<br/>
        elsif ($type eq 'head2') {<br/>
            ...<br/>
        }<br/>
        ...<br/>
    }<br/>
<div class="spacer">
</div>
The content for an element is represented by a reference to a list, blessed into the Pod::POM::Node::Content class.  This provides some magic in the form of an overloaded stringification operator which will automatically print the contents of the list if you print the object itself.  In plain English, or rather, in plain Perl, this means you can do things like the following:<div class="spacer">
</div>
<br/>
    foreach my $head1 ($pom-&gt;head1()) {<br/>
        print '&lt;h1&gt;', $head1-&gt;title(), &quot;&lt;/h1&gt;\n\n&quot;;<br/>
        print $head1-&gt;content();<br/>
    }<br/>
<br/>
    # print all the root content<br/>
    foreach my $item ($pom-&gt;content()) {<br/>
        print $item;<br/>
    }<br/>
<br/>
    # same as above<br/>
    print $pom-&gt;content();<br/>
<div class="spacer">
</div>
In fact, all Pod::POM::Node::* objects provide this same magic, and will attempt to Do The Right Thing to present themselves in the appropriate manner when printed.  Thus, the following are all valid.<div class="spacer">
</div>
<br/>
    print $pom;                 # entire document<br/>
    print $pom-&gt;content;        # content of document<br/>
    print $pom-&gt;head1-&gt;[0];     # just first section<br/>
    print $pom-&gt;head1;          # print all sections<br/>
    foreach my $h1 ($pom-&gt;head1()) {<br/>
        print $h1-&gt;head2();     # print all subsections<br/>
    }<br/>
</div>
<div class="subsection">
<h2>Output Views</h2> To understand how the different elements go about presenting themselves in &quot;the appropriate manner&quot;, we must introduce the concept of a view.  A view is quite simply a particular way of looking at the model.  In real terms, we can think of a view as being some kind of output type generated by a pod2whatever converter.  Notionally we can think in terms of reading in an input document, building a Pod Object Model, and then generating an HTML view of the document, and/or a LaTeX view, a plain text view, and so on.<div class="spacer">
</div>
A view is represented in this case by an object class which contains methods for displaying each of the different element types that could be encountered in any Pod document.  There's a method for displaying &quot;=head1&quot; sections ( <i>view_head1()</i>), another method for displaying &quot;=head2&quot; sections ( <i>view_head2()</i>), one for &quot;=over&quot; (<i>view_over()</i>), another for &quot;=item&quot; ( <i>view_item()</i>) and so on.<div class="spacer">
</div>
If we happen to have a reference to a $node and we know it's a 'head1' node, then we can directly call the right view method to have it displayed properly:<div class="spacer">
</div>
<br/>
    $view = 'Pod::POM::View::HTML';<br/>
    $view-&gt;view_head1($node);<br/>
<div class="spacer">
</div>
Thus our earlier example can be modified to be <i>slightly</i> less laborious and  <i>marginally</i> more flexible.<div class="spacer">
</div>
<br/>
    foreach my $node ($pom-&gt;content) {<br/>
        my $type = $node-&gt;type();<br/>
        if ($type eq 'head1') {<br/>
            print $view-&gt;view_head1($node);<br/>
        }<br/>
        elsif ($type eq 'head2') {<br/>
            print $view-&gt;view_head2($node);<br/>
        }<br/>
        ...<br/>
    }<br/>
<div class="spacer">
</div>
However, this is still far from ideal.  To make life easier, each Pod::POM::Node::* class inherits (or possibly redefines) a &quot;present($view)&quot; method from the Pod::POM::Node base class.  This method expects a reference to a view object passed as an argument, and it simply calls the appropriate  <i>view_xxx()</i> method on the view object, passing itself back as an argument.  In object parlance, this is known as &quot;double dispatch&quot;.  The beauty of it is that you don't need to know what kind of node you have to be able to print it.  You simply pass it a view object and leave it to work out the rest.<div class="spacer">
</div>
<br/>
    foreach my $node ($pom-&gt;content) {<br/>
        print $node-&gt;present($view);<br/>
    }<br/>
<div class="spacer">
</div>
If $node is a Pod::POM::Node::Head1 object, then the view_head1($node) method gets called against the $view object.  Otherwise, if it's a Pod::POM::Node::Head2 object, then the view_head2($node) method is dispatched.  And so on, and so on, with each node knowing what it is and where it's going as if determined by some genetically pre-programmed instinct.  Fullfilling their destinies, so to speak.<div class="spacer">
</div>
Double dispatch allows us to do away with all the explicit type checking and other nonsense and have the node objects themselves worry about where they should be routed to.  At the cost of an extra method call per node, we get programmer convenience, and that's usually a Good Thing.<div class="spacer">
</div>
Let's have a look at how the view and node classes might be implemented.<div class="spacer">
</div>
<br/>
    package Pod::POM::View::HTML;<br/>
<br/>
    sub view_pod {<br/>
        my ($self, $node) = @_;<br/>
        return $node-&gt;content-&gt;present($self);<br/>
    }<br/>
<br/>
    sub view_head1 {<br/>
        my ($self, $node) = @_;<br/>
        return &quot;&lt;h1&gt;&quot;, $node-&gt;title-&gt;present($self), &quot;&lt;/h1&gt;\n\n&quot;<br/>
             . $node-&gt;content-&gt;present($self);<br/>
    }<br/>
<br/>
    sub view_head2 {<br/>
        my ($self, $node) = @_;<br/>
        return &quot;&lt;h2&gt;&quot;, $node-&gt;title-&gt;present($self), &quot;&lt;/h2&gt;\n\n&quot;<br/>
             . $node-&gt;content-&gt;present($self);<br/>
    }<br/>
<br/>
    ...<br/>
<br/>
    package Pod::POM::Node::Pod;<br/>
<br/>
    sub present {<br/>
        my ($self, $view) = @_;<br/>
        $view-&gt;view_pod($self);<br/>
    }<br/>
<br/>
    package Pod::POM::Node::Head1;<br/>
<br/>
    sub present {<br/>
        my ($self, $view) = @_;<br/>
        $view-&gt;view_head1($self);<br/>
    }<br/>
<br/>
    package Pod::POM::Node::Head2;<br/>
<br/>
    sub present {<br/>
        my ($self, $view) = @_;<br/>
        $view-&gt;view_head2($self);<br/>
    }<br/>
<br/>
    ...<br/>
<div class="spacer">
</div>
Some of the view_xxx methods make calls back against the node objects to display their attributes and/or content.  This is shown in, for example, the  <i>view_head1()</i> method above, where the method prints the section title in &quot;&lt;h1&gt;&quot;...&quot;&lt;h1&gt;&quot; tags, followed by the remaining section content.<div class="spacer">
</div>
Note that the <i>title()</i> attribute is printed by calling its <i>present()</i> method, passing on the reference to the current view.  Similarly, the content  <i>present()</i> method is called giving it a chance to Do The Right Thing to present itself correctly via the view object.<div class="spacer">
</div>
There's a good chance that the title attribute is going to be regular text, so we might be tempted to simply print the title rather than call its present method.<div class="spacer">
</div>
<br/>
    sub view_head1 {<br/>
        my ($self, $node) = @_;<br/>
        # not recommended, prefer $node-&gt;title-&gt;present($self)<br/>
        return &quot;&lt;h1&gt;&quot;, $node-&gt;title(), &quot;&lt;/h1&gt;\n\n&quot;, ...<br/>
    }<br/>
<div class="spacer">
</div>
However, it is entirely valid for titles and other element attributes, as well as regular, formatted text blocks to contain code sequences, such like &quot;B&lt;this&gt;&quot; and &quot;I&lt;this&gt;&quot;.  These are used to indicate different markup styles, mark external references or index items, and so on.  What's more, they can be &quot;B&lt;nested I&lt;indefinately&gt;&gt;&quot;.  Pod::POM takes care of all this by parsing such text, along with any embedded sequences, into Yet Another Tree, the root node of which is a Pod::POM::Node::Text object, possibly containing other Pod::POM::Node::Sequence objects.  When the text is presented, the tree is automatically walked and relevant callbacks made against the view for the different sequence types.  The methods called against the view are all prefixed 'view_seq_', e.g. 'view_seq_bold', 'view_seq_italic'.<div class="spacer">
</div>
Now the real magic comes into effect.  You can define one view to render bold/italic text in one style:<div class="spacer">
</div>
<br/>
    package My::View::Text;<br/>
    use base qw( Pod::POM::View::Text );<br/>
<br/>
    sub view_seq_bold {<br/>
        my ($self, $text) = @_;<br/>
        return &quot;*$text*&quot;;<br/>
    }<br/>
<br/>
    sub view_seq_italic {<br/>
        my ($self, $text) = @_;<br/>
        return &quot;_$text_&quot;;<br/>
    }<br/>
<div class="spacer">
</div>
And another view to render it in a different style:<div class="spacer">
</div>
<br/>
    package My::View::HTML;<br/>
    use base qw( Pod::POM::View::HTML );<br/>
<br/>
    sub view_seq_bold {<br/>
        my ($self, $text) = @_;<br/>
        return &quot;&lt;b&gt;$text&lt;/b&gt;&quot;;<br/>
    }<br/>
<br/>
    sub view_seq_italic {<br/>
        my ($self, $text) = @_;<br/>
        return &quot;&lt;i&gt;$text&lt;/i&gt;&quot;;<br/>
    }<br/>
<div class="spacer">
</div>
Then, you can easily view a Pod Object Model in either style:<div class="spacer">
</div>
<br/>
    my $text = 'My::View::Text';<br/>
    my $html = 'My::View::HTML';<br/>
<br/>
    print $pom-&gt;present($text);<br/>
    print $pom-&gt;present($html);<br/>
<div class="spacer">
</div>
And you can apply this technique to any node within the object model.<div class="spacer">
</div>
<br/>
    print $pom-&gt;head1-&gt;[0]-&gt;present($text);<br/>
    print $pom-&gt;head1-&gt;[0]-&gt;present($html);<br/>
<div class="spacer">
</div>
In these examples, the view passed to the <i>present()</i> method has been a class name.  Thus, the view_xxx methods get called as class methods, as if written:<div class="spacer">
</div>
<br/>
    My::View::Text-&gt;view_head1(...);<br/>
<div class="spacer">
</div>
If your view needs to maintain state then you can create a view object and pass that to the  <i>present()</i> method.<div class="spacer">
</div>
<br/>
    my $view = My::View-&gt;new();<br/>
    $node-&gt;present($view);<br/>
<div class="spacer">
</div>
In this case the view_xxx methods get called as object methods.<div class="spacer">
</div>
<br/>
    sub view_head1 {<br/>
        my ($self, $node) = @_;<br/>
        my $title = $node-&gt;title();<br/>
        if ($title eq 'NAME' &amp;&amp; ref $self) {<br/>
            $self-&gt;{ title } = $title();<br/>
        }<br/>
        $self-&gt;SUPER::view_head1($node);<br/>
    }<br/>
<div class="spacer">
</div>
Whenever you print a Pod::POM::Node::* object, or do anything to cause Perl to stringify it (such as including it another quoted string &quot;like $this&quot;), then its  <i>present()</i> method is automatically called.  When called without a view argument, the  <i>present()</i> method uses the default view specified in $Pod::POM::DEFAULT_VIEW, which is, by default, 'Pod::POM::View::Pod'.  This view regenerates the original Pod document, although it should be noted that the output generated may not be exactly the same as the input.  The parser is smart enough to detect some common errors (e.g. not terminating an &quot;=over&quot; with a &quot;=back&quot;) and correct them automatically.  Thus you might find a &quot;=back&quot; correctly placed in the output, even if you forgot to add it to the input.  Such corrections raise non-fatal warnings which can later be examined via the  <i>warnings()</i> method.<div class="spacer">
</div>
You can update the $Pod::POM::DEFAULT_VIEW package variable to set the default view, or call the  <i>default_view()</i> method.  The <i>default_view()</i> method will automatically load any package you specify.  If setting the package variable directly, you should ensure that any packages required have been pre-loaded.<div class="spacer">
</div>
<br/>
    use My::View::HTML;<br/>
    $Pod::POM::DEFAULT_VIEW = 'My::View::HTML';<br/>
<div class="spacer">
</div>
or<div class="spacer">
</div>
<br/>
    Pod::POM-&gt;default_view('My::View::HTML');<br/>
</div>
<div class="subsection">
<h2>Template Toolkit Views</h2> One of the motivations for writing this module was to make it easier to customise Pod documentation to your own look and feel or local formatting conventions.  By clearly separating the content (represented by the Pod Object Model) from the presentation style (represented by one or more views) it becomes much easier to achieve this.<div class="spacer">
</div>
The latest version of the Template Toolkit (2.06 at the time of writing) provides a Pod plugin to interface to this module.  It also implements a new (but experimental) VIEW directive which can be used to build different presentation styles for converting Pod to other formats.  The Template Toolkit is available from CPAN:<div class="spacer">
</div>
<br/>
    http://www.cpan.org/modules/by-module/Template/<br/>
<div class="spacer">
</div>
Template Toolkit views are similar to the Pod::POM::View objects described above, except that they allow the presentation style for each Pod component to be written as a template file or block rather than an object method.  The precise syntax and structure of the VIEW directive is subject to change (given that it's still experimental), but at present it can be used to define a view something like this:<div class="spacer">
</div>
<br/>
    [% VIEW myview %]<br/>
<br/>
       [% BLOCK view_head1 %]<br/>
          &lt;h1&gt;[% item.title.present(view) %]&lt;/h1&gt;<br/>
          [% item.content.present(view) %]<br/>
       [% END %]<br/>
 <br/>
       [% BLOCK view_head2 %]<br/>
          &lt;h2&gt;[% item.title.present(view) %]&lt;/h2&gt;<br/>
          [% item.content.present(view) %]<br/>
       [% END %]<br/>
<br/>
       ...<br/>
<br/>
    [% END %]<br/>
<div class="spacer">
</div>
A plugin is provided to interface to the Pod::POM module:<div class="spacer">
</div>
<br/>
    [% USE pod %]<br/>
    [% pom = pod.parse('/path/to/podfile') %]<br/>
<div class="spacer">
</div>
The returned Pod Object Model instance can then be navigated and presented via the view in almost any way imaginable:<div class="spacer">
</div>
<br/>
    &lt;h1&gt;Table of Contents&lt;/h1&gt;<br/>
    &lt;ul&gt;<br/>
    [% FOREACH section = pom.head1 %]<br/>
       &lt;li&gt;[% section.title.present(view) %]<br/>
    [% END %]<br/>
    &lt;/ul&gt;<br/>
<br/>
    &lt;hr&gt;<br/>
<br/>
    [% FOREACH section = pom.head1 %]<br/>
       [% section.present(myview) %]<br/>
    [% END %]<br/>
<div class="spacer">
</div>
You can either pass a reference to the VIEW (myview) to the  <i>present()</i> method of a Pod::POM node:<div class="spacer">
</div>
<br/>
    [% pom.present(myview) %]       # present entire document<br/>
<div class="spacer">
</div>
Or alternately call the <i>print()</i> method on the VIEW, passing the Pod::POM node as an argument:<div class="spacer">
</div>
<br/>
    [% myview.print(pom) %]<br/>
<div class="spacer">
</div>
Internally, the view calls the <i>present()</i> method on the node, passing itself as an argument.  Thus it is equivalent to the previous example.<div class="spacer">
</div>
The Pod::POM node and the view conspire to &quot;Do The Right Thing&quot; to process the right template block for the node.  A reference to the node is available within the template as the 'item' variable.<div class="spacer">
</div>
<br/>
   [% BLOCK view_head2 %]<br/>
      &lt;h2&gt;[% item.title.present(view) %]&lt;/h2&gt;<br/>
      [% item.content.present(view) %]<br/>
   [% END %]<br/>
<div class="spacer">
</div>
The Template Toolkit documentation contains further information on defining and using views.  However, as noted above, this may be subject to change or incomplete pending further development of the VIEW directive.</div>
</div>
<div class="section">
<h1>METHODS</h1><div class="subsection">
<h2>new(\%config)</h2> Constructor method which instantiates and returns a new Pod::POM parser object.<div class="spacer">
</div>
<br/>
    use Pod::POM;<br/>
<br/>
    my $parser = Pod::POM-&gt;new();<br/>
<div class="spacer">
</div>
A reference to a hash array of configuration options may be passed as an argument.<div class="spacer">
</div>
<br/>
    my $parser = Pod::POM-&gt;new( { warn =&gt; 1 } );<br/>
<div class="spacer">
</div>
For convenience, configuration options can also be passed as a list of (key =&gt; value) pairs.<div class="spacer">
</div>
<br/>
    my $parser = Pod::POM-&gt;new( warn =&gt; 1 );<br/>
<div class="spacer">
</div>
The following configuration options are defined:<dl>
<dt>
code</dt>
<dd>
This option can be set to have all non-Pod parts of the input document stored within the object model as 'code' elements, represented by objects of the Pod::POM::Node::Code class.  It is disabled by default and code sections are ignored.<div style="height: 1.00em;">
&#160;</div>
<br/>
    my $parser = Pod::POM-&gt;new( code =&gt; 1 );<br/>
    my $podpom = $parser-&gt;parse(\*DATA);<br/>
<br/>
    foreach my $code ($podpom-&gt;code()) {<br/>
        print &quot;&lt;pre&gt;$code&lt;/pre&gt;\n&quot;;<br/>
    }<br/>
<br/>
    __DATA__<br/>
    This is some program code.<br/>
<br/>
    =head1 NAME<br/>
<br/>
    ...<br/>
<div style="height: 1.00em;">
&#160;</div>
This will generate the output:<div style="height: 1.00em;">
&#160;</div>
<br/>
    &lt;pre&gt;This is some program code.&lt;/pre&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
Note that code elements are stored within the POM element in which they are encountered.  For example, the code element below embedded within between Pod sections is stored in the array which can be retrieved by calling &quot;$podpom-&gt;head1-&gt;[0]-&gt;code()&quot;.<div style="height: 1.00em;">
&#160;</div>
<br/>
    =head1 NAME<br/>
<br/>
    My::Module::Name;<br/>
<br/>
    =cut<br/>
<br/>
    Some program code embedded in Pod.<br/>
<br/>
    =head1 SYNOPSIS<br/>
<br/>
    ...<br/>
</dd>
</dl>
<dl>
<dt>
warn</dt>
<dd>
Non-fatal warnings encountered while parsing a Pod document are stored internally and subsequently available via the  <i>warnings()</i> method.<div style="height: 1.00em;">
&#160;</div>
<br/>
    my $parser = Pod::POM-&gt;new();<br/>
    my $podpom = $parser-&gt;parse_file($filename);<br/>
<br/>
    foreach my $warning ($parser-&gt;warnings()) {<br/>
        warn $warning, &quot;\n&quot;;<br/>
    }<br/>
<div style="height: 1.00em;">
&#160;</div>
The 'warn' option can be set to have warnings raised automatically via &quot;warn()&quot; as and when they are encountered.<div style="height: 1.00em;">
&#160;</div>
<br/>
    my $parser = Pod::POM-&gt;new( warn =&gt; 1 );<br/>
    my $podpom = $parser-&gt;parse_file($filename);<br/>
<div style="height: 1.00em;">
&#160;</div>
If the configuration value is specified as a subroutine reference then the code will be called each time a warning is raised, passing the warning message as an argument.<div style="height: 1.00em;">
&#160;</div>
<br/>
    sub my_warning {<br/>
        my $msg = shift;<br/>
        warn $msg, &quot;\n&quot;;<br/>
    };<br/>
<br/>
    my $parser = Pod::POM-&gt;new( warn =&gt; \&amp;my_warning );<br/>
    my $podpom = $parser-&gt;parse_file($filename);<br/>
</dd>
</dl>
<dl>
<dt>
meta</dt>
<dd>
The 'meta' option can be set to allow &quot;=meta&quot; tags within the Pod document.<div style="height: 1.00em;">
&#160;</div>
<br/>
    my $parser = Pod::POM-&gt;new( meta =&gt; 1 );<br/>
    my $podpom = $parser-&gt;parse_file($filename);<br/>
<div style="height: 1.00em;">
&#160;</div>
This is an experimental feature which is not part of standard POD.  For example:<div style="height: 1.00em;">
&#160;</div>
<br/>
    =meta author Andy Wardley<br/>
<div style="height: 1.00em;">
&#160;</div>
These are made available as metadata items within the root node of the parsed POM.<div style="height: 1.00em;">
&#160;</div>
<br/>
    my $author = $podpom-&gt;metadata('author');<br/>
<div style="height: 1.00em;">
&#160;</div>
See the METADATA section below for further information.</dd>
</dl>
</div>
<div class="subsection">
<h2>parse_file($file)</h2> Parses the file specified by name or reference to a file handle. Returns a reference to a Pod::POM::Node::Pod object which represents the root node of the Pod Object Model on success.  On error, undef is returned and the error message generated can be retrieved by calling  <i>error()</i>.<div class="spacer">
</div>
<br/>
    my $podpom = $parser-&gt;parse_file($filename)<br/>
        || die $parser-&gt;error();<br/>
<br/>
    my $podpom = $parser-&gt;parse_file(\*STDIN)<br/>
        || die $parser-&gt;error();<br/>
<div class="spacer">
</div>
Any warnings encountered can be examined by calling the  <i>warnings()</i> method.<div class="spacer">
</div>
<br/>
    foreach my $warn ($parser-&gt;warnings()) {<br/>
        warn $warn, &quot;\n&quot;;<br/>
    }<br/>
</div>
<div class="subsection">
<h2>parse_text($text)</h2> Parses the Pod text string passed as an argument into a Pod Object Model, as per  <i>parse_file()</i>.</div>
<div class="subsection">
<h2>parse($text_or_$file)</h2> General purpose method which attempts to Do The Right Thing in calling  <i>parse_file()</i> or <i>parse_text()</i> according to the argument passed.<div class="spacer">
</div>
A hash reference can be passed as an argument that contains a 'text' or 'file' key and corresponding value.<div class="spacer">
</div>
<br/>
    my $podpom = $parser-&gt;parse({ file =&gt; $filename })<br/>
        || die $parser-&gt;error();<br/>
<div class="spacer">
</div>
Otherwise, the argument can be a reference to an input handle which is passed off to  <i>parse_file()</i>.<div class="spacer">
</div>
<br/>
    my $podpom = $parser-&gt;parse(\*DATA)<br/>
        || die $parser-&gt;error();<br/>
<div class="spacer">
</div>
If the argument is a text string that looks like Pod text (i.e. it contains '=' at the start of any line) then it is passed to  <i>parse_text()</i>.<div class="spacer">
</div>
<br/>
    my $podpom = $parser-&gt;parse($podtext)<br/>
        || die $parser-&gt;error();<br/>
<div class="spacer">
</div>
Otherwise it is assumed to be a filename and is passed to <i>parse_file()</i>.<div class="spacer">
</div>
<br/>
    my $podpom = $parser-&gt;parse($podfile)<br/>
        || die $parser-&gt;error();<br/>
</div>
</div>
<div class="section">
<h1>NODE TYPES, ATTRIBUTES AND ELEMENTS</h1> This section lists the different nodes that may be present in a Pod Object Model.  These are implemented as Pod::POM::Node::* object instances (e.g. head1 =&gt; Pod::POM::Node::Head1).  To present a node, a view should implement a method which corresponds to the node name prefixed by 'view_' (e.g. head1 =&gt;  <i>view_head1()</i>).<dl>
<dt>
pod</dt>
<dd>
The &quot;pod&quot; node is used to represent the root node of the Pod Object Model.<div style="height: 1.00em;">
&#160;</div>
Content elements: head1, head2, head3, head4, over, begin, for, verbatim, text, code.</dd>
</dl>
<dl>
<dt>
head1</dt>
<dd>
A &quot;head1&quot; node contains the Pod content from a &quot;=head1&quot; tag up to the next &quot;=head1&quot; tag or the end of the file.<div style="height: 1.00em;">
&#160;</div>
Attributes: title<div style="height: 1.00em;">
&#160;</div>
Content elements: head2, head3, head4, over, begin, for, verbatim, text, code.</dd>
</dl>
<dl>
<dt>
head2</dt>
<dd>
A &quot;head2&quot; node contains the Pod content from a &quot;=head2&quot; tag up to the next &quot;=head1&quot; or &quot;=head2&quot; tag or the end of the file.<div style="height: 1.00em;">
&#160;</div>
Attributes: title<div style="height: 1.00em;">
&#160;</div>
Content elements: head3, head4, over, begin, for, verbatim, text, code.</dd>
</dl>
<dl>
<dt>
head3</dt>
<dd>
A &quot;head3&quot; node contains the Pod content from a &quot;=head3&quot; tag up to the next &quot;=head1&quot;, &quot;=head2&quot; or &quot;=head3&quot; tag or the end of the file.<div style="height: 1.00em;">
&#160;</div>
Attributes: title<div style="height: 1.00em;">
&#160;</div>
Content elements: head4, over, begin, for, verbatim, text, code.</dd>
</dl>
<dl>
<dt>
head4</dt>
<dd>
A &quot;head4&quot; node contains the Pod content from a &quot;=head4&quot; tag up to the next &quot;=head1&quot;, &quot;=head2&quot;, &quot;=head3&quot; or &quot;=head4&quot; tag or the end of the file.<div style="height: 1.00em;">
&#160;</div>
Attributes: title<div style="height: 1.00em;">
&#160;</div>
Content elements: over, begin, for, verbatim, text, code.</dd>
</dl>
<dl>
<dt>
over</dt>
<dd>
The &quot;over&quot; node encloses the Pod content in a list starting at an &quot;=over&quot; tag and continuing up to the matching &quot;=back&quot; tag.  Lists may be nested indefinately.<div style="height: 1.00em;">
&#160;</div>
Attributes: indent (default: 4)<div style="height: 1.00em;">
&#160;</div>
Content elements: over, item, begin, for, verbatim, text, code.</dd>
</dl>
<dl>
<dt>
item</dt>
<dd>
The &quot;item&quot; node encloses the Pod content in a list item starting at an &quot;=item&quot; tag and continuing up to the next &quot;=item&quot; tag or a &quot;=back&quot; tag which terminates the list.<div style="height: 1.00em;">
&#160;</div>
Attributes: title (default: *)<div style="height: 1.00em;">
&#160;</div>
Content elements: over, begin, for, verbatim, text, code.</dd>
</dl>
<dl>
<dt>
begin</dt>
<dd>
A &quot;begin&quot; node encloses the Pod content in a conditional block starting with a &quot;=begin&quot; tag and continuing up to the next &quot;=end&quot; tag.<div style="height: 1.00em;">
&#160;</div>
Attributes: format<div style="height: 1.00em;">
&#160;</div>
Content elements: verbatim, text, code.</dd>
</dl>
<dl>
<dt>
for</dt>
<dd>
A &quot;for&quot; node contains a single paragraph containing text relevant to a particular format.<div style="height: 1.00em;">
&#160;</div>
Attributes: format, text</dd>
</dl>
<dl>
<dt>
verbatim</dt>
<dd>
A &quot;verbatim&quot; node contains a verbatim text paragraph which is prefixed by whitespace in the source Pod document (i.e. indented).<div style="height: 1.00em;">
&#160;</div>
Attributes: text</dd>
</dl>
<dl>
<dt>
text</dt>
<dd>
A &quot;text&quot; node contains a regular text paragraph.  This may include embedded inline sequences.<div style="height: 1.00em;">
&#160;</div>
Attributes: text</dd>
</dl>
<dl>
<dt>
code</dt>
<dd>
A &quot;code&quot; node contains Perl code which is by default, not considered to be part of a Pod document.  The &quot;code&quot; configuration option must be set for Pod::POM to generate code blocks, otherwise they are ignored.<div style="height: 1.00em;">
&#160;</div>
Attributes: text</dd>
</dl>
</div>
<div class="section">
<h1>INLINE SEQUENCES</h1> Embedded sequences are permitted within regular text blocks (i.e. not verbatim) and title attributes.  To present these sequences, a view should implement methods corresponding to the sequence name, prefixed by 'view_seq_' (e.g. bold =&gt;  <i>view_seq_bold()</i>).<dl>
<dt>
code</dt>
<dd>
Code extract, e.g. C&lt;my code&gt;</dd>
</dl>
<dl>
<dt>
bold</dt>
<dd>
Bold text, e.g. B&lt;bold text&gt;</dd>
</dl>
<dl>
<dt>
italic</dt>
<dd>
Italic text, e.g. I&lt;italic text&gt;</dd>
</dl>
<dl>
<dt>
link</dt>
<dd>
A link (cross reference), e.g. L&lt;My::Module&gt;</dd>
</dl>
<dl>
<dt>
space</dt>
<dd>
Text contains non-breaking space, e.g.S&lt;Buffy The Vampire Slayer&gt;</dd>
</dl>
<dl>
<dt>
file</dt>
<dd>
A filename, e.g. F&lt;/etc/lilo.conf&gt;</dd>
</dl>
<dl>
<dt>
index</dt>
<dd>
An index entry, e.g. X&lt;Angel&gt;</dd>
</dl>
<dl>
<dt>
zero</dt>
<dd>
A zero-width character, e.g. Z&lt;&gt;</dd>
</dl>
<dl>
<dt>
entity</dt>
<dd>
An entity escape, e.g. E&lt;lt&gt;</dd>
</dl>
</div>
<div class="section">
<h1>BUNDLED MODULES AND TOOLS</h1> The Pod::POM module distribution includes a number of sample view objects for rendering Pod Object Models into particular formats.  These are incomplete and may require some further work, but serve at present to illustrate the principal and can be used as the basis for your own view objects.<dl>
<dt>
Pod::POM::View::Pod</dt>
<dd>
Regenerates the model as Pod.</dd>
</dl>
<dl>
<dt>
Pod::POM::View::Text</dt>
<dd>
Presents the model as plain text.</dd>
</dl>
<dl>
<dt>
Pod::POM::View::HTML</dt>
<dd>
Presents the model as HTML.</dd>
</dl>
<div class="spacer">
</div>
A script is provided for converting Pod documents to other format by using the view objects provided.  The &quot;pom2&quot; script should be called with two arguments, the first specifying the output format, the second the input filename.  e.g.<div class="spacer">
</div>
<br/>
    $ pom2 text My/Module.pm &gt; README<br/>
    $ pom2 html My/Module.pm &gt; ~/public_html/My/Module.html<br/>
<div class="spacer">
</div>
You can also create symbolic links to the script if you prefer and leave it to determine the output format from its own name.<div class="spacer">
</div>
<br/>
    $ ln -s pom2 pom2text       <br/>
    $ ln -s pom2 pom2html<br/>
    $ pom2text My/Module.pm &gt; README<br/>
    $ pom2html My/Module.pm &gt; ~/public_html/My/Module.html<br/>
<div class="spacer">
</div>
The distribution also contains a trivial script, &quot;podlint&quot; (previously &quot;pomcheck&quot;), which checks a Pod document for well-formedness by simply parsing it into a Pod Object Model with warnings enabled.  Warnings are printed to STDERR.<div class="spacer">
</div>
<br/>
    $ podlint My/Module.pm<br/>
<div class="spacer">
</div>
The &quot;-f&quot; option can be set to have the script attempt to fix any problems it encounters.  The regenerated Pod output is printed to STDOUT.<div class="spacer">
</div>
<br/>
    $ podlint -f My/Module.pm &gt; newfile<br/>
</div>
<div class="section">
<h1>METADATA</h1> This module includes support for an experimental new &quot;=meta&quot; tag.  This is disabled by default but can be enabled by loading Pod::POM with the &quot;meta&quot; option.<div class="spacer">
</div>
<br/>
    use Pod::POM qw( meta );<br/>
<div class="spacer">
</div>
Alternately, you can specify the &quot;meta&quot; option to be any true value when you instantiate a Pod::POM parser:<div class="spacer">
</div>
<br/>
    my $parser = Pod::POM-&gt;new( meta =&gt; 1 );<br/>
    my $pom    = $parser-&gt;parse_file($filename);<br/>
<div class="spacer">
</div>
Any &quot;=meta&quot; tags in the document will be stored as metadata items in the root node of the Pod model created.<div class="spacer">
</div>
For example:<div class="spacer">
</div>
<br/>
    =meta module Foo::Bar<br/>
<br/>
    =meta author Andy Wardley<br/>
<div class="spacer">
</div>
You can then access these items via the <i>metadata()</i> method.<div class="spacer">
</div>
<br/>
    print &quot;module: &quot;, $pom-&gt;metadata('module'), &quot;\n&quot;;<br/>
    print &quot;author: &quot;, $pom-&gt;metadata('author'), &quot;\n&quot;;<br/>
<div class="spacer">
</div>
or<div class="spacer">
</div>
<br/>
    my $metadata = $pom-&gt;metadata();<br/>
    print &quot;module: $metadata-&gt;{ module }\n&quot;;<br/>
    print &quot;author: $metadata-&gt;{ author }\n&quot;;<br/>
<div class="spacer">
</div>
Please note that this is an experimental feature which is not supported by other POD processors and is therefore likely to be most incompatible.  Use carefully.</div>
<div class="section">
<h1>AUTHOR</h1> Andy Wardley &lt;abw@kfs.org&gt;<div class="spacer">
</div>
Andrew Ford &lt;A.Ford@ford-mason.co.uk&gt; (co-maintainer as of 03/2009)</div>
<div class="section">
<h1>VERSION</h1> This is version 0.25 of the Pod::POM module.</div>
<div class="section">
<h1>COPYRIGHT</h1> Copyright (C) 2000-2009 Andy Wardley.  All Rights Reserved.<div class="spacer">
</div>
This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</div>
<div class="section">
<h1>SEE ALSO</h1> For the definitive reference on Pod, see perlpod.<div class="spacer">
</div>
For an overview of Pod::POM internals and details relating to subclassing of POM nodes, see Pod::POM::Node.<div class="spacer">
</div>
There are numerous other fine Pod modules available from CPAN which perform conversion from Pod to other formats.  In many cases these are likely to be faster and quite possibly more reliable and/or complete than this module.  But as far as I know, there aren't any that offer the same kind of flexibility in being able to customise the generated output.  But don't take my word for it - see your local CPAN site for further details:<div class="spacer">
</div>
<br/>
    http://www.cpan.org/modules/by-module/Pod/<br/>
</div>
<table class="foot">
<tr>
<td class="foot-date">
2010-04-02</td>
<td class="foot-os">
perl v5.10.1</td>
</tr>
</table>
</div>
</body>
</html>

