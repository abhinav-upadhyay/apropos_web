<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
curl_multi_setopt(3)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
curl_multi_setopt(3)</td>
<td class="head-vol">
libcurl Manual</td>
<td class="head-rtitle">
curl_multi_setopt(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> curl_multi_setopt - set options for a curl multi handle</div>
<div class="section">
<h1>SYNOPSIS</h1> #include &lt;curl/curl.h&gt;<div style="height: 1.00em;">
&#160;</div>
CURLMcode curl_multi_setopt(CURLM * multi_handle, CURLMoption option, param);</div>
<div class="section">
<h1>DESCRIPTION</h1> curl_multi_setopt() is used to tell a libcurl multi handle how to behave. By using the appropriate options to  <i>curl_multi_setopt(3)</i>, you can change libcurl's behaviour when using that multi handle.  All options are set with the  <i>option</i> followed by the parameter <i>param</i>. That parameter can be a  <b>long</b>, a <b>function pointer</b>, an <b>object pointer</b> or a  <b>curl_off_t</b> type, depending on what the specific option expects. Read this manual carefully as bad input values may cause libcurl to behave badly! You can only set one option in each function call.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>OPTIONS</h1><dl>
<dt>
CURLMOPT_SOCKETFUNCTION</dt>
<dd>
Pass a pointer to a function matching the <b>curl_socket_callback</b> prototype. The  <i>curl_multi_socket_action(3)</i> function informs the application about updates in the socket (file descriptor) status by doing none, one, or multiple calls to the curl_socket_callback given in the  <b>param</b> argument. They update the status with changes since the previous time a  <i>curl_multi_socket(3)</i> function was called. If the given callback pointer is NULL, no callback will be called. Set the callback's  <b>userp</b> argument with  <i>CURLMOPT_SOCKETDATA</i>.  See <i>curl_multi_socket(3)</i> for more callback details.</dd>
</dl>
<dl>
<dt>
CURLMOPT_SOCKETDATA</dt>
<dd>
Pass a pointer to whatever you want passed to the <b>curl_socket_callback</b>'s forth argument, the userp pointer. This is not used by libcurl but only passed-thru as-is. Set the callback pointer with  <i>CURLMOPT_SOCKETFUNCTION</i>.</dd>
</dl>
<dl>
<dt>
CURLMOPT_PIPELINING</dt>
<dd>
Pass a long set to 1 to enable or 0 to disable. Enabling pipelining on a multi handle will make it attempt to perform HTTP Pipelining as far as possible for transfers using this handle. This means that if you add a second request that can use an already existing connection, the second request will be &quot;piped&quot; on the same connection rather than being executed in parallel. (Added in 7.16.0)</dd>
</dl>
<dl>
<dt>
CURLMOPT_TIMERFUNCTION</dt>
<dd>
Pass a pointer to a function matching the <b>curl_multi_timer_callback</b> prototype.  This function will then be called when the timeout value changes. The timeout value is at what latest time the application should call one of the &quot;performing&quot; functions of the multi interface ( <i>curl_multi_socket_action(3)</i> and <i>curl_multi_perform(3)</i>) - to allow libcurl to keep timeouts and retries etc to work. A timeout value of -1 means that there is no timeout at all, and 0 means that the timeout is already reached. Libcurl attempts to limit calling this only when the fixed future timeout time actually changes. See also  <i>CURLMOPT_TIMERDATA</i>. This callback can be used instead of, or in addition to,  <i>curl_multi_timeout(3)</i>. (Added in 7.16.0)</dd>
</dl>
<dl>
<dt>
CURLMOPT_TIMERDATA</dt>
<dd>
Pass a pointer to whatever you want passed to the  <b>curl_multi_timer_callback</b>'s third argument, the userp pointer.  This is not used by libcurl but only passed-thru as-is. Set the callback pointer with  <i>CURLMOPT_TIMERFUNCTION</i>. (Added in 7.16.0)</dd>
</dl>
<dl>
<dt>
CURLMOPT_MAXCONNECTS</dt>
<dd>
Pass a long. The set number will be used as the maximum amount of simultaneously open connections that libcurl may cache. Default is 10, and libcurl will enlarge the size for each added easy handle to make it fit 4 times the number of added easy handles.<div style="height: 1.00em;">
&#160;</div>
By setting this option, you can prevent the cache size from growing beyond the limit set by you.<div style="height: 1.00em;">
&#160;</div>
When the cache is full, curl closes the oldest one in the cache to prevent the number of open connections from increasing.<div style="height: 1.00em;">
&#160;</div>
This option is for the multi handle's use only, when using the easy interface you should instead use the  <i>CURLOPT_MAXCONNECTS</i> option.<div style="height: 1.00em;">
&#160;</div>
(Added in 7.16.3)</dd>
</dl>
</div>
<div class="section">
<h1>RETURNS</h1> The standard CURLMcode for multi interface error codes. Note that it returns a CURLM_UNKNOWN_OPTION if you try setting an option that this version of libcurl doesn't know of.</div>
<div class="section">
<h1>AVAILABILITY</h1> This function was added in libcurl 7.15.4.</div>
<div class="section">
<h1>SEE ALSO</h1> <b>curl_multi_cleanup</b>(3), <b>curl_multi_init</b>(3),  <b>curl_multi_socket</b>(3), <b>curl_multi_info_read</b>(3)</div>
<table class="foot">
<tr>
<td class="foot-date">
10 Oct 2006</td>
<td class="foot-os">
libcurl 7.16.0</td>
</tr>
</table>
</div>
</body>
</html>

