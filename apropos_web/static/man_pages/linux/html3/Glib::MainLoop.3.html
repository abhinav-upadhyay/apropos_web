<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Glib::MainLoop(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Glib::MainLoop(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
Glib::MainLoop(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Glib::MainLoop -  An event source manager</div>
<div class="section">
<h1>DESCRIPTION</h1> Event-driven programs need some sort of loop which watches for events and launches the appropriate actions.  Glib::MainLoop provides this functionality.<div class="spacer">
</div>
Mainloops have context, provided by the MainContext object.  For the most part you can use the default context (see &quot;default&quot;), but if you want to create a subcontext for a nested loop which doesn't have the same event sources, etc, you can.<div class="spacer">
</div>
Event sources, attached to main contexts, watch for events to happen, and launch appropriate actions.  Glib provides a few ready-made event sources, the Glib::Timeout, Glib::Idle, and io watch (&quot;Glib::IO-&gt;add_watch&quot;).<div class="spacer">
</div>
Under the hood, Gtk+ adds event sources for GdkEvents to dispatch events to your widgets.  In fact, Gtk2 provides an abstraction of Glib::MainLoop (See &quot;Gtk2-&gt;main&quot; and friends), so you may rarely have cause to use Glib::MainLoop directly.<div class="spacer">
</div>
Note: As of version 1.080, the Glib module uses a custom event source to ensure that perl's safe signal handling and the glib polling event loop play nicely together.  It is no longer necessary to install a timeout to ensure that async signals get handled in a timely manner.</div>
<div class="section">
<h1>CONSTANTS</h1> &quot;SOURCE_REMOVE&quot; and &quot;SOURCE_CONTINUE&quot; are designed for use as the return values from timeout, idle and I/O watch source functions.  They return true to keep running or false to remove themselves.  These constants can help you get that the right way around.<div class="spacer">
</div>
<br/>
    Glib::SOURCE_CONTINUE     # true<br/>
    Glib::SOURCE_REMOVE       # false<br/>
</div>
<div class="section">
<h1>METHODS</h1><div class="subsection">
<h2>maincontext thingamabob = Glib::MainContext-&gt;<b>new</b></h2></div>
<div class="subsection">
<h2>mainloop = Glib::MainLoop-&gt;<b>new</b> ($context=undef, $is_running=FALSE)</h2><dl>
<dt>
&#8226;</dt>
<dd>
$context (Glib::MainContext thingamabob)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
$is_running (boolean)</dd>
</dl>
</div>
<div class="subsection">
<h2>integer = Glib::Timeout-&gt;<b>add</b> ($interval, $callback, $data=undef, $priority=G_PRIORITY_DEFAULT)</h2><dl>
<dt>
&#8226;</dt>
<dd>
$interval (integer) number of milliseconds</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
$callback (subroutine)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
$data (scalar)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
$priority (integer)</dd>
</dl>
<div class="spacer">
</div>
Run <i></i><i>$callback</i><i></i> every <i></i><i>$interval</i><i></i> milliseconds until <i></i><i>$callback</i><i></i> returns false.  Returns a source id which may be used with &quot;Glib::Source-&gt;remove&quot;. Note that a mainloop must be active for the timeout to execute.</div>
<div class="subsection">
<h2>integer = Glib::Idle-&gt;<b>add</b> ($callback, $data=undef, $priority=G_PRIORITY_DEFAULT_IDLE)</h2><dl>
<dt>
&#8226;</dt>
<dd>
$callback (subroutine)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
$data (scalar)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
$priority (integer)</dd>
</dl>
<div class="spacer">
</div>
Run <i></i><i>$callback</i><i></i> when the mainloop is idle.  If <i></i><i>$callback</i><i></i> returns false, it will uninstall itself, otherwise, it will run again at the next idle iteration.  Returns a source id which may be used with &quot;Glib::Source-&gt;remove&quot;.</div>
<div class="subsection">
<h2>integer = Glib::Timeout-&gt;<b>add_seconds</b> ($interval, $callback, $data=undef, $priority=G_PRIORITY_DEFAULT)</h2><dl>
<dt>
&#8226;</dt>
<dd>
$interval (integer)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
$callback (scalar)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
$data (scalar)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
$priority (integer)</dd>
</dl>
<div class="spacer">
</div>
Since: glib 2.14</div>
<div class="subsection">
<h2>integer = Glib::IO-&gt;<b>add_watch</b> ($fd, $condition, $callback, $data=undef, $priority=G_PRIORITY_DEFAULT)</h2><dl>
<dt>
&#8226;</dt>
<dd>
$fd (integer) file descriptor, e.g. fileno($filehandle)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
$condition (Glib::IOCondition)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
$callback (subroutine)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
$data (scalar)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
$priority (integer)</dd>
</dl>
<div class="spacer">
</div>
Run <i></i><i>$callback</i><i></i> when there is an event on <i></i><i>$fd</i><i></i> that matches <i></i><i>$condition</i><i></i>. The watch uninstalls itself if  <i></i><i>$callback</i><i></i> returns false. Returns a source id that may be used with &quot;Glib::Source-&gt;remove&quot;.<div class="spacer">
</div>
Glib's IO channels serve the same basic purpose as Perl's file handles, so for the most part you don't see GIOChannels in Perl.  The IO watch integrates IO operations with the main loop, which Perl file handles don't do.  For various reasons, this function requires raw file descriptors, not full file handles.  See &quot;fileno&quot; in perlfunc.</div>
<div class="subsection">
<h2>maincontext thingamabob = $loop-&gt;<b>get_context</b></h2></div>
<div class="subsection">
<h2>maincontext thingamabob = Glib::MainContext-&gt;<b>default</b></h2></div>
<div class="subsection">
<h2>boolean = $context-&gt;<b>is_owner</b></h2> Since: glib 2.12</div>
<div class="subsection">
<h2>boolean = $loop-&gt;<b>is_running</b></h2></div>
<div class="subsection">
<h2>boolean = $context-&gt;<b>iteration</b> ($may_block)</h2><dl>
<dt>
&#8226;</dt>
<dd>
$may_block (boolean)</dd>
</dl>
</div>
<div class="subsection">
<h2>integer = Glib::main_depth</h2> Find the current main loop recursion level.  This is handy in fringe situations, but those are very rare; see the C API reference for a more in-depth discussion.<div class="spacer">
</div>
Since: glib 2.4</div>
<div class="subsection">
<h2>boolean = $context-&gt;<b>pending</b></h2></div>
<div class="subsection">
<h2>$loop-&gt;<b>quit</b></h2></div>
<div class="subsection">
<h2>boolean = Glib::Source-&gt;<b>remove</b> ($tag)</h2><dl>
<dt>
&#8226;</dt>
<dd>
$tag (integer)</dd>
</dl>
<div class="spacer">
</div>
Remove an event source.  <i></i><i>$tag</i><i></i> is the number returned by things like &quot;Glib::Timeout-&gt;add&quot;, &quot;Glib::Idle-&gt;add&quot;, and &quot;Glib::IO-&gt;add_watch&quot;.</div>
<div class="subsection">
<h2>$loop-&gt;<b>run</b></h2></div>
<div class="subsection">
<h2>integer = Glib::Child-&gt;<b>watch_add</b> ($pid, $callback, $data=undef, $priority=G_PRIORITY_DEFAULT)</h2><dl>
<dt>
&#8226;</dt>
<dd>
$pid (integer) child process ID</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
$callback (subroutine)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
$data (scalar)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
$priority (integer)</dd>
</dl>
<div class="spacer">
</div>
Add a source to the default main context which will call<div class="spacer">
</div>
<br/>
    &amp;$callback ($pid, $waitstatus, $data)<br/>
<div class="spacer">
</div>
when child process $pid terminates.  The return value is a source id which can be used with &quot;Glib::Source-&gt;remove&quot;.  When the callback is made the source is removed automatically.<div class="spacer">
</div>
In a non-threaded program Glib implements this source by installing a SIGCHLD handler.  Don't change $SIG{CHLD} in Perl or the callback will never run.<div class="spacer">
</div>
Since: glib 2.4</div>
</div>
<div class="section">
<h1>ENUMS AND FLAGS</h1><div class="subsection">
<h2>flags Glib::IOCondition</h2><dl>
<dt>
&#8226;</dt>
<dd>
'in' / 'G_IO_IN'</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
'out' / 'G_IO_OUT'</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
'pri' / 'G_IO_PRI'</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
'err' / 'G_IO_ERR'</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
'hup' / 'G_IO_HUP'</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
'nval' / 'G_IO_NVAL'</dd>
</dl>
</div>
</div>
<div class="section">
<h1>SEE ALSO</h1> Glib</div>
<div class="section">
<h1>COPYRIGHT</h1> Copyright (C) 2003-2011 by the gtk2-perl team.<div class="spacer">
</div>
This software is licensed under the LGPL.  See Glib for a full notice.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-12-05</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

