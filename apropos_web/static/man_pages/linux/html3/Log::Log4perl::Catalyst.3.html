<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Catalyst(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Catalyst(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
Catalyst(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Log::Log4perl::Catalyst - Log::Log4perl Catalyst Module</div>
<div class="section">
<h1>SYNOPSIS</h1> In your main Catalyst application module:<div class="spacer">
</div>
<br/>
  use Log::Log4perl::Catalyst;<br/>
<br/>
    # Either make Log4perl act like the Catalyst default logger:<br/>
  __PACKAGE__-&gt;log(Log::Log4perl::Catalyst-&gt;new());<br/>
<br/>
    # or use a Log4perl configuration file, utilizing the full <br/>
    # functionality of Log4perl<br/>
  __PACKAGE__-&gt;log(Log::Log4perl::Catalyst-&gt;new('l4p.conf'));<br/>
<div class="spacer">
</div>
... and then sprinkly logging statements all over any code executed by Catalyst:<div class="spacer">
</div>
<br/>
    $c-&gt;log-&gt;debug(&quot;This is using log4perl!&quot;);<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> This module provides Log4perl functions to Catalyst applications. It was inspired by Catalyst::Log::Log4perl on CPAN, but has been completely rewritten and uses a different approach to unite Catalyst and Log4perl.<div class="spacer">
</div>
Log4perl provides loggers, usually associated with the current package, which can then be remote-controlled by a central configuration. This means that if you have a controller function like<div class="spacer">
</div>
<br/>
    package MyApp::Controller::User;<br/>
<br/>
    sub add : Chained('base'): PathPart('add'): Args(0) {<br/>
        my ( $self, $c ) = @_;<br/>
<br/>
        $c-&gt;log-&gt;info(&quot;Adding a user&quot;);<br/>
        # ...<br/>
    }<br/>
<div class="spacer">
</div>
Level-based control is available via the following methods:<div class="spacer">
</div>
<br/>
   $c-&gt;log-&gt;debug(&quot;Reading configuration&quot;);<br/>
   $c-&gt;log-&gt;info(&quot;Adding a user&quot;);<br/>
   $c-&gt;log-&gt;warn(&quot;Can't read configuration ($!)&quot;);<br/>
   $c-&gt;log-&gt;error(&quot;Can't add user &quot;, $user);<br/>
   $c-&gt;log-&gt;fatal(&quot;Database down, aborting request&quot;);<br/>
<div class="spacer">
</div>
But that's no all, Log4perl is much more powerful.<div class="spacer">
</div>
The logging statement can be suppressed or activated based on a Log4perl file that looks like<div class="spacer">
</div>
<br/>
      # All MyApp loggers opened up for DEBUG and above<br/>
    log4perl.logger.MyApp = DEBUG, Screen<br/>
    # ...<br/>
<div class="spacer">
</div>
or<div class="spacer">
</div>
<br/>
      # All loggers block messages below INFO<br/>
    log4perl.logger=INFO, Screen<br/>
    # ...<br/>
<div class="spacer">
</div>
respectively. See the Log4perl manpage on how to perform fine-grained log-level and location filtering, and how to forward messages not only to the screen or to log files, but also to databases, email appenders, and much more.<div class="spacer">
</div>
Also, you can vary the layout of each message. For example if you want to know where a particular statement was logged, turn on file names and line numbers:<div class="spacer">
</div>
<br/>
    # Log4perl configuration file<br/>
    # ...<br/>
    log4perl.appender.Screen.layout.ConversionPattern = \<br/>
          %F{1}-%L: %p %m%n<br/>
<div class="spacer">
</div>
Messages will then look like<div class="spacer">
</div>
<br/>
    MyApp.pm-1869: INFO Saving user profile for user &quot;wonko&quot;<br/>
<div class="spacer">
</div>
Or want to log a request's IP address with every log statement? No problem with Log4perl, just call<div class="spacer">
</div>
<br/>
    Log::Log4perl::MDC-&gt;put( &quot;ip&quot;, $c-&gt;req-&gt;address() );<br/>
<div class="spacer">
</div>
at the beginning of the request cycle and use<div class="spacer">
</div>
<br/>
    # Log4perl configuration file<br/>
    # ...<br/>
    log4perl.appender.Screen.layout.ConversionPattern = \<br/>
          [%d]-%X{ip} %F{1}-%L: %p %m%n<br/>
<div class="spacer">
</div>
as a Log4perl layout. Messages will look like<div class="spacer">
</div>
<br/>
    [2010/02/22 23:25:55]-123.122.108.10 MyApp.pm-1953: INFO Reading profile for user &quot;wonko&quot;<br/>
<div class="spacer">
</div>
Again, check the Log4perl manual page, there's a plethora of configuration options.</div>
<div class="section">
<h1>METHODS</h1><dl>
<dt>
new($config, [%options])</dt>
<dd>
If called without parameters, <i>new()</i> initializes Log4perl in a way so that messages are logged similiarly to Catalyst's default logging mechanism. If you provide configuration, either the name of a configuration file or a reference to scalar string containing the configuration, it will call Log4perl with these parameters.<div style="height: 1.00em;">
&#160;</div>
The second (optional) parameter is a list of key/value pairs:<div style="height: 1.00em;">
&#160;</div>
<br/>
  'autoflush'   =&gt;  1   # Log without buffering ('abort' not supported)<br/>
  'watch_delay' =&gt; 30   # If set, use L&lt;Log::Log4perl&gt;'s init_and_watch<br/>
</dd>
</dl>
<dl>
<dt>
<i>_flush()</i></dt>
<dd>
Flushes the cache.</dd>
</dl>
<dl>
<dt>
abort($abort)</dt>
<dd>
Clears the logging system's internal buffers without logging anything.</dd>
</dl>
<div class="subsection">
<h2>Using :easy Macros with Catalyst</h2> If you're tired of typing<div class="spacer">
</div>
<br/>
    $c-&gt;log-&gt;debug(&quot;...&quot;);<br/>
<div class="spacer">
</div>
and would prefer to use Log4perl's convenient :easy mode macros like<div class="spacer">
</div>
<br/>
    DEBUG &quot;...&quot;;<br/>
<div class="spacer">
</div>
then just pull those macros in via Log::Log4perl's :easy mode and start cranking:<div class="spacer">
</div>
<br/>
    use Log::Log4perl qw(:easy);<br/>
<br/>
      # ... use macros later on<br/>
    sub base :Chained('/') :PathPart('apples') :CaptureArgs(0) {<br/>
        my ( $self, $c ) = @_;<br/>
<br/>
        DEBUG &quot;Handling apples&quot;;<br/>
    }<br/>
<div class="spacer">
</div>
Note the difference between Log4perl's initialization in Catalyst, which uses the Catalyst-specific Log::Log4perl::Catalyst module (top of this page), and making use of Log4perl's loggers with the standard Log::Log4perl loggers and macros. While initialization requires Log4perl to perform dark magic to conform to Catalyst's different logging strategy, obtaining Log4perl's logger objects or calling its macros are unchanged.<div class="spacer">
</div>
Instead of using Catalyst's way of referencing the &quot;context&quot; object $c to obtain logger references via its  <i>log()</i> method, you can just as well use Log4perl's  <i>get_logger()</i> or macros to access Log4perl's logger singletons. The result is the same.</div>
</div>
<div class="section">
<h1>COPYRIGHT AND LICENSE</h1> Copyright 2002-2010 by Mike Schilli &lt;m@perlmeister.com&gt;<div class="spacer">
</div>
This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</div>
<table class="foot">
<tr>
<td class="foot-date">
2010-06-17</td>
<td class="foot-os">
perl v5.10.1</td>
</tr>
</table>
</div>
</body>
</html>

