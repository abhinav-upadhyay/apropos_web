<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
FAQ(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
FAQ(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
FAQ(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Log::Log4perl::FAQ - Frequently Asked Questions on Log::Log4perl</div>
<div class="section">
<h1>DESCRIPTION</h1> This FAQ shows a wide variety of commonly encountered logging tasks and how to solve them in the most elegant way with Log::Log4perl. Most of the time, this will be just a matter of smartly configuring your Log::Log4perl configuration files.<div class="subsection">
<h2>Why use Log::Log4perl instead of any other logging module on CPAN?</h2> That's a good question. There's dozens of logging modules on CPAN. When it comes to logging, people typically think: &quot;Aha. Writing out debug and error messages. Debug is lower than error. Easy. I'm gonna write my own.&quot; Writing a logging module is like a rite of passage for every Perl programmer, just like writing your own templating system.<div class="spacer">
</div>
Of course, after getting the basics right, features need to be added. You'd like to write a timestamp with every message. Then timestamps with microseconds. Then messages need to be written to both the screen and a log file.<div class="spacer">
</div>
And, as your application grows in size you might wonder: Why doesn't my logging system scale along with it? You would like to switch on logging in selected parts of the application, and not all across the board, because this kills performance. This is when people turn to Log::Log4perl, because it handles all of that.<div class="spacer">
</div>
Avoid this costly switch.<div class="spacer">
</div>
Use &quot;Log::Log4perl&quot; right from the start. &quot;Log::Log4perl&quot;'s &quot;:easy&quot; mode supports easy logging in simple scripts:<div class="spacer">
</div>
<br/>
    use Log::Log4perl qw(:easy);<br/>
    Log::Log4perl-&gt;easy_init($DEBUG);<br/>
<br/>
    DEBUG &quot;A low-level message&quot;;<br/>
    ERROR &quot;Won't make it until level gets increased to ERROR&quot;;<br/>
<div class="spacer">
</div>
And when your application inevitably grows, your logging system grows with it without you having to change any code.<div class="spacer">
</div>
Please, don't re-invent logging. &quot;Log::Log4perl&quot; is here, it's easy to use, it scales, and covers many areas you haven't thought of yet, but will enter soon.</div>
<div class="subsection">
<h2>What's the easiest way to use Log4perl?</h2> If you just want to get all the comfort of logging, without much overhead, use  <i>Stealth Loggers</i>. If you use Log::Log4perl in &quot;:easy&quot; mode like<div class="spacer">
</div>
<br/>
    use Log::Log4perl qw(:easy);<br/>
<div class="spacer">
</div>
you'll have the following functions available in the current package:<div class="spacer">
</div>
<br/>
    DEBUG(&quot;message&quot;);<br/>
    INFO(&quot;message&quot;);<br/>
    WARN(&quot;message&quot;);<br/>
    ERROR(&quot;message&quot;);<br/>
    FATAL(&quot;message&quot;);<br/>
<div class="spacer">
</div>
Just make sure that every package of your code where you're using them in pulls in &quot;use Log::Log4perl qw(:easy)&quot; first, then you're set. Every stealth logger's category will be equivalent to the name of the package it's located in.<div class="spacer">
</div>
These stealth loggers will be absolutely silent until you initialize Log::Log4perl in your main program with either<div class="spacer">
</div>
<br/>
        # Define any Log4perl behaviour<br/>
    Log::Log4perl-&gt;init(&quot;foo.conf&quot;);<br/>
<div class="spacer">
</div>
(using a full-blown Log4perl config file) or the super-easy method<div class="spacer">
</div>
<br/>
        # Just log to STDERR<br/>
    Log::Log4perl-&gt;easy_init($DEBUG);<br/>
<div class="spacer">
</div>
or the parameter-style method with a complexity somewhat in between:<div class="spacer">
</div>
<br/>
        # Append to a log file<br/>
    Log::Log4perl-&gt;easy_init( { level   =&gt; $DEBUG,<br/>
                                file    =&gt; &quot;&gt;&gt;test.log&quot; } );<br/>
<div class="spacer">
</div>
For more info, please check out &quot;Stealth Loggers&quot; in Log::Log4perl.</div>
<div class="subsection">
<h2>How can I simply log all my ERROR messages to a file?</h2> After pulling in the &quot;Log::Log4perl&quot; module, just initialize its behaviour by passing in a configuration to its &quot;init&quot; method as a string reference. Then, obtain a logger instance and write out a message with its &quot;error()&quot; method:<div class="spacer">
</div>
<br/>
    use Log::Log4perl qw(get_logger);<br/>
<br/>
        # Define configuration<br/>
    my $conf = q(<br/>
        log4perl.logger                    = ERROR, FileApp<br/>
        log4perl.appender.FileApp          = Log::Log4perl::Appender::File<br/>
        log4perl.appender.FileApp.filename = test.log<br/>
        log4perl.appender.FileApp.layout   = PatternLayout<br/>
        log4perl.appender.FileApp.layout.ConversionPattern = %d&gt; %m%n<br/>
    );<br/>
<br/>
        # Initialize logging behaviour<br/>
    Log::Log4perl-&gt;init( \$conf );<br/>
<br/>
        # Obtain a logger instance<br/>
    my $logger = get_logger(&quot;Bar::Twix&quot;);<br/>
    $logger-&gt;error(&quot;Oh my, a dreadful error!&quot;);<br/>
    $logger-&gt;warn(&quot;Oh my, a dreadful warning!&quot;);<br/>
<div class="spacer">
</div>
This will append something like<div class="spacer">
</div>
<br/>
    2002/10/29 20:11:55&gt; Oh my, a dreadful error!<br/>
<div class="spacer">
</div>
to the log file &quot;test.log&quot;. How does this all work?<div class="spacer">
</div>
While the Log::Log4perl &quot;init()&quot; method typically takes the name of a configuration file as its input parameter like in<div class="spacer">
</div>
<br/>
    Log::Log4perl-&gt;init( &quot;/path/mylog.conf&quot; );<br/>
<div class="spacer">
</div>
the example above shows how to pass in a configuration as text in a scalar reference.<div class="spacer">
</div>
The configuration as shown defines a logger of the root category, which has an appender of type &quot;Log::Log4perl::Appender::File&quot; attached. The line<div class="spacer">
</div>
<br/>
    log4perl.logger = ERROR, FileApp<br/>
<div class="spacer">
</div>
doesn't list a category, defining a root logger. Compare that with<div class="spacer">
</div>
<br/>
    log4perl.logger.Bar.Twix = ERROR, FileApp<br/>
<div class="spacer">
</div>
which would define a logger for the category &quot;Bar::Twix&quot;, showing probably different behaviour. &quot;FileApp&quot; on the right side of the assignment is an arbitrarily defined variable name, which is only used to somehow reference an appender defined later on.<div class="spacer">
</div>
Appender settings in the configuration are defined as follows:<div class="spacer">
</div>
<br/>
    log4perl.appender.FileApp          = Log::Log4perl::Appender::File<br/>
    log4perl.appender.FileApp.filename = test.log<br/>
<div class="spacer">
</div>
It selects the file appender of the &quot;Log::Log4perl::Appender&quot; hierarchy, which will append to the file &quot;test.log&quot; if it already exists. If we wanted to overwrite a potentially existing file, we would have to explicitly set the appropriate &quot;Log::Log4perl::Appender::File&quot; parameter &quot;mode&quot;:<div class="spacer">
</div>
<br/>
    log4perl.appender.FileApp          = Log::Log4perl::Appender::File<br/>
    log4perl.appender.FileApp.filename = test.log<br/>
    log4perl.appender.FileApp.mode     = write<br/>
<div class="spacer">
</div>
Also, the configuration defines a PatternLayout format, adding the nicely formatted current date and time, an arrow (&gt;) and a space before the messages, which is then followed by a newline:<div class="spacer">
</div>
<br/>
    log4perl.appender.FileApp.layout   = PatternLayout<br/>
    log4perl.appender.FileApp.layout.ConversionPattern = %d&gt; %m%n<br/>
<div class="spacer">
</div>
Obtaining a logger instance and actually logging something is typically done in a different system part as the Log::Log4perl initialisation section, but in this example, it's just done right after init for the sake of compactness:<div class="spacer">
</div>
<br/>
        # Obtain a logger instance<br/>
    my $logger = get_logger(&quot;Bar::Twix&quot;);<br/>
    $logger-&gt;error(&quot;Oh my, a dreadful error!&quot;);<br/>
<div class="spacer">
</div>
This retrieves an instance of the logger of the category &quot;Bar::Twix&quot;, which, as all other categories, inherits behaviour from the root logger if no other loggers are defined in the initialization section.<div class="spacer">
</div>
The &quot;error()&quot; method fires up a message, which the root logger catches. Its priority is equal to or higher than the root logger's priority (ERROR), which causes the root logger to forward it to its attached appender. By contrast, the following<div class="spacer">
</div>
<br/>
    $logger-&gt;warn(&quot;Oh my, a dreadful warning!&quot;);<br/>
<div class="spacer">
</div>
doesn't make it through, because the root logger sports a higher setting (ERROR and up) than the WARN priority of the message.</div>
<div class="subsection">
<h2>How can I install Log::Log4perl on Microsoft Windows?</h2> Log::Log4perl is fully supported on the Win32 platform. It has been tested with Activestate perl 5.6.1 under Windows 98 and rumor has it that it also runs smoothly on all other major flavors (Windows NT, 2000, XP, etc.).<div class="spacer">
</div>
It also runs nicely with ActiveState 5.8.0, and, believe me, we had to jump through some major hoops for that.<div class="spacer">
</div>
Typically, Win32 systems don't have the &quot;make&quot; utility installed, so the standard &quot;perl Makefile.PL; make install&quot; on the downloadable distribution won't work. But don't despair, there's a very easy solution!<div class="spacer">
</div>
The &quot;Log::Log4perl&quot; homepage provides a so-called PPD file for ActiveState's &quot;ppm&quot; installer, which comes with ActiveState perl by default.<dl>
<dt>
Install on ActiveState 5.6.*</dt>
<dd>
The DOS command line<div style="height: 1.00em;">
&#160;</div>
<br/>
    ppm install &quot;http://log4perl.sourceforge.net/ppm/Log-Log4perl.ppd&quot;<br/>
<div style="height: 1.00em;">
&#160;</div>
will contact the Log4perl homepage, download the latest &quot;Log::Log4perl&quot; distribution and install it. If your ActiveState installation lacks any of the modules &quot;Log::Log4perl&quot; depends upon, &quot;ppm&quot; will automatically contact ActivateState and download them from their CPAN-like repository.</dd>
</dl>
<dl>
<dt>
Install on ActiveState 5.8.*</dt>
<dd>
ActiveState's &quot;Programmer's Package Manager&quot; can be called from Window's Start Menu: Start-&gt;Programs-&gt;&gt;ActiveState ActivePerl 5.8&gt;Perl Package Manager will invoke ppm. Since Log::Log4perl hasn't made it yet into the standard ActiveState repository (and you probably don't want their outdated packages anyway), just tell ppm the first time you call it to add the Log4perl repository<div style="height: 1.00em;">
&#160;</div>
<br/>
    ppm&gt; repository add http://log4perl.sourceforge.net/ppm<br/>
<div style="height: 1.00em;">
&#160;</div>
Then, just tell it to install Log::Log4perl and it will resolve all dependencies automatically and fetch them from log4perl.sourceforge.net if it can't find them in the main archives:<div style="height: 1.00em;">
&#160;</div>
<br/>
    ppm&gt; install Log-Log4perl<br/>
</dd>
</dl>
<div class="spacer">
</div>
That's it! Afterwards, just create a Perl script like<div class="spacer">
</div>
<br/>
    use Log::Log4perl qw(:easy);<br/>
    Log::Log4perl-&gt;easy_init($DEBUG);<br/>
<br/>
    my $logger = get_logger(&quot;Twix::Bar&quot;);<br/>
    $logger-&gt;debug(&quot;Watch me!&quot;);<br/>
<div class="spacer">
</div>
and run it. It should print something like<div class="spacer">
</div>
<br/>
    2002/11/06 01:22:05 Watch me!<br/>
<div class="spacer">
</div>
If you find that something doesn't work, please let us know at log4perl-devel@lists.sourceforge.net -- we'll apprechiate it. Have fun!</div>
<div class="subsection">
<h2>How can I include global (thread-specific) data in my log messages?</h2> Say, you're writing a web application and want all your log messages to include the current client's IP address. Most certainly, you don't want to include it in each and every log message like in<div class="spacer">
</div>
<br/>
    $logger-&gt;debug( $r-&gt;connection-&gt;remote_ip,<br/>
                    &quot; Retrieving user data from DB&quot; );<br/>
<div class="spacer">
</div>
do you? Instead, you want to set it in a global data structure and have Log::Log4perl include it automatically via a PatternLayout setting in the configuration file:<div class="spacer">
</div>
<br/>
    log4perl.appender.FileApp.layout.ConversionPattern = %X{ip} %m%n<br/>
<div class="spacer">
</div>
The conversion specifier %X{ip} references an entry under the key &quot;ip&quot; in the global &quot;MDC&quot; (mapped diagnostic context) table, which you've set once via<div class="spacer">
</div>
<br/>
    Log::Log4perl::MDC-&gt;put(&quot;ip&quot;, $r-&gt;connection-&gt;remote_ip);<br/>
<div class="spacer">
</div>
at the start of the request handler. Note that this is a  <i>static</i> (class) method, there's no logger object involved. You can use this method with as many key/value pairs as you like as long as you reference them under different names.<div class="spacer">
</div>
The mappings are stored in a global hash table within Log::Log4perl. Luckily, because the thread model in 5.8.0 doesn't share global variables between threads unless they're explicitly marked as such, there's no problem with multi-threaded environments.<div class="spacer">
</div>
For more details on the MDC, please refer to &quot;Mapped Diagnostic Context (MDC)&quot; in Log::Log4perl and Log::Log4perl::MDC.</div>
<div class="subsection">
<h2>My application is already logging to a file. How can I duplicate all messages to also go to the screen?</h2> Assuming that you already have a Log4perl configuration file like<div class="spacer">
</div>
<br/>
    log4perl.logger                    = DEBUG, FileApp<br/>
<br/>
    log4perl.appender.FileApp          = Log::Log4perl::Appender::File<br/>
    log4perl.appender.FileApp.filename = test.log<br/>
    log4perl.appender.FileApp.layout   = PatternLayout<br/>
    log4perl.appender.FileApp.layout.ConversionPattern = %d&gt; %m%n<br/>
<div class="spacer">
</div>
and log statements all over your code, it's very easy with Log4perl to have the same messages both printed to the logfile and the screen. No reason to change your code, of course, just add another appender to the configuration file and you're done:<div class="spacer">
</div>
<br/>
    log4perl.logger                    = DEBUG, FileApp, ScreenApp<br/>
<br/>
    log4perl.appender.FileApp          = Log::Log4perl::Appender::File<br/>
    log4perl.appender.FileApp.filename = test.log<br/>
    log4perl.appender.FileApp.layout   = PatternLayout<br/>
    log4perl.appender.FileApp.layout.ConversionPattern = %d&gt; %m%n<br/>
<br/>
    log4perl.appender.ScreenApp          = Log::Log4perl::Appender::Screen<br/>
    log4perl.appender.ScreenApp.stderr   = 0<br/>
    log4perl.appender.ScreenApp.layout   = PatternLayout<br/>
    log4perl.appender.ScreenApp.layout.ConversionPattern = %d&gt; %m%n<br/>
<div class="spacer">
</div>
The configuration file above is assuming that both appenders are active in the same logger hierarchy, in this case the &quot;root&quot; category. But even if you've got file loggers defined in several parts of your system, belonging to different logger categories, each logging to different files, you can gobble up all logged messages by defining a root logger with a screen appender, which would duplicate messages from all your file loggers to the screen due to Log4perl's appender inheritance. Check<div class="spacer">
</div>
<br/>
    http://www.perl.com/pub/a/2002/09/11/log4perl.html<br/>
<div class="spacer">
</div>
for details. Have fun!</div>
<div class="subsection">
<h2>How can I make sure my application logs a message when it dies unexpectedly?</h2> Whenever you encounter a fatal error in your application, instead of saying something like<div class="spacer">
</div>
<br/>
    open FILE, &quot;&lt;blah&quot; or die &quot;Can't open blah -- bailing out!&quot;;<br/>
<div class="spacer">
</div>
just use Log::Log4perl's fatal functions instead:<div class="spacer">
</div>
<br/>
    my $log = get_logger(&quot;Some::Package&quot;);<br/>
    open FILE, &quot;&lt;blah&quot; or $log-&gt;logdie(&quot;Can't open blah -- bailing out!&quot;);<br/>
<div class="spacer">
</div>
This will both log the message with priority FATAL according to your current Log::Log4perl configuration and then call Perl's &quot;die()&quot; afterwards to terminate the program. It works the same with stealth loggers (see &quot;Stealth Loggers&quot; in Log::Log4perl), all you need to do is call<div class="spacer">
</div>
<br/>
    use Log::Log4perl qw(:easy);<br/>
    open FILE, &quot;&lt;blah&quot; or LOGDIE &quot;Can't open blah -- bailing out!&quot;;<br/>
<div class="spacer">
</div>
What can you do if you're using some library which doesn't use Log::Log4perl and calls &quot;die()&quot; internally if something goes wrong? Use a $SIG{__DIE__} pseudo signal handler<div class="spacer">
</div>
<br/>
    use Log::Log4perl qw(get_logger);<br/>
<br/>
    $SIG{__DIE__} = sub {<br/>
        if($^S) {<br/>
            # We're in an eval {} and don't want log<br/>
            # this message but catch it later<br/>
            return;<br/>
        }<br/>
        local $Log::Log4perl::caller_depth =<br/>
              $Log::Log4perl::caller_depth + 1;<br/>
        my $logger = get_logger(&quot;&quot;);<br/>
        $logger-&gt;fatal(@_);<br/>
        die @_; # Now terminate really<br/>
    };<br/>
<div class="spacer">
</div>
This will catch every &quot;die()&quot;-Exception of your application or the modules it uses. In case you want to It will fetch a root logger and pass on the &quot;die()&quot;-Message to it. If you make sure you've configured with a root logger like this:<div class="spacer">
</div>
<br/>
    Log::Log4perl-&gt;init(\q{<br/>
        log4perl.category         = FATAL, Logfile<br/>
        log4perl.appender.Logfile = Log::Log4perl::Appender::File<br/>
        log4perl.appender.Logfile.filename = fatal_errors.log<br/>
        log4perl.appender.Logfile.layout = \<br/>
                   Log::Log4perl::Layout::PatternLayout<br/>
        log4perl.appender.Logfile.layout.ConversionPattern = %F{1}-%L (%M)&gt; %m%n<br/>
    });<br/>
<div class="spacer">
</div>
then all &quot;die()&quot; messages will be routed to a file properly. The line<div class="spacer">
</div>
<br/>
     local $Log::Log4perl::caller_depth =<br/>
           $Log::Log4perl::caller_depth + 1;<br/>
<div class="spacer">
</div>
in the pseudo signal handler above merits a more detailed explanation. With the setup above, if a module calls &quot;die()&quot; in one of its functions, the fatal message will be logged in the signal handler and not in the original function -- which will cause the %F, %L and %M placeholders in the pattern layout to be replaced by the filename, the line number and the function/method name of the signal handler, not the error-throwing module. To adjust this, Log::Log4perl has the $caller_depth variable, which defaults to 0, but can be set to positive integer values to offset the caller level. Increasing it by one will cause it to log the calling function's parameters, not the ones of the signal handler. See &quot;Using Log::Log4perl from wrapper classes&quot; in Log::Log4perl for more details.</div>
<div class="subsection">
<h2>How can I hook up the LWP library with Log::Log4perl?</h2> Or, to put it more generally: How can you utilize a third-party library's embedded logging and debug statements in Log::Log4perl? How can you make them print to configurable appenders, turn them on and off, just as if they were regular Log::Log4perl logging statements?<div class="spacer">
</div>
The easiest solution is to map the third-party library logging statements to Log::Log4perl's stealth loggers via a typeglob assignment.<div class="spacer">
</div>
As an example, let's take LWP, one of the most popular Perl modules, which makes handling WWW requests and responses a breeze. Internally, LWP uses its own logging and debugging system, utilizing the following calls inside the LWP code (from the LWP::Debug man page):<div class="spacer">
</div>
<br/>
        # Function tracing<br/>
    LWP::Debug::trace('send()');<br/>
<br/>
        # High-granular state in functions<br/>
    LWP::Debug::debug('url ok');<br/>
<br/>
        # Data going over the wire<br/>
    LWP::Debug::conns(&quot;read $n bytes: $data&quot;);<br/>
<div class="spacer">
</div>
First, let's assign Log::Log4perl priorities to these functions: I'd suggest that &quot;debug()&quot; messages have priority &quot;INFO&quot;, &quot;trace()&quot; uses &quot;DEBUG&quot; and &quot;conns()&quot; also logs with &quot;DEBUG&quot; -- although your mileage may certainly vary.<div class="spacer">
</div>
Now, in order to transpartently hook up LWP::Debug with Log::Log4perl, all we have to do is say<div class="spacer">
</div>
<br/>
    package LWP::Debug;<br/>
    use Log::Log4perl qw(:easy);<br/>
<br/>
    *trace = *INFO;<br/>
    *conns = *DEBUG;<br/>
    *debug = *DEBUG;<br/>
<br/>
    package main;<br/>
    # ... go on with your regular program ...<br/>
<div class="spacer">
</div>
at the beginning of our program. In this way, every time the, say, &quot;LWP::UserAgent&quot; module calls &quot;LWP::Debug::trace()&quot;, it will implicitely call  <i>INFO()</i>, which is the &quot;info()&quot; method of a stealth logger defined for the Log::Log4perl category &quot;LWP::Debug&quot;. Is this cool or what?<div class="spacer">
</div>
Here's a complete program:<div class="spacer">
</div>
<br/>
    use LWP::UserAgent;<br/>
    use HTTP::Request::Common;<br/>
    use Log::Log4perl qw(:easy);<br/>
<br/>
    Log::Log4perl-&gt;easy_init(<br/>
        { category =&gt; &quot;LWP::Debug&quot;,<br/>
          level    =&gt; $DEBUG,<br/>
          layout   =&gt; &quot;%r %p %M-%L %m%n&quot;,<br/>
        });<br/>
<br/>
    package LWP::Debug;<br/>
    use Log::Log4perl qw(:easy);<br/>
    *trace = *INFO;<br/>
    *conns = *DEBUG;<br/>
    *debug = *DEBUG;<br/>
<br/>
    package main;<br/>
    my $ua = LWP::UserAgent-&gt;new();<br/>
    my $resp = $ua-&gt;request(GET &quot;http://amazon.com&quot;);<br/>
<br/>
    if($resp-&gt;is_success()) {<br/>
        print &quot;Success: Received &quot;, <br/>
              length($resp-&gt;content()), &quot;\n&quot;;<br/>
    } else {<br/>
        print &quot;Error: &quot;, $resp-&gt;code(), &quot;\n&quot;;<br/>
    }<br/>
<div class="spacer">
</div>
This will generate the following output on STDERR:<div class="spacer">
</div>
<br/>
    174 INFO LWP::UserAgent::new-164 ()<br/>
    208 INFO LWP::UserAgent::request-436 ()<br/>
    211 INFO LWP::UserAgent::send_request-294 GET http://amazon.com<br/>
    212 DEBUG LWP::UserAgent::_need_proxy-1123 Not proxied<br/>
    405 INFO LWP::Protocol::http::request-122 ()<br/>
    859 DEBUG LWP::Protocol::collect-206 read 233 bytes<br/>
    863 DEBUG LWP::UserAgent::request-443 Simple response: Found<br/>
    869 INFO LWP::UserAgent::request-436 ()<br/>
    871 INFO LWP::UserAgent::send_request-294 <br/>
     GET http://www.amazon.com:80/exec/obidos/gateway_redirect<br/>
    872 DEBUG LWP::UserAgent::_need_proxy-1123 Not proxied<br/>
    873 INFO LWP::Protocol::http::request-122 ()<br/>
    1016 DEBUG LWP::UserAgent::request-443 Simple response: Found<br/>
    1020 INFO LWP::UserAgent::request-436 ()<br/>
    1022 INFO LWP::UserAgent::send_request-294 <br/>
     GET http://www.amazon.com/exec/obidos/subst/home/home.html/<br/>
    1023 DEBUG LWP::UserAgent::_need_proxy-1123 Not proxied<br/>
    1024 INFO LWP::Protocol::http::request-122 ()<br/>
    1382 DEBUG LWP::Protocol::collect-206 read 632 bytes<br/>
    ...<br/>
    2605 DEBUG LWP::Protocol::collect-206 read 77 bytes<br/>
    2607 DEBUG LWP::UserAgent::request-443 Simple response: OK<br/>
    Success: Received 42584<br/>
<div class="spacer">
</div>
Of course, in this way, the embedded logging and debug statements within LWP can be utilized in any Log::Log4perl way you can think of. You can have them sent to different appenders, block them based on the category and everything else Log::Log4perl has to offer.<div class="spacer">
</div>
Only drawback of this method: Steering logging behaviour via category is always based on the &quot;LWP::Debug&quot; package. Although the logging statements reflect the package name of the issuing module properly, the stealth loggers in &quot;LWP::Debug&quot; are all of the category &quot;LWP::Debug&quot;. This implies that you can't control the logging behaviour based on the package that's  <i>initiating</i> a log request (e.g. LWP::UserAgent) but only based on the package that's actually  <i>executing</i> the logging statement, &quot;LWP::Debug&quot; in this case.<div class="spacer">
</div>
To work around this conundrum, we need to write a wrapper function and plant it into the &quot;LWP::Debug&quot; package. It will determine the caller and create a logger bound to a category with the same name as the caller's package:<div class="spacer">
</div>
<br/>
    package LWP::Debug;<br/>
<br/>
    use Log::Log4perl qw(:levels get_logger);<br/>
<br/>
    sub l4p_wrapper {<br/>
        my($prio, @message) = @_;<br/>
        $Log::Log4perl::caller_depth += 2;<br/>
        get_logger(scalar caller(1))-&gt;log($prio, @message);<br/>
        $Log::Log4perl::caller_depth -= 2;<br/>
    }<br/>
<br/>
    no warnings 'redefine';<br/>
    *trace = sub { l4p_wrapper($INFO, @_); };<br/>
    *debug = *conns = sub { l4p_wrapper($DEBUG, @_); };<br/>
<br/>
    package main;<br/>
    # ... go on with your main program ...<br/>
<div class="spacer">
</div>
This is less performant than the previous approach, because every log request will request a reference to a logger first, then call the wrapper, which will in turn call the appropriate log function.<div class="spacer">
</div>
This hierarchy shift has to be compensated for by increasing $Log::Log4perl::caller_depth by 2 before calling the log function and decreasing it by 2 right afterwards. Also, the &quot;l4p_wrapper&quot; function shown above calls caller(1) which determines the name of the package  <i>two</i> levels down the calling hierarchy (and therefore compensates for both the wrapper function and the anonymous subroutine calling it).<div class="spacer">
</div>
&quot;no warnings 'redefine'&quot; suppresses a warning Perl would generate otherwise upon redefining &quot;LWP::Debug&quot;'s &quot;trace()&quot;, &quot;debug()&quot; and &quot;conns()&quot; functions. In case you use a perl prior to 5.6.x, you need to manipulate $^W instead.<div class="spacer">
</div>
To make things easy for you when dealing with LWP, Log::Log4perl 0.47 introduces &quot;Log::Log4perl-&gt;infiltrate_lwp()&quot; which does exactly the above.</div>
<div class="subsection">
<h2>What if I need dynamic values in a static Log4perl configuration file?</h2> Say, your application uses Log::Log4perl for logging and therefore comes with a Log4perl configuration file, specifying the logging behaviour. But, you also want it to take command line parameters to set values like the name of the log file. How can you have both a static Log4perl configuration file and a dynamic command line interface?<div class="spacer">
</div>
As of Log::Log4perl 0.28, every value in the configuration file can be specified as a  <i>Perl hook</i>. So, instead of saying<div class="spacer">
</div>
<br/>
    log4perl.appender.Logfile.filename = test.log<br/>
<div class="spacer">
</div>
you could just as well have a Perl subroutine deliver the value dynamically:<div class="spacer">
</div>
<br/>
    log4perl.appender.Logfile.filename = sub { logfile(); };<br/>
<div class="spacer">
</div>
given that &quot;logfile()&quot; is a valid function in your &quot;main&quot; package returning a string containing the path to the log file.<div class="spacer">
</div>
Or, think about using the value of an environment variable:<div class="spacer">
</div>
<br/>
    log4perl.appender.DBI.user = sub { $ENV{USERNAME} };<br/>
<div class="spacer">
</div>
When &quot;Log::Log4perl-&gt;init()&quot; parses the configuration file, it will notice the assignment above because of its &quot;sub {...}&quot; pattern and treat it in a special way: It will evaluate the subroutine (which can contain arbitrary Perl code) and take its return value as the right side of the assignment.<div class="spacer">
</div>
A typical application would be called like this on the command line:<div class="spacer">
</div>
<br/>
    app                # log file is &quot;test.log&quot;<br/>
    app -l mylog.txt   # log file is &quot;mylog.txt&quot;<br/>
<div class="spacer">
</div>
Here's some sample code implementing the command line interface above:<div class="spacer">
</div>
<br/>
    use Log::Log4perl qw(get_logger);<br/>
    use Getopt::Std;<br/>
<br/>
    getopt('l:', \our %OPTS);<br/>
<br/>
    my $conf = q(<br/>
    log4perl.category.Bar.Twix         = WARN, Logfile<br/>
    log4perl.appender.Logfile          = Log::Log4perl::Appender::File<br/>
    log4perl.appender.Logfile.filename = sub { logfile(); };<br/>
    log4perl.appender.Logfile.layout   = SimpleLayout<br/>
    );<br/>
<br/>
    Log::Log4perl::init(\$conf);<br/>
<br/>
    my $logger = get_logger(&quot;Bar::Twix&quot;);<br/>
    $logger-&gt;error(&quot;Blah&quot;);<br/>
<br/>
    ###########################################<br/>
    sub logfile {<br/>
    ###########################################<br/>
        if(exists $OPTS{l}) {<br/>
            return $OPTS{l};<br/>
        } else {<br/>
            return &quot;test.log&quot;;<br/>
        }<br/>
    }<br/>
<div class="spacer">
</div>
Every Perl hook may contain arbitrary perl code, just make sure to fully qualify eventual variable names (e.g. %main::OPTS instead of %OPTS).<div class="spacer">
</div>
<b>SECURITY NOTE</b>: this feature means arbitrary perl code can be embedded in the config file.  In the rare case where the people who have access to your config file are different from the people who write your code and shouldn't have execute rights, you might want to call<div class="spacer">
</div>
<br/>
    $Log::Log4perl::Config-&gt;allow_code(0);<br/>
<div class="spacer">
</div>
before you call <i>init()</i>. This will prevent Log::Log4perl from executing  <i>any</i> Perl code in the config file (including code for custom conversion specifiers (see &quot;Custom cspecs&quot; in Log::Log4perl::Layout::PatternLayout).</div>
<div class="subsection">
<h2>How can I roll over my logfiles automatically at midnight?</h2> Long-running applications tend to produce ever-increasing logfiles. For backup and cleanup purposes, however, it is often desirable to move the current logfile to a different location from time to time and start writing a new one.<div class="spacer">
</div>
This is a non-trivial task, because it has to happen in sync with the logging system in order not to lose any messages in the process.<div class="spacer">
</div>
Luckily, <i>Mark Pfeiffer</i>'s &quot;Log::Dispatch::FileRotate&quot; appender works well with Log::Log4perl to rotate your logfiles in a variety of ways.<div class="spacer">
</div>
Note, however, that having the application deal with rotating a log file is not cheap. Among other things, it requires locking the log file with every write to avoid race conditions. There are good reasons to use external rotators like &quot;newsyslog&quot; instead. See the entry &quot;How can I rotate a logfile with newsyslog?&quot; in the FAQ for more information on how to configure it.<div class="spacer">
</div>
When using &quot;Log::Dispatch::FileRotate&quot;, all you have to do is specify it in your Log::Log4perl configuration file and your logfiles will be rotated automatically.<div class="spacer">
</div>
You can choose between rolling based on a maximum size (&quot;roll if greater than 10 MB&quot;) or based on a date pattern (&quot;roll everyday at midnight&quot;). In both cases, &quot;Log::Dispatch::FileRotate&quot; allows you to define a number &quot;max&quot; of saved files to keep around until it starts overwriting the oldest ones. If you set the &quot;max&quot; parameter to 2 and the name of your logfile is &quot;test.log&quot;, &quot;Log::Dispatch::FileRotate&quot; will move &quot;test.log&quot; to &quot;test.log.1&quot; on the first rollover. On the second rollover, it will move &quot;test.log.1&quot; to &quot;test.log.2&quot; and then &quot;test.log&quot; to &quot;test.log.1&quot;. On the third rollover, it will move &quot;test.log.1&quot; to &quot;test.log.2&quot; (therefore discarding the old &quot;test.log.2&quot;) and &quot;test.log&quot; to &quot;test.log.1&quot;. And so forth. This way, there's always going to be a maximum of 2 saved log files around.<div class="spacer">
</div>
Here's an example of a Log::Log4perl configuration file, defining a daily rollover at midnight (date pattern &quot;yyyy-MM-dd&quot;), keeping a maximum of 5 saved logfiles around:<div class="spacer">
</div>
<br/>
    log4perl.category         = WARN, Logfile<br/>
    log4perl.appender.Logfile = Log::Dispatch::FileRotate<br/>
    log4perl.appender.Logfile.filename    = test.log<br/>
    log4perl.appender.Logfile.max         = 5<br/>
    log4perl.appender.Logfile.DatePattern = yyyy-MM-dd<br/>
    log4perl.appender.Logfile.TZ          = PST<br/>
    log4perl.appender.Logfile.layout = \<br/>
        Log::Log4perl::Layout::PatternLayout <br/>
    log4perl.appender.Logfile.layout.ConversionPattern = %d %m %n<br/>
<div class="spacer">
</div>
Please see the &quot;Log::Dispatch::FileRotate&quot; documentation for details. &quot;Log::Dispatch::FileRotate&quot; is available on CPAN.</div>
<div class="subsection">
<h2>What's the easiest way to turn off all logging, even with a lengthy Log4perl configuration file?</h2> In addition to category-based levels and appender thresholds, Log::Log4perl supports system-wide logging thresholds. This is the minimum level the system will require of any logging events in order for them to make it through to any configured appenders.<div class="spacer">
</div>
For example, putting the line<div class="spacer">
</div>
<br/>
    log4perl.threshold = ERROR<br/>
<div class="spacer">
</div>
anywhere in your configuration file will limit any output to any appender to events with priority of ERROR or higher (ERROR or FATAL that is).<div class="spacer">
</div>
However, in order to suppress all logging entirely, you need to use a priority that's higher than FATAL: It is simply called &quot;OFF&quot;, and it is never used by any logger. By definition, it is higher than the highest defined logger level.<div class="spacer">
</div>
Therefore, if you keep the line<div class="spacer">
</div>
<br/>
    log4perl.threshold = OFF<br/>
<div class="spacer">
</div>
somewhere in your Log::Log4perl configuration, the system will be quiet as a graveyard. If you deactivate the line (e.g. by commenting it out), the system will, upon config reload, snap back to normal operation, providing logging messages according to the rest of the configuration file again.</div>
<div class="subsection">
<h2>I keep getting duplicate log messages! What's wrong?</h2> Having several settings for related categories in the Log4perl configuration file sometimes leads to a phenomenon called &quot;message duplication&quot;. It can be very confusing at first, but if thought through properly, it turns out that Log4perl behaves as advertised. But, don't despair, of course there's a number of ways to avoid message duplication in your logs.<div class="spacer">
</div>
Here's a sample Log4perl configuration file that produces the phenomenon:<div class="spacer">
</div>
<br/>
    log4perl.logger.Cat        = ERROR, Screen<br/>
    log4perl.logger.Cat.Subcat = WARN, Screen<br/>
<br/>
    log4perl.appender.Screen   = Log::Log4perl::Appender::Screen<br/>
    log4perl.appender.Screen.layout = SimpleLayout<br/>
<div class="spacer">
</div>
It defines two loggers, one for category &quot;Cat&quot; and one for &quot;Cat::Subcat&quot;, which is obviously a subcategory of &quot;Cat&quot;. The parent logger has a priority setting of ERROR, the child is set to the lower &quot;WARN&quot; level.<div class="spacer">
</div>
Now imagine the following code in your program:<div class="spacer">
</div>
<br/>
    my $logger = get_logger(&quot;Cat.Subcat&quot;);<br/>
    $logger-&gt;warn(&quot;Warning!&quot;);<br/>
<div class="spacer">
</div>
What do you think will happen? An unexperienced Log4perl user might think: &quot;Well, the message is being sent with level WARN, so the &quot;Cat::Subcat&quot; logger will accept it and forward it to the attached &quot;Screen&quot; appender. Then, the message will percolate up the logger hierarchy, find the &quot;Cat&quot; logger, which will suppress the message because of its ERROR setting.&quot; But, perhaps surprisingly, what you'll get with the code snippet above is not one but two log messages written to the screen:<div class="spacer">
</div>
<br/>
    WARN - Warning!<br/>
    WARN - Warning!<br/>
<div class="spacer">
</div>
What happened? The culprit is that once the logger &quot;Cat::Subcat&quot; decides to fire, it will forward the message  <i>unconditionally</i> to all directly or indirectly attached appenders. The &quot;Cat&quot; logger will never be asked if it wants the message or not -- the message will just be pushed through to the appender attached to &quot;Cat&quot;.<div class="spacer">
</div>
One way to prevent the message from bubbling up the logger hierarchy is to set the &quot;additivity&quot; flag of the subordinate logger to 0:<div class="spacer">
</div>
<br/>
    log4perl.logger.Cat            = ERROR, Screen<br/>
    log4perl.logger.Cat.Subcat     = WARN, Screen<br/>
    log4perl.additivity.Cat.Subcat = 0<br/>
<br/>
    log4perl.appender.Screen   = Log::Log4perl::Appender::Screen<br/>
    log4perl.appender.Screen.layout = SimpleLayout<br/>
<div class="spacer">
</div>
The message will now be accepted by the &quot;Cat::Subcat&quot; logger, forwarded to its appender, but then &quot;Cat::Subcat&quot; will suppress any further action. While this setting avoids duplicate messages as seen before, it is often not the desired behaviour. Messages percolating up the hierarchy are a useful Log4perl feature.<div class="spacer">
</div>
If you're defining <i>different</i> appenders for the two loggers, one other option is to define an appender threshold for the higher-level appender. Typically it is set to be equal to the logger's level setting:<div class="spacer">
</div>
<br/>
    log4perl.logger.Cat           = ERROR, Screen1<br/>
    log4perl.logger.Cat.Subcat    = WARN, Screen2<br/>
<br/>
    log4perl.appender.Screen1   = Log::Log4perl::Appender::Screen<br/>
    log4perl.appender.Screen1.layout = SimpleLayout<br/>
    log4perl.appender.Screen1.Threshold = ERROR<br/>
<br/>
    log4perl.appender.Screen2   = Log::Log4perl::Appender::Screen<br/>
    log4perl.appender.Screen2.layout = SimpleLayout<br/>
<div class="spacer">
</div>
Since the &quot;Screen1&quot; appender now blocks every message with a priority less than ERROR, even if the logger in charge lets it through, the message percolating up the hierarchy is being blocked at the last minute and  <i>not</i> appended to &quot;Screen1&quot;.<div class="spacer">
</div>
So far, we've been operating well within the boundaries of the Log4j standard, which Log4perl adheres to. However, if you would really, really like to use a single appender and keep the message percolation intact without having to deal with message duplication, there's a non-standard solution for you:<div class="spacer">
</div>
<br/>
    log4perl.logger.Cat        = ERROR, Screen<br/>
    log4perl.logger.Cat.Subcat = WARN, Screen<br/>
<br/>
    log4perl.appender.Screen   = Log::Log4perl::Appender::Screen<br/>
    log4perl.appender.Screen.layout = SimpleLayout<br/>
<br/>
    log4perl.oneMessagePerAppender = 1<br/>
<div class="spacer">
</div>
The &quot;oneMessagePerAppender&quot; flag will suppress duplicate messages to the same appender. Again, that's non-standard. But way cool :).</div>
<div class="subsection">
<h2>How can I configure Log::Log4perl to send me email if something happens?</h2> Some incidents require immediate action. You can't wait until someone checks the log files, you need to get notified on your pager right away.<div class="spacer">
</div>
The easiest way to do that is by using the &quot;Log::Dispatch::Email::MailSend&quot; module as an appender. It comes with the &quot;Log::Dispatch&quot; bundle and allows you to specify recipient and subject of outgoing emails in the Log4perl configuration file:<div class="spacer">
</div>
<br/>
    log4perl.category = FATAL, Mailer<br/>
    log4perl.appender.Mailer         = Log::Dispatch::Email::MailSend<br/>
    log4perl.appender.Mailer.to      = drone@pageme.net<br/>
    log4perl.appender.Mailer.subject = Something's broken!<br/>
    log4perl.appender.Mailer.layout  = SimpleLayout<br/>
<div class="spacer">
</div>
The message of every log incident this appender gets will then be forwarded to the given email address. Check the &quot;Log::Dispatch::Email::MailSend&quot; documentation for details. And please make sure there's not a flood of email messages sent out by your application, filling up the receipient's inbox.<div class="spacer">
</div>
There's one caveat you need to know about: The &quot;Log::Dispatch::Email&quot; hierarchy of appenders turns on  <i>buffering</i> by default. This means that the appender will not send out messages right away but wait until a certain threshold has been reached. If you'd rather have your alerts sent out immeditately, use<div class="spacer">
</div>
<br/>
    log4perl.appender.Mailer.buffered = 0<br/>
<div class="spacer">
</div>
to turn buffering off.</div>
<div class="subsection">
<h2>How can I write my own appender?</h2> First off, Log::Log4perl comes with a set of standard appenders. Then, there's a lot of Log4perl-compatible appenders already available on CPAN: Just run a search for &quot;Log::Dispatch&quot; on http://search.cpan.org and chances are that what you're looking for has already been developed, debugged and been used successfully in production -- no need for you to reinvent the wheel.<div class="spacer">
</div>
Also, Log::Log4perl ships with a nifty database appender named Log::Log4perl::Appender::DBI -- check it out if talking to databases is your desire.<div class="spacer">
</div>
But if you're up for a truly exotic task, you might have to write an appender yourself. That's very easy -- it takes no longer than a couple of minutes.<div class="spacer">
</div>
Say, we wanted to create an appender of the class &quot;ColorScreenAppender&quot;, which logs messages to the screen in a configurable color. Just create a new class in &quot;ColorScreenAppender.pm&quot;:<div class="spacer">
</div>
<br/>
    package ColorScreenAppender;<br/>
<div class="spacer">
</div>
Now let's assume that your Log::Log4perl configuration file &quot;test.conf&quot; looks like this:<div class="spacer">
</div>
<br/>
    log4perl.logger = INFO, ColorApp<br/>
<br/>
    log4perl.appender.ColorApp=ColorScreenAppender<br/>
    log4perl.appender.ColorApp.color=blue<br/>
<br/>
    log4perl.appender.ColorApp.layout = PatternLayout<br/>
    log4perl.appender.ColorApp.layout.ConversionPattern=%d %m %n<br/>
<div class="spacer">
</div>
This will cause Log::Log4perl on &quot;init()&quot; to look for a class ColorScreenAppender and call its constructor  <i>new()</i>. Let's add  <i>new()</i> to ColorScreenAppender.pm:<div class="spacer">
</div>
<br/>
    sub new {<br/>
        my($class, %options) = @_;<br/>
<br/>
        my $self = { %options };<br/>
        bless $self, $class;<br/>
<br/>
        return $self;<br/>
    }<br/>
<div class="spacer">
</div>
To initialize this appender, Log::Log4perl will call and pass all attributes of the appender as defined in the configuration file to the constructor as name/value pairs (in this case just one):<div class="spacer">
</div>
<br/>
    ColorScreenAppender-&gt;new(color =&gt; &quot;blue&quot;);<br/>
<div class="spacer">
</div>
The <i>new()</i> method listed above stores the contents of the %options hash in the object's instance data hash (referred to by $self). That's all for initializing a new appender with Log::Log4perl.<div class="spacer">
</div>
Second, ColorScreenAppender needs to expose a &quot;log()&quot; method, which will be called by Log::Log4perl every time it thinks the appender should fire. Along with the object reference (as usual in Perl's object world),  <i>log()</i> will receive a list of name/value pairs, of which only the one under the key &quot;message&quot; shall be of interest for now since it is the message string to be logged. At this point, Log::Log4perl has already taken care of joining the message to be a single string.<div class="spacer">
</div>
For our special appender ColorScreenAppender, we're using the Term::ANSIColor module to colorize the output:<div class="spacer">
</div>
<br/>
    use Term::ANSIColor;<br/>
<br/>
    sub log {<br/>
        my($self, %params) = @_;<br/>
<br/>
        print colored($params{message},<br/>
                      $self-&gt;{color});<br/>
    }<br/>
<div class="spacer">
</div>
The color (as configured in the Log::Log4perl configuration file) is available as $self-&gt;{color} in the appender object. Don't forget to return<div class="spacer">
</div>
<br/>
    1;<br/>
<div class="spacer">
</div>
at the end of ColorScreenAppender.pm and you're done. Install the new appender somewhere where perl can find it and try it with a test script like<div class="spacer">
</div>
<br/>
    use Log::Log4perl qw(:easy);<br/>
    Log::Log4perl-&gt;init(&quot;test.conf&quot;);<br/>
    ERROR(&quot;blah&quot;);<br/>
<div class="spacer">
</div>
to see the new colored output. Is this cool or what?<div class="spacer">
</div>
And it gets even better: You can write dynamically generated appender classes using the &quot;Class::Prototyped&quot; module. Here's an example of an appender prepending every outgoing message with a configurable number of bullets:<div class="spacer">
</div>
<br/>
    use Class::Prototyped;<br/>
<br/>
    my $class = Class::Prototyped-&gt;newPackage(<br/>
      &quot;MyAppenders::Bulletizer&quot;,<br/>
      bullets =&gt; 1,<br/>
      log     =&gt; sub {<br/>
        my($self, %params) = @_;<br/>
        print &quot;*&quot; x $self-&gt;bullets(),<br/>
              $params{message};<br/>
      },<br/>
    );<br/>
<br/>
    use Log::Log4perl qw(:easy);<br/>
<br/>
    Log::Log4perl-&gt;init(\ q{<br/>
      log4perl.logger = INFO, Bully<br/>
    <br/>
      log4perl.appender.Bully=MyAppenders::Bulletizer<br/>
      log4perl.appender.Bully.bullets=3<br/>
    <br/>
      log4perl.appender.Bully.layout = PatternLayout<br/>
      log4perl.appender.Bully.layout.ConversionPattern=%m %n<br/>
    });<br/>
<br/>
        # ... prints: &quot;***Boo!\n&quot;;<br/>
    INFO &quot;Boo!&quot;;<br/>
</div>
<div class="subsection">
<h2>How can I drill down on references before logging them?</h2> If you've got a reference to a nested structure or object, then you probably don't want to log it as &quot;HASH(0x81141d4)&quot; but rather dump it as something like<div class="spacer">
</div>
<br/>
    $VAR1 = {<br/>
              'a' =&gt; 'b',<br/>
              'd' =&gt; 'e'<br/>
            };<br/>
<div class="spacer">
</div>
via a module like Data::Dumper. While it's syntactically correct to say<div class="spacer">
</div>
<br/>
    $logger-&gt;debug(Data::Dumper::Dumper($ref));<br/>
<div class="spacer">
</div>
this call imposes a huge performance penalty on your application if the message is suppressed by Log::Log4perl, because Data::Dumper will perform its expensive operations in any case, because it doesn't know that its output will be thrown away immediately.<div class="spacer">
</div>
As of Log::Log4perl 0.28, there's a better way: Use the message output filter format as in<div class="spacer">
</div>
<br/>
    $logger-&gt;debug( {filter =&gt; \&amp;Data::Dumper::Dumper,<br/>
                     value  =&gt; $ref} );<br/>
<div class="spacer">
</div>
and Log::Log4perl won't call the filter function unless the message really gets written out to an appender. Just make sure to pass the whole slew as a reference to a hash specifying a filter function (as a sub reference) under the key &quot;filter&quot; and the value to be passed to the filter function in &quot;value&quot;). When it comes to logging, Log::Log4perl will call the filter function, pass the &quot;value&quot; as an argument and log the return value. Saves you serious cycles.</div>
<div class="subsection">
<h2>How can I collect all FATAL messages in an extra log file?</h2> Suppose you have employed Log4perl all over your system and you've already activated logging in various subsystems. On top of that, without disrupting any other settings, how can you collect all FATAL messages all over the system and send them to a separate log file?<div class="spacer">
</div>
If you define a root logger like this:<div class="spacer">
</div>
<br/>
    log4perl.logger                  = FATAL, File<br/>
    log4perl.appender.File           = Log::Log4perl::Appender::File<br/>
    log4perl.appender.File.filename  = /tmp/fatal.txt<br/>
    log4perl.appender.File.layout    = PatternLayout<br/>
    log4perl.appender.File.layout.ConversionPattern= %d %m %n<br/>
        # !!! Something's missing ...<br/>
<div class="spacer">
</div>
you'll be surprised to not only receive all FATAL messages issued anywhere in the system, but also everything else -- gazillions of ERROR, WARN, INFO and even DEBUG messages will end up in your fatal.txt logfile! Reason for this is Log4perl's (or better: Log4j's) appender additivity. Once a lower-level logger decides to fire, the message is going to be forwarded to all appenders upstream -- without further priority checks with their attached loggers.<div class="spacer">
</div>
There's a way to prevent this, however: If your appender defines a minimum threshold, only messages of this priority or higher are going to be logged. So, just add<div class="spacer">
</div>
<br/>
    log4perl.appender.File.Threshold = FATAL<br/>
<div class="spacer">
</div>
to the configuration above, and you'll get what you wanted in the first place: An overall system FATAL message collector.</div>
<div class="subsection">
<h2>How can I bundle several log messages into one?</h2> Would you like to tally the messages arriving at your appender and dump out a summary once they're exceeding a certain threshold? So that something like<div class="spacer">
</div>
<br/>
    $logger-&gt;error(&quot;Blah&quot;);<br/>
    $logger-&gt;error(&quot;Blah&quot;);<br/>
    $logger-&gt;error(&quot;Blah&quot;);<br/>
<div class="spacer">
</div>
won't be logged as<div class="spacer">
</div>
<br/>
    Blah<br/>
    Blah<br/>
    Blah<br/>
<div class="spacer">
</div>
but as<div class="spacer">
</div>
<br/>
    [3] Blah<br/>
<div class="spacer">
</div>
instead? If you'd like to hold off on logging a message until it has been sent a couple of times, you can roll that out by creating a buffered appender.<div class="spacer">
</div>
Let's define a new appender like<div class="spacer">
</div>
<br/>
    package TallyAppender;<br/>
<br/>
    sub new {<br/>
        my($class, %options) = @_;<br/>
<br/>
        my $self = { maxcount =&gt; 5,<br/>
                     %options<br/>
                   };<br/>
<br/>
        bless $self, $class;<br/>
<br/>
        $self-&gt;{last_message}        = &quot;&quot;;<br/>
        $self-&gt;{last_message_count}  = 0;<br/>
<br/>
        return $self;<br/>
    }<br/>
<div class="spacer">
</div>
with two additional instance variables &quot;last_message&quot; and &quot;last_message_count&quot;, storing the content of the last message sent and a counter of how many times this has happened. Also, it features a configuration parameter &quot;maxcount&quot; which defaults to 5 in the snippet above but can be set in the Log4perl configuration file like this:<div class="spacer">
</div>
<br/>
    log4perl.logger = INFO, A<br/>
    log4perl.appender.A=TallyAppender<br/>
    log4perl.appender.A.maxcount = 3<br/>
<div class="spacer">
</div>
The main tallying logic lies in the appender's &quot;log&quot; method, which is called every time Log4perl thinks a message needs to get logged by our appender:<div class="spacer">
</div>
<br/>
    sub log {<br/>
        my($self, %params) = @_;<br/>
<br/>
            # Message changed? Print buffer.<br/>
        if($self-&gt;{last_message} and<br/>
           $params{message} ne $self-&gt;{last_message}) {<br/>
            print &quot;[$self-&gt;{last_message_count}]: &quot; .<br/>
                  &quot;$self-&gt;{last_message}&quot;;<br/>
            $self-&gt;{last_message_count} = 1;<br/>
            $self-&gt;{last_message} = $params{message};<br/>
            return;<br/>
        }<br/>
<br/>
        $self-&gt;{last_message_count}++;<br/>
        $self-&gt;{last_message} = $params{message};<br/>
<br/>
            # Threshold exceeded? Print, reset counter<br/>
        if($self-&gt;{last_message_count} &gt;= <br/>
           $self-&gt;{maxcount}) {<br/>
            print &quot;[$self-&gt;{last_message_count}]: &quot; .<br/>
                  &quot;$params{message}&quot;;<br/>
            $self-&gt;{last_message_count} = 0;<br/>
            $self-&gt;{last_message}       = &quot;&quot;;<br/>
            return;<br/>
        }<br/>
    }<br/>
<div class="spacer">
</div>
We basically just check if the oncoming message in $param{message} is equal to what we've saved before in the &quot;last_message&quot; instance variable. If so, we're increasing &quot;last_message_count&quot;. We print the message in two cases: If the new message is different than the buffered one, because then we need to dump the old stuff and store the new. Or, if the counter exceeds the threshold, as defined by the &quot;maxcount&quot; configuration parameter.<div class="spacer">
</div>
Please note that the appender always gets the fully rendered message and just compares it as a whole -- so if there's a date/timestamp in there, that might confuse your logic. You can work around this by specifying %m %n as a layout and add the date later on in the appender. Or, make the comparison smart enough to omit the date.<div class="spacer">
</div>
At last, don't forget what happens if the program is being shut down. If there's still messages in the buffer, they should be printed out at that point. That's easy to do in the appender's DESTROY method, which gets called at object destruction time:<div class="spacer">
</div>
<br/>
    sub DESTROY {<br/>
        my($self) = @_;<br/>
<br/>
        if($self-&gt;{last_message_count}) {<br/>
            print &quot;[$self-&gt;{last_message_count}]: &quot; .<br/>
                  &quot;$self-&gt;{last_message}&quot;;<br/>
            return;<br/>
        }<br/>
    }<br/>
<div class="spacer">
</div>
This will ensure that none of the buffered messages are lost. Happy buffering!</div>
<div class="subsection">
<h2>I want to log ERROR and WARN messages to different files! How can I do that?</h2> Let's assume you wanted to have each logging statement written to a different file, based on the statement's priority. Messages with priority &quot;WARN&quot; are supposed to go to &quot;/tmp/app.warn&quot;, events prioritized as &quot;ERROR&quot; should end up in &quot;/tmp/app.error&quot;.<div class="spacer">
</div>
Now, if you define two appenders &quot;AppWarn&quot; and &quot;AppError&quot; and assign them both to the root logger, messages bubbling up from any loggers below will be logged by both appenders because of Log4perl's message propagation feature. If you limit their exposure via the appender threshold mechanism and set &quot;AppWarn&quot;'s threshold to &quot;WARN&quot; and &quot;AppError&quot;'s to &quot;ERROR&quot;, you'll still get &quot;ERROR&quot; messages in &quot;AppWarn&quot;, because &quot;AppWarn&quot;'s &quot;WARN&quot; setting will just filter out messages with a  <i>lower</i> priority than &quot;WARN&quot; -- &quot;ERROR&quot; is higher and will be allowed to pass through.<div class="spacer">
</div>
What we need for this is a Log4perl <i>Custom Filter</i>, available with Log::Log4perl 0.30.<div class="spacer">
</div>
Both appenders need to verify that the priority of the oncoming messages exactly  <i>matches</i> the priority the appender is supposed to log messages of. To accomplish this task, let's define two custom filters, &quot;MatchError&quot; and &quot;MatchWarn&quot;, which, when attached to their appenders, will limit messages passed on to them to those matching a given priority:<div class="spacer">
</div>
<br/>
    log4perl.logger = WARN, AppWarn, AppError<br/>
<br/>
        # Filter to match level ERROR<br/>
    log4perl.filter.MatchError = Log::Log4perl::Filter::LevelMatch<br/>
    log4perl.filter.MatchError.LevelToMatch  = ERROR<br/>
    log4perl.filter.MatchError.AcceptOnMatch = true<br/>
<br/>
        # Filter to match level WARN<br/>
    log4perl.filter.MatchWarn  = Log::Log4perl::Filter::LevelMatch<br/>
    log4perl.filter.MatchWarn.LevelToMatch  = WARN<br/>
    log4perl.filter.MatchWarn.AcceptOnMatch = true<br/>
<br/>
        # Error appender<br/>
    log4perl.appender.AppError = Log::Log4perl::Appender::File<br/>
    log4perl.appender.AppError.filename = /tmp/app.err<br/>
    log4perl.appender.AppError.layout   = SimpleLayout<br/>
    log4perl.appender.AppError.Filter   = MatchError<br/>
<br/>
        # Warning appender<br/>
    log4perl.appender.AppWarn = Log::Log4perl::Appender::File<br/>
    log4perl.appender.AppWarn.filename = /tmp/app.warn<br/>
    log4perl.appender.AppWarn.layout   = SimpleLayout<br/>
    log4perl.appender.AppWarn.Filter   = MatchWarn<br/>
<div class="spacer">
</div>
The appenders &quot;AppWarn&quot; and &quot;AppError&quot; defined above are logging to &quot;/tmp/app.warn&quot; and &quot;/tmp/app.err&quot; respectively and have the custom filters &quot;MatchWarn&quot; and &quot;MatchError&quot; attached. This setup will direct all WARN messages, issued anywhere in the system, to /tmp/app.warn (and ERROR messages to /tmp/app.error) -- without any overlaps.</div>
<div class="subsection">
<h2>On our server farm, Log::Log4perl configuration files differ slightly from host to host. Can I roll them all into one?</h2> You sure can, because Log::Log4perl allows you to specify attribute values dynamically. Let's say that one of your appenders expects the host's IP address as one of its attributes. Now, you could certainly roll out different configuration files for every host and specify the value like<div class="spacer">
</div>
<br/>
    log4perl.appender.MyAppender    = Log::Log4perl::Appender::SomeAppender<br/>
    log4perl.appender.MyAppender.ip = 10.0.0.127<br/>
<div class="spacer">
</div>
but that's a maintenance nightmare. Instead, you can have Log::Log4perl figure out the IP address at configuration time and set the appender's value correctly:<div class="spacer">
</div>
<br/>
        # Set the IP address dynamically<br/>
    log4perl.appender.MyAppender    = Log::Log4perl::Appender::SomeAppender<br/>
    log4perl.appender.MyAppender.ip = sub { \<br/>
       use Sys::Hostname; \<br/>
       use Socket; \<br/>
       return inet_ntoa(scalar gethostbyname hostname); \<br/>
    }<br/>
<div class="spacer">
</div>
If Log::Log4perl detects that an attribute value starts with something like &quot;sub {...&quot;, it will interpret it as a perl subroutine which is to be executed once at configuration time (not runtime!) and its return value is to be used as the attribute value. This comes in handy for rolling out applications whichs Log::Log4perl configuration files show small host-specific differences, because you can deploy the unmodified application distribution on all instances of the server farm.</div>
<div class="subsection">
<h2>Log4perl doesn't interpret my backslashes correctly!</h2> If you're using Log4perl's feature to specify the configuration as a string in your program (as opposed to a separate configuration file), chances are that you've written it like this:<div class="spacer">
</div>
<br/>
    # *** WRONG! ***<br/>
<br/>
    Log::Log4perl-&gt;init( \ &lt;&lt;END_HERE);<br/>
        log4perl.logger = WARN, A1<br/>
        log4perl.appender.A1 = Log::Log4perl::Appender::Screen<br/>
        log4perl.appender.A1.layout = \<br/>
            Log::Log4perl::Layout::PatternLayout<br/>
        log4perl.appender.A1.layout.ConversionPattern = %m%n<br/>
    END_HERE<br/>
<br/>
    # *** WRONG! ***<br/>
<div class="spacer">
</div>
and you're getting the following error message:<div class="spacer">
</div>
<br/>
    Layout not specified for appender A1 at .../Config.pm line 342.<br/>
<div class="spacer">
</div>
What's wrong? The problem is that you're using a here-document with substitution enabled (&quot;&lt;&lt;END_HERE&quot;) and that Perl won't interpret backslashes at line-ends as continuation characters but will essentially throw them out. So, in the code above, the layout line will look like<div class="spacer">
</div>
<br/>
    log4perl.appender.A1.layout =<br/>
<div class="spacer">
</div>
to Log::Log4perl which causes it to report an error. To interpret the backslash at the end of the line correctly as a line-continuation character, use the non-interpreting mode of the here-document like in<div class="spacer">
</div>
<br/>
    # *** RIGHT! ***<br/>
<br/>
    Log::Log4perl-&gt;init( \ &lt;&lt;'END_HERE');<br/>
        log4perl.logger = WARN, A1<br/>
        log4perl.appender.A1 = Log::Log4perl::Appender::Screen<br/>
        log4perl.appender.A1.layout = \<br/>
            Log::Log4perl::Layout::PatternLayout<br/>
        log4perl.appender.A1.layout.ConversionPattern = %m%n<br/>
    END_HERE<br/>
<br/>
    # *** RIGHT! ***<br/>
<div class="spacer">
</div>
(note the single quotes around 'END_HERE') or use &quot;q{...}&quot; instead of a here-document and Perl will treat the backslashes at line-end as intended.</div>
<div class="subsection">
<h2>I want to suppress certain messages based on their content!</h2> Let's assume you've plastered all your functions with Log4perl statements like<div class="spacer">
</div>
<br/>
    sub some_func {<br/>
<br/>
        INFO(&quot;Begin of function&quot;);<br/>
<br/>
        # ... Stuff happens here ...<br/>
<br/>
        INFO(&quot;End of function&quot;);<br/>
    }<br/>
<div class="spacer">
</div>
to issue two log messages, one at the beginning and one at the end of each function. Now you want to suppress the message at the beginning and only keep the one at the end, what can you do? You can't use the category mechanism, because both messages are issued from the same package.<div class="spacer">
</div>
Log::Log4perl's custom filters (0.30 or better) provide an interface for the Log4perl user to step in right before a message gets logged and decide if it should be written out or suppressed, based on the message content or other parameters:<div class="spacer">
</div>
<br/>
    use Log::Log4perl qw(:easy);<br/>
<br/>
    Log::Log4perl::init( \ &lt;&lt;'EOT' );<br/>
        log4perl.logger             = INFO, A1<br/>
        log4perl.appender.A1        = Log::Log4perl::Appender::Screen<br/>
        log4perl.appender.A1.layout = \<br/>
            Log::Log4perl::Layout::PatternLayout<br/>
        log4perl.appender.A1.layout.ConversionPattern = %m%n<br/>
<br/>
        log4perl.filter.M1 = Log::Log4perl::Filter::StringMatch<br/>
        log4perl.filter.M1.StringToMatch = Begin<br/>
        log4perl.filter.M1.AcceptOnMatch = false<br/>
<br/>
        log4perl.appender.A1.Filter = M1<br/>
EOT<br/>
<div class="spacer">
</div>
The last four statements in the configuration above are defining a custom filter &quot;M1&quot; of type &quot;Log::Log4perl::Filter::StringMatch&quot;, which comes with Log4perl right out of the box and allows you to define a text pattern to match (as a perl regular expression) and a flag &quot;AcceptOnMatch&quot; indicating if a match is supposed to suppress the message or let it pass through.<div class="spacer">
</div>
The last line then assigns this filter to the &quot;A1&quot; appender, which will call it every time it receives a message to be logged and throw all messages out  <i>not</i> matching the regular expression &quot;Begin&quot;.<div class="spacer">
</div>
Instead of using the standard &quot;Log::Log4perl::Filter::StringMatch&quot; filter, you can define your own, simply using a perl subroutine:<div class="spacer">
</div>
<br/>
    log4perl.filter.ExcludeBegin  = sub { !/Begin/ }<br/>
    log4perl.appender.A1.Filter   = ExcludeBegin<br/>
<div class="spacer">
</div>
For details on custom filters, check Log::Log4perl::Filter.</div>
<div class="subsection">
<h2>My new module uses Log4perl -- but what happens if the calling program didn't configure it?</h2> If a Perl module uses Log::Log4perl, it will typically rely on the calling program to initialize it. If it is using Log::Log4perl in &quot;:easy&quot; mode, like in<div class="spacer">
</div>
<br/>
    package MyMod;<br/>
    use Log::Log4perl qw(:easy);<br/>
<br/>
    sub foo {<br/>
        DEBUG(&quot;In foo&quot;);<br/>
    }<br/>
<br/>
    1;<br/>
<div class="spacer">
</div>
and the calling program doesn't initialize Log::Log4perl at all (e.g. because it has no clue that it's available), Log::Log4perl will silently ignore all logging messages. However, if the module is using Log::Log4perl in regular mode like in<div class="spacer">
</div>
<br/>
    package MyMod;<br/>
    use Log::Log4perl qw(get_logger);<br/>
<br/>
    sub foo {<br/>
        my $logger = get_logger(&quot;&quot;);<br/>
        $logger-&gt;debug(&quot;blah&quot;);<br/>
    }<br/>
<br/>
    1;<br/>
<div class="spacer">
</div>
and the main program is just using the module like in<div class="spacer">
</div>
<br/>
    use MyMode;<br/>
    MyMode::foo();<br/>
<div class="spacer">
</div>
then Log::Log4perl will also ignore all logging messages but issue a warning like<div class="spacer">
</div>
<br/>
    Log4perl: Seems like no initialization happened. <br/>
    Forgot to call init()?<br/>
<div class="spacer">
</div>
(only once!) to remind novice users to not forget to initialize the logging system before using it. However, if you want to suppress this message, just add the &quot;:nowarn&quot; target to the module's &quot;use Log::Log4perl&quot; call:<div class="spacer">
</div>
<br/>
    use Log::Log4perl qw(get_logger :nowarn);<br/>
<div class="spacer">
</div>
This will have Log::Log4perl silently ignore all logging statements if no initialization has taken place. If, instead of using  <i>init()</i>, you're using Log4perl's API to define loggers and appenders, the same notification happens if no call to  <i>add_appenders()</i> is made, i.e. no appenders are defined.<div class="spacer">
</div>
If the module wants to figure out if some other program part has already initialized Log::Log4perl, it can do so by calling<div class="spacer">
</div>
<br/>
    Log::Log4perl::initialized()<br/>
<div class="spacer">
</div>
which will return a true value in case Log::Log4perl has been initialized and a false value if not.</div>
<div class="subsection">
<h2>How can I synchronize access to an appender?</h2> If you're using the same instance of an appender in multiple processes, and each process is passing on messages to the appender in parallel, you might end up with overlapping log entries.<div class="spacer">
</div>
Typical scenarios include a file appender that you create in the main program, and which will then be shared between the parent and a forked child process. Or two separate processes, each initializing a Log4perl file appender on the same logfile.<div class="spacer">
</div>
Log::Log4perl won't synchronize access to the shared logfile by default. Depending on your operating system's flush mechanism, buffer size and the size of your messages, there's a small chance of an overlap.<div class="spacer">
</div>
The easiest way to prevent overlapping messages in logfiles written to by multiple processes is setting the file appender's &quot;syswrite&quot; flag along with a file write mode of &quot;append&quot;. This makes sure that &quot;Log::Log4perl::Appender::File&quot; uses &quot;syswrite()&quot; (which is guaranteed to run uninterrupted) instead of &quot;print()&quot; which might buffer the message or get interrupted by the OS while it is writing. And in &quot;append&quot; mode, the OS kernel ensures that multiple processes share one end-of-file marker, ensuring that each process writes to the  <i>real</i> end of the file. (The value of &quot;append&quot; for the &quot;mode&quot; parameter is the default setting in Log4perl's file appender so you don't have to set it explicitely.)<div class="spacer">
</div>
<br/>
      # Guarantees atomic writes<br/>
<br/>
    log4perl.category.Bar.Twix          = WARN, Logfile<br/>
<br/>
    log4perl.appender.Logfile           = Log::Log4perl::Appender::File<br/>
    log4perl.appender.Logfile.mode      = append<br/>
    log4perl.appender.Logfile.syswrite  = 1<br/>
    log4perl.appender.Logfile.filename  = test.log<br/>
    log4perl.appender.Logfile.layout    = SimpleLayout<br/>
<div class="spacer">
</div>
Another guaranteed way of having messages separated with any kind of appender is putting a Log::Log4perl::Appender::Synchronized composite appender in between Log::Log4perl and the real appender. It will make sure to let messages pass through this virtual gate one by one only.<div class="spacer">
</div>
Here's a sample configuration to synchronize access to a file appender:<div class="spacer">
</div>
<br/>
    log4perl.category.Bar.Twix          = WARN, Syncer<br/>
<br/>
    log4perl.appender.Logfile           = Log::Log4perl::Appender::File<br/>
    log4perl.appender.Logfile.autoflush = 1<br/>
    log4perl.appender.Logfile.filename  = test.log<br/>
    log4perl.appender.Logfile.layout    = SimpleLayout<br/>
<br/>
    log4perl.appender.Syncer            = Log::Log4perl::Appender::Synchronized<br/>
    log4perl.appender.Syncer.appender   = Logfile<br/>
<div class="spacer">
</div>
&quot;Log::Log4perl::Appender::Synchronized&quot; uses the &quot;IPC::Shareable&quot; module and its semaphores, which will slow down writing the log messages, but ensures sequential access featuring atomic checks. Check Log::Log4perl::Appender::Synchronized for details.</div>
<div class="subsection">
<h2>Can I use Log::Log4perl with log4j's Chainsaw?</h2> Yes, Log::Log4perl can be configured to send its events to log4j's graphical log UI  <i>Chainsaw</i>.<div class="spacer">
</div>
Here's how it works:<dl>
<dt>
&#8226;</dt>
<dd>
Get Guido Carls' &lt;gcarls@cpan.org&gt; Log::Log4perl extension &quot;Log::Log4perl::Layout::XMLLayout&quot; from CPAN and install it:<div style="height: 1.00em;">
&#160;</div>
<br/>
    perl -MCPAN -eshell<br/>
    cpan&gt; install Log::Log4perl::Layout::XMLLayout<br/>
</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Install and start Chainsaw, which is part of the &quot;log4j&quot; distribution now (see http://jakarta.apache.org/log4j ). Create a configuration file like<div style="height: 1.00em;">
&#160;</div>
<br/>
  &lt;log4j:configuration debug=&quot;true&quot;&gt;<br/>
    &lt;plugin name=&quot;XMLSocketReceiver&quot; <br/>
            class=&quot;org.apache.log4j.net.XMLSocketReceiver&quot;&gt;<br/>
      &lt;param name=&quot;decoder&quot; value=&quot;org.apache.log4j.xml.XMLDecoder&quot;/&gt; <br/>
      &lt;param name=&quot;Port&quot; value=&quot;4445&quot;/&gt; <br/>
    &lt;/plugin&gt;<br/>
    &lt;root&gt; &lt;level value=&quot;debug&quot;/&gt; &lt;/root&gt; <br/>
  &lt;/log4j:configuration&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
and name it e.g. &quot;config.xml&quot;. Then start Chainsaw like<div style="height: 1.00em;">
&#160;</div>
<br/>
  java -Dlog4j.debug=true -Dlog4j.configuration=config.xml \<br/>
    -classpath &quot;.:log4j-1.3alpha.jar:log4j-chainsaw-1.3alpha.jar&quot; \<br/>
    org.apache.log4j.chainsaw.LogUI<br/>
<div style="height: 1.00em;">
&#160;</div>
and watch the GUI coming up.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Configure Log::Log4perl to use a socket appender with an XMLLayout, pointing to the host/port where Chainsaw (as configured above) is waiting with its XMLSocketReceiver:<div style="height: 1.00em;">
&#160;</div>
<br/>
  use Log::Log4perl qw(get_logger);<br/>
  use Log::Log4perl::Layout::XMLLayout;<br/>
<br/>
  my $conf = q(<br/>
    log4perl.category.Bar.Twix          = WARN, Appender<br/>
    log4perl.appender.Appender          = Log::Log4perl::Appender::Socket<br/>
    log4perl.appender.Appender.PeerAddr = localhost<br/>
    log4perl.appender.Appender.PeerPort = 4445<br/>
    log4perl.appender.Appender.layout   = Log::Log4perl::Layout::XMLLayout<br/>
  );<br/>
<br/>
  Log::Log4perl::init(\$conf);<br/>
<br/>
    # Nasty hack to suppress encoding header<br/>
  my $app = Log::Log4perl::appenders-&gt;{&quot;Appender&quot;};<br/>
  $app-&gt;layout()-&gt;{enc_set} = 1;<br/>
<br/>
  my $logger = get_logger(&quot;Bar.Twix&quot;);<br/>
  $logger-&gt;error(&quot;One&quot;);<br/>
<div style="height: 1.00em;">
&#160;</div>
The nasty hack shown in the code snippet above is currently (October 2003) necessary, because Chainsaw expects XML messages to arrive in a format like<div style="height: 1.00em;">
&#160;</div>
<br/>
  &lt;log4j:event logger=&quot;Bar.Twix&quot;<br/>
               timestamp=&quot;1066794904310&quot;<br/>
               level=&quot;ERROR&quot;<br/>
               thread=&quot;10567&quot;&gt;<br/>
    &lt;log4j:message&gt;&lt;![CDATA[Two]]&gt;&lt;/log4j:message&gt;<br/>
    &lt;log4j:NDC&gt;&lt;![CDATA[undef]]&gt;&lt;/log4j:NDC&gt;<br/>
    &lt;log4j:locationInfo class=&quot;main&quot;<br/>
      method=&quot;main&quot;<br/>
      file=&quot;./t&quot;<br/>
      line=&quot;32&quot;&gt;<br/>
    &lt;/log4j:locationInfo&gt;<br/>
  &lt;/log4j:event&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
without a preceding<div style="height: 1.00em;">
&#160;</div>
<br/>
  &lt;?xml version = &quot;1.0&quot; encoding = &quot;iso8859-1&quot;?&gt;<br/>
<div style="height: 1.00em;">
&#160;</div>
which Log::Log4perl::Layout::XMLLayout applies to the first event sent over the socket.</dd>
</dl>
<div class="spacer">
</div>
See figure 1 for a screenshot of Chainsaw in action, receiving events from the Perl script shown above.<div class="spacer">
</div>
Many thanks to Chainsaw's Scott Deboy &lt;sdeboy@comotivsystems.com&gt; for his support!</div>
<div class="subsection">
<h2>How can I run Log::Log4perl under mod_perl?</h2> In persistent environments it's important to play by the rules outlined in section &quot;Initialize once and only once&quot; in Log::Log4perl. If you haven't read this yet, please go ahead and read it right now. It's very important.<div class="spacer">
</div>
And no matter if you use a startup handler to <i>init()</i> Log::Log4perl or use the  <i>init_once()</i> strategy (added in 0.42), either way you're very likely to have unsynchronized writes to logfiles.<div class="spacer">
</div>
If Log::Log4perl is configured with a log file appender, and it is initialized via the Apache startup handler, the file handle created initially will be shared among all Apache processes. Similarly, with the  <i>init_once()</i> approach: although every process has a separate L4p configuration, processes are gonna share the appender file  <i>names</i> instead, effectively opening several different file handles on the same file.<div class="spacer">
</div>
Now, having several appenders using the same file handle or having several appenders logging to the same file unsynchronized, this might result in overlapping messages. Sometimes, this is acceptable. If it's not, here's two strategies:<dl>
<dt>
&#8226;</dt>
<dd>
Use the Log::Log4perl::Appender::Synchronized appender to connect to your file appenders. Here's the writeup: http://log4perl.sourceforge.net/releases/Log-Log4perl/docs/html/Log/Log4perl/FAQ.html#23804</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Use a different logfile for every process like in<div style="height: 1.00em;">
&#160;</div>
<br/>
     #log4perl.conf<br/>
     ...<br/>
     log4perl.appender.A1.filename = sub { &quot;mylog.$$.log&quot; }<br/>
</dd>
</dl>
</div>
<div class="subsection">
<h2>My program already uses <i>warn()</i> and <i>die()</i>. How can I switch to Log4perl?</h2> If your program already uses Perl's &quot;warn()&quot; function to spew out error messages and you'd like to channel those into the Log4perl world, just define a &quot;__WARN__&quot; handler where your program or module resides:<div class="spacer">
</div>
<br/>
    use Log::Log4perl qw(:easy);<br/>
<br/>
    $SIG{__WARN__} = sub {<br/>
        local $Log::Log4perl::caller_depth =<br/>
            $Log::Log4perl::caller_depth + 1;<br/>
        WARN @_;<br/>
    };<br/>
<div class="spacer">
</div>
Why the &quot;local&quot; setting of $Log::Log4perl::caller_depth? If you leave that out, &quot;PatternLayout&quot; conversion specifiers like %M or %F (printing the current function/method and source filename) will refer to where the __WARN__ handler resides, not the environment Perl's &quot;warn()&quot; function was issued from. Increasing &quot;caller_depth&quot; adjusts for this offset. Having it &quot;local&quot;, makes sure the level gets set back after the handler exits.<div class="spacer">
</div>
Once done, if your program does something like<div class="spacer">
</div>
<br/>
    sub some_func {<br/>
        warn &quot;Here's a warning&quot;;<br/>
    }<br/>
<div class="spacer">
</div>
you'll get (depending on your Log::Log4perl configuration) something like<div class="spacer">
</div>
<br/>
    2004/02/19 20:41:02-main::some_func: Here's a warning at ./t line 25.<br/>
<div class="spacer">
</div>
in the appropriate appender instead of having a screen full of STDERR messages. It also works with the &quot;Carp&quot; module and its &quot;carp()&quot; and &quot;cluck()&quot; functions.<div class="spacer">
</div>
If, on the other hand, catching &quot;die()&quot; and friends is required, a &quot;__DIE__&quot; handler is appropriate:<div class="spacer">
</div>
<br/>
    $SIG{__DIE__} = sub {<br/>
        if($^S) {<br/>
            # We're in an eval {} and don't want log<br/>
            # this message but catch it later<br/>
            return;<br/>
        }<br/>
        local $Log::Log4perl::caller_depth =<br/>
            $Log::Log4perl::caller_depth + 1;<br/>
        LOGDIE @_;<br/>
    };<br/>
<div class="spacer">
</div>
This will call Log4perl's &quot;LOGDIE()&quot; function, which will log a fatal error and then call  <i>die()</i> internally, causing the program to exit. Works equally well with &quot;Carp&quot;'s &quot;croak()&quot; and &quot;confess()&quot; functions.</div>
<div class="subsection">
<h2>Some module prints messages to STDERR. How can I funnel them to Log::Log4perl?</h2> If a module you're using doesn't use Log::Log4perl but prints logging messages to STDERR instead, like<div class="spacer">
</div>
<br/>
    ########################################<br/>
    package IgnorantModule;<br/>
    ########################################<br/>
<br/>
    sub some_method {<br/>
        print STDERR &quot;Parbleu! An error!\n&quot;;<br/>
    }<br/>
<br/>
    1;<br/>
<div class="spacer">
</div>
there's still a way to capture these messages and funnel them into Log::Log4perl, even without touching the module. What you need is a trapper module like<div class="spacer">
</div>
<br/>
    ########################################<br/>
    package Trapper;<br/>
    ########################################<br/>
    <br/>
    use Log::Log4perl qw(:easy);<br/>
    <br/>
    sub TIEHANDLE {<br/>
        my $class = shift;<br/>
        bless [], $class;<br/>
    }<br/>
    <br/>
    sub PRINT {<br/>
        my $self = shift;<br/>
        $Log::Log4perl::caller_depth++;<br/>
        DEBUG @_;<br/>
        $Log::Log4perl::caller_depth--;<br/>
    }<br/>
<br/>
    1;<br/>
<div class="spacer">
</div>
and a &quot;tie&quot; command in the main program to tie STDERR to the trapper module along with regular Log::Log4perl initialization:<div class="spacer">
</div>
<br/>
    ########################################<br/>
    package main;<br/>
    ########################################<br/>
<br/>
    use Log::Log4perl qw(:easy);<br/>
<br/>
    Log::Log4perl-&gt;easy_init(<br/>
        {level  =&gt; $DEBUG, <br/>
         file   =&gt; 'stdout',   # make sure not to use stderr here!<br/>
         layout =&gt; &quot;%d %M: %m%n&quot;,<br/>
        });<br/>
<br/>
    tie *STDERR, &quot;Trapper&quot;;<br/>
<div class="spacer">
</div>
Make sure not to use STDERR as Log::Log4perl's file appender here (which would be the default in &quot;:easy&quot; mode), because it would end up in an endless recursion.<div class="spacer">
</div>
Now, calling<div class="spacer">
</div>
<br/>
    IgnorantModule::some_method();<br/>
<div class="spacer">
</div>
will result in the desired output<div class="spacer">
</div>
<br/>
    2004/05/06 11:13:04 IgnorantModule::some_method: Parbleu! An error!<br/>
</div>
<div class="subsection">
<h2>How come PAR (Perl Archive Toolkit) creates executables which then can't find their Log::Log4perl appenders?</h2> If not instructed otherwise, &quot;Log::Log4perl&quot; dynamically pulls in appender classes found in its configuration. If you specify<div class="spacer">
</div>
<br/>
    #!/usr/bin/perl<br/>
    # mytest.pl<br/>
<br/>
    use Log::Log4perl qw(get_logger);<br/>
<br/>
    my $conf = q(<br/>
      log4perl.category.Bar.Twix = WARN, Logfile<br/>
      log4perl.appender.Logfile  = Log::Log4perl::Appender::Screen<br/>
      log4perl.appender.Logfile.layout = SimpleLayout<br/>
    );<br/>
<br/>
    Log::Log4perl::init(\$conf);<br/>
    my $logger = get_logger(&quot;Bar::Twix&quot;);<br/>
    $logger-&gt;error(&quot;Blah&quot;);<br/>
<div class="spacer">
</div>
then &quot;Log::Log4perl::Appender::Screen&quot; will be pulled in while the program runs, not at compile time. If you have PAR compile the script above to an executable binary via<div class="spacer">
</div>
<br/>
    pp -o mytest mytest.pl<br/>
<div class="spacer">
</div>
and then run &quot;mytest&quot; on a machine without having Log::Log4perl installed, you'll get an error message like<div class="spacer">
</div>
<br/>
    ERROR: can't load appenderclass 'Log::Log4perl::Appender::Screen'<br/>
    Can't locate Log/Log4perl/Appender/Screen.pm in @INC ...<br/>
<div class="spacer">
</div>
Why? At compile time, &quot;pp&quot; didn't realize that &quot;Log::Log4perl::Appender::Screen&quot; would be needed later on and didn't wrap it into the executable created. To avoid this, either say &quot;use Log::Log4perl::Appender::Screen&quot; in the script explicitely or compile it with<div class="spacer">
</div>
<br/>
    pp -o mytest -M Log::Log4perl::Appender::Screen mytest.pl<br/>
<div class="spacer">
</div>
to make sure the appender class gets included.</div>
<div class="subsection">
<h2>How can I access a custom appender defined in the configuration?</h2> Any appender defined in the configuration file or somewhere in the code can be accessed later via &quot;Log::Log4perl-&gt;appender_by_name(&quot;appender_name&quot;)&quot;, which returns a reference the the appender object.<div class="spacer">
</div>
Once you've got a hold of the object, it can be queried or modified to your liking. For example, see the custom &quot;IndentAppender&quot; defined below: After calling &quot;init()&quot; to define the Log4perl settings, the appender object is retrieved to call its &quot;indent_more()&quot; and &quot;indent_less()&quot; methods to control indentation of messages:<div class="spacer">
</div>
<br/>
    package IndentAppender;<br/>
<br/>
    sub new {<br/>
        bless { indent =&gt; 0 }, $_[0];<br/>
    }<br/>
<br/>
    sub indent_more  { $_[0]-&gt;{indent}++ }<br/>
    sub indent_less  { $_[0]-&gt;{indent}-- }<br/>
<br/>
    sub log {<br/>
        my($self, %params) = @_;<br/>
        print &quot; &quot; x $self-&gt;{indent}, $params{message};<br/>
    }<br/>
<br/>
    package main;<br/>
<br/>
    use Log::Log4perl qw(:easy);<br/>
<br/>
    my $conf = q(<br/>
    log4perl.category          = DEBUG, Indented<br/>
    log4perl.appender.Indented = IndentAppender<br/>
    log4perl.appender.Indented.layout = Log::Log4perl::Layout::SimpleLayout<br/>
    );<br/>
    <br/>
    Log::Log4perl::init(\$conf);<br/>
<br/>
    my $appender = Log::Log4perl-&gt;appender_by_name(&quot;Indented&quot;);<br/>
    <br/>
    DEBUG &quot;No identation&quot;;<br/>
    $appender-&gt;indent_more();<br/>
    DEBUG &quot;One more&quot;;<br/>
    $appender-&gt;indent_more();<br/>
    DEBUG &quot;Two more&quot;;<br/>
    $appender-&gt;indent_less();<br/>
    DEBUG &quot;One less&quot;;<br/>
<div class="spacer">
</div>
As you would expect, this will print<div class="spacer">
</div>
<br/>
    DEBUG - No identation<br/>
     DEBUG - One more<br/>
      DEBUG - Two more<br/>
     DEBUG - One less<br/>
<div class="spacer">
</div>
because the very appender used by Log4perl is modified dynamically at runtime.</div>
<div class="subsection">
<h2>I don't know if Log::Log4perl is installed. How can I prepare my script?</h2> In case your script needs to be prepared for environments that may or may not have Log::Log4perl installed, there's a trick.<div class="spacer">
</div>
If you put the following BEGIN blocks at the top of the program, you'll be able to use the  <i>DEBUG()</i>, <i>INFO()</i>, etc. macros in Log::Log4perl's &quot;:easy&quot; mode. If Log::Log4perl is installed in the target environment, the regular Log::Log4perl rules apply. If not, all of  <i>DEBUG()</i>, <i>INFO()</i>, etc. are &quot;stubbed&quot; out, i.e. they turn into no-ops:<div class="spacer">
</div>
<br/>
    use warnings;<br/>
    use strict;<br/>
<br/>
    BEGIN {<br/>
        eval { require Log::Log4perl; };<br/>
    <br/>
        if($@) {<br/>
            print &quot;Log::Log4perl not installed - stubbing.\n&quot;;<br/>
            no strict qw(refs);<br/>
            *{&quot;main::$_&quot;} = sub { } for qw(DEBUG INFO WARN ERROR FATAL);<br/>
        } else {<br/>
            no warnings;<br/>
            print &quot;Log::Log4perl installed - life is good.\n&quot;;<br/>
            require Log::Log4perl::Level;<br/>
            Log::Log4perl::Level-&gt;import(__PACKAGE__);<br/>
            Log::Log4perl-&gt;import(qw(:easy));<br/>
            Log::Log4perl-&gt;easy_init($main::DEBUG);<br/>
        }<br/>
    }<br/>
<br/>
        # The regular script begins ...<br/>
    DEBUG &quot;Hey now!&quot;;<br/>
<div class="spacer">
</div>
This snippet will first probe for Log::Log4perl, and if it can't be found, it will alias  <i>DEBUG()</i>, <i>INFO()</i>, with empty subroutines via typeglobs. If Log::Log4perl is available, its level constants are first imported ($DEBUG, $INFO, etc.) and then &quot;easy_init()&quot; gets called to initialize the logging system.</div>
<div class="subsection">
<h2>Can file appenders create files with different permissions?</h2> Typically, when &quot;Log::Log4perl::Appender::File&quot; creates a new file, its permissions are set to &quot;rw-r--r--&quot;. Why? Because your environment's  <i>umask</i> most likely defaults to 0022, that's the standard setting.<div class="spacer">
</div>
What's a <i>umask</i>, you're asking? It's a template that's applied to the permissions of all newly created files. While calls like &quot;open(FILE, &quot;&gt;foo&quot;)&quot; will always try to create files in &quot;rw-rw-rw- &quot; mode, the system will apply the current  <i>umask</i> template to determine the final permission setting.  <i>umask</i> is a bit mask that's inverted and then applied to the requested permission setting, using a bitwise AND:<div class="spacer">
</div>
<br/>
    $request_permission &amp;~ $umask<br/>
<div class="spacer">
</div>
So, a <i>umask</i> setting of 0000 (the leading 0 simply indicates an octal value) will create files in &quot;rw-rw-rw-&quot; mode, a setting of 0277 will use &quot;r--------&quot;, and the standard 0022 will use &quot;rw-r--r--&quot;.<div class="spacer">
</div>
As an example, if you want your log files to be created with &quot;rw-r--rw-&quot; permissions, use a  <i>umask</i> of 0020 before calling Log::Log4perl-&gt; <i>init()</i>:<div class="spacer">
</div>
<br/>
    use Log::Log4perl;<br/>
<br/>
    umask 0020;<br/>
        # Creates log.out in rw-r--rw mode<br/>
    Log::Log4perl-&gt;init(\ q{<br/>
        log4perl.logger = WARN, File<br/>
        log4perl.appender.File = Log::Log4perl::Appender::File<br/>
        log4perl.appender.File.filename = log.out<br/>
        log4perl.appender.File.layout = SimpleLayout<br/>
    });<br/>
</div>
<div class="subsection">
<h2>Using Log4perl in an END block causes a problem!</h2> It's not easy to get to this error, but if you write something like<div class="spacer">
</div>
<br/>
    END { Log::Log4perl::get_logger()-&gt;debug(&quot;Hey there.&quot;); }<br/>
<br/>
    use Log::Log4perl qw(:easy);<br/>
    Log::Log4perl-&gt;easy_init($DEBUG);<br/>
<div class="spacer">
</div>
it won't work. The reason is that &quot;Log::Log4perl&quot; defines an END block that cleans up all loggers. And perl will run END blocks in the reverse order as they're encountered in the compile phase, so in the scenario above, the END block will run  <i>after</i> Log4perl has cleaned up its loggers.<div class="spacer">
</div>
Placing END blocks using Log4perl <i>after</i> a &quot;use Log::Log4perl&quot; statement fixes the problem:<div class="spacer">
</div>
<br/>
    use Log::Log4perl qw(:easy);<br/>
    Log::Log4perl-&gt;easy_init($DEBUG);<br/>
<br/>
    END { Log::Log4perl::get_logger()-&gt;debug(&quot;Hey there.&quot;); }<br/>
<div class="spacer">
</div>
In this scenario, the shown END block is executed <i>before</i> Log4perl cleans up and the debug message will be processed properly.</div>
<div class="subsection">
<h2>Help! My appender is throwing a &quot;Wide character in print&quot; warning!</h2> This warning shows up when Unicode strings are printed without precautions. The warning goes away if the complaining appender is set to utf-8 mode:<div class="spacer">
</div>
<br/>
      # Either in the log4perl configuration file:<br/>
  log4perl.appender.Logfile.filename = test.log<br/>
  log4perl.appender.Logfile.utf8     = 1<br/>
<br/>
      # Or, in easy mode:<br/>
  Log::Log4perl-&gt;easy_init( {<br/>
    level =&gt; $DEBUG,<br/>
    file  =&gt; &quot;:utf8&gt; test.log&quot; <br/>
  } );<br/>
<div class="spacer">
</div>
If the complaining appender is a screen appender, set its &quot;utf8&quot; option:<div class="spacer">
</div>
<br/>
      log4perl.appender.Screen.stderr = 1<br/>
      log4perl.appender.Screen.utf8   = 1<br/>
<div class="spacer">
</div>
Alternatively, &quot;binmode&quot; does the trick:<div class="spacer">
</div>
<br/>
      # Either STDOUT ...<br/>
    binmode(STDOUT, &quot;:utf8);<br/>
<br/>
      # ... or STDERR.<br/>
    binmode(STDERR, &quot;:utf8);<br/>
<div class="spacer">
</div>
Some background on this: Perl's strings are either byte strings or Unicode strings. &quot;Mike&quot; is a byte string. &quot;\x{30DE}\x{30A4}\x{30AF}&quot; is a Unicode string. Unicode strings are marked specially and are UTF-8 encoded internally.<div class="spacer">
</div>
If you print a byte string to STDOUT, all is well, because STDOUT is by default set to byte mode. However, if you print a Unicode string to STDOUT without precautions, &quot;perl&quot; will try to transform the Unicode string back to a byte string before printing it out. This is troublesome if the Unicode string contains 'wide' characters which can't be represented in Latin-1.<div class="spacer">
</div>
For example, if you create a Unicode string with three japanese Katakana characters as in<div class="spacer">
</div>
<br/>
    perl -le 'print &quot;\x{30DE}\x{30A4}\x{30AF}&quot;'<br/>
<div class="spacer">
</div>
(coincidentally pronounced Ma-i-ku, the japanese pronounciation of &quot;Mike&quot;), STDOUT is in byte mode and the warning<div class="spacer">
</div>
<br/>
    Wide character in print at ./script.pl line 14.<br/>
<div class="spacer">
</div>
appears. Setting STDOUT to UTF-8 mode as in<div class="spacer">
</div>
<br/>
    perl -le 'binmode(STDOUT, &quot;:utf8&quot;); print &quot;\x{30DE}\x{30A4}\x{30AF}&quot;'<br/>
<div class="spacer">
</div>
will silently print the Unicode string to STDOUT in UTF-8. To see the characters printed, you'll need a UTF-8 terminal with a font including japanese Katakana characters.</div>
<div class="subsection">
<h2>How can I send errors to the screen, and debug messages to a file?</h2> Let's assume you want to maintain a detailed DEBUG output in a file and only messages of level ERROR and higher should be printed on the screen. Often times, developers come up with something like this:<div class="spacer">
</div>
<br/>
     # Wrong!!!<br/>
    log4perl.logger = DEBUG, FileApp<br/>
    log4perl.logger = ERROR, ScreenApp<br/>
     # Wrong!!!<br/>
<div class="spacer">
</div>
This won't work, however. Logger definitions aren't additive, and the second statement will overwrite the first one. Log4perl versions below 1.04 were silently accepting this, leaving people confused why it wouldn't work as expected. As of 1.04, this will throw a  <i>fatal error</i> to notify the user of the problem.<div class="spacer">
</div>
What you want to do instead, is this:<div class="spacer">
</div>
<br/>
    log4perl.logger                    = DEBUG, FileApp, ScreenApp<br/>
<br/>
    log4perl.appender.FileApp          = Log::Log4perl::Appender::File<br/>
    log4perl.appender.FileApp.filename = test.log<br/>
    log4perl.appender.FileApp.layout   = SimpleLayout<br/>
<br/>
    log4perl.appender.ScreenApp          = Log::Log4perl::Appender::Screen<br/>
    log4perl.appender.ScreenApp.stderr   = 0<br/>
    log4perl.appender.ScreenApp.layout   = SimpleLayout<br/>
       ### limiting output to ERROR messages<br/>
    log4perl.appender.ScreenApp.Threshold = ERROR<br/>
       ###<br/>
<div class="spacer">
</div>
Note that without the second appender's &quot;Threshold&quot; setting, both appenders would receive all messages prioritized DEBUG and higher. With the threshold set to ERROR, the second appender will filter the messages as required.</div>
<div class="subsection">
<h2>Where should I put my logfiles?</h2> Your log files may go anywhere you want them, but the effective user id of the calling process must have write access.<div class="spacer">
</div>
If the log file doesn't exist at program start, Log4perl's file appender will create it. For this, it needs write access to the directory where the new file will be located in. If the log file already exists at startup, the process simply needs write access to the file. Note that it will need write access to the file's directory if you're encountering situations where the logfile gets recreated, e.g. during log rotation.<div class="spacer">
</div>
If Log::Log4perl is used by a web server application (e.g. in a CGI script or mod_perl), then the webserver's user (usually &quot;nobody&quot; or &quot;www&quot;) must have the permissions mentioned above.<div class="spacer">
</div>
To prepare your web server to use log4perl, we'd recommend:<div class="spacer">
</div>
<br/>
    webserver:~$ su -<br/>
    webserver:~# mkdir /var/log/cgiapps<br/>
    webserver:~# chown nobody:root /var/log/cgiapps/<br/>
    webserver:~# chown nobody:root -R /var/log/cgiapps/<br/>
    webserver:~# chmod 02755 -R /var/log/cgiapps/<br/>
<div class="spacer">
</div>
Then set your /etc/log4perl.conf file to include:<div class="spacer">
</div>
<br/>
    log4perl.appender.FileAppndr1.filename = <br/>
        /var/log/cgiapps/&lt;app-name&gt;.log<br/>
</div>
<div class="subsection">
<h2>How can my file appender deal with disappearing log files?</h2> The file appender that comes with Log4perl, Log::Log4perl::Appender::File, will open a specified log file at initialization time and will keep writing to it via a file handle.<div class="spacer">
</div>
In case the associated file goes way, messages written by a long-running process will still be written to the file handle. In case the file has been moved to a different location on the same file system, the writer will keep writing to it under the new filename. In case the file has been removed from the file system, the log messages will end up in nowhere land. This is not a bug in Log4perl, this is how Unix works. There is no error message in this case, because the writer has no idea that the file handle is not associated with a visible file.<div class="spacer">
</div>
To prevent the loss of log messages when log files disappear, the file appender's &quot;recreate&quot; option needs to be set to a true value:<div class="spacer">
</div>
<br/>
    log4perl.appender.Logfile.recreate = 1<br/>
<div class="spacer">
</div>
This will instruct the file appender to check in regular intervals (default: 30 seconds) if the log file is still there. If it finds out that the file is missing, it will recreate it.<div class="spacer">
</div>
Continuously checking if the log file still exists is fairly expensive. For this reason it is only performed every 30 seconds. To change this interval, the option &quot;recreate_check_interval&quot; can be set to the number of seconds between checks. In the extreme case where the check should be performed before every write, it can even be set to 0:<div class="spacer">
</div>
<br/>
    log4perl.appender.Logfile.recreate = 1<br/>
    log4perl.appender.Logfile.recreate_check_interval = 0<br/>
<div class="spacer">
</div>
To avoid having to check the file system so frequently, a signal handler can be set up:<div class="spacer">
</div>
<br/>
    log4perl.appender.Logfile.recreate = 1<br/>
    log4perl.appender.Logfile.recreate_check_signal = USR1<br/>
<div class="spacer">
</div>
This will install a signal handler which will recreate a missing log file immediatly when it receives the defined signal.<div class="spacer">
</div>
Note that the <i>init_and_watch()</i> method for Log4perl's initialization can also be instructed to install a signal handler, usually using the HUP signal. Make sure to use a different signal if you're using both of them at the same time.</div>
<div class="subsection">
<h2>How can I rotate a logfile with newsyslog?</h2> Here's a few things that need to be taken care of when using the popular log file rotating utilty &quot;newsyslog&quot; (http://www.courtesan.com/newsyslog) with Log4perl's file appender in long-running processes.<div class="spacer">
</div>
For example, with a newsyslog configuration like<div class="spacer">
</div>
<br/>
    # newsyslog.conf<br/>
    /tmp/test.log 666  12  5  *  B<br/>
<div class="spacer">
</div>
and a call to<div class="spacer">
</div>
<br/>
    # newsyslog -f /path/to/newsyslog.conf<br/>
<div class="spacer">
</div>
&quot;newsyslog&quot; will take action if &quot;/tmp/test.log&quot; is larger than the specified 5K in size. It will move the current log file &quot;/tmp/test.log&quot; to &quot;/tmp/test.log.0&quot; and create a new and empty &quot;/tmp/test.log&quot; with the specified permissions (this is why &quot;newsyslog&quot; needs to run as root). An already existing &quot;/tmp/test.log.0&quot; would be moved to &quot;/tmp/test.log.1&quot;, &quot;/tmp/test.log.1&quot; to &quot;/tmp/test.log.2&quot;, and so forth, for every one of a max number of 12 archived logfiles that have been configured in &quot;newsyslog.conf&quot;.<div class="spacer">
</div>
Although a new file has been created, from Log4perl's appender's point of view, this situation is identical to the one described in the previous FAQ entry, labeled &quot;How can my file appender deal with disappearing log files&quot;.<div class="spacer">
</div>
To make sure that log messages are written to the new log file and not to an archived one or end up in nowhere land, the appender's &quot;recreate&quot; and &quot;recreate_check_interval&quot; have to be configured to deal with the 'disappearing' log file.<div class="spacer">
</div>
The situation gets interesting when &quot;newsyslog&quot;'s option to compress archived log files is enabled. This causes the original log file not to be moved, but to disappear. If the file appender isn't configured to recreate the logfile in this situation, log messages will actually be lost without warning. This also applies for the short time frame of &quot;recreate_check_interval&quot; seconds in between the recreator's file checks.<div class="spacer">
</div>
To make sure that no messages get lost, one option is to set the interval to<div class="spacer">
</div>
<br/>
    log4perl.appender.Logfile.recreate_check_interval = 0<br/>
<div class="spacer">
</div>
However, this is fairly expensive. A better approach is to define a signal handler:<div class="spacer">
</div>
<br/>
    log4perl.appender.Logfile.recreate = 1<br/>
    log4perl.appender.Logfile.recreate_check_signal  = USR1<br/>
    log4perl.appender.Logfile.recreate_pid_write = /tmp/myappid<br/>
<div class="spacer">
</div>
As a service for &quot;newsyslog&quot; users, Log4perl's file appender writes the current process ID to a PID file specified by the &quot;recreate_pid_write&quot; option.  &quot;newsyslog&quot; then needs to be configured as in<div class="spacer">
</div>
<br/>
    # newsyslog.conf configuration for compressing archive files and<br/>
    # sending a signal to the Log4perl-enabled application<br/>
    /tmp/test.log 666  12  5  *  B /tmp/myappid 30<br/>
<div class="spacer">
</div>
to send the defined signal (30, which is USR1 on FreeBSD) to the application process at rotation time. Note that the signal number is different on Linux, where USR1 denotes as 10. Check &quot;man signal&quot; for details.</div>
<div class="subsection">
<h2>How can a process under user id A log to a file under user id B?</h2> This scenario often occurs in configurations where processes run under various user IDs but need to write to a log file under a fixed, but different user id.<div class="spacer">
</div>
With a traditional file appender, the log file will probably be created under one user's id and appended to under a different user's id. With a typical umask of 0002, the file will be created with -rw-rw-r-- permissions. If a user who's not in the first user's group subsequently appends to the log file, it will fail because of a permission problem.<div class="spacer">
</div>
Two potential solutions come to mind:<dl>
<dt>
&#8226;</dt>
<dd>
Creating the file with a umask of 0000 will allow all users to append to the log file. Log4perl's file appender &quot;Log::Log4perl::Appender::File&quot; has an &quot;umask&quot; option that can be set to support this:<div style="height: 1.00em;">
&#160;</div>
<br/>
    log4perl.appender.File = Log::Log4perl::Appender::File<br/>
    log4perl.appender.File.umask = sub { 0000 };<br/>
<div style="height: 1.00em;">
&#160;</div>
This way, the log file will be created with -rw-rw-rw- permissions and therefore has world write permissions. This might open up the logfile for unwanted manipulations by arbitrary users, though.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Running the process under an effective user id of &quot;root&quot; will allow it to write to the log file, no matter who started the process. However, this is not a good idea, because of security concerns.</dd>
</dl>
<div class="spacer">
</div>
Luckily, under Unix, there's the syslog daemon which runs as root and takes log requests from user processes over a socket and writes them to log files as configured in &quot;/etc/syslog.conf&quot;.<div class="spacer">
</div>
By modifying &quot;/etc/syslog.conf&quot; and HUPing the syslog daemon, you can configure new log files:<div class="spacer">
</div>
<br/>
    # /etc/syslog.conf<br/>
    ...<br/>
    user.* /some/path/file.log<br/>
<div class="spacer">
</div>
Using the &quot;Log::Dispatch::Syslog&quot; appender, which comes with the &quot;Log::Log4perl&quot; distribution, you can then send messages via syslog:<div class="spacer">
</div>
<br/>
    use Log::Log4perl qw(:easy);<br/>
<br/>
    Log::Log4perl-&gt;init(\&lt;&lt;EOT);<br/>
        log4perl.logger = DEBUG, app<br/>
        log4perl.appender.app=Log::Dispatch::Syslog<br/>
        log4perl.appender.app.Facility=user<br/>
        log4perl.appender.app.layout=SimpleLayout<br/>
    EOT<br/>
    <br/>
        # Writes to /some/path/file.log<br/>
    ERROR &quot;Message!&quot;;<br/>
<div class="spacer">
</div>
This way, the syslog daemon will solve the permission problem.<div class="spacer">
</div>
Note that while it is possible to use <i>syslog()</i> without Log4perl (syslog supports log levels, too), traditional syslog setups have a significant drawback.<div class="spacer">
</div>
Without Log4perl's ability to activate logging in only specific parts of a system, complex systems will trigger log events all over the place and slow down execution to a crawl at high debug levels.<div class="spacer">
</div>
Remote-controlling logging in the hierarchical parts of an application via Log4perl's categories is one of its most distinguished features. It allows for enabling high debug levels in specified areas without noticable performance impact.</div>
<div class="subsection">
<h2>I want to use UTC instead of the local time!</h2> If a layout defines a date, Log::Log4perl uses local time to populate it. If you want UTC instead, set<div class="spacer">
</div>
<br/>
    $Log::Log4perl::DateFormat::GMTIME = 1;<br/>
<div class="spacer">
</div>
in your program before the first log statement.</div>
<div class="subsection">
<h2>Can Log4perl intercept messages written to a filehandle?</h2> You have a function that prints to a filehandle. You want to tie into that filehandle and forward all arriving messages to a Log4perl logger.<div class="spacer">
</div>
First, let's write a package that ties a file handle and forwards it to a Log4perl logger:<div class="spacer">
</div>
<br/>
    package FileHandleLogger;<br/>
    use Log::Log4perl qw(:levels get_logger);<br/>
<br/>
    sub TIEHANDLE {<br/>
       my($class, %options) = @_;<br/>
<br/>
       my $self = {<br/>
           level    =&gt; $DEBUG,<br/>
           category =&gt; '',<br/>
           %options<br/>
       };<br/>
<br/>
       $self-&gt;{logger} = get_logger($self-&gt;{category}),<br/>
       bless $self, $class;<br/>
    }<br/>
<br/>
    sub PRINT {<br/>
        my($self, @rest) = @_;<br/>
        $Log::Log4perl::caller_depth++;<br/>
        $self-&gt;{logger}-&gt;log($self-&gt;{level}, @rest);<br/>
        $Log::Log4perl::caller_depth--;<br/>
    }<br/>
<br/>
    sub PRINTF {<br/>
        my($self, $fmt, @rest) = @_;<br/>
        $Log::Log4perl::caller_depth++;<br/>
        $self-&gt;PRINT(sprintf($fmt, @rest));<br/>
        $Log::Log4perl::caller_depth--;<br/>
    }<br/>
<br/>
    1;<br/>
<div class="spacer">
</div>
Now, if you have a function like<div class="spacer">
</div>
<br/>
    sub function_printing_to_fh {<br/>
        my($fh) = @_;<br/>
        printf $fh &quot;Hi there!\n&quot;;<br/>
    }<br/>
<div class="spacer">
</div>
which takes a filehandle and prints something to it, it can be used with Log4perl:<div class="spacer">
</div>
<br/>
    use Log::Log4perl qw(:easy);<br/>
    usa FileHandleLogger;<br/>
<br/>
    Log::Log4perl-&gt;easy_init($DEBUG);<br/>
<br/>
    tie *SOMEHANDLE, 'FileHandleLogger' or<br/>
        die &quot;tie failed ($!)&quot;;<br/>
<br/>
    function_printing_to_fh(*SOMEHANDLE);<br/>
        # prints &quot;2007/03/22 21:43:30 Hi there!&quot;<br/>
<div class="spacer">
</div>
If you want, you can even specify a different log level or category:<div class="spacer">
</div>
<br/>
    tie *SOMEHANDLE, 'FileHandleLogger',<br/>
        level =&gt; $INFO, category =&gt; &quot;Foo::Bar&quot; or die &quot;tie failed ($!)&quot;;<br/>
</div>
<div class="subsection">
<h2>I want multiline messages rendered line-by-line!</h2> With the standard &quot;PatternLayout&quot;, if you send a multiline message to an appender as in<div class="spacer">
</div>
<br/>
    use Log::Log4perl qw(:easy);<br/>
    Log<br/>
<div class="spacer">
</div>
it gets rendered this way:<div class="spacer">
</div>
<br/>
    2007/04/04 23:23:39 multi<br/>
    line<br/>
    message<br/>
<div class="spacer">
</div>
If you want each line to be rendered separately according to the layout use &quot;Log::Log4perl::Layout::PatternLayout::Multiline&quot;:<div class="spacer">
</div>
<br/>
    use Log::Log4perl qw(:easy);<br/>
<br/>
    Log::Log4perl-&gt;init(\&lt;&lt;EOT);<br/>
      log4perl.category         = DEBUG, Screen<br/>
      log4perl.appender.Screen = Log::Log4perl::Appender::Screen<br/>
      log4perl.appender.Screen.layout = \\<br/>
        Log::Log4perl::Layout::PatternLayout::Multiline<br/>
      log4perl.appender.Screen.layout.ConversionPattern = %d %m %n<br/>
    EOT<br/>
    <br/>
    DEBUG &quot;some\nmultiline\nmessage&quot;;<br/>
<div class="spacer">
</div>
and you'll get<div class="spacer">
</div>
<br/>
    2007/04/04 23:23:39 some <br/>
    2007/04/04 23:23:39 multiline <br/>
    2007/04/04 23:23:39 message<br/>
<div class="spacer">
</div>
instead.</div>
<div class="subsection">
<h2>I'm on Windows and I'm getting all these 'redefined' messages!</h2> If you're on Windows and are getting warning messages like<div class="spacer">
</div>
<br/>
  Constant subroutine Log::Log4perl::_INTERNAL_DEBUG redefined at<br/>
    C:/Programme/Perl/lib/constant.pm line 103.<br/>
  Subroutine import redefined at<br/>
    C:/Programme/Perl/site/lib/Log/Log4Perl.pm line 69.<br/>
  Subroutine initialized redefined at<br/>
    C:/Programme/Perl/site/lib/Log/Log4Perl.pm line 207.<br/>
<div class="spacer">
</div>
then chances are that you're using 'Log::Log4Perl' (wrong uppercase P) instead of the correct 'Log::Log4perl'. Perl on Windows doesn't handle this error well and spits out a slew of confusing warning messages. But now you know, just use the correct module name and you'll be fine.</div>
<div class="subsection">
<h2>Log4perl complains that no initialization happened during shutdown!</h2> If you're using Log4perl log commands in DESTROY methods of your objects, you might see confusing messages like<div class="spacer">
</div>
<br/>
    Log4perl: Seems like no initialization happened. Forgot to call init()?<br/>
    Use of uninitialized value in subroutine entry at<br/>
    /home/y/lib/perl5/site_perl/5.6.1/Log/Log4perl.pm line 134 during global<br/>
    destruction. (in cleanup) Undefined subroutine &amp;main:: called at<br/>
    /home/y/lib/perl5/site_perl/5.6.1/Log/Log4perl.pm line 134 during global<br/>
    destruction.<br/>
<div class="spacer">
</div>
when the program shuts down. What's going on?<div class="spacer">
</div>
This phenomenon happens if you have circular references in your objects, which perl can't clean up when an object goes out of scope but waits until global destruction instead. At this time, however, Log4perl has already shut down, so you can't use it anymore.<div class="spacer">
</div>
For example, here's a simple class which uses a logger in its DESTROY method:<div class="spacer">
</div>
<br/>
    package A;<br/>
    use Log::Log4perl qw(:easy);<br/>
    sub new { bless {}, shift }<br/>
    sub DESTROY { DEBUG &quot;Waaah!&quot;; }<br/>
<div class="spacer">
</div>
Now, if the main program creates a self-referencing object, like in<div class="spacer">
</div>
<br/>
    package main;<br/>
    use Log::Log4perl qw(:easy);<br/>
    Log::Log4perl-&gt;easy_init($DEBUG);<br/>
<br/>
    my $a = A-&gt;new();<br/>
    $a-&gt;{selfref} = $a;<br/>
<div class="spacer">
</div>
then you'll see the error message shown above during global destruction. How to tackle this problem?<div class="spacer">
</div>
First, you should clean up your circular references before global destruction. They will not only cause objects to be destroyed in an order that's hard to predict, but also eat up memory until the program shuts down.<div class="spacer">
</div>
So, the program above could easily be fixed by putting<div class="spacer">
</div>
<br/>
    $a-&gt;{selfref} = undef;<br/>
<div class="spacer">
</div>
at the end or in an END handler. If that's hard to do, use weak references:<div class="spacer">
</div>
<br/>
    package main;<br/>
    use Scalar::Util qw(weaken);<br/>
    use Log::Log4perl qw(:easy);<br/>
    Log::Log4perl-&gt;easy_init($DEBUG);<br/>
<br/>
    my $a = A-&gt;new();<br/>
    $a-&gt;{selfref} = weaken $a;<br/>
<div class="spacer">
</div>
This allows perl to clean up the circular reference when the object goes out of scope, and doesn't wait until global destruction.</div>
<div class="subsection">
<h2>How can I access POE heap values from Log4perl's layout?</h2> POE is a framework for creating multitasked applications running in a single process and a single thread. POE's threads equivalents are 'sessions' and since they run quasi-simultaneously, you can't use Log4perl's global NDC/MDC to hold session-specific data.<div class="spacer">
</div>
However, POE already maintains a data store for every session. It is called 'heap' and is just a hash storing session-specific data in key-value pairs. To access this per-session heap data from a Log4perl layout, define a custom cspec and reference it with the newly defined pattern in the layout:<div class="spacer">
</div>
<br/>
    use strict;<br/>
    use POE;<br/>
    use Log::Log4perl qw(:easy);<br/>
<br/>
    Log::Log4perl-&gt;init( \ q{<br/>
        log4perl.logger = DEBUG, Screen<br/>
        log4perl.appender.Screen = Log::Log4perl::Appender::Screen<br/>
        log4perl.appender.Screen.layout = PatternLayout<br/>
        log4perl.appender.Screen.layout.ConversionPattern = %U %m%n<br/>
        log4perl.PatternLayout.cspec.U = \<br/>
            sub { POE::Kernel-&gt;get_active_session-&gt;get_heap()-&gt;{ user } }<br/>
    } );<br/>
<br/>
    for (qw( Huey Lewey Dewey )) {<br/>
        POE::Session-&gt;create(<br/>
            inline_states =&gt; {<br/>
                _start    =&gt; sub {<br/>
                    $_[HEAP]-&gt;{user} = $_;<br/>
                    POE::Kernel-&gt;yield('hello');<br/>
                },<br/>
                hello     =&gt; sub {<br/>
                    DEBUG &quot;I'm here now&quot;;<br/>
                }<br/>
            }<br/>
        );<br/>
    }<br/>
<br/>
    POE::Kernel-&gt;run();<br/>
    exit;<br/>
<div class="spacer">
</div>
The code snippet above defines a new layout placeholder (called 'cspec' in Log4perl) %U which calls a subroutine, retrieves the active session, gets its heap and looks up the entry specified ('user').<div class="spacer">
</div>
Starting with Log::Log4perl 1.20, cspecs also support parameters in curly braces, so you can say<div class="spacer">
</div>
<br/>
    log4perl.appender.Screen.layout.ConversionPattern = %U{user} %U{id} %m%n<br/>
    log4perl.PatternLayout.cspec.U = \<br/>
            sub { POE::Kernel-&gt;get_active_session-&gt; \<br/>
                  get_heap()-&gt;{ $_[0]-&gt;{curlies} } }<br/>
<div class="spacer">
</div>
and print the POE session heap entries 'user' and 'id' with every logged message. For more details on cpecs, read the PatternLayout manual.</div>
<div class="subsection">
<h2>I want to print something unconditionally!</h2> Sometimes it's a script that's supposed to log messages regardless if Log4perl has been initialized or not. Or there's a logging statement that's not going to be suppressed under any circumstances -- many people want to have the final word, make the executive decision, because it seems like the only logical choice.<div class="spacer">
</div>
But think about it: First off, if a messages is supposed to be printed, where is it supposed to end up at? STDOUT? STDERR? And are you sure you want to set in stone that this message needs to be printed, while someone else might find it annoying and wants to get rid of it?<div class="spacer">
</div>
The truth is, there's always going to be someone who wants to log a messages at all cost, but also another person who wants to suppress it with equal vigilance. There's no good way to serve these two conflicting desires, someone will always want to win at the cost of leaving the other party dissappointed.<div class="spacer">
</div>
So, the best Log4perl offers is the ALWAYS level for a message that even fires if the system log level is set to $OFF:<div class="spacer">
</div>
<br/>
    use Log::Log4perl qw(:easy);<br/>
<br/>
    Log::Log4perl-&gt;easy_init( $OFF );<br/>
    ALWAYS &quot;This gets logged always. Well, almost always&quot;;<br/>
<div class="spacer">
</div>
The logger won't fire, though, if Log4perl hasn't been initialized or if someone defines a custom log hurdle that's higher than $OFF.<div class="spacer">
</div>
Bottom line: Leave the setting of the logging level to the initial Perl script -- let their owners decided what they want, no matter how tempting it may be to decide it for them.</div>
</div>
<div class="section">
<h1>SEE ALSO</h1> Log::Log4perl</div>
<div class="section">
<h1>COPYRIGHT AND LICENSE</h1> Copyright 2002-2009 by Mike Schilli &lt;m@perlmeister.com&gt; and Kevin Goess &lt;cpan@goess.org&gt;.<div class="spacer">
</div>
This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</div>
<table class="foot">
<tr>
<td class="foot-date">
2010-06-17</td>
<td class="foot-os">
perl v5.10.1</td>
</tr>
</table>
</div>
</body>
</html>

