<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Moose::Cookbook::Basics::Recipe1(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Moose::Cookbook::Basics::Recipe1(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
Moose::Cookbook::Basics::Recipe1(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Moose::Cookbook::Basics::Recipe1 - The (always classic) Point example.</div>
<div class="section">
<h1>VERSION</h1> version 2.0401</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
  package Point;<br/>
  use Moose;<br/>
<br/>
  has 'x' =&gt; (isa =&gt; 'Int', is =&gt; 'rw', required =&gt; 1);<br/>
  has 'y' =&gt; (isa =&gt; 'Int', is =&gt; 'rw', required =&gt; 1);<br/>
<br/>
  sub clear {<br/>
      my $self = shift;<br/>
      $self-&gt;x(0);<br/>
      $self-&gt;y(0);<br/>
  }<br/>
<br/>
  package Point3D;<br/>
  use Moose;<br/>
<br/>
  extends 'Point';<br/>
<br/>
  has 'z' =&gt; (isa =&gt; 'Int', is =&gt; 'rw', required =&gt; 1);<br/>
<br/>
  after 'clear' =&gt; sub {<br/>
      my $self = shift;<br/>
      $self-&gt;z(0);<br/>
  };<br/>
<br/>
  package main;<br/>
<br/>
  # hash or hashrefs are ok for the constructor<br/>
  my $point1 = Point-&gt;new(x =&gt; 5, y =&gt; 7);<br/>
  my $point2 = Point-&gt;new({x =&gt; 5, y =&gt; 7});<br/>
<br/>
  my $point3d = Point3D-&gt;new(x =&gt; 5, y =&gt; 42, z =&gt; -5);<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> This is the classic Point example. It is taken directly from the Perl 6 Apocalypse 12 document, and is similar to the example found in the classic K&amp;R C book as well.<div class="spacer">
</div>
As with all Perl 5 classes, a Moose class is defined in a package. Moose handles turning on &quot;strict&quot; and &quot;warnings&quot; for us, so all we need to do is say &quot;use Moose&quot;, and no kittens will die.<div class="spacer">
</div>
When Moose is loaded, it exports a set of sugar functions into our package. This means that we import some functions which serve as Moose &quot;keywords&quot;. These aren't real language keywords, they're just Perl functions exported into our package.<div class="spacer">
</div>
Moose automatically makes our package a subclass of Moose::Object. The Moose::Object class provides us with a constructor that respects our attributes, as well other features. See Moose::Object for details.<div class="spacer">
</div>
Now, onto the keywords. The first one we see here is &quot;has&quot;, which defines an instance attribute in our class:<div class="spacer">
</div>
<br/>
  has 'x' =&gt; (isa =&gt; 'Int', is =&gt; 'rw', required =&gt; 1);<br/>
<div class="spacer">
</div>
This will create an attribute named &quot;x&quot;. The &quot;isa&quot; parameter says that we expect the value stored in this attribute to pass the type constraint for &quot;Int&quot; (1). The accessor generated for this attribute will be read-write.<div class="spacer">
</div>
The &quot;required =&gt; 1&quot; parameter means that this attribute must be provided when a new object is created. A point object without coordinates doesn't make much sense, so we don't allow it.<div class="spacer">
</div>
We have defined our attributes; next we define our methods. In Moose, as with regular Perl 5 OO, a method is just a subroutine defined within the package:<div class="spacer">
</div>
<br/>
  sub clear {<br/>
      my $self = shift;<br/>
      $self-&gt;x(0);<br/>
      $self-&gt;y(0);<br/>
  }<br/>
<div class="spacer">
</div>
That concludes the <b>Point</b> class.<div class="spacer">
</div>
Next we have a subclass of <b>Point</b>, <b>Point3D</b>. To declare our superclass, we use the Moose keyword &quot;extends&quot;:<div class="spacer">
</div>
<br/>
  extends 'Point';<br/>
<div class="spacer">
</div>
The &quot;extends&quot; keyword works much like &quot;use base&quot;. First, it will attempt to load your class if needed. However, unlike &quot;base&quot;, the &quot;extends&quot; keyword will  <i>overwrite</i> any previous values in your package's @ISA, where &quot;use base&quot; will &quot;push&quot; values onto the package's @ISA.<div class="spacer">
</div>
It is my opinion that the behavior of &quot;extends&quot; is more intuitive. (2).<div class="spacer">
</div>
Next we create a new attribute for <b>Point3D</b> called &quot;z&quot;.<div class="spacer">
</div>
<br/>
  has 'z' =&gt; (isa =&gt; 'Int', is =&gt; 'rw', required =&gt; 1);<br/>
<div class="spacer">
</div>
This attribute is just like <b>Point</b>'s &quot;x&quot; and &quot;y&quot; attributes.<div class="spacer">
</div>
The &quot;after&quot; keyword demonstrates a Moose feature called &quot;method modifiers&quot; (or &quot;advice&quot; for the AOP inclined):<div class="spacer">
</div>
<br/>
  after 'clear' =&gt; sub {<br/>
      my $self = shift;<br/>
      $self-&gt;z(0);<br/>
  };<br/>
<div class="spacer">
</div>
When &quot;clear&quot; is called on a <b>Point3D</b> object, our modifier method gets called as well. Unsurprisingly, the modifier is called  <i>after</i> the real method.<div class="spacer">
</div>
In this case, the real &quot;clear&quot; method is inherited from <b>Point</b>. Our modifier method receives the same arguments as those passed to the modified method (just $self here).<div class="spacer">
</div>
Of course, using the &quot;after&quot; modifier is not the only way to accomplish this. This  <b>is</b> Perl, right? You can get the same results with this code:<div class="spacer">
</div>
<br/>
  sub clear {<br/>
      my $self = shift;<br/>
      $self-&gt;SUPER::clear();<br/>
      $self-&gt;z(0);<br/>
  }<br/>
<div class="spacer">
</div>
You could also use another Moose method modifier, &quot;override&quot;:<div class="spacer">
</div>
<br/>
  override 'clear' =&gt; sub {<br/>
      my $self = shift;<br/>
      super();<br/>
      $self-&gt;z(0);<br/>
  };<br/>
<div class="spacer">
</div>
The &quot;override&quot; modifier allows you to use the &quot;super&quot; keyword to dispatch to the superclass's method in a very Ruby-ish style.<div class="spacer">
</div>
The choice of whether to use a method modifier, and which one to use, is often a question of style as much as functionality.<div class="spacer">
</div>
Since <b>Point</b> inherits from Moose::Object, it will also inherit the default Moose::Object constructor:<div class="spacer">
</div>
<br/>
  my $point1 = Point-&gt;new(x =&gt; 5, y =&gt; 7);<br/>
  my $point2 = Point-&gt;new({x =&gt; 5, y =&gt; 7});<br/>
<br/>
  my $point3d = Point3D-&gt;new(x =&gt; 5, y =&gt; 42, z =&gt; -5);<br/>
<div class="spacer">
</div>
The &quot;new&quot; constructor accepts a named argument pair for each attribute defined by the class, which you can provide as a hash or hash reference. In this particular example, the attributes are required, and calling &quot;new&quot; without them will throw an error.<div class="spacer">
</div>
<br/>
  my $point = Point-&gt;new( x =&gt; 5 ); # no y, kaboom!<br/>
<div class="spacer">
</div>
From here on, we can use $point and $point3d just as you would any other Perl 5 object. For a more detailed example of what can be done, you can refer to the  <i>t/recipes/moose_cookbook_basics_recipe1.t</i> test file.<div class="subsection">
<h2>Moose Objects are Just Hashrefs</h2> While this all may appear rather magical, it's important to realize that Moose objects are just hash references under the hood (3). For example, you could pass $self to &quot;Data::Dumper&quot; and you'd get exactly what you'd expect.<div class="spacer">
</div>
You could even poke around inside the object's data structure, but that is strongly discouraged.<div class="spacer">
</div>
The fact that Moose objects are hashrefs means it is easy to use Moose to extend non-Moose classes, as long as they too are hash references. If you want to extend a non-hashref class, check out &quot;MooseX::InsideOut&quot;.</div>
</div>
<div class="section">
<h1>CONCLUSION</h1> This recipe demonstrates some basic Moose concepts, attributes, subclassing, and a simple method modifier.</div>
<div class="section">
<h1>FOOTNOTES</h1><dl>
<dt>
(1)</dt>
<dd>
Moose provides a number of builtin type constraints, of which &quot;Int&quot; is one. For more information on the type constraint system, see Moose::Util::TypeConstraints.</dd>
</dl>
<dl>
<dt>
(2)</dt>
<dd>
The &quot;extends&quot; keyword supports multiple inheritance. Simply pass all of your superclasses to &quot;extends&quot; as a list:<div style="height: 1.00em;">
&#160;</div>
<br/>
  extends 'Foo', 'Bar', 'Baz';<br/>
</dd>
</dl>
<dl>
<dt>
(3)</dt>
<dd>
Moose supports using instance structures other than blessed hash references (such as glob references - see MooseX::GlobRef).</dd>
</dl>
</div>
<div class="section">
<h1>SEE ALSO</h1><dl>
<dt>
Method Modifiers</dt>
<dd>
The concept of method modifiers is directly ripped off from CLOS. A great explanation of them can be found by following this link.<div style="height: 1.00em;">
&#160;</div>
http://www.gigamonkeys.com/book/object-reorientation-generic-functions.html &lt;http://www.gigamonkeys.com/book/object-reorientation-generic-functions.html&gt;</dd>
</dl>
</div>
<div class="section">
<h1>AUTHOR</h1> Moose is maintained by the Moose Cabal, along with the help of many contributors. See &quot;CABAL&quot; in Moose and &quot;CONTRIBUTORS&quot; in Moose for details.</div>
<div class="section">
<h1>COPYRIGHT AND LICENSE</h1> This software is copyright (c) 2011 by Infinity Interactive, Inc..<div class="spacer">
</div>
This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5 programming language system itself.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-11-17</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

