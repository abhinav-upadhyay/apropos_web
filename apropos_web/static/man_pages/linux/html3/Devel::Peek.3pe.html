<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Devel::Peek(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Devel::Peek(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
Devel::Peek(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Devel::Peek - A data debugging tool for the XS programmer</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
        use Devel::Peek;<br/>
        Dump( $a );<br/>
        Dump( $a, 5 );<br/>
        DumpArray( 5, $a, $b, ... );<br/>
        mstat &quot;Point 5&quot;;<br/>
<br/>
        use Devel::Peek ':opd=st';<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> Devel::Peek contains functions which allows raw Perl datatypes to be manipulated from a Perl script.  This is used by those who do XS programming to check that the data they are sending from C to Perl looks as they think it should look.  The trick, then, is to know what the raw datatype is supposed to look like when it gets to Perl.  This document offers some tips and hints to describe good and bad raw data.<div class="spacer">
</div>
It is very possible that this document will fall far short of being useful to the casual reader.  The reader is expected to understand the material in the first few sections of perlguts.<div class="spacer">
</div>
Devel::Peek supplies a &quot;Dump()&quot; function which can dump a raw Perl datatype, and &quot;mstat(&quot;marker&quot;)&quot; function to report on memory usage (if perl is compiled with corresponding option).  The function  <i>DeadCode()</i> provides statistics on the data &quot;frozen&quot; into inactive &quot;CV&quot;.  Devel::Peek also supplies &quot;SvREFCNT()&quot;, &quot;SvREFCNT_inc()&quot;, and &quot;SvREFCNT_dec()&quot; which can query, increment, and decrement reference counts on SVs.  This document will take a passive, and safe, approach to data debugging and for that it will describe only the &quot;Dump()&quot; function.<div class="spacer">
</div>
Function &quot;DumpArray()&quot; allows dumping of multiple values (useful when you need to analyze returns of functions).<div class="spacer">
</div>
The global variable $Devel::Peek::pv_limit can be set to limit the number of character printed in various string values.  Setting it to 0 means no limit.<div class="spacer">
</div>
If &quot;use Devel::Peek&quot; directive has a &quot;:opd=FLAGS&quot; argument, this switches on debugging of opcode dispatch.  &quot;FLAGS&quot; should be a combination of &quot;s&quot;, &quot;t&quot;, and &quot;P&quot; (see  <b>-D</b> flags in perlrun). &quot;:opd&quot; is a shortcut for &quot;:opd=st&quot;.<div class="subsection">
<h2>Runtime debugging</h2> &quot;CvGV($cv)&quot; return one of the globs associated to a subroutine reference $cv.<div class="spacer">
</div>
<i>debug_flags()</i> returns a string representation of $^D (similar to what is allowed for  <b>-D</b> flag).  When called with a numeric argument, sets $^D to the corresponding value.  When called with an argument of the form &quot;flags-flags&quot;, set on/off bits of $^D corresponding to letters before/after &quot;-&quot;.  (The returned value is for $^D before the modification.)<div class="spacer">
</div>
<i>runops_debug()</i> returns true if the current <i>opcode dispatcher</i> is the debugging one.  When called with an argument, switches to debugging or non-debugging dispatcher depending on the argument (active for newly-entered subs/etc only).  (The returned value is for the dispatcher before the modification.)</div>
<div class="subsection">
<h2>Memory footprint debugging</h2> When perl is compiled with support for memory footprint debugging (default with Perl's  <i>malloc()</i>), Devel::Peek provides an access to this API.<div class="spacer">
</div>
Use <i>mstat()</i> function to emit a memory state statistic to the terminal. For more information on the format of output of  <i>mstat()</i> see &quot;Using $ENV{PERL_DEBUG_MSTATS}&quot; in perldebguts.<div class="spacer">
</div>
Three additional functions allow access to this statistic from Perl. First, use &quot;mstats_fillhash(%hash)&quot; to get the information contained in the output of  <i>mstat()</i> into %hash. The field of this hash are<div class="spacer">
</div>
<br/>
  minbucket nbuckets sbrk_good sbrk_slack sbrked_remains sbrks start_slack<br/>
  topbucket topbucket_ev topbucket_odd total total_chain total_sbrk totfree<br/>
<div class="spacer">
</div>
Two additional fields &quot;free&quot;, &quot;used&quot; contain array references which provide per-bucket count of free and used chunks.  Two other fields &quot;mem_size&quot;, &quot;available_size&quot; contain array references which provide the information about the allocated size and usable size of chunks in each bucket.  Again, see &quot;Using $ENV{PERL_DEBUG_MSTATS}&quot; in perldebguts for details.<div class="spacer">
</div>
Keep in mind that only the first several &quot;odd-numbered&quot; buckets are used, so the information on size of the &quot;odd-numbered&quot; buckets which are not used is probably meaningless.<div class="spacer">
</div>
The information in<div class="spacer">
</div>
<br/>
 mem_size available_size minbucket nbuckets<br/>
<div class="spacer">
</div>
is the property of a particular build of perl, and does not depend on the current process.  If you do not provide the optional argument to the functions  <i>mstats_fillhash()</i>, <i>fill_mstats()</i>, <i>mstats2hash()</i>, then the information in fields &quot;mem_size&quot;, &quot;available_size&quot; is not updated.<div class="spacer">
</div>
&quot;fill_mstats($buf)&quot; is a much cheaper call (both speedwise and memory-wise) which collects the statistic into $buf in machine-readable form.  At a later moment you may need to call &quot;mstats2hash($buf, %hash)&quot; to use this information to fill %hash.<div class="spacer">
</div>
All three APIs &quot;fill_mstats($buf)&quot;, &quot;mstats_fillhash(%hash)&quot;, and &quot;mstats2hash($buf, %hash)&quot; are designed to allocate no memory if used  <i>the second time</i> on the same $buf and/or %hash.<div class="spacer">
</div>
So, if you want to collect memory info in a cycle, you may call<div class="spacer">
</div>
<br/>
  $#buf = 999;<br/>
  fill_mstats($_) for @buf;<br/>
  mstats_fillhash(%report, 1);          # Static info too<br/>
<br/>
  foreach (@buf) {<br/>
    # Do something...<br/>
    fill_mstats $_;                     # Collect statistic<br/>
  }<br/>
  foreach (@buf) {<br/>
    mstats2hash($_, %report);           # Preserve static info<br/>
    # Do something with %report<br/>
  }<br/>
</div>
</div>
<div class="section">
<h1>EXAMPLES</h1> The following examples don't attempt to show everything as that would be a monumental task, and, frankly, we don't want this manpage to be an internals document for Perl.  The examples do demonstrate some basics of the raw Perl datatypes, and should suffice to get most determined people on their way. There are no guidewires or safety nets, nor blazed trails, so be prepared to travel alone from this point and on and, if at all possible, don't fall into the quicksand (it's bad for business).<div class="spacer">
</div>
Oh, one final bit of advice: take perlguts with you.  When you return we expect to see it well-thumbed.<div class="subsection">
<h2>A simple scalar string</h2> Let's begin by looking a simple scalar which is holding a string.<div class="spacer">
</div>
<br/>
        use Devel::Peek;<br/>
        $a = 42; $a = &quot;hello&quot;;<br/>
        Dump $a;<br/>
<div class="spacer">
</div>
The output:<div class="spacer">
</div>
<br/>
        SV = PVIV(0xbc288) at 0xbe9a8<br/>
          REFCNT = 1<br/>
          FLAGS = (POK,pPOK)<br/>
          IV = 42<br/>
          PV = 0xb2048 &quot;hello&quot;\0<br/>
          CUR = 5<br/>
          LEN = 8<br/>
<div class="spacer">
</div>
This says $a is an SV, a scalar.  The scalar type is a PVIV, which is capable of holding an integer (IV) and/or a string (PV) value. The scalar's head is allocated at address 0xbe9a8, while the body is at 0xbc288. Its reference count is 1.  It has the &quot;POK&quot; flag set, meaning its current PV field is valid.  Because POK is set we look at the PV item to see what is in the scalar.  The \0 at the end indicate that this PV is properly NUL-terminated. Note that the IV field still contains its old numeric value, but because FLAGS doesn't have IOK set, we must ignore the IV item. CUR indicates the number of characters in the PV.  LEN indicates the number of bytes allocated for the PV (at least one more than CUR, because LEN includes an extra byte for the end-of-string marker, then usually rounded up to some efficient allocation unit).</div>
<div class="subsection">
<h2>A simple scalar number</h2> If the scalar contains a number the raw SV will be leaner.<div class="spacer">
</div>
<br/>
        use Devel::Peek;<br/>
        $a = 42;<br/>
        Dump $a;<br/>
<div class="spacer">
</div>
The output:<div class="spacer">
</div>
<br/>
        SV = IV(0xbc818) at 0xbe9a8<br/>
          REFCNT = 1<br/>
          FLAGS = (IOK,pIOK)<br/>
          IV = 42<br/>
<div class="spacer">
</div>
This says $a is an SV, a scalar.  The scalar is an IV, a number.  Its reference count is 1.  It has the &quot;IOK&quot; flag set, meaning it is currently being evaluated as a number.  Because IOK is set we look at the IV item to see what is in the scalar.</div>
<div class="subsection">
<h2>A simple scalar with an extra reference</h2> If the scalar from the previous example had an extra reference:<div class="spacer">
</div>
<br/>
        use Devel::Peek;<br/>
        $a = 42;<br/>
        $b = \$a;<br/>
        Dump $a;<br/>
<div class="spacer">
</div>
The output:<div class="spacer">
</div>
<br/>
        SV = IV(0xbe860) at 0xbe9a8<br/>
          REFCNT = 2<br/>
          FLAGS = (IOK,pIOK)<br/>
          IV = 42<br/>
<div class="spacer">
</div>
Notice that this example differs from the previous example only in its reference count.  Compare this to the next example, where we dump $b instead of $a.</div>
<div class="subsection">
<h2>A reference to a simple scalar</h2> This shows what a reference looks like when it references a simple scalar.<div class="spacer">
</div>
<br/>
        use Devel::Peek;<br/>
        $a = 42;<br/>
        $b = \$a;<br/>
        Dump $b;<br/>
<div class="spacer">
</div>
The output:<div class="spacer">
</div>
<br/>
        SV = IV(0xf041c) at 0xbe9a0<br/>
          REFCNT = 1<br/>
          FLAGS = (ROK)<br/>
          RV = 0xbab08<br/>
          SV = IV(0xbe860) at 0xbe9a8<br/>
            REFCNT = 2<br/>
            FLAGS = (IOK,pIOK)<br/>
            IV = 42<br/>
<div class="spacer">
</div>
Starting from the top, this says $b is an SV.  The scalar is an IV, which is capable of holding an integer or reference value. It has the &quot;ROK&quot; flag set, meaning it is a reference (rather than an integer or string).  Notice that Dump follows the reference and shows us what $b was referencing.  We see the same $a that we found in the previous example.<div class="spacer">
</div>
Note that the value of &quot;RV&quot; coincides with the numbers we see when we stringify $b. The addresses inside  <i>IV()</i> are addresses of &quot;X***&quot; structures which hold the current state of an &quot;SV&quot;. This address may change during lifetime of an SV.</div>
<div class="subsection">
<h2>A reference to an array</h2> This shows what a reference to an array looks like.<div class="spacer">
</div>
<br/>
        use Devel::Peek;<br/>
        $a = [42];<br/>
        Dump $a;<br/>
<div class="spacer">
</div>
The output:<div class="spacer">
</div>
<br/>
        SV = IV(0xc85998) at 0xc859a8<br/>
          REFCNT = 1<br/>
          FLAGS = (ROK)<br/>
          RV = 0xc70de8<br/>
          SV = PVAV(0xc71e10) at 0xc70de8<br/>
            REFCNT = 1<br/>
            FLAGS = ()<br/>
            ARRAY = 0xc7e820<br/>
            FILL = 0<br/>
            MAX = 0<br/>
            ARYLEN = 0x0<br/>
            FLAGS = (REAL)<br/>
            Elt No. 0<br/>
            SV = IV(0xc70f88) at 0xc70f98<br/>
              REFCNT = 1<br/>
              FLAGS = (IOK,pIOK)<br/>
              IV = 42<br/>
<div class="spacer">
</div>
This says $a is a reference (ROK), which points to another SV which is a PVAV, an array.  The array has one element, element zero, which is another SV. The field &quot;FILL&quot; above indicates the last element in the array, similar to &quot;$#$a&quot;.<div class="spacer">
</div>
If $a pointed to an array of two elements then we would see the following.<div class="spacer">
</div>
<br/>
        use Devel::Peek 'Dump';<br/>
        $a = [42,24];<br/>
        Dump $a;<br/>
<div class="spacer">
</div>
The output:<div class="spacer">
</div>
<br/>
        SV = IV(0x158c998) at 0x158c9a8<br/>
          REFCNT = 1<br/>
          FLAGS = (ROK)<br/>
          RV = 0x1577de8<br/>
          SV = PVAV(0x1578e10) at 0x1577de8<br/>
            REFCNT = 1<br/>
            FLAGS = ()<br/>
            ARRAY = 0x1585820<br/>
            FILL = 1<br/>
            MAX = 1<br/>
            ARYLEN = 0x0<br/>
            FLAGS = (REAL)<br/>
            Elt No. 0<br/>
            SV = IV(0x1577f88) at 0x1577f98<br/>
              REFCNT = 1<br/>
              FLAGS = (IOK,pIOK)<br/>
              IV = 42<br/>
            Elt No. 1<br/>
            SV = IV(0x158be88) at 0x158be98<br/>
              REFCNT = 1<br/>
              FLAGS = (IOK,pIOK)<br/>
              IV = 24<br/>
<div class="spacer">
</div>
Note that &quot;Dump&quot; will not report <i>all</i> the elements in the array, only several first (depending on how deep it already went into the report tree).</div>
<div class="subsection">
<h2>A reference to a hash</h2> The following shows the raw form of a reference to a hash.<div class="spacer">
</div>
<br/>
        use Devel::Peek;<br/>
        $a = {hello=&gt;42};<br/>
        Dump $a;<br/>
<div class="spacer">
</div>
The output:<div class="spacer">
</div>
<br/>
        SV = IV(0x8177858) at 0x816a618<br/>
          REFCNT = 1<br/>
          FLAGS = (ROK)<br/>
          RV = 0x814fc10<br/>
          SV = PVHV(0x8167768) at 0x814fc10<br/>
            REFCNT = 1<br/>
            FLAGS = (SHAREKEYS)<br/>
            ARRAY = 0x816c5b8  (0:7, 1:1)<br/>
            hash quality = 100.0%<br/>
            KEYS = 1<br/>
            FILL = 1<br/>
            MAX = 7<br/>
            RITER = -1<br/>
            EITER = 0x0<br/>
            Elt &quot;hello&quot; HASH = 0xc8fd181b<br/>
            SV = IV(0x816c030) at 0x814fcf4<br/>
              REFCNT = 1<br/>
              FLAGS = (IOK,pIOK)<br/>
              IV = 42<br/>
<div class="spacer">
</div>
This shows $a is a reference pointing to an SV.  That SV is a PVHV, a hash. Fields RITER and EITER are used by &quot;each&quot;.<div class="spacer">
</div>
The &quot;quality&quot; of a hash is defined as the total number of comparisons needed to access every element once, relative to the expected number needed for a random hash. The value can go over 100%.<div class="spacer">
</div>
The total number of comparisons is equal to the sum of the squares of the number of entries in each bucket.  For a random hash of &quot;&lt;n&quot;&gt; keys into &quot;&lt;k&quot;&gt; buckets, the expected value is:<div class="spacer">
</div>
<br/>
                n + n(n-1)/2k<br/>
</div>
<div class="subsection">
<h2>Dumping a large array or hash</h2> The &quot;Dump()&quot; function, by default, dumps up to 4 elements from a toplevel array or hash.  This number can be increased by supplying a second argument to the function.<div class="spacer">
</div>
<br/>
        use Devel::Peek;<br/>
        $a = [10,11,12,13,14];<br/>
        Dump $a;<br/>
<div class="spacer">
</div>
Notice that &quot;Dump()&quot; prints only elements 10 through 13 in the above code. The following code will print all of the elements.<div class="spacer">
</div>
<br/>
        use Devel::Peek 'Dump';<br/>
        $a = [10,11,12,13,14];<br/>
        Dump $a, 5;<br/>
</div>
<div class="subsection">
<h2>A reference to an SV which holds a C pointer</h2> This is what you really need to know as an XS programmer, of course.  When an XSUB returns a pointer to a C structure that pointer is stored in an SV and a reference to that SV is placed on the XSUB stack.  So the output from an XSUB which uses something like the T_PTROBJ map might look something like this:<div class="spacer">
</div>
<br/>
        SV = IV(0xf381c) at 0xc859a8<br/>
          REFCNT = 1<br/>
          FLAGS = (ROK)<br/>
          RV = 0xb8ad8<br/>
          SV = PVMG(0xbb3c8) at 0xc859a0<br/>
            REFCNT = 1<br/>
            FLAGS = (OBJECT,IOK,pIOK)<br/>
            IV = 729160<br/>
            NV = 0<br/>
            PV = 0<br/>
            STASH = 0xc1d10       &quot;CookBookB::Opaque&quot;<br/>
<div class="spacer">
</div>
This shows that we have an SV which is a reference, which points at another SV.  In this case that second SV is a PVMG, a blessed scalar.  Because it is blessed it has the &quot;OBJECT&quot; flag set.  Note that an SV which holds a C pointer also has the &quot;IOK&quot; flag set.  The &quot;STASH&quot; is set to the package name which this SV was blessed into.<div class="spacer">
</div>
The output from an XSUB which uses something like the T_PTRREF map, which doesn't bless the object, might look something like this:<div class="spacer">
</div>
<br/>
        SV = IV(0xf381c) at 0xc859a8<br/>
          REFCNT = 1<br/>
          FLAGS = (ROK)<br/>
          RV = 0xb8ad8<br/>
          SV = PVMG(0xbb3c8) at 0xc859a0<br/>
            REFCNT = 1<br/>
            FLAGS = (IOK,pIOK)<br/>
            IV = 729160<br/>
            NV = 0<br/>
            PV = 0<br/>
</div>
<div class="subsection">
<h2>A reference to a subroutine</h2> Looks like this:<div class="spacer">
</div>
<br/>
        SV = IV(0x24d2dd8) at 0x24d2de8<br/>
          REFCNT = 1<br/>
          FLAGS = (TEMP,ROK)<br/>
          RV = 0x24e79d8<br/>
          SV = PVCV(0x24e5798) at 0x24e79d8<br/>
            REFCNT = 2<br/>
            FLAGS = ()<br/>
            COMP_STASH = 0x22c9c50      &quot;main&quot;<br/>
            START = 0x22eed60 ===&gt; 0<br/>
            ROOT = 0x22ee490<br/>
            GVGV::GV = 0x22de9d8        &quot;MY&quot; :: &quot;top_targets&quot;<br/>
            FILE = &quot;(eval 5)&quot;<br/>
            DEPTH = 0<br/>
            FLAGS = 0x0<br/>
            OUTSIDE_SEQ = 93<br/>
            PADLIST = 0x22e9ed8<br/>
            PADNAME = 0x22e9ec0(0x22eed00) PAD = 0x22e9ea8(0x22eecd0)<br/>
            OUTSIDE = 0x22c9fb0 (MAIN)<br/>
<div class="spacer">
</div>
This shows that<dl>
<dt>
&#8226;</dt>
<dd>
the subroutine is not an XSUB (since &quot;START&quot; and &quot;ROOT&quot; are non-zero, and &quot;XSUB&quot; is not listed, and is thus null);</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
that it was compiled in the package &quot;main&quot;;</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
under the name &quot;MY::top_targets&quot;;</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
inside a 5th eval in the program;</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
it is not currently executed (see &quot;DEPTH&quot;);</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
it has no prototype (&quot;PROTOTYPE&quot; field is missing).</dd>
</dl>
</div>
</div>
<div class="section">
<h1>EXPORTS</h1> &quot;Dump&quot;, &quot;mstat&quot;, &quot;DeadCode&quot;, &quot;DumpArray&quot;, &quot;DumpWithOP&quot; and &quot;DumpProg&quot;, &quot;fill_mstats&quot;, &quot;mstats_fillhash&quot;, &quot;mstats2hash&quot; by default. Additionally available &quot;SvREFCNT&quot;, &quot;SvREFCNT_inc&quot; and &quot;SvREFCNT_dec&quot;.</div>
<div class="section">
<h1>BUGS</h1> Readers have been known to skip important parts of perlguts, causing much frustration for all.</div>
<div class="section">
<h1>AUTHOR</h1> Ilya Zakharevich	ilya@math.ohio-state.edu<div class="spacer">
</div>
Copyright (c) 1995-98 Ilya Zakharevich. All rights reserved. This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.<div class="spacer">
</div>
Author of this software makes no claim whatsoever about suitability, reliability, edability, editability or usability of this product, and should not be kept liable for any damage resulting from the use of it. If you can use it, you are in luck, if not, I should not be kept responsible. Keep a handy copy of your backup tape at hand.</div>
<div class="section">
<h1>SEE ALSO</h1> perlguts, and perlguts, again.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-09-26</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

