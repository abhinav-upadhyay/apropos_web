<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Filter(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Filter(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
Filter(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Log::Log4perl::Filter - Log4perl Custom Filter Base Class</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
  use Log::Log4perl;<br/>
<br/>
  Log::Log4perl-&gt;init(\ &lt;&lt;'EOT');<br/>
    log4perl.logger = INFO, Screen<br/>
    log4perl.filter.MyFilter        = sub { /let this through/ }<br/>
    log4perl.appender.Screen        = Log::Log4perl::Appender::Screen<br/>
    log4perl.appender.Screen.Filter = MyFilter<br/>
    log4perl.appender.Screen.layout = Log::Log4perl::Layout::SimpleLayout<br/>
  EOT<br/>
<br/>
      # Define a logger<br/>
  my $logger = Log::Log4perl-&gt;get_logger(&quot;Some&quot;);<br/>
<br/>
      # Let this through<br/>
  $logger-&gt;info(&quot;Here's the info, let this through!&quot;);<br/>
<br/>
      # Suppress this<br/>
  $logger-&gt;info(&quot;Here's the info, suppress this!&quot;);<br/>
<br/>
  #################################################################<br/>
  # StringMatch Filter:<br/>
  #################################################################<br/>
  log4perl.filter.M1               = Log::Log4perl::Filter::StringMatch<br/>
  log4perl.filter.M1.StringToMatch = let this through<br/>
  log4perl.filter.M1.AcceptOnMatch = true<br/>
<br/>
  #################################################################<br/>
  # LevelMatch Filter:<br/>
  #################################################################<br/>
  log4perl.filter.M1               = Log::Log4perl::Filter::LevelMatch<br/>
  log4perl.filter.M1.LevelToMatch  = INFO<br/>
  log4perl.filter.M1.AcceptOnMatch = true<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> Log4perl allows the use of customized filters in its appenders to control the output of messages. These filters might grep for certain text chunks in a message, verify that its priority matches or exceeds a certain level or that this is the 10th time the same message has been submitted -- and come to a log/no log decision based upon these circumstantial facts.<div class="spacer">
</div>
Filters have names and can be specified in two different ways in the Log4perl configuration file: As subroutines or as filter classes. Here's a simple filter named &quot;MyFilter&quot; which just verifies that the oncoming message matches the regular expression &quot;/let this through/i&quot;:<div class="spacer">
</div>
<br/>
    log4perl.filter.MyFilter        = sub { /let this through/i }<br/>
<div class="spacer">
</div>
It exploits the fact that when the subroutine defined above is called on a message, Perl's special $_ variable will be set to the message text (prerendered, i.e. concatenated but not layouted) to be logged. The subroutine is expected to return a true value if it wants the message to be logged or a false value if doesn't.<div class="spacer">
</div>
Also, Log::Log4perl will pass a hash to the subroutine, containing all key/value pairs that it would pass to the corresponding appender, as specified in Log::Log4perl::Appender. Here's an example of a filter checking the priority of the oncoming message:<div class="spacer">
</div>
<br/>
  log4perl.filter.MyFilter        = sub {    \<br/>
       my %p = @_;                           \<br/>
       if($p{log4p_level} eq &quot;WARN&quot; or       \<br/>
          $p{log4p_level} eq &quot;INFO&quot;) {       \<br/>
           return 1;                         \<br/>
       }                                     \<br/>
       return 0;                             \<br/>
  }<br/>
<div class="spacer">
</div>
If the message priority equals &quot;WARN&quot; or &quot;INFO&quot;, it returns a true value, causing the message to be logged.<div class="subsection">
<h2>Predefined Filters</h2> For common tasks like verifying that the message priority matches a certain priority, there's already a set of predefined filters available. To perform an exact level match, it's much cleaner to use Log4perl's &quot;LevelMatch&quot; filter instead:<div class="spacer">
</div>
<br/>
  log4perl.filter.M1               = Log::Log4perl::Filter::LevelMatch<br/>
  log4perl.filter.M1.LevelToMatch  = INFO<br/>
  log4perl.filter.M1.AcceptOnMatch = true<br/>
<div class="spacer">
</div>
This will let the message through if its priority is INFO and suppress it otherwise. The statement can be negated by saying<div class="spacer">
</div>
<br/>
  log4perl.filter.M1.AcceptOnMatch = false<br/>
<div class="spacer">
</div>
instead. This way, the message will be logged if its priority is anything but INFO.<div class="spacer">
</div>
On a similar note, Log4perl's &quot;StringMatch&quot; filter will check the oncoming message for strings or regular expressions:<div class="spacer">
</div>
<br/>
  log4perl.filter.M1               = Log::Log4perl::Filter::StringMatch<br/>
  log4perl.filter.M1.StringToMatch = bl.. bl..<br/>
  log4perl.filter.M1.AcceptOnMatch = true<br/>
<div class="spacer">
</div>
This will open the gate for messages like &quot;blah blah&quot; because the regular expression in the &quot;StringToMatch&quot; matches them. Again, the setting of &quot;AcceptOnMatch&quot; determines if the filter is defined in a positive or negative way.<div class="spacer">
</div>
All class filter entries in the configuration file have to adhere to the following rule: Only after a filter has been defined by name and class/subroutine, its attribute values can be assigned, just like the &quot;true&quot; value above gets assigned to the &quot;AcceptOnMatch&quot; attribute  <i>after</i> the filter &quot;M1&quot; has been defined.</div>
<div class="subsection">
<h2>Attaching a filter to an appender</h2> Attaching a filter to an appender is as easy as assigning its name to the appender's &quot;Filter&quot; attribute:<div class="spacer">
</div>
<br/>
    log4perl.appender.MyAppender.Filter = MyFilter<br/>
<div class="spacer">
</div>
This will cause &quot;Log::Log4perl&quot; to call the filter subroutine/method every time a message is supposed to be passed to the appender. Depending on the filter's return value, &quot;Log::Log4perl&quot; will either continue as planned or withdraw immediately.</div>
<div class="subsection">
<h2>Combining filters with Log::Log4perl::Filter::Boolean</h2> Sometimes, it's useful to combine the output of various filters to arrive at a log/no log decision. While Log4j, Log4perl's mother ship, has chosen to implement this feature as a filter chain, similar to Linux' IP chains, Log4perl tries a different approach.<div class="spacer">
</div>
Typically, filter results will not need to be bumped along chains but combined in a programmatic manner using boolean logic. &quot;Log if this filter says 'yes' and that filter says 'no'&quot; is a fairly common requirement, but hard to implement as a chain.<div class="spacer">
</div>
&quot;Log::Log4perl::Filter::Boolean&quot; is a specially predefined custom filter for Log4perl. It combines the results of other custom filters in arbitrary ways, using boolean expressions:<div class="spacer">
</div>
<br/>
    log4perl.logger = WARN, AppWarn, AppError<br/>
<br/>
    log4perl.filter.Match1       = sub { /let this through/ }<br/>
    log4perl.filter.Match2       = sub { /and that, too/ }<br/>
    log4perl.filter.MyBoolean       = Log::Log4perl::Filter::Boolean<br/>
    log4perl.filter.MyBoolean.logic = Match1 || Match2<br/>
<br/>
    log4perl.appender.Screen        = Log::Log4perl::Appender::Screen<br/>
    log4perl.appender.Screen.Filter = MyBoolean<br/>
    log4perl.appender.Screen.layout = Log::Log4perl::Layout::SimpleLayout<br/>
<div class="spacer">
</div>
&quot;Log::Log4perl::Filter::Boolean&quot;'s boolean expressions allow for combining different appenders by name using AND (&amp;&amp; or &amp;), OR (|| or |) and NOT (!) as logical expressions. Also, parentheses can be used for defining precedences. Operator precedence follows standard Perl conventions. Here's a bunch of examples:<div class="spacer">
</div>
<br/>
    Match1 &amp;&amp; !Match2            # Match1 and not Match2<br/>
    !(Match1 || Match2)          # Neither Match1 nor Match2<br/>
    (Match1 &amp;&amp; Match2) || Match3 # Both Match1 and Match2 or Match3<br/>
</div>
<div class="subsection">
<h2>Writing your own filter classes</h2> If none of Log::Log4perl's predefined filter classes fits your needs, you can easily roll your own: Just define a new class, derive it from the baseclass &quot;Log::Log4perl::Filter&quot;, and define its &quot;new&quot; and &quot;ok&quot; methods like this:<div class="spacer">
</div>
<br/>
    package Log::Log4perl::Filter::MyFilter;<br/>
<br/>
    use base Log::Log4perl::Filter;<br/>
<br/>
    sub new {<br/>
        my ($class, %options) = @_;<br/>
<br/>
        my $self = { %options,<br/>
                   };<br/>
     <br/>
        bless $self, $class;<br/>
<br/>
        return $self;<br/>
    }<br/>
<br/>
    sub ok {<br/>
         my ($self, %p) = @_;<br/>
<br/>
         # ... decide and return 1 or 0<br/>
    }<br/>
<br/>
    1;<br/>
<div class="spacer">
</div>
Log4perl will call the <i>ok()</i> method to determine if the filter should let the message pass or not. A true return value indicates the message will be logged by the appender, a false value blocks it.<div class="spacer">
</div>
Values you've defined for its attributes in Log4perl's configuration file, will be received through its &quot;new&quot; method:<div class="spacer">
</div>
<br/>
    log4perl.filter.MyFilter       = Log::Log4perl::Filter::MyFilter<br/>
    log4perl.filter.MyFilter.color = red<br/>
<div class="spacer">
</div>
will cause &quot;Log::Log4perl::Filter::MyFilter&quot;'s constructor to be called like this:<div class="spacer">
</div>
<br/>
    Log::Log4perl::Filter::MyFilter-&gt;new( name  =&gt; &quot;MyFilter&quot;,<br/>
                                          color =&gt; &quot;red&quot; );<br/>
<div class="spacer">
</div>
The custom filter class should use this to set the object's attributes, to have them available later to base log/nolog decisions on it.<div class="spacer">
</div>
&quot;ok()&quot; is the filter's method to tell if it agrees or disagrees with logging the message. It will be called by Log::Log4perl whenever it needs the filter to decide. A false value returned by &quot;ok()&quot; will block messages, a true value will let them through.</div>
<div class="subsection">
<h2>A Practical Example: Level Matching</h2> See Log::Log4perl::FAQ for this.</div>
</div>
<div class="section">
<h1>SEE ALSO</h1> Log::Log4perl::Filter::LevelMatch, Log::Log4perl::Filter::LevelRange, Log::Log4perl::Filter::StringRange, Log::Log4perl::Filter::Boolean</div>
<div class="section">
<h1>COPYRIGHT AND LICENSE</h1> Copyright 2002-2009 by Mike Schilli &lt;m@perlmeister.com&gt; and Kevin Goess &lt;cpan@goess.org&gt;.<div class="spacer">
</div>
This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</div>
<table class="foot">
<tr>
<td class="foot-date">
2010-02-24</td>
<td class="foot-os">
perl v5.10.1</td>
</tr>
</table>
</div>
</body>
</html>

