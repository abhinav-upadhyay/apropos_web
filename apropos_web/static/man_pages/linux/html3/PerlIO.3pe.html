<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
PerlIO(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
PerlIO(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
PerlIO(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> PerlIO - On demand loader for PerlIO layers and root of PerlIO::* name space</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
  open($fh,&quot;&lt;:crlf&quot;, &quot;my.txt&quot;); # support platform-native and CRLF text files<br/>
<br/>
  open($fh,&quot;&lt;&quot;,&quot;his.jpg&quot;);      # portably open a binary file for reading<br/>
  binmode($fh);<br/>
<br/>
  Shell:<br/>
    PERLIO=perlio perl ....<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> When an undefined layer 'foo' is encountered in an &quot;open&quot; or &quot;binmode&quot; layer specification then C code performs the equivalent of:<div class="spacer">
</div>
<br/>
  use PerlIO 'foo';<br/>
<div class="spacer">
</div>
The perl code in PerlIO.pm then attempts to locate a layer by doing<div class="spacer">
</div>
<br/>
  require PerlIO::foo;<br/>
<div class="spacer">
</div>
Otherwise the &quot;PerlIO&quot; package is a place holder for additional PerlIO related functions.<div class="spacer">
</div>
The following layers are currently defined:<dl>
<dt>
:unix</dt>
<dd>
Lowest level layer which provides basic PerlIO operations in terms of UNIX/POSIX numeric file descriptor calls ( <i>open()</i>, <i>read()</i>, <i>write()</i>, <i>lseek()</i>, <i>close()</i>).</dd>
</dl>
<dl>
<dt>
:stdio</dt>
<dd>
Layer which calls &quot;fread&quot;, &quot;fwrite&quot; and &quot;fseek&quot;/&quot;ftell&quot; etc.  Note that as this is &quot;real&quot; stdio it will ignore any layers beneath it and go straight to the operating system via the C library as usual.</dd>
</dl>
<dl>
<dt>
:perlio</dt>
<dd>
A from scratch implementation of buffering for PerlIO. Provides fast access to the buffer for &quot;sv_gets&quot; which implements perl's readline/&lt;&gt; and in general attempts to minimize data copying.<div style="height: 1.00em;">
&#160;</div>
&quot;:perlio&quot; will insert a &quot;:unix&quot; layer below itself to do low level IO.</dd>
</dl>
<dl>
<dt>
:crlf</dt>
<dd>
A layer that implements DOS/Windows like CRLF line endings.  On read converts pairs of CR,LF to a single &quot;\n&quot; newline character.  On write converts each &quot;\n&quot; to a CR,LF pair.  Note that this layer will silently refuse to be pushed on top of itself.<div style="height: 1.00em;">
&#160;</div>
It currently does <i>not</i> mimic MS-DOS as far as treating of Control-Z as being an end-of-file marker.<div style="height: 1.00em;">
&#160;</div>
Based on the &quot;:perlio&quot; layer.</dd>
</dl>
<dl>
<dt>
:mmap</dt>
<dd>
A layer which implements &quot;reading&quot; of files by using &quot;mmap()&quot; to make a (whole) file appear in the process's address space, and then using that as PerlIO's &quot;buffer&quot;. This  <i>may</i> be faster in certain circumstances for large files, and may result in less physical memory use when multiple processes are reading the same file.<div style="height: 1.00em;">
&#160;</div>
Files which are not &quot;mmap()&quot;-able revert to behaving like the &quot;:perlio&quot; layer. Writes also behave like the &quot;:perlio&quot; layer, as &quot;mmap()&quot; for write needs extra house-keeping (to extend the file) which negates any advantage.<div style="height: 1.00em;">
&#160;</div>
The &quot;:mmap&quot; layer will not exist if the platform does not support &quot;mmap()&quot;.</dd>
</dl>
<dl>
<dt>
:utf8</dt>
<dd>
Declares that the stream accepts perl's <i>internal</i> encoding of characters.  (Which really is UTF-8 on ASCII machines, but is UTF-EBCDIC on EBCDIC machines.)  This allows any character perl can represent to be read from or written to the stream. The UTF-X encoding is chosen to render simple text parts (i.e.  non-accented letters, digits and common punctuation) human readable in the encoded file.<div style="height: 1.00em;">
&#160;</div>
Here is how to write your native data out using UTF-8 (or UTF-EBCDIC) and then read it back in.<div style="height: 1.00em;">
&#160;</div>
<br/>
        open(F, &quot;&gt;:utf8&quot;, &quot;data.utf&quot;);<br/>
        print F $out;<br/>
        close(F);<br/>
<br/>
        open(F, &quot;&lt;:utf8&quot;, &quot;data.utf&quot;);<br/>
        $in = &lt;F&gt;;<br/>
        close(F);<br/>
<div style="height: 1.00em;">
&#160;</div>
Note that this layer does not validate byte sequences. For reading input, using &quot;:encoding(utf8)&quot; instead of bare &quot;:utf8&quot; is strongly recommended.</dd>
</dl>
<dl>
<dt>
:bytes</dt>
<dd>
This is the inverse of the &quot;:utf8&quot; layer. It turns off the flag on the layer below so that data read from it is considered to be &quot;octets&quot; i.e. characters in the range 0..255 only. Likewise on output perl will warn if a &quot;wide&quot; character is written to a such a stream.</dd>
</dl>
<dl>
<dt>
:raw</dt>
<dd>
The &quot;:raw&quot; layer is <i>defined</i> as being identical to calling &quot;binmode($fh)&quot; - the stream is made suitable for passing binary data, i.e. each byte is passed as-is. The stream will still be buffered.<div style="height: 1.00em;">
&#160;</div>
In Perl 5.6 and some books the &quot;:raw&quot; layer (previously sometimes also referred to as a &quot;discipline&quot;) is documented as the inverse of the &quot;:crlf&quot; layer. That is no longer the case - other layers which would alter the binary nature of the stream are also disabled.  If you want UNIX line endings on a platform that normally does CRLF translation, but still want UTF-8 or encoding defaults, the appropriate thing to do is to add &quot;:perlio&quot; to the PERLIO environment variable.<div style="height: 1.00em;">
&#160;</div>
The implementation of &quot;:raw&quot; is as a pseudo-layer which when &quot;pushed&quot; pops itself and then any layers which do not declare themselves as suitable for binary data. (Undoing :utf8 and :crlf are implemented by clearing flags rather than popping layers but that is an implementation detail.)<div style="height: 1.00em;">
&#160;</div>
As a consequence of the fact that &quot;:raw&quot; normally pops layers, it usually only makes sense to have it as the only or first element in a layer specification.  When used as the first element it provides a known base on which to build e.g.<div style="height: 1.00em;">
&#160;</div>
<br/>
    open($fh,&quot;:raw:utf8&quot;,...)<br/>
<div style="height: 1.00em;">
&#160;</div>
will construct a &quot;binary&quot; stream, but then enable UTF-8 translation.</dd>
</dl>
<dl>
<dt>
:pop</dt>
<dd>
A pseudo layer that removes the top-most layer. Gives perl code a way to manipulate the layer stack. Should be considered as experimental. Note that &quot;:pop&quot; only works on real layers and will not undo the effects of pseudo layers like &quot;:utf8&quot;. An example of a possible use might be:<div style="height: 1.00em;">
&#160;</div>
<br/>
    open($fh,...)<br/>
    ...<br/>
    binmode($fh,&quot;:encoding(...)&quot;);  # next chunk is encoded<br/>
    ...<br/>
    binmode($fh,&quot;:pop&quot;);            # back to un-encoded<br/>
<div style="height: 1.00em;">
&#160;</div>
A more elegant (and safer) interface is needed.</dd>
</dl>
<dl>
<dt>
:win32</dt>
<dd>
On Win32 platforms this <i>experimental</i> layer uses the native &quot;handle&quot; IO rather than the unix-like numeric file descriptor layer. Known to be buggy as of perl 5.8.2.</dd>
</dl>
<div class="subsection">
<h2>Custom Layers</h2> It is possible to write custom layers in addition to the above builtin ones, both in C/XS and Perl.  Two such layers (and one example written in Perl using the latter) come with the Perl distribution.<dl>
<dt>
:encoding</dt>
<dd>
Use &quot;:encoding(ENCODING)&quot; either in <i>open()</i> or <i>binmode()</i> to install a layer that transparently does character set and encoding transformations, for example from Shift-JIS to Unicode.  Note that under &quot;stdio&quot; an &quot;:encoding&quot; also enables &quot;:utf8&quot;.  See PerlIO::encoding for more information.</dd>
</dl>
<dl>
<dt>
:via</dt>
<dd>
Use &quot;:via(MODULE)&quot; either in <i>open()</i> or <i>binmode()</i> to install a layer that does whatever transformation (for example compression / decompression, encryption / decryption) to the filehandle. See PerlIO::via for more information.</dd>
</dl>
</div>
<div class="subsection">
<h2>Alternatives to raw</h2> To get a binary stream an alternate method is to use:<div class="spacer">
</div>
<br/>
    open($fh,&quot;whatever&quot;)<br/>
    binmode($fh);<br/>
<div class="spacer">
</div>
this has the advantage of being backward compatible with how such things have had to be coded on some platforms for years.<div class="spacer">
</div>
To get an unbuffered stream specify an unbuffered layer (e.g. &quot;:unix&quot;) in the open call:<div class="spacer">
</div>
<br/>
    open($fh,&quot;&lt;:unix&quot;,$path)<br/>
</div>
<div class="subsection">
<h2>Defaults and how to override them</h2> If the platform is MS-DOS like and normally does CRLF to &quot;\n&quot; translation for text files then the default layers are :<div class="spacer">
</div>
<br/>
  unix crlf<br/>
<div class="spacer">
</div>
(The low level &quot;unix&quot; layer may be replaced by a platform specific low level layer.)<div class="spacer">
</div>
Otherwise if &quot;Configure&quot; found out how to do &quot;fast&quot; IO using the system's stdio, then the default layers are:<div class="spacer">
</div>
<br/>
  unix stdio<br/>
<div class="spacer">
</div>
Otherwise the default layers are<div class="spacer">
</div>
<br/>
  unix perlio<br/>
<div class="spacer">
</div>
These defaults may change once perlio has been better tested and tuned.<div class="spacer">
</div>
The default can be overridden by setting the environment variable PERLIO to a space separated list of layers (&quot;unix&quot; or platform low level layer is always pushed first).<div class="spacer">
</div>
This can be used to see the effect of/bugs in the various layers e.g.<div class="spacer">
</div>
<br/>
  cd .../perl/t<br/>
  PERLIO=stdio  ./perl harness<br/>
  PERLIO=perlio ./perl harness<br/>
<div class="spacer">
</div>
For the various values of PERLIO see &quot;PERLIO&quot; in perlrun.</div>
<div class="subsection">
<h2>Querying the layers of filehandles</h2> The following returns the  <b>names</b> of the PerlIO layers on a filehandle.<div class="spacer">
</div>
<br/>
   my @layers = PerlIO::get_layers($fh); # Or FH, *FH, &quot;FH&quot;.<br/>
<div class="spacer">
</div>
The layers are returned in the order an <i>open()</i> or <i>binmode()</i> call would use them.  Note that the &quot;default stack&quot; depends on the operating system and on the Perl version, and both the compile-time and runtime configurations of Perl.<div class="spacer">
</div>
The following table summarizes the default layers on UNIX-like and DOS-like platforms and depending on the setting of $ENV{PERLIO}:<div class="spacer">
</div>
<br/>
 PERLIO     UNIX-like                   DOS-like<br/>
 ------     ---------                   --------<br/>
 unset / &quot;&quot; unix perlio / stdio [1]     unix crlf<br/>
 stdio      unix perlio / stdio [1]     stdio<br/>
 perlio     unix perlio                 unix perlio<br/>
 mmap       unix mmap                   unix mmap<br/>
<br/>
 # [1] &quot;stdio&quot; if Configure found out how to do &quot;fast stdio&quot; (depends<br/>
 # on the stdio implementation) and in Perl 5.8, otherwise &quot;unix perlio&quot;<br/>
<div class="spacer">
</div>
By default the layers from the input side of the filehandle are returned; to get the output side, use the optional &quot;output&quot; argument:<div class="spacer">
</div>
<br/>
   my @layers = PerlIO::get_layers($fh, output =&gt; 1);<br/>
<div class="spacer">
</div>
(Usually the layers are identical on either side of a filehandle but for example with sockets there may be differences, or if you have been using the &quot;open&quot; pragma.)<div class="spacer">
</div>
There is no <i>set_layers()</i>, nor does <i>get_layers()</i> return a tied array mirroring the stack, or anything fancy like that.  This is not accidental or unintentional.  The PerlIO layer stack is a bit more complicated than just a stack (see for example the behaviour of &quot;:raw&quot;). You are supposed to use  <i>open()</i> and <i>binmode()</i> to manipulate the stack.<div class="spacer">
</div>
<b>Implementation details follow, please close your eyes.</b><div class="spacer">
</div>
The arguments to layers are by default returned in parentheses after the name of the layer, and certain layers (like &quot;utf8&quot;) are not real layers but instead flags on real layers; to get all of these returned separately, use the optional &quot;details&quot; argument:<div class="spacer">
</div>
<br/>
   my @layer_and_args_and_flags = PerlIO::get_layers($fh, details =&gt; 1);<br/>
<div class="spacer">
</div>
The result will be up to be three times the number of layers: the first element will be a name, the second element the arguments (unspecified arguments will be &quot;undef&quot;), the third element the flags, the fourth element a name again, and so forth.<div class="spacer">
</div>
<b>You may open your eyes now.</b></div>
</div>
<div class="section">
<h1>AUTHOR</h1> Nick Ing-Simmons &lt;nick@ing-simmons.net&gt;</div>
<div class="section">
<h1>SEE ALSO</h1> &quot;binmode&quot; in perlfunc, &quot;open&quot; in perlfunc, perlunicode, perliol, Encode</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-09-19</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

