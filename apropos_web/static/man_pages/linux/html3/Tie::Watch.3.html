<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Tie::Watch(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Tie::Watch(3pm)</td>
<td class="head-vol">
perl/Tk Documentation</td>
<td class="head-rtitle">
Tie::Watch(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1><br/>
 Tie::Watch - place watchpoints on Perl variables.<br/>
</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
 use Tie::Watch;<br/>
<br/>
 $watch = Tie::Watch-&gt;new(<br/>
     -variable =&gt; \$frog,<br/>
     -debug    =&gt; 1,<br/>
     -shadow   =&gt; 0,                      <br/>
     -fetch    =&gt; [\&amp;fetch, 'arg1', 'arg2', ..., 'argn'],<br/>
     -store    =&gt; \&amp;store,<br/>
     -destroy  =&gt; sub {print &quot;Final value=$frog.\n&quot;},<br/>
 }<br/>
 %vinfo = $watch-&gt;Info;<br/>
 $args  = $watch-&gt;Args(-fetch);<br/>
 $val   = $watch-&gt;Fetch;<br/>
 print &quot;val=&quot;, $watch-&gt;Say($val), &quot;.\n&quot;;<br/>
 $watch-&gt;Store('Hello');<br/>
 $watch-&gt;Unwatch;<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> This class module binds one or more subroutines of your devising to a Perl variable.  All variables can have  <b>FETCH</b>, <b>STORE</b> and  <b>DESTROY</b> callbacks.  Additionally, arrays can define <b>CLEAR</b>,  <b>DELETE</b>, <b>EXISTS</b>, <b>EXTEND</b>, <b>FETCHSIZE</b>, <b>POP</b>, <b>PUSH</b>,  <b>SHIFT</b>, <b>SPLICE</b>, <b>STORESIZE</b> and <b>UNSHIFT</b> callbacks, and hashes can define  <b>CLEAR</b>, <b>DELETE</b>, <b>EXISTS</b>, <b>FIRSTKEY</b> and <b>NEXTKEY</b> callbacks.  If these term are unfamiliar to you, I  <i>really</i> suggest you read perltie.<div class="spacer">
</div>
With Tie::Watch you can:<div class="spacer">
</div>
<br/>
 . alter a variable's value<br/>
 . prevent a variable's value from being changed<br/>
 . invoke a Perl/Tk callback when a variable changes<br/>
 . trace references to a variable<br/>
<div class="spacer">
</div>
Callback format is patterned after the Perl/Tk scheme: supply either a code reference, or, supply an array reference and pass the callback code reference in the first element of the array, followed by callback arguments.  (See examples in the Synopsis, above.)<div class="spacer">
</div>
Tie::Watch provides default callbacks for any that you fail to specify.  Other than negatively impacting performance, they perform the standard action that you'd expect, so the variable behaves &quot;normally&quot;.  Once you override a default callback, perhaps to insert debug code like print statements, your callback normally finishes by calling the underlying (overridden) method.  But you don't have to!<div class="spacer">
</div>
To map a tied method name to a default callback name simply lowercase the tied method name and uppercase its first character.  So FETCH becomes Fetch, NEXTKEY becomes Nextkey, etcetera.<div class="spacer">
</div>
Here are two callbacks for a scalar. The <b>FETCH</b> (read) callback does nothing other than illustrate the fact that it returns the value to assign the variable.  The  <b>STORE</b> (write) callback uppercases the variable and returns it.  In all cases the callback  <i>must</i> return the correct read or write value - typically, it does this by invoking the underlying method.<div class="spacer">
</div>
<br/>
 my $fetch_scalar = sub {<br/>
     my($self) = @_;<br/>
     $self-&gt;Fetch;<br/>
 };<br/>
<br/>
 my $store_scalar = sub {<br/>
     my($self, $new_val) = @_;<br/>
     $self-&gt;Store(uc $new_val);<br/>
 };<br/>
<div class="spacer">
</div>
Here are <b>FETCH</b> and <b>STORE</b> callbacks for either an array or hash. They do essentially the same thing as the scalar callbacks, but provide a little more information.<div class="spacer">
</div>
<br/>
 my $fetch = sub {<br/>
     my($self, $key) = @_;<br/>
     my $val = $self-&gt;Fetch($key);<br/>
     print &quot;In fetch callback, key=$key, val=&quot;, $self-&gt;Say($val);<br/>
     my $args = $self-&gt;Args(-fetch);<br/>
     print &quot;, args=('&quot;, join(&quot;', '&quot;,  @$args), &quot;')&quot; if $args;<br/>
     print &quot;.\n&quot;;<br/>
     $val;<br/>
 };<br/>
<br/>
 my $store = sub {<br/>
     my($self, $key, $new_val) = @_;<br/>
     my $val = $self-&gt;Fetch($key);<br/>
     $new_val = uc $new_val;<br/>
     $self-&gt;Store($key, $new_val);<br/>
     print &quot;In store callback, key=$key, val=&quot;, $self-&gt;Say($val),<br/>
       &quot;, new_val=&quot;, $self-&gt;Say($new_val);<br/>
     my $args = $self-&gt;Args(-store);<br/>
     print &quot;, args=('&quot;, join(&quot;', '&quot;,  @$args), &quot;')&quot; if $args;<br/>
     print &quot;.\n&quot;;<br/>
     $new_val;<br/>
 };<br/>
<div class="spacer">
</div>
In all cases, the first parameter is a reference to the Watch object, used to invoke the following class methods.</div>
<div class="section">
<h1>METHODS</h1><dl>
<dt>
$watch = Tie::Watch-&gt;new(-options =&gt; values);</dt>
<dd>
The watchpoint constructor method that accepts option/value pairs to create and configure the Watch object.  The only required option is  <b>-variable</b>.<div style="height: 1.00em;">
&#160;</div>
<b>-variable</b> is a <i>reference</i> to a scalar, array or hash variable.<div style="height: 1.00em;">
&#160;</div>
<b>-debug</b> (default 0) is 1 to activate debug print statements internal to Tie::Watch.<div style="height: 1.00em;">
&#160;</div>
<b>-shadow</b> (default 1) is 0 to disable array and hash shadowing.  To prevent infinite recursion Tie::Watch maintains parallel variables for arrays and hashes.  When the watchpoint is created the parallel shadow variable is initialized with the watched variable's contents, and when the watchpoint is deleted the shadow variable is copied to the original variable.  Thus, changes made during the watch process are not lost. Shadowing is on my default.  If you disable shadowing any changes made to an array or hash are lost when the watchpoint is deleted.<div style="height: 1.00em;">
&#160;</div>
Specify any of the following relevant callback parameters, in the format described above:  <b>-fetch</b>, <b>-store</b>, <b>-destroy</b>. Additionally for arrays:  <b>-clear</b>, <b>-extend</b>, <b>-fetchsize</b>,  <b>-pop</b>, <b>-push</b>, <b>-shift</b>, <b>-splice</b>, <b>-storesize</b> and  <b>-unshift</b>.  Additionally for hashes: <b>-clear</b>, <b>-delete</b>,  <b>-exists</b>, <b>-firstkey</b> and <b>-nextkey</b>.</dd>
</dl>
<dl>
<dt>
$args = $watch-&gt;Args(-fetch);</dt>
<dd>
Returns a reference to a list of arguments for the specified callback, or undefined if none.</dd>
</dl>
<dl>
<dt>
$watch-&gt;<i>Fetch()</i>;  $watch-&gt;Fetch($key);</dt>
<dd>
Returns a variable's current value.  $key is required for an array or hash.</dd>
</dl>
<dl>
<dt>
%vinfo = $watch-&gt;<i>Info()</i>;</dt>
<dd>
Returns a hash detailing the internals of the Watch object, with these keys:<div style="height: 1.00em;">
&#160;</div>
<br/>
 %vinfo = {<br/>
     -variable =&gt;  SCALAR(0x200737f8)<br/>
     -debug    =&gt;  '0'<br/>
     -shadow   =&gt;  '1'<br/>
     -value    =&gt;  'HELLO SCALAR'<br/>
     -destroy  =&gt;  ARRAY(0x200f86cc)<br/>
     -fetch    =&gt;  ARRAY(0x200f8558)<br/>
     -store    =&gt;  ARRAY(0x200f85a0)<br/>
     -legible  =&gt;  above data formatted as a list of string, for printing<br/>
 }<br/>
<div style="height: 1.00em;">
&#160;</div>
For array and hash Watch objects, the <b>-value</b> key is replaced with a  <b>-ptr</b> key which is a reference to the parallel array or hash. Additionally, for an array or hash, there are key/value pairs for all the variable specific callbacks.</dd>
</dl>
<dl>
<dt>
$watch-&gt;Say($val);</dt>
<dd>
Used mainly for debugging, it returns $val in quotes if required, or the string &quot;undefined&quot; for undefined values.</dd>
</dl>
<dl>
<dt>
$watch-&gt;Store($new_val);  $watch-&gt;Store($key, $new_val);</dt>
<dd>
Store a variable's new value.  $key is required for an array or hash.</dd>
</dl>
<dl>
<dt>
$watch-&gt;<i>Unwatch()</i>;</dt>
<dd>
Stop watching the variable.</dd>
</dl>
</div>
<div class="section">
<h1>EFFICIENCY CONSIDERATIONS</h1> If you can live using the class methods provided, please do so.  You can meddle with the object hash directly and improved watch performance, at the risk of your code breaking in the future.</div>
<div class="section">
<h1>AUTHOR</h1> Stephen O. Lidie</div>
<div class="section">
<h1>HISTORY</h1><br/>
 lusol@Lehigh.EDU, LUCC, 96/05/30<br/>
 . Original version 0.92 release, based on the Trace module from Hans Mulder,<br/>
   and ideas from Tim Bunce.<br/>
<br/>
 lusol@Lehigh.EDU, LUCC, 96/12/25<br/>
 . Version 0.96, release two inner references detected by Perl 5.004.<br/>
<br/>
 lusol@Lehigh.EDU, LUCC, 97/01/11<br/>
 . Version 0.97, fix Makefile.PL and MANIFEST (thanks Andreas Koenig).<br/>
   Make sure test.pl doesn't fail if Tk isn't installed.<br/>
<br/>
 Stephen.O.Lidie@Lehigh.EDU, Lehigh University Computing Center, 97/10/03<br/>
 . Version 0.98, implement -shadow option for arrays and hashes.<br/>
<br/>
 Stephen.O.Lidie@Lehigh.EDU, Lehigh University Computing Center, 98/02/11<br/>
 . Version 0.99, finally, with Perl 5.004_57, we can completely watch arrays.<br/>
   With tied array support this module is essentially complete, so its been<br/>
   optimized for speed at the expense of clarity - sorry about that. The<br/>
   Delete() method has been renamed Unwatch() because it conflicts with the<br/>
   builtin delete().<br/>
<br/>
 Stephen.O.Lidie@Lehigh.EDU, Lehigh University Computing Center, 99/04/04<br/>
 . Version 1.0, for Perl 5.005_03, update Makefile.PL for ActiveState, and<br/>
   add two examples (one for Perl/Tk).<br/>
<br/>
 sol0@lehigh.edu, Lehigh University Computing Center, 2003/06/07<br/>
 . Version 1.1, for Perl 5.8, can trace a reference now, patch from Slaven<br/>
   Rezic.<br/>
<br/>
 sol0@lehigh.edu, Lehigh University Computing Center, 2005/05/17<br/>
 . Version 1.2, for Perl 5.8, per Rob Seegel's suggestion, support array<br/>
   DELETE and EXISTS.<br/>
</div>
<div class="section">
<h1>COPYRIGHT</h1> Copyright (C) 1996 - 2005 Stephen O. Lidie. All rights reserved.<div class="spacer">
</div>
This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</div>
<table class="foot">
<tr>
<td class="foot-date">
2010-01-30</td>
<td class="foot-os">
Tk804.029</td>
</tr>
</table>
</div>
</body>
</html>

