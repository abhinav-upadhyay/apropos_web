<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Threading(3)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Threading(3)</td>
<td class="head-vol">
globus common</td>
<td class="head-rtitle">
Threading(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Threading -<div class="subsection">
<h2>Data Structures</h2><br/>
union <b>globus_thread_t</b><div style="height: 0.00em;">
&#160;</div>
<i>Thread ID. </i> union  <b>globus_threadattr_t</b><div style="height: 0.00em;">
&#160;</div>
<i>Thread attributes. </i> union  <b>globus_thread_key_t</b><div style="height: 0.00em;">
&#160;</div>
<i>Thread-specific data key. </i><br/>
</div>
<div class="subsection">
<h2>Modules</h2><br/>
<b>Mutual Exclusion</b><div style="height: 0.00em;">
&#160;</div>
<b>Condition Variables</b><div style="height: 0.00em;">
&#160;</div>
<b>Thread-Specific Storage</b><div style="height: 0.00em;">
&#160;</div>
<b>One-time execution</b><div style="height: 0.00em;">
&#160;</div>
<br/>
</div>
<div class="subsection">
<h2>Defines</h2><br/>
#define <b>GLOBUS_THREAD_CANCEL_DISABLE</b>   0<div style="height: 0.00em;">
&#160;</div>
#define <b>GLOBUS_THREAD_CANCEL_ENABLE</b>   1<div style="height: 0.00em;">
&#160;</div>
#define <b>GLOBUS_THREAD_MODULE</b>   (&amp;globus_i_thread_module)<div style="height: 0.00em;">
&#160;</div>
<br/>
</div>
<div class="subsection">
<h2>Typedefs</h2><br/>
typedef void(* <b>globus_thread_key_destructor_func_t</b> )(void *value)<div style="height: 0.00em;">
&#160;</div>
<br/>
</div>
<div class="subsection">
<h2>Functions</h2><br/>
int <b>globus_thread_set_model</b> (const char *model)<div style="height: 0.00em;">
&#160;</div>
int <b>globus_thread_create</b> (<b>globus_thread_t</b> *thread, <b>globus_threadattr_t</b> *attr, globus_thread_func_t func, void *user_arg)<div style="height: 0.00em;">
&#160;</div>
void <b>globus_thread_yield</b> (void)<div style="height: 0.00em;">
&#160;</div>
void <b>globus_thread_exit</b> (void *value)<div style="height: 0.00em;">
&#160;</div>
int <b>globus_thread_sigmask</b> (int how, const sigset_t *new_mask, sigset_t *old_mask)<div style="height: 0.00em;">
&#160;</div>
int <b>globus_thread_kill</b> (<b>globus_thread_t</b> thread, int sig)<div style="height: 0.00em;">
&#160;</div>
<b>globus_thread_t</b> <b>globus_thread_self</b> (void)<div style="height: 0.00em;">
&#160;</div>
globus_bool_t <b>globus_thread_equal</b> (<b>globus_thread_t</b> thread1, <b>globus_thread_t</b> thread2)<div style="height: 0.00em;">
&#160;</div>
globus_bool_t <b>globus_thread_preemptive_threads</b> (void)<div style="height: 0.00em;">
&#160;</div>
globus_bool_t <b>globus_i_am_only_thread</b> (void)<div style="height: 0.00em;">
&#160;</div>
void * <b>globus_thread_cancellable_func</b> (void *(*func)(void *), void *arg, void(*cleanup_func)(void *), void *cleanup_arg, globus_bool_t execute_cleanup)<div style="height: 0.00em;">
&#160;</div>
int <b>globus_thread_cancel</b> (<b>globus_thread_t</b> thr)<div style="height: 0.00em;">
&#160;</div>
void <b>globus_thread_testcancel</b> (void)<div style="height: 0.00em;">
&#160;</div>
int <b>globus_thread_setcancelstate</b> (int state, int *oldstate)<div style="height: 0.00em;">
&#160;</div>
<br/>
</div>
</div>
<div class="section">
<h1>Detailed Description</h1> The Globus runtime includes support for portably creating threads on POSIX and Windows systems.<div style="height: 1.00em;">
&#160;</div>
It also provides a callback-driven system for applications that may use threads but don't require them. The Globus Thread API is modeled closely after the POSIX threads API.<div class="spacer">
</div>
Applications can choose whether to run as threaded or non-threaded at runtime by either setting the GLOBUS_THREAD_MODEL environment variable or calling the <b>globus_thread_set_model()</b> function prior to activating any Globus modules.<div class="spacer">
</div>
The Globus thread system provides primitives for mutual exclusion (<b>globus_mutex_t</b>, <b>globus_rmutex_t</b>, globus_rw_mutex_t), event synchronization (<b>globus_cond_t</b>), one-time execution (globus_once_t), and threading (<b>globus_thread_t</b>).<div class="spacer">
</div>
In non-threaded operation, <b>globus_cond_wait()</b> and its variants will poll the callback queue and I/O system to allow event-driven programs to run in the absence of threads. The <b>globus_thread_create()</b> function will fail in that model. Other primitive operations will return success but not provide any thread exclusion as there is only one thread.</div>
<div class="section">
<h1>Define Documentation</h1><div class="subsection">
<h2>#define <b>GLOBUS_THREAD_CANCEL_DISABLE</b>   0</h2> Disable thread cancellation value.  <b>See also:</b><div style="margin-left: 4.00ex;">
<b>globus_thread_setcancelstate()</b></div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>#define <b>GLOBUS_THREAD_CANCEL_ENABLE</b>   1</h2> Enable thread cancellation value.  <b>See also:</b><div style="margin-left: 4.00ex;">
<b>globus_thread_setcancelstate()</b></div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>#define <b>GLOBUS_THREAD_MODULE</b>   (&amp;globus_i_thread_module)</h2> Thread Module.</div>
</div>
<div class="section">
<h1>Typedef Documentation</h1><div class="subsection">
<h2>typedef void(*  <b>globus_thread_key_destructor_func_t</b>)(void *value)</h2> Thread-specific data destructor.</div>
</div>
<div class="section">
<h1>Function Documentation</h1><div class="subsection">
<h2>int <b>globus_thread_set_model</b> (const char *model)</h2> Select threading model for an application. The  <b>globus_thread_set_model()</b> function selects which runtime model the current application will use. By default, the Globus runtime uses a non-threaded model. Additional models may be available based on system support: pthread, or windows. This function must be called prior to activating any globus module, as it changes how certain functions (like <b>globus_mutex_lock()</b> and <b>globus_cond_wait()</b>) behave. This function overrides the value set by the GLOBUS_THREAD_MODEL environment variable.<div class="spacer">
</div>
The <b>globus_thread_set_model()</b> function will fail if a Globus module has been activated already.<div class="spacer">
</div>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>model</i> The name of the thread model to use. Depending on operating system capabilities, this may be 'none', 'pthread', 'windows', or some other custom thread implementation. The corresponding libtool module 'libglobus_thread_pthread.la' or 'libglobus_thread_windows.la' must be installed on the system for it to be used.</div>
<div class="spacer">
</div>
<b>Returns:</b><div style="margin-left: 4.00ex;">
On success, <b>globus_thread_set_model()</b> sets the name of the thread model to use and returns GLOBUS_SUCCESS. If an error occurs, then <b>globus_thread_set_model()</b> returns GLOBUS_FAILURE.</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int <b>globus_thread_create</b> (<b>globus_thread_t</b> *thread, <b>globus_threadattr_t</b> *attr, globus_thread_func_tfunc, void *user_arg)</h2> Create a new thread. The  <b>globus_thread_create()</b> function creates a new thread of execution in the current process to run the function pointed to by the <i>func</i> parameter passed the <i>user_arg</i> value as its only parameter. This new thread will be detached, so that storage associated with the thread will be automatically reclaimed by the operating system. A thread identifier will be copied to the value pointed by the <i>thread</i> parameter if it is non-NULL. The caller may use this thread identifier to signal or cancel this thread. The <i>attr</i> paramter is ignored by this function. If the 'none' threading model is used by an application, then this function will always fail. One alternative that will work both with and without threads is to use the functions in the <b>Globus Callback API </b>.<div class="spacer">
</div>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>thread</i> Pointer to a variable to contain the new thread's identifier.<div style="height: 0.00em;">
&#160;</div>
<i>attr</i> Ignored<div style="height: 0.00em;">
&#160;</div>
<i>func</i> Pointer to a function to start in the new thread.<div style="height: 0.00em;">
&#160;</div>
<i>user_arg</i> Argument to the new thread's function.</div>
<div class="spacer">
</div>
<b>Returns:</b><div style="margin-left: 4.00ex;">
On success, <b>globus_thread_create()</b> will start a new thread, invoking (*func)(user_arg), modify the value pointed to by the <i>thread</i> parameter to contain the new thread's identifier and return GLOBUS_SUCCESS. If an error occurs, then the value of <i>thread</i> is undefined and <b>globus_thread_create()</b> returns an implementation-specific non-zero error value.</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>void <b>globus_thread_yield</b> (void)</h2> Yield execution to another thread. The  <b>globus_thread_yield()</b> function yields execution to other threads which are ready for execution. The current thread may continue to execute if there are no other threads in the system's ready queue.</div>
<div class="subsection">
<h2>void <b>globus_thread_exit</b> (void *value)</h2> Terminate the current thread<div class="spacer">
</div>
The <b>globus_thread_exit()</b> terminates the current thread with the value passed to it. This function does not return.</div>
<div class="subsection">
<h2>int <b>globus_thread_sigmask</b> (inthow, const sigset_t *new_mask, sigset_t *old_mask)</h2> Modify the current thread's signal mask. The  <b>globus_thread_sigmask()</b> function modifies the current thread's signal mask and returns the old value of the signal mask in the value pointed to by the <i>old_mask</i> parameter. The <i>how</i> parameter can be one of SIG_BLOCK, SIG_UNBLOCK, or SIG_SETMASK to control how the signal mask is modified.<div class="spacer">
</div>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>how</i> Flag indicating how to interpret <i>new_mask</i> if it is non-NULL. If <i>how</i> is SIG_BLOCK, then all signals in <i>new_mask</i> are blocked, as well as any which were previously blocked. If <i>how</i> is SIG_UNBLOCK, then all signals in which were previously blocked in <i>new_mask</i> are unblocked. If <i>how</i> is SIG_SETMASK, then the old signal mask is replaced with the value of <i>new_mask</i>.<div style="height: 0.00em;">
&#160;</div>
<i>new_mask</i> Set of signals to block or unblock, based on the <i>how</i> parameter.<div style="height: 0.00em;">
&#160;</div>
<i>old_mask</i> A pointer to be set to the old signal mask associated with the current thread.</div>
<div class="spacer">
</div>
<b>Returns:</b><div style="margin-left: 4.00ex;">
On success, <b>globus_thread_sigmask()</b> modifies the signal mask, modifies the value pointed to by <i>old_mask</i> with the signal mask prior to this function's execution and returns GLOBUS_SUCCESS. If an error occurs, <b>globus_thread_sigmask()</b> returns an implementation-specific non-zero error value.</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int <b>globus_thread_kill</b> (<b>globus_thread_t</b>thread, intsig)</h2> Send a signal to a thread. The  <b>globus_thread_kill()</b> function sends the signal specified by the <i>sig</i> number to the thread whose ID matches the <i>thread</i> parameter. Depending on the signal mask of that thread, this may result in a signal being delivered or not, and depending on the process's signal actions, a signal handler, termination, or no operation will occur in that thread.<div class="spacer">
</div>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>thread</i> The thread identifier of the thread to signal.<div style="height: 0.00em;">
&#160;</div>
<i>sig</i> The signal to send to the thread.</div>
<div class="spacer">
</div>
<b>Returns:</b><div style="margin-left: 4.00ex;">
On success, <b>globus_thread_kill()</b> queues the signal for delivery to the specified thread and returns GLOBUS_SUCCESS. If an error occurs, <b>globus_thread_kill()</b> returns an implementation-specific non-zero error value.</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2><b>globus_thread_t</b> <b>globus_thread_self</b> (void)</h2> Determine the current thread's ID. The  <b>globus_thread_self()</b> function returns the thread identifier of the current thread. This value is unique among all threads which are running at any given time.</div>
<div class="subsection">
<h2>globus_bool_t <b>globus_thread_equal</b> (<b>globus_thread_t</b>thread1, <b>globus_thread_t</b>thread2)</h2> Check whether thread identifiers match. The  <b>globus_thread_equal()</b> function checks whether the thread identifiers passed as the <i>thread1</i> and <i>thread2</i> parameters refer to the same thread. If so, <b>globus_thread_equal()</b> returns GLOBUS_TRUE; otherwise GLOBUS_FALSE.<div class="spacer">
</div>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>thread1</i> Thread identifier to compare.<div style="height: 0.00em;">
&#160;</div>
<i>thread2</i> Thread identifier to compare.</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>globus_bool_t <b>globus_thread_preemptive_threads</b> (void)</h2> Indicate whether the active thread model supports preemption. The  <b>globus_thread_preemptive_threads()</b> function returns GLOBUS_TRUE if the current thread model supports thread preemption; othwerise it returns GLOBUS_FALSE.</div>
<div class="subsection">
<h2>globus_bool_t <b>globus_i_am_only_thread</b> (void)</h2> Determine if threads are supported. The  <b>globus_i_am_only_thread()</b> function returns GLOBUS_TRUE if the current thread model is the 'none' thread model; GLOBUS_FALSE otherwise. If running with the 'none' thread model, there will only be one Globus thread available and the <b>globus_thread_create()</b> function will always fail.</div>
<div class="subsection">
<h2>void* <b>globus_thread_cancellable_func</b> (void *(*)(void *)func, void *arg, void(*)(void *)cleanup_func, void *cleanup_arg, globus_bool_texecute_cleanup)</h2> Execute a function with thread cleanup in case of cancellation. The  <b>globus_thread_cancellable_func()</b> function provides an interface to POSIX thread cancellation points that does not rely on preprocessor macros. It is roughly equivalent to<div class="spacer">
</div>
<br/>
 pthread_cleanup_push(cleanup_func, cleanup_arg);<br/>
 (*func)(arg);<br/>
 pthread_cleanup_pop(execute_cleanup)<div class="spacer">
</div>
<br/>
<div class="spacer">
</div>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>func</i> Pointer to a function which may be cancelled.<div style="height: 0.00em;">
&#160;</div>
<i>arg</i> Parameter to the <i>func</i> function.<div style="height: 0.00em;">
&#160;</div>
<i>cleanup_func</i> Pointer to a function to execute if thread cancellation occurs during <i>func</i>.<div style="height: 0.00em;">
&#160;</div>
<i>cleanup_arg</i> Parameter to the <i>cleanup_func</i> function.<div style="height: 0.00em;">
&#160;</div>
<i>execute_cleanup</i> Flag indicating whether the function pointed to by <i>cleanup_func</i> should be executed after <i>func</i> completes even if it is not cancelled.</div>
<div class="spacer">
</div>
<b>Returns:</b><div style="margin-left: 4.00ex;">
<b>globus_thread_cancellable_func()</b> returns the value returned by <i>func</i>.</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>int <b>globus_thread_cancel</b> (<b>globus_thread_t</b>thr)</h2> Cancel a thread. The  <b>globus_thread_cancel()</b> function cancels the thread with the identifier <i>thr</i> if it is still executing. If it is running with a cancellation cleanup stack, the functions in that stack are executed. The target thread's cancel state determines when the cancellation is delivered.<div class="spacer">
</div>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>thr</i> The id of the thread to cancel</div>
<div class="spacer">
</div>
<b>Returns:</b><div style="margin-left: 4.00ex;">
On success, the <b>globus_thread_cancel()</b> function delivers the cancellation to the target thread and returns GLOBUS_SUCCESS. If an error occurs, <b>globus_thread_cancel()</b> returns an implementation-specific non-zero error value.</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>void <b>globus_thread_testcancel</b> (void)</h2> Thread cancellation point. The  <b>globus_thread_testcancel()</b> function acts as a cancellation point for the current thread. If a thread has called <b>globus_thread_cancel()</b> and cancellation is enabled, this will cause the thread to be cancelled and any functions on the thread's cleanup stack to be executed. This function will not return if the thread is cancelled.</div>
<div class="subsection">
<h2>int <b>globus_thread_setcancelstate</b> (intstate, int *oldstate)</h2> Set the thread's cancellable state. The  <b>globus_thread_setcancelstate()</b> function sets the current cancellation state to either GLOBUS_THREAD_CANCEL_DISABLE or GLOBUS_THREAD_CANCEL_ENABLE, do control whether <b>globus_thread_cancel()</b> is able to cancel this thread.<div class="spacer">
</div>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>state</i> The desired cancellation state. If the value is GLOBUS_THREAD_CANCEL_DISABLE, then cancellation will be disabled for this thread. If the value is GLOBUS_THREAD_CANCEL_ENABLE, then cancellation will be enabled for this thread.<div style="height: 0.00em;">
&#160;</div>
<i>oldstate</i> A pointer to a value which will be set to the value of the thread's cancellation state when this function call began. This may be NULL if the caller is not interested in the previous value.</div>
<div class="spacer">
</div>
<b>Returns:</b><div style="margin-left: 4.00ex;">
On success, the <b>globus_thread_setcancelstate()</b> function modifies the thread cancellation state, modifies oldstate (if non-NULL) to the value of its previous state, and returns GLOBUS_SUCCESS. If an error occurs, <b>globus_thread_setcancelstate()</b> returns an implementation-specific non-zero error value.</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
</div>
<div class="section">
<h1>Author</h1> Generated automatically by Doxygen for globus common from the source code.</div>
<table class="foot">
<tr>
<td class="foot-date">
Tue Jan 24 2012</td>
<td class="foot-os">
Version 14.5</td>
</tr>
</table>
</div>
</body>
</html>

