<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Dpkg::Control::Fields(3)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Dpkg::Control::Fields(3)</td>
<td class="head-vol">
libdpkg-perl</td>
<td class="head-rtitle">
Dpkg::Control::Fields(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Dpkg::Control::Fields - manage (list of official) control fields</div>
<div class="section">
<h1>DESCRIPTION</h1> The modules contains a list of fieldnames with associated meta-data explaining in which type of control information they are allowed. The types are the CTRL_* constants exported by Dpkg::Control.</div>
<div class="section">
<h1>FUNCTIONS</h1><dl>
<dt>
my $f = field_capitalize($field_name)</dt>
<dd>
Returns the field name properly capitalized. All characters are lowercase, except the first of each word (words are separated by a dash in field names).</dd>
</dl>
<dl>
<dt>
field_is_official($fname)</dt>
<dd>
Returns true if the field is official and known.</dd>
</dl>
<dl>
<dt>
field_is_allowed_in($fname, @types)</dt>
<dd>
Returns true (1) if the field $fname is allowed in all the types listed in the list. Note that you can use type sets instead of individual types (ex: CTRL_FILE_CHANGES | CTRL_CHANGELOG).<div style="height: 1.00em;">
&#160;</div>
field_allowed_in(A|B, C) returns true only if the field is allowed in C and either A or B.<div style="height: 1.00em;">
&#160;</div>
Undef is returned for non-official fields.</dd>
</dl>
<dl>
<dt>
field_transfer_single($from, $to, $field)</dt>
<dd>
If appropriate, copy the value of the field named $field taken from the $from Dpkg::Control object to the $to Dpkg::Control object.<div style="height: 1.00em;">
&#160;</div>
Official fields are copied only if the field is allowed in both types of objects. Custom fields are treated in a specific manner. When the target is not among CTRL_PKG_SRC, CTRL_PKG_DEB or CTRL_FILE_CHANGES, then they are alway copied as is (the X- prefix is kept). Otherwise they are not copied except if the target object matches the target destination encoded in the field name. The initial X denoting custom fields can be followed by one or more letters among &quot;S&quot; (Source: corresponds to CTRL_PKG_SRC), &quot;B&quot; (Binary: corresponds to CTRL_PKG_DEB) or &quot;C&quot; (Changes: corresponds to CTRL_FILE_CHANGES).<div style="height: 1.00em;">
&#160;</div>
Returns undef if nothing has been copied or the name of the new field added to $to otherwise.</dd>
</dl>
<dl>
<dt>
field_transfer_all($from, $to)</dt>
<dd>
Transfer all appropriate fields from $from to $to. Calls  <i>field_transfer_single()</i> on all fields available in $from.<div style="height: 1.00em;">
&#160;</div>
Returns the list of fields that have been added to $to.</dd>
</dl>
<dl>
<dt>
field_ordered_list($type)</dt>
<dd>
Returns an ordered list of fields for a given type of control information. This list can be used to output the fields in a predictable order. The list might be empty for types where the order does not matter much.</dd>
</dl>
<dl>
<dt>
<i>field_list_src_dep()</i></dt>
<dd>
List of fields that contains dependencies-like information in a source Debian package.</dd>
</dl>
<dl>
<dt>
<i>field_list_pkg_dep()</i></dt>
<dd>
List of fields that contains dependencies-like information in a binary Debian package. The fields that express real dependencies are sorted from the stronger to the weaker.</dd>
</dl>
<dl>
<dt>
field_get_dep_type($field)</dt>
<dd>
Return the type of the dependency expressed by the given field. Can either be &quot;normal&quot; for a real dependency field (Pre-Depends, Depends, ...) or &quot;union&quot; for other relation fields sharing the same syntax (Conflicts, Breaks, ...). Returns undef for fields which are not dependencies.</dd>
</dl>
<dl>
<dt>
field_register($field, $allowed_types, %opts)</dt>
<dd>
Register a new field as being allowed in control information of specified types. %opts is optional</dd>
</dl>
<dl>
<dt>
field_insert_after($type, $ref, @fields)</dt>
<dd>
Place field after another one ($ref) in output of control information of type $type.</dd>
</dl>
<dl>
<dt>
field_insert_before($type, $ref, @fields)</dt>
<dd>
Place field before another one ($ref) in output of control information of type $type.</dd>
</dl>
</div>
<div class="section">
<h1>AUTHOR</h1> Rapha&#235;l Hertzog &lt;hertzog@debian.org&gt;.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-06-17</td>
<td class="foot-os">
1.16.1.2</td>
</tr>
</table>
</div>
</body>
</html>

