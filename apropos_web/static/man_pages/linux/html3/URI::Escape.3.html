<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
URI::Escape(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
URI::Escape(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
URI::Escape(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> URI::Escape - Percent-encode and percent-decode unsafe characters</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
 use URI::Escape;<br/>
 $safe = uri_escape(&quot;10% is enough\n&quot;);<br/>
 $verysafe = uri_escape(&quot;foo&quot;, &quot;\0-\377&quot;);<br/>
 $str  = uri_unescape($safe);<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> This module provides functions to percent-encode and percent-decode URI strings as defined by RFC 3986. Percent-encoding URI's is informally called &quot;URI escaping&quot;. This is the terminology used by this module, which predates the formalization of the terms by the RFC by several years.<div class="spacer">
</div>
A URI consists of a restricted set of characters.  The restricted set of characters consists of digits, letters, and a few graphic symbols chosen from those common to most of the character encodings and input facilities available to Internet users.  They are made up of the &quot;unreserved&quot; and &quot;reserved&quot; character sets as defined in RFC 3986.<div class="spacer">
</div>
<br/>
   unreserved    = ALPHA / DIGIT / &quot;-&quot; / &quot;.&quot; / &quot;_&quot; / &quot;~&quot;<br/>
   reserved      = &quot;:&quot; / &quot;/&quot; / &quot;?&quot; / &quot;#&quot; / &quot;[&quot; / &quot;]&quot; / &quot;@&quot;<br/>
                   &quot;!&quot; / &quot;$&quot; / &quot;&amp;&quot; / &quot;'&quot; / &quot;(&quot; / &quot;)&quot;<br/>
                 / &quot;*&quot; / &quot;+&quot; / &quot;,&quot; / &quot;;&quot; / &quot;=&quot;<br/>
<div class="spacer">
</div>
In addition, any byte (octet) can be represented in a URI by an escape sequence: a triplet consisting of the character &quot;%&quot; followed by two hexadecimal digits.  A byte can also be represented directly by a character, using the US-ASCII character for that octet.<div class="spacer">
</div>
Some of the characters are <i>reserved</i> for use as delimiters or as part of certain URI components.  These must be escaped if they are to be treated as ordinary data.  Read RFC 3986 for further details.<div class="spacer">
</div>
The functions provided (and exported by default) from this module are:<dl>
<dt>
uri_escape( $string )</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
uri_escape( $string, $unsafe )</dt>
<dd>
Replaces each unsafe character in the $string with the corresponding escape sequence and returns the result.  The $string argument should be a string of bytes.  The  <i>uri_escape()</i> function will croak if given a characters with code above 255.  Use  <i>uri_escape_utf8()</i> if you know you have such chars or/and want chars in the 128 .. 255 range treated as UTF-8.<div style="height: 1.00em;">
&#160;</div>
The <i>uri_escape()</i> function takes an optional second argument that overrides the set of characters that are to be escaped.  The set is specified as a string that can be used in a regular expression character class (between [ ]).  E.g.:<div style="height: 1.00em;">
&#160;</div>
<br/>
  &quot;\x00-\x1f\x7f-\xff&quot;          # all control and hi-bit characters<br/>
  &quot;a-z&quot;                         # all lower case characters<br/>
  &quot;^A-Za-z&quot;                     # everything not a letter<br/>
<div style="height: 1.00em;">
&#160;</div>
The default set of characters to be escaped is all those which are  <i>not</i> part of the &quot;unreserved&quot; character class shown above as well as the reserved characters.  I.e. the default is:<div style="height: 1.00em;">
&#160;</div>
<br/>
    &quot;^A-Za-z0-9\-\._~&quot;<br/>
</dd>
</dl>
<dl>
<dt>
uri_escape_utf8( $string )</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
uri_escape_utf8( $string, $unsafe )</dt>
<dd>
Works like <i>uri_escape()</i>, but will encode chars as UTF-8 before escaping them.  This makes this function able to deal with characters with code above 255 in $string.  Note that chars in the 128 .. 255 range will be escaped differently by this function compared to what  <i>uri_escape()</i> would.  For chars in the 0 .. 127 range there is no difference.<div style="height: 1.00em;">
&#160;</div>
Equivalent to:<div style="height: 1.00em;">
&#160;</div>
<br/>
    utf8::encode($string);<br/>
    my $uri = uri_escape($string);<br/>
<div style="height: 1.00em;">
&#160;</div>
Note: JavaScript has a function called <i>escape()</i> that produces the sequence &quot;%uXXXX&quot; for chars in the 256 .. 65535 range.  This function has really nothing to do with URI escaping but some folks got confused since it &quot;does the right thing&quot; in the 0 .. 255 range.  Because of this you sometimes see &quot;URIs&quot; with these kind of escapes.  The JavaScript  <i>encodeURIComponent()</i> function is similar to <i>uri_escape_utf8()</i>.</dd>
</dl>
<dl>
<dt>
uri_unescape($string,...)</dt>
<dd>
Returns a string with each %XX sequence replaced with the actual byte (octet).<div style="height: 1.00em;">
&#160;</div>
This does the same as:<div style="height: 1.00em;">
&#160;</div>
<br/>
   $string =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;<br/>
<div style="height: 1.00em;">
&#160;</div>
but does not modify the string in-place as this RE would.  Using the  <i>uri_unescape()</i> function instead of the RE might make the code look cleaner and is a few characters less to type.<div style="height: 1.00em;">
&#160;</div>
In a simple benchmark test I did, calling the function (instead of the inline RE above) if a few chars were unescaped was something like 40% slower, and something like 700% slower if none were.  If you are going to unescape a lot of times it might be a good idea to inline the RE.<div style="height: 1.00em;">
&#160;</div>
If the <i>uri_unescape()</i> function is passed multiple strings, then each one is returned unescaped.</dd>
</dl>
<div class="spacer">
</div>
The module can also export the %escapes hash, which contains the mapping from all 256 bytes to the corresponding escape codes.  Lookup in this hash is faster than evaluating &quot;sprintf(&quot;%%%02X&quot;, ord($byte))&quot; each time.</div>
<div class="section">
<h1>SEE ALSO</h1> URI</div>
<div class="section">
<h1>COPYRIGHT</h1> Copyright 1995-2004 Gisle Aas.<div class="spacer">
</div>
This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-08-14</td>
<td class="foot-os">
perl v5.12.4</td>
</tr>
</table>
</div>
</body>
</html>

