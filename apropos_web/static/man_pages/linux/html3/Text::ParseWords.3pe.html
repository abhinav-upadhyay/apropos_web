<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Text::ParseWords(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Text::ParseWords(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
Text::ParseWords(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Text::ParseWords - parse text into an array of tokens or array of arrays</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
  use Text::ParseWords;<br/>
  @lists = nested_quotewords($delim, $keep, @lines);<br/>
  @words = quotewords($delim, $keep, @lines);<br/>
  @words = shellwords(@lines);<br/>
  @words = parse_line($delim, $keep, $line);<br/>
  @words = old_shellwords(@lines); # DEPRECATED!<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> The &amp; <i>nested_quotewords()</i> and &amp;<i>quotewords()</i> functions accept a delimiter (which can be a regular expression) and a list of lines and then breaks those lines up into a list of words ignoring delimiters that appear inside quotes.  &amp; <i>quotewords()</i> returns all of the tokens in a single long list, while &amp; <i>nested_quotewords()</i> returns a list of token lists corresponding to the elements of @lines. &amp; <i>parse_line()</i> does tokenizing on a single string.  The &amp;*<i>quotewords()</i> functions simply call &amp; <i>parse_line()</i>, so if you're only splitting one line you can call &amp; <i>parse_line()</i> directly and save a function call.<div class="spacer">
</div>
The $keep argument is a boolean flag.  If true, then the tokens are split on the specified delimiter, but all other characters (quotes, backslashes, etc.) are kept in the tokens.  If $keep is false then the &amp;* <i>quotewords()</i> functions remove all quotes and backslashes that are not themselves backslash-escaped or inside of single quotes (i.e., &amp; <i>quotewords()</i> tries to interpret these characters just like the Bourne shell).  NB: these semantics are significantly different from the original version of this module shipped with Perl 5.000 through 5.004. As an additional feature, $keep may be the keyword &quot;delimiters&quot; which causes the functions to preserve the delimiters in each string as tokens in the token lists, in addition to preserving quote and backslash characters.<div class="spacer">
</div>
&amp;<i>shellwords()</i> is written as a special case of &amp;<i>quotewords()</i>, and it does token parsing with whitespace as a delimiter-- similar to most Unix shells.</div>
<div class="section">
<h1>EXAMPLES</h1> The sample program:<div class="spacer">
</div>
<br/>
  use Text::ParseWords;<br/>
  @words = quotewords('\s+', 0, q{this   is &quot;a test&quot; of\ quotewords \&quot;for you});<br/>
  $i = 0;<br/>
  foreach (@words) {<br/>
      print &quot;$i: &lt;$_&gt;\n&quot;;<br/>
      $i++;<br/>
  }<br/>
<div class="spacer">
</div>
produces:<div class="spacer">
</div>
<br/>
  0: &lt;this&gt;<br/>
  1: &lt;is&gt;<br/>
  2: &lt;a test&gt;<br/>
  3: &lt;of quotewords&gt;<br/>
  4: &lt;&quot;for&gt;<br/>
  5: &lt;you&gt;<br/>
<div class="spacer">
</div>
demonstrating:<dl>
<dt>
0</dt>
<dd>
a simple word</dd>
</dl>
<dl>
<dt>
1</dt>
<dd>
multiple spaces are skipped because of our $delim</dd>
</dl>
<dl>
<dt>
2</dt>
<dd>
use of quotes to include a space in a word</dd>
</dl>
<dl>
<dt>
3</dt>
<dd>
use of a backslash to include a space in a word</dd>
</dl>
<dl>
<dt>
4</dt>
<dd>
use of a backslash to remove the special meaning of a double-quote</dd>
</dl>
<dl>
<dt>
5</dt>
<dd>
another simple word (note the lack of effect of the backslashed double-quote)</dd>
</dl>
<div class="spacer">
</div>
Replacing &quot;quotewords('\s+', 0, q{this   is...})&quot; with &quot;shellwords(q{this   is...})&quot; is a simpler way to accomplish the same thing.</div>
<div class="section">
<h1>AUTHORS</h1> Maintainer: Alexandr Ciornii &lt;alexchornyATgmail.com&gt;.<div class="spacer">
</div>
Previous maintainer: Hal Pomeranz &lt;pomeranz@netcom.com&gt;, 1994-1997 (Original author unknown).  Much of the code for &amp; <i>parse_line()</i> (including the primary regexp) from Joerk Behrends &lt;jbehrends@multimediaproduzenten.de&gt;.<div class="spacer">
</div>
Examples section another documentation provided by John Heidemann &lt;johnh@ISI.EDU&gt;<div class="spacer">
</div>
Bug reports, patches, and nagging provided by lots of folks-- thanks everybody!  Special thanks to Michael Schwern &lt;schwern@envirolink.org&gt; for assuring me that a &amp; <i>nested_quotewords()</i> would be useful, and to Jeff Friedl &lt;jfriedl@yahoo-inc.com&gt; for telling me not to worry about error-checking (sort of-- you had to be there).</div>
<table class="foot">
<tr>
<td class="foot-date">
2010-12-30</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

