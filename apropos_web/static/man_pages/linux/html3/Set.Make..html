<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Set.Make(3)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Set.Make(3)</td>
<td class="head-vol">
OCaml library</td>
<td class="head-rtitle">
Set.Make(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Set.Make - Functor building an implementation of the set structure given a totally ordered type.</div>
<div class="section">
<h1>Module</h1> Module   Set.Make</div>
<div class="section">
<h1>Documentation</h1> Module <b>Make</b><br/>
 : <b>functor (Ord : OrderedType) -&gt; sig end</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
Functor building an implementation of the set structure given a totally ordered type.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>Parameters:</b><div style="height: 1.00em;">
&#160;</div>
&quot;Ord&quot;<div style="height: 1.00em;">
&#160;</div>
<b>Set.OrderedType</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>type elt</i><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
The type of the set elements.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>type t</i><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
The type of sets.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val empty</i> : <b>t</b><div style="height: 1.00em;">
&#160;</div>
The empty set.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val is_empty</i> : <b>t -&gt; bool</b><div style="height: 1.00em;">
&#160;</div>
Test whether a set is empty or not.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val mem</i> : <b>elt -&gt; t -&gt; bool</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>mem x s</b> tests whether <b>x</b> belongs to the set <b>s</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val add</i> : <b>elt -&gt; t -&gt; t</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>add x s</b> returns a set containing all elements of <b>s</b> , plus <b>x</b> . If <b>x</b> was already in <b>s</b> , <b>s</b> is returned unchanged.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val singleton</i> : <b>elt -&gt; t</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>singleton x</b> returns the one-element set containing only <b>x</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val remove</i> : <b>elt -&gt; t -&gt; t</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>remove x s</b> returns a set containing all elements of <b>s</b> , except <b>x</b> . If <b>x</b> was not in <b>s</b> , <b>s</b> is returned unchanged.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val union</i> : <b>t -&gt; t -&gt; t</b><div style="height: 1.00em;">
&#160;</div>
Set union.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val inter</i> : <b>t -&gt; t -&gt; t</b><div style="height: 1.00em;">
&#160;</div>
Set intersection.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val diff</i> : <b>t -&gt; t -&gt; t</b><div style="height: 1.00em;">
&#160;</div>
Set difference.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val compare</i> : <b>t -&gt; t -&gt; int</b><div style="height: 1.00em;">
&#160;</div>
Total ordering between sets. Can be used as the ordering function for doing sets of sets.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val equal</i> : <b>t -&gt; t -&gt; bool</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>equal s1 s2</b> tests whether the sets <b>s1</b> and <b>s2</b> are equal, that is, contain equal elements.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val subset</i> : <b>t -&gt; t -&gt; bool</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>subset s1 s2</b> tests whether the set <b>s1</b> is a subset of the set <b>s2</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val iter</i> : <b>(elt -&gt; unit) -&gt; t -&gt; unit</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>iter f s</b> applies <b>f</b> in turn to all elements of <b>s</b> . The elements of <b>s</b> are presented to <b>f</b> in increasing order with respect to the ordering over the type of the elements.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val fold</i> : <b>(elt -&gt; 'a -&gt; 'a) -&gt; t -&gt; 'a -&gt; 'a</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>fold f s a</b> computes <b>(f xN ... (f x2 (f x1 a))...)</b> , where <b>x1 ... xN</b> are the elements of <b>s</b> , in increasing order.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val for_all</i> : <b>(elt -&gt; bool) -&gt; t -&gt; bool</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>for_all p s</b> checks if all elements of the set satisfy the predicate <b>p</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val exists</i> : <b>(elt -&gt; bool) -&gt; t -&gt; bool</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>exists p s</b> checks if at least one element of the set satisfies the predicate <b>p</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val filter</i> : <b>(elt -&gt; bool) -&gt; t -&gt; t</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>filter p s</b> returns the set of all elements in <b>s</b> that satisfy predicate <b>p</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val partition</i> : <b>(elt -&gt; bool) -&gt; t -&gt; t * t</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>partition p s</b> returns a pair of sets <b>(s1, s2)</b> , where <b>s1</b> is the set of all the elements of <b>s</b> that satisfy the predicate <b>p</b> , and <b>s2</b> is the set of all the elements of <b>s</b> that do not satisfy <b>p</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val cardinal</i> : <b>t -&gt; int</b><div style="height: 1.00em;">
&#160;</div>
Return the number of elements of a set.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val elements</i> : <b>t -&gt; elt list</b><div style="height: 1.00em;">
&#160;</div>
Return the list of all elements of the given set. The returned list is sorted in increasing order with respect to the ordering <b>Ord.compare</b> , where <b>Ord</b> is the argument given to <b>Set.Make</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val min_elt</i> : <b>t -&gt; elt</b><div style="height: 1.00em;">
&#160;</div>
Return the smallest element of the given set (with respect to the <b>Ord.compare</b> ordering), or raise <b>Not_found</b> if the set is empty.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val max_elt</i> : <b>t -&gt; elt</b><div style="height: 1.00em;">
&#160;</div>
Same as <b>Set.S.min_elt</b> , but returns the largest element of the given set.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val choose</i> : <b>t -&gt; elt</b><div style="height: 1.00em;">
&#160;</div>
Return one element of the given set, or raise <b>Not_found</b> if the set is empty. Which element is chosen is unspecified, but equal elements will be chosen for equal sets.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val split</i> : <b>elt -&gt; t -&gt; t * bool * t</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>split x s</b> returns a triple <b>(l, present, r)</b> , where <b>l</b> is the set of elements of <b>s</b> that are strictly less than <b>x</b> ; <b>r</b> is the set of elements of <b>s</b> that are strictly greater than <b>x</b> ; <b>present</b> is <b>false</b> if <b>s</b> contains no element equal to <b>x</b> , or <b>true</b> if <b>s</b> contains an element equal to <b>x</b> .<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val find</i> : <b>elt -&gt; t -&gt; elt</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>find x s</b> returns the element of <b>s</b> equal to <b>x</b> (according to <b>Ord.compare</b> ), or raise <b>Not_found</b> if no such element exists.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>Since</b> 4.01.0<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<i>val of_list</i> : <b>elt list -&gt; t</b><div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>of_list l</b> creates a set from a list of elements. This is usually more efficient than folding <b>add</b> over the list, except perhaps for lists with many duplicated elements.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>Since</b> 4.02.0<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<table class="foot">
<tr>
<td class="foot-date">
2015-08-12</td>
<td class="foot-os">
OCamldoc</td>
</tr>
</table>
</div>
</body>
</html>

