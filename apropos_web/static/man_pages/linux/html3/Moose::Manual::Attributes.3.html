<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Moose::Manual::Attributes(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Moose::Manual::Attributes(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
Moose::Manual::Attributes(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Moose::Manual::Attributes - Object attributes with Moose</div>
<div class="section">
<h1>VERSION</h1> version 2.0401</div>
<div class="section">
<h1>INTRODUCTION</h1> Moose attributes have many properties, and attributes are probably the single most powerful and flexible part of Moose. You can create a powerful class simply by declaring attributes. In fact, it's possible to have classes that consist solely of attribute declarations.<div class="spacer">
</div>
An attribute is a property that every member of a class has. For example, we might say that &quot;every &quot;Person&quot; object has a first name and last name&quot;. Attributes can be optional, so that we can say &quot;some &quot;Person&quot; objects have a social security number (and some don't)&quot;.<div class="spacer">
</div>
At its simplest, an attribute can be thought of as a named value (as in a hash) that can be read and set. However, attributes can also have defaults, type constraints, delegation and much more.<div class="spacer">
</div>
In other languages, attributes are also referred to as slots or properties.</div>
<div class="section">
<h1>ATTRIBUTE OPTIONS</h1> Use the &quot;has&quot; function to declare an attribute:<div class="spacer">
</div>
<br/>
  package Person;<br/>
<br/>
  use Moose;<br/>
<br/>
  has 'first_name' =&gt; ( is =&gt; 'rw' );<br/>
<div class="spacer">
</div>
This says that all &quot;Person&quot; objects have an optional read-write &quot;first_name&quot; attribute.<div class="subsection">
<h2>Read-write vs. read-only</h2> The options passed to &quot;has&quot; define the properties of the attribute. There are many options, but in the simplest form you just need to set &quot;is&quot;, which can be either &quot;ro&quot; (read-only) or &quot;rw&quot; (read-write). When an attribute is &quot;rw&quot;, you can change it by passing a value to its accessor. When an attribute is &quot;ro&quot;, you may only read the current value of the attribute.<div class="spacer">
</div>
In fact, you could even omit &quot;is&quot;, but that gives you an attribute that has no accessor. This can be useful with other attribute options, such as &quot;handles&quot;. However, if your attribute generates  <i>no</i> accessors, Moose will issue a warning, because that usually means the programmer forgot to say the attribute is read-only or read-write. If you really mean to have no accessors, you can silence this warning by setting &quot;is&quot; to &quot;bare&quot;.</div>
<div class="subsection">
<h2>Accessor methods</h2> Each attribute has one or more accessor methods. An accessor lets you read and write the value of that attribute for an object.<div class="spacer">
</div>
By default, the accessor method has the same name as the attribute. If you declared your attribute as &quot;ro&quot; then your accessor will be read-only. If you declared it read-write, you get a read-write accessor. Simple.<div class="spacer">
</div>
Given our &quot;Person&quot; example above, we now have a single &quot;first_name&quot; accessor that can read or write a &quot;Person&quot; object's &quot;first_name&quot; attribute's value.<div class="spacer">
</div>
If you want, you can also explicitly specify the method names to be used for reading and writing an attribute's value. This is particularly handy when you'd like an attribute to be publicly readable, but only privately settable. For example:<div class="spacer">
</div>
<br/>
  has 'weight' =&gt; (<br/>
      is     =&gt; 'ro',<br/>
      writer =&gt; '_set_weight',<br/>
  );<br/>
<div class="spacer">
</div>
This might be useful if weight is calculated based on other methods. For example, every time the &quot;eat&quot; method is called, we might adjust weight. This lets us hide the implementation details of weight changes, but still provide the weight value to users of the class.<div class="spacer">
</div>
Some people might prefer to have distinct methods for reading and writing. In  <i>Perl Best Practices</i>, Damian Conway recommends that reader methods start with &quot;get_&quot; and writer methods start with &quot;set_&quot;.<div class="spacer">
</div>
We can do exactly that by providing names for both the &quot;reader&quot; and &quot;writer&quot; methods:<div class="spacer">
</div>
<br/>
  has 'weight' =&gt; (<br/>
      is     =&gt; 'rw',<br/>
      reader =&gt; 'get_weight',<br/>
      writer =&gt; 'set_weight',<br/>
  );<br/>
<div class="spacer">
</div>
If you're thinking that doing this over and over would be insanely tedious, you're right! Fortunately, Moose provides a powerful extension system that lets you override the default naming conventions. See Moose::Manual::MooseX for more details.</div>
<div class="subsection">
<h2>Predicate and clearer methods</h2> Moose allows you to explicitly distinguish between a false or undefined attribute value and an attribute which has not been set. If you want to access this information, you must define clearer and predicate methods for an attribute.<div class="spacer">
</div>
A predicate method tells you whether or not a given attribute is currently set. Note that an attribute can be explicitly set to &quot;undef&quot; or some other false value, but the predicate will return true.<div class="spacer">
</div>
The clearer method unsets the attribute. This is <i>not</i> the same as setting the value to &quot;undef&quot;, but you can only distinguish between them if you define a predicate method!<div class="spacer">
</div>
Here's some code to illustrate the relationship between an accessor, predicate, and clearer method.<div class="spacer">
</div>
<br/>
  package Person;<br/>
<br/>
  use Moose;<br/>
<br/>
  has 'ssn' =&gt; (<br/>
      is        =&gt; 'rw',<br/>
      clearer   =&gt; 'clear_ssn',<br/>
      predicate =&gt; 'has_ssn',<br/>
  );<br/>
<br/>
  ...<br/>
<br/>
  my $person = Person-&gt;new();<br/>
  $person-&gt;has_ssn; # false<br/>
<br/>
  $person-&gt;ssn(undef);<br/>
  $person-&gt;ssn; # returns undef<br/>
  $person-&gt;has_ssn; # true<br/>
<br/>
  $person-&gt;clear_ssn;<br/>
  $person-&gt;ssn; # returns undef<br/>
  $person-&gt;has_ssn; # false<br/>
<br/>
  $person-&gt;ssn('123-45-6789');<br/>
  $person-&gt;ssn; # returns '123-45-6789'<br/>
  $person-&gt;has_ssn; # true<br/>
<br/>
  my $person2 = Person-&gt;new( ssn =&gt; '111-22-3333');<br/>
  $person2-&gt;has_ssn; # true<br/>
<div class="spacer">
</div>
By default, Moose does not make a predicate or clearer for you. You must explicitly provide names for them, and then Moose will create the methods for you.</div>
<div class="subsection">
<h2>Required or not?</h2> By default, all attributes are optional, and do not need to be provided at object construction time. If you want to make an attribute required, simply set the &quot;required&quot; option to true:<div class="spacer">
</div>
<br/>
  has 'name' =&gt; (<br/>
      is       =&gt; 'ro',<br/>
      required =&gt; 1,<br/>
  );<br/>
<div class="spacer">
</div>
There are a couple caveats worth mentioning in regards to what &quot;required&quot; actually means.<div class="spacer">
</div>
Basically, all it says is that this attribute (&quot;name&quot;) must be provided to the constructor, or be lazy with either a default or a builder. It does not say anything about its value, so it could be &quot;undef&quot;.<div class="spacer">
</div>
If you define a clearer method on a required attribute, the clearer  <i>will</i> work, so even a required attribute can be unset after object construction.<div class="spacer">
</div>
This means that if you do make an attribute required, providing a clearer doesn't make much sense. In some cases, it might be handy to have a  <i>private</i> &quot;clearer&quot; and &quot;predicate&quot; for a required attribute.</div>
<div class="subsection">
<h2>Default and builder methods</h2> Attributes can have default values, and Moose provides two ways to specify that default.<div class="spacer">
</div>
In the simplest form, you simply provide a non-reference scalar value for the &quot;default&quot; option:<div class="spacer">
</div>
<br/>
  has 'size' =&gt; (<br/>
      is        =&gt; 'ro',<br/>
      default   =&gt; 'medium',<br/>
      predicate =&gt; 'has_size',<br/>
  );<br/>
<div class="spacer">
</div>
If the size attribute is not provided to the constructor, then it ends up being set to &quot;medium&quot;:<div class="spacer">
</div>
<br/>
  my $person = Person-&gt;new();<br/>
  $person-&gt;size; # medium<br/>
  $person-&gt;has_size; # true<br/>
<div class="spacer">
</div>
You can also provide a subroutine reference for &quot;default&quot;. This reference will be called as a method on the object.<div class="spacer">
</div>
<br/>
  has 'size' =&gt; (<br/>
      is =&gt; 'ro',<br/>
      default =&gt;<br/>
          sub { ( 'small', 'medium', 'large' )[ int( rand 3 ) ] },<br/>
      predicate =&gt; 'has_size',<br/>
  );<br/>
<div class="spacer">
</div>
This is a trivial example, but it illustrates the point that the subroutine will be called for every new object created.<div class="spacer">
</div>
When you provide a &quot;default&quot; subroutine reference, it is called as a method on the object, with no additional parameters:<div class="spacer">
</div>
<br/>
  has 'size' =&gt; (<br/>
      is      =&gt; 'ro',<br/>
      default =&gt; sub {<br/>
          my $self = shift;<br/>
<br/>
          return $self-&gt;height &gt; 200 ? 'large' : 'average';<br/>
      },<br/>
  );<br/>
<div class="spacer">
</div>
When the &quot;default&quot; is called during object construction, it may be called before other attributes have been set. If your default is dependent on other parts of the object's state, you can make the attribute &quot;lazy&quot;. Laziness is covered in the next section.<div class="spacer">
</div>
If you want to use a reference of any sort as the default value, you must return it from a subroutine.<div class="spacer">
</div>
<br/>
  has 'mapping' =&gt; (<br/>
      is      =&gt; 'ro',<br/>
      default =&gt; sub { {} },<br/>
  );<br/>
<div class="spacer">
</div>
This is necessary because otherwise Perl would instantiate the reference exactly once, and it would be shared by all objects:<div class="spacer">
</div>
<br/>
  has 'mapping' =&gt; (<br/>
      is      =&gt; 'ro',<br/>
      default =&gt; {}, # wrong!<br/>
  );<br/>
<div class="spacer">
</div>
Moose will throw an error if you pass a bare non-subroutine reference as the default.<div class="spacer">
</div>
If Moose allowed this then the default mapping attribute could easily end up shared across many objects. Instead, wrap it in a subroutine reference as we saw above.<div class="spacer">
</div>
This is a bit awkward, but it's just the way Perl works.<div class="spacer">
</div>
As an alternative to using a subroutine reference, you can supply a &quot;builder&quot; method for your attribute:<div class="spacer">
</div>
<br/>
  has 'size' =&gt; (<br/>
      is        =&gt; 'ro',<br/>
      builder   =&gt; '_build_size',<br/>
      predicate =&gt; 'has_size',<br/>
  );<br/>
<br/>
  sub _build_size {<br/>
      return ( 'small', 'medium', 'large' )[ int( rand 3 ) ];<br/>
  }<br/>
<div class="spacer">
</div>
This has several advantages. First, it moves a chunk of code to its own named method, which improves readability and code organization. Second, because this is a  <i>named</i> method, it can be subclassed or provided by a role.<div class="spacer">
</div>
We strongly recommend that you use a &quot;builder&quot; instead of a &quot;default&quot; for anything beyond the most trivial default.<div class="spacer">
</div>
A &quot;builder&quot;, just like a &quot;default&quot;, is called as a method on the object with no additional parameters.<div class="spacer">
</div>
<i>Builders allow subclassing</i><div class="spacer">
</div>
Because the &quot;builder&quot; is called <i>by name</i>, it goes through Perl's method resolution. This means that builder methods are both inheritable and overridable.<div class="spacer">
</div>
If we subclass our &quot;Person&quot; class, we can override &quot;_build_size&quot;:<div class="spacer">
</div>
<br/>
  package Lilliputian;<br/>
<br/>
  use Moose;<br/>
  extends 'Person';<br/>
<br/>
  sub _build_size { return 'small' }<br/>
<div class="spacer">
</div>
<i>Builders work well with roles</i><div class="spacer">
</div>
Because builders are called by name, they work well with roles. For example, a role could provide an attribute but require that the consuming class provide the &quot;builder&quot;:<div class="spacer">
</div>
<br/>
  package HasSize;<br/>
  use Moose::Role;<br/>
<br/>
  requires '_build_size';<br/>
<br/>
  has 'size' =&gt; (<br/>
      is      =&gt; 'ro',<br/>
      lazy    =&gt; 1,<br/>
      builder =&gt; '_build_size',<br/>
  );<br/>
<br/>
  package Lilliputian;<br/>
  use Moose;<br/>
<br/>
  with 'HasSize';<br/>
<br/>
  sub _build_size { return 'small' }<br/>
<div class="spacer">
</div>
Roles are covered in Moose::Manual::Roles.</div>
<div class="subsection">
<h2>Laziness</h2> Moose lets you defer attribute population by making an attribute &quot;lazy&quot;:<div class="spacer">
</div>
<br/>
  has 'size' =&gt; (<br/>
      is      =&gt; 'ro',<br/>
      lazy    =&gt; 1,<br/>
      builder =&gt; '_build_size',<br/>
  );<br/>
<div class="spacer">
</div>
When &quot;lazy&quot; is true, the default is not generated until the reader method is called, rather than at object construction time. There are several reasons you might choose to do this.<div class="spacer">
</div>
First, if the default value for this attribute depends on some other attributes, then the attribute  <i>must</i> be &quot;lazy&quot;. During object construction, defaults are not generated in a predictable order, so you cannot count on some other attribute being populated when generating a default.<div class="spacer">
</div>
Second, there's often no reason to calculate a default before it's needed. Making an attribute &quot;lazy&quot; lets you defer the cost until the attribute is needed. If the attribute is  <i>never</i> needed, you save some CPU time.<div class="spacer">
</div>
We recommend that you make any attribute with a builder or non-trivial default &quot;lazy&quot; as a matter of course.</div>
<div class="subsection">
<h2>Constructor parameters (&quot;init_arg&quot;)</h2> By default, each attribute can be passed by name to the class's constructor. On occasion, you may want to use a different name for the constructor parameter. You may also want to make an attribute unsettable via the constructor.<div class="spacer">
</div>
You can do either of these things with the &quot;init_arg&quot; option:<div class="spacer">
</div>
<br/>
  has 'bigness' =&gt; (<br/>
      is       =&gt; 'ro',<br/>
      init_arg =&gt; 'size',<br/>
  );<br/>
<div class="spacer">
</div>
Now we have an attribute named &quot;bigness&quot;, but we pass &quot;size&quot; to the constructor.<div class="spacer">
</div>
Even more useful is the ability to disable setting an attribute via the constructor. This is particularly handy for private attributes:<div class="spacer">
</div>
<br/>
  has '_genetic_code' =&gt; (<br/>
      is       =&gt; 'ro',<br/>
      lazy     =&gt; 1,<br/>
      builder  =&gt; '_build_genetic_code',<br/>
      init_arg =&gt; undef,<br/>
  );<br/>
<div class="spacer">
</div>
By setting the &quot;init_arg&quot; to &quot;undef&quot;, we make it impossible to set this attribute when creating a new object.</div>
<div class="subsection">
<h2>Weak references</h2> Moose has built-in support for weak references. If you set the &quot;weak_ref&quot; option to a true value, then it will call &quot;Scalar::Util::weaken&quot; whenever the attribute is set:<div class="spacer">
</div>
<br/>
  has 'parent' =&gt; (<br/>
      is       =&gt; 'rw',<br/>
      weak_ref =&gt; 1,<br/>
  );<br/>
<br/>
  $node-&gt;parent($parent_node);<br/>
<div class="spacer">
</div>
This is very useful when you're building objects that may contain circular references.<div class="spacer">
</div>
When the object in a weak references goes out of scope, the attribute's value will become &quot;undef&quot; &quot;behind the scenes&quot;. This is done by the Perl interpreter directly, so Moose does not see this change. This means that triggers don't fire, coercions aren't applied, etc.<div class="spacer">
</div>
The attribute is not cleared, so a predicate method for that attribute will still return true. Similarly, when the attribute is next accessed, a default value will not be generated.</div>
<div class="subsection">
<h2>Triggers</h2> A &quot;trigger&quot; is a subroutine that is called whenever the attribute is set:<div class="spacer">
</div>
<br/>
  has 'size' =&gt; (<br/>
      is      =&gt; 'rw',<br/>
      trigger =&gt; \&amp;_size_set,<br/>
  );<br/>
<br/>
  sub _size_set {<br/>
      my ( $self, $size, $old_size ) = @_;<br/>
<br/>
      my $msg = $self-&gt;name;<br/>
<br/>
      if ( @_ &gt; 2 ) {<br/>
          $msg .= &quot; - old size was $old_size&quot;;<br/>
      }<br/>
<br/>
      $msg .= &quot; - size is now $size&quot;;<br/>
      warn $msg;<br/>
  }<br/>
<div class="spacer">
</div>
The trigger is called <i>after</i> an attribute's value is set. It is called as a method on the object, and receives the new and old values as its arguments. If the attribute had not previously been set at all, then only the new value is passed. This lets you distinguish between the case where the attribute had no value versus when the old value was &quot;undef&quot;.<div class="spacer">
</div>
This differs from an &quot;after&quot; method modifier in two ways. First, a trigger is only called when the attribute is set, as opposed to whenever the accessor method is called (for reading or writing). Second, it is also called when an attribute's value is passed to the constructor.<div class="spacer">
</div>
However, triggers are <i>not</i> called when an attribute is populated from a &quot;default&quot; or &quot;builder&quot;.</div>
<div class="subsection">
<h2>Attribute types</h2> Attributes can be restricted to only accept certain types:<div class="spacer">
</div>
<br/>
  has 'first_name' =&gt; (<br/>
      is  =&gt; 'ro',<br/>
      isa =&gt; 'Str',<br/>
  );<br/>
<div class="spacer">
</div>
This says that the &quot;first_name&quot; attribute must be a string.<div class="spacer">
</div>
Moose also provides a shortcut for specifying that an attribute only accepts objects that do a certain role:<div class="spacer">
</div>
<br/>
  has 'weapon' =&gt; (<br/>
      is   =&gt; 'rw',<br/>
      does =&gt; 'MyApp::Weapon',<br/>
  );<br/>
<div class="spacer">
</div>
See the Moose::Manual::Types documentation for a complete discussion of Moose's type system.</div>
<div class="subsection">
<h2>Delegation</h2> An attribute can define methods which simply delegate to its value:<div class="spacer">
</div>
<br/>
  has 'hair_color' =&gt; (<br/>
      is      =&gt; 'ro',<br/>
      isa     =&gt; 'Graphics::Color::RGB',<br/>
      handles =&gt; { hair_color_hex =&gt; 'as_hex_string' },<br/>
  );<br/>
<div class="spacer">
</div>
This adds a new method, &quot;hair_color_hex&quot;. When someone calls &quot;hair_color_hex&quot;, internally, the object just calls &quot;$self-&gt;hair_color-&gt;as_hex_string&quot;.<div class="spacer">
</div>
See Moose::Manual::Delegation for documentation on how to set up delegation methods.</div>
<div class="subsection">
<h2>Attribute traits and metaclasses</h2> One of Moose's best features is that it can be extended in all sorts of ways through the use of metaclass traits and custom metaclasses.<div class="spacer">
</div>
You can apply one or more traits to an attribute:<div class="spacer">
</div>
<br/>
  use MooseX::MetaDescription;<br/>
<br/>
  has 'size' =&gt; (<br/>
      is          =&gt; 'ro',<br/>
      traits      =&gt; ['MooseX::MetaDescription::Meta::Trait'],<br/>
      description =&gt; {<br/>
          html_widget  =&gt; 'text_input',<br/>
          serialize_as =&gt; 'element',<br/>
      },<br/>
  );<br/>
<div class="spacer">
</div>
The advantage of traits is that you can mix more than one of them together easily (in fact, a trait is just a role under the hood).<div class="spacer">
</div>
There are a number of MooseX modules on CPAN which provide useful attribute metaclasses and traits. See Moose::Manual::MooseX for some examples. You can also write your own metaclasses and traits. See the &quot;Meta&quot; and &quot;Extending&quot; recipes in Moose::Cookbook for examples.</div>
<div class="subsection">
<h2>Native Delegations</h2> Native delegations allow you to delegate to standard Perl data structures as if they were objects.<div class="spacer">
</div>
For example, we can pretend that an array reference has methods like &quot;push()&quot;, &quot;shift()&quot;, &quot;map()&quot;, &quot;count()&quot;, and more.<div class="spacer">
</div>
<br/>
  has 'options' =&gt; (<br/>
      traits  =&gt; ['Array'],<br/>
      is      =&gt; 'ro',<br/>
      isa     =&gt; 'ArrayRef[Str]',<br/>
      default =&gt; sub { [] },<br/>
      handles =&gt; {<br/>
          all_options    =&gt; 'elements',<br/>
          add_option     =&gt; 'push',<br/>
          map_options    =&gt; 'map',<br/>
          option_count   =&gt; 'count',<br/>
          sorted_options =&gt; 'sort',<br/>
      },<br/>
  );<br/>
<div class="spacer">
</div>
See Moose::Manual::Delegation for more details.</div>
</div>
<div class="section">
<h1>ATTRIBUTE INHERITANCE</h1> By default, a child inherits all of its parent class(es)' attributes as-is. However, you can change most aspects of the inherited attribute in the child class. You cannot change any of its associated method names (reader, writer, predicate, etc).<div class="spacer">
</div>
To override an attribute, you simply prepend its name with a plus sign (&quot;+&quot;):<div class="spacer">
</div>
<br/>
  package LazyPerson;<br/>
<br/>
  use Moose;<br/>
<br/>
  extends 'Person';<br/>
<br/>
  has '+first_name' =&gt; (<br/>
      lazy    =&gt; 1,<br/>
      default =&gt; 'Bill',<br/>
  );<br/>
<div class="spacer">
</div>
Now the &quot;first_name&quot; attribute in &quot;LazyPerson&quot; is lazy, and defaults to 'Bill'.<div class="spacer">
</div>
We recommend that you exercise caution when changing the type (&quot;isa&quot;) of an inherited attribute.</div>
<div class="section">
<h1>MULTIPLE ATTRIBUTE SHORTCUTS</h1> If you have a number of attributes that differ only by name, you can declare them all at once:<div class="spacer">
</div>
<br/>
  package Point;<br/>
<br/>
  use Moose;<br/>
<br/>
  has [ 'x', 'y' ] =&gt; ( is =&gt; 'ro', isa =&gt; 'Int' );<br/>
<div class="spacer">
</div>
Also, because &quot;has&quot; is just a function call, you can call it in a loop:<div class="spacer">
</div>
<br/>
  for my $name ( qw( x y ) ) {<br/>
      my $builder = '_build_' . $name;<br/>
      has $name =&gt; ( is =&gt; 'ro', isa =&gt; 'Int', builder =&gt; $builder );<br/>
  }<br/>
</div>
<div class="section">
<h1>MORE ON ATTRIBUTES</h1> Moose attributes are a big topic, and this document glosses over a few aspects. We recommend that you read the Moose::Manual::Delegation and Moose::Manual::Types documents to get a more complete understanding of attribute features.</div>
<div class="section">
<h1>A FEW MORE OPTIONS</h1> Moose has lots of attribute options. The ones listed below are superseded by some more modern features, but are covered for the sake of completeness.<div class="subsection">
<h2>The &quot;documentation&quot; option</h2> You can provide a piece of documentation as a string for an attribute:<div class="spacer">
</div>
<br/>
  has 'first_name' =&gt; (<br/>
      is            =&gt; 'rw',<br/>
      documentation =&gt; q{The person's first (personal) name},<br/>
  );<br/>
<div class="spacer">
</div>
Moose does absolutely nothing with this information other than store it.</div>
<div class="subsection">
<h2>The &quot;auto_deref&quot; option</h2> If your attribute is an array reference or hash reference, the &quot;auto_deref&quot; option will make Moose dereference the value when it is returned from the reader method:<div class="spacer">
</div>
<br/>
  my %map = $object-&gt;mapping;<br/>
<div class="spacer">
</div>
This option only works if your attribute is explicitly typed as an &quot;ArrayRef&quot; or &quot;HashRef&quot;.<div class="spacer">
</div>
However, we recommend that you use Moose::Meta::Attribute::Native traits for these types of attributes, which gives you much more control over how they are accessed and manipulated.</div>
<div class="subsection">
<h2>Initializer</h2> Moose provides an attribute option called &quot;initializer&quot;. This is called when the attribute's value is being set in the constructor, and lets you change the value before it is set.</div>
</div>
<div class="section">
<h1>AUTHOR</h1> Moose is maintained by the Moose Cabal, along with the help of many contributors. See &quot;CABAL&quot; in Moose and &quot;CONTRIBUTORS&quot; in Moose for details.</div>
<div class="section">
<h1>COPYRIGHT AND LICENSE</h1> This software is copyright (c) 2011 by Infinity Interactive, Inc..<div class="spacer">
</div>
This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5 programming language system itself.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-11-17</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

