<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Pod::Simple(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Pod::Simple(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
Pod::Simple(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Pod::Simple - framework for parsing Pod</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
 TODO<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> Pod::Simple is a Perl library for parsing text in the Pod (&quot;plain old documentation&quot;) markup language that is typically used for writing documentation for Perl and for Perl modules. The Pod format is explained perlpod; the most common formatter is called &quot;perldoc&quot;.<div class="spacer">
</div>
Pod formatters can use Pod::Simple to parse Pod documents and render them into plain text, HTML, or any number of other formats. Typically, such formatters will be subclasses of Pod::Simple, and so they will inherit its methods, like &quot;parse_file&quot;.<div class="spacer">
</div>
If you're reading this document just because you have a Pod-processing subclass that you want to use, this document (plus the documentation for the subclass) is probably all you need to read.<div class="spacer">
</div>
If you're reading this document because you want to write a formatter subclass, continue reading it and then read Pod::Simple::Subclassing, and then possibly even read perlpodspec (some of which is for parser-writers, but much of which is notes to formatter-writers).</div>
<div class="section">
<h1>MAIN METHODS</h1><dl>
<dt>
&quot;$parser = <i>SomeClass</i>-&gt;new();&quot;</dt>
<dd>
This returns a new parser object, where <i></i><i>&quot;SomeClass&quot;</i><i></i> is a subclass of Pod::Simple.</dd>
</dl>
<dl>
<dt>
&quot;$parser-&gt;output_fh( *OUT );&quot;</dt>
<dd>
This sets the filehandle that $parser's output will be written to. You can pass *STDOUT, otherwise you should probably do something like this:<div style="height: 1.00em;">
&#160;</div>
<br/>
    my $outfile = &quot;output.txt&quot;;<br/>
    open TXTOUT, &quot;&gt;$outfile&quot; or die &quot;Can't write to $outfile: $!&quot;;<br/>
    $parser-&gt;output_fh(*TXTOUT);<br/>
<div style="height: 1.00em;">
&#160;</div>
...before you call one of the &quot;$parser-&gt;parse_<i>whatever</i>&quot; methods.</dd>
</dl>
<dl>
<dt>
&quot;$parser-&gt;output_string( \$somestring );&quot;</dt>
<dd>
This sets the string that $parser's output will be sent to, instead of any filehandle.</dd>
</dl>
<dl>
<dt>
&quot;$parser-&gt;parse_file( <i>$some_filename</i> );&quot;</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
&quot;$parser-&gt;parse_file( *INPUT_FH );&quot;</dt>
<dd>
This reads the Pod content of the file (or filehandle) that you specify, and processes it with that $parser object, according to however $parser's class works, and according to whatever parser options you have set up for this $parser object.</dd>
</dl>
<dl>
<dt>
&quot;$parser-&gt;parse_string_document( <i>$all_content</i> );&quot;</dt>
<dd>
This works just like &quot;parse_file&quot; except that it reads the Pod content not from a file, but from a string that you have already in memory.</dd>
</dl>
<dl>
<dt>
&quot;$parser-&gt;parse_lines( <i>...@lines...</i>, undef );&quot;</dt>
<dd>
This processes the lines in @lines (where each list item must be a defined value, and must contain exactly one line of content -- so no items like &quot;foo\nbar&quot; are allowed).  The final &quot;undef&quot; is used to indicate the end of document being parsed.<div style="height: 1.00em;">
&#160;</div>
The other &quot;parser_<i>whatever</i>&quot; methods are meant to be called only once per $parser object; but &quot;parse_lines&quot; can be called as many times per $parser object as you want, as long as the last call (and only the last call) ends with an &quot;undef&quot; value.</dd>
</dl>
<dl>
<dt>
&quot;$parser-&gt;content_seen&quot;</dt>
<dd>
This returns true only if there has been any real content seen for this document.</dd>
</dl>
<dl>
<dt>
&quot;<i>SomeClass</i>-&gt;filter( <i>$filename</i> );&quot;</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
&quot;<i>SomeClass</i>-&gt;filter( <i>*INPUT_FH</i> );&quot;</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
&quot;<i>SomeClass</i>-&gt;filter( <i>\$document_content</i> );&quot;</dt>
<dd>
This is a shortcut method for creating a new parser object, setting the output handle to STDOUT, and then processing the specified file (or filehandle, or in-memory document). This is handy for one-liners like this:<div style="height: 1.00em;">
&#160;</div>
<br/>
  perl -MPod::Simple::Text -e &quot;Pod::Simple::Text-&gt;filter('thingy.pod')&quot;<br/>
</dd>
</dl>
</div>
<div class="section">
<h1>SECONDARY METHODS</h1> Some of these methods might be of interest to general users, as well as of interest to formatter-writers.<div class="spacer">
</div>
Note that the general pattern here is that the accessor-methods read the attribute's value with &quot;$value = $parser-&gt; <i>attribute</i>&quot; and set the attribute's value with &quot;$parser-&gt; <i>attribute</i>(<i>newvalue</i>)&quot;.  For each accessor, I typically only mention one syntax or another, based on which I think you are actually most likely to use.<dl>
<dt>
&quot;$parser-&gt;no_whining( <i>SOMEVALUE</i> )&quot;</dt>
<dd>
If you set this attribute to a true value, you will suppress the parser's complaints about irregularities in the Pod coding. By default, this attribute's value is false, meaning that irregularities will be reported.<div style="height: 1.00em;">
&#160;</div>
Note that turning this attribute to true won't suppress one or two kinds of complaints about rarely occurring unrecoverable errors.</dd>
</dl>
<dl>
<dt>
&quot;$parser-&gt;no_errata_section( <i>SOMEVALUE</i> )&quot;</dt>
<dd>
If you set this attribute to a true value, you will stop the parser from generating a &quot;POD ERRORS&quot; section at the end of the document. By default, this attribute's value is false, meaning that an errata section will be generated, as necessary.</dd>
</dl>
<dl>
<dt>
&quot;$parser-&gt;complain_stderr( <i>SOMEVALUE</i> )&quot;</dt>
<dd>
If you set this attribute to a true value, it will send reports of parsing errors to STDERR. By default, this attribute's value is false, meaning that no output is sent to STDERR.<div style="height: 1.00em;">
&#160;</div>
Setting &quot;complain_stderr&quot; also sets &quot;no_errata_section&quot;.</dd>
</dl>
<dl>
<dt>
&quot;$parser-&gt;source_filename&quot;</dt>
<dd>
This returns the filename that this parser object was set to read from.</dd>
</dl>
<dl>
<dt>
&quot;$parser-&gt;doc_has_started&quot;</dt>
<dd>
This returns true if $parser has read from a source, and has seen Pod content in it.</dd>
</dl>
<dl>
<dt>
&quot;$parser-&gt;source_dead&quot;</dt>
<dd>
This returns true if $parser has read from a source, and come to the end of that source.</dd>
</dl>
<dl>
<dt>
&quot;$parser-&gt;strip_verbatim_indent( <i>SOMEVALUE</i> )&quot;</dt>
<dd>
The perlpod spec for a Verbatim paragraph is &quot;It should be reproduced exactly...&quot;, which means that the whitespace you've used to indent your verbatim blocks will be preserved in the output. This can be annoying for outputs such as HTML, where that whitespace will remain in front of every line. It's an unfortunate case where syntax is turned into semantics.<div style="height: 1.00em;">
&#160;</div>
If the POD your parsing adheres to a consistent indentation policy, you can have such indentation stripped from the beginning of every line of your verbatim blocks. This method tells Pod::Simple what to strip. For two-space indents, you'd use:<div style="height: 1.00em;">
&#160;</div>
<br/>
  $parser-&gt;strip_verbatim_indent('  ');<br/>
<div style="height: 1.00em;">
&#160;</div>
For tab indents, you'd use a tab character:<div style="height: 1.00em;">
&#160;</div>
<br/>
  $parser-&gt;strip_verbatim_indent(&quot;\t&quot;);<br/>
<div style="height: 1.00em;">
&#160;</div>
If the POD is inconsistent about the indentation of verbatim blocks, but you have figured out a heuristic to determine how much a particular verbatim block is indented, you can pass a code reference instead. The code reference will be executed with one argument, an array reference of all the lines in the verbatim block, and should return the value to be stripped from each line. For example, if you decide that you're fine to use the first line of the verbatim block to set the standard for indentation of the rest of the block, you can look at the first line and return the appropriate value, like so:<div style="height: 1.00em;">
&#160;</div>
<br/>
  $new-&gt;strip_verbatim_indent(sub {<br/>
      my $lines = shift;<br/>
      (my $indent = $lines-&gt;[0]) =~ s/\S.*//;<br/>
      return $indent;<br/>
  });<br/>
<div style="height: 1.00em;">
&#160;</div>
If you'd rather treat each line individually, you can do that, too, by just transforming them in-place in the code reference and returning &quot;undef&quot;. Say that you don't want  <i>any</i> lines indented. You can do something like this:<div style="height: 1.00em;">
&#160;</div>
<br/>
  $new-&gt;strip_verbatim_indent(sub {<br/>
      my $lines = shift;<br/>
      sub { s/^\s+// for @{ $lines },<br/>
      return undef;<br/>
  });<br/>
</dd>
</dl>
</div>
<div class="section">
<h1>CAVEATS</h1> This is just a beta release -- there are a good number of things still left to do.  Notably, support for EBCDIC platforms is still half-done, an untested.</div>
<div class="section">
<h1>SEE ALSO</h1> Pod::Simple::Subclassing<div class="spacer">
</div>
perlpod<div class="spacer">
</div>
perlpodspec<div class="spacer">
</div>
Pod::Escapes<div class="spacer">
</div>
perldoc</div>
<div class="section">
<h1>SUPPORT</h1> Questions or discussion about POD and Pod::Simple should be sent to the pod-people@perl.org mail list. Send an empty email to pod-people-subscribe@perl.org to subscribe.<div class="spacer">
</div>
This module is managed in an open GitHub repository, http://github.com/theory/pod-simple/ &lt;http://github.com/theory/pod-simple/&gt;. Feel free to fork and contribute, or to clone git://github.com/theory/pod-simple.git &lt;git://github.com/theory/pod-simple.git&gt; and send patches!<div class="spacer">
</div>
Patches against Pod::Simple are welcome. Please send bug reports to &lt;bug-pod-simple@rt.cpan.org&gt;.</div>
<div class="section">
<h1>COPYRIGHT AND DISCLAIMERS</h1> Copyright (c) 2002 Sean M. Burke.<div class="spacer">
</div>
This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.<div class="spacer">
</div>
This program is distributed in the hope that it will be useful, but without any warranty; without even the implied warranty of merchantability or fitness for a particular purpose.</div>
<div class="section">
<h1>AUTHOR</h1> Pod::Simple was created by Sean M. Burke &lt;sburke@cpan.org&gt;. But don't bother him, he's retired.<div class="spacer">
</div>
Pod::Simple is maintained by:<dl>
<dt>
&#8226;</dt>
<dd>
Allison Randal &quot;allison@perl.org&quot;</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Hans Dieter Pearcey &quot;hdp@cpan.org&quot;</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
David E. Wheeler &quot;dwheeler@cpan.org&quot;</dd>
</dl>
</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-09-26</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

