<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
I18N::LangTags(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
I18N::LangTags(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
I18N::LangTags(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> I18N::LangTags - functions for dealing with RFC3066-style language tags</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
  use I18N::LangTags();<br/>
<div class="spacer">
</div>
...or specify whichever of those functions you want to import, like so:<div class="spacer">
</div>
<br/>
  use I18N::LangTags qw(implicate_supers similarity_language_tag);<br/>
<div class="spacer">
</div>
All the exportable functions are listed below -- you're free to import only some, or none at all.  By default, none are imported.  If you say:<div class="spacer">
</div>
<br/>
    use I18N::LangTags qw(:ALL)<br/>
<div class="spacer">
</div>
...then all are exported.  (This saves you from having to use something less obvious like &quot;use I18N::LangTags qw(/./)&quot;.)<div class="spacer">
</div>
If you don't import any of these functions, assume a &amp;I18N::LangTags:: in front of all the function names in the following examples.</div>
<div class="section">
<h1>DESCRIPTION</h1> Language tags are a formalism, described in RFC 3066 (obsoleting 1766), for declaring what language form (language and possibly dialect) a given chunk of information is in.<div class="spacer">
</div>
This library provides functions for common tasks involving language tags as they are needed in a variety of protocols and applications.<div class="spacer">
</div>
Please see the &quot;See Also&quot; references for a thorough explanation of how to correctly use language tags.<dl>
<dt>
&#8226;</dt>
<dd>
the function is_language_tag($lang1)<div style="height: 1.00em;">
&#160;</div>
Returns true iff $lang1 is a formally valid language tag.<div style="height: 1.00em;">
&#160;</div>
<br/>
   is_language_tag(&quot;fr&quot;)            is TRUE<br/>
   is_language_tag(&quot;x-jicarilla&quot;)   is FALSE<br/>
       (Subtags can be 8 chars long at most -- 'jicarilla' is 9)<br/>
<br/>
   is_language_tag(&quot;sgn-US&quot;)    is TRUE<br/>
       (That's American Sign Language)<br/>
<br/>
   is_language_tag(&quot;i-Klikitat&quot;)    is TRUE<br/>
       (True without regard to the fact noone has actually<br/>
        registered Klikitat -- it's a formally valid tag)<br/>
<br/>
   is_language_tag(&quot;fr-patois&quot;)     is TRUE<br/>
       (Formally valid -- altho descriptively weak!)<br/>
<br/>
   is_language_tag(&quot;Spanish&quot;)       is FALSE<br/>
   is_language_tag(&quot;french-patois&quot;) is FALSE<br/>
       (No good -- first subtag has to match<br/>
        /^([xXiI]|[a-zA-Z]{2,3})$/ -- see RFC3066)<br/>
<br/>
   is_language_tag(&quot;x-borg-prot2532&quot;) is TRUE<br/>
       (Yes, subtags can contain digits, as of RFC3066)<br/>
</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
the function extract_language_tags($whatever)<div style="height: 1.00em;">
&#160;</div>
Returns a list of whatever looks like formally valid language tags in $whatever.  Not very smart, so don't get too creative with what you want to feed it.<div style="height: 1.00em;">
&#160;</div>
<br/>
  extract_language_tags(&quot;fr, fr-ca, i-mingo&quot;)<br/>
    returns:   ('fr', 'fr-ca', 'i-mingo')<br/>
<br/>
  extract_language_tags(&quot;It's like this: I'm in fr -- French!&quot;)<br/>
    returns:   ('It', 'in', 'fr')<br/>
  (So don't just feed it any old thing.)<br/>
<div style="height: 1.00em;">
&#160;</div>
The output is untainted.  If you don't know what tainting is, don't worry about it.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
the function same_language_tag($lang1, $lang2)<div style="height: 1.00em;">
&#160;</div>
Returns true iff $lang1 and $lang2 are acceptable variant tags representing the same language-form.<div style="height: 1.00em;">
&#160;</div>
<br/>
   same_language_tag('x-kadara', 'i-kadara')  is TRUE<br/>
      (The x/i- alternation doesn't matter)<br/>
   same_language_tag('X-KADARA', 'i-kadara')  is TRUE<br/>
      (...and neither does case)<br/>
   same_language_tag('en',       'en-US')     is FALSE<br/>
      (all-English is not the SAME as US English)<br/>
   same_language_tag('x-kadara', 'x-kadar')   is FALSE<br/>
      (these are totally unrelated tags)<br/>
   same_language_tag('no-bok',    'nb')       is TRUE<br/>
      (no-bok is a legacy tag for nb (Norwegian Bokmal))<br/>
<div style="height: 1.00em;">
&#160;</div>
&quot;same_language_tag&quot; works by just seeing whether &quot;encode_language_tag($lang1)&quot; is the same as &quot;encode_language_tag($lang2)&quot;.<div style="height: 1.00em;">
&#160;</div>
(Yes, I know this function is named a bit oddly.  Call it historic reasons.)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
the function similarity_language_tag($lang1, $lang2)<div style="height: 1.00em;">
&#160;</div>
Returns an integer representing the degree of similarity between tags $lang1 and $lang2 (the order of which does not matter), where similarity is the number of common elements on the left, without regard to case and to x/i- alternation.<div style="height: 1.00em;">
&#160;</div>
<br/>
   similarity_language_tag('fr', 'fr-ca')           is 1<br/>
      (one element in common)<br/>
   similarity_language_tag('fr-ca', 'fr-FR')        is 1<br/>
      (one element in common)<br/>
<br/>
   similarity_language_tag('fr-CA-joual',<br/>
                           'fr-CA-PEI')             is 2<br/>
   similarity_language_tag('fr-CA-joual', 'fr-CA')  is 2<br/>
      (two elements in common)<br/>
<br/>
   similarity_language_tag('x-kadara', 'i-kadara')  is 1<br/>
      (x/i- doesn't matter)<br/>
<br/>
   similarity_language_tag('en',       'x-kadar')   is 0<br/>
   similarity_language_tag('x-kadara', 'x-kadar')   is 0<br/>
      (unrelated tags -- no similarity)<br/>
<br/>
   similarity_language_tag('i-cree-syllabic',<br/>
                           'i-cherokee-syllabic')   is 0<br/>
      (no B&lt;leftmost&gt; elements in common!)<br/>
</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
the function is_dialect_of($lang1, $lang2)<div style="height: 1.00em;">
&#160;</div>
Returns true iff language tag $lang1 represents a subform of language tag $lang2.<div style="height: 1.00em;">
&#160;</div>
<b>Get the order right!  It doesn't work the other way around!</b><div style="height: 1.00em;">
&#160;</div>
<br/>
   is_dialect_of('en-US', 'en')            is TRUE<br/>
     (American English IS a dialect of all-English)<br/>
<br/>
   is_dialect_of('fr-CA-joual', 'fr-CA')   is TRUE<br/>
   is_dialect_of('fr-CA-joual', 'fr')      is TRUE<br/>
     (Joual is a dialect of (a dialect of) French)<br/>
<br/>
   is_dialect_of('en', 'en-US')            is FALSE<br/>
     (all-English is a NOT dialect of American English)<br/>
<br/>
   is_dialect_of('fr', 'en-CA')            is FALSE<br/>
<br/>
   is_dialect_of('en',    'en'   )         is TRUE<br/>
   is_dialect_of('en-US', 'en-US')         is TRUE<br/>
     (B&lt;Note:&gt; these are degenerate cases)<br/>
<br/>
   is_dialect_of('i-mingo-tom', 'x-Mingo') is TRUE<br/>
     (the x/i thing doesn't matter, nor does case)<br/>
<br/>
   is_dialect_of('nn', 'no')               is TRUE<br/>
     (because 'nn' (New Norse) is aliased to 'no-nyn',<br/>
      as a special legacy case, and 'no-nyn' is a<br/>
      subform of 'no' (Norwegian))<br/>
</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
the function super_languages($lang1)<div style="height: 1.00em;">
&#160;</div>
Returns a list of language tags that are superordinate tags to $lang1 -- it gets this by removing subtags from the end of $lang1 until nothing (or just &quot;i&quot; or &quot;x&quot;) is left.<div style="height: 1.00em;">
&#160;</div>
<br/>
   super_languages(&quot;fr-CA-joual&quot;)  is  (&quot;fr-CA&quot;, &quot;fr&quot;)<br/>
<br/>
   super_languages(&quot;en-AU&quot;)  is  (&quot;en&quot;)<br/>
<br/>
   super_languages(&quot;en&quot;)  is  empty-list, ()<br/>
<br/>
   super_languages(&quot;i-cherokee&quot;)  is  empty-list, ()<br/>
    ...not (&quot;i&quot;), which would be illegal as well as pointless.<br/>
<div style="height: 1.00em;">
&#160;</div>
If $lang1 is not a valid language tag, returns empty-list in a list context, undef in a scalar context.<div style="height: 1.00em;">
&#160;</div>
A notable and rather unavoidable problem with this method: &quot;x-mingo-tom&quot; has an &quot;x&quot; because the whole tag isn't an IANA-registered tag -- but super_languages('x-mingo-tom') is ('x-mingo') -- which isn't really right, since 'i-mingo' is registered.  But this module has no way of knowing that.  (But note that same_language_tag('x-mingo', 'i-mingo') is TRUE.)<div style="height: 1.00em;">
&#160;</div>
More importantly, you assume <i>at your peril</i> that superordinates of $lang1 are mutually intelligible with $lang1.  Consider this carefully.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
the function locale2language_tag($locale_identifier)<div style="height: 1.00em;">
&#160;</div>
This takes a locale name (like &quot;en&quot;, &quot;en_US&quot;, or &quot;en_US.ISO8859-1&quot;) and maps it to a language tag.  If it's not mappable (as with, notably, &quot;C&quot; and &quot;POSIX&quot;), this returns empty-list in a list context, or undef in a scalar context.<div style="height: 1.00em;">
&#160;</div>
<br/>
   locale2language_tag(&quot;en&quot;) is &quot;en&quot;<br/>
<br/>
   locale2language_tag(&quot;en_US&quot;) is &quot;en-US&quot;<br/>
<br/>
   locale2language_tag(&quot;en_US.ISO8859-1&quot;) is &quot;en-US&quot;<br/>
<br/>
   locale2language_tag(&quot;C&quot;) is undef or ()<br/>
<br/>
   locale2language_tag(&quot;POSIX&quot;) is undef or ()<br/>
<br/>
   locale2language_tag(&quot;POSIX&quot;) is undef or ()<br/>
<div style="height: 1.00em;">
&#160;</div>
I'm not totally sure that locale names map satisfactorily to language tags.  Think REAL hard about how you use this.  YOU HAVE BEEN WARNED.<div style="height: 1.00em;">
&#160;</div>
The output is untainted.  If you don't know what tainting is, don't worry about it.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
the function encode_language_tag($lang1)<div style="height: 1.00em;">
&#160;</div>
This function, if given a language tag, returns an encoding of it such that:<div style="height: 1.00em;">
&#160;</div>
* tags representing different languages never get the same encoding.<div style="height: 1.00em;">
&#160;</div>
* tags representing the same language always get the same encoding.<div style="height: 1.00em;">
&#160;</div>
* an encoding of a formally valid language tag always is a string value that is defined, has length, and is true if considered as a boolean.<div style="height: 1.00em;">
&#160;</div>
Note that the encoding itself is <b>not</b> a formally valid language tag. Note also that you cannot, currently, go from an encoding back to a language tag that it's an encoding of.<div style="height: 1.00em;">
&#160;</div>
Note also that you <b>must</b> consider the encoded value as atomic; i.e., you should not consider it as anything but an opaque, unanalysable string value.  (The internals of the encoding method may change in future versions, as the language tagging standard changes over time.)<div style="height: 1.00em;">
&#160;</div>
&quot;encode_language_tag&quot; returns undef if given anything other than a formally valid language tag.<div style="height: 1.00em;">
&#160;</div>
The reason &quot;encode_language_tag&quot; exists is because different language tags may represent the same language; this is normally treatable with &quot;same_language_tag&quot;, but consider this situation:<div style="height: 1.00em;">
&#160;</div>
You have a data file that expresses greetings in different languages. Its format is &quot;[language tag]=[how to say 'Hello']&quot;, like:<div style="height: 1.00em;">
&#160;</div>
<br/>
          en-US=Hiho<br/>
          fr=Bonjour<br/>
          i-mingo=Hau'<br/>
<div style="height: 1.00em;">
&#160;</div>
And suppose you write a program that reads that file and then runs as a daemon, answering client requests that specify a language tag and then expect the string that says how to greet in that language.  So an interaction looks like:<div style="height: 1.00em;">
&#160;</div>
<br/>
          greeting-client asks:    fr<br/>
          greeting-server answers: Bonjour<br/>
<div style="height: 1.00em;">
&#160;</div>
So far so good.  But suppose the way you're implementing this is:<div style="height: 1.00em;">
&#160;</div>
<br/>
          my %greetings;<br/>
          die unless open(IN, &quot;&lt;in.dat&quot;);<br/>
          while(&lt;IN&gt;) {<br/>
            chomp;<br/>
            next unless /^([^=]+)=(.+)/s;<br/>
            my($lang, $expr) = ($1, $2);<br/>
            $greetings{$lang} = $expr;<br/>
          }<br/>
          close(IN);<br/>
<div style="height: 1.00em;">
&#160;</div>
at which point %greetings has the contents:<div style="height: 1.00em;">
&#160;</div>
<br/>
          &quot;en-US&quot;   =&gt; &quot;Hiho&quot;<br/>
          &quot;fr&quot;      =&gt; &quot;Bonjour&quot;<br/>
          &quot;i-mingo&quot; =&gt; &quot;Hau'&quot;<br/>
<div style="height: 1.00em;">
&#160;</div>
And suppose then that you answer client requests for language $wanted by just looking up $greetings{$wanted}.<div style="height: 1.00em;">
&#160;</div>
If the client asks for &quot;fr&quot;, that will look up successfully in %greetings, to the value &quot;Bonjour&quot;.  And if the client asks for &quot;i-mingo&quot;, that will look up successfully in %greetings, to the value &quot;Hau'&quot;.<div style="height: 1.00em;">
&#160;</div>
But if the client asks for &quot;i-Mingo&quot; or &quot;x-mingo&quot;, or &quot;Fr&quot;, then the lookup in %greetings fails.  That's the Wrong Thing.<div style="height: 1.00em;">
&#160;</div>
You could instead do lookups on $wanted with:<div style="height: 1.00em;">
&#160;</div>
<br/>
          use I18N::LangTags qw(same_language_tag);<br/>
          my $response = '';<br/>
          foreach my $l2 (keys %greetings) {<br/>
            if(same_language_tag($wanted, $l2)) {<br/>
              $response = $greetings{$l2};<br/>
              last;<br/>
            }<br/>
          }<br/>
<div style="height: 1.00em;">
&#160;</div>
But that's rather inefficient.  A better way to do it is to start your program with:<div style="height: 1.00em;">
&#160;</div>
<br/>
          use I18N::LangTags qw(encode_language_tag);<br/>
          my %greetings;<br/>
          die unless open(IN, &quot;&lt;in.dat&quot;);<br/>
          while(&lt;IN&gt;) {<br/>
            chomp;<br/>
            next unless /^([^=]+)=(.+)/s;<br/>
            my($lang, $expr) = ($1, $2);<br/>
            $greetings{<br/>
                        encode_language_tag($lang)<br/>
                      } = $expr;<br/>
          }<br/>
          close(IN);<br/>
<div style="height: 1.00em;">
&#160;</div>
and then just answer client requests for language $wanted by just looking up<div style="height: 1.00em;">
&#160;</div>
<br/>
          $greetings{encode_language_tag($wanted)}<br/>
<div style="height: 1.00em;">
&#160;</div>
And that does the Right Thing.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
the function alternate_language_tags($lang1)<div style="height: 1.00em;">
&#160;</div>
This function, if given a language tag, returns all language tags that are alternate forms of this language tag.  (I.e., tags which refer to the same language.)  This is meant to handle legacy tags caused by the minor changes in language tag standards over the years; and the x-/i- alternation is also dealt with.<div style="height: 1.00em;">
&#160;</div>
Note that this function does <i>not</i> try to equate new (and never-used, and unusable) ISO639-2 three-letter tags to old (and still in use) ISO639-1 two-letter equivalents -- like &quot;ara&quot; -&gt; &quot;ar&quot; -- because &quot;ara&quot; has  <i>never</i> been in use as an Internet language tag, and RFC 3066 stipulates that it never should be, since a shorter tag (&quot;ar&quot;) exists.<div style="height: 1.00em;">
&#160;</div>
Examples:<div style="height: 1.00em;">
&#160;</div>
<br/>
          alternate_language_tags('no-bok')       is ('nb')<br/>
          alternate_language_tags('nb')           is ('no-bok')<br/>
          alternate_language_tags('he')           is ('iw')<br/>
          alternate_language_tags('iw')           is ('he')<br/>
          alternate_language_tags('i-hakka')      is ('zh-hakka', 'x-hakka')<br/>
          alternate_language_tags('zh-hakka')     is ('i-hakka', 'x-hakka')<br/>
          alternate_language_tags('en')           is ()<br/>
          alternate_language_tags('x-mingo-tom')  is ('i-mingo-tom')<br/>
          alternate_language_tags('x-klikitat')   is ('i-klikitat')<br/>
          alternate_language_tags('i-klikitat')   is ('x-klikitat')<br/>
<div style="height: 1.00em;">
&#160;</div>
This function returns empty-list if given anything other than a formally valid language tag.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
the function @langs = panic_languages(@accept_languages)<div style="height: 1.00em;">
&#160;</div>
This function takes a list of 0 or more language tags that constitute a given user's Accept-Language list, and returns a list of tags for  <i>other</i> (non-super) languages that are probably acceptable to the user, to be used  <i>if all else fails</i>.<div style="height: 1.00em;">
&#160;</div>
For example, if a user accepts only 'ca' (Catalan) and 'es' (Spanish), and the documents/interfaces you have available are just in German, Italian, and Chinese, then the user will most likely want the Italian one (and not the Chinese or German one!), instead of getting nothing.  So &quot;panic_languages('ca', 'es')&quot; returns a list containing 'it' (Italian).<div style="height: 1.00em;">
&#160;</div>
English ('en') is <i>always</i> in the return list, but whether it's at the very end or not depends on the input languages.  This function works by consulting an internal table that stipulates what common languages are &quot;close&quot; to each other.<div style="height: 1.00em;">
&#160;</div>
A useful construct you might consider using is:<div style="height: 1.00em;">
&#160;</div>
<br/>
  @fallbacks = super_languages(@accept_languages);<br/>
  push @fallbacks, panic_languages(<br/>
    @accept_languages, @fallbacks,<br/>
  );<br/>
</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
the function implicate_supers( ...languages... )<div style="height: 1.00em;">
&#160;</div>
This takes a list of strings (which are presumed to be language-tags; strings that aren't, are ignored); and after each one, this function inserts super-ordinate forms that don't already appear in the list. The original list, plus these insertions, is returned.<div style="height: 1.00em;">
&#160;</div>
In other words, it takes this:<div style="height: 1.00em;">
&#160;</div>
<br/>
  pt-br de-DE en-US fr pt-br-janeiro<br/>
<div style="height: 1.00em;">
&#160;</div>
and returns this:<div style="height: 1.00em;">
&#160;</div>
<br/>
  pt-br pt de-DE de en-US en fr pt-br-janeiro<br/>
<div style="height: 1.00em;">
&#160;</div>
This function is most useful in the idiom<div style="height: 1.00em;">
&#160;</div>
<br/>
  implicate_supers( I18N::LangTags::Detect::detect() );<br/>
<div style="height: 1.00em;">
&#160;</div>
(See I18N::LangTags::Detect.)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
the function implicate_supers_strictly( ...languages... )<div style="height: 1.00em;">
&#160;</div>
This works like &quot;implicate_supers&quot; except that the implicated forms are added to the end of the return list.<div style="height: 1.00em;">
&#160;</div>
In other words, implicate_supers_strictly takes a list of strings (which are presumed to be language-tags; strings that aren't, are ignored) and after the whole given list, it inserts the super-ordinate forms of all given tags, minus any tags that already appear in the input list.<div style="height: 1.00em;">
&#160;</div>
In other words, it takes this:<div style="height: 1.00em;">
&#160;</div>
<br/>
  pt-br de-DE en-US fr pt-br-janeiro<br/>
<div style="height: 1.00em;">
&#160;</div>
and returns this:<div style="height: 1.00em;">
&#160;</div>
<br/>
  pt-br de-DE en-US fr pt-br-janeiro pt de en<br/>
<div style="height: 1.00em;">
&#160;</div>
The reason this function has &quot;_strictly&quot; in its name is that when you're processing an Accept-Language list according to the RFCs, if you interpret the RFCs quite strictly, then you would use implicate_supers_strictly, but for normal use (i.e., common-sense use, as far as I'm concerned) you'd use implicate_supers.</dd>
</dl>
</div>
<div class="section">
<h1>ABOUT LOWERCASING</h1> I've considered making all the above functions that output language tags return all those tags strictly in lowercase.  Having all your language tags in lowercase does make some things easier.  But you might as well just lowercase as you like, or call &quot;encode_language_tag($lang1)&quot; where appropriate.</div>
<div class="section">
<h1>ABOUT UNICODE PLAINTEXT LANGUAGE TAGS</h1> In some future version of I18N::LangTags, I plan to include support for RFC2482-style language tags -- which are basically just normal language tags with their ASCII characters shifted into Plane 14.</div>
<div class="section">
<h1>SEE ALSO</h1> * I18N::LangTags::List<div class="spacer">
</div>
* RFC 3066, &quot;ftp://ftp.isi.edu/in-notes/rfc3066.txt&quot;, &quot;Tags for the Identification of Languages&quot;.  (Obsoletes RFC 1766)<div class="spacer">
</div>
* RFC 2277, &quot;ftp://ftp.isi.edu/in-notes/rfc2277.txt&quot;, &quot;IETF Policy on Character Sets and Languages&quot;.<div class="spacer">
</div>
* RFC 2231, &quot;ftp://ftp.isi.edu/in-notes/rfc2231.txt&quot;, &quot;MIME Parameter Value and Encoded Word Extensions: Character Sets, Languages, and Continuations&quot;.<div class="spacer">
</div>
* RFC 2482, &quot;ftp://ftp.isi.edu/in-notes/rfc2482.txt&quot;, &quot;Language Tagging in Unicode Plain Text&quot;.<div class="spacer">
</div>
* Locale::Codes, in &quot;http://www.perl.com/CPAN/modules/by-module/Locale/&quot;<div class="spacer">
</div>
* ISO 639-2, &quot;Codes for the representation of names of languages&quot;, including two-letter and three-letter codes, &quot;http://www.loc.gov/standards/iso639-2/langcodes.html&quot;<div class="spacer">
</div>
* The IANA list of registered languages (hopefully up-to-date), &quot;http://www.iana.org/assignments/language-tags&quot;</div>
<div class="section">
<h1>COPYRIGHT</h1> Copyright (c) 1998+ Sean M. Burke. All rights reserved.<div class="spacer">
</div>
This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.<div class="spacer">
</div>
The programs and documentation in this dist are distributed in the hope that they will be useful, but without any warranty; without even the implied warranty of merchantability or fitness for a particular purpose.</div>
<div class="section">
<h1>AUTHOR</h1> Sean M. Burke &quot;sburke@cpan.org&quot;</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-09-26</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

