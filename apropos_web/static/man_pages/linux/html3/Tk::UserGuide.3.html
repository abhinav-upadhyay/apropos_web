<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
UserGuide(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
UserGuide(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
UserGuide(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Perl/Tk - Writing Tk applications in Perl 5</div>
<div class="section">
<h1>DESCRIPTION</h1> This document is for beginners.  It assumes you know some  <b>Perl</b>, and have it and Tk running.  If you are  <i>not</i> currently reading this document courtesy of the  <b>widget</b> demonstration program, please be sure to run  <b>widget</b>, as it will show you the various widget types supported by Tk and how to use them.  <b>widget</b> should be installed in your default path, so type  <i>widget</i> at a command prompt.<div class="spacer">
</div>
Here are links to other novice tutorials:<div class="spacer">
</div>
&lt;http://www.lehigh.edu/~sol0/ptk/tpj1.html&gt; &lt;http://www.lehigh.edu/~sol0/ptk/perlmonth01/pm1.html&gt;<div class="spacer">
</div>
<i>Mastering Perl/Tk</i> is the definitive book on Perl/Tk:<div class="spacer">
</div>
&lt;http://www.oreilly.com/catalog/mastperltk&gt;</div>
<div class="section">
<h1>Some Background</h1> Tk GUI programming is event-driven.  (This may already be familiar to you.)  In event-driven programs, the main GUI loop is outside of the user program and inside the GUI library.  This loop - initiated by calling  <b>MainLoop</b> - watches all events of interest and activates the correct handler procedures to handle these events.  Some of these handler procedures may be user-supplied; others will be part of the library.<div class="spacer">
</div>
For a programmer, this means that you're not watching what is happening; instead, you are requested by the toolkit to perform actions whenever necessary. So, you're not watching for 'raise window / close window / redraw window' requests, but you tell the toolkit which routine will handle such cases, and the toolkit will call the procedures when required. These procedures are known as  <i>callbacks</i>, and some of them you write yourself.</div>
<div class="section">
<h1>First Requirements</h1>  <b>Perl</b> programs that use Tk need to include &quot;use Tk&quot;. A program should also use &quot;use strict&quot; and the  <b>-w</b> switch to ensure the program is working without common errors.<div class="spacer">
</div>
Any Perl/Tk application starts by creating the Tk <b>MainWindow</b>.  You then create items inside the  <b>MainWindow</b>, and/or create new windows called  <b>Toplevel</b>s that also contain child items, before starting the  <b>MainLoop</b>, which is the last logical statment in your program. You can also create more items and windows while you're running, using callbacks.  Items are only shown on the display after they have been arranged by a  <i>geometry manager</i> like <b>pack</b>; more information on this later.   <b>MainLoop</b> starts the GUI and handle all events.  That's all there is to it!  A trivial one-window example is shown below:<div class="spacer">
</div>
<br/>
    #!/usr/bin/perl -w  <br/>
    use Tk;<br/>
    use strict;<br/>
<br/>
    my $mw = MainWindow-&gt;new;<br/>
    $mw-&gt;Label(-text =&gt; 'Hello, world!')-&gt;pack;<br/>
    $mw-&gt;Button(<br/>
        -text    =&gt; 'Quit',<br/>
        -command =&gt; sub { exit },<br/>
    )-&gt;pack;<br/>
    MainLoop;<br/>
<div class="spacer">
</div>
Please run this example.  It shows you two widget types, a <b>Label</b> and a  <b>Button</b>, and how they are packed. When clicked, the <b>Button</b> widget invokes the callback specified by the &quot;-command&quot; option.  Finally, note the typical Tk style using &quot;-option&quot; =&gt; &quot;value&quot; pairs.</div>
<div class="section">
<h1>Widget creation</h1> Tk windows and widgets are hierarchical, i.e.&#160;one window includes one or more other windows.  You create the first Tk window using &quot;MainWindow-&gt;new&quot;.  This returns a window handle, assigned to $mw in the example above.  Keep track of the main handle, commonly called a  <i>widget reference</i>.<div class="spacer">
</div>
You can use any Tk handle to create child widgets within the window (or widget).  This is done by calling the Tk constructor method on the variable.  In the example above, the &quot;Label&quot; method called from $mw creates a  <b>Label</b> widget inside the <b>MainWindow</b>.  In the constructor call, you can specify various options; you can later add or change options for any widget using the  <b>configure</b> method, which takes the same parameters as the constructor.  The one exception to the hierarchical structure is the  <b>Toplevel</b> constructor, which creates a new outermost window.<div class="spacer">
</div>
After you create any widget (other than the <b>MainWindow</b> or  <b>Toplevel</b>s, you must render it by calling <b>pack</b>.  (This is not entirely true; more later)).  If you do not need to refer to the widget after construction and packing, call  <b>pack</b> off the constructor results, as shown for the  <b>Label</b> and <b>Button</b> in the example above.  Note that the result of the compound call is the result of  <b>pack</b>, which is a valid Tk handle.<div class="spacer">
</div>
Windows and widgets are deleted by calling <b>destroy</b> on them; this will delete and un-draw the widget and all its children.</div>
<div class="section">
<h1>Standard Tk widgets</h1> Here is an itemize of the standard Tk widget set.<dl>
<dt>
Button</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Canvas</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Checkbutton</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Entry</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Frame</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Label</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Labelframe</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Listbox</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Menu</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Menubutton</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Message</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Panedwindow</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Radiobutton</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Scale</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Scrollbar</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Spinbox</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Text</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Toplevel</dt>
<dd>
</dd>
</dl>
<div class="spacer">
</div>
Perl/Tk provides an equal number of new widgets, above and beyond this core set.<dl>
<dt>
Adjuster</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Balloon</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
BrowseEntry</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
ColorEditor</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Dialog</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
DialogBox</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
DirTree</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
ErrorDialog</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
FBox</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
FileSelect</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
HList</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
LabEntry</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
LabFrame</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
NoteBook</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Optionmenu</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Pane</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
ProgressBar</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
ROText</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Table</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
TextUndo</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Tiler</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
TList</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
Tree</dt>
<dd>
</dd>
</dl>
</div>
<div class="section">
<h1>Variables and callback routines</h1> Most graphical interfaces are used to set up a set of values and conditions, and then perform the appropriate action.  The Tk toolkit is different from your average text-based prompting or menu driven system in that you do not collect settings yourself, and decide on an action based on an input code; instead, you leave these values to your toolkit and only get them when the action is performed.<div class="spacer">
</div>
So, where a traditional text-based system would look like this:<div class="spacer">
</div>
<br/>
    #!/usr/bin/perl -w<br/>
    use strict;<br/>
<br/>
    print &quot;Please type a font name\n&quot;;<br/>
    my $font = &lt;&gt;; chomp $font;<br/>
    # Validate font<br/>
<br/>
    print &quot;Please type a file name\n&quot;;<br/>
    my $filename = &lt;&gt;; chomp $filename;<br/>
    # Validate filename<br/>
<br/>
    print &quot;Type &lt;1&gt; to fax, &lt;2&gt; to print\n&quot;;<br/>
    my $option = &lt;&gt;; chomp $option;<br/>
    if ($option eq 1) {<br/>
        print &quot;Faxing $filename in font $font\n&quot;;<br/>
    } elsif ($option eq 2) {<br/>
        print &quot;Now sending $filename to printer in font $font\n&quot;;<br/>
    }<br/>
<div class="spacer">
</div>
The slightly larger example below shows how to do this in Tk. Note the use of callbacks.  Note, also, that Tk handles the values, and the subroutine uses the method  <b>get</b> to get at the values. If a user changes his mind and wants to change the font again, the application never notices; it's all handled by Tk.<div class="spacer">
</div>
<br/>
    #!/usr/bin/perl -w<br/>
    use Tk;<br/>
    use strict;<br/>
<br/>
    my $mw = MainWindow-&gt;new;<br/>
<br/>
    $mw-&gt;Label(-text =&gt; 'File Name')-&gt;pack;<br/>
    my $filename = $mw-&gt;Entry(-width =&gt; 20);<br/>
    $filename-&gt;pack;<br/>
<br/>
    $mw-&gt;Label(-text =&gt; 'Font Name')-&gt;pack;<br/>
    my $font = $mw-&gt;Entry(-width =&gt; 10);<br/>
    $font-&gt;pack;<br/>
<br/>
    $mw-&gt;Button(<br/>
        -text =&gt; 'Fax',<br/>
        -command =&gt; sub{do_fax($filename, $font)}<br/>
    )-&gt;pack;<br/>
<br/>
    $mw-&gt;Button(<br/>
        -text =&gt; 'Print',<br/>
        -command =&gt; sub{do_print($filename, $font)}<br/>
    )-&gt;pack;<br/>
<br/>
    MainLoop;<br/>
<br/>
    sub do_fax {<br/>
        my ($file, $font) = @_;<br/>
        my $file_val = $file-&gt;get;<br/>
        my $font_val = $font-&gt;get;<br/>
        print &quot;Now faxing $file_val in font $font_val\n&quot;;<br/>
    }<br/>
<br/>
    sub do_print {<br/>
        my ($file, $font) = @_;<br/>
        my $file_val = $file-&gt;get;<br/>
        my $font_val = $font-&gt;get;<br/>
        print &quot;Sending file $file_val to printer in font $font_val\n&quot;;<br/>
    }<br/>
</div>
<div class="section">
<h1>The packer - grouping with Frame widgets</h1> In the examples above, you must have noticed the  <b>pack</b> calls.  This is one of the more complicated parts of Tk.  The basic idea is that any window or widget should be subject to a Tk geometry manager; the  <i>packer</i> is one of the placement managers, and <b>grid</b> is another.<div class="spacer">
</div>
The actions of the packer are rather simple: when applied to a widget, the packer positions that widget on the indicated position within the remaining space in its parent.  By default, the position is on top; this means the next items will be put below.  You can also specify the left, right, or bottom positions.  Specify position using  <b>-side =&gt; 'right'</b>.<div class="spacer">
</div>
Additional packing parameters specify the behavior of the widget when there is some space left in the  <b>Frame</b> or when the window size is increased.  If widgets should maintain a fixed size, specify nothing; this is the default.  For widgets that you want to fill up the current horizontal and/or vertical space, specify  <b>-fill =&gt; 'x'</b>, <b>'y'</b>, or  <b>'both'</b>; for widgets that should grow, specify <b>-expand =&gt; 1</b>. These parameters are not shown in the example below; see the  <b>widget</b> demonstration.<div class="spacer">
</div>
If you want to group some items within a window that have a different packing order than others, you can include them in a Frame.  This is a do-nothing window type that is meant for packing or filling (and to play games with borders and colors).<div class="spacer">
</div>
The example below shows the use of pack and Frames:<div class="spacer">
</div>
<br/>
    #!/usr/bin/perl -w<br/>
    use Tk;<br/>
    use strict;<br/>
<br/>
    # Take top and the bottom - now implicit top is in the middle<br/>
    my $mw = MainWindow-&gt;new;<br/>
    $mw-&gt;title( 'The MainWindow' );<br/>
    $mw-&gt;Label(-text =&gt; 'At the top (default)')-&gt;pack;<br/>
    $mw-&gt;Label(-text =&gt; 'At the bottom')-&gt;pack(-side =&gt; 'bottom');<br/>
    $mw-&gt;Label(-text =&gt; 'The middle remains')-&gt;pack;<br/>
<br/>
    # Since left and right are taken, bottom will not work...<br/>
    my $top1 = $mw-&gt;Toplevel;<br/>
    $top1-&gt;title( 'Toplevel 1' );<br/>
    $top1-&gt;Label(-text =&gt; 'Left')-&gt;pack(-side =&gt; 'left');<br/>
    $top1-&gt;Label(-text =&gt; 'Right')-&gt;pack(-side =&gt; 'right');<br/>
    $top1-&gt;Label(-text =&gt; '?Bottom?')-&gt;pack(-side =&gt; 'bottom');<br/>
<br/>
    # But when you use Frames, things work quite alright<br/>
    my $top2 = $mw-&gt;Toplevel;<br/>
    $top2-&gt;title( 'Toplevel 2' );<br/>
    my $frame = $top2-&gt;Frame;<br/>
    $frame-&gt;pack;<br/>
    $frame-&gt;Label(-text =&gt; 'Left2')-&gt;pack(-side =&gt; 'left');<br/>
    $frame-&gt;Label(-text =&gt; 'Right2')-&gt;pack(-side =&gt; 'right');<br/>
    $top2-&gt;Label(-text =&gt; 'Bottom2')-&gt;pack(-side =&gt; 'bottom');<br/>
<br/>
    MainLoop;<br/>
</div>
<div class="section">
<h1>More than one window</h1> Most real applications require more than one window.  As you just saw, you can create more outermost windows by using a  <b>Toplevel</b> widget. Each window is independent; destroying a  <b>Toplevel</b> window does not affect the others as long as they are not a child of the closed  <b>Toplevel</b>.  However, exiting the <b>MainWindow</b> will destroy all remaining  <b>Toplevel</b> widgets and end the application.  The example below shows a trivial three-window application:<div class="spacer">
</div>
<br/>
    #!/usr/bin/perl -w<br/>
    use Tk;<br/>
    use strict;<br/>
<br/>
    my $mw = MainWindow-&gt;new;<br/>
    fill_window($mw, 'Main');<br/>
    my $top1 = $mw-&gt;Toplevel;<br/>
    fill_window($top1, 'First top-level');<br/>
    my $top2 = $mw-&gt;Toplevel;<br/>
    fill_window($top2, 'Second top-level');<br/>
    MainLoop;<br/>
<br/>
    sub fill_window {<br/>
        my ($window, $header) = @_;<br/>
        $window-&gt;Label(-text =&gt; $header)-&gt;pack;<br/>
        $window-&gt;Button(<br/>
            -text    =&gt; 'close',<br/>
            -command =&gt; [$window =&gt; 'destroy']<br/>
        )-&gt;pack(-side =&gt; 'left');<br/>
        $window-&gt;Button(<br/>
            -text    =&gt; 'exit',<br/>
            -command =&gt; [$mw =&gt; 'destroy']<br/>
        )-&gt;pack(-side =&gt; 'right');<br/>
    }<br/>
</div>
<div class="section">
<h1>More callbacks</h1> So far, all callback routines shown called a user procedure. You can also have a callback routine call another Tk routine. This is the way that scroll bars are implemented: scroll-bars can call a Tk item or a user procedure, whenever their position has changed.  The Tk item that has a scrollbar attached calls the scrollbar when its size or offset has changed.  In this way, the items are linked.  You can still ask a scrollbar's position, or set it by hand - but the defaults will be taken care of.<div class="spacer">
</div>
The example below shows a <b>Listbox</b> with a scroll bar.  Moving the scrollbar moves the  <b>Listbox</b>.  Scanning a <b>Listbox</b> (dragging an item with the left mouse button) moves the scrollbar.<div class="spacer">
</div>
<br/>
     #!/usr/bin/perl -w<br/>
     use Tk;<br/>
     use strict;<br/>
<br/>
     my $mw = MainWindow-&gt;new;<br/>
     my $box = $mw-&gt;Listbox(<br/>
         -relief =&gt; 'sunken',<br/>
         -height  =&gt; 5,<br/>
         -setgrid =&gt; 1,<br/>
    );<br/>
    my @items = qw(One Two Three Four Five Six Seven<br/>
                   Eight Nine Ten Eleven Twelve);<br/>
    foreach (@items) {<br/>
       $box-&gt;insert('end', $_);<br/>
    }<br/>
    my $scroll = $mw-&gt;Scrollbar(-command =&gt; ['yview', $box]);<br/>
    $box-&gt;configure(-yscrollcommand =&gt; ['set', $scroll]);<br/>
    $box-&gt;pack(-side =&gt; 'left', -fill =&gt; 'both', -expand =&gt; 1);<br/>
    $scroll-&gt;pack(-side =&gt; 'right', -fill =&gt; 'y');<br/>
<br/>
    MainLoop;<br/>
<div class="spacer">
</div>
Note that there's a convenience method <b>Scrolled</b> which helps constructing widgets with automatically managed scrollbars.</div>
<div class="section">
<h1>Canvases and tags</h1> One of the most powerful widgets in Tk is the  <b>Canvas</b> window. In a  <b>Canvas</b> window, you can draw simple graphics and include other widgets.  The  <b>Canvas</b> area may be larger than the visible window, and may then be scrolled.  Any item you draw on the canvas has its own id, and may optionally have one or more  <i>tags</i>.  You may refer to any item by its id, and may refer to any group of items by a common tag; you can move, delete, or change groups of items using these tags, and you can  <i>bind</i> actions to tags.  For a properly designed (often structured)  <b>Canvas</b>, you can specify powerful actions quite simply.<div class="spacer">
</div>
In the example below, actions are bound to circles (single click) and blue items (double-click); obviously, this can be extended to any tag or group of tags.<div class="spacer">
</div>
<br/>
    #!/usr/bin/perl -w<br/>
    use Tk;<br/>
    use strict;<br/>
<br/>
    # Create B&lt;MainWindow&gt; and canvas<br/>
    my $mw = MainWindow-&gt;new;<br/>
    my $canvas = $mw-&gt;Canvas;<br/>
    $canvas-&gt;pack(-expand =&gt; 1, -fill =&gt; 'both');<br/>
<br/>
    # Create various items<br/>
    create_item($canvas, 1, 1, 'circle', 'blue', 'Jane');<br/>
    create_item($canvas, 4, 4, 'circle', 'red', 'Peter');<br/>
    create_item($canvas, 4, 1, 'square', 'blue', 'James');<br/>
    create_item($canvas, 1, 4, 'square', 'red', 'Patricia');<br/>
<br/>
    # Single-clicking with left on a 'circle' item invokes a procedure<br/>
    $canvas-&gt;bind('circle', '&lt;1&gt;' =&gt; sub {handle_circle($canvas)});<br/>
    # Double-clicking with left on a 'blue' item invokes a procedure<br/>
    $canvas-&gt;bind('blue', '&lt;Double-1&gt;' =&gt; sub {handle_blue($canvas)});<br/>
    MainLoop;<br/>
<br/>
    # Create an item; use parameters as tags (this is not a default!)<br/>
    sub create_item {<br/>
        my ($can, $x, $y, $form, $color, $name) = @_;<br/>
<br/>
        my $x2 = $x + 1;<br/>
        my $y2 = $y + 1;<br/>
        my $kind;<br/>
        $kind = 'oval' if ($form eq 'circle');<br/>
        $kind = 'rectangle' if ($form eq 'square');<br/>
        $can-&gt;create(<br/>
            ($kind, &quot;$x&quot; . 'c', &quot;$y&quot; . 'c',<br/>
            &quot;$x2&quot; . 'c', &quot;$y2&quot; . 'c'),<br/>
            -tags =&gt; [$form, $color, $name],<br/>
            -fill =&gt; $color);<br/>
    }<br/>
<br/>
    # This gets the real name (not current, blue/red, square/circle)<br/>
    # Note: you'll want to return a list in realistic situations...<br/>
    sub get_name {<br/>
        my ($can) = @_;<br/>
        my $item = $can-&gt;find('withtag', 'current');<br/>
        my @taglist = $can-&gt;gettags($item);<br/>
        my $name;<br/>
        foreach (@taglist) {<br/>
            next if ($_ eq 'current');<br/>
            next if ($_ eq 'red' or $_ eq 'blue');<br/>
            next if ($_ eq 'square' or $_ eq 'circle');<br/>
            $name = $_;<br/>
            last;<br/>
        }<br/>
        return $name;<br/>
    }<br/>
<br/>
    sub handle_circle {<br/>
        my ($can) = @_;<br/>
        my $name = get_name($can);<br/>
        print &quot;Action on circle $name...\n&quot;;<br/>
    }<br/>
<br/>
    sub handle_blue {<br/>
        my ($can) = @_;<br/>
        my $name = get_name($can);<br/>
        print &quot;Action on blue item $name...\n&quot;;<br/>
    }<br/>
</div>
<div class="section">
<h1>Perl/Tk and Unicode</h1> Perl/Tk follows Perl's model of handling Unicode. That is, if a string is correctly flagged as a &quot;character&quot; string in the sense like described in &quot;TERMINOLOGY&quot; in Encode, then Perl/Tk will very probably display and handle this string correctly.<div class="spacer">
</div>
Note that every variable which is passed somehow into a Perl/Tk method will be implicitely changed into an internally utf8-flagged variable. Semantically nothing changes, as the series of codepoints stays the same, but things will change when variables with high-bit iso-8859-1 characters will be passed to the &quot;outer&quot; world. In this case you have to explicitely mark the encoding of your output stream if using IO, or encode the variables using Encode for other style of communication.<div class="spacer">
</div>
This is the theory, now some examples.<div class="spacer">
</div>
If you use non-iso-8859-1 characters in the source code, then use either the &quot;use utf8;&quot; or &quot;use encoding ' <i>encodingname</i>'&quot; pragma:<div class="spacer">
</div>
<br/>
     use utf8;<br/>
     use Tk;<br/>
     my $x = &quot;some characters using utf8 encoding&quot;;<br/>
     tkinit-&gt;Label(-text =&gt; $x)-&gt;pack;<br/>
     MainLoop;<br/>
<div class="spacer">
</div>
For data that comes from a file you have to specify the encoding unless it's encoded as ascii or iso-8559-1:<div class="spacer">
</div>
<br/>
     use Tk;<br/>
     open my $FH, &quot;&lt;:encoding(utf-8)&quot;, &quot;filename&quot; or die $!;<br/>
     # or for utf-16 data: open my $FH, &quot;&lt;:encoding(utf-16)&quot;, &quot;filename&quot; or die $!;<br/>
     my $data = &lt;$FH&gt;;<br/>
     tkinit-&gt;Label(-text =&gt; $data)-&gt;pack;<br/>
     MainLoop;<br/>
<div class="spacer">
</div>
Likewise, the encoding must be specified for all data which is read from Tk widgets and that shall be output into a file. For the output, the encoding should be always specified, even if it is iso-8859-1:<div class="spacer">
</div>
<br/>
     use Tk;<br/>
     $mw = tkinit;<br/>
     $mw-&gt;Entry(-textvariable =&gt; \$input)-&gt;pack;<br/>
     $mw-&gt;Button(<br/>
         -text =&gt; &quot;Write to file&quot;,<br/>
         -command =&gt; sub {<br/>
             open my $FH, &quot;&gt;:encoding(iso-8859-1)&quot;, &quot;filename&quot; or die $!;<br/>
             print $FH $input;<br/>
         },<br/>
     )-&gt;pack;<br/>
     MainLoop;<br/>
<div class="spacer">
</div>
Note that Tk is Unicode-capable. So you need to be prepared that the user has the appropriate input methods activated to enter non-ascii characters. If an output encoding is used which does not cover the whole of Unicode codepoints then a warning will be issued when writing the file, like this:<div class="spacer">
</div>
<br/>
    &quot;\x{20ac}&quot; does not map to iso-8859-1 at /usr/local/lib/perl5/site_perl/5.8.8/mach/Tk.pm line 250.<br/>
<div class="spacer">
</div>
Also, the same hexadecimal notation will be used as replacements for the unhandled characters.<div class="spacer">
</div>
Handling encoding in I/O is pretty simple using the &quot;encoding&quot; PerlIO layer, as described above. In other cases, such as when dealing with databases, encoding the data usually has to be done manually, unless the database driver has some means for automatically do this for you. So when working with a MySQL database, one could use:<div class="spacer">
</div>
<br/>
     use Tk;<br/>
     use DBI;<br/>
     use Encode qw(encode);<br/>
     $mw = tkinit;<br/>
     $mw-&gt;Entry(-textvariable =&gt; \$input)-&gt;pack;<br/>
     $mw-&gt;Button(<br/>
         -text =&gt; &quot;Write to database&quot;,<br/>
         -command =&gt; sub {<br/>
             my $dbh = DBI-&gt;connect(&quot;dbi:mysql:test&quot;, &quot;root&quot;, &quot;&quot;) or die;<br/>
             my $encoded_input = encode(&quot;iso-8859-1&quot;, $input);<br/>
             $dbh-&gt;do(&quot;INSERT INTO testtable VALUES (?)&quot;, undef, $encoded_input) or die;<br/>
         },<br/>
     )-&gt;pack;<br/>
     MainLoop;<br/>
<div class="spacer">
</div>
Unfortunately, there are still places in Perl ignorant of Unicode. One of these places are filenames. Consequently, the file selectors in Perl/Tk do not handle encoding of filenames properly. Currently they suppose that filenames are in iso-8859-1 encoding, at least on Unix systems. As soon as Perl has a concept of filename encodings, then Perl/Tk will also implement such schemes.</div>
<table class="foot">
<tr>
<td class="foot-date">
2010-01-30</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

