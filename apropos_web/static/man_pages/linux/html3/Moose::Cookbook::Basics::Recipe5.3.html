<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Moose::Cookbook::Basics::Recipe5(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Moose::Cookbook::Basics::Recipe5(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
Moose::Cookbook::Basics::Recipe5(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Moose::Cookbook::Basics::Recipe5 - More subtypes, coercion in a Request class</div>
<div class="section">
<h1>VERSION</h1> version 2.0401</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
  package Request;<br/>
  use Moose;<br/>
  use Moose::Util::TypeConstraints;<br/>
<br/>
  use HTTP::Headers  ();<br/>
  use Params::Coerce ();<br/>
  use URI            ();<br/>
<br/>
  subtype 'My::Types::HTTP::Headers' =&gt; as class_type('HTTP::Headers');<br/>
<br/>
  coerce 'My::Types::HTTP::Headers'<br/>
      =&gt; from 'ArrayRef'<br/>
          =&gt; via { HTTP::Headers-&gt;new( @{$_} ) }<br/>
      =&gt; from 'HashRef'<br/>
          =&gt; via { HTTP::Headers-&gt;new( %{$_} ) };<br/>
<br/>
  subtype 'My::Types::URI' =&gt; as class_type('URI');<br/>
<br/>
  coerce 'My::Types::URI'<br/>
      =&gt; from 'Object'<br/>
          =&gt; via { $_-&gt;isa('URI')<br/>
                   ? $_<br/>
                   : Params::Coerce::coerce( 'URI', $_ ); }<br/>
      =&gt; from 'Str'<br/>
          =&gt; via { URI-&gt;new( $_, 'http' ) };<br/>
<br/>
  subtype 'Protocol'<br/>
      =&gt; as 'Str'<br/>
      =&gt; where { /^HTTP\/[0-9]\.[0-9]$/ };<br/>
<br/>
  has 'base' =&gt; ( is =&gt; 'rw', isa =&gt; 'My::Types::URI', coerce =&gt; 1 );<br/>
  has 'uri'  =&gt; ( is =&gt; 'rw', isa =&gt; 'My::Types::URI', coerce =&gt; 1 );<br/>
  has 'method'   =&gt; ( is =&gt; 'rw', isa =&gt; 'Str' );<br/>
  has 'protocol' =&gt; ( is =&gt; 'rw', isa =&gt; 'Protocol' );<br/>
  has 'headers'  =&gt; (<br/>
      is      =&gt; 'rw',<br/>
      isa     =&gt; 'My::Types::HTTP::Headers',<br/>
      coerce  =&gt; 1,<br/>
      default =&gt; sub { HTTP::Headers-&gt;new }<br/>
  );<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> This recipe introduces type coercions, which are defined with the &quot;coerce&quot; sugar function. Coercions are attached to existing type constraints, and define a (one-way) transformation from one type to another.<div class="spacer">
</div>
This is very powerful, but it can also have unexpected consequences, so you have to explicitly ask for an attribute to be coerced. To do this, you must set the &quot;coerce&quot; attribute option to a true value.<div class="spacer">
</div>
First, we create the subtype to which we will coerce the other types:<div class="spacer">
</div>
<br/>
  subtype 'My::Types::HTTP::Headers' =&gt; as class_type('HTTP::Headers');<br/>
<div class="spacer">
</div>
We are creating a subtype rather than using &quot;HTTP::Headers&quot; as a type directly. The reason we do this is that coercions are global, and a coercion defined for &quot;HTTP::Headers&quot; in our &quot;Request&quot; class would then be defined for  <i>all</i> Moose-using classes in the current Perl interpreter. It's a best practice to avoid this sort of namespace pollution.<div class="spacer">
</div>
The &quot;class_type&quot; sugar function is simply a shortcut for this:<div class="spacer">
</div>
<br/>
  subtype 'HTTP::Headers'<br/>
      =&gt; as 'Object'<br/>
      =&gt; where { $_-&gt;isa('HTTP::Headers') };<br/>
<div class="spacer">
</div>
Internally, Moose creates a type constraint for each Moose-using class, but for non-Moose classes, the type must be declared explicitly.<div class="spacer">
</div>
We could go ahead and use this new type directly:<div class="spacer">
</div>
<br/>
  has 'headers' =&gt; (<br/>
      is      =&gt; 'rw',<br/>
      isa     =&gt; 'My::Types::HTTP::Headers',<br/>
      default =&gt; sub { HTTP::Headers-&gt;new }<br/>
  );<br/>
<div class="spacer">
</div>
This creates a simple attribute which defaults to an empty instance of HTTP::Headers.<div class="spacer">
</div>
The constructor for HTTP::Headers accepts a list of key-value pairs representing the HTTP header fields. In Perl, such a list could be stored in an ARRAY or HASH reference. We want our &quot;headers&quot; attribute to accept those data structures instead of an  <b>HTTP::Headers</b> instance, and just do the right thing. This is exactly what coercion is for:<div class="spacer">
</div>
<br/>
  coerce 'My::Types::HTTP::Headers'<br/>
      =&gt; from 'ArrayRef'<br/>
          =&gt; via { HTTP::Headers-&gt;new( @{$_} ) }<br/>
      =&gt; from 'HashRef'<br/>
          =&gt; via { HTTP::Headers-&gt;new( %{$_} ) };<br/>
<div class="spacer">
</div>
The first argument to &quot;coerce&quot; is the type <i>to</i> which we are coercing. Then we give it a set of &quot;from&quot;/&quot;via&quot; clauses. The &quot;from&quot; function takes some other type name and &quot;via&quot; takes a subroutine reference which actually does the coercion.<div class="spacer">
</div>
However, defining the coercion doesn't do anything until we tell Moose we want a particular attribute to be coerced:<div class="spacer">
</div>
<br/>
  has 'headers' =&gt; (<br/>
      is      =&gt; 'rw',<br/>
      isa     =&gt; 'My::Types::HTTP::Headers',<br/>
      coerce  =&gt; 1,<br/>
      default =&gt; sub { HTTP::Headers-&gt;new }<br/>
  );<br/>
<div class="spacer">
</div>
Now, if we use an &quot;ArrayRef&quot; or &quot;HashRef&quot; to populate &quot;headers&quot;, it will be coerced into a new HTTP::Headers instance. With the coercion in place, the following lines of code are all equivalent:<div class="spacer">
</div>
<br/>
  $foo-&gt;headers( HTTP::Headers-&gt;new( bar =&gt; 1, baz =&gt; 2 ) );<br/>
  $foo-&gt;headers( [ 'bar', 1, 'baz', 2 ] );<br/>
  $foo-&gt;headers( { bar =&gt; 1, baz =&gt; 2 } );<br/>
<div class="spacer">
</div>
As you can see, careful use of coercions can produce a very open interface for your class, while still retaining the &quot;safety&quot; of your type constraint checks. (1)<div class="spacer">
</div>
Our next coercion shows how we can leverage existing CPAN modules to help implement coercions. In this case we use Params::Coerce.<div class="spacer">
</div>
Once again, we need to declare a class type for our non-Moose URI class:<div class="spacer">
</div>
<br/>
  subtype 'My::Types::URI' =&gt; as class_type('URI');<br/>
<div class="spacer">
</div>
Then we define the coercion:<div class="spacer">
</div>
<br/>
  coerce 'My::Types::URI'<br/>
      =&gt; from 'Object'<br/>
          =&gt; via { $_-&gt;isa('URI')<br/>
                   ? $_<br/>
                   : Params::Coerce::coerce( 'URI', $_ ); }<br/>
      =&gt; from 'Str'<br/>
          =&gt; via { URI-&gt;new( $_, 'http' ) };<br/>
<div class="spacer">
</div>
The first coercion takes any object and makes it a &quot;URI&quot; object. The coercion system isn't that smart, and does not check if the object is already a URI, so we check for that ourselves. If it's not a URI already, we let Params::Coerce do its magic, and we just use its return value.<div class="spacer">
</div>
If Params::Coerce didn't return a URI object (for whatever reason), Moose would throw a type constraint error.<div class="spacer">
</div>
The other coercion takes a string and converts it to a URI. In this case, we are using the coercion to apply a default behavior, where a string is assumed to be an &quot;http&quot; URI.<div class="spacer">
</div>
Finally, we need to make sure our attributes enable coercion.<div class="spacer">
</div>
<br/>
  has 'base' =&gt; ( is =&gt; 'rw', isa =&gt; 'My::Types::URI', coerce =&gt; 1 );<br/>
  has 'uri'  =&gt; ( is =&gt; 'rw', isa =&gt; 'My::Types::URI', coerce =&gt; 1 );<br/>
<div class="spacer">
</div>
Re-using the coercion lets us enforce a consistent API across multiple attributes.</div>
<div class="section">
<h1>CONCLUSION</h1> This recipe showed the use of coercions to create a more flexible and DWIM-y API. Like any powerful feature, we recommend some caution. Sometimes it's better to reject a value than just guess at how to DWIM.<div class="spacer">
</div>
We also showed the use of the &quot;class_type&quot; sugar function as a shortcut for defining a new subtype of &quot;Object&quot;.</div>
<div class="section">
<h1>FOOTNOTES</h1><dl>
<dt>
(1)</dt>
<dd>
This particular example could be safer. Really we only want to coerce an array with an  <i>even</i> number of elements. We could create a new &quot;EvenElementArrayRef&quot; type, and then coerce from that type, as opposed to a plain &quot;ArrayRef&quot;</dd>
</dl>
</div>
<div class="section">
<h1>AUTHOR</h1> Moose is maintained by the Moose Cabal, along with the help of many contributors. See &quot;CABAL&quot; in Moose and &quot;CONTRIBUTORS&quot; in Moose for details.</div>
<div class="section">
<h1>COPYRIGHT AND LICENSE</h1> This software is copyright (c) 2011 by Infinity Interactive, Inc..<div class="spacer">
</div>
This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5 programming language system itself.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-11-17</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

