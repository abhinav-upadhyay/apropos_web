<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Params::Util(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Params::Util(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
Params::Util(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Params::Util - Simple, compact and correct param-checking functions</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
  # Import some functions<br/>
  use Params::Util qw{_SCALAR _HASH _INSTANCE};<br/>
  <br/>
  # If you are lazy, or need a lot of them...<br/>
  use Params::Util ':ALL';<br/>
  <br/>
  sub foo {<br/>
      my $object  = _INSTANCE(shift, 'Foo') or return undef;<br/>
      my $image   = _SCALAR(shift)          or return undef;<br/>
      my $options = _HASH(shift)            or return undef;<br/>
      # etc...<br/>
  }<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> &quot;Params::Util&quot; provides a basic set of importable functions that makes checking parameters a hell of a lot easier<div class="spacer">
</div>
While they can be (and are) used in other contexts, the main point behind this module is that the functions  <b>both</b> Do What You Mean, and Do The Right Thing, so they are most useful when you are getting params passed into your code from someone and/or somewhere else and you can't really trust the quality.<div class="spacer">
</div>
Thus, &quot;Params::Util&quot; is of most use at the edges of your API, where params and data are coming in from outside your code.<div class="spacer">
</div>
The functions provided by &quot;Params::Util&quot; check in the most strictly correct manner known, are documented as thoroughly as possible so their exact behaviour is clear, and heavily tested so make sure they are not fooled by weird data and Really Bad Things.<div class="spacer">
</div>
To use, simply load the module providing the functions you want to use as arguments (as shown in the SYNOPSIS).<div class="spacer">
</div>
To aid in maintainability, &quot;Params::Util&quot; will <b>never</b> export by default.<div class="spacer">
</div>
You must explicitly name the functions you want to export, or use the &quot;:ALL&quot; param to just have it export everything (although this is not recommended if you have any _FOO functions yourself with which future additions to &quot;Params::Util&quot; may clash)</div>
<div class="section">
<h1>FUNCTIONS</h1><div class="subsection">
<h2>_STRING $string</h2> The &quot;_STRING&quot; function is intended to be imported into your package, and provides a convenient way to test to see if a value is a normal non-false string of non-zero length.<div class="spacer">
</div>
Note that this will NOT do anything magic to deal with the special '0' false negative case, but will return it.<div class="spacer">
</div>
<br/>
  # '0' not considered valid data<br/>
  my $name = _STRING(shift) or die &quot;Bad name&quot;;<br/>
  <br/>
  # '0' is considered valid data<br/>
  my $string = _STRING($_[0]) ? shift : die &quot;Bad string&quot;;<br/>
<div class="spacer">
</div>
Please also note that this function expects a normal string. It does not support overloading or other magic techniques to get a string.<div class="spacer">
</div>
Returns the string as a conveince if it is a valid string, or &quot;undef&quot; if not.</div>
<div class="subsection">
<h2>_IDENTIFIER $string</h2> The &quot;_IDENTIFIER&quot; function is intended to be imported into your package, and provides a convenient way to test to see if a value is a string that is a valid Perl identifier.<div class="spacer">
</div>
Returns the string as a convenience if it is a valid identifier, or &quot;undef&quot; if not.</div>
<div class="subsection">
<h2>_CLASS $string</h2> The &quot;_CLASS&quot; function is intended to be imported into your package, and provides a convenient way to test to see if a value is a string that is a valid Perl class.<div class="spacer">
</div>
This function only checks that the format is valid, not that the class is actually loaded. It also assumes &quot;normalised&quot; form, and does not accept class names such as &quot;::Foo&quot; or &quot;D'Oh&quot;.<div class="spacer">
</div>
Returns the string as a convenience if it is a valid class name, or &quot;undef&quot; if not.</div>
<div class="subsection">
<h2>_CLASSISA $string, $class</h2> The &quot;_CLASSISA&quot; function is intended to be imported into your package, and provides a convenient way to test to see if a value is a string that is a particularly class, or a subclass of it.<div class="spacer">
</div>
This function checks that the format is valid and calls the -&gt;isa method on the class name. It does not check that the class is actually loaded.<div class="spacer">
</div>
It also assumes &quot;normalised&quot; form, and does not accept class names such as &quot;::Foo&quot; or &quot;D'Oh&quot;.<div class="spacer">
</div>
Returns the string as a convenience if it is a valid class name, or &quot;undef&quot; if not.</div>
<div class="subsection">
<h2>_SUBCLASS $string, $class</h2> The &quot;_SUBCLASS&quot; function is intended to be imported into your package, and provides a convenient way to test to see if a value is a string that is a subclass of a specified class.<div class="spacer">
</div>
This function checks that the format is valid and calls the -&gt;isa method on the class name. It does not check that the class is actually loaded.<div class="spacer">
</div>
It also assumes &quot;normalised&quot; form, and does not accept class names such as &quot;::Foo&quot; or &quot;D'Oh&quot;.<div class="spacer">
</div>
Returns the string as a convenience if it is a valid class name, or &quot;undef&quot; if not.</div>
<div class="subsection">
<h2>_NUMBER $scalar</h2> The &quot;_NUMBER&quot; function is intended to be imported into your package, and provides a convenient way to test to see if a value is a number. That is, it is defined and perl thinks it's a number.<div class="spacer">
</div>
This function is basically a Params::Util-style wrapper around the Scalar::Util &quot;looks_like_number&quot; function.<div class="spacer">
</div>
Returns the value as a convience, or &quot;undef&quot; if the value is not a number.</div>
<div class="subsection">
<h2>_POSINT $integer</h2> The &quot;_POSINT&quot; function is intended to be imported into your package, and provides a convenient way to test to see if a value is a positive integer (of any length).<div class="spacer">
</div>
Returns the value as a convience, or &quot;undef&quot; if the value is not a positive integer.<div class="spacer">
</div>
The name itself is derived from the XML schema constraint of the same name.</div>
<div class="subsection">
<h2>_NONNEGINT $integer</h2> The &quot;_NONNEGINT&quot; function is intended to be imported into your package, and provides a convenient way to test to see if a value is a non-negative integer (of any length). That is, a positive integer, or zero.<div class="spacer">
</div>
Returns the value as a convience, or &quot;undef&quot; if the value is not a non-negative integer.<div class="spacer">
</div>
As with other tests that may return false values, care should be taken to test via &quot;defined&quot; in boolean validy contexts.<div class="spacer">
</div>
<br/>
  unless ( defined _NONNEGINT($value) ) {<br/>
     die &quot;Invalid value&quot;;<br/>
  }<br/>
<div class="spacer">
</div>
The name itself is derived from the XML schema constraint of the same name.</div>
<div class="subsection">
<h2>_SCALAR \$scalar</h2> The &quot;_SCALAR&quot; function is intended to be imported into your package, and provides a convenient way to test for a raw and unblessed &quot;SCALAR&quot; reference, with content of non-zero length.<div class="spacer">
</div>
For a version that allows zero length &quot;SCALAR&quot; references, see the &quot;_SCALAR0&quot; function.<div class="spacer">
</div>
Returns the &quot;SCALAR&quot; reference itself as a convenience, or &quot;undef&quot; if the value provided is not a &quot;SCALAR&quot; reference.</div>
<div class="subsection">
<h2>_SCALAR0 \$scalar</h2> The &quot;_SCALAR0&quot; function is intended to be imported into your package, and provides a convenient way to test for a raw and unblessed &quot;SCALAR0&quot; reference, allowing content of zero-length.<div class="spacer">
</div>
For a simpler &quot;give me some content&quot; version that requires non-zero length, &quot;_SCALAR&quot; function.<div class="spacer">
</div>
Returns the &quot;SCALAR&quot; reference itself as a convenience, or &quot;undef&quot; if the value provided is not a &quot;SCALAR&quot; reference.</div>
<div class="subsection">
<h2>_ARRAY $value</h2> The &quot;_ARRAY&quot; function is intended to be imported into your package, and provides a convenient way to test for a raw and unblessed &quot;ARRAY&quot; reference containing  <b>at least</b> one element of any kind.<div class="spacer">
</div>
For a more basic form that allows zero length ARRAY references, see the &quot;_ARRAY0&quot; function.<div class="spacer">
</div>
Returns the &quot;ARRAY&quot; reference itself as a convenience, or &quot;undef&quot; if the value provided is not an &quot;ARRAY&quot; reference.</div>
<div class="subsection">
<h2>_ARRAY0 $value</h2> The &quot;_ARRAY0&quot; function is intended to be imported into your package, and provides a convenient way to test for a raw and unblessed &quot;ARRAY&quot; reference, allowing &quot;ARRAY&quot; references that contain no elements.<div class="spacer">
</div>
For a more basic &quot;An array of something&quot; form that also requires at least one element, see the &quot;_ARRAY&quot; function.<div class="spacer">
</div>
Returns the &quot;ARRAY&quot; reference itself as a convenience, or &quot;undef&quot; if the value provided is not an &quot;ARRAY&quot; reference.</div>
<div class="subsection">
<h2>_ARRAYLIKE $value</h2> The &quot;_ARRAYLIKE&quot; function tests whether a given scalar value can respond to array dereferencing.  If it can, the value is returned.  If it cannot, &quot;_ARRAYLIKE&quot; returns &quot;undef&quot;.</div>
<div class="subsection">
<h2>_HASH $value</h2> The &quot;_HASH&quot; function is intended to be imported into your package, and provides a convenient way to test for a raw and unblessed &quot;HASH&quot; reference with at least one entry.<div class="spacer">
</div>
For a version of this function that allows the &quot;HASH&quot; to be empty, see the &quot;_HASH0&quot; function.<div class="spacer">
</div>
Returns the &quot;HASH&quot; reference itself as a convenience, or &quot;undef&quot; if the value provided is not an &quot;HASH&quot; reference.</div>
<div class="subsection">
<h2>_HASH0 $value</h2> The &quot;_HASH0&quot; function is intended to be imported into your package, and provides a convenient way to test for a raw and unblessed &quot;HASH&quot; reference, regardless of the &quot;HASH&quot; content.<div class="spacer">
</div>
For a simpler &quot;A hash of something&quot; version that requires at least one element, see the &quot;_HASH&quot; function.<div class="spacer">
</div>
Returns the &quot;HASH&quot; reference itself as a convenience, or &quot;undef&quot; if the value provided is not an &quot;HASH&quot; reference.</div>
<div class="subsection">
<h2>_HASHLIKE $value</h2> The &quot;_HASHLIKE&quot; function tests whether a given scalar value can respond to hash dereferencing.  If it can, the value is returned.  If it cannot, &quot;_HASHLIKE&quot; returns &quot;undef&quot;.</div>
<div class="subsection">
<h2>_CODE $value</h2> The &quot;_CODE&quot; function is intended to be imported into your package, and provides a convenient way to test for a raw and unblessed &quot;CODE&quot; reference.<div class="spacer">
</div>
Returns the &quot;CODE&quot; reference itself as a convenience, or &quot;undef&quot; if the value provided is not an &quot;CODE&quot; reference.</div>
<div class="subsection">
<h2>_CODELIKE $value</h2> The &quot;_CODELIKE&quot; is the more generic version of &quot;_CODE&quot;. Unlike &quot;_CODE&quot;, which checks for an explicit &quot;CODE&quot; reference, the &quot;_CODELIKE&quot; function also includes things that act like them, such as blessed objects that overload '&amp;{}'.<div class="spacer">
</div>
Please note that in the case of objects overloaded with '&amp;{}', you will almost always end up also testing it in 'bool' context at some stage.<div class="spacer">
</div>
For example:<div class="spacer">
</div>
<br/>
  sub foo {<br/>
      my $code1 = _CODELIKE(shift) or die &quot;No code param provided&quot;;<br/>
      my $code2 = _CODELIKE(shift);<br/>
      if ( $code2 ) {<br/>
           print &quot;Got optional second code param&quot;;<br/>
      }<br/>
  }<br/>
<div class="spacer">
</div>
As such, you will most likely always want to make sure your class has at least the following to allow it to evaluate to true in boolean context.<div class="spacer">
</div>
<br/>
  # Always evaluate to true in boolean context<br/>
  use overload 'bool' =&gt; sub () { 1 };<br/>
<div class="spacer">
</div>
Returns the callable value as a convenience, or &quot;undef&quot; if the value provided is not callable.<div class="spacer">
</div>
Note - This function was formerly known as _CALLABLE but has been renamed for greater symmetry with the other _XXXXLIKE functions.<div class="spacer">
</div>
The use of _CALLABLE has been deprecated. It will continue to work, but with a warning, until end-2006, then will be removed.<div class="spacer">
</div>
I apologise for any inconvenience caused.</div>
<div class="subsection">
<h2>_INVOCANT $value</h2> This routine tests whether the given value is a valid method invocant. This can be either an instance of an object, or a class name.<div class="spacer">
</div>
If so, the value itself is returned.  Otherwise, &quot;_INVOCANT&quot; returns &quot;undef&quot;.</div>
<div class="subsection">
<h2>_INSTANCE $object, $class</h2> The &quot;_INSTANCE&quot; function is intended to be imported into your package, and provides a convenient way to test for an object of a particular class in a strictly correct manner.<div class="spacer">
</div>
Returns the object itself as a convenience, or &quot;undef&quot; if the value provided is not an object of that type.</div>
<div class="subsection">
<h2>_REGEX $value</h2> The &quot;_REGEX&quot; function is intended to be imported into your package, and provides a convenient way to test for a regular expression.<div class="spacer">
</div>
Returns the value itself as a convenience, or &quot;undef&quot; if the value provided is not a regular expression.</div>
<div class="subsection">
<h2>_SET \@array, $class</h2> The &quot;_SET&quot; function is intended to be imported into your package, and provides a convenient way to test for set of at least one object of a particular class in a strictly correct manner.<div class="spacer">
</div>
The set is provided as a reference to an &quot;ARRAY&quot; of objects of the class provided.<div class="spacer">
</div>
For an alternative function that allows zero-length sets, see the &quot;_SET0&quot; function.<div class="spacer">
</div>
Returns the &quot;ARRAY&quot; reference itself as a convenience, or &quot;undef&quot; if the value provided is not a set of that class.</div>
<div class="subsection">
<h2>_SET0 \@array, $class</h2> The &quot;_SET0&quot; function is intended to be imported into your package, and provides a convenient way to test for a set of objects of a particular class in a strictly correct manner, allowing for zero objects.<div class="spacer">
</div>
The set is provided as a reference to an &quot;ARRAY&quot; of objects of the class provided.<div class="spacer">
</div>
For an alternative function that requires at least one object, see the &quot;_SET&quot; function.<div class="spacer">
</div>
Returns the &quot;ARRAY&quot; reference itself as a convenience, or &quot;undef&quot; if the value provided is not a set of that class.</div>
<div class="subsection">
<h2>_HANDLE</h2> The &quot;_HANDLE&quot; function is intended to be imported into your package, and provides a convenient way to test whether or not a single scalar value is a file handle.<div class="spacer">
</div>
Unfortunately, in Perl the definition of a file handle can be a little bit fuzzy, so this function is likely to be somewhat imperfect (at first anyway).<div class="spacer">
</div>
That said, it is implement as well or better than the other file handle detectors in existance (and we stole from the best of them).</div>
<div class="subsection">
<h2>_DRIVER $string</h2><br/>
  sub foo {<br/>
    my $class = _DRIVER(shift, 'My::Driver::Base') or die &quot;Bad driver&quot;;<br/>
    ...<br/>
  }<br/>
<div class="spacer">
</div>
The &quot;_DRIVER&quot; function is intended to be imported into your package, and provides a convenient way to load and validate a driver class.<div class="spacer">
</div>
The most common pattern when taking a driver class as a parameter is to check that the name is a class (i.e. check against _CLASS) and then to load the class (if it exists) and then ensure that the class returns true for the isa method on some base driver name.<div class="spacer">
</div>
Return the value as a convenience, or &quot;undef&quot; if the value is not a class name, the module does not exist, the module does not load, or the class fails the isa test.</div>
</div>
<div class="section">
<h1>TO DO</h1> - Add _CAN to help resolve the UNIVERSAL::can debacle<div class="spacer">
</div>
- Would be even nicer if someone would demonstrate how the hell to build a Module::Install dist of the ::Util dual Perl/XS type. :/<div class="spacer">
</div>
- Implement an assertion-like version of this module, that dies on error.<div class="spacer">
</div>
- Implement a Test:: version of this module, for use in testing</div>
<div class="section">
<h1>SUPPORT</h1> Bugs should be reported via the CPAN bug tracker at<div class="spacer">
</div>
http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Params-Util &lt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Params-Util&gt;<div class="spacer">
</div>
For other issues, contact the author.</div>
<div class="section">
<h1>AUTHOR</h1> Adam Kennedy &lt;adamk@cpan.org&gt;</div>
<div class="section">
<h1>SEE ALSO</h1> Params::Validate</div>
<div class="section">
<h1>COPYRIGHT</h1> Copyright 2005 - 2011 Adam Kennedy.<div class="spacer">
</div>
This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.<div class="spacer">
</div>
The full text of the license can be found in the LICENSE file included with this module.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-04-20</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

