<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
lwpcook(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
lwpcook(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
lwpcook(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> lwpcook - The libwww-perl cookbook</div>
<div class="section">
<h1>DESCRIPTION</h1> This document contain some examples that show typical usage of the libwww-perl library.  You should consult the documentation for the individual modules for more detail.<div class="spacer">
</div>
All examples should be runnable programs. You can, in most cases, test the code sections by piping the program text directly to perl.</div>
<div class="section">
<h1>GET</h1> It is very easy to use this library to just fetch documents from the net.  The LWP::Simple module provides the  <i>get()</i> function that return the document specified by its URL argument:<div class="spacer">
</div>
<br/>
  use LWP::Simple;<br/>
  $doc = get 'http://search.cpan.org/dist/libwww-perl/';<br/>
<div class="spacer">
</div>
or, as a perl one-liner using the <i>getprint()</i> function:<div class="spacer">
</div>
<br/>
  perl -MLWP::Simple -e 'getprint &quot;http://search.cpan.org/dist/libwww-perl/&quot;'<br/>
<div class="spacer">
</div>
or, how about fetching the latest perl by running this command:<div class="spacer">
</div>
<br/>
  perl -MLWP::Simple -e '<br/>
    getstore &quot;ftp://ftp.sunet.se/pub/lang/perl/CPAN/src/latest.tar.gz&quot;,<br/>
             &quot;perl.tar.gz&quot;'<br/>
<div class="spacer">
</div>
You will probably first want to find a CPAN site closer to you by running something like the following command:<div class="spacer">
</div>
<br/>
  perl -MLWP::Simple -e 'getprint &quot;http://www.cpan.org/SITES.html&quot;'<br/>
<div class="spacer">
</div>
Enough of this simple stuff!  The LWP object oriented interface gives you more control over the request sent to the server.  Using this interface you have full control over headers sent and how you want to handle the response returned.<div class="spacer">
</div>
<br/>
  use LWP::UserAgent;<br/>
  $ua = LWP::UserAgent-&gt;new;<br/>
  $ua-&gt;agent(&quot;$0/0.1 &quot; . $ua-&gt;agent);<br/>
  # $ua-&gt;agent(&quot;Mozilla/8.0&quot;) # pretend we are very capable browser<br/>
<br/>
  $req = HTTP::Request-&gt;new(<br/>
     GET =&gt; 'http://search.cpan.org/dist/libwww-perl/');<br/>
  $req-&gt;header('Accept' =&gt; 'text/html');<br/>
<br/>
  # send request<br/>
  $res = $ua-&gt;request($req);<br/>
<br/>
  # check the outcome<br/>
  if ($res-&gt;is_success) {<br/>
     print $res-&gt;decoded_content;<br/>
  }<br/>
  else {<br/>
     print &quot;Error: &quot; . $res-&gt;status_line . &quot;\n&quot;;<br/>
  }<br/>
<div class="spacer">
</div>
The lwp-request program (alias GET) that is distributed with the library can also be used to fetch documents from WWW servers.</div>
<div class="section">
<h1>HEAD</h1> If you just want to check if a document is present (i.e. the URL is valid) try to run code that looks like this:<div class="spacer">
</div>
<br/>
  use LWP::Simple;<br/>
<br/>
  if (head($url)) {<br/>
     # ok document exists<br/>
  }<br/>
<div class="spacer">
</div>
The <i>head()</i> function really returns a list of meta-information about the document.  The first three values of the list returned are the document type, the size of the document, and the age of the document.<div class="spacer">
</div>
More control over the request or access to all header values returned require that you use the object oriented interface described for GET above.  Just s/GET/HEAD/g.</div>
<div class="section">
<h1>POST</h1> There is no simple procedural interface for posting data to a WWW server.  You must use the object oriented interface for this. The most common POST operation is to access a WWW form application:<div class="spacer">
</div>
<br/>
  use LWP::UserAgent;<br/>
  $ua = LWP::UserAgent-&gt;new;<br/>
<br/>
  my $req = HTTP::Request-&gt;new(<br/>
      POST =&gt; 'http://rt.cpan.org/Public/Dist/Display.html');<br/>
  $req-&gt;content_type('application/x-www-form-urlencoded');<br/>
  $req-&gt;content('Status=Active&amp;Name=libwww-perl');<br/>
<br/>
  my $res = $ua-&gt;request($req);<br/>
  print $res-&gt;as_string;<br/>
<div class="spacer">
</div>
Lazy people use the HTTP::Request::Common module to set up a suitable POST request message (it handles all the escaping issues) and has a suitable default for the content_type:<div class="spacer">
</div>
<br/>
  use HTTP::Request::Common qw(POST);<br/>
  use LWP::UserAgent;<br/>
  $ua = LWP::UserAgent-&gt;new;<br/>
<br/>
  my $req = POST 'http://rt.cpan.org/Public/Dist/Display.html',<br/>
                [ Status =&gt; 'Active', Name =&gt; 'libwww-perl' ];<br/>
<br/>
  print $ua-&gt;request($req)-&gt;as_string;<br/>
<div class="spacer">
</div>
The lwp-request program (alias POST) that is distributed with the library can also be used for posting data.</div>
<div class="section">
<h1>PROXIES</h1> Some sites use proxies to go through fire wall machines, or just as cache in order to improve performance.  Proxies can also be used for accessing resources through protocols not supported directly (or supported badly :-) by the libwww-perl library.<div class="spacer">
</div>
You should initialize your proxy setting before you start sending requests:<div class="spacer">
</div>
<br/>
  use LWP::UserAgent;<br/>
  $ua = LWP::UserAgent-&gt;new;<br/>
  $ua-&gt;env_proxy; # initialize from environment variables<br/>
  # or<br/>
  $ua-&gt;proxy(ftp  =&gt; 'http://proxy.myorg.com');<br/>
  $ua-&gt;proxy(wais =&gt; 'http://proxy.myorg.com');<br/>
  $ua-&gt;no_proxy(qw(no se fi));<br/>
<br/>
  my $req = HTTP::Request-&gt;new(GET =&gt; 'wais://xxx.com/');<br/>
  print $ua-&gt;request($req)-&gt;as_string;<br/>
<div class="spacer">
</div>
The LWP::Simple interface will call <i>env_proxy()</i> for you automatically. Applications that use the $ua-&gt; <i>env_proxy()</i> method will normally not use the $ua-&gt; <i>proxy()</i> and $ua-&gt;<i>no_proxy()</i> methods.<div class="spacer">
</div>
Some proxies also require that you send it a username/password in order to let requests through.  You should be able to add the required header, with something like this:<div class="spacer">
</div>
<br/>
 use LWP::UserAgent;<br/>
<br/>
 $ua = LWP::UserAgent-&gt;new;<br/>
 $ua-&gt;proxy(['http', 'ftp'] =&gt; 'http://username:password@proxy.myorg.com');<br/>
<br/>
 $req = HTTP::Request-&gt;new('GET',&quot;http://www.perl.com&quot;);<br/>
<br/>
 $res = $ua-&gt;request($req);<br/>
 print $res-&gt;decoded_content if $res-&gt;is_success;<br/>
<div class="spacer">
</div>
Replace &quot;proxy.myorg.com&quot;, &quot;username&quot; and &quot;password&quot; with something suitable for your site.</div>
<div class="section">
<h1>ACCESS TO PROTECTED DOCUMENTS</h1> Documents protected by basic authorization can easily be accessed like this:<div class="spacer">
</div>
<br/>
  use LWP::UserAgent;<br/>
  $ua = LWP::UserAgent-&gt;new;<br/>
  $req = HTTP::Request-&gt;new(GET =&gt; 'http://www.linpro.no/secret/');<br/>
  $req-&gt;authorization_basic('aas', 'mypassword');<br/>
  print $ua-&gt;request($req)-&gt;as_string;<br/>
<div class="spacer">
</div>
The other alternative is to provide a subclass of <i>LWP::UserAgent</i> that overrides the  <i>get_basic_credentials()</i> method. Study the <i>lwp-request</i> program for an example of this.</div>
<div class="section">
<h1>COOKIES</h1> Some sites like to play games with cookies.  By default LWP ignores cookies provided by the servers it visits.  LWP will collect cookies and respond to cookie requests if you set up a cookie jar.<div class="spacer">
</div>
<br/>
  use LWP::UserAgent;<br/>
  use HTTP::Cookies;<br/>
<br/>
  $ua = LWP::UserAgent-&gt;new;<br/>
  $ua-&gt;cookie_jar(HTTP::Cookies-&gt;new(file =&gt; &quot;lwpcookies.txt&quot;,<br/>
                                     autosave =&gt; 1));<br/>
<br/>
  # and then send requests just as you used to do<br/>
  $res = $ua-&gt;request(HTTP::Request-&gt;new(GET =&gt; &quot;http://no.yahoo.com/&quot;));<br/>
  print $res-&gt;status_line, &quot;\n&quot;;<br/>
<div class="spacer">
</div>
As you visit sites that send you cookies to keep, then the file  <i>lwpcookies.txt&quot;</i> will grow.</div>
<div class="section">
<h1>HTTPS</h1> URLs with https scheme are accessed in exactly the same way as with http scheme, provided that an SSL interface module for LWP has been properly installed (see the  <i>README.SSL</i> file found in the libwww-perl distribution for more details).  If no SSL interface is installed for LWP to use, then you will get &quot;501 Protocol scheme 'https' is not supported&quot; errors when accessing such URLs.<div class="spacer">
</div>
Here's an example of fetching and printing a WWW page using SSL:<div class="spacer">
</div>
<br/>
  use LWP::UserAgent;<br/>
<br/>
  my $ua = LWP::UserAgent-&gt;new;<br/>
  my $req = HTTP::Request-&gt;new(GET =&gt; 'https://www.helsinki.fi/');<br/>
  my $res = $ua-&gt;request($req);<br/>
  if ($res-&gt;is_success) {<br/>
      print $res-&gt;as_string;<br/>
  }<br/>
  else {<br/>
      print &quot;Failed: &quot;, $res-&gt;status_line, &quot;\n&quot;;<br/>
  }<br/>
</div>
<div class="section">
<h1>MIRRORING</h1> If you want to mirror documents from a WWW server, then try to run code similar to this at regular intervals:<div class="spacer">
</div>
<br/>
  use LWP::Simple;<br/>
<br/>
  %mirrors = (<br/>
     'http://www.sn.no/'                       =&gt; 'sn.html',<br/>
     'http://www.perl.com/'                    =&gt; 'perl.html',<br/>
     'http://search.cpan.org/distlibwww-perl/' =&gt; 'lwp.html',<br/>
     'gopher://gopher.sn.no/'                  =&gt; 'gopher.html',<br/>
  );<br/>
<br/>
  while (($url, $localfile) = each(%mirrors)) {<br/>
     mirror($url, $localfile);<br/>
  }<br/>
<div class="spacer">
</div>
Or, as a perl one-liner:<div class="spacer">
</div>
<br/>
  perl -MLWP::Simple -e 'mirror(&quot;http://www.perl.com/&quot;, &quot;perl.html&quot;)';<br/>
<div class="spacer">
</div>
The document will not be transferred unless it has been updated.</div>
<div class="section">
<h1>LARGE DOCUMENTS</h1> If the document you want to fetch is too large to be kept in memory, then you have two alternatives.  You can instruct the library to write the document content to a file (second $ua-&gt; <i>request()</i> argument is a file name):<div class="spacer">
</div>
<br/>
  use LWP::UserAgent;<br/>
  $ua = LWP::UserAgent-&gt;new;<br/>
<br/>
  my $req = HTTP::Request-&gt;new(GET =&gt;<br/>
     'http://www.cpan.org/authors/Gisle_Aas/libwww-perl-6.02.tar.gz');<br/>
  $res = $ua-&gt;request($req, &quot;libwww-perl.tar.gz&quot;);<br/>
  if ($res-&gt;is_success) {<br/>
     print &quot;ok\n&quot;;<br/>
  }<br/>
  else {<br/>
     print $res-&gt;status_line, &quot;\n&quot;;<br/>
  }<br/>
<div class="spacer">
</div>
Or you can process the document as it arrives (second $ua-&gt;<i>request()</i> argument is a code reference):<div class="spacer">
</div>
<br/>
  use LWP::UserAgent;<br/>
  $ua = LWP::UserAgent-&gt;new;<br/>
  $URL = 'ftp://ftp.unit.no/pub/rfc/rfc-index.txt';<br/>
<br/>
  my $expected_length;<br/>
  my $bytes_received = 0;<br/>
  my $res =<br/>
     $ua-&gt;request(HTTP::Request-&gt;new(GET =&gt; $URL),<br/>
               sub {<br/>
                   my($chunk, $res) = @_;<br/>
                   $bytes_received += length($chunk);<br/>
                   unless (defined $expected_length) {<br/>
                      $expected_length = $res-&gt;content_length || 0;<br/>
                   }<br/>
                   if ($expected_length) {<br/>
                        printf STDERR &quot;%d%% - &quot;,<br/>
                                  100 * $bytes_received / $expected_length;<br/>
                   }<br/>
                   print STDERR &quot;$bytes_received bytes received\n&quot;;<br/>
<br/>
                   # XXX Should really do something with the chunk itself<br/>
                   # print $chunk;<br/>
               });<br/>
   print $res-&gt;status_line, &quot;\n&quot;;<br/>
</div>
<div class="section">
<h1>COPYRIGHT</h1> Copyright 1996-2001, Gisle Aas<div class="spacer">
</div>
This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-05-01</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

