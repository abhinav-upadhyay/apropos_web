<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
LWP::UserAgent(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
LWP::UserAgent(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
LWP::UserAgent(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> LWP::UserAgent - Web user agent class</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
 require LWP::UserAgent;<br/>
 <br/>
 my $ua = LWP::UserAgent-&gt;new;<br/>
 $ua-&gt;timeout(10);<br/>
 $ua-&gt;env_proxy;<br/>
 <br/>
 my $response = $ua-&gt;get('http://search.cpan.org/');<br/>
 <br/>
 if ($response-&gt;is_success) {<br/>
     print $response-&gt;decoded_content;  # or whatever<br/>
 }<br/>
 else {<br/>
     die $response-&gt;status_line;<br/>
 }<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> The &quot;LWP::UserAgent&quot; is a class implementing a web user agent. &quot;LWP::UserAgent&quot; objects can be used to dispatch web requests.<div class="spacer">
</div>
In normal use the application creates an &quot;LWP::UserAgent&quot; object, and then configures it with values for timeouts, proxies, name, etc. It then creates an instance of &quot;HTTP::Request&quot; for the request that needs to be performed. This request is then passed to one of the request method the UserAgent, which dispatches it using the relevant protocol, and returns a &quot;HTTP::Response&quot; object.  There are convenience methods for sending the most common request types:  <i>get()</i>,  <i>head()</i> and <i>post()</i>.  When using these methods then the creation of the request object is hidden as shown in the synopsis above.<div class="spacer">
</div>
The basic approach of the library is to use HTTP style communication for all protocol schemes.  This means that you will construct &quot;HTTP::Request&quot; objects and receive &quot;HTTP::Response&quot; objects even for non-HTTP resources like  <i>gopher</i> and <i>ftp</i>.  In order to achieve even more similarity to HTTP style communications, gopher menus and file directories are converted to HTML documents.</div>
<div class="section">
<h1>CONSTRUCTOR METHODS</h1> The following constructor methods are available:<dl>
<dt>
$ua = LWP::UserAgent-&gt;new( %options )</dt>
<dd>
This method constructs a new &quot;LWP::UserAgent&quot; object and returns it. Key/value pair arguments may be provided to set up the initial state. The following options correspond to attribute methods described below:<div style="height: 1.00em;">
&#160;</div>
<br/>
   KEY                     DEFAULT<br/>
   -----------             --------------------<br/>
   agent                   &quot;libwww-perl/#.###&quot;<br/>
   from                    undef<br/>
   conn_cache              undef<br/>
   cookie_jar              undef<br/>
   default_headers         HTTP::Headers-&gt;new<br/>
   local_address           undef<br/>
   ssl_opts                { verify_hostname =&gt; 1 }<br/>
   max_size                undef<br/>
   max_redirect            7<br/>
   parse_head              1<br/>
   protocols_allowed       undef<br/>
   protocols_forbidden     undef<br/>
   requests_redirectable   ['GET', 'HEAD']<br/>
   timeout                 180<br/>
<div style="height: 1.00em;">
&#160;</div>
The following additional options are also accepted: If the &quot;env_proxy&quot; option is passed in with a TRUE value, then proxy settings are read from environment variables (see  <i>env_proxy()</i> method below).  If &quot;env_proxy&quot; isn't provided the &quot;PERL_LWP_ENV_PROXY&quot; envirionment variable controls if  <i>env_proxy()</i> is called during initalization.  If the &quot;keep_alive&quot; option is passed in, then a &quot;LWP::ConnCache&quot; is set up (see  <i>conn_cache()</i> method below).  The &quot;keep_alive&quot; value is passed on as the &quot;total_capacity&quot; for the connection cache.</dd>
</dl>
<dl>
<dt>
$ua-&gt;clone</dt>
<dd>
Returns a copy of the LWP::UserAgent object.</dd>
</dl>
</div>
<div class="section">
<h1>ATTRIBUTES</h1> The settings of the configuration attributes modify the behaviour of the &quot;LWP::UserAgent&quot; when it dispatches requests.  Most of these can also be initialized by options passed to the constructor method.<div class="spacer">
</div>
The following attribute methods are provided.  The attribute value is left unchanged if no argument is given.  The return value from each method is the old attribute value.<dl>
<dt>
$ua-&gt;agent</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$ua-&gt;agent( $product_id )</dt>
<dd>
Get/set the product token that is used to identify the user agent on the network.  The agent value is sent as the &quot;User-Agent&quot; header in the requests.  The default is the string returned by the  <i>_agent()</i> method (see below).<div style="height: 1.00em;">
&#160;</div>
If the $product_id ends with space then the <i>_agent()</i> string is appended to it.<div style="height: 1.00em;">
&#160;</div>
The user agent string should be one or more simple product identifiers with an optional version number separated by the &quot;/&quot; character. Examples are:<div style="height: 1.00em;">
&#160;</div>
<br/>
  $ua-&gt;agent('Checkbot/0.4 ' . $ua-&gt;_agent);<br/>
  $ua-&gt;agent('Checkbot/0.4 ');    # same as above<br/>
  $ua-&gt;agent('Mozilla/5.0');<br/>
  $ua-&gt;agent(&quot;&quot;);                 # don't identify<br/>
</dd>
</dl>
<dl>
<dt>
$ua-&gt;_agent</dt>
<dd>
Returns the default agent identifier.  This is a string of the form &quot;libwww-perl/#.###&quot;, where &quot;#.###&quot; is substituted with the version number of this library.</dd>
</dl>
<dl>
<dt>
$ua-&gt;from</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$ua-&gt;from( $email_address )</dt>
<dd>
Get/set the e-mail address for the human user who controls the requesting user agent.  The address should be machine-usable, as defined in RFC 822.  The &quot;from&quot; value is send as the &quot;From&quot; header in the requests.  Example:<div style="height: 1.00em;">
&#160;</div>
<br/>
  $ua-&gt;from('gaas@cpan.org');<br/>
<div style="height: 1.00em;">
&#160;</div>
The default is to not send a &quot;From&quot; header.  See the <i>default_headers()</i> method for the more general interface that allow any header to be defaulted.</dd>
</dl>
<dl>
<dt>
$ua-&gt;cookie_jar</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$ua-&gt;cookie_jar( $cookie_jar_obj )</dt>
<dd>
Get/set the cookie jar object to use.  The only requirement is that the cookie jar object must implement the extract_cookies($request) and add_cookie_header($response) methods.  These methods will then be invoked by the user agent as requests are sent and responses are received.  Normally this will be a &quot;HTTP::Cookies&quot; object or some subclass.<div style="height: 1.00em;">
&#160;</div>
The default is to have no cookie_jar, i.e. never automatically add &quot;Cookie&quot; headers to the requests.<div style="height: 1.00em;">
&#160;</div>
Shortcut: If a reference to a plain hash is passed in as the $cookie_jar_object, then it is replaced with an instance of &quot;HTTP::Cookies&quot; that is initialized based on the hash.  This form also automatically loads the &quot;HTTP::Cookies&quot; module.  It means that:<div style="height: 1.00em;">
&#160;</div>
<br/>
  $ua-&gt;cookie_jar({ file =&gt; &quot;$ENV{HOME}/.cookies.txt&quot; });<br/>
<div style="height: 1.00em;">
&#160;</div>
is really just a shortcut for:<div style="height: 1.00em;">
&#160;</div>
<br/>
  require HTTP::Cookies;<br/>
  $ua-&gt;cookie_jar(HTTP::Cookies-&gt;new(file =&gt; &quot;$ENV{HOME}/.cookies.txt&quot;));<br/>
</dd>
</dl>
<dl>
<dt>
$ua-&gt;default_headers</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$ua-&gt;default_headers( $headers_obj )</dt>
<dd>
Get/set the headers object that will provide default header values for any requests sent.  By default this will be an empty &quot;HTTP::Headers&quot; object.</dd>
</dl>
<dl>
<dt>
$ua-&gt;default_header( $field )</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$ua-&gt;default_header( $field =&gt; $value )</dt>
<dd>
This is just a short-cut for $ua-&gt;default_headers-&gt;header( $field =&gt; $value ). Example:<div style="height: 1.00em;">
&#160;</div>
<br/>
  $ua-&gt;default_header('Accept-Encoding' =&gt; scalar HTTP::Message::decodable());<br/>
  $ua-&gt;default_header('Accept-Language' =&gt; &quot;no, en&quot;);<br/>
</dd>
</dl>
<dl>
<dt>
$ua-&gt;conn_cache</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$ua-&gt;conn_cache( $cache_obj )</dt>
<dd>
Get/set the &quot;LWP::ConnCache&quot; object to use.  See LWP::ConnCache for details.</dd>
</dl>
<dl>
<dt>
$ua-&gt;credentials( $netloc, $realm )</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$ua-&gt;credentials( $netloc, $realm, $uname, $pass )</dt>
<dd>
Get/set the user name and password to be used for a realm.<div style="height: 1.00em;">
&#160;</div>
The $netloc is a string of the form &quot;&lt;host&gt;:&lt;port&gt;&quot;.  The username and password will only be passed to this server.  Example:<div style="height: 1.00em;">
&#160;</div>
<br/>
  $ua-&gt;credentials(&quot;www.example.com:80&quot;, &quot;Some Realm&quot;, &quot;foo&quot;, &quot;secret&quot;);<br/>
</dd>
</dl>
<dl>
<dt>
$ua-&gt;local_address</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$ua-&gt;local_address( $address )</dt>
<dd>
Get/set the local interface to bind to for network connections.  The interface can be specified as a hostname or an IP address.  This value is passed as the &quot;LocalAddr&quot; argument to IO::Socket::INET.</dd>
</dl>
<dl>
<dt>
$ua-&gt;max_size</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$ua-&gt;max_size( $bytes )</dt>
<dd>
Get/set the size limit for response content.  The default is &quot;undef&quot;, which means that there is no limit.  If the returned response content is only partial, because the size limit was exceeded, then a &quot;Client-Aborted&quot; header will be added to the response.  The content might end up longer than &quot;max_size&quot; as we abort once appending a chunk of data makes the length exceed the limit.  The &quot;Content-Length&quot; header, if present, will indicate the length of the full content and will normally not be the same as &quot;length($res-&gt;content)&quot;.</dd>
</dl>
<dl>
<dt>
$ua-&gt;max_redirect</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$ua-&gt;max_redirect( $n )</dt>
<dd>
This reads or sets the object's limit of how many times it will obey redirection responses in a given request cycle.<div style="height: 1.00em;">
&#160;</div>
By default, the value is 7. This means that if you call <i>request()</i> method and the response is a redirect elsewhere which is in turn a redirect, and so on seven times, then LWP gives up after that seventh request.</dd>
</dl>
<dl>
<dt>
$ua-&gt;parse_head</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$ua-&gt;parse_head( $boolean )</dt>
<dd>
Get/set a value indicating whether we should initialize response headers from the &lt;head&gt; section of HTML documents. The default is TRUE.  Do not turn this off, unless you know what you are doing.</dd>
</dl>
<dl>
<dt>
$ua-&gt;protocols_allowed</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$ua-&gt;protocols_allowed( \@protocols )</dt>
<dd>
This reads (or sets) this user agent's list of protocols that the request methods will exclusively allow.  The protocol names are case insensitive.<div style="height: 1.00em;">
&#160;</div>
For example: &quot;$ua-&gt;protocols_allowed( [ 'http', 'https'] );&quot; means that this user agent will  <i>allow only</i> those protocols, and attempts to use this user agent to access URLs with any other schemes (like &quot;ftp://...&quot;) will result in a 500 error.<div style="height: 1.00em;">
&#160;</div>
To delete the list, call: &quot;$ua-&gt;protocols_allowed(undef)&quot;<div style="height: 1.00em;">
&#160;</div>
By default, an object has neither a &quot;protocols_allowed&quot; list, nor a &quot;protocols_forbidden&quot; list.<div style="height: 1.00em;">
&#160;</div>
Note that having a &quot;protocols_allowed&quot; list causes any &quot;protocols_forbidden&quot; list to be ignored.</dd>
</dl>
<dl>
<dt>
$ua-&gt;protocols_forbidden</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$ua-&gt;protocols_forbidden( \@protocols )</dt>
<dd>
This reads (or sets) this user agent's list of protocols that the request method will  <i>not</i> allow. The protocol names are case insensitive.<div style="height: 1.00em;">
&#160;</div>
For example: &quot;$ua-&gt;protocols_forbidden( [ 'file', 'mailto'] );&quot; means that this user agent will  <i>not</i> allow those protocols, and attempts to use this user agent to access URLs with those schemes will result in a 500 error.<div style="height: 1.00em;">
&#160;</div>
To delete the list, call: &quot;$ua-&gt;protocols_forbidden(undef)&quot;</dd>
</dl>
<dl>
<dt>
$ua-&gt;requests_redirectable</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$ua-&gt;requests_redirectable( \@requests )</dt>
<dd>
This reads or sets the object's list of request names that &quot;$ua-&gt;redirect_ok(...)&quot; will allow redirection for.  By default, this is &quot;['GET', 'HEAD']&quot;, as per RFC 2616.  To change to include 'POST', consider:<div style="height: 1.00em;">
&#160;</div>
<br/>
   push @{ $ua-&gt;requests_redirectable }, 'POST';<br/>
</dd>
</dl>
<dl>
<dt>
$ua-&gt;show_progress</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$ua-&gt;show_progress( $boolean )</dt>
<dd>
Get/set a value indicating whether a progress bar should be displayed on on the terminal as requests are processed. The default is FALSE.</dd>
</dl>
<dl>
<dt>
$ua-&gt;timeout</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$ua-&gt;timeout( $secs )</dt>
<dd>
Get/set the timeout value in seconds. The default <i>timeout()</i> value is 180 seconds, i.e. 3 minutes.<div style="height: 1.00em;">
&#160;</div>
The requests is aborted if no activity on the connection to the server is observed for &quot;timeout&quot; seconds.  This means that the time it takes for the complete transaction and the  <i>request()</i> method to actually return might be longer.</dd>
</dl>
<dl>
<dt>
$ua-&gt;ssl_opts</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$ua-&gt;ssl_opts( $key )</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$ua-&gt;ssl_opts( $key =&gt; $value )</dt>
<dd>
Get/set the options for SSL connections.  Without argument return the list of options keys currently set.  With a single argument return the current value for the given option.  With 2 arguments set the option value and return the old.  Setting an option to the value &quot;undef&quot; removes this option.<div style="height: 1.00em;">
&#160;</div>
The options that LWP relates to are:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
&quot;verify_hostname&quot; =&gt; $bool</dt>
<dd>
When TRUE LWP will for secure protocol schemes ensure it connects to servers that have a valid certificate matching the expected hostname.  If FALSE no checks are made and you can't be sure that you communicate with the expected peer. The no checks behaviour was the default for libwww-perl-5.837 and earlier releases.<div style="height: 1.00em;">
&#160;</div>
This option is initialized from the PERL_LWP_SSL_VERIFY_HOSTNAME environment variable.  If this envirionment variable isn't set; then &quot;verify_hostname&quot; defaults to 1.</dd>
</dl>
<dl>
<dt>
&quot;SSL_ca_file&quot; =&gt; $path</dt>
<dd>
The path to a file containing Certificate Authority certificates. A default setting for this option is provided by checking the environment variables &quot;PERL_LWP_SSL_CA_FILE&quot; and &quot;HTTPS_CA_FILE&quot; in order.</dd>
</dl>
<dl>
<dt>
&quot;SSL_ca_path&quot; =&gt; $path</dt>
<dd>
The path to a directory containing files containing Certificate Authority certificates. A default setting for this option is provided by checking the environment variables &quot;PERL_LWP_SSL_CA_PATH&quot; and &quot;HTTPS_CA_DIR&quot; in order.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">
&#160;</div>
Other options can be set and are processed directly by the SSL Socket implementation in use.  See IO::Socket::SSL or Net::SSL for details.<div style="height: 1.00em;">
&#160;</div>
The libwww-perl core no longer bundles protocol plugins for SSL.  You will need to install LWP::Protocol::https separately to enable support for processing https-URLs.</div>
<div class="subsection">
<h2>Proxy attributes</h2> The following methods set up when requests should be passed via a proxy server.<dl>
<dt>
$ua-&gt;proxy(\@schemes, $proxy_url)</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$ua-&gt;proxy($scheme, $proxy_url)</dt>
<dd>
Set/retrieve proxy URL for a scheme:<div style="height: 1.00em;">
&#160;</div>
<br/>
 $ua-&gt;proxy(['http', 'ftp'], 'http://proxy.sn.no:8001/');<br/>
 $ua-&gt;proxy('gopher', 'http://proxy.sn.no:8001/');<br/>
<div style="height: 1.00em;">
&#160;</div>
The first form specifies that the URL is to be used for proxying of access methods listed in the list in the first method argument, i.e. 'http' and 'ftp'.<div style="height: 1.00em;">
&#160;</div>
The second form shows a shorthand form for specifying proxy URL for a single access scheme.</dd>
</dl>
<dl>
<dt>
$ua-&gt;no_proxy( $domain, ... )</dt>
<dd>
Do not proxy requests to the given domains.  Calling no_proxy without any domains clears the list of domains. Eg:<div style="height: 1.00em;">
&#160;</div>
<br/>
 $ua-&gt;no_proxy('localhost', 'example.com');<br/>
</dd>
</dl>
<dl>
<dt>
$ua-&gt;env_proxy</dt>
<dd>
Load proxy settings from *_proxy environment variables.  You might specify proxies like this (sh-syntax):<div style="height: 1.00em;">
&#160;</div>
<br/>
  gopher_proxy=http://proxy.my.place/<br/>
  wais_proxy=http://proxy.my.place/<br/>
  no_proxy=&quot;localhost,example.com&quot;<br/>
  export gopher_proxy wais_proxy no_proxy<br/>
<div style="height: 1.00em;">
&#160;</div>
csh or tcsh users should use the &quot;setenv&quot; command to define these environment variables.<div style="height: 1.00em;">
&#160;</div>
On systems with case insensitive environment variables there exists a name clash between the CGI environment variables and the &quot;HTTP_PROXY&quot; environment variable normally picked up by  <i>env_proxy()</i>.  Because of this &quot;HTTP_PROXY&quot; is not honored for CGI scripts.  The &quot;CGI_HTTP_PROXY&quot; environment variable can be used instead.</dd>
</dl>
</div>
<div class="subsection">
<h2>Handlers</h2> Handlers are code that injected at various phases during the processing of requests.  The following methods are provided to manage the active handlers:<dl>
<dt>
$ua-&gt;add_handler( $phase =&gt; \&amp;cb, %matchspec )</dt>
<dd>
Add handler to be invoked in the given processing phase.  For how to specify %matchspec see &quot;Matching&quot; in HTTP::Config.<div style="height: 1.00em;">
&#160;</div>
The possible values $phase and the corresponding callback signatures are:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
request_preprepare =&gt; sub { my($request, $ua, $h) = @_; ... }</dt>
<dd>
The handler is called before the &quot;request_prepare&quot; and other standard initialization of of the request.  This can be used to set up headers and attributes that the &quot;request_prepare&quot; handler depends on.  Proxy initialization should take place here; but in general don't register handlers for this phase.</dd>
</dl>
<dl>
<dt>
request_prepare =&gt; sub { my($request, $ua, $h) = @_; ... }</dt>
<dd>
The handler is called before the request is sent and can modify the request any way it see fit.  This can for instance be used to add certain headers to specific requests.<div style="height: 1.00em;">
&#160;</div>
The method can assign a new request object to $_[0] to replace the request that is sent fully.<div style="height: 1.00em;">
&#160;</div>
The return value from the callback is ignored.  If an exception is raised it will abort the request and make the request method return a &quot;400 Bad request&quot; response.</dd>
</dl>
<dl>
<dt>
request_send =&gt; sub { my($request, $ua, $h) = @_; ... }</dt>
<dd>
This handler gets a chance of handling requests before they're sent to the protocol handlers.  It should return an HTTP::Response object if it wishes to terminate the processing; otherwise it should return nothing.<div style="height: 1.00em;">
&#160;</div>
The &quot;response_header&quot; and &quot;response_data&quot; handlers will not be invoked for this response, but the &quot;response_done&quot; will be.</dd>
</dl>
<dl>
<dt>
response_header =&gt; sub { my($response, $ua, $h) = @_; ... }</dt>
<dd>
This handler is called right after the response headers have been received, but before any content data.  The handler might set up handlers for data and might croak to abort the request.<div style="height: 1.00em;">
&#160;</div>
The handler might set the $response-&gt;{default_add_content} value to control if any received data should be added to the response object directly.  This will initially be false if the $ua-&gt; <i>request()</i> method was called with a $content_file or $content_cb argument; otherwise true.</dd>
</dl>
<dl>
<dt>
response_data =&gt; sub { my($response, $ua, $h, $data) = @_; ... }</dt>
<dd>
This handler is called for each chunk of data received for the response.  The handler might croak to abort the request.<div style="height: 1.00em;">
&#160;</div>
This handler needs to return a TRUE value to be called again for subsequent chunks for the same request.</dd>
</dl>
<dl>
<dt>
response_done =&gt; sub { my($response, $ua, $h) = @_; ... }</dt>
<dd>
The handler is called after the response has been fully received, but before any redirect handling is attempted.  The handler can be used to extract information or modify the response.</dd>
</dl>
<dl>
<dt>
response_redirect =&gt; sub { my($response, $ua, $h) = @_; ... }</dt>
<dd>
The handler is called in $ua-&gt;request after &quot;response_done&quot;.  If the handler returns an HTTP::Request object we'll start over with processing this request instead.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
</div>
<dl>
<dt>
$ua-&gt;remove_handler( undef, %matchspec )</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$ua-&gt;remove_handler( $phase, %matchspec )</dt>
<dd>
Remove handlers that match the given %matchspec.  If $phase is not provided remove handlers from all phases.<div style="height: 1.00em;">
&#160;</div>
Be careful as calling this function with %matchspec that is not not specific enough can remove handlers not owned by you.  It's probably better to use the  <i>set_my_handler()</i> method instead.<div style="height: 1.00em;">
&#160;</div>
The removed handlers are returned.</dd>
</dl>
<dl>
<dt>
$ua-&gt;set_my_handler( $phase, $cb, %matchspec )</dt>
<dd>
Set handlers private to the executing subroutine.  Works by defaulting an &quot;owner&quot; field to the %matchspec that holds the name of the called subroutine.  You might pass an explicit &quot;owner&quot; to override this.<div style="height: 1.00em;">
&#160;</div>
If $cb is passed as &quot;undef&quot;, remove the handler.</dd>
</dl>
<dl>
<dt>
$ua-&gt;get_my_handler( $phase, %matchspec )</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$ua-&gt;get_my_handler( $phase, %matchspec, $init )</dt>
<dd>
Will retrieve the matching handler as hash ref.<div style="height: 1.00em;">
&#160;</div>
If $init is passed passed as a TRUE value, create and add the handler if it's not found.  If $init is a subroutine reference, then it's called with the created handler hash as argument.  This sub might populate the hash with extra fields; especially the callback.  If $init is a hash reference, merge the hashes.</dd>
</dl>
<dl>
<dt>
$ua-&gt;handlers( $phase, $request )</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$ua-&gt;handlers( $phase, $response )</dt>
<dd>
Returns the handlers that apply to the given request or response at the given processing phase.</dd>
</dl>
</div>
</div>
<div class="section">
<h1>REQUEST METHODS</h1> The methods described in this section are used to dispatch requests via the user agent.  The following request methods are provided:<dl>
<dt>
$ua-&gt;get( $url )</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$ua-&gt;get( $url , $field_name =&gt; $value, ... )</dt>
<dd>
This method will dispatch a &quot;GET&quot; request on the given $url.  Further arguments can be given to initialize the headers of the request. These are given as separate name/value pairs.  The return value is a response object.  See HTTP::Response for a description of the interface it provides.<div style="height: 1.00em;">
&#160;</div>
There will still be a response object returned when LWP can't connect to the server specified in the URL or when other failures in protocol handlers occur. These internal responses use the standard HTTP status codes, so the responses can't be differentiated by testing the response status code alone.  Error responses that LWP generates internally will have the &quot;Client-Warning&quot; header set to the value &quot;Internal response&quot;.  If you need to differentiate these internal responses from responses that a remote server actually generates, you need to test this header value.<div style="height: 1.00em;">
&#160;</div>
Fields names that start with &quot;:&quot; are special.  These will not initialize headers of the request but will determine how the response content is treated.  The following special field names are recognized:<div style="height: 1.00em;">
&#160;</div>
<br/>
    :content_file   =&gt; $filename<br/>
    :content_cb     =&gt; \&amp;callback<br/>
    :read_size_hint =&gt; $bytes<br/>
<div style="height: 1.00em;">
&#160;</div>
If a $filename is provided with the &quot;:content_file&quot; option, then the response content will be saved here instead of in the response object.  If a callback is provided with the &quot;:content_cb&quot; option then this function will be called for each chunk of the response content as it is received from the server.  If neither of these options are given, then the response content will accumulate in the response object itself.  This might not be suitable for very large response bodies.  Only one of &quot;:content_file&quot; or &quot;:content_cb&quot; can be specified.  The content of unsuccessful responses will always accumulate in the response object itself, regardless of the &quot;:content_file&quot; or &quot;:content_cb&quot; options passed in.<div style="height: 1.00em;">
&#160;</div>
The &quot;:read_size_hint&quot; option is passed to the protocol module which will try to read data from the server in chunks of this size.  A smaller value for the &quot;:read_size_hint&quot; will result in a higher number of callback invocations.<div style="height: 1.00em;">
&#160;</div>
The callback function is called with 3 arguments: a chunk of data, a reference to the response object, and a reference to the protocol object.  The callback can abort the request by invoking  <i>die()</i>.  The exception message will show up as the &quot;X-Died&quot; header field in the response returned by the  <i>get()</i> function.</dd>
</dl>
<dl>
<dt>
$ua-&gt;head( $url )</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$ua-&gt;head( $url , $field_name =&gt; $value, ... )</dt>
<dd>
This method will dispatch a &quot;HEAD&quot; request on the given $url. Otherwise it works like the  <i>get()</i> method described above.</dd>
</dl>
<dl>
<dt>
$ua-&gt;post( $url, \%form )</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$ua-&gt;post( $url, \@form )</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$ua-&gt;post( $url, \%form, $field_name =&gt; $value, ... )</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$ua-&gt;post( $url, $field_name =&gt; $value,... Content =&gt; \%form )</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$ua-&gt;post( $url, $field_name =&gt; $value,... Content =&gt; \@form )</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$ua-&gt;post( $url, $field_name =&gt; $value,... Content =&gt; $content )</dt>
<dd>
This method will dispatch a &quot;POST&quot; request on the given $url, with %form or @form providing the key/value pairs for the fill-in form content. Additional headers and content options are the same as for the  <i>get()</i> method.<div style="height: 1.00em;">
&#160;</div>
This method will use the <i>POST()</i> function from &quot;HTTP::Request::Common&quot; to build the request.  See HTTP::Request::Common for a details on how to pass form content and other advanced features.</dd>
</dl>
<dl>
<dt>
$ua-&gt;mirror( $url, $filename )</dt>
<dd>
This method will get the document identified by $url and store it in file called $filename.  If the file already exists, then the request will contain an &quot;If-Modified-Since&quot; header matching the modification time of the file.  If the document on the server has not changed since this time, then nothing happens.  If the document has been updated, it will be downloaded again.  The modification time of the file will be forced to match that of the server.<div style="height: 1.00em;">
&#160;</div>
The return value is the the response object.</dd>
</dl>
<dl>
<dt>
$ua-&gt;request( $request )</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$ua-&gt;request( $request, $content_file )</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$ua-&gt;request( $request, $content_cb )</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$ua-&gt;request( $request, $content_cb, $read_size_hint )</dt>
<dd>
This method will dispatch the given $request object.  Normally this will be an instance of the &quot;HTTP::Request&quot; class, but any object with a similar interface will do.  The return value is a response object. See HTTP::Request and HTTP::Response for a description of the interface provided by these classes.<div style="height: 1.00em;">
&#160;</div>
The <i>request()</i> method will process redirects and authentication responses transparently.  This means that it may actually send several simple requests via the  <i>simple_request()</i> method described below.<div style="height: 1.00em;">
&#160;</div>
The request methods described above; <i>get()</i>, <i>head()</i>, <i>post()</i> and  <i>mirror()</i>, will all dispatch the request they build via this method. They are convenience methods that simply hides the creation of the request object for you.<div style="height: 1.00em;">
&#160;</div>
The $content_file, $content_cb and $read_size_hint all correspond to options described with the  <i>get()</i> method above.<div style="height: 1.00em;">
&#160;</div>
You are allowed to use a CODE reference as &quot;content&quot; in the request object passed in.  The &quot;content&quot; function should return the content when called.  The content can be returned in chunks.  The content function will be invoked repeatedly until it return an empty string to signal that there is no more content.</dd>
</dl>
<dl>
<dt>
$ua-&gt;simple_request( $request )</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$ua-&gt;simple_request( $request, $content_file )</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$ua-&gt;simple_request( $request, $content_cb )</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$ua-&gt;simple_request( $request, $content_cb, $read_size_hint )</dt>
<dd>
This method dispatches a single request and returns the response received.  Arguments are the same as for  <i>request()</i> described above.<div style="height: 1.00em;">
&#160;</div>
The difference from <i>request()</i> is that <i>simple_request()</i> will not try to handle redirects or authentication responses.  The  <i>request()</i> method will in fact invoke this method for each simple request it sends.</dd>
</dl>
<dl>
<dt>
$ua-&gt;is_protocol_supported( $scheme )</dt>
<dd>
You can use this method to test whether this user agent object supports the specified &quot;scheme&quot;.  (The &quot;scheme&quot; might be a string (like 'http' or 'ftp') or it might be an URI object reference.)<div style="height: 1.00em;">
&#160;</div>
Whether a scheme is supported, is determined by the user agent's &quot;protocols_allowed&quot; or &quot;protocols_forbidden&quot; lists (if any), and by the capabilities of LWP.  I.e., this will return TRUE only if LWP supports this protocol  <i>and</i> it's permitted for this particular object.</dd>
</dl>
<div class="subsection">
<h2>Callback methods</h2> The following methods will be invoked as requests are processed. These methods are documented here because subclasses of &quot;LWP::UserAgent&quot; might want to override their behaviour.<dl>
<dt>
$ua-&gt;prepare_request( $request )</dt>
<dd>
This method is invoked by <i>simple_request()</i>.  Its task is to modify the given $request object by setting up various headers based on the attributes of the user agent. The return value should normally be the $request object passed in.  If a different request object is returned it will be the one actually processed.<div style="height: 1.00em;">
&#160;</div>
The headers affected by the base implementation are; &quot;User-Agent&quot;, &quot;From&quot;, &quot;Range&quot; and &quot;Cookie&quot;.</dd>
</dl>
<dl>
<dt>
$ua-&gt;redirect_ok( $prospective_request, $response )</dt>
<dd>
This method is called by <i>request()</i> before it tries to follow a redirection to the request in $response.  This should return a TRUE value if this redirection is permissible.  The $prospective_request will be the request to be sent if this method returns TRUE.<div style="height: 1.00em;">
&#160;</div>
The base implementation will return FALSE unless the method is in the object's &quot;requests_redirectable&quot; list, FALSE if the proposed redirection is to a &quot;file://...&quot; URL, and TRUE otherwise.</dd>
</dl>
<dl>
<dt>
$ua-&gt;get_basic_credentials( $realm, $uri, $isproxy )</dt>
<dd>
This is called by <i>request()</i> to retrieve credentials for documents protected by Basic or Digest Authentication.  The arguments passed in is the $realm provided by the server, the $uri requested and a boolean flag to indicate if this is authentication against a proxy server.<div style="height: 1.00em;">
&#160;</div>
The method should return a username and password.  It should return an empty list to abort the authentication resolution attempt.  Subclasses can override this method to prompt the user for the information. An example of this can be found in &quot;lwp-request&quot; program distributed with this library.<div style="height: 1.00em;">
&#160;</div>
The base implementation simply checks a set of pre-stored member variables, set up with the  <i>credentials()</i> method.</dd>
</dl>
<dl>
<dt>
$ua-&gt;progress( $status, $request_or_response )</dt>
<dd>
This is called frequently as the response is received regardless of how the content is processed.  The method is called with $status &quot;begin&quot; at the start of processing the request and with $state &quot;end&quot; before the request method returns.  In between these $status will be the fraction of the response currently received or the string &quot;tick&quot; if the fraction can't be calculated.<div style="height: 1.00em;">
&#160;</div>
When $status is &quot;begin&quot; the second argument is the request object, otherwise it is the response object.</dd>
</dl>
</div>
</div>
<div class="section">
<h1>SEE ALSO</h1> See LWP for a complete overview of libwww-perl5.  See lwpcook and the scripts  <i>lwp-request</i> and <i>lwp-download</i> for examples of usage.<div class="spacer">
</div>
See HTTP::Request and HTTP::Response for a description of the message objects dispatched and received.  See HTTP::Request::Common and HTML::Form for other ways to build request objects.<div class="spacer">
</div>
See WWW::Mechanize and WWW::Search for examples of more specialized user agents based on &quot;LWP::UserAgent&quot;.</div>
<div class="section">
<h1>COPYRIGHT</h1> Copyright 1995-2009 Gisle Aas.<div class="spacer">
</div>
This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-10-15</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

