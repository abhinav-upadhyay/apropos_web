<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Globus Callback Signal Handling(3)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Globus Callback Signal Handling(3)</td>
<td class="head-vol">
globus common</td>
<td class="head-rtitle">
Globus Callback Signal Handling(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Globus Callback Signal Handling -<div class="subsection">
<h2>Defines</h2><br/>
#define <b>GLOBUS_SIGNAL_INTERRUPT</b><div style="height: 0.00em;">
&#160;</div>
<br/>
</div>
<div class="subsection">
<h2>Functions</h2><br/>
globus_result_t <b>globus_callback_space_register_signal_handler</b> (int signum, globus_bool_t persist, <b>globus_callback_func_t</b> callback_func, void *callback_user_arg, <b>globus_callback_space_t</b> space)<div style="height: 0.00em;">
&#160;</div>
globus_result_t <b>globus_callback_unregister_signal_handler</b> (int signum, <b>globus_callback_func_t</b> unregister_callback, void *unreg_arg)<div style="height: 0.00em;">
&#160;</div>
void <b>globus_callback_add_wakeup_handler</b> (void(*wakeup)(void *), void *user_arg)<div style="height: 0.00em;">
&#160;</div>
<br/>
</div>
</div>
<div class="section">
<h1>Detailed Description</h1><div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>Define Documentation</h1><div class="subsection">
<h2>#define <b>GLOBUS_SIGNAL_INTERRUPT</b> Use this to trap interrupts (SIGINT on unix). In the future, this will also map to handle ctrl-C on win32.</h2></div>
</div>
<div class="section">
<h1>Function Documentation</h1><div class="subsection">
<h2>globus_result_t <b>globus_callback_space_register_signal_handler</b> (intsignum, globus_bool_tpersist, <b>globus_callback_func_t</b>callback_func, void *callback_user_arg, <b>globus_callback_space_t</b>space)</h2> Fire a callback when the specified signal is received. Note that there is a tiny delay between the time this call returns and the signal is actually handled by this library. It is likely that, if the signal was received the instant the call returned, it will be lost (this is normally not an issue, since you would call this in your startup code anyway)<div class="spacer">
</div>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>signum</i> The signal to receive. The following signals are not allowed: SIGKILL, SIGSEGV, SIGABRT, SIGBUS, SIGFPE, SIGILL, SIGIOT, SIGPIPE, SIGEMT, SIGSYS, SIGTRAP, SIGSTOP, SIGCONT, and SIGWAITING<div style="height: 0.00em;">
&#160;</div>
<i>persist</i> If GLOBUS_TRUE, keep this callback registered for multiple signals. If GLOBUS_FALSE, the signal handler will automatically be unregistered once the signal has been received.<div style="height: 0.00em;">
&#160;</div>
<i>callback_func</i> the user func to call when a signal is received<div style="height: 0.00em;">
&#160;</div>
<i>callback_user_arg</i> user arg that will be passed to callback<div style="height: 0.00em;">
&#160;</div>
<i>space</i> the space to deliver callbacks to.</div>
<div class="spacer">
</div>
<b>Returns:</b><div style="margin-left: 4.00ex;">
<dl>
<dt>
&#8226;</dt>
<dd>
GLOBUS_CALLBACK_ERROR_INVALID_SPACE</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
GLOBUS_CALLBACK_ERROR_INVALID_ARGUMENT</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
GLOBUS_SUCCESS otherwise</dd>
</dl>
</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>globus_result_t <b>globus_callback_unregister_signal_handler</b> (intsignum, <b>globus_callback_func_t</b>unregister_callback, void *unreg_arg)</h2> Unregister a signal handling callback.  <b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>signum</i> The signal to unregister.<div style="height: 0.00em;">
&#160;</div>
<i>unregister_callback</i> the function to call when the callback has been canceled and there are no running instances of it (may be NULL). This will be delivered to the same space used in the register call.<div style="height: 0.00em;">
&#160;</div>
<i>unreg_arg</i> user arg that will be passed to callback</div>
<div class="spacer">
</div>
<b>Returns:</b><div style="margin-left: 4.00ex;">
<dl>
<dt>
&#8226;</dt>
<dd>
GLOBUS_CALLBACK_ERROR_INVALID_ARGUMENT if this signal was registered with persist == false, then there is a race between a signal actually being caught and therefor automatically unregistered and the attempt to manually unregister it. If that race occurs, you will receive this error just as you would for any signal not registered.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
GLOBUS_SUCCESS otherwise</dd>
</dl>
</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>void <b>globus_callback_add_wakeup_handler</b> (void(*)(void *)wakeup, void *user_arg)</h2> Register a wakeup handler with callback library. This is really only needed in non-threaded builds, but for cross builds should be used everywhere that a callback may sleep for an extended period of time.<div class="spacer">
</div>
An example use is for an io poller that sleeps indefinitely on select(). If the callback library receives a signal that it needs to deliver asap, it will call the wakeup handler(s), These wakeup handlers must run as though they were called from a signal handler (don't use any thread utilities). The io poll example will likely write a single byte to a pipe that select() is monitoring.<div class="spacer">
</div>
This handler will not be unregistered until the callback library is deactivated (via common).<div class="spacer">
</div>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>wakeup</i> function to call when callback library needs you to return asap from any blocked callbacks.<div style="height: 0.00em;">
&#160;</div>
<i>user_arg</i> user data that will be passed along in the wakeup handler</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
</div>
<div class="section">
<h1>Author</h1> Generated automatically by Doxygen for globus common from the source code.</div>
<table class="foot">
<tr>
<td class="foot-date">
Tue Jan 24 2012</td>
<td class="foot-os">
Version 14.5</td>
</tr>
</table>
</div>
</body>
</html>

