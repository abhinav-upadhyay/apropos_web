<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
ExtUtils::Constant::Base(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
ExtUtils::Constant::Base(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
ExtUtils::Constant::Base(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> ExtUtils::Constant::Base - base class for ExtUtils::Constant objects</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
    require ExtUtils::Constant::Base;<br/>
    @ISA = 'ExtUtils::Constant::Base';<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> ExtUtils::Constant::Base provides a base implementation of methods to generate C code to give fast constant value lookup by named string. Currently it's mostly used ExtUtils::Constant::XS, which generates the lookup code for the  <i>constant()</i> subroutine found in many XS modules.</div>
<div class="section">
<h1>USAGE</h1> ExtUtils::Constant::Base exports no subroutines. The following methods are available<dl>
<dt>
header</dt>
<dd>
A method returning a scalar containing definitions needed, typically for a C header file.</dd>
</dl>
<dl>
<dt>
memEQ_clause args_hashref</dt>
<dd>
A method to return a suitable C &quot;if&quot; statement to check whether <i>name</i> is equal to the C variable &quot;name&quot;. If  <i>checked_at</i> is defined, then it is used to avoid &quot;memEQ&quot; for short names, or to generate a comment to highlight the position of the character in the &quot;switch&quot; statement.<div style="height: 1.00em;">
&#160;</div>
If i&lt;checked_at&gt; is a reference to a scalar, then instead it gives the characters pre-checked at the beginning, (and the number of chars by which the C variable name has been advanced. These need to be chopped from the front of  <i>name</i>).</dd>
</dl>
<dl>
<dt>
dump_names arg_hashref, ITEM...</dt>
<dd>
An internal function to generate the embedded perl code that will regenerate the constant subroutines.   <i>default_type</i>, <i>types</i> and <i>ITEM</i>s are the same as for C_constant.   <i>indent</i> is treated as number of spaces to indent by.  If &quot;declare_types&quot; is true a $types is always declared in the perl code generated, if defined and false never declared, and if undefined $types is only declared if the values in  <i>types</i> as passed in cannot be inferred from  <i>default_types</i> and the <i>ITEM</i>s.</dd>
</dl>
<dl>
<dt>
assign arg_hashref, VALUE...</dt>
<dd>
A method to return a suitable assignment clause. If <i>type</i> is aggregate (eg  <i>PVN</i> expects both pointer and length) then there should be multiple  <i>VALUE</i>s for the components. <i>pre</i> and <i>post</i> if defined give snippets of C code to proceed and follow the assignment.  <i>pre</i> will be at the start of a block, so variables may be defined in it.</dd>
</dl>
<dl>
<dt>
return_clause arg_hashref, ITEM</dt>
<dd>
A method to return a suitable &quot;#ifdef&quot; clause. <i>ITEM</i> is a hashref (as passed to &quot;C_constant&quot; and &quot;match_clause&quot;.  <i>indent</i> is the number of spaces to indent, defaulting to 6.</dd>
</dl>
<dl>
<dt>
switch_clause arg_hashref, NAMELEN, ITEMHASH, ITEM...</dt>
<dd>
An internal method to generate a suitable &quot;switch&quot; clause, called by &quot;C_constant&quot;  <i>ITEM</i>s are in the hash ref format as given in the description of &quot;C_constant&quot;, and must all have the names of the same length, given by  <i>NAMELEN</i>.  <i>ITEMHASH</i> is a reference to a hash, keyed by name, values being the hashrefs in the  <i>ITEM</i> list.  (No parameters are modified, and there can be keys in the  <i>ITEMHASH</i> that are not in the list of <i>ITEM</i>s without causing problems - the hash is passed in to save generating it afresh for each call).</dd>
</dl>
<dl>
<dt>
params WHAT</dt>
<dd>
An &quot;internal&quot; method, subject to change, currently called to allow an overriding class to cache information that will then be passed into all the &quot;*param*&quot; calls. (Yes, having to read the source to make sense of this is considered a known bug).  <i>WHAT</i> is be a hashref of types the constant function will return. In ExtUtils::Constant::XS this method is used to returns a hashref keyed IV NV PV SV to show which combination of pointers will be needed in the C argument list generated by C_constant_other_params_definition and C_constant_other_params</dd>
</dl>
<dl>
<dt>
dogfood arg_hashref, ITEM...</dt>
<dd>
An internal function to generate the embedded perl code that will regenerate the constant subroutines.  Parameters are the same as for C_constant.<div style="height: 1.00em;">
&#160;</div>
Currently the base class does nothing and returns an empty string.</dd>
</dl>
<dl>
<dt>
normalise_items args, default_type, seen_types, seen_items, ITEM...</dt>
<dd>
Convert the items to a normalised form. For 8 bit and Unicode values converts the item to an array of 1 or 2 items, both 8 bit and UTF-8 encoded.</dd>
</dl>
<dl>
<dt>
C_constant arg_hashref, ITEM...</dt>
<dd>
A function that returns a <b>list</b> of C subroutine definitions that return the value and type of constants when passed the name by the XS wrapper.  <i>ITEM...</i> gives a list of constant names. Each can either be a string, which is taken as a C macro name, or a reference to a hash with the following keys</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
name</dt>
<dd>
The name of the constant, as seen by the perl code.</dd>
</dl>
<dl>
<dt>
type</dt>
<dd>
The type of the constant (<i>IV</i>, <i>NV</i> etc)</dd>
</dl>
<dl>
<dt>
value</dt>
<dd>
A C expression for the value of the constant, or a list of C expressions if the type is aggregate. This defaults to the  <i>name</i> if not given.</dd>
</dl>
<dl>
<dt>
macro</dt>
<dd>
The C pre-processor macro to use in the &quot;#ifdef&quot;. This defaults to the  <i>name</i>, and is mainly used if <i>value</i> is an &quot;enum&quot;. If a reference an array is passed then the first element is used in place of the &quot;#ifdef&quot; line, and the second element in place of the &quot;#endif&quot;. This allows pre-processor constructions such as<div style="height: 1.00em;">
&#160;</div>
<br/>
    #if defined (foo)<br/>
    #if !defined (bar)<br/>
    ...<br/>
    #endif<br/>
    #endif<br/>
<div style="height: 1.00em;">
&#160;</div>
to be used to determine if a constant is to be defined.<div style="height: 1.00em;">
&#160;</div>
A &quot;macro&quot; 1 signals that the constant is always defined, so the &quot;#if&quot;/&quot;#endif&quot; test is omitted.</dd>
</dl>
<dl>
<dt>
default</dt>
<dd>
Default value to use (instead of &quot;croak&quot;ing with &quot;your vendor has not defined...&quot;) to return if the macro isn't defined. Specify a reference to an array with type followed by value(s).</dd>
</dl>
<dl>
<dt>
pre</dt>
<dd>
C code to use before the assignment of the value of the constant. This allows you to use temporary variables to extract a value from part of a &quot;struct&quot; and return this as  <i>value</i>. This C code is places at the start of a block, so you can declare variables in it.</dd>
</dl>
<dl>
<dt>
post</dt>
<dd>
C code to place between the assignment of value (to a temporary) and the return from the function. This allows you to clear up anything in  <i>pre</i>. Rarely needed.</dd>
</dl>
<dl>
<dt>
def_pre</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
def_post</dt>
<dd>
Equivalents of <i>pre</i> and <i>post</i> for the default value.</dd>
</dl>
<dl>
<dt>
utf8</dt>
<dd>
Generated internally. Is zero or undefined if name is 7 bit ASCII, &quot;no&quot; if the name is 8 bit (and so should only match if  <i>SvUTF8()</i> is false), &quot;yes&quot; if the name is utf8 encoded.<div style="height: 1.00em;">
&#160;</div>
The internals automatically clone any name with characters 128-255 but none 256+ (ie one that could be either in bytes or utf8) into a second entry which is utf8 encoded.</dd>
</dl>
<dl>
<dt>
weight</dt>
<dd>
Optional sorting weight for names, to determine the order of linear testing when multiple names fall in the same case of a switch clause. Higher comes earlier, undefined defaults to zero.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">
&#160;</div>
In the argument hashref, <i>package</i> is the name of the package, and is only used in comments inside the generated C code.  <i>subname</i> defaults to &quot;constant&quot; if undefined.<div style="height: 1.00em;">
&#160;</div>
<i>default_type</i> is the type returned by &quot;ITEM&quot;s that don't specify their type. It defaults to the value of &quot;default_type()&quot;.  <i>types</i> should be given either as a comma separated list of types that the C subroutine  <i>subname</i> will generate or as a reference to a hash.  <i>default_type</i> will be added to the list if not present, as will any types given in the list of  <i>ITEM</i>s. The resultant list should be the same list of types that &quot;XS_constant&quot; is given. [Otherwise &quot;XS_constant&quot; and &quot;C_constant&quot; may differ in the number of parameters to the constant function.  <i>indent</i> is currently unused and ignored. In future it may be used to pass in information used to change the C indentation style used.]  The best way to maintain consistency is to pass in a hash reference and let this function update it.<div style="height: 1.00em;">
&#160;</div>
<i>breakout</i> governs when child functions of <i>subname</i> are generated.  If there are  <i>breakout</i> or more <i>ITEM</i>s with the same length of name, then the code to switch between them is placed into a function named  <i>subname</i>_<i>len</i>, for example &quot;constant_5&quot; for names 5 characters long.  The default  <i>breakout</i> is 3.  A single &quot;ITEM&quot; is always inlined.</div>
</div>
<div class="section">
<h1>BUGS</h1> Not everything is documented yet.<div class="spacer">
</div>
Probably others.</div>
<div class="section">
<h1>AUTHOR</h1> Nicholas Clark &lt;nick@ccl4.org&gt; based on the code in &quot;h2xs&quot; by Larry Wall and others</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-09-19</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

