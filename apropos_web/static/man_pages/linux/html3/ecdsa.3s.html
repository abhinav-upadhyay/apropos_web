<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
ecdsa(3SSL)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
ecdsa(3SSL)</td>
<td class="head-vol">
OpenSSL</td>
<td class="head-rtitle">
ecdsa(3SSL)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> ecdsa - Elliptic Curve Digital Signature Algorithm</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
 #include &lt;openssl/ecdsa.h&gt;<br/>
<br/>
 ECDSA_SIG*     ECDSA_SIG_new(void);<br/>
 void           ECDSA_SIG_free(ECDSA_SIG *sig);<br/>
 int            i2d_ECDSA_SIG(const ECDSA_SIG *sig, unsigned char **pp);<br/>
 ECDSA_SIG*     d2i_ECDSA_SIG(ECDSA_SIG **sig, const unsigned char **pp, <br/>
                long len);<br/>
<br/>
 ECDSA_SIG*     ECDSA_do_sign(const unsigned char *dgst, int dgst_len,<br/>
                        EC_KEY *eckey);<br/>
 ECDSA_SIG*     ECDSA_do_sign_ex(const unsigned char *dgst, int dgstlen, <br/>
                        const BIGNUM *kinv, const BIGNUM *rp,<br/>
                        EC_KEY *eckey);<br/>
 int            ECDSA_do_verify(const unsigned char *dgst, int dgst_len,<br/>
                        const ECDSA_SIG *sig, EC_KEY* eckey);<br/>
 int            ECDSA_sign_setup(EC_KEY *eckey, BN_CTX *ctx,<br/>
                        BIGNUM **kinv, BIGNUM **rp);<br/>
 int            ECDSA_sign(int type, const unsigned char *dgst,<br/>
                        int dgstlen, unsigned char *sig,<br/>
                        unsigned int *siglen, EC_KEY *eckey);<br/>
 int            ECDSA_sign_ex(int type, const unsigned char *dgst,<br/>
                        int dgstlen, unsigned char *sig,<br/>
                        unsigned int *siglen, const BIGNUM *kinv, <br/>
                        const BIGNUM *rp, EC_KEY *eckey);<br/>
 int            ECDSA_verify(int type, const unsigned char *dgst,<br/>
                        int dgstlen, const unsigned char *sig,<br/>
                        int siglen, EC_KEY *eckey);<br/>
 int            ECDSA_size(const EC_KEY *eckey);<br/>
<br/>
 const ECDSA_METHOD*    ECDSA_OpenSSL(void);<br/>
 void           ECDSA_set_default_method(const ECDSA_METHOD *meth);<br/>
 const ECDSA_METHOD*    ECDSA_get_default_method(void);<br/>
 int            ECDSA_set_method(EC_KEY *eckey,const ECDSA_METHOD *meth);<br/>
<br/>
 int            ECDSA_get_ex_new_index(long argl, void *argp,<br/>
                        CRYPTO_EX_new *new_func,<br/>
                        CRYPTO_EX_dup *dup_func,<br/>
                        CRYPTO_EX_free *free_func);<br/>
 int            ECDSA_set_ex_data(EC_KEY *d, int idx, void *arg);<br/>
 void*          ECDSA_get_ex_data(EC_KEY *d, int idx);<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> The  <b>ECDSA_SIG</b> structure consists of two BIGNUMs for the r and s value of a ECDSA signature (see X9.62 or FIPS 186-2).<div class="spacer">
</div>
<br/>
 struct<br/>
        {<br/>
        BIGNUM *r;<br/>
        BIGNUM *s;<br/>
 } ECDSA_SIG;<br/>
<div class="spacer">
</div>
<i>ECDSA_SIG_new()</i> allocates a new <b>ECDSA_SIG</b> structure (note: this function also allocates the BIGNUMs) and initialize it.<div class="spacer">
</div>
<i>ECDSA_SIG_free()</i> frees the <b>ECDSA_SIG</b> structure <b>sig</b>.<div class="spacer">
</div>
<i>i2d_ECDSA_SIG()</i> creates the DER encoding of the ECDSA signature  <b>sig</b> and writes the encoded signature to <b>*pp</b> (note: if <b>pp</b> is NULL  <b>i2d_ECDSA_SIG</b> returns the expected length in bytes of the DER encoded signature).  <b>i2d_ECDSA_SIG</b> returns the length of the DER encoded signature (or 0 on error).<div class="spacer">
</div>
<i>d2i_ECDSA_SIG()</i> decodes a DER encoded ECDSA signature and returns the decoded signature in a newly allocated  <b>ECDSA_SIG</b> structure.  <b>*sig</b> points to the buffer containing the DER encoded signature of size  <b>len</b>.<div class="spacer">
</div>
<i>ECDSA_size()</i> returns the maximum length of a DER encoded ECDSA signature created with the private EC key  <b>eckey</b>.<div class="spacer">
</div>
<i>ECDSA_sign_setup()</i> may be used to precompute parts of the signing operation.  <b>eckey</b> is the private EC key and <b>ctx</b> is a pointer to  <b>BN_CTX</b> structure (or NULL). The precomputed values or returned in  <b>kinv</b> and <b>rp</b> and can be used in a later call to  <b>ECDSA_sign_ex</b> or <b>ECDSA_do_sign_ex</b>.<div class="spacer">
</div>
<i>ECDSA_sign()</i> is wrapper function for ECDSA_sign_ex with <b>kinv</b> and  <b>rp</b> set to NULL.<div class="spacer">
</div>
<i>ECDSA_sign_ex()</i> computes a digital signature of the <b>dgstlen</b> bytes hash value  <b>dgst</b> using the private EC key <b>eckey</b> and the optional pre-computed values  <b>kinv</b> and <b>rp</b>. The DER encoded signatures is stored in  <b>sig</b> and it's length is returned in <b>sig_len</b>. Note: <b>sig</b> must point to  <b>ECDSA_size</b> bytes of memory. The parameter <b>type</b> is ignored.<div class="spacer">
</div>
<i>ECDSA_verify()</i> verifies that the signature in <b>sig</b> of size  <b>siglen</b> is a valid ECDSA signature of the hash value value  <b>dgst</b> of size <b>dgstlen</b> using the public key <b>eckey</b>. The parameter  <b>type</b> is ignored.<div class="spacer">
</div>
<i>ECDSA_do_sign()</i> is wrapper function for ECDSA_do_sign_ex with <b>kinv</b> and  <b>rp</b> set to NULL.<div class="spacer">
</div>
<i>ECDSA_do_sign_ex()</i> computes a digital signature of the <b>dgst_len</b> bytes hash value  <b>dgst</b> using the private key <b>eckey</b> and the optional pre-computed values  <b>kinv</b> and <b>rp</b>. The signature is returned in a newly allocated  <b>ECDSA_SIG</b> structure (or NULL on error).<div class="spacer">
</div>
<i>ECDSA_do_verify()</i> verifies that the signature <b>sig</b> is a valid ECDSA signature of the hash value  <b>dgst</b> of size <b>dgst_len</b> using the public key  <b>eckey</b>.</div>
<div class="section">
<h1>RETURN VALUES</h1>  <i>ECDSA_size()</i> returns the maximum length signature or 0 on error.<div class="spacer">
</div>
<i>ECDSA_sign_setup()</i> and <i>ECDSA_sign()</i> return 1 if successful or 0 on error.<div class="spacer">
</div>
<i>ECDSA_verify()</i> and <i>ECDSA_do_verify()</i> return 1 for a valid signature, 0 for an invalid signature and -1 on error. The error codes can be obtained by  <i>ERR_get_error</i>(3).</div>
<div class="section">
<h1>EXAMPLES</h1> Creating a ECDSA signature of given SHA-1 hash value using the named curve secp192k1.<div class="spacer">
</div>
First step: create a EC_KEY object (note: this part is <b>not</b> ECDSA specific)<div class="spacer">
</div>
<br/>
 int        ret;<br/>
 ECDSA_SIG *sig;<br/>
 EC_KEY    *eckey = EC_KEY_new();<br/>
 if (eckey == NULL)<br/>
        {<br/>
        /* error */<br/>
        }<br/>
 key-&gt;group = EC_GROUP_new_by_nid(NID_secp192k1);<br/>
 if (key-&gt;group == NULL)<br/>
        {<br/>
        /* error */<br/>
        }<br/>
 if (!EC_KEY_generate_key(eckey))<br/>
        {<br/>
        /* error */<br/>
        }<br/>
<div class="spacer">
</div>
Second step: compute the ECDSA signature of a SHA-1 hash value using  <b>ECDSA_do_sign</b><div class="spacer">
</div>
<br/>
 sig = ECDSA_do_sign(digest, 20, eckey);<br/>
 if (sig == NULL)<br/>
        {<br/>
        /* error */<br/>
        }<br/>
<div class="spacer">
</div>
or using <b>ECDSA_sign</b><div class="spacer">
</div>
<br/>
 unsigned char *buffer, *pp;<br/>
 int            buf_len;<br/>
 buf_len = ECDSA_size(eckey);<br/>
 buffer  = OPENSSL_malloc(buf_len);<br/>
 pp = buffer;<br/>
 if (!ECDSA_sign(0, dgst, dgstlen, pp, &amp;buf_len, eckey);<br/>
        {<br/>
        /* error */<br/>
        }<br/>
<div class="spacer">
</div>
Third step: verify the created ECDSA signature using <b>ECDSA_do_verify</b><div class="spacer">
</div>
<br/>
 ret = ECDSA_do_verify(digest, 20, sig, eckey);<br/>
<div class="spacer">
</div>
or using <b>ECDSA_verify</b><div class="spacer">
</div>
<br/>
 ret = ECDSA_verify(0, digest, 20, buffer, buf_len, eckey);<br/>
<div class="spacer">
</div>
and finally evaluate the return value:<div class="spacer">
</div>
<br/>
 if (ret == -1)<br/>
        {<br/>
        /* error */<br/>
        }<br/>
 else if (ret == 0)<br/>
        {<br/>
        /* incorrect signature */<br/>
        }<br/>
 else   /* ret == 1 */<br/>
        {<br/>
        /* signature ok */<br/>
        }<br/>
</div>
<div class="section">
<h1>CONFORMING TO</h1> ANSI X9.62, US Federal Information Processing Standard FIPS 186-2 (Digital Signature Standard, DSS)</div>
<div class="section">
<h1>SEE ALSO</h1>  <i>dsa</i>(3), <i>rsa</i>(3)</div>
<div class="section">
<h1>HISTORY</h1> The ecdsa implementation was first introduced in OpenSSL 0.9.8</div>
<div class="section">
<h1>AUTHOR</h1> Nils Larsch for the OpenSSL project (http://www.openssl.org).</div>
<table class="foot">
<tr>
<td class="foot-date">
2012-01-11</td>
<td class="foot-os">
1.0.1</td>
</tr>
</table>
</div>
</body>
</html>

