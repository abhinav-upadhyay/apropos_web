<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Globus Callback API(3)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Globus Callback API(3)</td>
<td class="head-vol">
globus common</td>
<td class="head-rtitle">
Globus Callback API(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Globus Callback API -<div class="subsection">
<h2>Convenience Macros</h2><br/>
#define <b>globus_callback_poll</b>(a)<div style="height: 0.00em;">
&#160;</div>
#define <b>globus_poll_blocking</b>()<div style="height: 0.00em;">
&#160;</div>
#define <b>globus_poll_nonblocking</b>()<div style="height: 0.00em;">
&#160;</div>
#define <b>globus_poll</b>()<div style="height: 0.00em;">
&#160;</div>
#define <b>globus_signal_poll</b>()<div style="height: 0.00em;">
&#160;</div>
#define <b>globus_callback_register_oneshot</b>(callback_handle,delay_time,callback_func,callback_user_arg)<div style="height: 0.00em;">
&#160;</div>
#define <b>globus_callback_register_periodic</b>(callback_handle,delay_time,period,callback_func,callback_user_arg)<div style="height: 0.00em;">
&#160;</div>
#define <b>globus_callback_register_signal_handler</b>(signum,persist,callback_func,callback_user_arg)<div style="height: 0.00em;">
&#160;</div>
<br/>
</div>
<div class="subsection">
<h2>Callback Prototypes</h2><br/>
typedef void(* <b>globus_callback_func_t</b> )(void *user_arg)<div style="height: 0.00em;">
&#160;</div>
<br/>
</div>
<div class="subsection">
<h2>Oneshot Callbacks</h2><br/>
globus_result_t <b>globus_callback_space_register_oneshot</b> (<b>globus_callback_handle_t</b> *callback_handle, const globus_reltime_t *delay_time, <b>globus_callback_func_t</b> callback_func, void *callback_user_arg, <b>globus_callback_space_t</b> space)<div style="height: 0.00em;">
&#160;</div>
<br/>
</div>
<div class="subsection">
<h2>Periodic Callbacks</h2><br/>
globus_result_t <b>globus_callback_space_register_periodic</b> (<b>globus_callback_handle_t</b> *callback_handle, const globus_reltime_t *delay_time, const globus_reltime_t *period, <b>globus_callback_func_t</b> callback_func, void *callback_user_arg, <b>globus_callback_space_t</b> space)<div style="height: 0.00em;">
&#160;</div>
globus_result_t <b>globus_callback_unregister</b> (<b>globus_callback_handle_t</b> callback_handle, <b>globus_callback_func_t</b> unregister_callback, void *unreg_arg, globus_bool_t *active)<div style="height: 0.00em;">
&#160;</div>
globus_result_t <b>globus_callback_adjust_oneshot</b> (<b>globus_callback_handle_t</b> callback_handle, const globus_reltime_t *new_delay)<div style="height: 0.00em;">
&#160;</div>
globus_result_t <b>globus_callback_adjust_period</b> (<b>globus_callback_handle_t</b> callback_handle, const globus_reltime_t *new_period)<div style="height: 0.00em;">
&#160;</div>
<br/>
</div>
<div class="subsection">
<h2>Callback Polling</h2><br/>
void <b>globus_callback_space_poll</b> (const globus_abstime_t *timestop, <b>globus_callback_space_t</b> space)<div style="height: 0.00em;">
&#160;</div>
void <b>globus_callback_signal_poll</b> ()<div style="height: 0.00em;">
&#160;</div>
<br/>
</div>
<div class="subsection">
<h2>Miscellaneous</h2><br/>
globus_bool_t <b>globus_callback_get_timeout</b> (globus_reltime_t *time_left)<div style="height: 0.00em;">
&#160;</div>
globus_bool_t <b>globus_callback_has_time_expired</b> ()<div style="height: 0.00em;">
&#160;</div>
globus_bool_t <b>globus_callback_was_restarted</b> ()<div style="height: 0.00em;">
&#160;</div>
<br/>
</div>
</div>
<div class="section">
<h1>Detailed Description</h1><div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>Define Documentation</h1><div class="subsection">
<h2>#define <b>globus_callback_poll</b>(a)</h2> Poll the global callback space. Specifies the global space for  <b>globus_callback_space_poll()</b>. argument is the timeout<div class="spacer">
</div>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>globus_callback_space_poll()</b></div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>#define <b>globus_poll_blocking</b>()</h2> Blocking poll of the global callback space. Specifies that  <b>globus_callback_space_poll()</b> should poll on the global space with an infinite timeout<div class="spacer">
</div>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>globus_callback_space_poll()</b></div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>#define <b>globus_poll_nonblocking</b>()</h2> Nonblocking poll of the global callback space. Specifies that  <b>globus_callback_space_poll()</b> should poll on the global space with an immediate timeout<div class="spacer">
</div>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>globus_callback_space_poll()</b></div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>#define <b>globus_poll</b>()</h2> Nonblocking poll of the global callback space. Specifies that  <b>globus_callback_space_poll()</b> should poll on the global space with an immediate timeout<div class="spacer">
</div>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>globus_callback_space_poll()</b></div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>#define <b>globus_signal_poll</b>()</h2> Wake up callback polling thread. Counterpart to  <b>globus_poll()</b>.<div class="spacer">
</div>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>globus_callback_signal_poll()</b></div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>#define <b>globus_callback_register_oneshot</b>(callback_handle, delay_time, callback_func, callback_user_arg)</h2> Register a oneshot function in the global callback space. Specifies the global space for  <b>globus_callback_space_register_oneshot()</b> all other arguments are the same as specified there.<div class="spacer">
</div>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>globus_callback_space_register_oneshot()</b></div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>#define <b>globus_callback_register_periodic</b>(callback_handle, delay_time, period, callback_func, callback_user_arg)</h2> Register a periodic function in the global callback space. Specifies the global space for  <b>globus_callback_space_register_periodic()</b> all other arguments are the same as specified there.<div class="spacer">
</div>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>globus_callback_space_register_periodic()</b></div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>#define <b>globus_callback_register_signal_handler</b>(signum, persist, callback_func, callback_user_arg)</h2> Register a signal handler in the global callback space. Specifies the global space for  <b>globus_callback_space_register_signal_handler()</b> all other arguments are the same as specified there.<div class="spacer">
</div>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>globus_callback_space_register_signal_handler()</b></div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
</div>
<div class="section">
<h1>Typedef Documentation</h1><div class="subsection">
<h2>typedef void(* <b>globus_callback_func_t</b>)(void *user_arg)</h2> Globus callback prototype. This is the signature of the function registered with the globus_callback_register_* calls.<div class="spacer">
</div>
If this is a periodic callback, it is guaranteed that the call canNOT be reentered unless globus_thread_blocking_space_will_block() is called (explicitly, or implicitly via <b>globus_cond_wait()</b>). Also, if <b>globus_callback_unregister()</b> is called to cancel this periodic from within this callback, it is guaranteed that the callback will NOT be requeued again<div class="spacer">
</div>
If the function will block at all, the user should call <b>globus_callback_get_timeout()</b> to see how long this function can safely block or call globus_thread_blocking_space_will_block()<div class="spacer">
</div>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>user_arg</i> The user argument registered with this callback</div>
<div class="spacer">
</div>
<b>Returns:</b><div style="margin-left: 4.00ex;">
<dl>
<dt>
&#8226;</dt>
<dd>
void</dd>
</dl>
</div>
<div class="spacer">
</div>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>globus_callback_space_register_oneshot()</b><div class="spacer">
</div>
<b>globus_callback_space_register_periodic()</b><div class="spacer">
</div>
globus_thread_blocking_space_will_block()<div class="spacer">
</div>
<b>globus_callback_get_timeout()</b></div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
</div>
<div class="section">
<h1>Function Documentation</h1><div class="subsection">
<h2>globus_result_t <b>globus_callback_space_register_oneshot</b> (<b>globus_callback_handle_t</b> *callback_handle, const globus_reltime_t *delay_time, <b>globus_callback_func_t</b>callback_func, void *callback_user_arg, <b>globus_callback_space_t</b>space)</h2> Register a oneshot some delay from now. This function registers the callback_func to start some delay_time from now.<div class="spacer">
</div>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>callback_handle</i> Storage for a handle. This may be NULL. If it is NOT NULL, you must unregister the callback to reclaim resources.<div style="height: 0.00em;">
&#160;</div>
<i>delay_time</i> The relative time from now to fire this callback. If NULL, will fire as soon as possible<div style="height: 0.00em;">
&#160;</div>
<i>callback_func</i> the user func to call<div style="height: 0.00em;">
&#160;</div>
<i>callback_user_arg</i> user arg that will be passed to callback<div style="height: 0.00em;">
&#160;</div>
<i>space</i> The space with which to register this callback</div>
<div class="spacer">
</div>
<b>Returns:</b><div style="margin-left: 4.00ex;">
<dl>
<dt>
&#8226;</dt>
<dd>
GLOBUS_CALLBACK_ERROR_INVALID_ARGUMENT</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
GLOBUS_CALLBACK_ERROR_MEMORY_ALLOC</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
GLOBUS_SUCCESS</dd>
</dl>
</div>
<div class="spacer">
</div>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>globus_callback_func_t</b><div class="spacer">
</div>
<b>Globus Callback Spaces</b></div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>globus_result_t <b>globus_callback_space_register_periodic</b> (<b>globus_callback_handle_t</b> *callback_handle, const globus_reltime_t *delay_time, const globus_reltime_t *period, <b>globus_callback_func_t</b>callback_func, void *callback_user_arg, <b>globus_callback_space_t</b>space)</h2> Register a periodic callback. This function registers a periodic callback_func to start some delay_time and run every period from then.<div class="spacer">
</div>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>callback_handle</i> Storage for a handle. This may be NULL. If it is NOT NULL, you must cancel the periodic to reclaim resources.<div style="height: 0.00em;">
&#160;</div>
<i>delay_time</i> The relative time from now to fire this callback. If NULL, will fire the first callback as soon as possible<div style="height: 0.00em;">
&#160;</div>
<i>period</i> The relative period of this callback<div style="height: 0.00em;">
&#160;</div>
<i>callback_func</i> the user func to call<div style="height: 0.00em;">
&#160;</div>
<i>callback_user_arg</i> user arg that will be passed to callback<div style="height: 0.00em;">
&#160;</div>
<i>space</i> The space with which to register this callback</div>
<div class="spacer">
</div>
<b>Returns:</b><div style="margin-left: 4.00ex;">
<dl>
<dt>
&#8226;</dt>
<dd>
GLOBUS_CALLBACK_ERROR_INVALID_ARGUMENT</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
GLOBUS_CALLBACK_ERROR_MEMORY_ALLOC</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
GLOBUS_SUCCESS</dd>
</dl>
</div>
<div class="spacer">
</div>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>globus_callback_unregister()</b><div class="spacer">
</div>
<b>globus_callback_func_t</b><div class="spacer">
</div>
<b>globus_callback_spaces</b></div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>globus_result_t <b>globus_callback_unregister</b> (<b>globus_callback_handle_t</b>callback_handle, <b>globus_callback_func_t</b>unregister_callback, void *unreg_arg, globus_bool_t *active)</h2> Unregister a callback. This function will cancel a callback and free the resources associcated with the callback handle. If the callback was able to be canceled immediately (or if it has already run), GLOBUS_SUCCESS is returned and it is guaranteed that there are no running instances of the callback.<div class="spacer">
</div>
If the callback is currently running (or unstoppably about to be run), then the callback is prevented from being requeued, but, the 'official' cancel is deferred until the last running instance of the callback returns. If you need to know when the callback is guaranteed to have been canceled, pass an unregister callback.<div class="spacer">
</div>
If you would like to know if you unregistered a callback before it ran, pass storage for a boolean 'active'. This will be GLOBUS_TRUE if callback was running. GLOBUS_FALSE otherwise.<div class="spacer">
</div>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>callback_handle</i> the handle received from a globus_callback_space_register_*() call<div style="height: 0.00em;">
&#160;</div>
<i>unregister_callback</i> the function to call when the callback has been canceled and there are no running instances of it. This will be delivered to the same space used in the register call.<div style="height: 0.00em;">
&#160;</div>
<i>unreg_arg</i> user arg that will be passed to the unregister callback<div style="height: 0.00em;">
&#160;</div>
<i>active</i> storage for an indication of whether the callback was running when this call was made</div>
<div class="spacer">
</div>
<b>Returns:</b><div style="margin-left: 4.00ex;">
<dl>
<dt>
&#8226;</dt>
<dd>
GLOBUS_CALLBACK_ERROR_INVALID_CALLBACK_HANDLE</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
GLOBUS_CALLBACK_ERROR_ALREADY_CANCELED</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
GLOBUS_SUCCESS</dd>
</dl>
</div>
<div class="spacer">
</div>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>globus_callback_space_register_periodic()</b><div class="spacer">
</div>
<b>globus_callback_func_t</b></div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>globus_result_t <b>globus_callback_adjust_oneshot</b> (<b>globus_callback_handle_t</b>callback_handle, const globus_reltime_t *new_delay)</h2> Adjust the delay of a oneshot callback. This function allows a user to adjust the delay of a previously registered callback. It is safe to call this within or outside of the callback that is being modified.<div class="spacer">
</div>
Note if the oneshot has already been fired, this function will still return GLOBUS_SUCCESS, but won't affect anything.<div class="spacer">
</div>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>callback_handle</i> the handle received from a <b>globus_callback_space_register_oneshot()</b> call<div style="height: 0.00em;">
&#160;</div>
<i>new_delay</i> The new delay from now. If NULL, then callback will be fired as soon as possible.</div>
<div class="spacer">
</div>
<b>Returns:</b><div style="margin-left: 4.00ex;">
<dl>
<dt>
&#8226;</dt>
<dd>
GLOBUS_CALLBACK_ERROR_INVALID_CALLBACK_HANDLE</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
GLOBUS_CALLBACK_ERROR_ALREADY_CANCELED</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
GLOBUS_SUCCESS</dd>
</dl>
</div>
<div class="spacer">
</div>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>globus_callback_space_register_periodic()</b></div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>globus_result_t <b>globus_callback_adjust_period</b> (<b>globus_callback_handle_t</b>callback_handle, const globus_reltime_t *new_period)</h2> Adjust the period of a periodic callback. This function allows a user to adjust the period of a previously registered callback. It is safe to call this within or outside of the callback that is being modified.<div class="spacer">
</div>
This func also allows a user to effectively 'suspend' a periodic callback until another time by passing a period of NULL. The callback can later be resumed by passing in a new period.<div class="spacer">
</div>
Note that the callback will not be fired sooner than 'new_period' from now. A 'suspended' callback must still be unregistered to free its resources.<div class="spacer">
</div>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>callback_handle</i> the handle received from a <b>globus_callback_space_register_periodic()</b> call<div style="height: 0.00em;">
&#160;</div>
<i>new_period</i> The new period. If NULL or globus_i_reltime_infinity, then callback will be 'suspended' as soon as the last running instance of it returns.</div>
<div class="spacer">
</div>
<b>Returns:</b><div style="margin-left: 4.00ex;">
<dl>
<dt>
&#8226;</dt>
<dd>
GLOBUS_CALLBACK_ERROR_INVALID_CALLBACK_HANDLE</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
GLOBUS_CALLBACK_ERROR_ALREADY_CANCELED</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
GLOBUS_SUCCESS</dd>
</dl>
</div>
<div class="spacer">
</div>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>globus_callback_space_register_periodic()</b></div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>void <b>globus_callback_space_poll</b> (const globus_abstime_t *timestop, <b>globus_callback_space_t</b>space)</h2> Poll for ready callbacks. This function is used to poll for registered callbacks.<div class="spacer">
</div>
For non-threaded builds, callbacks are not/can not be delivered unless this is called. Any call to this can cause callbacks registered with the 'global' space to be fired. Whereas callbacks registered with a user's space will only be delivered when this is called with that space.<div class="spacer">
</div>
For threaded builds, this only needs to be called to poll user spaces with behavior == GLOBUS_CALLBACK_SPACE_BEHAVIOR_SINGLE. The 'global' space and other user spaces are constantly polled in a separate thread. (If it is called in a threaded build for these spaces, it will just yield its thread)<div class="spacer">
</div>
In general, you never need to call this function directly. It is called (when necessary) by <b>globus_cond_wait()</b>. The only case in which a user may wish to call this explicitly is if the application has no aspirations of ever being built threaded.<div class="spacer">
</div>
This function (when not yielding) will block up to timestop or until <b>globus_callback_signal_poll()</b> is called by one of the fired callbacks. It will always try and kick out ready callbacks, regardless of the timestop.<div class="spacer">
</div>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>timestop</i> The time to block until. If this is NULL or less than the cuurent time, an attempt to fire only ready callbacks is made (no blocking).<div style="height: 0.00em;">
&#160;</div>
<i>space</i> The callback space to poll. Note: regardless of what space is passed here, the 'global' space is also always polled.</div>
<div class="spacer">
</div>
<b>Returns:</b><div style="margin-left: 4.00ex;">
<dl>
<dt>
&#8226;</dt>
<dd>
void</dd>
</dl>
</div>
<div class="spacer">
</div>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>Globus Callback Spaces</b><div class="spacer">
</div>
<b>globus_condattr_setspace()</b></div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>void <b>globus_callback_signal_poll</b> ()</h2> Signal the poll. This function signals  <b>globus_callback_space_poll()</b> that something has changed and it should return to its caller as soon as possible.<div class="spacer">
</div>
In general, you never need to call this function directly. It is called (when necessary) by <b>globus_cond_signal()</b> or globus_cond_broadcast. The only case in which a user may wish to call this explicitly is if the application has no aspirations of ever being built threaded.<div class="spacer">
</div>
<b>Returns:</b><div style="margin-left: 4.00ex;">
<dl>
<dt>
&#8226;</dt>
<dd>
void</dd>
</dl>
</div>
<div class="spacer">
</div>
<b>See also:</b><div style="margin-left: 4.00ex;">
<b>globus_callback_space_poll()</b></div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>globus_bool_t <b>globus_callback_get_timeout</b> (globus_reltime_t *time_left)</h2> Get the amount of time left in a callback. This function retrieves the remaining time a callback is allowed to run. If a callback has already timed out, time_left will be set to zero and GLOBUS_TRUE returned. This function is intended to be called within a callback's stack, but is harmless to call anywhere (will return GLOBUS_FALSE and an infinite time_left)<div class="spacer">
</div>
<b>Parameters:</b><div style="margin-left: 4.00ex;">
<i>time_left</i> storage for the remaining time.</div>
<div class="spacer">
</div>
<b>Returns:</b><div style="margin-left: 4.00ex;">
<dl>
<dt>
&#8226;</dt>
<dd>
GLOBUS_FALSE if time remaining</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
GLOBUS_TRUE if already timed out</dd>
</dl>
</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>globus_bool_t <b>globus_callback_has_time_expired</b> ()</h2> See if there is remaining time in a callback. This function returns GLOBUS_TRUE if the running time of a callback has already expired. This function is intended to be called within a callback's stack, but is harmless to call anywhere (will return GLOBUS_FALSE)<div class="spacer">
</div>
<b>Returns:</b><div style="margin-left: 4.00ex;">
<dl>
<dt>
&#8226;</dt>
<dd>
GLOBUS_FALSE if time remaining</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
GLOBUS_TRUE if already timed out</dd>
</dl>
</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>globus_bool_t <b>globus_callback_was_restarted</b> ()</h2> See if a callback has been restarted. If the callback is a oneshot, this merely means the callback called globus_thread_blocking_space_will_block (or  <b>globus_cond_wait()</b> at some point.<div class="spacer">
</div>
For a periodic, it signifies the same and also that the periodic has been requeued. This means that the callback function may be reentered if the period is short enough (on a threaded build)<div class="spacer">
</div>
<b>Returns:</b><div style="margin-left: 4.00ex;">
<dl>
<dt>
&#8226;</dt>
<dd>
GLOBUS_FALSE if not restarted</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
GLOBUS_TRUE if restarted</dd>
</dl>
</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
</div>
<div class="section">
<h1>Author</h1> Generated automatically by Doxygen for globus common from the source code.</div>
<table class="foot">
<tr>
<td class="foot-date">
Tue Jan 24 2012</td>
<td class="foot-os">
Version 14.5</td>
</tr>
</table>
</div>
</body>
</html>

