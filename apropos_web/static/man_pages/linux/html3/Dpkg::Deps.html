<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Dpkg::Deps(3)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Dpkg::Deps(3)</td>
<td class="head-vol">
libdpkg-perl</td>
<td class="head-rtitle">
Dpkg::Deps(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Dpkg::Deps - parse and manipulate dependencies of Debian packages</div>
<div class="section">
<h1>DESCRIPTION</h1> The Dpkg::Deps module provides objects implementing various types of dependencies.<div class="spacer">
</div>
The most important function is <i>deps_parse()</i>, it turns a dependency line in a set of Dpkg::Deps::{Simple,AND,OR,Union} objects depending on the case.</div>
<div class="section">
<h1>FUNCTIONS</h1> All the deps_* functions are exported by default.<dl>
<dt>
deps_eval_implication($rel_p, $v_p, $rel_q, $v_q)</dt>
<dd>
($rel_p, $v_p) and ($rel_q, $v_q) express two dependencies as (relation, version). The relation variable can have the following values that are exported by Dpkg::Version: REL_EQ, REL_LT, REL_LE, REL_GT, REL_GT.<div style="height: 1.00em;">
&#160;</div>
This functions returns 1 if the &quot;p&quot; dependency implies the &quot;q&quot; dependency. It returns 0 if the &quot;p&quot; dependency implies that &quot;q&quot; is not satisfied. It returns undef when there's no implication.<div style="height: 1.00em;">
&#160;</div>
The $v_p and $v_q parameter should be Dpkg::Version objects.</dd>
</dl>
<dl>
<dt>
my $dep = deps_parse($line, %options)</dt>
<dd>
This function parses the dependency line and returns an object, either a Dpkg::Deps::AND or a Dpkg::Deps::Union. Various options can alter the behaviour of that function.</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
use_arch (defaults to 1)</dt>
<dd>
Take into account the architecture restriction part of the dependencies. Set to 0 to completely ignore that information.</dd>
</dl>
<dl>
<dt>
host_arch (defaults to the current architecture)</dt>
<dd>
Define the host architecture. By default it uses  <i>Dpkg::Arch::get_host_arch()</i> to identify the proper architecture.</dd>
</dl>
<dl>
<dt>
reduce_arch (defaults to 0)</dt>
<dd>
If set to 1, ignore dependencies that do not concern the current host architecture. This implicitely strips off the architecture restriction list so that the resulting dependencies are directly applicable to the current architecture.</dd>
</dl>
<dl>
<dt>
union (defaults to 0)</dt>
<dd>
If set to 1, returns a Dpkg::Deps::Union instead of a Dpkg::Deps::AND. Use this when parsing non-dependency fields like Conflicts.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
</div>
<dl>
<dt>
deps_compare($a, $b)</dt>
<dd>
Implements a comparison operator between two dependency objects. This function is mainly used to implement the  <i>sort()</i> method.</dd>
</dl>
</div>
<div class="section">
<h1>OBJECTS - Dpkg::Deps::*</h1> There are several kind of dependencies. A Dpkg::Deps::Simple dependency represents a single dependency statement (it relates to one package only). Dpkg::Deps::Multiple dependencies are built on top of this object and combine several dependencies in a different manners. Dpkg::Deps::AND represents the logical &quot;AND&quot; between dependencies while Dpkg::Deps::OR represents the logical &quot;OR&quot;. Dpkg::Deps::Multiple objects can contain Dpkg::Deps::Simple object as well as other Dpkg::Deps::Multiple objects.<div class="spacer">
</div>
In practice, the code is only meant to handle the realistic cases which, given Debian's dependencies structure, imply those restrictions: AND can contain Simple or OR objects, OR can only contain Simple objects.<div class="spacer">
</div>
Dpkg::Deps::KnownFacts is a special object that is used while evaluating dependencies and while trying to simplify them. It represents a set of installed packages along with the virtual packages that they might provide.<div class="subsection">
<h2>Common functions</h2><dl>
<dt>
$dep-&gt;<i>is_empty()</i></dt>
<dd>
Returns true if the dependency is empty and doesn't contain any useful information. This is true when a Dpkg::Deps::Simple object has not yet been initialized or when a (descendant of) Dpkg::Deps::Multiple contains an empty list of dependencies.</dd>
</dl>
<dl>
<dt>
$dep-&gt;<i>get_deps()</i></dt>
<dd>
Returns a list of sub-dependencies. For Dpkg::Deps::Simple it returns itself.</dd>
</dl>
<dl>
<dt>
$dep-&gt;output([$fh])</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
&quot;$dep&quot;</dt>
<dd>
Returns a string representing the dependency. If $fh is set, it prints the string to the filehandle.</dd>
</dl>
<dl>
<dt>
$dep-&gt;implies($other_dep)</dt>
<dd>
Returns 1 when $dep implies $other_dep. Returns 0 when $dep implies NOT($other_dep). Returns undef when there's no implication. $dep and $other_dep do not need to be of the same type.</dd>
</dl>
<dl>
<dt>
$dep-&gt;<i>sort()</i></dt>
<dd>
Sorts alphabetically the internal list of dependencies. It's a no-op for Dpkg::Deps::Simple objects.</dd>
</dl>
<dl>
<dt>
$dep-&gt;arch_is_concerned($arch)</dt>
<dd>
Returns true if the dependency applies to the indicated architecture. For multiple dependencies, it returns true if at least one of the sub-dependencies apply to this architecture.</dd>
</dl>
<dl>
<dt>
$dep-&gt;reduce_arch($arch)</dt>
<dd>
Simplifies the dependency to contain only information relevant to the given architecture. A Dpkg::Deps::Simple object can be left empty after this operation. For Dpkg::Deps::Multiple objects, the non-relevant sub-dependencies are simply removed.<div style="height: 1.00em;">
&#160;</div>
This trims off the architecture restriction list of Dpkg::Deps::Simple objects.</dd>
</dl>
<dl>
<dt>
$dep-&gt;get_evaluation($facts)</dt>
<dd>
Evaluates the dependency given a list of installed packages and a list of virtual packages provided. Those lists are part of the Dpkg::Deps::KnownFacts object given as parameters.<div style="height: 1.00em;">
&#160;</div>
Returns 1 when it's true, 0 when it's false, undef when some information is lacking to conclude.</dd>
</dl>
<dl>
<dt>
$dep-&gt;simplify_deps($facts, @assumed_deps)</dt>
<dd>
Simplifies the dependency as much as possible given the list of facts (see object Dpkg::Deps::KnownFacts) and a list of other dependencies that are known to be true.</dd>
</dl>
<dl>
<dt>
$dep-&gt;<i>has_arch_restriction()</i></dt>
<dd>
For a simple dependency, returns the package name if the dependency applies only to a subset of architectures.  For multiple dependencies, it returns the list of package names that have such a restriction.</dd>
</dl>
<dl>
<dt>
$dep-&gt;<i>reset()</i></dt>
<dd>
Clears any dependency information stored in $dep so that $dep-&gt;<i>is_empty()</i> returns true.</dd>
</dl>
</div>
<div class="subsection">
<h2>Dpkg::Deps::Simple</h2> Such an object has four interesting properties:<dl>
<dt>
package</dt>
<dd>
The package name (can be undef if the dependency has not been initialized or if the simplification of the dependency lead to its removal).</dd>
</dl>
<dl>
<dt>
relation</dt>
<dd>
The relational operator: &quot;=&quot;, &quot;&lt;&lt;&quot;, &quot;&lt;=&quot;, &quot;&gt;=&quot; or &quot;&gt;&gt;&quot;. It can be undefined if the dependency had no version restriction. In that case the following field is also undefined.</dd>
</dl>
<dl>
<dt>
version</dt>
<dd>
The version.</dd>
</dl>
<dl>
<dt>
arches</dt>
<dd>
The list of architectures where this dependency is applicable. It's undefined when there's no restriction, otherwise it's an array ref. It can contain an exclusion list, in that case each architecture is prefixed with an exclamation mark.</dd>
</dl>
<dl>
<dt>
archqual</dt>
<dd>
The arch qualifier of the dependency (can be undef if there's none). In the dependency &quot;python:any (&gt;= 2.6)&quot;, the arch qualifier is &quot;any&quot;.</dd>
</dl>
<div class="spacer">
</div>
<i>Methods</i><dl>
<dt>
$simple_dep-&gt;parse_string(&quot;dpkg-dev (&gt;= 1.14.8) [!hurd-i386]&quot;)</dt>
<dd>
Parses the dependency and modifies internal properties to match the parsed dependency.</dd>
</dl>
<dl>
<dt>
$simple_dep-&gt;merge_union($other_dep)</dt>
<dd>
Returns true if $simple_dep could be modified to represent the union of both dependencies. Otherwise returns false.</dd>
</dl>
</div>
<div class="subsection">
<h2>Dpkg::Deps::Multiple</h2> This is the base class for Dpkg::Deps::{AND,OR,Union}. It implements the following methods:<dl>
<dt>
$mul-&gt;add($dep)</dt>
<dd>
Adds a new dependency object at the end of the list.</dd>
</dl>
</div>
<div class="subsection">
<h2>Dpkg::Deps::AND</h2> This object represents a list of dependencies who must be met at the same time.<dl>
<dt>
$and-&gt;output([$fh])</dt>
<dd>
The output method uses &quot;, &quot; to join the list of sub-dependencies.</dd>
</dl>
</div>
<div class="subsection">
<h2>Dpkg::Deps::OR</h2> This object represents a list of dependencies of which only one must be met for the dependency to be true.<dl>
<dt>
$or-&gt;output([$fh])</dt>
<dd>
The output method uses &quot; | &quot; to join the list of sub-dependencies.</dd>
</dl>
</div>
<div class="subsection">
<h2>Dpkg::Deps::Union</h2> This object represents a list of relationships.<dl>
<dt>
$union-&gt;output([$fh])</dt>
<dd>
The output method uses &quot;, &quot; to join the list of relationships.</dd>
</dl>
<dl>
<dt>
$union-&gt;implies($other_dep)</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$union-&gt;get_evaluation($other_dep)</dt>
<dd>
Those methods are not meaningful for this object and always return undef.</dd>
</dl>
<dl>
<dt>
$union-&gt;simplify_deps($facts)</dt>
<dd>
The simplication is done to generate an union of all the relationships. It uses $simple_dep-&gt;merge_union($other_dep) to get its job done.</dd>
</dl>
</div>
<div class="subsection">
<h2>Dpkg::Deps::KnownFacts</h2> This object represents a list of installed packages and a list of virtual packages provided (by the set of installed packages).<dl>
<dt>
my $facts = Dpkg::Deps::KnownFacts-&gt;<i>new()</i>;</dt>
<dd>
Creates a new object.</dd>
</dl>
<dl>
<dt>
$facts-&gt;add_installed_package($package, $version, $arch, $multiarch)</dt>
<dd>
Records that the given version of the package is installed. If $version/$arch is undefined we know that the package is installed but we don't know which version/architecture it is. $multiarch is the Multi-Arch field of the package. If $multiarch is undef, it will be equivalent to &quot;Multi-Arch: no&quot;.<div style="height: 1.00em;">
&#160;</div>
Note that $multiarch is only used if $arch is provided.</dd>
</dl>
<dl>
<dt>
$facts-&gt;add_provided_package($virtual, $relation, $version, $by)</dt>
<dd>
Records that the &quot;$by&quot; package provides the $virtual package. $relation and $version correspond to the associated relation given in the Provides field. This might be used in the future for versioned provides.</dd>
</dl>
<dl>
<dt>
my ($check, $param) = $facts-&gt;check_package($package)</dt>
<dd>
$check is one when the package is found. For a real package, $param contains the version. For a virtual package, $param contains an array reference containing the list of packages that provide it (each package is listed as [ $provider, $relation, $version ]).<div style="height: 1.00em;">
&#160;</div>
This function is obsolete and should not be used. Dpkg::Deps::KnownFacts is only meant to be filled with data and then passed to Dpkg::Deps methods where appropriate, but it should not be directly queried.</dd>
</dl>
</div>
</div>
<div class="section">
<h1>CHANGES</h1><div class="subsection">
<h2>Version 1.01</h2><dl>
<dt>
&#8226;</dt>
<dd>
Add new $dep-&gt;<i>reset()</i> method that all dependency objects support.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Dpkg::Deps::Simple now recognizes the arch qualifier &quot;any&quot; and stores it in the &quot;archqual&quot; property when present.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Dpkg::Deps::KnownFacts-&gt;<i>add_installed_package()</i> now accepts 2 supplementary parameters ($arch and $multiarch).</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Dpkg::Deps::KnownFacts-&gt;<i>check_package()</i> is obsolete, it should not have been part of the public API.</dd>
</dl>
</div>
</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-10-14</td>
<td class="foot-os">
1.16.1.2</td>
</tr>
</table>
</div>
</body>
</html>

