<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
curl_multi_socket_action(3)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
curl_multi_socket_action(3)</td>
<td class="head-vol">
libcurl Manual</td>
<td class="head-rtitle">
curl_multi_socket_action(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> curl_multi_socket_action - reads/writes available data given an action</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
#include &lt;curl/curl.h&gt;<div class="spacer">
</div>
<br/>
CURLMcode curl_multi_socket_action(CURLM * multi_handle,<br/>
                                   curl_socket_t sockfd, int ev_bitmask,<br/>
                                   int *running_handles);<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> When the application has detected action on a socket handled by libcurl, it should call  <i>curl_multi_socket_action(3)</i> with the <b>sockfd</b> argument set to the socket with the action. When the events on a socket are known, they can be passed as an events bitmask  <b>ev_bitmask</b> by first setting  <b>ev_bitmask</b> to 0, and then adding using bitwise OR (|) any combination of events to be chosen from CURL_CSELECT_IN, CURL_CSELECT_OUT or CURL_CSELECT_ERR. When the events on a socket are unknown, pass 0 instead, and libcurl will test the descriptor internally.<div style="height: 1.00em;">
&#160;</div>
At return, the integer <b>running_handles</b> points to will contain the number of running easy handles within the multi handle. When this number reaches zero, all transfers are complete/done. When you call  <i>curl_multi_socket_action(3)</i> on a specific socket and the counter decreases by one, it DOES NOT necessarily mean that this exact socket/transfer is the one that completed. Use  <i>curl_multi_info_read(3)</i> to figure out which easy handle that completed.<div style="height: 1.00em;">
&#160;</div>
The <b>curl_multi_socket_action(3)</b> functions inform the application about updates in the socket (file descriptor) status by doing none, one, or multiple calls to the socket callback function set with the CURLMOPT_SOCKETFUNCTION option to  <i>curl_multi_setopt(3)</i>. They update the status with changes since the previous time the callback was called.<div style="height: 1.00em;">
&#160;</div>
Get the timeout time by setting the <i>CURLMOPT_TIMERFUNCTION</i> option with  <i>curl_multi_setopt(3)</i>. Your application will then get called with information on how long to wait for socket actions at most before doing the timeout action: call the  <b>curl_multi_socket_action(3)</b> function with the  <b>sockfd</b> argument set to CURL_SOCKET_TIMEOUT. You can also use the  <i>curl_multi_timeout(3)</i> function to poll the value at any given time, but for an event-based system using the callback is far better than relying on polling the timeout value.</div>
<div class="section">
<h1>CALLBACK DETAILS</h1> The socket  <b>callback</b> function uses a prototype like this<div class="spacer">
</div>
<br/>
  int curl_socket_callback(CURL *easy,      /* easy handle */<br/>
                           curl_socket_t s, /* socket */<br/>
                           int action,      /* see values below */<br/>
                           void *userp,    /* private callback pointer */<br/>
                           void *socketp); /* private socket pointer */<div class="spacer">
</div>
<br/>
The callback MUST return 0.<div style="height: 1.00em;">
&#160;</div>
The <i>easy</i> argument is a pointer to the easy handle that deals with this particular socket. Note that a single handle may work with several sockets simultaneously.<div style="height: 1.00em;">
&#160;</div>
The <i>s</i> argument is the actual socket value as you use it within your system.<div style="height: 1.00em;">
&#160;</div>
The <i>action</i> argument to the callback has one of five values:<div style="margin-left: 5.00ex;">
<dl>
<dt>
CURL_POLL_NONE (0)</dt>
<dd>
register, not interested in readiness (yet)</dd>
</dl>
<dl>
<dt>
CURL_POLL_IN (1)</dt>
<dd>
register, interested in read readiness</dd>
</dl>
<dl>
<dt>
CURL_POLL_OUT (2)</dt>
<dd>
register, interested in write readiness</dd>
</dl>
<dl>
<dt>
CURL_POLL_INOUT (3)</dt>
<dd>
register, interested in both read and write readiness</dd>
</dl>
<dl>
<dt>
CURL_POLL_REMOVE (4)</dt>
<dd>
unregister</dd>
</dl>
</div>
<div style="height: 1.00em;">
&#160;</div>
The <i>socketp</i> argument is a private pointer you have previously set with  <i>curl_multi_assign(3)</i> to be associated with the <i>s</i> socket. If no pointer has been set, socketp will be NULL. This argument is of course a service to applications that want to keep certain data or structs that are strictly associated to the given socket.<div style="height: 1.00em;">
&#160;</div>
The <i>userp</i> argument is a private pointer you have previously set with  <i>curl_multi_setopt(3)</i> and the CURLMOPT_SOCKETDATA option.</div>
<div class="section">
<h1>RETURN VALUE</h1> CURLMcode type, general libcurl multi interface error code.<div style="height: 1.00em;">
&#160;</div>
Before version 7.20.0: If you receive <i>CURLM_CALL_MULTI_PERFORM</i>, this basically means that you should call  <i>curl_multi_socket_action(3)</i> again before you wait for more actions on libcurl's sockets. You don't have to do it immediately, but the return code means that libcurl may have more data available to return or that there may be more data to send off before it is &quot;satisfied&quot;.<div style="height: 1.00em;">
&#160;</div>
The return code from this function is for the whole multi stack.  Problems still might have occurred on individual transfers even when one of these functions return OK.</div>
<div class="section">
<h1>TYPICAL USAGE</h1> 1. Create a multi handle<div style="height: 1.00em;">
&#160;</div>
2. Set the socket callback with CURLMOPT_SOCKETFUNCTION<div style="height: 1.00em;">
&#160;</div>
3. Set the timeout callback with CURLMOPT_TIMERFUNCTION, to get to know what timeout value to use when waiting for socket activities.<div style="height: 1.00em;">
&#160;</div>
4. Add easy handles with curl_multi_add_handle()<div style="height: 1.00em;">
&#160;</div>
5. Provide some means to manage the sockets libcurl is using, so you can check them for activity. This can be done through your application code, or by way of an external library such as libevent or glib.<div style="height: 1.00em;">
&#160;</div>
6. Call curl_multi_socket_action() to kickstart everything. To get one or more callbacks called.<div style="height: 1.00em;">
&#160;</div>
7. Wait for activity on any of libcurl's sockets, use the timeout value your callback has been told<div style="height: 1.00em;">
&#160;</div>
8, When activity is detected, call curl_multi_socket_action() for the socket(s) that got action. If no activity is detected and the timeout expires, call  <i>curl_multi_socket_action(3)</i> with <i>CURL_SOCKET_TIMEOUT</i></div>
<div class="section">
<h1>AVAILABILITY</h1> This function was added in libcurl 7.15.4, and is deemed stable since 7.16.0.</div>
<div class="section">
<h1>SEE ALSO</h1> <b>curl_multi_cleanup</b>(3), <b>curl_multi_init</b>(3),  <b>curl_multi_fdset</b>(3), <b>curl_multi_info_read</b>(3),  <b>the hiperfifo.c example</b></div>
<table class="foot">
<tr>
<td class="foot-date">
9 Jul 2006</td>
<td class="foot-os">
libcurl 7.16.0</td>
</tr>
</table>
</div>
</body>
</html>

