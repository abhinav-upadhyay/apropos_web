<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Log::Log4perl(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Log::Log4perl(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
Log::Log4perl(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Log::Log4perl - Log4j implementation for Perl</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
        # Easy mode if you like it simple ...<br/>
<br/>
    use Log::Log4perl qw(:easy);<br/>
    Log::Log4perl-&gt;easy_init($ERROR);<br/>
<br/>
    DEBUG &quot;This doesn't go anywhere&quot;;<br/>
    ERROR &quot;This gets logged&quot;;<br/>
<br/>
        # ... or standard mode for more features:<br/>
<br/>
    Log::Log4perl::init('/etc/log4perl.conf');<br/>
    <br/>
    --or--<br/>
    <br/>
        # Check config every 10 secs<br/>
    Log::Log4perl::init_and_watch('/etc/log4perl.conf',10);<br/>
<br/>
    --then--<br/>
    <br/>
    $logger = Log::Log4perl-&gt;get_logger('house.bedrm.desk.topdrwr');<br/>
    <br/>
    $logger-&gt;debug('this is a debug message');<br/>
    $logger-&gt;info('this is an info message');<br/>
    $logger-&gt;warn('etc');<br/>
    $logger-&gt;error('..');<br/>
    $logger-&gt;fatal('..');<br/>
    <br/>
    #####/etc/log4perl.conf###############################<br/>
    log4perl.logger.house              = WARN,  FileAppndr1<br/>
    log4perl.logger.house.bedroom.desk = DEBUG, FileAppndr1<br/>
    <br/>
    log4perl.appender.FileAppndr1      = Log::Log4perl::Appender::File<br/>
    log4perl.appender.FileAppndr1.filename = desk.log <br/>
    log4perl.appender.FileAppndr1.layout   = \<br/>
                            Log::Log4perl::Layout::SimpleLayout<br/>
    ######################################################<br/>
</div>
<div class="section">
<h1>ABSTRACT</h1><br/>
    Log::Log4perl provides a powerful logging API for your application<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> Log::Log4perl lets you remote-control and fine-tune the logging behaviour of your system from the outside. It implements the widely popular (Java-based) Log4j logging package in pure Perl.<div class="spacer">
</div>
<b>For a detailed tutorial on Log::Log4perl usage, please read</b><div class="spacer">
</div>
<br/>
    http://www.perl.com/pub/a/2002/09/11/log4perl.html<br/>
<div class="spacer">
</div>
Logging beats a debugger if you want to know what's going on in your code during runtime. However, traditional logging packages are too static and generate a flood of log messages in your log files that won't help you.<div class="spacer">
</div>
&quot;Log::Log4perl&quot; is different. It allows you to control the number of logging messages generated at three different levels:<dl>
<dt>
&#8226;</dt>
<dd>
At a central location in your system (either in a configuration file or in the startup code) you specify  <i>which components</i> (classes, functions) of your system should generate logs.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
You specify how detailed the logging of these components should be by specifying logging  <i>levels</i>.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
You also specify which so-called <i>appenders</i> you want to feed your log messages to (&quot;Print it to the screen and also append it to /tmp/my.log&quot;) and which format (&quot;Write the date first, then the file name and line number, and then the log message&quot;) they should be in.</dd>
</dl>
<div class="spacer">
</div>
This is a very powerful and flexible mechanism. You can turn on and off your logs at any time, specify the level of detail and make that dependent on the subsystem that's currently executed.<div class="spacer">
</div>
Let me give you an example: You might find out that your system has a problem in the &quot;MySystem::Helpers::ScanDir&quot; component. Turning on detailed debugging logs all over the system would generate a flood of useless log messages and bog your system down beyond recognition. With &quot;Log::Log4perl&quot;, however, you can tell the system: &quot;Continue to log only severe errors to the log file. Open a second log file, turn on full debug logs in the &quot;MySystem::Helpers::ScanDir&quot; component and dump all messages originating from there into the new log file&quot;. And all this is possible by just changing the parameters in a configuration file, which your system can re-read even while it's running!</div>
<div class="section">
<h1>How to use it</h1> The &quot;Log::Log4perl&quot; package can be initialized in two ways: Either via Perl commands or via a &quot;log4j&quot;-style configuration file.<div class="subsection">
<h2>Initialize via a configuration file</h2> This is the easiest way to prepare your system for using &quot;Log::Log4perl&quot;. Use a configuration file like this:<div class="spacer">
</div>
<br/>
    ############################################################<br/>
    # A simple root logger with a Log::Log4perl::Appender::File <br/>
    # file appender in Perl.<br/>
    ############################################################<br/>
    log4perl.rootLogger=ERROR, LOGFILE<br/>
    <br/>
    log4perl.appender.LOGFILE=Log::Log4perl::Appender::File<br/>
    log4perl.appender.LOGFILE.filename=/var/log/myerrs.log<br/>
    log4perl.appender.LOGFILE.mode=append<br/>
    <br/>
    log4perl.appender.LOGFILE.layout=PatternLayout<br/>
    log4perl.appender.LOGFILE.layout.ConversionPattern=[%r] %F %L %c - %m%n<br/>
<div class="spacer">
</div>
These lines define your standard logger that's appending severe errors to &quot;/var/log/myerrs.log&quot;, using the format<div class="spacer">
</div>
<br/>
    [millisecs] source-filename line-number class - message newline<br/>
<div class="spacer">
</div>
Assuming that this configuration file is saved as &quot;log.conf&quot;, you need to read it in in the startup section of your code, using the following commands:<div class="spacer">
</div>
<br/>
  use Log::Log4perl;<br/>
  Log::Log4perl-&gt;init(&quot;log.conf&quot;);<br/>
<div class="spacer">
</div>
After that's done <i>somewhere</i> in the code, you can retrieve logger objects  <i>anywhere</i> in the code. Note that there's no need to carry any logger references around with your functions and methods. You can get a logger anytime via a singleton mechanism:<div class="spacer">
</div>
<br/>
    package My::MegaPackage;<br/>
    use  Log::Log4perl;<br/>
<br/>
    sub some_method {<br/>
        my($param) = @_;<br/>
<br/>
        my $log = Log::Log4perl-&gt;get_logger(&quot;My::MegaPackage&quot;);<br/>
<br/>
        $log-&gt;debug(&quot;Debug message&quot;);<br/>
        $log-&gt;info(&quot;Info message&quot;);<br/>
        $log-&gt;error(&quot;Error message&quot;);<br/>
<br/>
        ...<br/>
    }<br/>
<div class="spacer">
</div>
With the configuration file above, &quot;Log::Log4perl&quot; will write &quot;Error message&quot; to the specified log file, but won't do anything for the &quot;debug()&quot; and &quot;info()&quot; calls, because the log level has been set to &quot;ERROR&quot; for all components in the first line of configuration file shown above.<div class="spacer">
</div>
Why &quot;Log::Log4perl-&gt;get_logger&quot; and not &quot;Log::Log4perl-&gt;new&quot;? We don't want to create a new object every time. Usually in OO-Programming, you create an object once and use the reference to it to call its methods. However, this requires that you pass around the object to all functions and the last thing we want is pollute each and every function/method we're using with a handle to the &quot;Logger&quot;:<div class="spacer">
</div>
<br/>
    sub function {  # Brrrr!!<br/>
        my($logger, $some, $other, $parameters) = @_;<br/>
    }<br/>
<div class="spacer">
</div>
Instead, if a function/method wants a reference to the logger, it just calls the Logger's static &quot;get_logger($category)&quot; method to obtain a reference to the  <i>one and only</i> possible logger object of a certain category. That's called a  <i>singleton</i> if you're a Gamma fan.<div class="spacer">
</div>
How does the logger know which messages it is supposed to log and which ones to suppress? &quot;Log::Log4perl&quot; works with inheritance: The config file above didn't specify anything about &quot;My::MegaPackage&quot;. And yet, we've defined a logger of the category &quot;My::MegaPackage&quot;. In this case, &quot;Log::Log4perl&quot; will walk up the namespace hierarchy (&quot;My&quot; and then we're at the root) to figure out if a log level is defined somewhere. In the case above, the log level at the root (root  <i>always</i> defines a log level, but not necessarily an appender) defines that the log level is supposed to be &quot;ERROR&quot; -- meaning that  <i>DEBUG</i> and  <i>INFO</i> messages are suppressed. Note that this 'inheritance' is unrelated to Perl's class inheritance, it is merely related to the logger namespace.</div>
<div class="subsection">
<h2>Log Levels</h2> There are six predefined log levels: &quot;FATAL&quot;, &quot;ERROR&quot;, &quot;WARN&quot;, &quot;INFO&quot;, &quot;DEBUG&quot;, and &quot;TRACE&quot; (in descending priority). Your configured logging level has to at least match the priority of the logging message.<div class="spacer">
</div>
If your configured logging level is &quot;WARN&quot;, then messages logged with &quot;info()&quot;, &quot;debug()&quot;, and &quot;trace()&quot; will be suppressed. &quot;fatal()&quot;, &quot;error()&quot; and &quot;warn()&quot; will make their way through, because their priority is higher or equal than the configured setting.<div class="spacer">
</div>
Instead of calling the methods<div class="spacer">
</div>
<br/>
    $logger-&gt;trace(&quot;...&quot;);  # Log a trace message<br/>
    $logger-&gt;debug(&quot;...&quot;);  # Log a debug message<br/>
    $logger-&gt;info(&quot;...&quot;);   # Log a info message<br/>
    $logger-&gt;warn(&quot;...&quot;);   # Log a warn message<br/>
    $logger-&gt;error(&quot;...&quot;);  # Log a error message<br/>
    $logger-&gt;fatal(&quot;...&quot;);  # Log a fatal message<br/>
<div class="spacer">
</div>
you could also call the &quot;log()&quot; method with the appropriate level using the constants defined in &quot;Log::Log4perl::Level&quot;:<div class="spacer">
</div>
<br/>
    use Log::Log4perl::Level;<br/>
<br/>
    $logger-&gt;log($TRACE, &quot;...&quot;);<br/>
    $logger-&gt;log($DEBUG, &quot;...&quot;);<br/>
    $logger-&gt;log($INFO, &quot;...&quot;);<br/>
    $logger-&gt;log($WARN, &quot;...&quot;);<br/>
    $logger-&gt;log($ERROR, &quot;...&quot;);<br/>
    $logger-&gt;log($FATAL, &quot;...&quot;);<br/>
<div class="spacer">
</div>
But nobody does that, really. Neither does anyone need more logging levels than these predefined ones. If you think you do, I would suggest you look into steering your logging behaviour via the category mechanism.<div class="spacer">
</div>
If you need to find out if the currently configured logging level would allow a logger's logging statement to go through, use the logger's &quot;is_ <i>level</i>()&quot; methods:<div class="spacer">
</div>
<br/>
    $logger-&gt;is_trace()    # True if trace messages would go through<br/>
    $logger-&gt;is_debug()    # True if debug messages would go through<br/>
    $logger-&gt;is_info()     # True if info messages would go through<br/>
    $logger-&gt;is_warn()     # True if warn messages would go through<br/>
    $logger-&gt;is_error()    # True if error messages would go through<br/>
    $logger-&gt;is_fatal()    # True if fatal messages would go through<br/>
<div class="spacer">
</div>
Example: &quot;$logger-&gt;is_warn()&quot; returns true if the logger's current level, as derived from either the logger's category (or, in absence of that, one of the logger's parent's level setting) is $WARN, $ERROR or $FATAL.<div class="spacer">
</div>
Also available are a series of more Java-esque functions which return the same values. These are of the format &quot;is <i>Level</i>Enabled()&quot;, so &quot;$logger-&gt;isDebugEnabled()&quot; is synonymous to &quot;$logger-&gt;is_debug()&quot;.<div class="spacer">
</div>
These level checking functions will come in handy later, when we want to block unnecessary expensive parameter construction in case the logging level is too low to log the statement anyway, like in:<div class="spacer">
</div>
<br/>
    if($logger-&gt;is_error()) {<br/>
        $logger-&gt;error(&quot;Erroneous array: @super_long_array&quot;);<br/>
    }<br/>
<div class="spacer">
</div>
If we had just written<div class="spacer">
</div>
<br/>
    $logger-&gt;error(&quot;Erroneous array: @super_long_array&quot;);<br/>
<div class="spacer">
</div>
then Perl would have interpolated @super_long_array into the string via an expensive operation only to figure out shortly after that the string can be ignored entirely because the configured logging level is lower than $ERROR.<div class="spacer">
</div>
The to-be-logged message passed to all of the functions described above can consist of an arbitrary number of arguments, which the logging functions just chain together to a single string. Therefore<div class="spacer">
</div>
<br/>
    $logger-&gt;debug(&quot;Hello &quot;, &quot;World&quot;, &quot;!&quot;);  # and<br/>
    $logger-&gt;debug(&quot;Hello World!&quot;);<br/>
<div class="spacer">
</div>
are identical.<div class="spacer">
</div>
Note that even if one of the methods above returns true, it doesn't necessarily mean that the message will actually get logged. What  <i>is_debug()</i> checks is that the logger used is configured to let a message of the given priority (DEBUG) through. But after this check, Log4perl will eventually apply custom filters and forward the message to one or more appenders. None of this gets checked by  <i>is_xxx()</i>, for the simple reason that it's impossible to know what a custom filter does with a message without having the actual message or what an appender does to a message without actually having it log it.</div>
<div class="subsection">
<h2>Log and die or warn</h2> Often, when you croak / carp / warn / die, you want to log those messages. Rather than doing the following:<div class="spacer">
</div>
<br/>
    $logger-&gt;fatal($err) &amp;&amp; die($err);<br/>
<div class="spacer">
</div>
you can use the following:<div class="spacer">
</div>
<br/>
    $logger-&gt;logwarn();<br/>
    $logger-&gt;logdie();<br/>
<div class="spacer">
</div>
These print out log messages in the WARN and FATAL level, respectively, and then call the built-in  <i>warn()</i> and <i>die()</i> functions. Since there is an ERROR level between WARN and FATAL, there are two additional helper functions in case you'd like to use ERROR for either  <i>warn()</i> or <i>die()</i>:<div class="spacer">
</div>
<br/>
    $logger-&gt;error_warn();<br/>
    $logger-&gt;error_die();<br/>
<div class="spacer">
</div>
Finally, there's the Carp functions that do just what the Carp functions do, but with logging:<div class="spacer">
</div>
<br/>
    $logger-&gt;logcarp();        # warn w/ 1-level stack trace<br/>
    $logger-&gt;logcluck();       # warn w/ full stack trace<br/>
    $logger-&gt;logcroak();       # die w/ 1-level stack trace<br/>
    $logger-&gt;logconfess();     # die w/ full stack trace<br/>
</div>
<div class="subsection">
<h2>Appenders</h2> If you don't define any appenders, nothing will happen. Appenders will be triggered whenever the configured logging level requires a message to be logged and not suppressed.<div class="spacer">
</div>
&quot;Log::Log4perl&quot; doesn't define any appenders by default, not even the root logger has one.<div class="spacer">
</div>
&quot;Log::Log4perl&quot; already comes with a standard set of appenders:<div class="spacer">
</div>
<br/>
    Log::Log4perl::Appender::Screen<br/>
    Log::Log4perl::Appender::ScreenColoredLevels<br/>
    Log::Log4perl::Appender::File<br/>
    Log::Log4perl::Appender::Socket<br/>
    Log::Log4perl::Appender::DBI<br/>
    Log::Log4perl::Appender::Synchronized<br/>
    Log::Log4perl::Appender::RRDs<br/>
<div class="spacer">
</div>
to log to the screen, to files and to databases.<div class="spacer">
</div>
On CPAN, you can find additional appenders like<div class="spacer">
</div>
<br/>
    Log::Log4perl::Layout::XMLLayout<br/>
<div class="spacer">
</div>
by Guido Carls &lt;gcarls@cpan.org&gt;. It allows for hooking up Log::Log4perl with the graphical Log Analyzer Chainsaw (see &quot;Can I use Log::Log4perl with log4j's Chainsaw?&quot; in Log::Log4perl::FAQ).</div>
<div class="subsection">
<h2>Additional Appenders via Log::Dispatch</h2> &quot;Log::Log4perl&quot; also supports  <i>Dave Rolskys</i> excellent &quot;Log::Dispatch&quot; framework which implements a wide variety of different appenders.<div class="spacer">
</div>
Here's the list of appender modules currently available via &quot;Log::Dispatch&quot;:<div class="spacer">
</div>
<br/>
       Log::Dispatch::ApacheLog<br/>
       Log::Dispatch::DBI (by Tatsuhiko Miyagawa)<br/>
       Log::Dispatch::Email,<br/>
       Log::Dispatch::Email::MailSend,<br/>
       Log::Dispatch::Email::MailSendmail,<br/>
       Log::Dispatch::Email::MIMELite<br/>
       Log::Dispatch::File<br/>
       Log::Dispatch::FileRotate (by Mark Pfeiffer)<br/>
       Log::Dispatch::Handle<br/>
       Log::Dispatch::Screen<br/>
       Log::Dispatch::Syslog<br/>
       Log::Dispatch::Tk (by Dominique Dumont)<br/>
<div class="spacer">
</div>
Please note that in order to use any of these additional appenders, you have to fetch Log::Dispatch from CPAN and install it. Also the particular appender you're using might require installing the particular module.<div class="spacer">
</div>
For additional information on appenders, please check the Log::Log4perl::Appender manual page.</div>
<div class="subsection">
<h2>Appender Example</h2> Now let's assume that we want to log &quot;info()&quot; or higher prioritized messages in the &quot;Foo::Bar&quot; category to both STDOUT and to a log file, say &quot;test.log&quot;. In the initialization section of your system, just define two appenders using the readily available &quot;Log::Log4perl::Appender::File&quot; and &quot;Log::Log4perl::Appender::Screen&quot; modules:<div class="spacer">
</div>
<br/>
  use Log::Log4perl;<br/>
<br/>
     # Configuration in a string ...<br/>
  my $conf = q(<br/>
    log4perl.category.Foo.Bar          = INFO, Logfile, Screen<br/>
<br/>
    log4perl.appender.Logfile          = Log::Log4perl::Appender::File<br/>
    log4perl.appender.Logfile.filename = test.log<br/>
    log4perl.appender.Logfile.layout   = Log::Log4perl::Layout::PatternLayout<br/>
    log4perl.appender.Logfile.layout.ConversionPattern = [%r] %F %L %m%n<br/>
<br/>
    log4perl.appender.Screen         = Log::Log4perl::Appender::Screen<br/>
    log4perl.appender.Screen.stderr  = 0<br/>
    log4perl.appender.Screen.layout = Log::Log4perl::Layout::SimpleLayout<br/>
  );<br/>
<br/>
     # ... passed as a reference to init()<br/>
  Log::Log4perl::init( \$conf );<br/>
<div class="spacer">
</div>
Once the initialization shown above has happened once, typically in the startup code of your system, just use the defined logger anywhere in your system:<div class="spacer">
</div>
<br/>
  ##########################<br/>
  # ... in some function ...<br/>
  ##########################<br/>
  my $log = Log::Log4perl::get_logger(&quot;Foo::Bar&quot;);<br/>
<br/>
    # Logs both to STDOUT and to the file test.log<br/>
  $log-&gt;info(&quot;Important Info!&quot;);<br/>
<div class="spacer">
</div>
The &quot;layout&quot; settings specified in the configuration section define the format in which the message is going to be logged by the specified appender. The format shown for the file appender is logging not only the message but also the number of milliseconds since the program has started (%r), the name of the file the call to the logger has happened and the line number there (%F and %L), the message itself (%m) and a OS-specific newline character (%n):<div class="spacer">
</div>
<br/>
    [187] ./myscript.pl 27 Important Info!<br/>
<div class="spacer">
</div>
The screen appender above, on the other hand, uses a &quot;SimpleLayout&quot;, which logs the debug level, a hyphen (-) and the log message:<div class="spacer">
</div>
<br/>
    INFO - Important Info!<br/>
<div class="spacer">
</div>
For more detailed info on layout formats, see &quot;Log Layouts&quot;.<div class="spacer">
</div>
In the configuration sample above, we chose to define a <i>category</i> logger (&quot;Foo::Bar&quot;). This will cause only messages originating from this specific category logger to be logged in the defined format and locations.</div>
<div class="subsection">
<h2>Logging newlines</h2> There's some controversy between different logging systems as to when and where newlines are supposed to be added to logged messages.<div class="spacer">
</div>
The Log4perl way is that a logging statement <i>should not</i> contain a newline:<div class="spacer">
</div>
<br/>
    $logger-&gt;info(&quot;Some message&quot;);<br/>
    $logger-&gt;info(&quot;Another message&quot;);<br/>
<div class="spacer">
</div>
If this is supposed to end up in a log file like<div class="spacer">
</div>
<br/>
    Some message<br/>
    Another message<br/>
<div class="spacer">
</div>
then an appropriate appender layout like &quot;%m%n&quot; will take care of adding a newline at the end of each message to make sure every message is printed on its own line.<div class="spacer">
</div>
Other logging systems, Log::Dispatch in particular, recommend adding the newline to the log statement. This doesn't work well, however, if you, say, replace your file appender by a database appender, and all of a sudden those newlines scattered around the code don't make sense anymore.<div class="spacer">
</div>
Assigning matching layouts to different appenders and leaving newlines out of the code solves this problem. If you inherited code that has logging statements with newlines and want to make it work with Log4perl, read the Log::Log4perl::Layout::PatternLayout documentation on how to accomplish that.</div>
<div class="subsection">
<h2>Configuration files</h2> As shown above, you can define &quot;Log::Log4perl&quot; loggers both from within your Perl code or from configuration files. The latter have the unbeatable advantage that you can modify your system's logging behaviour without interfering with the code at all. So even if your code is being run by somebody who's totally oblivious to Perl, they still can adapt the module's logging behaviour to their needs.<div class="spacer">
</div>
&quot;Log::Log4perl&quot; has been designed to understand &quot;Log4j&quot; configuration files -- as used by the original Java implementation. Instead of reiterating the format description in [2], let me just list three examples (also derived from [2]), which should also illustrate how it works:<div class="spacer">
</div>
<br/>
    log4j.rootLogger=DEBUG, A1<br/>
    log4j.appender.A1=org.apache.log4j.ConsoleAppender<br/>
    log4j.appender.A1.layout=org.apache.log4j.PatternLayout<br/>
    log4j.appender.A1.layout.ConversionPattern=%-4r %-5p %c %x - %m%n<br/>
<div class="spacer">
</div>
This enables messages of priority &quot;DEBUG&quot; or higher in the root hierarchy and has the system write them to the console. &quot;ConsoleAppender&quot; is a Java appender, but &quot;Log::Log4perl&quot; jumps through a significant number of hoops internally to map these to their corresponding Perl classes, &quot;Log::Log4perl::Appender::Screen&quot; in this case.<div class="spacer">
</div>
Second example:<div class="spacer">
</div>
<br/>
    log4perl.rootLogger=DEBUG, A1<br/>
    log4perl.appender.A1=Log::Log4perl::Appender::Screen<br/>
    log4perl.appender.A1.layout=PatternLayout<br/>
    log4perl.appender.A1.layout.ConversionPattern=%d %-5p %c - %m%n<br/>
    log4perl.logger.com.foo=WARN<br/>
<div class="spacer">
</div>
This defines two loggers: The root logger and the &quot;com.foo&quot; logger. The root logger is easily triggered by debug-messages, but the &quot;com.foo&quot; logger makes sure that messages issued within the &quot;Com::Foo&quot; component and below are only forwarded to the appender if they're of priority  <i>warning</i> or higher.<div class="spacer">
</div>
Note that the &quot;com.foo&quot; logger doesn't define an appender. Therefore, it will just propagate the message up the hierarchy until the root logger picks it up and forwards it to the one and only appender of the root category, using the format defined for it.<div class="spacer">
</div>
Third example:<div class="spacer">
</div>
<br/>
    log4j.rootLogger=debug, stdout, R<br/>
    log4j.appender.stdout=org.apache.log4j.ConsoleAppender<br/>
    log4j.appender.stdout.layout=org.apache.log4j.PatternLayout<br/>
    log4j.appender.stdout.layout.ConversionPattern=%5p (%F:%L) - %m%n<br/>
    log4j.appender.R=org.apache.log4j.RollingFileAppender<br/>
    log4j.appender.R.File=example.log<br/>
    log4j.appender.R.layout=org.apache.log4j.PatternLayout<br/>
    log4j.appender.R.layout.ConversionPattern=%p %c - %m%n<br/>
<div class="spacer">
</div>
The root logger defines two appenders here: &quot;stdout&quot;, which uses &quot;org.apache.log4j.ConsoleAppender&quot; (ultimately mapped by &quot;Log::Log4perl&quot; to &quot;Log::Log4perl::Appender::Screen&quot;) to write to the screen. And &quot;R&quot;, a &quot;org.apache.log4j.RollingFileAppender&quot; (mapped by &quot;Log::Log4perl&quot; to &quot;Log::Dispatch::FileRotate&quot; with the &quot;File&quot; attribute specifying the log file.<div class="spacer">
</div>
See Log::Log4perl::Config for more examples and syntax explanations.</div>
<div class="subsection">
<h2>Log Layouts</h2> If the logging engine passes a message to an appender, because it thinks it should be logged, the appender doesn't just write it out haphazardly. There's ways to tell the appender how to format the message and add all sorts of interesting data to it: The date and time when the event happened, the file, the line number, the debug level of the logger and others.<div class="spacer">
</div>
There's currently two layouts defined in &quot;Log::Log4perl&quot;: &quot;Log::Log4perl::Layout::SimpleLayout&quot; and &quot;Log::Log4perl::Layout::PatternLayout&quot;:<dl>
<dt>
&quot;Log::Log4perl::SimpleLayout&quot;</dt>
<dd>
formats a message in a simple way and just prepends it by the debug level and a hyphen: &quot;&quot;$level - $message&quot;, for example &quot;FATAL - Can't open password file&quot;.</dd>
</dl>
<dl>
<dt>
&quot;Log::Log4perl::Layout::PatternLayout&quot;</dt>
<dd>
on the other hand is very powerful and allows for a very flexible format in &quot;printf&quot;-style. The format string can contain a number of placeholders which will be replaced by the logging engine when it's time to log the message:<div style="height: 1.00em;">
&#160;</div>
<br/>
    %c Category of the logging event.<br/>
    %C Fully qualified package (or class) name of the caller<br/>
    %d Current date in yyyy/MM/dd hh:mm:ss format<br/>
    %F File where the logging event occurred<br/>
    %H Hostname (if Sys::Hostname is available)<br/>
    %l Fully qualified name of the calling method followed by the<br/>
       callers source the file name and line number between <br/>
       parentheses.<br/>
    %L Line number within the file where the log statement was issued<br/>
    %m The message to be logged<br/>
    %m{chomp} The message to be logged, stripped off a trailing newline<br/>
    %M Method or function where the logging request was issued<br/>
    %n Newline (OS-independent)<br/>
    %p Priority of the logging event<br/>
    %P pid of the current process<br/>
    %r Number of milliseconds elapsed from program start to logging <br/>
       event<br/>
    %R Number of milliseconds elapsed from last logging event to<br/>
       current logging event <br/>
    %T A stack trace of functions called<br/>
    %x The topmost NDC (see below)<br/>
    %X{key} The entry 'key' of the MDC (see below)<br/>
    %% A literal percent (%) sign<br/>
<div style="height: 1.00em;">
&#160;</div>
NDC and MDC are explained in &quot;Nested Diagnostic Context (NDC)&quot; and &quot;Mapped Diagnostic Context (MDC)&quot;.<div style="height: 1.00em;">
&#160;</div>
Also, %d can be fine-tuned to display only certain characteristics of a date, according to the SimpleDateFormat in the Java World (http://java.sun.com/j2se/1.3/docs/api/java/text/SimpleDateFormat.html)<div style="height: 1.00em;">
&#160;</div>
In this way, %d{HH:mm} displays only hours and minutes of the current date, while %d{yy, EEEE} displays a two-digit year, followed by a spelled-out (like &quot;Wednesday&quot;).<div style="height: 1.00em;">
&#160;</div>
Similar options are available for shrinking the displayed category or limit file/path components, %F{1} only displays the source file  <i>name</i> without any path components while %F logs the full path. %c{2} only logs the last two components of the current category, &quot;Foo::Bar::Baz&quot; becomes &quot;Bar::Baz&quot; and saves space.<div style="height: 1.00em;">
&#160;</div>
If those placeholders aren't enough, then you can define your own right in the config file like this:<div style="height: 1.00em;">
&#160;</div>
<br/>
    log4perl.PatternLayout.cspec.U = sub { return &quot;UID $&lt;&quot; }<br/>
<div style="height: 1.00em;">
&#160;</div>
See Log::Log4perl::Layout::PatternLayout for further details on customized specifiers.<div style="height: 1.00em;">
&#160;</div>
Please note that the subroutines you're defining in this way are going to be run in the &quot;main&quot; namespace, so be sure to fully qualify functions and variables if they're located in different packages.<div style="height: 1.00em;">
&#160;</div>
SECURITY NOTE: this feature means arbitrary perl code can be embedded in the config file.  In the rare case where the people who have access to your config file are different from the people who write your code and shouldn't have execute rights, you might want to call<div style="height: 1.00em;">
&#160;</div>
<br/>
    Log::Log4perl::Config-&gt;allow_code(0);<br/>
<div style="height: 1.00em;">
&#160;</div>
before you call <i>init()</i>. Alternatively you can supply a restricted set of Perl opcodes that can be embedded in the config file as described in &quot;Restricting what Opcodes can be in a Perl Hook&quot;.</dd>
</dl>
<div class="spacer">
</div>
All placeholders are quantifiable, just like in <i>printf</i>. Following this tradition, &quot;%-20c&quot; will reserve 20 chars for the category and left-justify it.<div class="spacer">
</div>
For more details on logging and how to use the flexible and the simple format, check out the original &quot;log4j&quot; website under<div class="spacer">
</div>
<br/>
    http://jakarta.apache.org/log4j/docs/api/org/apache/log4j/SimpleLayout.html<br/>
    http://jakarta.apache.org/log4j/docs/api/org/apache/log4j/PatternLayout.html<br/>
</div>
<div class="subsection">
<h2>Penalties</h2> Logging comes with a price tag. &quot;Log::Log4perl&quot; has been optimized to allow for maximum performance, both with logging enabled and disabled.<div class="spacer">
</div>
But you need to be aware that there's a small hit every time your code encounters a log statement -- no matter if logging is enabled or not. &quot;Log::Log4perl&quot; has been designed to keep this so low that it will be unnoticable to most applications.<div class="spacer">
</div>
Here's a couple of tricks which help &quot;Log::Log4perl&quot; to avoid unnecessary delays:<div class="spacer">
</div>
You can save serious time if you're logging something like<div class="spacer">
</div>
<br/>
        # Expensive in non-debug mode!<br/>
    for (@super_long_array) {<br/>
        $logger-&gt;debug(&quot;Element: $_&quot;);<br/>
    }<br/>
<div class="spacer">
</div>
and @super_long_array is fairly big, so looping through it is pretty expensive. Only you, the programmer, knows that going through that &quot;for&quot; loop can be skipped entirely if the current logging level for the actual component is higher than &quot;debug&quot;. In this case, use this instead:<div class="spacer">
</div>
<br/>
        # Cheap in non-debug mode!<br/>
    if($logger-&gt;is_debug()) {<br/>
        for (@super_long_array) {<br/>
            $logger-&gt;debug(&quot;Element: $_&quot;);<br/>
        }<br/>
    }<br/>
<div class="spacer">
</div>
If you're afraid that generating the parameters to the logging function is fairly expensive, use closures:<div class="spacer">
</div>
<br/>
        # Passed as subroutine ref<br/>
    use Data::Dumper;<br/>
    $logger-&gt;debug(sub { Dumper($data) } );<br/>
<div class="spacer">
</div>
This won't unravel $data via <i>Dumper()</i> unless it's actually needed because it's logged.<div class="spacer">
</div>
Also, Log::Log4perl lets you specify arguments to logger functions in  <i>message output filter syntax</i>:<div class="spacer">
</div>
<br/>
    $logger-&gt;debug(&quot;Structure: &quot;,<br/>
                   { filter =&gt; \&amp;Dumper,<br/>
                     value  =&gt; $someref });<br/>
<div class="spacer">
</div>
In this way, shortly before Log::Log4perl sending the message out to any appenders, it will be searching all arguments for hash references and treat them in a special way:<div class="spacer">
</div>
It will invoke the function given as a reference with the &quot;filter&quot; key (&quot;Data::Dumper::Dumper()&quot;) and pass it the value that came with the key named &quot;value&quot; as an argument. The anonymous hash in the call above will be replaced by the return value of the filter function.</div>
</div>
<div class="section">
<h1>Categories</h1>  <b>Categories are also called &quot;Loggers&quot; in Log4perl, both refer</b>  <b>to the the same thing and these terms are used interchangeably.</b> &quot;Log::Log4perl&quot; uses  <i>categories</i> to determine if a log statement in a component should be executed or suppressed at the current logging level. Most of the time, these categories are just the classes the log statements are located in:<div class="spacer">
</div>
<br/>
    package Candy::Twix;<br/>
<br/>
    sub new { <br/>
        my $logger = Log::Log4perl-&gt;new(&quot;Candy::Twix&quot;);<br/>
        $logger-&gt;debug(&quot;Creating a new Twix bar&quot;);<br/>
        bless {}, shift;<br/>
    }<br/>
 <br/>
    # ...<br/>
<br/>
    package Candy::Snickers;<br/>
<br/>
    sub new { <br/>
        my $logger = Log::Log4perl-&gt;new(&quot;Candy.Snickers&quot;);<br/>
        $logger-&gt;debug(&quot;Creating a new Snickers bar&quot;);<br/>
        bless {}, shift;<br/>
    }<br/>
<br/>
    # ...<br/>
<br/>
    package main;<br/>
    Log::Log4perl-&gt;init(&quot;mylogdefs.conf&quot;);<br/>
<br/>
        # =&gt; &quot;LOG&gt; Creating a new Snickers bar&quot;<br/>
    my $first = Candy::Snickers-&gt;new();<br/>
        # =&gt; &quot;LOG&gt; Creating a new Twix bar&quot;<br/>
    my $second = Candy::Twix-&gt;new();<br/>
<div class="spacer">
</div>
Note that you can separate your category hierarchy levels using either dots like in Java (.) or double-colons (::) like in Perl. Both notations are equivalent and are handled the same way internally.<div class="spacer">
</div>
However, categories are just there to make use of inheritance: if you invoke a logger in a sub-category, it will bubble up the hierarchy and call the appropriate appenders. Internally, categories are not related to the class hierarchy of the program at all -- they're purely virtual. You can use arbitrary categories -- for example in the following program, which isn't oo-style, but procedural:<div class="spacer">
</div>
<br/>
    sub print_portfolio {<br/>
<br/>
        my $log = Log::Log4perl-&gt;new(&quot;user.portfolio&quot;);<br/>
        $log-&gt;debug(&quot;Quotes requested: @_&quot;);<br/>
<br/>
        for(@_) {<br/>
            print &quot;$_: &quot;, get_quote($_), &quot;\n&quot;;<br/>
        }<br/>
    }<br/>
<br/>
    sub get_quote {<br/>
<br/>
        my $log = Log::Log4perl-&gt;new(&quot;internet.quotesystem&quot;);<br/>
        $log-&gt;debug(&quot;Fetching quote: $_[0]&quot;);<br/>
<br/>
        return yahoo_quote($_[0]);<br/>
    }<br/>
<div class="spacer">
</div>
The logger in first function, &quot;print_portfolio&quot;, is assigned the (virtual) &quot;user.portfolio&quot; category. Depending on the &quot;Log4perl&quot; configuration, this will either call a &quot;user.portfolio&quot; appender, a &quot;user&quot; appender, or an appender assigned to root -- without &quot;user.portfolio&quot; having any relevance to the class system used in the program. The logger in the second function adheres to the &quot;internet.quotesystem&quot; category -- again, maybe because it's bundled with other Internet functions, but not because there would be a class of this name somewhere.<div class="spacer">
</div>
However, be careful, don't go overboard: if you're developing a system in object-oriented style, using the class hierarchy is usually your best choice. Think about the people taking over your code one day: The class hierarchy is probably what they know right up front, so it's easy for them to tune the logging to their needs.<div class="subsection">
<h2>Turn off a component</h2> &quot;Log4perl&quot; doesn't only allow you to selectively switch  <i>on</i> a category of log messages, you can also use the mechanism to selectively  <i>disable</i> logging in certain components whereas logging is kept turned on in higher-level categories. This mechanism comes in handy if you find that while bumping up the logging level of a high-level (i. e. close to root) category, that one component logs more than it should,<div class="spacer">
</div>
Here's how it works:<div class="spacer">
</div>
<br/>
    ############################################################<br/>
    # Turn off logging in a lower-level category while keeping<br/>
    # it active in higher-level categories.<br/>
    ############################################################<br/>
    log4perl.rootLogger=DEBUG, LOGFILE<br/>
    log4perl.logger.deep.down.the.hierarchy = ERROR, LOGFILE<br/>
<br/>
    # ... Define appenders ...<br/>
<div class="spacer">
</div>
This way, log messages issued from within &quot;Deep::Down::The::Hierarchy&quot; and below will be logged only if they're &quot;ERROR&quot; or worse, while in all other system components even &quot;DEBUG&quot; messages will be logged.</div>
<div class="subsection">
<h2>Return Values</h2> All logging methods return values indicating if their message actually reached one or more appenders. If the message has been suppressed because of level constraints, &quot;undef&quot; is returned.<div class="spacer">
</div>
For example,<div class="spacer">
</div>
<br/>
    my $ret = $logger-&gt;info(&quot;Message&quot;);<br/>
<div class="spacer">
</div>
will return &quot;undef&quot; if the system debug level for the current category is not &quot;INFO&quot; or more permissive. If Log::Log4perl forwarded the message to one or more appenders, the number of appenders is returned.<div class="spacer">
</div>
If appenders decide to veto on the message with an appender threshold, the log method's return value will have them excluded. This means that if you've got one appender holding an appender threshold and you're logging a message which passes the system's log level hurdle but not the appender threshold, 0 will be returned by the log function.<div class="spacer">
</div>
The bottom line is: Logging functions will return a <i>true</i> value if the message made it through to one or more appenders and a  <i>false</i> value if it didn't. This allows for constructs like<div class="spacer">
</div>
<br/>
    $logger-&gt;fatal(&quot;@_&quot;) or print STDERR &quot;@_\n&quot;;<br/>
<div class="spacer">
</div>
which will ensure that the fatal message isn't lost if the current level is lower than FATAL or printed twice if the level is acceptable but an appender already points to STDERR.</div>
<div class="subsection">
<h2>Pitfalls with Categories</h2> Be careful with just blindly reusing the system's packages as categories. If you do, you'll get into trouble with inherited methods. Imagine the following class setup:<div class="spacer">
</div>
<br/>
    use Log::Log4perl;<br/>
<br/>
    ###########################################<br/>
    package Bar;<br/>
    ###########################################<br/>
    sub new {<br/>
        my($class) = @_;<br/>
        my $logger = Log::Log4perl::get_logger(__PACKAGE__);<br/>
        $logger-&gt;debug(&quot;Creating instance&quot;);<br/>
        bless {}, $class;<br/>
    }<br/>
    ###########################################<br/>
    package Bar::Twix;<br/>
    ###########################################<br/>
    our @ISA = qw(Bar);<br/>
<br/>
    ###########################################<br/>
    package main;<br/>
    ###########################################<br/>
    Log::Log4perl-&gt;init(\ qq{<br/>
    log4perl.category.Bar.Twix = DEBUG, Screen<br/>
    log4perl.appender.Screen = Log::Log4perl::Appender::Screen<br/>
    log4perl.appender.Screen.layout = SimpleLayout<br/>
    });<br/>
<br/>
    my $bar = Bar::Twix-&gt;new();<br/>
<div class="spacer">
</div>
&quot;Bar::Twix&quot; just inherits everything from &quot;Bar&quot;, including the constructor &quot;new()&quot;. Contrary to what you might be thinking at first, this won't log anything. Reason for this is the &quot;get_logger()&quot; call in package &quot;Bar&quot;, which will always get a logger of the &quot;Bar&quot; category, even if we call &quot;new()&quot; via the &quot;Bar::Twix&quot; package, which will make perl go up the inheritance tree to actually execute &quot;Bar::new()&quot;. Since we've only defined logging behaviour for &quot;Bar::Twix&quot; in the configuration file, nothing will happen.<div class="spacer">
</div>
This can be fixed by changing the &quot;get_logger()&quot; method in &quot;Bar::new()&quot; to obtain a logger of the category matching the  <i>actual</i> class of the object, like in<div class="spacer">
</div>
<br/>
        # ... in Bar::new() ...<br/>
    my $logger = Log::Log4perl::get_logger($class);<br/>
<div class="spacer">
</div>
This way, you'll make sure the logger logs appropriately, no matter if the method is inherited or called directly. &quot;new()&quot; always gets the real class name as an argument and all other methods can determine it via &quot;ref($self)&quot;), so it shouldn't be a problem to get the right class every time.</div>
<div class="subsection">
<h2>Initialize once and only once</h2> It's important to realize that Log::Log4perl gets initialized once and only once, typically at the start of a program or system. Calling &quot;init()&quot; more than once will cause it to clobber the existing configuration and  <i>replace</i> it by the new one.<div class="spacer">
</div>
If you're in a traditional CGI environment, where every request is handeled by a new process, calling &quot;init()&quot; every time is fine. In persistent environments like &quot;mod_perl&quot;, however, Log::Log4perl should be initialized either at system startup time (Apache offers startup handlers for that) or via<div class="spacer">
</div>
<br/>
        # Init or skip if already done<br/>
    Log::Log4perl-&gt;init_once($conf_file);<br/>
<div class="spacer">
</div>
&quot;init_once()&quot; is identical to &quot;init()&quot;, just with the exception that it will leave a potentially existing configuration alone and will only call &quot;init()&quot; if Log::Log4perl hasn't been initialized yet.<div class="spacer">
</div>
If you're just curious if Log::Log4perl has been initialized yet, the check<div class="spacer">
</div>
<br/>
    if(Log::Log4perl-&gt;initialized()) {<br/>
        # Yes, Log::Log4perl has already been initialized<br/>
    } else {<br/>
        # No, not initialized yet ...<br/>
    }<br/>
<div class="spacer">
</div>
can be used.<div class="spacer">
</div>
If you're afraid that the components of your system are stepping on each other's toes or if you are thinking that different components should initialize Log::Log4perl seperately, try to consolidate your system to use a centralized Log4perl configuration file and use Log4perl's  <i>categories</i> to separate your components.</div>
<div class="subsection">
<h2>Custom Filters</h2> Log4perl allows the use of customized filters in its appenders to control the output of messages. These filters might grep for certain text chunks in a message, verify that its priority matches or exceeds a certain level or that this is the 10th time the same message has been submitted -- and come to a log/no log decision based upon these circumstantial facts.<div class="spacer">
</div>
Check out Log::Log4perl::Filter for detailed instructions on how to use them.</div>
<div class="subsection">
<h2>Performance</h2> The performance of Log::Log4perl calls obviously depends on a lot of things. But to give you a general idea, here's some rough numbers:<div class="spacer">
</div>
On a Pentium 4 Linux box at 2.4 GHz, you'll get through<dl>
<dt>
&#8226;</dt>
<dd>
500,000 suppressed log statements per second</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
30,000 logged messages per second (using an in-memory appender)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
init_and_watch delay mode: 300,000 suppressed, 30,000 logged. init_and_watch signal mode: 450,000 suppressed, 30,000 logged.</dd>
</dl>
<div class="spacer">
</div>
Numbers depend on the complexity of the Log::Log4perl configuration. For a more detailed benchmark test, check the &quot;docs/benchmark.results.txt&quot; document in the Log::Log4perl distribution.</div>
</div>
<div class="section">
<h1>Cool Tricks</h1> Here's a collection of useful tricks for the advanced &quot;Log::Log4perl&quot; user. For more, check the the FAQ, either in the distribution (Log::Log4perl::FAQ) or on http://log4perl.sourceforge.net.<div class="subsection">
<h2>Shortcuts</h2> When getting an instance of a logger, instead of saying<div class="spacer">
</div>
<br/>
    use Log::Log4perl;<br/>
    my $logger = Log::Log4perl-&gt;get_logger();<br/>
<div class="spacer">
</div>
it's often more convenient to import the &quot;get_logger&quot; method from &quot;Log::Log4perl&quot; into the current namespace:<div class="spacer">
</div>
<br/>
    use Log::Log4perl qw(get_logger);<br/>
    my $logger = get_logger();<br/>
<div class="spacer">
</div>
Please note this difference: To obtain the root logger, please use &quot;get_logger(&quot;&quot;)&quot;, call it without parameters (&quot;get_logger()&quot;), you'll get the logger of a category named after the current package. &quot;get_logger()&quot; is equivalent to &quot;get_logger(__PACKAGE__)&quot;.</div>
<div class="subsection">
<h2>Alternative initialization</h2> Instead of having &quot;init()&quot; read in a configuration file by specifying a file name or passing it a reference to an open filehandle (&quot;Log::Log4perl-&gt;init( \*FILE )&quot;), you can also pass in a reference to a string, containing the content of the file:<div class="spacer">
</div>
<br/>
    Log::Log4perl-&gt;init( \$config_text );<br/>
<div class="spacer">
</div>
Also, if you've got the &quot;name=value&quot; pairs of the configuration in a hash, you can just as well initialize &quot;Log::Log4perl&quot; with a reference to it:<div class="spacer">
</div>
<br/>
    my %key_value_pairs = (<br/>
        &quot;log4perl.rootLogger&quot;       =&gt; &quot;ERROR, LOGFILE&quot;,<br/>
        &quot;log4perl.appender.LOGFILE&quot; =&gt; &quot;Log::Log4perl::Appender::File&quot;,<br/>
        ...<br/>
    );<br/>
<br/>
    Log::Log4perl-&gt;init( \%key_value_pairs );<br/>
<div class="spacer">
</div>
Or also you can use a URL, see below:</div>
<div class="subsection">
<h2>Using LWP to parse URLs</h2> (This section borrowed from XML::DOM::Parser by T.J. Mather).<div class="spacer">
</div>
The <i>init()</i> function now also supports URLs, e.g. <i>http://www.erols.com/enno/xsa.xml</i>. It uses LWP to download the file and then calls  <i>parse()</i> on the resulting string. By default it will use a LWP::UserAgent that is created as follows:<div class="spacer">
</div>
<br/>
 use LWP::UserAgent;<br/>
 $LWP_USER_AGENT = LWP::UserAgent-&gt;new;<br/>
 $LWP_USER_AGENT-&gt;env_proxy;<br/>
<div class="spacer">
</div>
Note that env_proxy reads proxy settings from environment variables, which is what I need to do to get thru our firewall. If you want to use a different LWP::UserAgent, you can set it with<div class="spacer">
</div>
<br/>
    Log::Log4perl::Config::set_LWP_UserAgent($my_agent);<br/>
<div class="spacer">
</div>
Currently, LWP is used when the filename (passed to parsefile) starts with one of the following URL schemes: http, https, ftp, wais, gopher, or file (followed by a colon.)<div class="spacer">
</div>
Don't use this feature with <i>init_and_watch()</i>.</div>
<div class="subsection">
<h2>Automatic reloading of changed configuration files</h2> Instead of just statically initializing Log::Log4perl via<div class="spacer">
</div>
<br/>
    Log::Log4perl-&gt;init($conf_file);<br/>
<div class="spacer">
</div>
there's a way to have Log::Log4perl periodically check for changes in the configuration and reload it if necessary:<div class="spacer">
</div>
<br/>
    Log::Log4perl-&gt;init_and_watch($conf_file, $delay);<br/>
<div class="spacer">
</div>
In this mode, Log::Log4perl will examine the configuration file $conf_file every $delay seconds for changes via the file's last modification timestamp. If the file has been updated, it will be reloaded and replace the current Log::Log4perl configuration.<div class="spacer">
</div>
The way this works is that with every logger function called ( <i>debug()</i>, <i>is_debug()</i>, etc.), Log::Log4perl will check if the delay interval has expired. If so, it will run a -M file check on the configuration file. If its timestamp has been modified, the current configuration will be dumped and new content of the file will be loaded.<div class="spacer">
</div>
This convenience comes at a price, though: Calling <i>time()</i> with every logging function call, especially the ones that are &quot;suppressed&quot; (!), will slow down these Log4perl calls by about 40%.<div class="spacer">
</div>
To alleviate this performance hit a bit, &quot;init_and_watch()&quot; can be configured to listen for a Unix signal to reload the configuration instead:<div class="spacer">
</div>
<br/>
    Log::Log4perl-&gt;init_and_watch($conf_file, 'HUP');<br/>
<div class="spacer">
</div>
This will set up a signal handler for SIGHUP and reload the configuration if the application receives this signal, e.g. via the &quot;kill&quot; command:<div class="spacer">
</div>
<br/>
    kill -HUP pid<br/>
<div class="spacer">
</div>
where &quot;pid&quot; is the process ID of the application. This will bring you back to about 85% of Log::Log4perl's normal execution speed for suppressed statements. For details, check out &quot;Performance&quot;. For more info on the signal handler, look for &quot;SIGNAL MODE&quot; in Log::Log4perl::Config::Watch.<div class="spacer">
</div>
If you have a somewhat long delay set between physical config file checks or don't want to use the signal associated with the config file watcher, you can trigger a configuration reload at the next possible time by calling &quot;Log::Log4perl::Config-&gt;watcher-&gt;force_next_check()&quot;.<div class="spacer">
</div>
One thing to watch out for: If the configuration file contains a syntax or other fatal error, a running application will stop with &quot;die&quot; if this damaged configuration will be loaded during runtime, triggered either by a signal or if the delay period expired and the change is detected. This behaviour might change in the future.<div class="spacer">
</div>
To allow the application to intercept and control a configuration reload in init_and_watch mode, a callback can be specified:<div class="spacer">
</div>
<br/>
    Log::Log4perl-&gt;init_and_watch($conf_file, 10, { <br/>
            preinit_callback =&gt; \&amp;callback });<br/>
<div class="spacer">
</div>
If Log4perl determines that the configuration needs to be reloaded, it will call the &quot;preinit_callback&quot; function without parameters. If the callback returns a true value, Log4perl will proceed and reload the configuration.  If the callback returns a false value, Log4perl will keep the old configuration and skip reloading it until the next time around.  Inside the callback, an application can run all kinds of checks, including accessing the configuration file, which is available via &quot;Log::Log4perl::Config-&gt;watcher()-&gt;file()&quot;.</div>
<div class="subsection">
<h2>Variable Substitution</h2> To avoid having to retype the same expressions over and over again, Log::Log4perl's configuration files support simple variable substitution. New variables are defined simply by adding<div class="spacer">
</div>
<br/>
    varname = value<br/>
<div class="spacer">
</div>
lines to the configuration file before using<div class="spacer">
</div>
<br/>
    ${varname}<br/>
<div class="spacer">
</div>
afterwards to recall the assigned values. Here's an example:<div class="spacer">
</div>
<br/>
    layout_class   = Log::Log4perl::Layout::PatternLayout<br/>
    layout_pattern = %d %F{1} %L&gt; %m %n<br/>
    <br/>
    log4perl.category.Bar.Twix = WARN, Logfile, Screen<br/>
<br/>
    log4perl.appender.Logfile  = Log::Log4perl::Appender::File<br/>
    log4perl.appender.Logfile.filename = test.log<br/>
    log4perl.appender.Logfile.layout = ${layout_class}<br/>
    log4perl.appender.Logfile.layout.ConversionPattern = ${layout_pattern}<br/>
<br/>
    log4perl.appender.Screen  = Log::Log4perl::Appender::Screen<br/>
    log4perl.appender.Screen.layout = ${layout_class}<br/>
    log4perl.appender.Screen.layout.ConversionPattern = ${layout_pattern}<br/>
<div class="spacer">
</div>
This is a convenient way to define two appenders with the same layout without having to retype the pattern definitions.<div class="spacer">
</div>
Variable substitution via &quot;${varname}&quot; will first try to find an explicitely defined variable. If that fails, it will check your shell's environment for a variable of that name. If that also fails, the program will &quot;die()&quot;.</div>
<div class="subsection">
<h2>Perl Hooks in the Configuration File</h2> If some of the values used in the Log4perl configuration file need to be dynamically modified by the program, use Perl hooks:<div class="spacer">
</div>
<br/>
    log4perl.appender.File.filename = \<br/>
        sub { return getLogfileName(); }<br/>
<div class="spacer">
</div>
Each value starting with the string &quot;sub {...&quot; is interpreted as Perl code to be executed at the time the application parses the configuration via &quot;Log::Log4perl::init()&quot;. The return value of the subroutine is used by Log::Log4perl as the configuration value.<div class="spacer">
</div>
The Perl code is executed in the &quot;main&quot; package, functions in other packages have to be called in fully-qualified notation.<div class="spacer">
</div>
Here's another example, utilizing an environment variable as a username for a DBI appender:<div class="spacer">
</div>
<br/>
    log4perl.appender.DB.username = \<br/>
        sub { $ENV{DB_USER_NAME } }<br/>
<div class="spacer">
</div>
However, please note the difference between these code snippets and those used for user-defined conversion specifiers as discussed in Log::Log4perl::Layout::PatternLayout: While the snippets above are run  <i>once</i> when &quot;Log::Log4perl::init()&quot; is called, the conversion specifier snippets are executed  <i>each time</i> a message is rendered according to the PatternLayout.<div class="spacer">
</div>
SECURITY NOTE: this feature means arbitrary perl code can be embedded in the config file.  In the rare case where the people who have access to your config file are different from the people who write your code and shouldn't have execute rights, you might want to set<div class="spacer">
</div>
<br/>
    Log::Log4perl::Config-&gt;allow_code(0);<br/>
<div class="spacer">
</div>
before you call <i>init()</i>.  Alternatively you can supply a restricted set of Perl opcodes that can be embedded in the config file as described in &quot;Restricting what Opcodes can be in a Perl Hook&quot;.</div>
<div class="subsection">
<h2>Restricting what Opcodes can be in a Perl Hook</h2> The value you pass to Log::Log4perl::Config-&gt; <i>allow_code()</i> determines whether the code that is embedded in the config file is eval'd unrestricted, or eval'd in a Safe compartment.  By default, a value of '1' is assumed, which does a normal 'eval' without any restrictions. A value of '0' however prevents any embedded code from being evaluated.<div class="spacer">
</div>
If you would like fine-grained control over what can and cannot be included in embedded code, then please utilize the following methods:<div class="spacer">
</div>
<br/>
 Log::Log4perl::Config-&gt;allow_code( $allow );<br/>
 Log::Log4perl::Config-&gt;allowed_code_ops($op1, $op2, ... );<br/>
 Log::Log4perl::Config-&gt;vars_shared_with_safe_compartment( [ \%vars | $package, \@vars ] );<br/>
 Log::Log4perl::Config-&gt;allowed_code_ops_convenience_map( [ \%map | $name, \@mask ] );<br/>
<div class="spacer">
</div>
Log::Log4perl::Config-&gt;<i>allowed_code_ops()</i> takes a list of opcode masks that are allowed to run in the compartment.  The opcode masks must be specified as described in Opcode:<div class="spacer">
</div>
<br/>
 Log::Log4perl::Config-&gt;allowed_code_ops(':subprocess');<br/>
<div class="spacer">
</div>
This example would allow Perl operations like backticks, system, fork, and waitpid to be executed in the compartment.  Of course, you probably don't want to use this mask -- it would allow exactly what the Safe compartment is designed to prevent.<div class="spacer">
</div>
Log::Log4perl::Config-&gt;<i>vars_shared_with_safe_compartment()</i> takes the symbols which should be exported into the Safe compartment before the code is evaluated. The keys of this hash are the package names that the symbols are in, and the values are array references to the literal symbol names.  For convenience, the default settings export the '%ENV' hash from the 'main' package into the compartment:<div class="spacer">
</div>
<br/>
 Log::Log4perl::Config-&gt;vars_shared_with_safe_compartment(<br/>
   main =&gt; [ '%ENV' ],<br/>
 );<br/>
<div class="spacer">
</div>
Log::Log4perl::Config-&gt;<i>allowed_code_ops_convenience_map()</i> is an accessor method to a map of convenience names to opcode masks. At present, the following convenience names are defined:<div class="spacer">
</div>
<br/>
 safe        = [ ':browse' ]<br/>
 restrictive = [ ':default' ]<br/>
<div class="spacer">
</div>
For convenience, if Log::Log4perl::Config-&gt;<i>allow_code()</i> is called with a value which is a key of the map previously defined with Log::Log4perl::Config-&gt; <i>allowed_code_ops_convenience_map()</i>, then the allowed opcodes are set according to the value defined in the map. If this is confusing, consider the following:<div class="spacer">
</div>
<br/>
 use Log::Log4perl;<br/>
 <br/>
 my $config = &lt;&lt;'END';<br/>
  log4perl.logger = INFO, Main<br/>
  log4perl.appender.Main = Log::Log4perl::Appender::File<br/>
  log4perl.appender.Main.filename = \<br/>
      sub { &quot;example&quot; . getpwuid($&lt;) . &quot;.log&quot; }<br/>
  log4perl.appender.Main.layout = Log::Log4perl::Layout::SimpleLayout<br/>
 END<br/>
 <br/>
 $Log::Log4perl::Config-&gt;allow_code('restrictive');<br/>
 Log::Log4perl-&gt;init( \$config );       # will fail<br/>
 $Log::Log4perl::Config-&gt;allow_code('safe');<br/>
 Log::Log4perl-&gt;init( \$config );       # will succeed<br/>
<div class="spacer">
</div>
The reason that the first call to -&gt;<i>init()</i> fails is because the 'restrictive' name maps to an opcode mask of ':default'.   <i>getpwuid()</i> is not part of ':default', so -&gt; <i>init()</i> fails.  The 'safe' name maps to an opcode mask of ':browse', which allows  <i>getpwuid()</i> to run, so -&gt;<i>init()</i> succeeds.<div class="spacer">
</div>
<i>allowed_code_ops_convenience_map()</i> can be invoked in several ways:<dl>
<dt>
<i>allowed_code_ops_convenience_map()</i></dt>
<dd>
Returns the entire convenience name map as a hash reference in scalar context or a hash in list context.</dd>
</dl>
<dl>
<dt>
allowed_code_ops_convenience_map( \%map )</dt>
<dd>
Replaces the entire conveniece name map with the supplied hash reference.</dd>
</dl>
<dl>
<dt>
allowed_code_ops_convenience_map( $name )</dt>
<dd>
Returns the opcode mask for the given convenience name, or undef if no such name is defined in the map.</dd>
</dl>
<dl>
<dt>
allowed_code_ops_convenience_map( $name, \@mask )</dt>
<dd>
Adds the given name/mask pair to the convenience name map.  If the name already exists in the map, it's value is replaced with the new mask.</dd>
</dl>
<div class="spacer">
</div>
as can <i>vars_shared_with_safe_compartment()</i>:<dl>
<dt>
<i>vars_shared_with_safe_compartment()</i></dt>
<dd>
Return the entire map of packages to variables as a hash reference in scalar context or a hash in list context.</dd>
</dl>
<dl>
<dt>
vars_shared_with_safe_compartment( \%packages )</dt>
<dd>
Replaces the entire map of packages to variables with the supplied hash reference.</dd>
</dl>
<dl>
<dt>
vars_shared_with_safe_compartment( $package )</dt>
<dd>
Returns the arrayref of variables to be shared for a specific package.</dd>
</dl>
<dl>
<dt>
vars_shared_with_safe_compartment( $package, \@vars )</dt>
<dd>
Adds the given package / varlist pair to the map.  If the package already exists in the map, it's value is replaced with the new arrayref of variable names.</dd>
</dl>
<div class="spacer">
</div>
For more information on opcodes and Safe Compartments, see Opcode and Safe.</div>
<div class="subsection">
<h2>Changing the Log Level on a Logger</h2> Log4perl provides some internal functions for quickly adjusting the log level from within a running Perl program.<div class="spacer">
</div>
Now, some people might argue that you should adjust your levels from within an external Log4perl configuration file, but Log4perl is everybody's darling.<div class="spacer">
</div>
Typically run-time adjusting of levels is done at the beginning, or in response to some external input (like a &quot;more logging&quot; runtime command for diagnostics).<div class="spacer">
</div>
You get the log level from a logger object with:<div class="spacer">
</div>
<br/>
    $current_level = $logger-&gt;level();<br/>
<div class="spacer">
</div>
and you may set it with the same method, provided you first imported the log level constants, with:<div class="spacer">
</div>
<br/>
    use Log::Log4perl::Level;<br/>
<div class="spacer">
</div>
Then you can set the level on a logger to one of the constants,<div class="spacer">
</div>
<br/>
    $logger-&gt;level($ERROR); # one of DEBUG, INFO, WARN, ERROR, FATAL<br/>
<div class="spacer">
</div>
To <b>increase</b> the level of logging currently being done, use:<div class="spacer">
</div>
<br/>
    $logger-&gt;more_logging($delta);<br/>
<div class="spacer">
</div>
and to <b>decrease</b> it, use:<div class="spacer">
</div>
<br/>
    $logger-&gt;less_logging($delta);<br/>
<div class="spacer">
</div>
$delta must be a positive integer (for now, we may fix this later ;).<div class="spacer">
</div>
There are also two equivalent functions:<div class="spacer">
</div>
<br/>
    $logger-&gt;inc_level($delta);<br/>
    $logger-&gt;dec_level($delta);<br/>
<div class="spacer">
</div>
They're included to allow you a choice in readability. Some folks will prefer more/less_logging, as they're fairly clear in what they do, and allow the programmer not to worry too much about what a Level is and whether a higher Level means more or less logging. However, other folks who do understand and have lots of code that deals with levels will probably prefer the  <i>inc_level()</i> and <i>dec_level()</i> methods as they want to work with Levels and not worry about whether that means more or less logging. :)<div class="spacer">
</div>
That diatribe aside, typically you'll use <i>more_logging()</i> or <i>inc_level()</i> as such:<div class="spacer">
</div>
<br/>
    my $v = 0; # default level of verbosity.<br/>
    <br/>
    GetOptions(&quot;v+&quot; =&gt; \$v, ...);<br/>
<br/>
    $logger-&gt;more_logging($v);  # inc logging level once for each -v in ARGV<br/>
</div>
<div class="subsection">
<h2>Custom Log Levels</h2> First off, let me tell you that creating custom levels is heavily deprecated by the log4j folks. Indeed, instead of creating additional levels on top of the predefined DEBUG, INFO, WARN, ERROR and FATAL, you should use categories to control the amount of logging smartly, based on the location of the log-active code in the system.<div class="spacer">
</div>
Nevertheless, Log4perl provides a nice way to create custom levels via the  <i>create_custom_level()</i> routine function. However, this must be done before the first call to  <i>init()</i> or <i>get_logger()</i>. Say you want to create a NOTIFY logging level that comes after WARN (and thus before INFO). You'd do such as follows:<div class="spacer">
</div>
<br/>
    use Log::Log4perl;<br/>
    use Log::Log4perl::Level;<br/>
<br/>
    Log::Log4perl::Logger::create_custom_level(&quot;NOTIFY&quot;, &quot;WARN&quot;);<br/>
<div class="spacer">
</div>
And that's it! <i>create_custom_level()</i> creates the following functions / variables for level FOO:<div class="spacer">
</div>
<br/>
    $FOO_INT        # integer to use in L4p::Level::to_level()<br/>
    $logger-&gt;foo()  # log function to log if level = FOO<br/>
    $logger-&gt;is_foo()   # true if current level is &gt;= FOO<br/>
<div class="spacer">
</div>
These levels can also be used in your config file, but note that your config file probably won't be portable to another log4perl or log4j environment unless you've made the appropriate mods there too.</div>
<div class="subsection">
<h2>System-wide log levels</h2> As a fairly drastic measure to decrease (or increase) the logging level all over the system with one single configuration option, use the &quot;threshold&quot; keyword in the Log4perl configuration file:<div class="spacer">
</div>
<br/>
    log4perl.threshold = ERROR<br/>
<div class="spacer">
</div>
sets the system-wide (or hierarchy-wide according to the log4j documentation) to ERROR and therefore deprives every logger in the system of the right to log lower-prio messages.</div>
<div class="subsection">
<h2>Easy Mode</h2> For teaching purposes (especially for [1]), I've put &quot;:easy&quot; mode into &quot;Log::Log4perl&quot;, which just initializes a single root logger with a defined priority and a screen appender including some nice standard layout:<div class="spacer">
</div>
<br/>
    ### Initialization Section<br/>
    use Log::Log4perl qw(:easy);<br/>
    Log::Log4perl-&gt;easy_init($ERROR);  # Set priority of root logger to ERROR<br/>
<br/>
    ### Application Section<br/>
    my $logger = get_logger();<br/>
    $logger-&gt;fatal(&quot;This will get logged.&quot;);<br/>
    $logger-&gt;debug(&quot;This won't.&quot;);<br/>
<div class="spacer">
</div>
This will dump something like<div class="spacer">
</div>
<br/>
    2002/08/04 11:43:09 ERROR&gt; script.pl:16 main::function - This will get logged.<br/>
<div class="spacer">
</div>
to the screen. While this has been proven to work well familiarizing people with &quot;Log::Logperl&quot; slowly, effectively avoiding to clobber them over the head with a plethora of different knobs to fiddle with (categories, appenders, levels, layout), the overall mission of &quot;Log::Log4perl&quot; is to let people use categories right from the start to get used to the concept. So, let's keep this one fairly hidden in the man page (congrats on reading this far :).</div>
<div class="subsection">
<h2>Stealth loggers</h2> Sometimes, people are lazy. If you're whipping up a 50-line script and want the comfort of Log::Log4perl without having the burden of carrying a separate log4perl.conf file or a 5-liner defining that you want to append your log statements to a file, you can use the following features:<div class="spacer">
</div>
<br/>
    use Log::Log4perl qw(:easy);<br/>
<br/>
    Log::Log4perl-&gt;easy_init( { level   =&gt; $DEBUG,<br/>
                                file    =&gt; &quot;&gt;&gt;test.log&quot; } );<br/>
<br/>
        # Logs to test.log via stealth logger<br/>
    DEBUG(&quot;Debug this!&quot;);<br/>
    INFO(&quot;Info this!&quot;);<br/>
    WARN(&quot;Warn this!&quot;);<br/>
    ERROR(&quot;Error this!&quot;);<br/>
<br/>
    some_function();<br/>
<br/>
    sub some_function {<br/>
            # Same here<br/>
        FATAL(&quot;Fatal this!&quot;);<br/>
    }<br/>
<div class="spacer">
</div>
In &quot;:easy&quot; mode, &quot;Log::Log4perl&quot; will instantiate a <i>stealth logger</i> named $_default_logger and import it into the current package. Also, it will introduce the convenience functions &quot;TRACE&quot;, &quot;DEBUG()&quot;, &quot;INFO()&quot;, &quot;WARN()&quot;, &quot;ERROR()&quot;, &quot;FATAL()&quot;, and &quot;ALWAYS&quot; into the package namespace. These functions simply take messages as arguments and forward them to &quot;_default_logger-&gt;debug()&quot;, &quot;_default_logger-&gt;info()&quot; and so on. If a message should never be blocked, regardless of the log level, use the &quot;ALWAYS&quot; function which corresponds to a log level of &quot;OFF&quot;:<div class="spacer">
</div>
<br/>
    ALWAYS &quot;This will be printed regardless of the log level&quot;;<br/>
<div class="spacer">
</div>
The &quot;easy_init&quot; method can be called with a single level value to create a STDERR appender and a root logger as in<div class="spacer">
</div>
<br/>
    Log::Log4perl-&gt;easy_init($DEBUG);<br/>
<div class="spacer">
</div>
or, as shown below (and in the example above) with a reference to a hash, specifying values for &quot;level&quot; (the logger's priority), &quot;file&quot; (the appender's data sink), &quot;category&quot; (the logger's category&gt; and &quot;layout&quot; for the appender's pattern layout specification. All key-value pairs are optional, they default to $DEBUG for &quot;level&quot;, &quot;STDERR&quot; for &quot;file&quot;, &quot;&quot; (root category) for &quot;category&quot; and &quot;%d %m%n&quot; for &quot;layout&quot;:<div class="spacer">
</div>
<br/>
    Log::Log4perl-&gt;easy_init( { level    =&gt; $DEBUG,<br/>
                                file     =&gt; &quot;&gt;test.log&quot;,<br/>
                                utf8     =&gt; 1,<br/>
                                category =&gt; &quot;Bar::Twix&quot;,<br/>
                                layout   =&gt; '%F{1}-%L-%M: %m%n' } );<br/>
<div class="spacer">
</div>
The &quot;file&quot; parameter takes file names preceded by &quot;&gt;&quot; (overwrite) and &quot;&gt;&gt;&quot; (append) as arguments. This will cause &quot;Log::Log4perl::Appender::File&quot; appenders to be created behind the scenes. Also the keywords &quot;STDOUT&quot; and &quot;STDERR&quot; (no &quot;&gt;&quot; or &quot;&gt;&gt;&quot;) are recognized, which will utilize and configure &quot;Log::Log4perl::Appender::Screen&quot; appropriately. The &quot;utf8&quot; flag, if set to a true value, runs a &quot;binmode&quot; command on the file handle to establish a utf8 line discpline on the file, otherwise you'll get a 'wide character in print' warning message and probably not what you'd expect as output.<div class="spacer">
</div>
The stealth loggers can be used in different packages, you just need to make sure you're calling the &quot;use&quot; function in every package you're using &quot;Log::Log4perl&quot;'s easy services:<div class="spacer">
</div>
<br/>
    package Bar::Twix;<br/>
    use Log::Log4perl qw(:easy);<br/>
    sub eat { DEBUG(&quot;Twix mjam&quot;); }<br/>
<br/>
    package Bar::Mars;<br/>
    use Log::Log4perl qw(:easy);<br/>
    sub eat { INFO(&quot;Mars mjam&quot;); }<br/>
<br/>
    package main;<br/>
<br/>
    use Log::Log4perl qw(:easy);<br/>
<br/>
    Log::Log4perl-&gt;easy_init( { level    =&gt; $DEBUG,<br/>
                                file     =&gt; &quot;&gt;&gt;test.log&quot;,<br/>
                                category =&gt; &quot;Bar::Twix&quot;,<br/>
                                layout   =&gt; '%F{1}-%L-%M: %m%n' },<br/>
                              { level    =&gt; $DEBUG,<br/>
                                file     =&gt; &quot;STDOUT&quot;,<br/>
                                category =&gt; &quot;Bar::Mars&quot;,<br/>
                                layout   =&gt; '%m%n' },<br/>
                            );<br/>
    Bar::Twix::eat();<br/>
    Bar::Mars::eat();<br/>
<div class="spacer">
</div>
As shown above, &quot;easy_init()&quot; will take any number of different logger definitions as hash references.<div class="spacer">
</div>
Also, stealth loggers feature the functions &quot;LOGWARN()&quot;, &quot;LOGDIE()&quot;, and &quot;LOGEXIT()&quot;, combining a logging request with a subsequent Perl  <i>warn()</i> or <i>die()</i> or <i>exit()</i> statement. So, for example<div class="spacer">
</div>
<br/>
    if($all_is_lost) {<br/>
        LOGDIE(&quot;Terrible Problem&quot;);<br/>
    }<br/>
<div class="spacer">
</div>
will log the message if the package's logger is at least &quot;FATAL&quot; but &quot;die()&quot; (including the traditional output to STDERR) in any case afterwards.<div class="spacer">
</div>
See &quot;Log and die or warn&quot; for the similar &quot;logdie()&quot; and &quot;logwarn()&quot; functions of regular (i.e non-stealth) loggers.<div class="spacer">
</div>
Similarily, &quot;LOGCARP()&quot;, &quot;LOGCLUCK()&quot;, &quot;LOGCROAK()&quot;, and &quot;LOGCONFESS()&quot; are provided in &quot;:easy&quot; mode, facilitating the use of &quot;logcarp()&quot;, &quot;logcluck()&quot;, &quot;logcroak()&quot;, and &quot;logconfess()&quot; with stealth loggers.<div class="spacer">
</div>
<b>When using Log::Log4perl in easy mode,</b>  <b>please make sure you understand the implications of</b>  <b>&quot;Pitfalls with Categories&quot;</b>.<div class="spacer">
</div>
By the way, these convenience functions perform exactly as fast as the standard Log::Log4perl logger methods, there's  <i>no</i> performance penalty whatsoever.</div>
<div class="subsection">
<h2>Nested Diagnostic Context (NDC)</h2> If you find that your application could use a global (thread-specific) data stack which your loggers throughout the system have easy access to, use Nested Diagnostic Contexts (NDCs). Also check out &quot;Mapped Diagnostic Context (MDC)&quot;, this might turn out to be even more useful.<div class="spacer">
</div>
For example, when handling a request of a web client, it's probably useful to have the user's IP address available in all log statements within code dealing with this particular request. Instead of passing this piece of data around between your application functions, you can just use the global (but thread-specific) NDC mechanism. It allows you to push data pieces (scalars usually) onto its stack via<div class="spacer">
</div>
<br/>
    Log::Log4perl::NDC-&gt;push(&quot;San&quot;);<br/>
    Log::Log4perl::NDC-&gt;push(&quot;Francisco&quot;);<br/>
<div class="spacer">
</div>
and have your loggers retrieve them again via the &quot;%x&quot; placeholder in the PatternLayout. With the stack values above and a PatternLayout format like &quot;%x %m%n&quot;, the call<div class="spacer">
</div>
<br/>
    $logger-&gt;debug(&quot;rocks&quot;);<br/>
<div class="spacer">
</div>
will end up as<div class="spacer">
</div>
<br/>
    San Francisco rocks<br/>
<div class="spacer">
</div>
in the log appender.<div class="spacer">
</div>
The stack mechanism allows for nested structures. Just make sure that at the end of the request, you either decrease the stack one by one by calling<div class="spacer">
</div>
<br/>
    Log::Log4perl::NDC-&gt;pop();<br/>
    Log::Log4perl::NDC-&gt;pop();<br/>
<div class="spacer">
</div>
or clear out the entire NDC stack by calling<div class="spacer">
</div>
<br/>
    Log::Log4perl::NDC-&gt;remove();<br/>
<div class="spacer">
</div>
Even if you should forget to do that, &quot;Log::Log4perl&quot; won't grow the stack indefinitely, but limit it to a maximum, defined in &quot;Log::Log4perl::NDC&quot; (currently 5). A call to &quot;push()&quot; on a full stack will just replace the topmost element by the new value.<div class="spacer">
</div>
Again, the stack is always available via the &quot;%x&quot; placeholder in the Log::Log4perl::Layout::PatternLayout class whenever a logger fires. It will replace &quot;%x&quot; by the blank-separated list of the values on the stack. It does that by just calling<div class="spacer">
</div>
<br/>
    Log::Log4perl::NDC-&gt;get();<br/>
<div class="spacer">
</div>
internally. See details on how this standard log4j feature is implemented in Log::Log4perl::NDC.</div>
<div class="subsection">
<h2>Mapped Diagnostic Context (MDC)</h2> Just like the previously discussed NDC stores thread-specific information in a stack structure, the MDC implements a hash table to store key/value pairs in.<div class="spacer">
</div>
The static method<div class="spacer">
</div>
<br/>
    Log::Log4perl::MDC-&gt;put($key, $value);<br/>
<div class="spacer">
</div>
stores $value under a key $key, with which it can be retrieved later (possibly in a totally different part of the system) by calling the &quot;get&quot; method:<div class="spacer">
</div>
<br/>
    my $value = Log::Log4perl::MDC-&gt;get($key);<br/>
<div class="spacer">
</div>
If no value has been stored previously under $key, the &quot;get&quot; method will return &quot;undef&quot;.<div class="spacer">
</div>
Typically, MDC values are retrieved later on via the &quot;%X{...}&quot; placeholder in &quot;Log::Log4perl::Layout::PatternLayout&quot;. If the &quot;get()&quot; method returns &quot;undef&quot;, the placeholder will expand to the string &quot;[undef]&quot;.<div class="spacer">
</div>
An application taking a web request might store the remote host like<div class="spacer">
</div>
<br/>
    Log::Log4perl::MDC-&gt;put(&quot;remote_host&quot;, $r-&gt;headers(&quot;HOST&quot;));<br/>
<div class="spacer">
</div>
at its beginning and if the appender's layout looks something like<div class="spacer">
</div>
<br/>
    log4perl.appender.Logfile.layout.ConversionPattern = %X{remote_host}: %m%n<br/>
<div class="spacer">
</div>
then a log statement like<div class="spacer">
</div>
<br/>
   DEBUG(&quot;Content delivered&quot;);<br/>
<div class="spacer">
</div>
will log something like<div class="spacer">
</div>
<br/>
   adsl-63.dsl.snf.pacbell.net: Content delivered<br/>
<div class="spacer">
</div>
later on in the program.<div class="spacer">
</div>
For details, please check Log::Log4perl::MDC.</div>
<div class="subsection">
<h2>Resurrecting hidden Log4perl Statements</h2> Sometimes scripts need to be deployed in environments without having Log::Log4perl installed yet. On the other hand, you dont't want to live without your Log4perl statements -- they're gonna come in handy later.<div class="spacer">
</div>
So, just deploy your script with Log4perl statements commented out with the pattern &quot;###l4p&quot;, like in<div class="spacer">
</div>
<br/>
    ###l4p DEBUG &quot;It works!&quot;;<br/>
    # ...<br/>
    ###l4p INFO &quot;Really!&quot;;<br/>
<div class="spacer">
</div>
If Log::Log4perl is available, use the &quot;:resurrect&quot; tag to have Log4perl resurrect those burried statements before the script starts running:<div class="spacer">
</div>
<br/>
    use Log::Log4perl qw(:resurrect :easy);<br/>
<br/>
    ###l4p Log::Log4perl-&gt;easy_init($DEBUG);<br/>
    ###l4p DEBUG &quot;It works!&quot;;<br/>
    # ...<br/>
    ###l4p INFO &quot;Really!&quot;;<br/>
<div class="spacer">
</div>
This will have a source filter kick in and indeed print<div class="spacer">
</div>
<br/>
    2004/11/18 22:08:46 It works!<br/>
    2004/11/18 22:08:46 Really!<br/>
<div class="spacer">
</div>
In environments lacking Log::Log4perl, just comment out the first line and the script will run nevertheless (but of course without logging):<div class="spacer">
</div>
<br/>
    # use Log::Log4perl qw(:resurrect :easy);<br/>
<br/>
    ###l4p Log::Log4perl-&gt;easy_init($DEBUG);<br/>
    ###l4p DEBUG &quot;It works!&quot;;<br/>
    # ...<br/>
    ###l4p INFO &quot;Really!&quot;;<br/>
<div class="spacer">
</div>
because everything's a regular comment now. Alternatively, put the magic Log::Log4perl comment resurrection line into your shell's PERL5OPT environment variable, e.g. for bash:<div class="spacer">
</div>
<br/>
    set PERL5OPT=-MLog::Log4perl=:resurrect,:easy<br/>
    export PERL5OPT<br/>
<div class="spacer">
</div>
This will awaken the giant within an otherwise silent script like the following:<div class="spacer">
</div>
<br/>
    #!/usr/bin/perl<br/>
<br/>
    ###l4p Log::Log4perl-&gt;easy_init($DEBUG);<br/>
    ###l4p DEBUG &quot;It works!&quot;;<br/>
<div class="spacer">
</div>
As of &quot;Log::Log4perl&quot; 1.12, you can even force <i>all</i> modules loaded by a script to have their hidden Log4perl statements resurrected. For this to happen, load &quot;Log::Log4perl::Resurrector&quot;  <i>before</i> loading any modules:<div class="spacer">
</div>
<br/>
    use Log::Log4perl qw(:easy);<br/>
    use Log::Log4perl::Resurrector;<br/>
<br/>
    use Foobar; # All hidden Log4perl statements in here will<br/>
                # be uncommented before Foobar gets loaded.<br/>
<br/>
    Log::Log4perl-&gt;easy_init($DEBUG);<br/>
    ...<br/>
<div class="spacer">
</div>
Check the &quot;Log::Log4perl::Resurrector&quot; manpage for more details.</div>
<div class="subsection">
<h2>Access defined appenders</h2> All appenders defined in the configuration file or via Perl code can be retrieved by the &quot;appender_by_name()&quot; class method. This comes in handy if you want to manipulate or query appender properties after the Log4perl configuration has been loaded via &quot;init()&quot;.<div class="spacer">
</div>
Note that internally, Log::Log4perl uses the &quot;Log::Log4perl::Appender&quot; wrapper class to control the real appenders (like &quot;Log::Log4perl::Appender::File&quot; or &quot;Log::Dispatch::FileRotate&quot;). The &quot;Log::Log4perl::Appender&quot; class has an &quot;appender&quot; attribute, pointing to the real appender.<div class="spacer">
</div>
The reason for this is that external appenders like &quot;Log::Dispatch::FileRotate&quot; don't support all of Log::Log4perl's appender control mechanisms (like appender thresholds).<div class="spacer">
</div>
The previously mentioned method &quot;appender_by_name()&quot; returns a reference to the  <i>real</i> appender object. If you want access to the wrapper class (e.g. if you want to modify the appender's threshold), use the hash $Log::Log4perl::Logger::APPENDER_BY_NAME{...} instead, which holds references to all appender wrapper objects.</div>
<div class="subsection">
<h2>Modify appender thresholds</h2> To conveniently adjust appender thresholds (e.g. because a script uses  <i>more_logging()</i>), use<div class="spacer">
</div>
<br/>
       # decrease thresholds of all appenders<br/>
    Log::Log4perl-&gt;appender_thresholds_adjust(-1);<br/>
<div class="spacer">
</div>
This will decrease the thresholds of all appenders in the system by one level, i.e. WARN becomes INFO, INFO becomes DEBUG, etc. To only modify selected ones, use<div class="spacer">
</div>
<br/>
       # decrease thresholds of all appenders<br/>
    Log::Log4perl-&gt;appender_thresholds_adjust(-1, ['AppName1', ...]);<br/>
<div class="spacer">
</div>
and pass the names of affected appenders in a ref to an array.</div>
</div>
<div class="section">
<h1>Advanced configuration within Perl</h1> Initializing Log::Log4perl can certainly also be done from within Perl. At last, this is what &quot;Log::Log4perl::Config&quot; does behind the scenes. Log::Log4perl's configuration file parsers are using a publically available API to set up Log::Log4perl's categories, appenders and layouts.<div class="spacer">
</div>
Here's an example on how to configure two appenders with the same layout in Perl, without using a configuration file at all:<div class="spacer">
</div>
<br/>
  ########################<br/>
  # Initialization section<br/>
  ########################<br/>
  use Log::Log4perl;<br/>
  use Log::Log4perl::Layout;<br/>
  use Log::Log4perl::Level;<br/>
<br/>
     # Define a category logger<br/>
  my $log = Log::Log4perl-&gt;get_logger(&quot;Foo::Bar&quot;);<br/>
<br/>
     # Define a layout<br/>
  my $layout = Log::Log4perl::Layout::PatternLayout-&gt;new(&quot;[%r] %F %L %m%n&quot;);<br/>
<br/>
     # Define a file appender<br/>
  my $file_appender = Log::Log4perl::Appender-&gt;new(<br/>
                          &quot;Log::Log4perl::Appender::File&quot;,<br/>
                          name      =&gt; &quot;filelog&quot;,<br/>
                          filename  =&gt; &quot;/tmp/my.log&quot;);<br/>
<br/>
     # Define a stdout appender<br/>
  my $stdout_appender =  Log::Log4perl::Appender-&gt;new(<br/>
                          &quot;Log::Log4perl::Appender::Screen&quot;,<br/>
                          name      =&gt; &quot;screenlog&quot;,<br/>
                          stderr    =&gt; 0);<br/>
<br/>
     # Have both appenders use the same layout (could be different)<br/>
  $stdout_appender-&gt;layout($layout);<br/>
  $file_appender-&gt;layout($layout);<br/>
<br/>
  $log-&gt;add_appender($stdout_appender);<br/>
  $log-&gt;add_appender($file_appender);<br/>
  $log-&gt;level($INFO);<br/>
<div class="spacer">
</div>
Please note the class of the appender object is passed as a <i>string</i> to &quot;Log::Log4perl::Appender&quot; in the  <i>first</i> argument. Behind the scenes, &quot;Log::Log4perl::Appender&quot; will create the necessary &quot;Log::Log4perl::Appender::*&quot; (or &quot;Log::Dispatch::*&quot;) object and pass along the name value pairs we provided to &quot;Log::Log4perl::Appender-&gt;new()&quot; after the first argument.<div class="spacer">
</div>
The &quot;name&quot; value is optional and if you don't provide one, &quot;Log::Log4perl::Appender-&gt;new()&quot; will create a unique one for you. The names and values of additional parameters are dependent on the requirements of the particular appender class and can be looked up in their manual pages.<div class="spacer">
</div>
A side note: In case you're wondering if &quot;Log::Log4perl::Appender-&gt;new()&quot; will also take care of the &quot;min_level&quot; argument to the &quot;Log::Dispatch::*&quot; constructors called behind the scenes -- yes, it does. This is because we want the &quot;Log::Dispatch&quot; objects to blindly log everything we send them (&quot;debug&quot; is their lowest setting) because  <i>we</i> in &quot;Log::Log4perl&quot; want to call the shots and decide on when and what to log.<div class="spacer">
</div>
The call to the appender's <i></i><i>layout()</i><i></i> method specifies the format (as a previously created &quot;Log::Log4perl::Layout::PatternLayout&quot; object) in which the message is being logged in the specified appender. If you don't specify a layout, the logger will fall back to &quot;Log::Log4perl::SimpleLayout&quot;, which logs the debug level, a hyphen (-) and the log message.<div class="spacer">
</div>
Layouts are objects, here's how you create them:<div class="spacer">
</div>
<br/>
        # Create a simple layout<br/>
    my $simple = Log::Log4perl::SimpleLayout();<br/>
<br/>
        # create a flexible layout:<br/>
        # (&quot;yyyy/MM/dd hh:mm:ss (file:lineno)&gt; message\n&quot;)<br/>
    my $pattern = Log::Log4perl::Layout::PatternLayout(&quot;%d (%F:%L)&gt; %m%n&quot;);<br/>
<div class="spacer">
</div>
Every appender has exactly one layout assigned to it. You assign the layout to the appender using the appender's &quot;layout()&quot; object:<div class="spacer">
</div>
<br/>
    my $app =  Log::Log4perl::Appender-&gt;new(<br/>
                  &quot;Log::Log4perl::Appender::Screen&quot;,<br/>
                  name      =&gt; &quot;screenlog&quot;,<br/>
                  stderr    =&gt; 0);<br/>
<br/>
        # Assign the previously defined flexible layout<br/>
    $app-&gt;layout($pattern);<br/>
<br/>
        # Add the appender to a previously defined logger<br/>
    $logger-&gt;add_appender($app);<br/>
<br/>
        # ... and you're good to go!<br/>
    $logger-&gt;debug(&quot;Blah&quot;);<br/>
        # =&gt; &quot;2002/07/10 23:55:35 (test.pl:207)&gt; Blah\n&quot;<br/>
<div class="spacer">
</div>
It's also possible to remove appenders from a logger:<div class="spacer">
</div>
<br/>
    $logger-&gt;remove_appender($appender_name);<br/>
<div class="spacer">
</div>
will remove an appender, specified by name, from a given logger. Please note that this does  <i>not</i> remove an appender from the system.<div class="spacer">
</div>
To eradicate an appender from the system, you need to call &quot;Log::Log4perl-&gt;eradicate_appender($appender_name)&quot; which will first remove the appender from every logger in the system and then will delete all references Log4perl holds to it.</div>
<div class="section">
<h1>How about Log::Dispatch::Config?</h1> Tatsuhiko Miyagawa's &quot;Log::Dispatch::Config&quot; is a very clever simplified logger implementation, covering some of the  <i>log4j</i> functionality. Among the things that &quot;Log::Log4perl&quot; can but &quot;Log::Dispatch::Config&quot; can't are:<dl>
<dt>
&#8226;</dt>
<dd>
You can't assign categories to loggers. For small systems that's fine, but if you can't turn off and on detailed logging in only a tiny subsystem of your environment, you're missing out on a majorly useful log4j feature.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Defining appender thresholds. Important if you want to solve problems like &quot;log all messages of level FATAL to STDERR, plus log all DEBUG messages in &quot;Foo::Bar&quot; to a log file&quot;. If you don't have appenders thresholds, there's no way to prevent cluttering STDERR with DEBUG messages.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
PatternLayout specifications in accordance with the standard (e.g. &quot;%d{HH:mm}&quot;).</dd>
</dl>
<div class="spacer">
</div>
Bottom line: Log::Dispatch::Config is fine for small systems with simple logging requirements. However, if you're designing a system with lots of subsystems which you need to control independantly, you'll love the features of &quot;Log::Log4perl&quot;, which is equally easy to use.</div>
<div class="section">
<h1>Using Log::Log4perl with wrapper functions and classes</h1> If you don't use &quot;Log::Log4perl&quot; as described above, but from a wrapper function, the pattern layout will generate wrong data for %F, %C, %L, and the like. Reason for this is that &quot;Log::Log4perl&quot;'s loggers assume a static caller depth to the application that's using them.<div class="spacer">
</div>
If you're using one (or more) wrapper functions, &quot;Log::Log4perl&quot; will indicate where your logger function called the loggers, not where your application called your wrapper:<div class="spacer">
</div>
<br/>
    use Log::Log4perl qw(:easy);<br/>
    Log::Log4perl-&gt;easy_init({ level =&gt; $DEBUG, <br/>
                               layout =&gt; &quot;%M %m%n&quot; });<br/>
<br/>
    sub mylog {<br/>
        my($message) = @_;<br/>
<br/>
        DEBUG $message;<br/>
    }<br/>
<br/>
    sub func {<br/>
        mylog &quot;Hello&quot;;<br/>
    }<br/>
<br/>
    func();<br/>
<div class="spacer">
</div>
prints<div class="spacer">
</div>
<br/>
    main::mylog Hello<br/>
<div class="spacer">
</div>
but that's probably not what your application expects. Rather, you'd want<div class="spacer">
</div>
<br/>
    main::func Hello<br/>
<div class="spacer">
</div>
because the &quot;func&quot; function called your logging function.<div class="spacer">
</div>
But don't dispair, there's a solution: Just register your wrapper package with Log4perl beforehand. If Log4perl then finds that it's being called from a registered wrapper, it will automatically step up to the next call frame.<div class="spacer">
</div>
<br/>
    Log::Log4perl-&gt;wrapper_register(__PACKAGE__);<br/>
<br/>
    sub mylog {<br/>
        my($message) = @_;<br/>
<br/>
        DEBUG $message;<br/>
    }<br/>
<div class="spacer">
</div>
Alternatively, you can increase the value of the global variable $Log::Log4perl::caller_depth (defaults to 0) by one for every wrapper that's in between your application and &quot;Log::Log4perl&quot;, then &quot;Log::Log4perl&quot; will compensate for the difference:<div class="spacer">
</div>
<br/>
    sub mylog {<br/>
        my($message) = @_;<br/>
<br/>
        local $Log::Log4perl::caller_depth =<br/>
              $Log::Log4perl::caller_depth + 1;<br/>
        DEBUG $message;<br/>
    }<br/>
<div class="spacer">
</div>
Also, note that if you're writing a subclass of Log4perl, like<div class="spacer">
</div>
<br/>
    package MyL4pWrapper;<br/>
    use Log::Log4perl;<br/>
    our @ISA = qw(Log::Log4perl);<br/>
<div class="spacer">
</div>
and you want to call <i>get_logger()</i> in your code, like<div class="spacer">
</div>
<br/>
    use MyL4pWrapper;<br/>
<br/>
    sub get_logger {<br/>
        my $logger = Log::Log4perl-&gt;get_logger();<br/>
    }<br/>
<div class="spacer">
</div>
then the <i>get_logger()</i> call will get a logger for the &quot;MyL4pWrapper&quot; category, not for the package calling the wrapper class as in<div class="spacer">
</div>
<br/>
    package UserPackage;<br/>
    my $logger = MyL4pWrapper-&gt;get_logger();<br/>
<div class="spacer">
</div>
To have the above call to get_logger return a logger for the &quot;UserPackage&quot; category, you need to tell Log4perl that &quot;MyL4pWrapper&quot; is a Log4perl wrapper class:<div class="spacer">
</div>
<br/>
    use MyL4pWrapper;<br/>
    Log::Log4perl-&gt;wrapper_register(__PACKAGE__);<br/>
<br/>
    sub get_logger {<br/>
          # Now gets a logger for the category of the calling package<br/>
        my $logger = Log::Log4perl-&gt;get_logger();<br/>
    }<br/>
<div class="spacer">
</div>
This feature works both for Log4perl-relaying classes like the wrapper described above, and for wrappers that inherit from Log4perl use Log4perl's get_logger function via inheritance, alike.</div>
<div class="section">
<h1>Access to Internals</h1> The following methods are only of use if you want to peek/poke in the internals of Log::Log4perl. Be careful not to disrupt its inner workings.<dl>
<dt>
&quot;Log::Log4perl-&gt;appenders()&quot;</dt>
<dd>
To find out which appenders are currently defined (not only for a particular logger, but overall), a &quot;appenders()&quot; method is available to return a reference to a hash mapping appender names to their Log::Log4perl::Appender object references.</dd>
</dl>
</div>
<div class="section">
<h1>Dirty Tricks</h1><dl>
<dt>
<i>infiltrate_lwp()</i></dt>
<dd>
The famous LWP::UserAgent module isn't Log::Log4perl-enabled. Often, though, especially when tracing Web-related problems, it would be helpful to get some insight on what's happening inside LWP::UserAgent. Ideally, LWP::UserAgent would even play along in the Log::Log4perl framework.<div style="height: 1.00em;">
&#160;</div>
A call to &quot;Log::Log4perl-&gt;infiltrate_lwp()&quot; does exactly this. In a very rude way, it pulls the rug from under LWP::UserAgent and transforms its &quot;debug/conn&quot; messages into &quot;debug()&quot; calls of loggers of the category &quot;LWP::UserAgent&quot;. Similarily, &quot;LWP::UserAgent&quot;'s &quot;trace&quot; messages are turned into &quot;Log::Log4perl&quot;'s &quot;info()&quot; method calls. Note that this only works for LWP::UserAgent versions &lt; 5.822, because this (and probably later) versions miss debugging functions entirely.</dd>
</dl>
<dl>
<dt>
Suppressing 'duplicate' LOGDIE messages</dt>
<dd>
If a script with a simple Log4perl configuration uses <i>logdie()</i> to catch errors and stop processing, as in<div style="height: 1.00em;">
&#160;</div>
<br/>
    use Log::Log4perl qw(:easy) ;<br/>
    Log::Log4perl-&gt;easy_init($DEBUG);<br/>
    <br/>
    shaky_function() or LOGDIE &quot;It failed!&quot;;<br/>
<div style="height: 1.00em;">
&#160;</div>
there's a cosmetic problem: The message gets printed twice:<div style="height: 1.00em;">
&#160;</div>
<br/>
    2005/07/10 18:37:14 It failed!<br/>
    It failed! at ./t line 12<br/>
<div style="height: 1.00em;">
&#160;</div>
The obvious solution is to use <i>LOGEXIT()</i> instead of <i>LOGDIE()</i>, but there's also a special tag for Log4perl that suppresses the second message:<div style="height: 1.00em;">
&#160;</div>
<br/>
    use Log::Log4perl qw(:no_extra_logdie_message);<br/>
<div style="height: 1.00em;">
&#160;</div>
This causes <i>logdie()</i> and <i>logcroak()</i> to call <i>exit()</i> instead of <i>die()</i>. To modify the script exit code in these occasions, set the variable $Log::Log4perl::LOGEXIT_CODE to the desired value, the default is 1.</dd>
</dl>
<dl>
<dt>
Redefine values without causing errors</dt>
<dd>
Log4perl's configuration file parser has a few basic safety mechanisms to make sure configurations are more or less sane.<div style="height: 1.00em;">
&#160;</div>
One of these safety measures is catching redefined values. For example, if you first write<div style="height: 1.00em;">
&#160;</div>
<br/>
    log4perl.category = WARN, Logfile<br/>
<div style="height: 1.00em;">
&#160;</div>
and then a couple of lines later<div style="height: 1.00em;">
&#160;</div>
<br/>
    log4perl.category = TRACE, Logfile<br/>
<div style="height: 1.00em;">
&#160;</div>
then you might have unintentionally overwritten the first value and Log4perl will die on this with an error (suspicious configurations always throw an error). Now, there's a chance that this is intentional, for example when you're lumping together several configuration files and actually  <i>want</i> the first value to overwrite the second. In this case use<div style="height: 1.00em;">
&#160;</div>
<br/>
    use Log::Log4perl qw(:nostrict);<br/>
<div style="height: 1.00em;">
&#160;</div>
to put Log4perl in a more permissive mode.</dd>
</dl>
</div>
<div class="section">
<h1>EXAMPLE</h1> A simple example to cut-and-paste and get started:<div class="spacer">
</div>
<br/>
    use Log::Log4perl qw(get_logger);<br/>
    <br/>
    my $conf = q(<br/>
    log4perl.category.Bar.Twix         = WARN, Logfile<br/>
    log4perl.appender.Logfile          = Log::Log4perl::Appender::File<br/>
    log4perl.appender.Logfile.filename = test.log<br/>
    log4perl.appender.Logfile.layout = \<br/>
        Log::Log4perl::Layout::PatternLayout<br/>
    log4perl.appender.Logfile.layout.ConversionPattern = %d %F{1} %L&gt; %m %n<br/>
    );<br/>
    <br/>
    Log::Log4perl::init(\$conf);<br/>
    <br/>
    my $logger = get_logger(&quot;Bar::Twix&quot;);<br/>
    $logger-&gt;error(&quot;Blah&quot;);<br/>
<div class="spacer">
</div>
This will log something like<div class="spacer">
</div>
<br/>
    2002/09/19 23:48:15 t1 25&gt; Blah<br/>
<div class="spacer">
</div>
to the log file &quot;test.log&quot;, which Log4perl will append to or create it if it doesn't exist already.</div>
<div class="section">
<h1>INSTALLATION</h1> If you want to use external appenders provided with &quot;Log::Dispatch&quot;, you need to install &quot;Log::Dispatch&quot; (2.00 or better) from CPAN, which itself depends on &quot;Attribute-Handlers&quot; and &quot;Params-Validate&quot;. And a lot of other modules, that's the reason why we're now shipping Log::Log4perl with its own standard appenders and only if you wish to use additional ones, you'll have to go through the &quot;Log::Dispatch&quot; installation process.<div class="spacer">
</div>
Log::Log4perl needs &quot;Test::More&quot;, &quot;Test::Harness&quot; and &quot;File::Spec&quot;, but they already come with fairly recent versions of perl. If not, everything's automatically fetched from CPAN if you're using the CPAN shell (CPAN.pm), because they're listed as dependencies.<div class="spacer">
</div>
&quot;Time::HiRes&quot; (1.20 or better) is required only if you need the fine-grained time stamps of the %r parameter in &quot;Log::Log4perl::Layout::PatternLayout&quot;.<div class="spacer">
</div>
Manual installation works as usual with<div class="spacer">
</div>
<br/>
    perl Makefile.PL<br/>
    make<br/>
    make test<br/>
    make install<br/>
<div class="spacer">
</div>
If you're running <b>Windows (98, 2000, NT, XP etc.)</b>, and you're too lazy to rummage through all of Log-Log4perl's dependencies, don't despair: We're providing a PPM package which installs easily with your Activestate Perl. Check &quot;how_can_i_install_log__log4perl_on_microsoft_windows&quot; in Log::Log4perl::FAQ for details.</div>
<div class="section">
<h1>DEVELOPMENT</h1> Log::Log4perl is still being actively developed. We will always make sure the test suite (approx. 500 cases) will pass, but there might still be bugs. please check http://github.com/mschilli/log4perl for the latest release. The api has reached a mature state, we will not change it unless for a good reason.<div class="spacer">
</div>
Bug reports and feedback are always welcome, just email them to our mailing list shown in the AUTHORS section. We're usually addressing them immediately.</div>
<div class="section">
<h1>REFERENCES</h1><dl>
<dt>
[1]</dt>
<dd>
Michael Schilli, &quot;Retire your debugger, log smartly with Log::Log4perl!&quot;, Tutorial on perl.com, 09/2002, http://www.perl.com/pub/a/2002/09/11/log4perl.html</dd>
</dl>
<dl>
<dt>
[2]</dt>
<dd>
Ceki GA~XlcA~X, &quot;Short introduction to log4j&quot;, http://jakarta.apache.org/log4j/docs/manual.html</dd>
</dl>
<dl>
<dt>
[3]</dt>
<dd>
Vipan Singla, &quot;Don't Use System.out.println! Use Log4j.&quot;, http://www.vipan.com/htdocs/log4jhelp.html</dd>
</dl>
<dl>
<dt>
[4]</dt>
<dd>
The Log::Log4perl project home page: http://log4perl.com</dd>
</dl>
</div>
<div class="section">
<h1>SEE ALSO</h1> Log::Log4perl::Config, Log::Log4perl::Appender, Log::Log4perl::Layout::PatternLayout, Log::Log4perl::Layout::SimpleLayout, Log::Log4perl::Level, Log::Log4perl::JavaMap Log::Log4perl::NDC,</div>
<div class="section">
<h1>AUTHORS</h1> Please contribute patches to the project page on Github:<div class="spacer">
</div>
<br/>
    http://github.com/mschilli/log4perl<br/>
<div class="spacer">
</div>
Bug reports or requests for enhancements to the authors via our<div class="spacer">
</div>
<br/>
    MAILING LIST (questions, bug reports, suggestions/patches): <br/>
    log4perl-devel@lists.sourceforge.net<br/>
<br/>
    Authors (please contact them via the list above, not directly)<br/>
    Mike Schilli &lt;m@perlmeister.com&gt;<br/>
    Kevin Goess &lt;cpan@goess.org&gt;<br/>
<br/>
    Contributors (in alphabetical order):<br/>
    Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton<br/>
    Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony<br/>
    Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy<br/>
    Grundman, Paul Harrington, David Hull, Robert Jacobson, Jason Kohles, <br/>
    Jeff Macdonald, Markus Peter, Brett Rann, Peter Rabbitson, Erik<br/>
    Selberg, Aaron Straup Cope, Lars Thegler, David Viner, Mac Yang.<br/>
</div>
<div class="section">
<h1>COPYRIGHT AND LICENSE</h1> Copyright 2002-2009 by Mike Schilli &lt;m@perlmeister.com&gt; and Kevin Goess &lt;cpan@goess.org&gt;.<div class="spacer">
</div>
This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</div>
<table class="foot">
<tr>
<td class="foot-date">
2010-06-17</td>
<td class="foot-os">
perl v5.10.1</td>
</tr>
</table>
</div>
</body>
</html>

