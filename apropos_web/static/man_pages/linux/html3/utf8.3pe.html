<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
utf8(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
utf8(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
utf8(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> utf8 - Perl pragma to enable/disable UTF-8 (or UTF-EBCDIC) in source code</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
    use utf8;<br/>
    no utf8;<br/>
<br/>
    # Convert the internal representation of a Perl scalar to/from UTF-8.<br/>
<br/>
    $num_octets = utf8::upgrade($string);<br/>
    $success    = utf8::downgrade($string[, FAIL_OK]);<br/>
<br/>
    # Change each character of a Perl scalar to/from a series of<br/>
    # characters that represent the UTF-8 bytes of each original character.<br/>
<br/>
    utf8::encode($string);  # &quot;\x{100}&quot;  becomes &quot;\xc4\x80&quot;<br/>
    utf8::decode($string);  # &quot;\xc4\x80&quot; becomes &quot;\x{100}&quot;<br/>
<br/>
    $flag = utf8::is_utf8(STRING); # since Perl 5.8.1<br/>
    $flag = utf8::valid(STRING);<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> The &quot;use utf8&quot; pragma tells the Perl parser to allow UTF-8 in the program text in the current lexical scope (allow UTF-EBCDIC on EBCDIC based platforms).  The &quot;no utf8&quot; pragma tells Perl to switch back to treating the source text as literal bytes in the current lexical scope.<div class="spacer">
</div>
<b>Do not use this pragma for anything else than telling Perl that your</b>  <b>script is written in UTF-8.</b> The utility functions described below are directly usable without &quot;use utf8;&quot;.<div class="spacer">
</div>
Because it is not possible to reliably tell UTF-8 from native 8 bit encodings, you need either a Byte Order Mark at the beginning of your source code, or &quot;use utf8;&quot;, to instruct perl.<div class="spacer">
</div>
When UTF-8 becomes the standard source format, this pragma will effectively become a no-op.  For convenience in what follows the term  <i>UTF-X</i> is used to refer to UTF-8 on ASCII and ISO Latin based platforms and UTF-EBCDIC on EBCDIC based platforms.<div class="spacer">
</div>
See also the effects of the &quot;-C&quot; switch and its cousin, the $ENV{PERL_UNICODE}, in perlrun.<div class="spacer">
</div>
Enabling the &quot;utf8&quot; pragma has the following effect:<dl>
<dt>
&#8226;</dt>
<dd>
Bytes in the source text that have their high-bit set will be treated as being part of a literal UTF-X sequence.  This includes most literals such as identifier names, string constants, and constant regular expression patterns.<div style="height: 1.00em;">
&#160;</div>
On EBCDIC platforms characters in the Latin 1 character set are treated as being part of a literal UTF-EBCDIC character.</dd>
</dl>
<div class="spacer">
</div>
Note that if you have bytes with the eighth bit on in your script (for example embedded Latin-1 in your string literals), &quot;use utf8&quot; will be unhappy since the bytes are most probably not well-formed UTF-X.  If you want to have such bytes under &quot;use utf8&quot;, you can disable this pragma until the end the block (or file, if at top level) by &quot;no utf8;&quot;.<div class="subsection">
<h2>Utility functions</h2> The following functions are defined in the &quot;utf8::&quot; package by the Perl core.  You do not need to say &quot;use utf8&quot; to use these and in fact you should not say that  unless you really want to have UTF-8 source code.<dl>
<dt>
&#8226;</dt>
<dd>
$num_octets = utf8::upgrade($string)<div style="height: 1.00em;">
&#160;</div>
Converts in-place the internal representation of the string from an octet sequence in the native encoding (Latin-1 or EBCDIC) to  <i>UTF-X</i>. The logical character sequence itself is unchanged.  If  <i></i><i>$string</i><i></i> is already stored as  <i>UTF-X</i>, then this is a no-op. Returns the number of octets necessary to represent the string as  <i>UTF-X</i>.  Can be used to make sure that the UTF-8 flag is on, so that &quot;\w&quot; or &quot;lc()&quot; work as Unicode on strings containing characters in the range 0x80-0xFF (on ASCII and derivatives).<div style="height: 1.00em;">
&#160;</div>
<b>Note that this function does not handle arbitrary encodings.</b> Therefore Encode is recommended for the general purposes; see also Encode.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
$success = utf8::downgrade($string[, FAIL_OK])<div style="height: 1.00em;">
&#160;</div>
Converts in-place the internal representation of the string from  <i>UTF-X</i> to the equivalent octet sequence in the native encoding (Latin-1 or EBCDIC). The logical character sequence itself is unchanged. If  <i></i><i>$string</i><i></i> is already stored as native 8 bit, then this is a no-op.  Can be used to make sure that the UTF-8 flag is off, e.g. when you want to make sure that the  <i>substr()</i> or <i>length()</i> function works with the usually faster byte algorithm.<div style="height: 1.00em;">
&#160;</div>
Fails if the original <i>UTF-X</i> sequence cannot be represented in the native 8 bit encoding. On failure dies or, if the value of &quot;FAIL_OK&quot; is true, returns false.<div style="height: 1.00em;">
&#160;</div>
Returns true on success.<div style="height: 1.00em;">
&#160;</div>
<b>Note that this function does not handle arbitrary encodings.</b> Therefore Encode is recommended for the general purposes; see also Encode.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
utf8::encode($string)<div style="height: 1.00em;">
&#160;</div>
Converts in-place the character sequence to the corresponding octet sequence in  <i>UTF-X</i>. That is, every (possibly wide) character gets replaced with a sequence of one or more characters that represent the individual  <i>UTF-X</i> bytes of the character.  The UTF8 flag is turned off. Returns nothing.<div style="height: 1.00em;">
&#160;</div>
<br/>
    my $a = &quot;\x{100}&quot;; # $a contains one character, with ord 0x100<br/>
    utf8::encode($a);  # $a contains two characters, with ords 0xc4 and 0x80<br/>
<div style="height: 1.00em;">
&#160;</div>
<b>Note that this function does not handle arbitrary encodings.</b> Therefore Encode is recommended for the general purposes; see also Encode.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
$success = utf8::decode($string)<div style="height: 1.00em;">
&#160;</div>
Attempts to convert in-place the octet sequence in <i>UTF-X</i> to the corresponding character sequence. That is, it replaces each sequence of characters in the string whose ords represent a valid UTF-X byte sequence, with the corresponding single character.  The UTF-8 flag is turned on only if the source string contains multiple-byte  <i>UTF-X</i> characters.  If  <i></i><i>$string</i><i></i> is invalid as <i>UTF-X</i>, returns false; otherwise returns true.<div style="height: 1.00em;">
&#160;</div>
<br/>
    my $a = &quot;\xc4\x80&quot;; # $a contains two characters, with ords 0xc4 and 0x80<br/>
    utf8::decode($a);   # $a contains one character, with ord 0x100<br/>
<div style="height: 1.00em;">
&#160;</div>
<b>Note that this function does not handle arbitrary encodings.</b> Therefore Encode is recommended for the general purposes; see also Encode.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
$flag = utf8::is_utf8(STRING)<div style="height: 1.00em;">
&#160;</div>
(Since Perl 5.8.1)  Test whether STRING is in UTF-8 internally. Functionally the same as  <i>Encode::is_utf8()</i>.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
$flag = utf8::valid(STRING)<div style="height: 1.00em;">
&#160;</div>
[INTERNAL] Test whether STRING is in a consistent state regarding UTF-8.  Will return true is well-formed UTF-8 and has the UTF-8 flag on  <b>or</b> if string is held as bytes (both these states are 'consistent'). Main reason for this routine is to allow Perl's testsuite to check that operations have left strings in a consistent state.  You most probably want to use  <i>utf8::is_utf8()</i> instead.</dd>
</dl>
<div class="spacer">
</div>
&quot;utf8::encode&quot; is like &quot;utf8::upgrade&quot;, but the UTF8 flag is cleared.  See perlunicode for more on the UTF8 flag and the C API functions &quot;sv_utf8_upgrade&quot;, &quot;sv_utf8_downgrade&quot;, &quot;sv_utf8_encode&quot;, and &quot;sv_utf8_decode&quot;, which are wrapped by the Perl functions &quot;utf8::upgrade&quot;, &quot;utf8::downgrade&quot;, &quot;utf8::encode&quot; and &quot;utf8::decode&quot;.  Also, the functions utf8::is_utf8, utf8::valid, utf8::encode, utf8::decode, utf8::upgrade, and utf8::downgrade are actually internal, and thus always available, without a &quot;require utf8&quot; statement.</div>
</div>
<div class="section">
<h1>BUGS</h1> One can have Unicode in identifier names, but not in package/class or subroutine names.  While some limited functionality towards this does exist as of Perl 5.8.0, that is more accidental than designed; use of Unicode for the said purposes is unsupported.<div class="spacer">
</div>
One reason of this unfinishedness is its (currently) inherent unportability: since both package names and subroutine names may need to be mapped to file and directory names, the Unicode capability of the filesystem becomes important-- and there unfortunately aren't portable answers.</div>
<div class="section">
<h1>SEE ALSO</h1> perlunitut, perluniintro, perlrun, bytes, perlunicode</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-09-19</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

