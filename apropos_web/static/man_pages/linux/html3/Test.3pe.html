<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Test(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Test(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
Test(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Test - provides a simple framework for writing test scripts</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
  use strict;<br/>
  use Test;<br/>
<br/>
  # use a BEGIN block so we print our plan before MyModule is loaded<br/>
  BEGIN { plan tests =&gt; 14, todo =&gt; [3,4] }<br/>
<br/>
  # load your module...<br/>
  use MyModule;<br/>
<br/>
  # Helpful notes.  All note-lines must start with a &quot;#&quot;.<br/>
  print &quot;# I'm testing MyModule version $MyModule::VERSION\n&quot;;<br/>
<br/>
  ok(0); # failure<br/>
  ok(1); # success<br/>
<br/>
  ok(0); # ok, expected failure (see todo list, above)<br/>
  ok(1); # surprise success!<br/>
<br/>
  ok(0,1);             # failure: '0' ne '1'<br/>
  ok('broke','fixed'); # failure: 'broke' ne 'fixed'<br/>
  ok('fixed','fixed'); # success: 'fixed' eq 'fixed'<br/>
  ok('fixed',qr/x/);   # success: 'fixed' =~ qr/x/<br/>
<br/>
  ok(sub { 1+1 }, 2);  # success: '2' eq '2'<br/>
  ok(sub { 1+1 }, 3);  # failure: '2' ne '3'<br/>
<br/>
  my @list = (0,0);<br/>
  ok @list, 3, &quot;\@list=&quot;.join(',',@list);      #extra notes<br/>
  ok 'segmentation fault', '/(?i)success/';    #regex match<br/>
<br/>
  skip(<br/>
    $^O =~ m/MSWin/ ? &quot;Skip if MSWin&quot; : 0,  # whether to skip<br/>
    $foo, $bar  # arguments just like for ok(...)<br/>
  );<br/>
  skip(<br/>
    $^O =~ m/MSWin/ ? 0 : &quot;Skip unless MSWin&quot;,  # whether to skip<br/>
    $foo, $bar  # arguments just like for ok(...)<br/>
  );<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> This module simplifies the task of writing test files for Perl modules, such that their output is in the format that Test::Harness expects to see.</div>
<div class="section">
<h1>QUICK START GUIDE</h1> To write a test for your new (and probably not even done) module, create a new file called  <i>t/test.t</i> (in a new <i>t</i> directory). If you have multiple test files, to test the &quot;foo&quot;, &quot;bar&quot;, and &quot;baz&quot; feature sets, then feel free to call your files  <i>t/foo.t</i>, <i>t/bar.t</i>, and  <i>t/baz.t</i><div class="subsection">
<h2>Functions</h2> This module defines three public functions, &quot;plan(...)&quot;, &quot;ok(...)&quot;, and &quot;skip(...)&quot;.  By default, all three are exported by the &quot;use Test;&quot; statement.<dl>
<dt>
&quot;plan(...)&quot;</dt>
<dd>
<br/>
     BEGIN { plan %theplan; }<br/>
<div style="height: 1.00em;">
&#160;</div>
This should be the first thing you call in your test script.  It declares your testing plan, how many there will be, if any of them should be allowed to fail, and so on.<div style="height: 1.00em;">
&#160;</div>
Typical usage is just:<div style="height: 1.00em;">
&#160;</div>
<br/>
     use Test;<br/>
     BEGIN { plan tests =&gt; 23 }<br/>
<div style="height: 1.00em;">
&#160;</div>
These are the things that you can put in the parameters to plan:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
&quot;tests =&gt; <i>number</i>&quot;</dt>
<dd>
The number of tests in your script. This means all  <i>ok()</i> and <i>skip()</i> calls.</dd>
</dl>
<dl>
<dt>
&quot;todo =&gt; [<i>1,5,14</i>]&quot;</dt>
<dd>
A reference to a list of tests which are allowed to fail. See &quot;TODO TESTS&quot;.</dd>
</dl>
<dl>
<dt>
&quot;onfail =&gt; sub { ... }&quot;</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
&quot;onfail =&gt; \&amp;some_sub&quot;</dt>
<dd>
A subroutine reference to be run at the end of the test script, if any of the tests fail.  See &quot;ONFAIL&quot;.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">
&#160;</div>
You must call &quot;plan(...)&quot; once and only once.  You should call it in a &quot;BEGIN {...}&quot; block, like so:<div style="height: 1.00em;">
&#160;</div>
<br/>
     BEGIN { plan tests =&gt; 23 }<br/>
</div>
<dl>
<dt>
&quot;ok(...)&quot;</dt>
<dd>
<br/>
  ok(1 + 1 == 2);<br/>
  ok($have, $expect);<br/>
  ok($have, $expect, $diagnostics);<br/>
<div style="height: 1.00em;">
&#160;</div>
This function is the reason for &quot;Test&quot;'s existence.  It's the basic function that handles printing &quot;&quot;ok&quot;&quot; or &quot;&quot;not ok&quot;&quot;, along with the current test number.  (That's what &quot;Test::Harness&quot; wants to see.)<div style="height: 1.00em;">
&#160;</div>
In its most basic usage, &quot;ok(...)&quot; simply takes a single scalar expression.  If its value is true, the test passes; if false, the test fails.  Examples:<div style="height: 1.00em;">
&#160;</div>
<br/>
    # Examples of ok(scalar)<br/>
<br/>
    ok( 1 + 1 == 2 );           # ok if 1 + 1 == 2<br/>
    ok( $foo =~ /bar/ );        # ok if $foo contains 'bar'<br/>
    ok( baz($x + $y) eq 'Armondo' );    # ok if baz($x + $y) returns<br/>
                                        # 'Armondo'<br/>
    ok( @a == @b );             # ok if @a and @b are the same length<br/>
<div style="height: 1.00em;">
&#160;</div>
The expression is evaluated in scalar context.  So the following will work:<div style="height: 1.00em;">
&#160;</div>
<br/>
    ok( @stuff );                       # ok if @stuff has any elements<br/>
    ok( !grep !defined $_, @stuff );    # ok if everything in @stuff is<br/>
                                        # defined.<br/>
<div style="height: 1.00em;">
&#160;</div>
A special case is if the expression is a subroutine reference (in either &quot;sub {...}&quot; syntax or &quot;\&amp;foo&quot; syntax).  In that case, it is executed and its value (true or false) determines if the test passes or fails.  For example,<div style="height: 1.00em;">
&#160;</div>
<br/>
    ok( sub {   # See whether sleep works at least passably<br/>
      my $start_time = time;<br/>
      sleep 5;<br/>
      time() - $start_time  &gt;= 4<br/>
    });<br/>
<div style="height: 1.00em;">
&#160;</div>
In its two-argument form, &quot;ok(<i>arg1</i>, <i>arg2</i>)&quot; compares the two scalar values to see if they match.  They match if both are undefined, or if  <i>arg2</i> is a regex that matches <i>arg1</i>, or if they compare equal with &quot;eq&quot;.<div style="height: 1.00em;">
&#160;</div>
<br/>
    # Example of ok(scalar, scalar)<br/>
<br/>
    ok( &quot;this&quot;, &quot;that&quot; );               # not ok, 'this' ne 'that'<br/>
    ok( &quot;&quot;, undef );                    # not ok, &quot;&quot; is defined<br/>
<div style="height: 1.00em;">
&#160;</div>
The second argument is considered a regex if it is either a regex object or a string that looks like a regex.  Regex objects are constructed with the qr// operator in recent versions of perl.  A string is considered to look like a regex if its first and last characters are &quot;/&quot;, or if the first character is &quot;m&quot; and its second and last characters are both the same non-alphanumeric non-whitespace character.  These regexp<div style="height: 1.00em;">
&#160;</div>
Regex examples:<div style="height: 1.00em;">
&#160;</div>
<br/>
    ok( 'JaffO', '/Jaff/' );    # ok, 'JaffO' =~ /Jaff/<br/>
    ok( 'JaffO', 'm|Jaff|' );   # ok, 'JaffO' =~ m|Jaff|<br/>
    ok( 'JaffO', qr/Jaff/ );    # ok, 'JaffO' =~ qr/Jaff/;<br/>
    ok( 'JaffO', '/(?i)jaff/ ); # ok, 'JaffO' =~ /jaff/i;<br/>
<div style="height: 1.00em;">
&#160;</div>
If either (or both!) is a subroutine reference, it is run and used as the value for comparing.  For example:<div style="height: 1.00em;">
&#160;</div>
<br/>
    ok sub {<br/>
        open(OUT, &quot;&gt;x.dat&quot;) || die $!;<br/>
        print OUT &quot;\x{e000}&quot;;<br/>
        close OUT;<br/>
        my $bytecount = -s 'x.dat';<br/>
        unlink 'x.dat' or warn &quot;Can't unlink : $!&quot;;<br/>
        return $bytecount;<br/>
      },<br/>
      4<br/>
    ;<br/>
<div style="height: 1.00em;">
&#160;</div>
The above test passes two values to &quot;ok(arg1, arg2)&quot; -- the first a coderef, and the second is the number 4.  Before &quot;ok&quot; compares them, it calls the coderef, and uses its return value as the real value of this parameter. Assuming that $bytecount returns 4, &quot;ok&quot; ends up testing &quot;4 eq 4&quot;.  Since that's true, this test passes.<div style="height: 1.00em;">
&#160;</div>
Finally, you can append an optional third argument, in &quot;ok( <i>arg1</i>,<i>arg2</i>, <i>note</i>)&quot;, where <i>note</i> is a string value that will be printed if the test fails.  This should be some useful information about the test, pertaining to why it failed, and/or a description of the test.  For example:<div style="height: 1.00em;">
&#160;</div>
<br/>
    ok( grep($_ eq 'something unique', @stuff), 1,<br/>
        &quot;Something that should be unique isn't!\n&quot;.<br/>
        '@stuff = '.join ', ', @stuff<br/>
      );<br/>
<div style="height: 1.00em;">
&#160;</div>
Unfortunately, a note cannot be used with the single argument style of &quot;ok()&quot;.  That is, if you try &quot;ok( <i>arg1</i>, <i>note</i>)&quot;, then &quot;Test&quot; will interpret this as &quot;ok( <i>arg1</i>, <i>arg2</i>)&quot;, and probably end up testing &quot; <i>arg1</i> eq <i>arg2</i>&quot; -- and that's not what you want!<div style="height: 1.00em;">
&#160;</div>
All of the above special cases can occasionally cause some problems.  See &quot;BUGS and CAVEATS&quot;.</dd>
</dl>
<dl>
<dt>
&quot;skip(<i>skip_if_true</i>, <i>args...</i>)&quot;</dt>
<dd>
This is used for tests that under some conditions can be skipped.  It's basically equivalent to:<div style="height: 1.00em;">
&#160;</div>
<br/>
  if( $skip_if_true ) {<br/>
    ok(1);<br/>
  } else {<br/>
    ok( args... );<br/>
  }<br/>
<div style="height: 1.00em;">
&#160;</div>
...except that the ok(1) emits not just &quot;&quot;ok <i>testnum</i>&quot;&quot; but actually &quot;&quot;ok  <i>testnum</i> # <i>skip_if_true_value</i>&quot;&quot;.<div style="height: 1.00em;">
&#160;</div>
The arguments after the <i>skip_if_true</i> are what is fed to &quot;ok(...)&quot; if this test isn't skipped.<div style="height: 1.00em;">
&#160;</div>
Example usage:<div style="height: 1.00em;">
&#160;</div>
<br/>
  my $if_MSWin =<br/>
    $^O =~ m/MSWin/ ? 'Skip if under MSWin' : '';<br/>
<br/>
  # A test to be skipped if under MSWin (i.e., run except under MSWin)<br/>
  skip($if_MSWin, thing($foo), thing($bar) );<br/>
<div style="height: 1.00em;">
&#160;</div>
Or, going the other way:<div style="height: 1.00em;">
&#160;</div>
<br/>
  my $unless_MSWin =<br/>
    $^O =~ m/MSWin/ ? '' : 'Skip unless under MSWin';<br/>
<br/>
  # A test to be skipped unless under MSWin (i.e., run only under MSWin)<br/>
  skip($unless_MSWin, thing($foo), thing($bar) );<br/>
<div style="height: 1.00em;">
&#160;</div>
The tricky thing to remember is that the first parameter is true if you want to  <i>skip</i> the test, not <i>run</i> it; and it also doubles as a note about why it's being skipped. So in the first codeblock above, read the code as &quot;skip if MSWin -- (otherwise) test whether &quot;thing($foo)&quot; is &quot;thing($bar)&quot;&quot; or for the second case, &quot;skip unless MSWin...&quot;.<div style="height: 1.00em;">
&#160;</div>
Also, when your <i>skip_if_reason</i> string is true, it really should (for backwards compatibility with older Test.pm versions) start with the string &quot;Skip&quot;, as shown in the above examples.<div style="height: 1.00em;">
&#160;</div>
Note that in the above cases, &quot;thing($foo)&quot; and &quot;thing($bar)&quot;  <i>are</i> evaluated -- but as long as the &quot;skip_if_true&quot; is true, then we &quot;skip(...)&quot; just tosses out their value (i.e., not bothering to treat them like values to &quot;ok(...)&quot;.  But if you need to  <i>not</i> eval the arguments when skipping the test, use this format:<div style="height: 1.00em;">
&#160;</div>
<br/>
  skip( $unless_MSWin,<br/>
    sub {<br/>
      # This code returns true if the test passes.<br/>
      # (But it doesn't even get called if the test is skipped.)<br/>
      thing($foo) eq thing($bar)<br/>
    }<br/>
  );<br/>
<div style="height: 1.00em;">
&#160;</div>
or even this, which is basically equivalent:<div style="height: 1.00em;">
&#160;</div>
<br/>
  skip( $unless_MSWin,<br/>
    sub { thing($foo) }, sub { thing($bar) }<br/>
  );<br/>
<div style="height: 1.00em;">
&#160;</div>
That is, both are like this:<div style="height: 1.00em;">
&#160;</div>
<br/>
  if( $unless_MSWin ) {<br/>
    ok(1);  # but it actually appends &quot;# $unless_MSWin&quot;<br/>
            #  so that Test::Harness can tell it's a skip<br/>
  } else {<br/>
    # Not skipping, so actually call and evaluate...<br/>
    ok( sub { thing($foo) }, sub { thing($bar) } );<br/>
  }<br/>
</dd>
</dl>
</div>
</div>
<div class="section">
<h1>TEST TYPES</h1><dl>
<dt>
&#8226;</dt>
<dd>
NORMAL TESTS<div style="height: 1.00em;">
&#160;</div>
These tests are expected to succeed.  Usually, most or all of your tests are in this category.  If a normal test doesn't succeed, then that means that something is  <i>wrong</i>.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
SKIPPED TESTS<div style="height: 1.00em;">
&#160;</div>
The &quot;skip(...)&quot; function is for tests that might or might not be possible to run, depending on the availability of platform-specific features.  The first argument should evaluate to true (think &quot;yes, please skip&quot;) if the required feature is  <i>not</i> available.  After the first argument, &quot;skip(...)&quot; works exactly the same way as &quot;ok(...)&quot; does.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
TODO TESTS<div style="height: 1.00em;">
&#160;</div>
TODO tests are designed for maintaining an <b>executable TODO list</b>. These tests are  <i>expected to fail.</i>  If a TODO test does succeed, then the feature in question shouldn't be on the TODO list, now should it?<div style="height: 1.00em;">
&#160;</div>
Packages should NOT be released with succeeding TODO tests.  As soon as a TODO test starts working, it should be promoted to a normal test, and the newly working feature should be documented in the release notes or in the change log.</dd>
</dl>
</div>
<div class="section">
<h1>ONFAIL</h1><br/>
  BEGIN { plan test =&gt; 4, onfail =&gt; sub { warn &quot;CALL 911!&quot; } }<br/>
<div class="spacer">
</div>
Although test failures should be enough, extra diagnostics can be triggered at the end of a test run.  &quot;onfail&quot; is passed an array ref of hash refs that describe each test failure.  Each hash will contain at least the following fields: &quot;package&quot;, &quot;repetition&quot;, and &quot;result&quot;.  (You shouldn't rely on any other fields being present.)  If the test had an expected value or a diagnostic (or &quot;note&quot;) string, these will also be included.<div class="spacer">
</div>
The <i>optional</i> &quot;onfail&quot; hook might be used simply to print out the version of your package and/or how to report problems.  It might also be used to generate extremely sophisticated diagnostics for a particularly bizarre test failure.  However it's not a panacea.  Core dumps or other unrecoverable errors prevent the &quot;onfail&quot; hook from running.  (It is run inside an &quot;END&quot; block.)  Besides, &quot;onfail&quot; is probably over-kill in most cases.  (Your test code should be simpler than the code it is testing, yes?)</div>
<div class="section">
<h1>BUGS and CAVEATS</h1><dl>
<dt>
&#8226;</dt>
<dd>
&quot;ok(...)&quot;'s special handing of strings which look like they might be regexes can also cause unexpected behavior.  An innocent:<div style="height: 1.00em;">
&#160;</div>
<br/>
    ok( $fileglob, '/path/to/some/*stuff/' );<br/>
<div style="height: 1.00em;">
&#160;</div>
will fail, since Test.pm considers the second argument to be a regex! The best bet is to use the one-argument form:<div style="height: 1.00em;">
&#160;</div>
<br/>
    ok( $fileglob eq '/path/to/some/*stuff/' );<br/>
</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;ok(...)&quot;'s use of string &quot;eq&quot; can sometimes cause odd problems when comparing numbers, especially if you're casting a string to a number:<div style="height: 1.00em;">
&#160;</div>
<br/>
    $foo = &quot;1.0&quot;;<br/>
    ok( $foo, 1 );      # not ok, &quot;1.0&quot; ne 1<br/>
<div style="height: 1.00em;">
&#160;</div>
Your best bet is to use the single argument form:<div style="height: 1.00em;">
&#160;</div>
<br/>
    ok( $foo == 1 );    # ok &quot;1.0&quot; == 1<br/>
</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
As you may have inferred from the above documentation and examples, &quot;ok&quot;'s prototype is &quot;($;$$)&quot; (and, incidentally, &quot;skip&quot;'s is &quot;($;$$$)&quot;). This means, for example, that you can do &quot;ok @foo, @bar&quot; to compare the  <i>size</i> of the two arrays. But don't be fooled into thinking that &quot;ok @foo, @bar&quot; means a comparison of the contents of two arrays -- you're comparing  <i>just</i> the number of elements of each. It's so easy to make that mistake in reading &quot;ok @foo, @bar&quot; that you might want to be very explicit about it, and instead write &quot;ok scalar(@foo), scalar(@bar)&quot;.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
This almost definitely doesn't do what you expect:<div style="height: 1.00em;">
&#160;</div>
<br/>
     ok $thingy-&gt;can('some_method');<br/>
<div style="height: 1.00em;">
&#160;</div>
Why?  Because &quot;can&quot; returns a coderef to mean &quot;yes it can (and the method is this...)&quot;, and then &quot;ok&quot; sees a coderef and thinks you're passing a function that you want it to call and consider the truth of the result of!  I.e., just like:<div style="height: 1.00em;">
&#160;</div>
<br/>
     ok $thingy-&gt;can('some_method')-&gt;();<br/>
<div style="height: 1.00em;">
&#160;</div>
What you probably want instead is this:<div style="height: 1.00em;">
&#160;</div>
<br/>
     ok $thingy-&gt;can('some_method') &amp;&amp; 1;<br/>
<div style="height: 1.00em;">
&#160;</div>
If the &quot;can&quot; returns false, then that is passed to &quot;ok&quot;.  If it returns true, then the larger expression &quot;$thingy-&gt;can('some_method')&#160;&amp;&amp;&#160;1&quot; returns 1, which &quot;ok&quot; sees as a simple signal of success, as you would expect.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
The syntax for &quot;skip&quot; is about the only way it can be, but it's still quite confusing.  Just start with the above examples and you'll be okay.<div style="height: 1.00em;">
&#160;</div>
Moreover, users may expect this:<div style="height: 1.00em;">
&#160;</div>
<br/>
  skip $unless_mswin, foo($bar), baz($quux);<br/>
<div style="height: 1.00em;">
&#160;</div>
to not evaluate &quot;foo($bar)&quot; and &quot;baz($quux)&quot; when the test is being skipped.  But in reality, they  <i>are</i> evaluated, but &quot;skip&quot; just won't bother comparing them if $unless_mswin is true.<div style="height: 1.00em;">
&#160;</div>
You could do this:<div style="height: 1.00em;">
&#160;</div>
<br/>
  skip $unless_mswin, sub{foo($bar)}, sub{baz($quux)};<br/>
<div style="height: 1.00em;">
&#160;</div>
But that's not terribly pretty.  You may find it simpler or clearer in the long run to just do things like this:<div style="height: 1.00em;">
&#160;</div>
<br/>
  if( $^O =~ m/MSWin/ ) {<br/>
    print &quot;# Yay, we're under $^O\n&quot;;<br/>
    ok foo($bar), baz($quux);<br/>
    ok thing($whatever), baz($stuff);<br/>
    ok blorp($quux, $whatever);<br/>
    ok foo($barzbarz), thang($quux);<br/>
  } else {<br/>
    print &quot;# Feh, we're under $^O.  Watch me skip some tests...\n&quot;;<br/>
    for(1 .. 4) { skip &quot;Skip unless under MSWin&quot; }<br/>
  }<br/>
<div style="height: 1.00em;">
&#160;</div>
But be quite sure that &quot;ok&quot; is called exactly as many times in the first block as &quot;skip&quot; is called in the second block.</dd>
</dl>
</div>
<div class="section">
<h1>ENVIRONMENT</h1> If &quot;PERL_TEST_DIFF&quot; environment variable is set, it will be used as a command for comparing unexpected multiline results.  If you have GNU diff installed, you might want to set &quot;PERL_TEST_DIFF&quot; to &quot;diff -u&quot;. If you don't have a suitable program, you might install the &quot;Text::Diff&quot; module and then set &quot;PERL_TEST_DIFF&quot; to be &quot;perl -MText::Diff -e 'print diff(@ARGV)'&quot;.  If &quot;PERL_TEST_DIFF&quot; isn't set but the &quot;Algorithm::Diff&quot; module is available, then it will be used to show the differences in multiline results.</div>
<div class="section">
<h1>NOTE</h1> A past developer of this module once said that it was no longer being actively developed.  However, rumors of its demise were greatly exaggerated.  Feedback and suggestions are quite welcome.<div class="spacer">
</div>
Be aware that the main value of this module is its simplicity.  Note that there are already more ambitious modules out there, such as Test::More and Test::Unit.<div class="spacer">
</div>
Some earlier versions of this module had docs with some confusing typos in the description of &quot;skip(...)&quot;.</div>
<div class="section">
<h1>SEE ALSO</h1> Test::Harness<div class="spacer">
</div>
Test::Simple, Test::More, Devel::Cover<div class="spacer">
</div>
Test::Builder for building your own testing library.<div class="spacer">
</div>
Test::Unit is an interesting XUnit-style testing library.<div class="spacer">
</div>
Test::Inline and SelfTest let you embed tests in code.</div>
<div class="section">
<h1>AUTHOR</h1> Copyright (c) 1998-2000 Joshua Nathaniel Pritikin.<div class="spacer">
</div>
Copyright (c) 2001-2002 Michael G. Schwern.<div class="spacer">
</div>
Copyright (c) 2002-2004 Sean M. Burke.<div class="spacer">
</div>
Current maintainer: Jesse Vincent. &lt;jesse@bestpractical.com&gt;<div class="spacer">
</div>
This package is free software and is provided &quot;as is&quot; without express or implied warranty.  It may be used, redistributed and/or modified under the same terms as Perl itself.</div>
<table class="foot">
<tr>
<td class="foot-date">
2010-12-30</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

