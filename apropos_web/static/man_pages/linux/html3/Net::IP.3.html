<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
IP(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
IP(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
IP(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Net::IP - Perl extension for manipulating IPv4/IPv6 addresses</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
  use Net::IP;<br/>
  <br/>
  my $ip = new Net::IP ('193.0.1/24') or die (Net::IP::Error());<br/>
  print (&quot;IP  : &quot;.$ip-&gt;ip().&quot;\n&quot;);<br/>
  print (&quot;Sho : &quot;.$ip-&gt;short().&quot;\n&quot;);<br/>
  print (&quot;Bin : &quot;.$ip-&gt;binip().&quot;\n&quot;);<br/>
  print (&quot;Int : &quot;.$ip-&gt;intip().&quot;\n&quot;);<br/>
  print (&quot;Mask: &quot;.$ip-&gt;mask().&quot;\n&quot;);<br/>
  print (&quot;Last: &quot;.$ip-&gt;last_ip().&quot;\n&quot;);<br/>
  print (&quot;Len : &quot;.$ip-&gt;prefixlen().&quot;\n&quot;);<br/>
  print (&quot;Size: &quot;.$ip-&gt;size().&quot;\n&quot;);<br/>
  print (&quot;Type: &quot;.$ip-&gt;iptype().&quot;\n&quot;);<br/>
  print (&quot;Rev:  &quot;.$ip-&gt;reverse_ip().&quot;\n&quot;);<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> This module provides functions to deal with  <b>IPv4/IPv6</b> addresses. The module can be used as a class, allowing the user to instantiate IP objects, which can be single IP addresses, prefixes, or ranges of addresses. There is also a procedural way of accessing most of the functions. Most subroutines can take either  <b>IPv4</b> or <b>IPv6</b> addresses transparently.</div>
<div class="section">
<h1>OBJECT-ORIENTED INTERFACE</h1><div class="subsection">
<h2>Object Creation</h2> A Net::IP object can be created from a single IP address:<div class="spacer">
</div>
<br/>
  $ip = new Net::IP ('193.0.1.46') || die ...<br/>
<div class="spacer">
</div>
Or from a Classless Prefix (a /24 prefix is equivalent to a C class):<div class="spacer">
</div>
<br/>
  $ip = new Net::IP ('195.114.80/24') || die ...<br/>
<div class="spacer">
</div>
Or from a range of addresses:<div class="spacer">
</div>
<br/>
  $ip = new Net::IP ('20.34.101.207 - 201.3.9.99') || die ...<br/>
<div class="spacer">
</div>
Or from a address plus a number:<div class="spacer">
</div>
<br/>
  $ip = new Net::IP ('20.34.10.0 + 255') || die ...<br/>
<div class="spacer">
</div>
The <i>new()</i> function accepts IPv4 and IPv6 addresses:<div class="spacer">
</div>
<br/>
  $ip = new Net::IP ('dead:beef::/32') || die ...<br/>
<div class="spacer">
</div>
Optionnaly, the function can be passed the version of the IP. Otherwise, it tries to guess what the version is (see  <b></b><b><i>_is_ipv4()</i></b><b></b> and <b></b><b><i>_is_ipv6()</i></b><b></b>).<div class="spacer">
</div>
<br/>
  $ip = new Net::IP ('195/8',4); # Class A<br/>
</div>
</div>
<div class="section">
<h1>OBJECT METHODS</h1> Most of these methods are front-ends for the real functions, which use a procedural interface. Most functions return undef on failure, and a true value on success. A detailed description of the procedural interface is provided below.<div class="subsection">
<h2>set</h2> Set an IP address in an existing IP object. This method has the same functionality as the  <i>new()</i> method, except that it reuses an existing object to store the new IP.<div class="spacer">
</div>
&quot;$ip-&gt;set('130.23.1/24',4);&quot;<div class="spacer">
</div>
Like <i>new()</i>, <i>set()</i> takes two arguments - a string used to build an IP address, prefix, or range, and optionally, the IP version of the considered address.<div class="spacer">
</div>
It returns an IP object on success, and undef on failure.</div>
<div class="subsection">
<h2>error</h2> Return the current object error string. The error string is set whenever one of the methods produces an error. Also, a global, class-wide  <b></b><b><i>Error()</i></b><b></b> function is available.<div class="spacer">
</div>
&quot;warn ($ip-&gt;error());&quot;</div>
<div class="subsection">
<h2>errno</h2> Return the current object error number. The error number is set whenever one of the methods produces an error. Also, a global  <b></b><b>$ERRNO</b><b></b> variable is set when an error is produced.<div class="spacer">
</div>
&quot;warn ($ip-&gt;errno());&quot;</div>
<div class="subsection">
<h2>ip</h2> Return the IP address (or first IP of the prefix or range) in quad format, as a string.<div class="spacer">
</div>
&quot;print ($ip-&gt;ip());&quot;</div>
<div class="subsection">
<h2>binip</h2> Return the IP address as a binary string of 0s and 1s.<div class="spacer">
</div>
&quot;print ($ip-&gt;binip());&quot;</div>
<div class="subsection">
<h2>prefixlen</h2> Return the length in bits of the current prefix.<div class="spacer">
</div>
&quot;print ($ip-&gt;prefixlen());&quot;</div>
<div class="subsection">
<h2>version</h2> Return the version of the current IP object (4 or 6).<div class="spacer">
</div>
&quot;print ($ip-&gt;version());&quot;</div>
<div class="subsection">
<h2>size</h2> Return the number of IP addresses in the current prefix or range. Use of this function requires Math::BigInt.<div class="spacer">
</div>
&quot;print ($ip-&gt;size());&quot;</div>
<div class="subsection">
<h2>binmask</h2> Return the binary mask of the current prefix, if applicable.<div class="spacer">
</div>
&quot;print ($ip-&gt;binmask());&quot;</div>
<div class="subsection">
<h2>mask</h2> Return the mask in quad format of the current prefix.<div class="spacer">
</div>
&quot;print ($ip-&gt;mask());&quot;</div>
<div class="subsection">
<h2>prefix</h2> Return the full prefix (ip+prefix length) in quad (standard) format.<div class="spacer">
</div>
&quot;print ($ip-&gt;prefix());&quot;</div>
<div class="subsection">
<h2>print</h2> Print the IP object (IP/Prefix or First - Last)<div class="spacer">
</div>
&quot;print ($ip-&gt;print());&quot;</div>
<div class="subsection">
<h2>intip</h2> Convert the IP in integer format and return it as a Math::BigInt object.<div class="spacer">
</div>
&quot;print ($ip-&gt;intip());&quot;</div>
<div class="subsection">
<h2>hexip</h2> Return the IP in hex format<div class="spacer">
</div>
&quot;print ($ip-&gt;hexip());&quot;</div>
<div class="subsection">
<h2>hexmask</h2> Return the mask in hex format<div class="spacer">
</div>
&quot;print ($ip-&gt;hexmask());&quot;</div>
<div class="subsection">
<h2>short</h2> Return the IP in short format: 	IPv4 addresses: 194.5/16 	IPv6 addresses: ab32:f000::<div class="spacer">
</div>
&quot;print ($ip-&gt;short());&quot;</div>
<div class="subsection">
<h2>iptype</h2> Return the IP Type - this describes the type of an IP (Public, Private, Reserved, etc.)<div class="spacer">
</div>
&quot;print ($ip-&gt;iptype());&quot;</div>
<div class="subsection">
<h2>reverse_ip</h2> Return the reverse IP for a given IP address (in.addr. format).<div class="spacer">
</div>
&quot;print ($ip-&gt;reserve_ip());&quot;</div>
<div class="subsection">
<h2>last_ip</h2> Return the last IP of a prefix/range in quad format.<div class="spacer">
</div>
&quot;print ($ip-&gt;last_ip());&quot;</div>
<div class="subsection">
<h2>last_bin</h2> Return the last IP of a prefix/range in binary format.<div class="spacer">
</div>
&quot;print ($ip-&gt;last_bin());&quot;</div>
<div class="subsection">
<h2>last_int</h2> Return the last IP of a prefix/range in integer format.<div class="spacer">
</div>
&quot;print ($ip-&gt;last_int());&quot;</div>
<div class="subsection">
<h2>find_prefixes</h2> This function finds all the prefixes that can be found between the two addresses of a range. The function returns a list of prefixes.<div class="spacer">
</div>
&quot;@list = $ip-&gt;find_prefixes($other_ip));&quot;</div>
<div class="subsection">
<h2>bincomp</h2> Binary comparaison of two IP objects. The function takes an operation and an IP object as arguments. It returns a boolean value.<div class="spacer">
</div>
The operation can be one of: lt: less than (smaller than) le: smaller or equal to gt: greater than ge: greater or equal to<div class="spacer">
</div>
&quot;if ($ip-&gt;bincomp('lt',$ip2) {...}&quot;</div>
<div class="subsection">
<h2>binadd</h2> Binary addition of two IP objects. The value returned is an IP object.<div class="spacer">
</div>
&quot;my $sum = $ip-&gt;binadd($ip2);&quot;</div>
<div class="subsection">
<h2>aggregate</h2> Aggregate 2 IPs - Append one range/prefix of IPs to another. The last address of the first range must be the one immediately preceding the first address of the second range. A new IP object is returned.<div class="spacer">
</div>
&quot;my $total = $ip-&gt;aggregate($ip2);&quot;</div>
<div class="subsection">
<h2>overlaps</h2> Check if two IP ranges/prefixes overlap each other. The value returned by the function should be one of: 	$IP_PARTIAL_OVERLAP (ranges overlap) 	$IP_NO_OVERLAP      (no overlap) 	$IP_A_IN_B_OVERLAP  (range2 contains range1) 	$IP_B_IN_A_OVERLAP  (range1 contains range2) 	$IP_IDENTICAL       (ranges are identical) 	undef               (problem)<div class="spacer">
</div>
&quot;if ($ip-&gt;overlaps($ip2)==$IP_A_IN_B_OVERLAP) {...};&quot;</div>
<div class="subsection">
<h2>looping</h2> The &quot;+&quot; operator is overloaded in order to allow looping though a whole range of IP addresses:<div class="spacer">
</div>
<br/>
  my $ip = new Net::IP ('195.45.6.7 - 195.45.6.19') || die;<br/>
  # Loop<br/>
  do {<br/>
      print $ip-&gt;ip(), &quot;\n&quot;;<br/>
  } while (++$ip);<br/>
<div class="spacer">
</div>
The ++ operator returns undef when the last address of the range is reached.</div>
<div class="subsection">
<h2>auth</h2> Return IP authority information from the IP::Authority module<div class="spacer">
</div>
&quot;$auth = ip-&quot;auth ();&gt;<div class="spacer">
</div>
Note: IPv4 only</div>
</div>
<div class="section">
<h1>PROCEDURAL INTERFACE</h1> These functions do the real work in the module. Like the OO methods, most of these return undef on failure. In order to access error codes and strings, instead of using $ip-&gt; <i>error()</i> and $ip-&gt;<i>errno()</i>, use the global functions &quot;Error()&quot; and &quot;Errno()&quot;.<div class="spacer">
</div>
The functions of the procedural interface are not exported by default. In order to import these functions, you need to modify the use statement for the module:<div class="spacer">
</div>
&quot;use Net::IP qw(:PROC);&quot;<div class="subsection">
<h2>Error</h2> Returns the error string corresponding to the last error generated in the module. This is also useful for the OO interface, as if the  <i>new()</i> function fails, we cannot call $ip-&gt; <i>error()</i> and so we have to use <i>Error()</i>.<div class="spacer">
</div>
warn <i>Error()</i>;</div>
<div class="subsection">
<h2>Errno</h2> Returns a numeric error code corresponding to the error string returned by Error.</div>
<div class="subsection">
<h2>ip_iptobin</h2> Transform an IP address into a bit string.<div class="spacer">
</div>
<br/>
    Params  : IP address, IP version<br/>
    Returns : binary IP string on success, undef otherwise<br/>
<div class="spacer">
</div>
&quot;$binip = ip_iptobin ($ip,6);&quot;</div>
<div class="subsection">
<h2>ip_bintoip</h2> Transform a bit string into an IP address<div class="spacer">
</div>
<br/>
    Params  : binary IP, IP version<br/>
    Returns : IP address on success, undef otherwise<br/>
<div class="spacer">
</div>
&quot;$ip = ip_bintoip ($binip,6);&quot;</div>
<div class="subsection">
<h2>ip_bintoint</h2> Transform a bit string into a BigInt.<div class="spacer">
</div>
<br/>
    Params  : binary IP<br/>
    Returns : BigInt<br/>
<div class="spacer">
</div>
&quot;$bigint = new Math::BigInt (ip_bintoint($binip));&quot;</div>
<div class="subsection">
<h2>ip_inttobin</h2> Transform a BigInt into a bit string.  <i>Warning</i>: sets warnings (&quot;-w&quot;) off. This is necessary because Math::BigInt is not compliant.<div class="spacer">
</div>
<br/>
    Params  : BigInt, IP version<br/>
    Returns : binary IP<br/>
<div class="spacer">
</div>
&quot;$binip = ip_inttobin ($bigint);&quot;</div>
<div class="subsection">
<h2>ip_get_version</h2> Try to guess the IP version of an IP address.<div class="spacer">
</div>
<br/>
    Params  : IP address<br/>
    Returns : 4, 6, undef(unable to determine)<br/>
<div class="spacer">
</div>
&quot;$version = ip_get_version ($ip)&quot;</div>
<div class="subsection">
<h2>ip_is_ipv4</h2> Check if an IP address is of type 4.<div class="spacer">
</div>
<br/>
    Params  : IP address<br/>
    Returns : 1 (yes) or 0 (no)<br/>
<div class="spacer">
</div>
&quot;ip_is_ipv4($ip) and print &quot;$ip is IPv4&quot;;&quot;</div>
<div class="subsection">
<h2>ip_is_ipv6</h2> Check if an IP address is of type 6.<div class="spacer">
</div>
<br/>
    Params            : IP address<br/>
    Returns           : 1 (yes) or 0 (no)<br/>
<div class="spacer">
</div>
&quot;ip_is_ipv6($ip) and print &quot;$ip is IPv6&quot;;&quot;</div>
<div class="subsection">
<h2>ip_expand_address</h2> Expand an IP address from compact notation.<div class="spacer">
</div>
<br/>
    Params  : IP address, IP version<br/>
    Returns : expanded IP address or undef on failure<br/>
<div class="spacer">
</div>
&quot;$ip = ip_expand_address ($ip,4);&quot;</div>
<div class="subsection">
<h2>ip_get_mask</h2> Get IP mask from prefix length.<div class="spacer">
</div>
<br/>
    Params  : Prefix length, IP version<br/>
    Returns : Binary Mask<br/>
<div class="spacer">
</div>
&quot;$mask = ip_get_mask ($len,6);&quot;</div>
<div class="subsection">
<h2>ip_last_address_bin</h2> Return the last binary address of a prefix.<div class="spacer">
</div>
<br/>
    Params  : First binary IP, prefix length, IP version<br/>
    Returns : Binary IP<br/>
<div class="spacer">
</div>
&quot;$lastbin = ip_last_address_bin ($ip,$len,6);&quot;</div>
<div class="subsection">
<h2>ip_splitprefix</h2> Split a prefix into IP and prefix length. If it was passed a simple IP, it just returns it.<div class="spacer">
</div>
<br/>
    Params  : Prefix<br/>
    Returns : IP, optionally length of prefix<br/>
<div class="spacer">
</div>
&quot;($ip,$len) = ip_splitprefix ($prefix)&quot;</div>
<div class="subsection">
<h2>ip_prefix_to_range</h2> Get a range of IPs from a prefix.<div class="spacer">
</div>
<br/>
    Params  : Prefix, IP version<br/>
    Returns : First IP, last IP<br/>
<div class="spacer">
</div>
&quot;($ip1,$ip2) = ip_prefix_to_range ($prefix,6);&quot;</div>
<div class="subsection">
<h2>ip_bincomp</h2> Compare binary Ips with &lt;, &gt;, &lt;=, &gt;=.<br/>
 Operators are lt(&lt;), le(&lt;=), gt(&gt;), and ge(&gt;=)<div class="spacer">
</div>
<br/>
    Params  : First binary IP, operator, Last binary IP<br/>
    Returns : 1 (yes), 0 (no), or undef (problem)<br/>
<div class="spacer">
</div>
&quot;ip_bincomp ($ip1,'lt',$ip2) == 1 or do {}&quot;</div>
<div class="subsection">
<h2>ip_binadd</h2> Add two binary IPs.<div class="spacer">
</div>
<br/>
    Params  : First binary IP, Last binary IP<br/>
    Returns : Binary sum or undef (problem)<br/>
<div class="spacer">
</div>
&quot;$binip = ip_binadd ($bin1,$bin2);&quot;</div>
<div class="subsection">
<h2>ip_get_prefix_length</h2> Get the prefix length for a given range of 2 IPs.<div class="spacer">
</div>
<br/>
    Params  : First binary IP, Last binary IP<br/>
    Returns : Length of prefix or undef (problem)<br/>
<div class="spacer">
</div>
&quot;$len = ip_get_prefix_length ($ip1,$ip2);&quot;</div>
<div class="subsection">
<h2>ip_range_to_prefix</h2> Return all prefixes between two IPs.<div class="spacer">
</div>
<br/>
    Params  : First IP, Last IP, IP version<br/>
    Returns : List of Prefixes or undef (problem)<br/>
<div class="spacer">
</div>
The prefixes returned have the form q.q.q.q/nn.<div class="spacer">
</div>
&quot;@prefix = ip_range_to_prefix ($ip1,$ip2,6);&quot;</div>
<div class="subsection">
<h2>ip_compress_v4_prefix</h2> Compress an IPv4 Prefix.<div class="spacer">
</div>
<br/>
    Params  : IP, Prefix length<br/>
    Returns : Compressed Prefix<br/>
<div class="spacer">
</div>
&quot;$ip = ip_compress_v4_prefix ($ip, $len);&quot;</div>
<div class="subsection">
<h2>ip_compress_address</h2> Compress an IPv6 address. Just returns the IP if it is an IPv4.<div class="spacer">
</div>
<br/>
    Params  : IP, IP version<br/>
    Returns : Compressed IP or undef (problem)<br/>
<div class="spacer">
</div>
&quot;$ip = ip_compress_adress ($ip, $version);&quot;</div>
<div class="subsection">
<h2>ip_is_overlap</h2> Check if two ranges of IPs overlap.<div class="spacer">
</div>
<br/>
    Params  : Four binary IPs (begin of range 1,end1,begin2,end2), IP version<br/>
        $IP_PARTIAL_OVERLAP (ranges overlap) <br/>
        $IP_NO_OVERLAP      (no overlap)<br/>
        $IP_A_IN_B_OVERLAP  (range2 contains range1)<br/>
        $IP_B_IN_A_OVERLAP  (range1 contains range2)<br/>
        $IP_IDENTICAL       (ranges are identical)<br/>
        undef               (problem)<br/>
<div class="spacer">
</div>
&quot;(ip_is_overlap($rb1,$re1,$rb2,$re2,4) eq $IP_A_IN_B_OVERLAP) and do {};&quot;</div>
<div class="subsection">
<h2>ip_get_embedded_ipv4</h2> Get an IPv4 embedded in an IPv6 address<div class="spacer">
</div>
<br/>
    Params  : IPv6<br/>
    Returns : IPv4 string or undef (not found)<br/>
<div class="spacer">
</div>
&quot;$ip4 = ip_get_embedded($ip6);&quot;</div>
<div class="subsection">
<h2>ip_check_mask</h2> Check the validity of a binary IP mask<div class="spacer">
</div>
<br/>
    Params  : Mask<br/>
    Returns : 1 or undef (invalid)<br/>
<div class="spacer">
</div>
&quot;ip_check_mask($binmask) or do {};&quot;<div class="spacer">
</div>
Checks if mask has only 1s followed by 0s.</div>
<div class="subsection">
<h2>ip_aggregate</h2> Aggregate 2 ranges of binary IPs<div class="spacer">
</div>
<br/>
    Params  : 1st range (1st IP, Last IP), last range (1st IP, last IP), IP version<br/>
    Returns : prefix or undef (invalid)<br/>
<div class="spacer">
</div>
&quot;$prefix = ip_aggregate ($bip1,$eip1,$bip2,$eip2) || die ...&quot;</div>
<div class="subsection">
<h2>ip_iptype</h2> Return the type of an IP (Public, Private, Reserved)<div class="spacer">
</div>
<br/>
    Params  : IP to test, IP version<br/>
    Returns : type or undef (invalid)<br/>
<div class="spacer">
</div>
&quot;$type = ip_iptype ($ip);&quot;</div>
<div class="subsection">
<h2>ip_check_prefix</h2> Check the validity of a prefix<div class="spacer">
</div>
<br/>
    Params  : binary IP, length of prefix, IP version<br/>
    Returns : 1 or undef (invalid)<br/>
<div class="spacer">
</div>
Checks if the variant part of a prefix only has 0s, and the length is correct.<div class="spacer">
</div>
&quot;ip_check_prefix ($ip,$len,$ipv) or do {};&quot;</div>
<div class="subsection">
<h2>ip_reverse</h2> Get a reverse name from a prefix<div class="spacer">
</div>
<br/>
    Params  : IP, length of prefix, IP version<br/>
    Returns : Reverse name or undef (error)<br/>
<div class="spacer">
</div>
&quot;$reverse = ip_reverse ($ip);&quot;</div>
<div class="subsection">
<h2>ip_normalize</h2> Normalize data to a range/prefix of IP addresses<div class="spacer">
</div>
<br/>
    Params  : Data String (Single IP, Range, Prefix)<br/>
    Returns : ip1, ip2 (if range/prefix) or undef (error)<br/>
<div class="spacer">
</div>
&quot;($ip1,$ip2) = ip_normalize ($data);&quot;</div>
<div class="subsection">
<h2>ip_auth</h2> Return IP authority information from the IP::Authority module<div class="spacer">
</div>
<br/>
    Params  : IP, version<br/>
    Returns : Auth info (RI for RIPE, AR for ARIN, etc)<br/>
<div class="spacer">
</div>
&quot;$auth = ip_auth ($ip,4);&quot;<div class="spacer">
</div>
Note: IPv4 only</div>
</div>
<div class="section">
<h1>BUGS</h1> The Math::BigInt library is needed for functions that use integers. These are ip_inttobin, ip_bintoint, and the size method. In a next version, Math::BigInt will become optional.</div>
<div class="section">
<h1>AUTHORS</h1> Manuel Valente &lt;manuel.valente@gmail.com&gt;.<div class="spacer">
</div>
Original IPv4 code by Monica Cortes Sack &lt;mcortes@ripe.net&gt;.<div class="spacer">
</div>
Original IPv6 code by Lee Wilmot &lt;lee@ripe.net&gt;.</div>
<div class="section">
<h1>BASED ON</h1> ipv4pack.pm, iplib.pm, iplibncc.pm.</div>
<div class="section">
<h1>SEE ALSO</h1>  <i>perl</i>(1), IP::Authority</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-05-13</td>
<td class="foot-os">
perl v5.12.3</td>
</tr>
</table>
</div>
</body>
</html>

