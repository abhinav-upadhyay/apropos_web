<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Internals(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Internals(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
Internals(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> CallingTk -  what is Perl Tk interface doing when you call Tk functions.<div class="spacer">
</div>
This information is worse than useless for &quot;perlTk&quot; users, but can of some help for people interested in using modified Tk source with &quot;perlTk&quot;.<div class="spacer">
</div>
This document is under construction. The information is believed to be pertinent to the version of &quot;portableTk&quot; available when it was created. All the details are subject to change.</div>
<div class="section">
<h1>DESCRIPTION</h1><dl>
<dt>
PreCompiling</dt>
<dd>
Before the actual compilation stage a script scans the source and extracts the subcommands of different commands. This information resides in the file &quot;pTk/Methods.def&quot;.</dd>
</dl>
<dl>
<dt>
Compilation</dt>
<dd>
During compilation the above file is included in the source of booting routine of dynamic (or static) library. More precisely, the booting code of module &quot;Tk&quot; calls the subroutine  <i>Boot_Glue()</i> from the module &quot;tkGlue.c&quot;, and this subroutine includes the file (with appropriate macro definitions).</dd>
</dl>
<dl>
<dt>
Inside &quot;use Tk;&quot;</dt>
<dd>
The module bootstraps the C code, then loads the Perl libraries. The heart of the Perl code is contained in the &quot;Tk::Widget&quot; library, all the widgets inherit from this module. Code for toplevels is loaded from &quot;Tk::MainWindow&quot;.<div style="height: 1.00em;">
&#160;</div>
During bootstrap of the C glue code the &quot;Xevent::?&quot; codes and a handful of &quot;Tk::Widget&quot; and &quot;Tk::Image&quot; routines are defined. (Much more XSUBs are created from &quot;Tk.xs&quot; code.) The widget subcommands are glued to Perl basing on the list included from &quot;pTk/Methods.def&quot;. In fact all the subcommands are glued to XSUBs that are related to the same C subroutine  <i>XStoWidget()</i>, but have different data parts.<div style="height: 1.00em;">
&#160;</div>
During the Perl code bootstrap the method &quot;Tk::Widget::import&quot; is called. This call requires all the code from particular widget packages.<div style="height: 1.00em;">
&#160;</div>
Code from the widget packages calls an obscure command like<div style="height: 1.00em;">
&#160;</div>
<br/>
  (bless \&quot;Text&quot;)-&gt;WidgetClass;<br/>
<div style="height: 1.00em;">
&#160;</div>
This command (actually <i>Tk::Widget::WidgetClass()</i>) creates three routines:  <i>Tk::Widget::Text()</i>, <i>Tk::Widget::isText()</i>, and  <i>Tk::Text::isText()</i>. The first one is basically &quot;new&quot; of &quot;Tk::Text&quot;, the other two return constants. It also puts the class into depository.</dd>
</dl>
<dl>
<dt>
Inside &quot;$top = MainWindow-&gt;new;&quot;</dt>
<dd>
This is quite intuitive. This call goes direct to &quot;Tk::MainWindow::new&quot;, that calls XSUB &quot;Tk::MainWindow::CreateMainWindow&quot;, that calls C subroutine  <i>Tk_CreateMainWindow()</i>. It is a &quot;Tk&quot; subroutine, so here black magic ends (almost).<div style="height: 1.00em;">
&#160;</div>
The only remaining black magic is that the &quot;Tk&quot; initialization routine creates a lot of commands, but the subroutine for creation is usurped by  <b>portableTk</b> and the commands are created in the package &quot;Tk&quot;. They are associated to XSUBs that are related to one of three C subroutines  <i>XStoSubCmd()</i>, <i>XStoBind()</i>, or <i>XStoTk()</i>, but have different data parts.<div style="height: 1.00em;">
&#160;</div>
The result of the call is blessed into &quot;Tk::MainWindow&quot;, as it should.</dd>
</dl>
<dl>
<dt>
Inside &quot;$top-&gt;title('Text demo');&quot;</dt>
<dd>
The package &quot;Tk::Toplevel&quot; defines a lot of subroutines on the fly on some list. All the commands from the list are converted to the corresponding subcommands of &quot;wm&quot; method of the widget. Here subcommand is a command with some particular second argument (in this case &quot;title&quot;). Recall that the first argument is $self.<div style="height: 1.00em;">
&#160;</div>
Now &quot;Tk::Toplevel&quot; @ISA &quot;Tk::Widget&quot;, that in turn @ISA &quot;Tk&quot;. So a call to &quot;$top-&gt;wm('title','Text demo')&quot; calls &quot;Tk::wm&quot;, that is defined during call to  <i>Tk_CreateMainWindow()</i>. As it is described above, the XSUB associated to  <i>XStoSubCmd()</i> is called.<div style="height: 1.00em;">
&#160;</div>
This C routine is defined in &quot;tkGlue.c&quot;. It gets the data part of XSUB, creates a &quot;SV&quot; with the name of the command, and calls  <i>Call_Tk()</i> with the XSUB data as the first argument, and with the name of XSUB stuffed into the Perl stack in the place there &quot;tk&quot; expects it. (In fact it can also reorder the arguments if it thinks it is what you want).<div style="height: 1.00em;">
&#160;</div>
The latter procedure extracts name of &quot;tk&quot; procedure and &quot;clientData&quot; from the first argument and makes a call, using Perl stack as &quot;argv&quot; for the procedure. A lot of black magic is performed afterwards to convert result of the procedure to a Perl array return.</dd>
</dl>
<dl>
<dt>
Inside &quot;$text = $top-&gt;Text(background =&gt; $txtBg);&quot;</dt>
<dd>
Above we discussed how the command &quot;Tk::Widget::Text&quot; is created. The above command calls it via inheritance. It is translated to<div style="height: 1.00em;">
&#160;</div>
<br/>
  Tk::Text::new($top, background =&gt; $txtBg);<br/>
<div style="height: 1.00em;">
&#160;</div>
The package &quot;Tk::Text&quot; has no method &quot;new&quot;, so the &quot;Tk::Widget::new&quot; is called. In turn it calls &quot;Tk::Text-&gt;DoInit($top)&quot;, that is &quot;Tk::Widget::DoInit(Tk::Text,$top)&quot;, that initializes the bindings if necessary. Then it creates the name for the widget of the form &quot;.text0&quot;, and calls &quot;Tk::text('.text0', background =&gt; $txtBg)&quot; (note lowercase). The result of the call is blessed into &quot;Tk::Text&quot;, and the method &quot;bindtags&quot; for this object is called.<div style="height: 1.00em;">
&#160;</div>
Now the only thing to discuss is who defines the methods &quot;text&quot; and &quot;bindtags&quot;. The answer is that they are defined in &quot;tkWindow.c&quot;, and these commands are created in the package &quot;Tk&quot; in the same sweep that created the command &quot;Tk::wm&quot; discussed above.<div style="height: 1.00em;">
&#160;</div>
So the the same C code that corresponds to the processing of corresponding TCL commands is called here as well (this time via &quot;XStoTk&quot; interface).</dd>
</dl>
<dl>
<dt>
Inside &quot;$text-&gt;insert('insert','Hello, world!');&quot;</dt>
<dd>
As we discussed above, the subcommands of widget procedures correspond to XSUB &quot;XStoWidget&quot;. This XSUB substitutes the first argument $text (that is a hash reference) to an appropriate value from this hash, adds the additional argument after the first one that contains the name of the subcommand extracted from the data part of XSUB, and calls the corresponding Tk C subroutine via &quot;Call_Tk&quot;.</dd>
</dl>
<div class="spacer">
</div>
Ilya Zakharevich &lt;ilya@math.ohio-state.edu&gt;</div>
<table class="foot">
<tr>
<td class="foot-date">
2007-02-10</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

