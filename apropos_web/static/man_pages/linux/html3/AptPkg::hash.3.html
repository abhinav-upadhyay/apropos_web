<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
AptPkg::hash(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
AptPkg::hash(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
AptPkg::hash(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> AptPkg::hash - a helper class for implementing tied hashes</div>
<div class="section">
<h1>SYNOPSIS</h1> use AptPkg::hash;</div>
<div class="section">
<h1>DESCRIPTION</h1> The AptPkg::hash class provides hash-like access for objects which have an underlying XS implementation.<div class="spacer">
</div>
Such objects need to add AptPkg::hash to @ISA, provide get, set and exists methods, and an iterator class.<div class="subsection">
<h2>AptPkg::hash</h2><dl>
<dt>
new([<i>XS_OBJECT</i>])</dt>
<dd>
Create a object as a tied hash.  The object is implemented as a hash reference blessed into the class, which in turn is tied to AptPkg::hash.<div style="height: 1.00em;">
&#160;</div>
This means that both $obj-&gt;<i>method()</i> and $obj-&gt;{key} valid, the latter invoking get/set (through FETCH/STORE).<div style="height: 1.00em;">
&#160;</div>
The tie associates an array reference with the hash, which initially contains a reference to the hash, the XS object and an anon hash which may be used by subclasses to store state information.<div style="height: 1.00em;">
&#160;</div>
If no XS object is passed, one is created via new in the XS class. The name of that class is constructed from the class name, by lower-casing the last component and prefixing it with an underscore (eg. AptPkg::Config becomes AptPkg::_config).<div style="height: 1.00em;">
&#160;</div>
If the module contains a @KEYS array, then the private hash will be populated with those entries as keys (see the description below of the AptPkg::hash::method class).</dd>
</dl>
<dl>
<dt>
_self, _xs, _priv</dt>
<dd>
Accessors which may be used in subclass methods to fetch the three array elements associated with the hash reference.</dd>
</dl>
<dl>
<dt>
keys(<i>ARGS</i>)</dt>
<dd>
In a scalar context, creates and returns a new iterator object (the class name with the suffix ::Iter appended).<div style="height: 1.00em;">
&#160;</div>
The XS object, the private hash and any arguments are passed to the constructor.<div style="height: 1.00em;">
&#160;</div>
In an array context, the iterator is used to generate a list of keys which are then returned.<div style="height: 1.00em;">
&#160;</div>
The iterator class must implement a next method, which returns the current key and advances to the next.</dd>
</dl>
</div>
<div class="subsection">
<h2>AptPkg::hash::method</h2> The AptPkg::hash::method class extends AptPkg::hash, providing a simple way to map a fixed set of keys (defined by the @KEYS array) into method calls on either the object, or the internal XS object.<div class="spacer">
</div>
Classes inheriting from AptPkg::hash::method should provide an iterator class which inherits from AptPkg::hash::method::iter.</div>
</div>
<div class="section">
<h1>AUTHOR</h1> Brendan O'Dea &lt;bod@debian.org&gt;</div>
<table class="foot">
<tr>
<td class="foot-date">
2009-04-16</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

