<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Moose::Manual::Types(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Moose::Manual::Types(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
Moose::Manual::Types(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Moose::Manual::Types - Moose's type system</div>
<div class="section">
<h1>VERSION</h1> version 2.0401</div>
<div class="section">
<h1>TYPES IN PERL?</h1> Moose provides its own type system for attributes. You can also use these types to validate method parameters with the help of a MooseX module.<div class="spacer">
</div>
Moose's type system is based on a combination of Perl 5's own  <i>implicit</i> types and some Perl 6 concepts. You can create your own subtypes with custom constraints, making it easy to express any sort of validation.<div class="spacer">
</div>
Types have names, and you can re-use them by name, making it easy to share types throughout a large application.<div class="spacer">
</div>
However, this is not a &quot;real&quot; type system. Moose does not magically make Perl start associating types with variables. This is just an advanced parameter checking system which allows you to associate a name with a constraint.<div class="spacer">
</div>
That said, it's still pretty damn useful, and we think it's one of the things that makes Moose both fun and powerful. Taking advantage of the type system makes it much easier to ensure that you are getting valid data, and it also contributes greatly to code maintainability.</div>
<div class="section">
<h1>THE TYPES</h1> The basic Moose type hierarchy looks like this<div class="spacer">
</div>
<br/>
  Any<br/>
  Item<br/>
      Bool<br/>
      Maybe[`a]<br/>
      Undef<br/>
      Defined<br/>
          Value<br/>
              Str<br/>
                  Num<br/>
                      Int<br/>
                  ClassName<br/>
                  RoleName<br/>
          Ref<br/>
              ScalarRef[`a]<br/>
              ArrayRef[`a]<br/>
              HashRef[`a]<br/>
              CodeRef<br/>
              RegexpRef<br/>
              GlobRef<br/>
                  FileHandle<br/>
              Object<br/>
<div class="spacer">
</div>
In practice, the only difference between &quot;Any&quot; and &quot;Item&quot; is conceptual. &quot;Item&quot; is used as the top-level type in the hierarchy.<div class="spacer">
</div>
The rest of these types correspond to existing Perl concepts. In particular:<dl>
<dt>
&#8226;</dt>
<dd>
&quot;Bool&quot; accepts 1 for true, and undef, 0, or the empty string as false.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;Maybe[`a]&quot; accepts either &quot;`a&quot; or &quot;undef&quot;.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;Num&quot; accepts anything that perl thinks looks like a number (see &quot;looks_like_number&quot; in Scalar::Util).</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;ClassName&quot; and &quot;RoleName&quot; accept strings that are either the name of a class or the name of a role. The class/role must already be loaded when the constraint is checked.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;FileHandle&quot; accepts either an IO::Handle object or a builtin perl filehandle (see &quot;openhandle&quot; in Scalar::Util).</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;Object&quot; accepts any blessed reference.</dd>
</dl>
<div class="spacer">
</div>
The types followed by &quot;[`a]&quot; can be parameterized. So instead of just plain &quot;ArrayRef&quot; we can say that we want &quot;ArrayRef[Int]&quot; instead. We can even do something like &quot;HashRef[ArrayRef[Str]]&quot;.<div class="spacer">
</div>
The &quot;Maybe[`a]&quot; type deserves a special mention. Used by itself, it doesn't really mean anything (and is equivalent to &quot;Item&quot;). When it is parameterized, it means that the value is either &quot;undef&quot; or the parameterized type. So &quot;Maybe[Int]&quot; means an integer or &quot;undef&quot;.<div class="spacer">
</div>
For more details on the type hierarchy, see Moose::Util::TypeConstraints.</div>
<div class="section">
<h1>WHAT IS A TYPE?</h1> It's important to realize that types are not classes (or packages). Types are just objects (Moose::Meta::TypeConstraint objects, to be exact) with a name and a constraint. Moose maintains a global type registry that lets it convert names like &quot;Num&quot; into the appropriate object.<div class="spacer">
</div>
However, class names <i>can be</i> type names. When you define a new class using Moose, it defines an associated type name behind the scenes:<div class="spacer">
</div>
<br/>
  package MyApp::User;<br/>
<br/>
  use Moose;<br/>
<div class="spacer">
</div>
Now you can use 'MyApp::User' as a type name:<div class="spacer">
</div>
<br/>
  has creator =&gt; (<br/>
      is  =&gt; 'ro',<br/>
      isa =&gt; 'MyApp::User',<br/>
  );<br/>
<div class="spacer">
</div>
However, for non-Moose classes there's no magic. You may have to explicitly declare the class type. This is a bit muddled because Moose assumes that any unknown type name passed as the &quot;isa&quot; value for an attribute is a class. So this works:<div class="spacer">
</div>
<br/>
  has 'birth_date' =&gt; (<br/>
      is  =&gt; 'ro',<br/>
      isa =&gt; 'DateTime',<br/>
  );<br/>
<div class="spacer">
</div>
In general, when Moose is presented with an unknown name, it assumes that the name is a class:<div class="spacer">
</div>
<br/>
  subtype 'ModernDateTime'<br/>
      =&gt; as 'DateTime'<br/>
      =&gt; where { $_-&gt;year() &gt;= 1980 }<br/>
      =&gt; message { 'The date you provided is not modern enough' };<br/>
<br/>
  has 'valid_dates' =&gt; (<br/>
      is  =&gt; 'ro',<br/>
      isa =&gt; 'ArrayRef[DateTime]',<br/>
  );<br/>
<div class="spacer">
</div>
Moose will assume that &quot;DateTime&quot; is a class name in both of these instances.</div>
<div class="section">
<h1>SUBTYPES</h1> Moose uses subtypes in its built-in hierarchy. For example, &quot;Int&quot; is a child of &quot;Num&quot;.<div class="spacer">
</div>
A subtype is defined in terms of a parent type and a constraint. Any constraints defined by the parent(s) will be checked first, followed by constraints defined by the subtype. A value must pass  <i>all</i> of these checks to be valid for the subtype.<div class="spacer">
</div>
Typically, a subtype takes the parent's constraint and makes it more specific.<div class="spacer">
</div>
A subtype can also define its own constraint failure message. This lets you do things like have an error &quot;The value you provided (20), was not a valid rating, which must be a number from 1-10.&quot; This is much friendlier than the default error, which just says that the value failed a validation check for the type. The default error can, however, be made more friendly by installing Devel::PartialDump (version 0.14 or higher), which Moose will use if possible to display the invalid value.<div class="spacer">
</div>
Here's a simple (and useful) subtype example:<div class="spacer">
</div>
<br/>
  subtype 'PositiveInt',<br/>
      as 'Int',<br/>
      where { $_ &gt; 0 },<br/>
      message { &quot;The number you provided, $_, was not a positive number&quot; };<br/>
<div class="spacer">
</div>
Note that the sugar functions for working with types are all exported by Moose::Util::TypeConstraints.</div>
<div class="section">
<h1>TYPE NAMES</h1> Type names are global throughout the current Perl interpreter. Internally, Moose maps names to type objects via a registry.<div class="spacer">
</div>
If you have multiple apps or libraries all using Moose in the same process, you could have problems with collisions. We recommend that you prefix names with some sort of namespace indicator to prevent these sorts of collisions.<div class="spacer">
</div>
For example, instead of calling a type &quot;PositiveInt&quot;, call it &quot;MyApp::Type::PositiveInt&quot; or &quot;MyApp::Types::PositiveInt&quot;. We recommend that you centralize all of these definitions in a single package, &quot;MyApp::Types&quot;, which can be loaded by other classes in your application.<div class="spacer">
</div>
However, before you do this, you should look at the MooseX::Types module. This module makes it easy to create a &quot;type library&quot; module, which can export your types as perl constants.<div class="spacer">
</div>
<br/>
  has 'counter' =&gt; (is =&gt; 'rw', isa =&gt; PositiveInt);<br/>
<div class="spacer">
</div>
This lets you use a short name rather than needing to fully qualify the name everywhere. It also allows you to easily create parameterized types:<div class="spacer">
</div>
<br/>
  has 'counts' =&gt; (is =&gt; 'ro', isa =&gt; HashRef[PositiveInt]);<br/>
<div class="spacer">
</div>
This module will check your names at compile time, and is generally more robust than the string type parsing for complex cases.</div>
<div class="section">
<h1>COERCION</h1> A coercion lets you tell Moose to automatically convert one type to another.<div class="spacer">
</div>
<br/>
  subtype 'ArrayRefOfInts',<br/>
      as 'ArrayRef[Int]';<br/>
<br/>
  coerce 'ArrayRefOfInts',<br/>
      from 'Int',<br/>
      via { [ $_ ] };<br/>
<div class="spacer">
</div>
You'll note that we created a subtype rather than coercing &quot;ArrayRef[Int]&quot; directly. It's a bad idea to add coercions to the raw built in types.<div class="spacer">
</div>
Coercions are global, just like type names, so a coercion applied to a built in type is seen by all modules using Moose types. This is  <i>another</i> reason why it is good to namespace your types.<div class="spacer">
</div>
Moose will <i>never</i> try to coerce a value unless you explicitly ask for it. This is done by setting the &quot;coerce&quot; attribute option to a true value:<div class="spacer">
</div>
<br/>
  package Foo;<br/>
<br/>
  has 'sizes' =&gt; (<br/>
      is     =&gt; 'ro',<br/>
      isa    =&gt; 'ArrayRefOfInts',<br/>
      coerce =&gt; 1,<br/>
  );<br/>
<br/>
  Foo-&gt;new( sizes =&gt; 42 );<br/>
<div class="spacer">
</div>
This code example will do the right thing, and the newly created object will have &quot;[ 42 ]&quot; as its &quot;sizes&quot; attribute.<div class="subsection">
<h2>Deep coercion</h2> Deep coercion is the coercion of type parameters for parameterized types. Let's take these types as an example:<div class="spacer">
</div>
<br/>
  subtype 'HexNum',<br/>
      as 'Str',<br/>
      where { /[a-f0-9]/i };<br/>
<br/>
  coerce 'Int',<br/>
      from 'HexNum',<br/>
      via { hex $_ };<br/>
<br/>
  has 'sizes' =&gt; (<br/>
      is     =&gt; 'ro',<br/>
      isa    =&gt; 'ArrayRef[Int]',<br/>
      coerce =&gt; 1,<br/>
  );<br/>
<div class="spacer">
</div>
If we try passing an array reference of hex numbers for the &quot;sizes&quot; attribute, Moose will not do any coercion.<div class="spacer">
</div>
However, you can define a set of subtypes to enable coercion between two parameterized types.<div class="spacer">
</div>
<br/>
  subtype 'ArrayRefOfHexNums',<br/>
      as 'ArrayRef[HexNum]';<br/>
<br/>
  subtype 'ArrayRefOfInts',<br/>
      as 'ArrayRef[Int]';<br/>
<br/>
  coerce 'ArrayRefOfInts',<br/>
      from 'ArrayRefOfHexNums',<br/>
      via { [ map { hex } @{$_} ] };<br/>
<br/>
  Foo-&gt;new( sizes =&gt; [ 'a1', 'ff', '22' ] );<br/>
<div class="spacer">
</div>
Now Moose will coerce the hex numbers to integers.<div class="spacer">
</div>
Moose does not attempt to chain coercions, so it will not coerce a single hex number. To do that, we need to define a separate coercion:<div class="spacer">
</div>
<br/>
  coerce 'ArrayRefOfInts',<br/>
      from 'HexNum',<br/>
      via { [ hex $_ ] };<br/>
<div class="spacer">
</div>
Yes, this can all get verbose, but coercion is tricky magic, and we think it's best to make it explicit.</div>
</div>
<div class="section">
<h1>TYPE UNIONS</h1> Moose allows you to say that an attribute can be of two or more disparate types. For example, we might allow an &quot;Object&quot; or &quot;FileHandle&quot;:<div class="spacer">
</div>
<br/>
  has 'output' =&gt; (<br/>
      is  =&gt; 'rw',<br/>
      isa =&gt; 'Object | FileHandle',<br/>
  );<br/>
<div class="spacer">
</div>
Moose actually parses that string and recognizes that you are creating a type union. The &quot;output&quot; attribute will accept any sort of object, as well as an unblessed file handle. It is up to you to do the right thing for each of them in your code.<div class="spacer">
</div>
Whenever you use a type union, you should consider whether or not coercion might be a better answer.<div class="spacer">
</div>
For our example above, we might want to be more specific, and insist that output be an object with a &quot;print&quot; method:<div class="spacer">
</div>
<br/>
  duck_type 'CanPrint', [qw(print)];<br/>
<div class="spacer">
</div>
We can coerce file handles to an object that satisfies this condition with a simple wrapper class:<div class="spacer">
</div>
<br/>
  package FHWrapper;<br/>
<br/>
  use Moose;<br/>
<br/>
  has 'handle' =&gt; (<br/>
      is  =&gt; 'rw',<br/>
      isa =&gt; 'FileHandle',<br/>
  );<br/>
<br/>
  sub print {<br/>
      my $self = shift;<br/>
      my $fh   = $self-&gt;handle();<br/>
<br/>
      print {$fh} @_;<br/>
  }<br/>
<div class="spacer">
</div>
Now we can define a coercion from &quot;FileHandle&quot; to our wrapper class:<div class="spacer">
</div>
<br/>
  coerce 'CanPrint'<br/>
      =&gt; from 'FileHandle'<br/>
      =&gt; via { FHWrapper-&gt;new( handle =&gt; $_ ) };<br/>
<br/>
  has 'output' =&gt; (<br/>
      is     =&gt; 'rw',<br/>
      isa    =&gt; 'CanPrint',<br/>
      coerce =&gt; 1,<br/>
  );<br/>
<div class="spacer">
</div>
This pattern of using a coercion instead of a type union will help make your class internals simpler.</div>
<div class="section">
<h1>TYPE CREATION HELPERS</h1> The Moose::Util::TypeConstraints module exports a number of helper functions for creating specific kinds of types. These include &quot;class_type&quot;, &quot;role_type&quot;, &quot;maybe_type&quot;, and &quot;duck_type&quot;. See the docs for details.<div class="spacer">
</div>
One helper worth noting is &quot;enum&quot;, which allows you to create a subtype of &quot;Str&quot; that only allows the specified values:<div class="spacer">
</div>
<br/>
  enum 'RGB', [qw( red green blue )];<br/>
<div class="spacer">
</div>
This creates a type named &quot;RGB&quot;.</div>
<div class="section">
<h1>ANONYMOUS TYPES</h1> All of the type creation functions return a type object. This type object can be used wherever you would use a type name, as a parent type, or as the value for an attribute's &quot;isa&quot; option:<div class="spacer">
</div>
<br/>
  has 'size' =&gt; (<br/>
      is  =&gt; 'ro',<br/>
      isa =&gt; subtype( 'Int' =&gt; where { $_ &gt; 0 } ),<br/>
  );<br/>
<div class="spacer">
</div>
This is handy when you want to create a one-off type and don't want to &quot;pollute&quot; the global namespace registry.</div>
<div class="section">
<h1>VALIDATING METHOD PARAMETERS</h1> Moose does not provide any means of validating method parameters. However, there are several MooseX extensions on CPAN which let you do this.<div class="spacer">
</div>
The simplest and least sugary is MooseX::Params::Validate. This lets you validate a set of named parameters using Moose types:<div class="spacer">
</div>
<br/>
  use Moose;<br/>
  use MooseX::Params::Validate;<br/>
<br/>
  sub foo {<br/>
      my $self   = shift;<br/>
      my %params = validated_hash(<br/>
          \@_,<br/>
          bar =&gt; { isa =&gt; 'Str', default =&gt; 'Moose' },<br/>
      );<br/>
      ...<br/>
  }<br/>
<div class="spacer">
</div>
MooseX::Params::Validate also supports coercions.<div class="spacer">
</div>
There are several more powerful extensions that support method parameter validation using Moose types, including MooseX::Method::Signatures, which gives you a full-blown &quot;method&quot; keyword.<div class="spacer">
</div>
<br/>
  method morning ( Str $name ) {<br/>
      $self-&gt;say(&quot;Good morning ${name}!&quot;);<br/>
  }<br/>
</div>
<div class="section">
<h1>LOAD ORDER ISSUES</h1> Because Moose types are defined at runtime, you may run into load order problems. In particular, you may want to use a class's type constraint before that type has been defined.<div class="spacer">
</div>
In order to ameliorate this problem, we recommend defining <i>all</i> of your custom types in one module, &quot;MyApp::Types&quot;, and then loading this module in all of your other modules.</div>
<div class="section">
<h1>AUTHOR</h1> Moose is maintained by the Moose Cabal, along with the help of many contributors. See &quot;CABAL&quot; in Moose and &quot;CONTRIBUTORS&quot; in Moose for details.</div>
<div class="section">
<h1>COPYRIGHT AND LICENSE</h1> This software is copyright (c) 2011 by Infinity Interactive, Inc..<div class="spacer">
</div>
This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5 programming language system itself.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-11-17</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

