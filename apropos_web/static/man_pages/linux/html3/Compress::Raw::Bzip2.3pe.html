<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Compress::Raw::Bzip2(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Compress::Raw::Bzip2(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
Compress::Raw::Bzip2(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Compress::Raw::Bzip2 - Low-Level Interface to bzip2 compression library</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
    use Compress::Raw::Bzip2 ;<br/>
<br/>
    my ($bz, $status) = new Compress::Raw::Bzip2 [OPTS]<br/>
        or die &quot;Cannot create bzip2 object: $bzerno\n&quot;;<br/>
    <br/>
    $status = $bz-&gt;bzdeflate($input, $output);<br/>
    $status = $bz-&gt;bzflush($output);<br/>
    $status = $bz-&gt;bzclose($output);<br/>
<br/>
    my ($bz, $status) = new Compress::Raw::Bunzip2 [OPTS]<br/>
        or die &quot;Cannot create bunzip2 object: $bzerno\n&quot;;<br/>
    <br/>
    $status = $bz-&gt;bzinflate($input, $output);<br/>
<br/>
    my $version = Compress::Raw::Bzip2::bzlibversion();<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> &quot;Compress::Raw::Bzip2&quot; provides an interface to the in-memory compression/uncompression functions from the bzip2 compression library.<div class="spacer">
</div>
Although the primary purpose for the existence of &quot;Compress::Raw::Bzip2&quot; is for use by the  &quot;IO::Compress::Bzip2&quot; and &quot;IO::Compress::Bunzip2&quot; modules, it can be used on its own for simple compression/uncompression tasks.</div>
<div class="section">
<h1>Compression</h1><div class="subsection">
<h2>($z, $status) = new Compress::Raw::Bzip2 $appendOutput, $blockSize100k, $workfactor;</h2> Creates a new compression object.<div class="spacer">
</div>
If successful, it will return the initialised compression object, $z and a $status of &quot;BZ_OK&quot; in a list context. In scalar context it returns the deflation object, $z, only.<div class="spacer">
</div>
If not successful, the returned compression object, $z, will be  <i>undef</i> and $status will hold the a <i>bzip2</i> error code.<div class="spacer">
</div>
Below is a list of the valid options:<dl>
<dt>
<b></b><b>$appendOutput</b><b></b></dt>
<dd>
Controls whether the compressed data is appended to the output buffer in the &quot;bzdeflate&quot;, &quot;bzflush&quot; and &quot;bzclose&quot; methods.<div style="height: 1.00em;">
&#160;</div>
Defaults to 1.</dd>
</dl>
<dl>
<dt>
<b></b><b>$blockSize100k</b><b></b></dt>
<dd>
To quote the bzip2 documentation<div style="height: 1.00em;">
&#160;</div>
<br/>
    blockSize100k specifies the block size to be used for compression. It<br/>
    should be a value between 1 and 9 inclusive, and the actual block size<br/>
    used is 100000 x this figure. 9 gives the best compression but takes<br/>
    most memory.<br/>
<div style="height: 1.00em;">
&#160;</div>
Defaults to 1.</dd>
</dl>
<dl>
<dt>
<b></b><b>$workfactor</b><b></b></dt>
<dd>
To quote the bzip2 documentation<div style="height: 1.00em;">
&#160;</div>
<br/>
    This parameter controls how the compression phase behaves when<br/>
    presented with worst case, highly repetitive, input data. If<br/>
    compression runs into difficulties caused by repetitive data, the<br/>
    library switches from the standard sorting algorithm to a fallback<br/>
    algorithm. The fallback is slower than the standard algorithm by<br/>
    perhaps a factor of three, but always behaves reasonably, no matter how<br/>
    bad the input.<br/>
<br/>
    Lower values of workFactor reduce the amount of effort the standard<br/>
    algorithm will expend before resorting to the fallback. You should set<br/>
    this parameter carefully; too low, and many inputs will be handled by<br/>
    the fallback algorithm and so compress rather slowly, too high, and<br/>
    your average-to-worst case compression times can become very large. The<br/>
    default value of 30 gives reasonable behaviour over a wide range of<br/>
    circumstances.<br/>
<br/>
    Allowable values range from 0 to 250 inclusive. 0 is a special case,<br/>
    equivalent to using the default value of 30.<br/>
<div style="height: 1.00em;">
&#160;</div>
Defaults to 0.</dd>
</dl>
</div>
<div class="subsection">
<h2>$status = $bz-&gt;bzdeflate($input, $output);</h2> Reads the contents of $input, compresses it and writes the compressed data to $output.<div class="spacer">
</div>
Returns &quot;BZ_RUN_OK&quot; on success and a &quot;bzip2&quot; error code on failure.<div class="spacer">
</div>
If &quot;appendOutput&quot; is enabled in the constructor for the bzip2 object, the compressed data will be appended to $output. If not enabled, $output will be truncated before the compressed data is written to it.</div>
<div class="subsection">
<h2>$status = $bz-&gt;bzflush($output);</h2> Flushes any pending compressed data to $output.<div class="spacer">
</div>
Returns &quot;BZ_RUN_OK&quot; on success and a &quot;bzip2&quot; error code on failure.</div>
<div class="subsection">
<h2>$status = $bz-&gt;bzclose($output);</h2> Terminates the compressed data stream and flushes any pending compressed data to $output.<div class="spacer">
</div>
Returns &quot;BZ_STREAM_END&quot; on success and a &quot;bzip2&quot; error code on failure.</div>
<div class="subsection">
<h2>Example</h2></div>
</div>
<div class="section">
<h1>Uncompression</h1><div class="subsection">
<h2>($z, $status) = new Compress::Raw::Bunzip2 $appendOutput, $consumeInput, $small, $verbosity, $limitOutput;</h2> If successful, it will return the initialised uncompression object, $z and a $status of &quot;BZ_OK&quot; in a list context. In scalar context it returns the deflation object, $z, only.<div class="spacer">
</div>
If not successful, the returned uncompression object, $z, will be  <i>undef</i> and $status will hold the a <i>bzip2</i> error code.<div class="spacer">
</div>
Below is a list of the valid options:<dl>
<dt>
<b></b><b>$appendOutput</b><b></b></dt>
<dd>
Controls whether the compressed data is appended to the output buffer in the &quot;bzinflate&quot;, &quot;bzflush&quot; and &quot;bzclose&quot; methods.<div style="height: 1.00em;">
&#160;</div>
Defaults to 1.</dd>
</dl>
<dl>
<dt>
<b></b><b>$consumeInput</b><b></b></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<b></b><b>$small</b><b></b></dt>
<dd>
To quote the bzip2 documentation<div style="height: 1.00em;">
&#160;</div>
<br/>
    If small is nonzero, the library will use an alternative decompression<br/>
    algorithm which uses less memory but at the cost of decompressing more<br/>
    slowly (roughly speaking, half the speed, but the maximum memory<br/>
    requirement drops to around 2300k).<br/>
<div style="height: 1.00em;">
&#160;</div>
Defaults to 0.</dd>
</dl>
<dl>
<dt>
<b></b><b>$limitOutput</b><b></b></dt>
<dd>
The &quot;LimitOutput&quot; option changes the behavior of the &quot;$i-&gt;bzinflate&quot; method so that the amount of memory used by the output buffer can be limited.<div style="height: 1.00em;">
&#160;</div>
When &quot;LimitOutput&quot; is used the size of the output buffer used will either be the 16k or the amount of memory already allocated to $output, whichever is larger. Predicting the output size available is tricky, so don't rely on getting an exact output buffer size.<div style="height: 1.00em;">
&#160;</div>
When &quot;LimitOutout&quot; is not specified &quot;$i-&gt;bzinflate&quot; will use as much memory as it takes to write all the uncompressed data it creates by uncompressing the input buffer.<div style="height: 1.00em;">
&#160;</div>
If &quot;LimitOutput&quot; is enabled, the &quot;ConsumeInput&quot; option will also be enabled.<div style="height: 1.00em;">
&#160;</div>
This option defaults to false.</dd>
</dl>
<dl>
<dt>
<b></b><b>$verbosity</b><b></b></dt>
<dd>
This parameter is ignored.<div style="height: 1.00em;">
&#160;</div>
Defaults to 0.</dd>
</dl>
</div>
<div class="subsection">
<h2>$status = $z-&gt;bzinflate($input, $output);</h2> Uncompresses $input and writes the uncompressed data to $output.<div class="spacer">
</div>
Returns &quot;BZ_OK&quot; if the uncompression was successful, but the end of the compressed data stream has not been reached. Returns &quot;BZ_STREAM_END&quot; on successful uncompression and the end of the compression stream has been reached.<div class="spacer">
</div>
If &quot;consumeInput&quot; is enabled in the constructor for the bunzip2 object, $input will have all compressed data removed from it after uncompression. On &quot;BZ_OK&quot; return this will mean that $input will be an empty string; when &quot;BZ_STREAM_END&quot; $input will either be an empty string or will contain whatever data immediately followed the compressed data stream.<div class="spacer">
</div>
If &quot;appendOutput&quot; is enabled in the constructor for the bunzip2 object, the uncompressed data will be appended to $output. If not enabled, $output will be truncated before the uncompressed data is written to it.</div>
</div>
<div class="section">
<h1>Misc</h1><div class="subsection">
<h2>my $version = <i>Compress::Raw::Bzip2::bzlibversion()</i>;</h2> Returns the version of the underlying bzip2 library.</div>
</div>
<div class="section">
<h1>Constants</h1> The following bzip2 constants are exported by this module<div class="spacer">
</div>
<br/>
                BZ_RUN<br/>
                BZ_FLUSH<br/>
                BZ_FINISH<br/>
<br/>
                BZ_OK<br/>
                BZ_RUN_OK<br/>
                BZ_FLUSH_OK<br/>
                BZ_FINISH_OK<br/>
                BZ_STREAM_END<br/>
                BZ_SEQUENCE_ERROR<br/>
                BZ_PARAM_ERROR<br/>
                BZ_MEM_ERROR<br/>
                BZ_DATA_ERROR<br/>
                BZ_DATA_ERROR_MAGIC<br/>
                BZ_IO_ERROR<br/>
                BZ_UNEXPECTED_EOF<br/>
                BZ_OUTBUFF_FULL<br/>
                BZ_CONFIG_ERROR<br/>
</div>
<div class="section">
<h1>SEE ALSO</h1> Compress::Zlib, IO::Compress::Gzip, IO::Uncompress::Gunzip, IO::Compress::Deflate, IO::Uncompress::Inflate, IO::Compress::RawDeflate, IO::Uncompress::RawInflate, IO::Compress::Bzip2, IO::Uncompress::Bunzip2, IO::Compress::Lzma, IO::Uncompress::UnLzma, IO::Compress::Xz, IO::Uncompress::UnXz, IO::Compress::Lzop, IO::Uncompress::UnLzop, IO::Compress::Lzf, IO::Uncompress::UnLzf, IO::Uncompress::AnyInflate, IO::Uncompress::AnyUncompress<div class="spacer">
</div>
Compress::Zlib::FAQ<div class="spacer">
</div>
File::GlobMapper, Archive::Zip, Archive::Tar, IO::Zlib<div class="spacer">
</div>
The primary site for the bzip2 program is <i>http://www.bzip.org</i>.<div class="spacer">
</div>
See the module Compress::Bzip2</div>
<div class="section">
<h1>AUTHOR</h1> This module was written by Paul Marquess,  <i>pmqs@cpan.org</i>.</div>
<div class="section">
<h1>MODIFICATION HISTORY</h1> See the Changes file.</div>
<div class="section">
<h1>COPYRIGHT AND LICENSE</h1> Copyright (c) 2005-2011 Paul Marquess. All rights reserved.<div class="spacer">
</div>
This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-09-26</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

