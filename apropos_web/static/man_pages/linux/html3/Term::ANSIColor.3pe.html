<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Term::ANSIColor(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Term::ANSIColor(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
Term::ANSIColor(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Term::ANSIColor - Color screen output using ANSI escape sequences</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
    use Term::ANSIColor;<br/>
    print color 'bold blue';<br/>
    print &quot;This text is bold blue.\n&quot;;<br/>
    print color 'reset';<br/>
    print &quot;This text is normal.\n&quot;;<br/>
    print colored (&quot;Yellow on magenta.&quot;, 'yellow on_magenta'), &quot;\n&quot;;<br/>
    print &quot;This text is normal.\n&quot;;<br/>
    print colored ['yellow on_magenta'], 'Yellow on magenta.', &quot;\n&quot;;<br/>
    print colored ['red on_bright_yellow'] 'Red on bright yellow.', &quot;\n&quot;;<br/>
    print colored ['bright_red on_black], 'Bright red on black.', &quot;\n&quot;;<br/>
    print &quot;\n&quot;;<br/>
<br/>
    use Term::ANSIColor qw(uncolor);<br/>
    print uncolor ('01;31'), &quot;\n&quot;;<br/>
<br/>
    use Term::ANSIColor qw(colorstrip);<br/>
    print colorstrip '\e[1mThis is bold\e[0m', &quot;\n&quot;;<br/>
<br/>
    use Term::ANSIColor qw(colorvalid);<br/>
    my $valid = colorvalid ('blue bold', 'on_magenta');<br/>
    print &quot;Color string is &quot;, $valid ? &quot;valid\n&quot; : &quot;invalid\n&quot;;<br/>
<br/>
    use Term::ANSIColor qw(:constants);<br/>
    print BOLD, BLUE, &quot;This text is in bold blue.\n&quot;, RESET;<br/>
<br/>
    use Term::ANSIColor qw(:constants);<br/>
    {<br/>
        local $Term::ANSIColor::AUTORESET = 1;<br/>
        print BOLD BLUE &quot;This text is in bold blue.\n&quot;;<br/>
        print &quot;This text is normal.\n&quot;;<br/>
    }<br/>
<br/>
    use Term::ANSIColor qw(:pushpop);<br/>
    print PUSHCOLOR RED ON_GREEN &quot;This text is red on green.\n&quot;;<br/>
    print PUSHCOLOR BRIGHT_BLUE &quot;This text is bright blue on green.\n&quot;;<br/>
    print RESET BRIGHT_BLUE &quot;This text is just bright blue.\n&quot;;<br/>
    print POPCOLOR &quot;Back to red on green.\n&quot;;<br/>
    print LOCALCOLOR GREEN ON_BLUE &quot;This text is green on blue.\n&quot;;<br/>
    print &quot;This text is red on green.\n&quot;;<br/>
    {<br/>
        local $Term::ANSIColor::AUTOLOCAL = 1;<br/>
        print ON_BLUE &quot;This text is red on blue.\n&quot;;<br/>
        print &quot;This text is red on green.\n&quot;;<br/>
    }<br/>
    print POPCOLOR &quot;Back to whatever we started as.\n&quot;;<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> This module has two interfaces, one through  <i>color()</i> and <i>colored()</i> and the other through constants.  It also offers the utility functions  <i>uncolor()</i>,  <i>colorstrip()</i>, and <i>colorvalid()</i>, which have to be explicitly imported to be used (see &quot;SYNOPSIS&quot;).<div class="subsection">
<h2>Supported Colors</h2> Terminal emulators that support color divide into two types: ones that support only eight colors, and ones that support sixteen.  This module provides both the ANSI escape codes for the &quot;normal&quot; colors, supported by both types, as well as the additional colors supported by sixteen-color emulators.  These colors are referred to as ANSI colors 0 through 7 (normal) and 8 through 15.<div class="spacer">
</div>
Unfortunately, interpretation of colors 0 through 7 often depends on whether the emulator supports eight colors or sixteen colors.  Emulators that only support eight colors (such as the Linux console) will display colors 0 through 7 with normal brightness and ignore colors 8 through 15, treating them the same as white.  Emulators that support 16 colors, such as gnome-terminal, normally display colors 0 through 7 as dim or darker versions and colors 8 through 15 as normal brightness.  On such emulators, the &quot;normal&quot; white (color 7) usually is shown as pale grey, requiring bright white (15) to be used to get a real white color.  Bright black usually is a dark grey color, although some terminals display it as pure black.  Some sixteen-color terminal emulators also treat normal yellow (color 3) as orange or brown, and bright yellow (color 11) as yellow.<div class="spacer">
</div>
Following the normal convention of sixteen-color emulators, this module provides a pair of attributes for each color.  For every normal color (0 through 7), the corresponding bright color (8 through 15) is obtained by prepending the string &quot;bright_&quot; to the normal color name.  For example, &quot;red&quot; is color 1 and &quot;bright_red&quot; is color 9.  The same applies for background colors: &quot;on_red&quot; is the normal color and &quot;on_bright_red&quot; is the bright color.  Capitalize these strings for the constant interface.<div class="spacer">
</div>
There is unfortunately no way to know whether the current emulator supports sixteen colors or not, which makes the choice of colors difficult.  The most conservative choice is to use only the regular colors, which are at least displayed on all emulators.  However, they will appear dark in sixteen-color terminal emulators, including most common emulators in UNIX X environments.  If you know the display is one of those emulators, you may wish to use the bright variants instead.  Even better, offer the user a way to configure the colors for a given application to fit their terminal emulator.<div class="spacer">
</div>
Support for colors 8 through 15 (the &quot;bright_&quot; variants) was added in Term::ANSIColor 3.0.</div>
<div class="subsection">
<h2>Function Interface</h2> The function interface uses attribute strings to describe the colors and text attributes to assign to text.  The recognized non-color attributes are clear, reset, bold, dark, faint, underline, underscore, blink, reverse, and concealed.  Clear and reset (reset to default attributes), dark and faint (dim and saturated), and underline and underscore are equivalent, so use whichever is the most intuitive to you.<div class="spacer">
</div>
Note that not all attributes are supported by all terminal types, and some terminals may not support any of these sequences.  Dark and faint, blink, and concealed in particular are frequently not implemented.<div class="spacer">
</div>
The recognized normal foreground color attributes (colors 0 to 7) are:<div class="spacer">
</div>
<br/>
  black  red  green  yellow  blue  magenta  cyan  white<br/>
<div class="spacer">
</div>
The corresponding bright foreground color attributes (colors 8 to 15) are:<div class="spacer">
</div>
<br/>
  bright_black  bright_red      bright_green  bright_yellow<br/>
  bright_blue   bright_magenta  bright_cyan   bright_white<br/>
<div class="spacer">
</div>
The recognized normal background color attributes (colors 0 to 7) are:<div class="spacer">
</div>
<br/>
  on_black  on_red      on_green  on yellow<br/>
  on_blue   on_magenta  on_cyan   on_white<br/>
<div class="spacer">
</div>
The recognized bright background color attributes (colors 8 to 15) are:<div class="spacer">
</div>
<br/>
  on_bright_black  on_bright_red      on_bright_green  on_bright_yellow<br/>
  on_bright_blue   on_bright_magenta  on_bright_cyan   on_bright_white<br/>
<div class="spacer">
</div>
For any of the above listed attributes, case is not significant.<div class="spacer">
</div>
Attributes, once set, last until they are unset (by printing the attribute &quot;clear&quot; or &quot;reset&quot;).  Be careful to do this, or otherwise your attribute will last after your script is done running, and people get very annoyed at having their prompt and typing changed to weird colors.<dl>
<dt>
color(ATTR[, ATTR ...])</dt>
<dd>
<i>color()</i> takes any number of strings as arguments and considers them to be space-separated lists of attributes.  It then forms and returns the escape sequence to set those attributes.  It doesn't print it out, just returns it, so you'll have to print it yourself if you want to.  This is so that you can save it as a string, pass it to something else, send it to a file handle, or do anything else with it that you might care to.   <i>color()</i> throws an exception if given an invalid attribute.</dd>
</dl>
<dl>
<dt>
colored(STRING, ATTRIBUTES)</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
colored(ATTR-REF, STRING[, STRING...])</dt>
<dd>
As an aid in resetting colors, <i>colored()</i> takes a scalar as the first argument and any number of attribute strings as the second argument and returns the scalar wrapped in escape codes so that the attributes will be set as requested before the string and reset to normal after the string. Alternately, you can pass a reference to an array as the first argument, and then the contents of that array will be taken as attributes and color codes and the remainder of the arguments as text to colorize.<div style="height: 1.00em;">
&#160;</div>
Normally, <i>colored()</i> just puts attribute codes at the beginning and end of the string, but if you set $Term::ANSIColor::EACHLINE to some string, that string will be considered the line delimiter and the attribute will be set at the beginning of each line of the passed string and reset at the end of each line.  This is often desirable if the output contains newlines and you're using background colors, since a background color that persists across a newline is often interpreted by the terminal as providing the default background color for the next line.  Programs like pagers can also be confused by attributes that span lines.  Normally you'll want to set $Term::ANSIColor::EACHLINE to &quot;\n&quot; to use this feature.</dd>
</dl>
<dl>
<dt>
uncolor(ESCAPE)</dt>
<dd>
<i>uncolor()</i> performs the opposite translation as <i>color()</i>, turning escape sequences into a list of strings corresponding to the attributes being set by those sequences.</dd>
</dl>
<dl>
<dt>
colorstrip(STRING[, STRING ...])</dt>
<dd>
<i>colorstrip()</i> removes all color escape sequences from the provided strings, returning the modified strings separately in array context or joined together in scalar context.  Its arguments are not modified.</dd>
</dl>
<dl>
<dt>
colorvalid(ATTR[, ATTR ...])</dt>
<dd>
<i>colorvalid()</i> takes attribute strings the same as <i>color()</i> and returns true if all attributes are known and false otherwise.</dd>
</dl>
</div>
<div class="subsection">
<h2>Constant Interface</h2> Alternately, if you import &quot;:constants&quot;, you can use the following constants directly:<div class="spacer">
</div>
<br/>
  CLEAR           RESET             BOLD            DARK<br/>
  FAINT           UNDERLINE         UNDERSCORE      BLINK<br/>
  REVERSE         CONCEALED<br/>
<br/>
  BLACK           RED               GREEN           YELLOW<br/>
  BLUE            MAGENTA           CYAN            WHITE<br/>
  BRIGHT_BLACK    BRIGHT_RED        BRIGHT_GREEN    BRIGHT_YELLOW<br/>
  BRIGHT_BLUE     BRIGHT_MAGENTA    BRIGHT_CYAN     BRIGHT_WHITE<br/>
<br/>
  ON_BLACK        ON_RED            ON_GREEN        ON_YELLOW<br/>
  ON_BLUE         ON_MAGENTA        ON_CYAN         ON_WHITE<br/>
  ON_BRIGHT_BLACK ON_BRIGHT_RED     ON_BRIGHT_GREEN ON_BRIGHT_YELLOW<br/>
  ON_BRIGHT_BLUE  ON_BRIGHT_MAGENTA ON_BRIGHT_CYAN  ON_BRIGHT_WHITE<br/>
<div class="spacer">
</div>
These are the same as color('attribute') and can be used if you prefer typing:<div class="spacer">
</div>
<br/>
    print BOLD BLUE ON_WHITE &quot;Text&quot;, RESET, &quot;\n&quot;;<br/>
<div class="spacer">
</div>
to<div class="spacer">
</div>
<br/>
    print colored (&quot;Text&quot;, 'bold blue on_white'), &quot;\n&quot;;<br/>
<div class="spacer">
</div>
(Note that the newline is kept separate to avoid confusing the terminal as described above since a background color is being used.)<div class="spacer">
</div>
When using the constants, if you don't want to have to remember to add the &quot;, RESET&quot; at the end of each print line, you can set $Term::ANSIColor::AUTORESET to a true value.  Then, the display mode will automatically be reset if there is no comma after the constant.  In other words, with that variable set:<div class="spacer">
</div>
<br/>
    print BOLD BLUE &quot;Text\n&quot;;<br/>
<div class="spacer">
</div>
will reset the display mode afterward, whereas:<div class="spacer">
</div>
<br/>
    print BOLD, BLUE, &quot;Text\n&quot;;<br/>
<div class="spacer">
</div>
will not.  If you are using background colors, you will probably want to print the newline with a separate print statement to avoid confusing the terminal.<div class="spacer">
</div>
The subroutine interface has the advantage over the constants interface in that only two subroutines are exported into your namespace, versus thirty-eight in the constants interface.  On the flip side, the constants interface has the advantage of better compile time error checking, since misspelled names of colors or attributes in calls to  <i>color()</i> and <i>colored()</i> won't be caught until runtime whereas misspelled names of constants will be caught at compile time.  So, pollute your namespace with almost two dozen subroutines that you may not even use that often, or risk a silly bug by mistyping an attribute.  Your choice, TMTOWTDI after all.</div>
<div class="subsection">
<h2>The Color Stack</h2> As of Term::ANSIColor 2.0, you can import &quot;:pushpop&quot; and maintain a stack of colors using PUSHCOLOR, POPCOLOR, and LOCALCOLOR.  PUSHCOLOR takes the attribute string that starts its argument and pushes it onto a stack of attributes.  POPCOLOR removes the top of the stack and restores the previous attributes set by the argument of a prior PUSHCOLOR.  LOCALCOLOR surrounds its argument in a PUSHCOLOR and POPCOLOR so that the color resets afterward.<div class="spacer">
</div>
When using PUSHCOLOR, POPCOLOR, and LOCALCOLOR, it's particularly important to not put commas between the constants.<div class="spacer">
</div>
<br/>
    print PUSHCOLOR BLUE &quot;Text\n&quot;;<br/>
<div class="spacer">
</div>
will correctly push BLUE onto the top of the stack.<div class="spacer">
</div>
<br/>
    print PUSHCOLOR, BLUE, &quot;Text\n&quot;;    # wrong!<br/>
<div class="spacer">
</div>
will not, and a subsequent pop won't restore the correct attributes. PUSHCOLOR pushes the attributes set by its argument, which is normally a string of color constants.  It can't ask the terminal what the current attributes are.</div>
</div>
<div class="section">
<h1>DIAGNOSTICS</h1><dl>
<dt>
Bad escape sequence %s</dt>
<dd>
(F) You passed an invalid ANSI escape sequence to <i>uncolor()</i>.</dd>
</dl>
<dl>
<dt>
Bareword &quot;%s&quot; not allowed while &quot;strict subs&quot; in use</dt>
<dd>
(F) You probably mistyped a constant color name such as:<div style="height: 1.00em;">
&#160;</div>
<br/>
    $Foobar = FOOBAR . &quot;This line should be blue\n&quot;;<br/>
<div style="height: 1.00em;">
&#160;</div>
or:<div style="height: 1.00em;">
&#160;</div>
<br/>
    @Foobar = FOOBAR, &quot;This line should be blue\n&quot;;<br/>
<div style="height: 1.00em;">
&#160;</div>
This will only show up under use strict (another good reason to run under use strict).</dd>
</dl>
<dl>
<dt>
Invalid attribute name %s</dt>
<dd>
(F) You passed an invalid attribute name to either <i>color()</i> or <i>colored()</i>.</dd>
</dl>
<dl>
<dt>
Name &quot;%s&quot; used only once: possible typo</dt>
<dd>
(W) You probably mistyped a constant color name such as:<div style="height: 1.00em;">
&#160;</div>
<br/>
    print FOOBAR &quot;This text is color FOOBAR\n&quot;;<br/>
<div style="height: 1.00em;">
&#160;</div>
It's probably better to always use commas after constant names in order to force the next error.</dd>
</dl>
<dl>
<dt>
No comma allowed after filehandle</dt>
<dd>
(F) You probably mistyped a constant color name such as:<div style="height: 1.00em;">
&#160;</div>
<br/>
    print FOOBAR, &quot;This text is color FOOBAR\n&quot;;<br/>
<div style="height: 1.00em;">
&#160;</div>
Generating this fatal compile error is one of the main advantages of using the constants interface, since you'll immediately know if you mistype a color name.</dd>
</dl>
<dl>
<dt>
No name for escape sequence %s</dt>
<dd>
(F) The ANSI escape sequence passed to <i>uncolor()</i> contains escapes which aren't recognized and can't be translated to names.</dd>
</dl>
</div>
<div class="section">
<h1>ENVIRONMENT</h1><dl>
<dt>
ANSI_COLORS_DISABLED</dt>
<dd>
If this environment variable is set, all of the functions defined by this module ( <i>color()</i>, <i>colored()</i>, and all of the constants not previously used in the program) will not output any escape sequences and instead will just return the empty string or pass through the original text as appropriate. This is intended to support easy use of scripts using this module on platforms that don't support ANSI escape sequences.<div style="height: 1.00em;">
&#160;</div>
For it to have its proper effect, this environment variable must be set before any color constants are used in the program.</dd>
</dl>
</div>
<div class="section">
<h1>RESTRICTIONS</h1> It would be nice if one could leave off the commas around the constants entirely and just say:<div class="spacer">
</div>
<br/>
    print BOLD BLUE ON_WHITE &quot;Text\n&quot; RESET;<br/>
<div class="spacer">
</div>
but the syntax of Perl doesn't allow this.  You need a comma after the string.  (Of course, you may consider it a bug that commas between all the constants aren't required, in which case you may feel free to insert commas unless you're using $Term::ANSIColor::AUTORESET or PUSHCOLOR/POPCOLOR.)<div class="spacer">
</div>
For easier debugging, you may prefer to always use the commas when not setting $Term::ANSIColor::AUTORESET or PUSHCOLOR/POPCOLOR so that you'll get a fatal compile error rather than a warning.</div>
<div class="section">
<h1>NOTES</h1> The codes generated by this module are standard terminal control codes, complying with ECMA-048 and ISO 6429 (generally referred to as &quot;ANSI color&quot; for the color codes).  The non-color control codes (bold, dark, italic, underline, and reverse) are part of the earlier ANSI X3.64 standard for control sequences for video terminals and peripherals.<div class="spacer">
</div>
Note that not all displays are ISO 6429-compliant, or even X3.64-compliant (or are even attempting to be so).  This module will not work as expected on displays that do not honor these escape sequences, such as cmd.exe, 4nt.exe, and command.com under either Windows NT or Windows 2000.  They may just be ignored, or they may display as an ESC character followed by some apparent garbage.<div class="spacer">
</div>
Jean Delvare provided the following table of different common terminal emulators and their support for the various attributes and others have helped me flesh it out:<div class="spacer">
</div>
<br/>
              clear    bold     faint   under    blink   reverse  conceal<br/>
 ------------------------------------------------------------------------<br/>
 xterm         yes      yes      no      yes      yes      yes      yes<br/>
 linux         yes      yes      yes    bold      yes      yes      no<br/>
 rxvt          yes      yes      no      yes  bold/black   yes      no<br/>
 dtterm        yes      yes      yes     yes    reverse    yes      yes<br/>
 teraterm      yes    reverse    no      yes    rev/red    yes      no<br/>
 aixterm      kinda   normal     no      yes      no       yes      yes<br/>
 PuTTY         yes     color     no      yes      no       yes      no<br/>
 Windows       yes      no       no      no       no       yes      no<br/>
 Cygwin SSH    yes      yes      no     color    color    color     yes<br/>
 Mac Terminal  yes      yes      no      yes      yes      yes      yes<br/>
<div class="spacer">
</div>
Windows is Windows telnet, Cygwin SSH is the OpenSSH implementation under Cygwin on Windows NT, and Mac Terminal is the Terminal application in Mac OS X.  Where the entry is other than yes or no, that emulator displays the given attribute as something else instead.  Note that on an aixterm, clear doesn't reset colors; you have to explicitly set the colors back to what you want.  More entries in this table are welcome.<div class="spacer">
</div>
Note that codes 3 (italic), 6 (rapid blink), and 9 (strike-through) are specified in ANSI X3.64 and ECMA-048 but are not commonly supported by most displays and emulators and therefore aren't supported by this module at the present time.  ECMA-048 also specifies a large number of other attributes, including a sequence of attributes for font changes, Fraktur characters, double-underlining, framing, circling, and overlining.  As none of these attributes are widely supported or useful, they also aren't currently supported by this module.</div>
<div class="section">
<h1>SEE ALSO</h1> ECMA-048 is available on-line (at least at the time of this writing) at http://www.ecma-international.org/publications/standards/ECMA-048.HTM &lt;http://www.ecma-international.org/publications/standards/ECMA-048.HTM&gt;.<div class="spacer">
</div>
ISO 6429 is available from ISO for a charge; the author of this module does not own a copy of it.  Since the source material for ISO 6429 was ECMA-048 and the latter is available for free, there seems little reason to obtain the ISO standard.<div class="spacer">
</div>
The current version of this module is always available from its web site at &lt;http://www.eyrie.org/~eagle/software/ansicolor/&gt;.  It is also part of the Perl core distribution as of 5.6.0.</div>
<div class="section">
<h1>AUTHORS</h1> Original idea (using constants) by Zenin, reimplemented using subs by Russ Allbery &lt;rra@stanford.edu&gt;, and then combined with the original idea by Russ with input from Zenin.  Russ Allbery now maintains this module.</div>
<div class="section">
<h1>COPYRIGHT AND LICENSE</h1> Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2005, 2006, 2008, 2009, 2010 Russ Allbery &lt;rra@stanford.edu&gt; and Zenin.  This program is free software; you may redistribute it and/or modify it under the same terms as Perl itself.<div class="spacer">
</div>
PUSHCOLOR, POPCOLOR, and LOCALCOLOR were contributed by openmethods.com voice solutions.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-09-26</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

