<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Config::Augeas(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Config::Augeas(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
Config::Augeas(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Config::Augeas - Edit configuration files through Augeas C library</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
  use Config::Augeas;<br/>
<br/>
  my $aug = Config::Augeas-&gt;new( root =&gt; $aug_root ) ;<br/>
<br/>
  my $ret = $aug-&gt;get(&quot;/files/etc/hosts/1/ipaddr&quot;) ;<br/>
  $aug-&gt;set(&quot;/files/etc/hosts/2/ipaddr&quot;,&quot;192.168.0.1&quot;) ;<br/>
<br/>
  my @a = $aug-&gt;match(&quot;/files/etc/hosts/&quot;) ;<br/>
<br/>
  my $nb = $aug-&gt;count_match(&quot;/files/etc/hosts/&quot;) ;<br/>
<br/>
  $aug-&gt;save ;<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> Augeas is a library and command line tool that focuses on the most basic problem in handling Linux configurations programmatically: editing actual configuration files in a controlled manner.<div class="spacer">
</div>
To that end, Augeas exposes a tree of all configuration settings (well, all the ones it knows about) and a simple local API for manipulating the tree. Augeas then modifies underlying configuration files according to the changes that have been made to the tree; it does as little modeling of configurations as possible, and focuses exclusively on transforming the tree-oriented syntax of its public API to the myriad syntaxes of individual configuration files.<div class="spacer">
</div>
This module provides an object oriented Perl interface for Augeas configuration edition library with a more &quot;perlish&quot; API than Augeas C counterpart.</div>
<div class="section">
<h1>Constructor</h1></div>
<div class="section">
<h1>new ( ... )</h1> Creates a new Config::Augeas object. Optional parameters are:<dl>
<dt>
loadpath</dt>
<dd>
a colon-spearated list of directories that lenses should be searched in. This is in addition to the standard load path and the directories in specified &quot;AUGEAS_LENS_LIB&quot; environment variable.</dd>
</dl>
<dl>
<dt>
root</dt>
<dd>
Use &quot;root&quot; as the filesystem root. If not specified, use the value of the environment variable &quot;AUGEAS_ROOT&quot;. If that doesn't exist either, use &quot;&quot;/&quot;&quot;.</dd>
</dl>
<dl>
<dt>
save =&gt; backup | newfile | noop</dt>
<dd>
Specify how to save the configuration file. Either create a newfile (with extension &quot;.augnew&quot;, and do not overwrite the original file) or move the original file into a backup file (&quot;.augsave&quot; extension). &quot;noop&quot; make saves a no-op process, just record what would have changed</dd>
</dl>
<dl>
<dt>
type_check =&gt; 1</dt>
<dd>
Typecheck lenses; since it can be very expensive it is not done by default.</dd>
</dl>
<dl>
<dt>
no_std_inc</dt>
<dd>
Do not use the builtin load path for modules</dd>
</dl>
<dl>
<dt>
no_load</dt>
<dd>
Do not load the tree from AUG_INIT</dd>
</dl>
</div>
<div class="section">
<h1>Methods</h1><div class="subsection">
<h2>defvar( name, [ expr ])</h2> Define a variable &quot;name&quot; whose value is the result of evaluating &quot;expr&quot;. If a variable &quot;name&quot; already exists, its name will be replaced with the result of evaluating &quot;expr&quot;.<div class="spacer">
</div>
If &quot;expr&quot; is omitted, the variable &quot;name&quot; will be removed if it is defined.<div class="spacer">
</div>
Path variables can be used in path expressions later on by prefixing them with '$'.<div class="spacer">
</div>
Returns -1 on error; on success, returns 0 if &quot;expr&quot; evaluates to anything other than a nodeset, and the number of nodes if &quot;expr&quot; evaluates to a nodeset</div>
<div class="subsection">
<h2>defnode ( name, expr, value )</h2> Define a variable &quot;name&quot; whose value is the result of evaluating &quot;expr&quot;, which must evaluate to a nodeset. If a variable &quot;name&quot; already exists, its name will be replaced with the result of evaluating &quot;expr&quot;.<div class="spacer">
</div>
If &quot;expr&quot; evaluates to an empty nodeset, a node is created, equivalent to calling &quot;set( expr, value)&quot; and &quot;name&quot; will be the nodeset containing that single node.<div class="spacer">
</div>
Returns undef on error<div class="spacer">
</div>
Returns an array containing:<dl>
<dt>
&#8226;</dt>
<dd>
the number of nodes in the nodeset</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
1 if a node was created, and 0 if it already existed.</dd>
</dl>
</div>
<div class="subsection">
<h2>get( path )</h2> Lookup the value associated with &quot;path&quot;. Returns the value associated with &quot;path&quot; if &quot;path&quot; matches exactly one node. If PATH matches no nodes or more than one node, returns undef.</div>
<div class="subsection">
<h2>set ( path, value )</h2> Set the value associated with &quot;path&quot; to &quot;value&quot;. &quot;value&quot; is copied into Augeas internal data structure. Intermediate entries are created if they don't exist. Return 1 on success, 0 on error. It is an error if more than one node matches &quot;path&quot;.</div>
<div class="subsection">
<h2>insert ( label, before | after , path )</h2> Create a new sibling &quot;label&quot; for &quot;path&quot; by inserting into the tree just before or just after &quot;path&quot;.<div class="spacer">
</div>
&quot;path&quot; must match exactly one existing node in the tree, and &quot;label&quot; must be a label, i.e. not contain a '/', '*' or end with a bracketed index '[N]'.<div class="spacer">
</div>
Return 1 on success, and 0 if the insertion fails.</div>
<div class="subsection">
<h2>remove ( path )</h2> Remove path and all its children. Returns the number of entries removed.  All nodes that match &quot;path&quot;, and their descendants, are removed. (&quot;remove&quot; can also be called with &quot;rm&quot;)</div>
<div class="subsection">
<h2>move ( src, dest )</h2> Move the node SRC to DST. SRC must match exactly one node in the tree. DST must either match exactly one node in the tree, or may not exist yet. If DST exists already, it and all its descendants are deleted. If DST does not exist yet, it and all its missing ancestors are created.<div class="spacer">
</div>
Note that the node SRC always becomes the node DST: when you move &quot;/a/b&quot; to &quot;/x&quot;, the node &quot;/a/b&quot; is now called &quot;/x&quot;, no matter whether &quot;/x&quot; existed initially or not. (&quot;move&quot; can also be called with &quot;mv&quot;)<div class="spacer">
</div>
Returns 1 in case of success, 0 otherwise.</div>
<div class="subsection">
<h2>span ( path )</h2> Returns a hash containing the &quot;filename&quot;, &quot;label_start&quot;, &quot;label_end&quot;, &quot;value_start&quot;, &quot;value_end&quot;, &quot;span_start&quot; and &quot;span_end&quot; of the given &quot;path&quot;.<div class="spacer">
</div>
Example:<div class="spacer">
</div>
<br/>
  my $span = $aug-&gt;span('/files/etc/passwd/root') ;<br/>
  # If filename is undefined, there are no valid span information for this node<br/>
  if ($span-&gt;{filename}) {<br/>
     print &quot;Found root in passwd at character $span-&gt;{span_start}\n&quot; ;<br/>
  }<br/>
<div class="spacer">
</div>
WARNING: You must check that $span-&gt;{filename} is defined. If it isn't, the node has no span information and all other values in the hash are wrong.</div>
<div class="subsection">
<h2>match ( pattern )</h2> Returns an array of the elements that match of the path expression &quot;pattern&quot;. The returned paths are sufficiently qualified to make sure that they match exactly one node in the current tree.</div>
<div class="subsection">
<h2>count_match ( pattern )</h2> Same as match but return the number of matching element in manner more efficient than using &quot;scalar match( pattern )&quot;</div>
<div class="subsection">
<h2>save</h2> Write all pending changes to disk. Return 0 if an error is encountered, 1 on success. Only files that had any changes made to them are written. &quot;save&quot; will follow backup files as specified with Config::Augeas::new &quot;backup&quot; parameter.</div>
<div class="subsection">
<h2>load</h2> Load files into the tree. Which files to load and what lenses to use on them is specified under &quot;/augeas/load&quot; in the tree; each entry &quot;/augeas/load/NAME&quot; specifies a 'transform', by having itself exactly one child 'lens' and any number of children labelled 'incl' and 'excl'. The value of NAME has no meaning.<div class="spacer">
</div>
The 'lens' grandchild of &quot;/augeas/load&quot; specifies which lens to use, and can either be the fully qualified name of a lens 'Module.lens' or '@Module'. The latter form means that the lens from the transform marked for autoloading in &quot;MODULE&quot; should be used.<div class="spacer">
</div>
The 'incl' and 'excl' grandchildren of &quot;/augeas/load&quot; indicate which files to transform. Their value are used as glob patterns. Any file that matches at least one 'incl' pattern and no 'excl' pattern is transformed. The order of 'incl' and 'excl' entries is irrelevant.<div class="spacer">
</div>
When init is first called, it populates &quot;/augeas/load&quot; with the transforms marked for autoloading in all the modules it finds.<div class="spacer">
</div>
Before loading any files, &quot;load&quot; will remove everything underneath &quot;/augeas/files&quot; and &quot;/files&quot;, regardless of whether any entries have been modified or not.<div class="spacer">
</div>
Returns 0 on error, 1 on success. Note that success includes the case where some files could not be loaded. Details of such files can be found as '&quot;/augeas//error&quot;'.</div>
<div class="subsection">
<h2>print ( [ path  , [ file ] ] )</h2> Print each node matching &quot;path&quot; and its descendants on STDOUT or in a file<div class="spacer">
</div>
The second parameter can be :<dl>
<dt>
&#8226;</dt>
<dd>
A file name.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Omitted. In this case, print to STDOUT</dd>
</dl>
<div class="spacer">
</div>
If path is omitted, all Augeas nodes will be printed.<div class="spacer">
</div>
Example:<div class="spacer">
</div>
<br/>
  $aug-&gt;print ; # print all nodes to STDOUT<br/>
  $aug-&gt;print('/files') ; # print all file nodes to STDOUT<br/>
  $aug-&gt;print('/augeas/','bar.txt'); # print Augeas meta data in bar.txt<br/>
<div class="spacer">
</div>
WARNING: The parameter order is reversed compared to Augeas C API.</div>
<div class="subsection">
<h2>srun ( [ text  , [ file ] ] )</h2> Run one or more newline-separated commands listed in &quot;text&quot;. Running just &quot;help&quot; will print what commands are available. Commands accepted by this are identical to what augtool accepts.<div class="spacer">
</div>
The second parameter can be :<dl>
<dt>
&#8226;</dt>
<dd>
A file name.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Omitted. In this case, print to STDOUT</dd>
</dl>
<div class="spacer">
</div>
The function returns the number of executed commands on success, and 0 otherwise.</div>
</div>
<div class="section">
<h1>Error reporting</h1><div class="subsection">
<h2>error</h2> Returns the error code from the last API call as a short string: noerror, nomem, internal, pathx, nomatch, manymatch, syntax, nolens, multiple_transforms</div>
<div class="subsection">
<h2>error_message</h2> Return a human-readable message for the error code.</div>
<div class="subsection">
<h2>error_minor_message</h2> Return a human-readable message elaborating the error code; might be undef. For example, when the error code is &quot;pathx&quot;, this will explain how the path expression is invalid.</div>
<div class="subsection">
<h2>error_details</h2> Return details about the error, which might be undef. For example, for &quot;pathx&quot;, indicates where in the path expression the error occurred. The returned value can only be used until the next API call</div>
</div>
<div class="section">
<h1>CAVEATS</h1> Object oriented design would suggest to use a new class to represent Augeas errors, but this would stray too far from current Augeas design and API.</div>
<div class="section">
<h1>SEE ALSO</h1><dl>
<dt>
&#8226;</dt>
<dd>
http://augeas.net/ : Augeas project page</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Config::Model : Another kind of configuration editor (with optional GUI and advanced validation).</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Config::Augeas::Validator : A unit test framework for configuration files.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Config::Augeas::Exporter : A module to export the Augeas tree to various formats.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Augeas mailing list: http://augeas.net/developers.html</dd>
</dl>
</div>
<div class="section">
<h1>AUTHORS</h1><dl>
<dt>
&#8226;</dt>
<dd>
Dominique Dumont, &lt;ddumont at cpan dot org@&lt;gt&gt;</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Raphael Pinson, &lt;raphink at cpan dot org@&lt;gt&gt;</dd>
</dl>
</div>
<div class="section">
<h1>COPYRIGHT AND LICENSE</h1><dl>
<dt>
&#8226;</dt>
<dd>
Copyright (C) 2008-2010 by Dominique Dumont</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Copyright (C) 2011 by Raphael Pinson</dd>
</dl>
<div class="spacer">
</div>
This library is free software; you can redistribute it and/or modify it under the LGPL terms.</div>
<table class="foot">
<tr>
<td class="foot-date">
2012-03-06</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

