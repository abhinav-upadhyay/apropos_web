<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Exception::Class(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Exception::Class(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
Exception::Class(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Exception::Class - A module that allows you to declare real exception classes in Perl</div>
<div class="section">
<h1>VERSION</h1> version 1.31</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
  use Exception::Class (<br/>
      'MyException',<br/>
<br/>
      'AnotherException' =&gt; { isa =&gt; 'MyException' },<br/>
<br/>
      'YetAnotherException' =&gt; {<br/>
          isa         =&gt; 'AnotherException',<br/>
          description =&gt; 'These exceptions are related to IPC'<br/>
      },<br/>
<br/>
      'ExceptionWithFields' =&gt; {<br/>
          isa    =&gt; 'YetAnotherException',<br/>
          fields =&gt; [ 'grandiosity', 'quixotic' ],<br/>
          alias  =&gt; 'throw_fields',<br/>
      },<br/>
  );<br/>
<br/>
  # try<br/>
  eval { MyException-&gt;throw( error =&gt; 'I feel funny.' ) };<br/>
<br/>
  my $e;<br/>
<br/>
  # catch<br/>
  if ( $e = Exception::Class-&gt;caught('MyException') ) {<br/>
      warn $e-&gt;error, &quot;\n&quot;, $e-&gt;trace-&gt;as_string, &quot;\n&quot;;<br/>
      warn join ' ', $e-&gt;euid, $e-&gt;egid, $e-&gt;uid, $e-&gt;gid, $e-&gt;pid, $e-&gt;time;<br/>
<br/>
      exit;<br/>
  }<br/>
  elsif ( $e = Exception::Class-&gt;caught('ExceptionWithFields') ) {<br/>
      $e-&gt;quixotic ? do_something_wacky() : do_something_sane();<br/>
  }<br/>
  else {<br/>
      $e = Exception::Class-&gt;caught();<br/>
      ref $e ? $e-&gt;rethrow : die $e;<br/>
  }<br/>
<br/>
  # use an alias - without parens subroutine name is checked at<br/>
  # compile time<br/>
  throw_fields error =&gt; &quot;No strawberry&quot;, grandiosity =&gt; &quot;quite a bit&quot;;<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> Exception::Class allows you to declare exception hierarchies in your modules in a &quot;Java-esque&quot; manner.<div class="spacer">
</div>
It features a simple interface allowing programmers to 'declare' exception classes at compile time.  It also has a base exception class, Exception::Class::Base, that can be easily extended.<div class="spacer">
</div>
It is designed to make structured exception handling simpler and better by encouraging people to use hierarchies of exceptions in their applications, as opposed to a single catch-all exception class.<div class="spacer">
</div>
This module does not implement any try/catch syntax.  Please see the &quot;OTHER EXCEPTION MODULES (try/catch syntax)&quot; section for more information on how to get this syntax.<div class="spacer">
</div>
You will also want to look at the documentation for Exception::Class::Base, which is the default base class for all exception objects created by this module.</div>
<div class="section">
<h1>DECLARING EXCEPTION CLASSES</h1> Importing &quot;Exception::Class&quot; allows you to automagically create Exception::Class::Base subclasses.  You can also create subclasses via the traditional means of defining your own subclass with @ISA. These two methods may be easily combined, so that you could subclass an exception class defined via the automagic import, if you desired this.<div class="spacer">
</div>
The syntax for the magic declarations is as follows:<div class="spacer">
</div>
'MANDATORY CLASS NAME' =&gt; \%optional_hashref<div class="spacer">
</div>
The hashref may contain the following options:<dl>
<dt>
&#8226;</dt>
<dd>
isa<div style="height: 1.00em;">
&#160;</div>
This is the class's parent class.  If this isn't provided then the class name in $Exception::Class::BASE_EXC_CLASS is assumed to be the parent (see below).<div style="height: 1.00em;">
&#160;</div>
This parameter lets you create arbitrarily deep class hierarchies. This can be any other Exception::Class::Base subclass in your declaration  <i>or</i> a subclass loaded from a module.<div style="height: 1.00em;">
&#160;</div>
To change the default exception class you will need to change the value of $Exception::Class::BASE_EXC_CLASS  <i>before</i> calling &quot;import()&quot;.  To do this simply do something like this:<div style="height: 1.00em;">
&#160;</div>
<br/>
  BEGIN { $Exception::Class::BASE_EXC_CLASS = 'SomeExceptionClass'; }<br/>
<div style="height: 1.00em;">
&#160;</div>
If anyone can come up with a more elegant way to do this please let me know.<div style="height: 1.00em;">
&#160;</div>
CAVEAT: If you want to automagically subclass an Exception::Class::Base subclass loaded from a file, then you  <i>must</i> compile the class (via use or require or some other magic)  <i>before</i> you import &quot;Exception::Class&quot; or you'll get a compile time error.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
fields<div style="height: 1.00em;">
&#160;</div>
This allows you to define additional attributes for your exception class.  Any field you define can be passed to the &quot;throw()&quot; or &quot;new()&quot; methods as additional parameters for the constructor.  In addition, your exception object will have an accessor method for the fields you define.<div style="height: 1.00em;">
&#160;</div>
This parameter can be either a scalar (for a single field) or an array reference if you need to define multiple fields.<div style="height: 1.00em;">
&#160;</div>
Fields will be inherited by subclasses.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
alias<div style="height: 1.00em;">
&#160;</div>
Specifying an alias causes this class to create a subroutine of the specified name in the  <i>caller's</i> namespace.  Calling this subroutine is equivalent to calling &quot;&lt;class&gt;-&gt;throw(@_)&quot; for the given exception class.<div style="height: 1.00em;">
&#160;</div>
Besides convenience, using aliases also allows for additional compile time checking.  If the alias is called  <i>without parentheses</i>, as in &quot;throw_fields &quot;an error occurred&quot;&quot;, then Perl checks for the existence of the &quot;throw_fields()&quot; subroutine at compile time.  If instead you do &quot;ExceptionWithFields-&gt;throw(...)&quot;, then Perl checks the class name at runtime, meaning that typos may sneak through.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
description<div style="height: 1.00em;">
&#160;</div>
Each exception class has a description method that returns a fixed string.  This should describe the exception  <i>class</i> (as opposed to any particular exception object).  This may be useful for debugging if you start catching exceptions you weren't expecting (particularly if someone forgot to document them) and you don't understand the error messages.</dd>
</dl>
<div class="spacer">
</div>
The &quot;Exception::Class&quot; magic attempts to detect circular class hierarchies and will die if it finds one.  It also detects missing links in a chain, for example if you declare Bar to be a subclass of Foo and never declare Foo.</div>
<div class="section">
<h1>Catching Exceptions</h1> &quot;Exception::Class&quot; provides some syntactic sugar for catching exceptions in a safe manner:<div class="spacer">
</div>
<br/>
  eval {...};<br/>
<br/>
  if ( my $e = Exception::Class-&gt;caught('My::Error') ) {<br/>
      cleanup();<br/>
      do_something_with_exception($e);<br/>
  }<br/>
<div class="spacer">
</div>
The &quot;caught()&quot; method takes a class name and returns an exception object if the last thrown exception is of the given class, or a subclass of that class.  If it is not given any arguments, it simply returns $@.<div class="spacer">
</div>
You should <b>always</b> make a copy of the exception object, rather than using $@ directly.  This is necessary because if your &quot;cleanup()&quot; function uses &quot;eval&quot;, or calls something which uses it, then $@ is overwritten.  Copying the exception preserves it for the call to &quot;do_something_with_exception()&quot;.<div class="spacer">
</div>
Exception objects also provide a caught method so you can write:<div class="spacer">
</div>
<br/>
  if ( my $e = My::Error-&gt;caught() ) {<br/>
      cleanup();<br/>
      do_something_with_exception($e);<br/>
  }<br/>
<div class="subsection">
<h2>Uncatchable Exceptions</h2> Internally, the &quot;caught()&quot; method will call &quot;isa()&quot; on the exception object.  You could make an exception &quot;uncatchable&quot; by overriding &quot;isa()&quot; in that class like this:<div class="spacer">
</div>
<br/>
 package Exception::Uncatchable;<br/>
<br/>
 sub isa { shift-&gt;rethrow }<br/>
<div class="spacer">
</div>
Of course, this only works if you always call &quot;Exception::Class-&gt;caught()&quot; after an &quot;eval&quot;.</div>
</div>
<div class="section">
<h1>USAGE RECOMMENDATION</h1> If you're creating a complex system that throws lots of different types of exceptions, consider putting all the exception declarations in one place.  For an app called Foo you might make a &quot;Foo::Exceptions&quot; module and use that in all your code.  This module could just contain the code to make &quot;Exception::Class&quot; do its automagic class creation.  Doing this allows you to more easily see what exceptions you have, and makes it easier to keep track of them.<div class="spacer">
</div>
This might look something like this:<div class="spacer">
</div>
<br/>
  package Foo::Bar::Exceptions;<br/>
<br/>
  use Exception::Class (<br/>
      Foo::Bar::Exception::Senses =&gt;<br/>
          { description =&gt; 'sense-related exception' },<br/>
<br/>
      Foo::Bar::Exception::Smell =&gt; {<br/>
          isa         =&gt; 'Foo::Bar::Exception::Senses',<br/>
          fields      =&gt; 'odor',<br/>
          description =&gt; 'stinky!'<br/>
      },<br/>
<br/>
      Foo::Bar::Exception::Taste =&gt; {<br/>
          isa         =&gt; 'Foo::Bar::Exception::Senses',<br/>
          fields      =&gt; [ 'taste', 'bitterness' ],<br/>
          description =&gt; 'like, gag me with a spoon!'<br/>
      },<br/>
<br/>
      ...<br/>
  );<br/>
<div class="spacer">
</div>
You may want to create a real module to subclass Exception::Class::Base as well, particularly if you want your exceptions to have more methods.<div class="subsection">
<h2>Subclassing Exception::Class::Base</h2> As part of your usage of &quot;Exception::Class&quot;, you may want to create your own base exception class which subclasses Exception::Class::Base.  You should feel free to subclass any of the methods documented above.  For example, you may want to subclass &quot;new()&quot; to add additional information to your exception objects.</div>
</div>
<div class="section">
<h1>Exception::Class FUNCTIONS</h1> The &quot;Exception::Class&quot; method offers one function, &quot;Classes()&quot;, which is not exported.  This method returns a list of the classes that have been created by calling the &quot;Exception::Class&quot;  <i>import()</i> method. Note that this is  <i>all</i> the subclasses that have been created, so it may include subclasses created by things like CPAN modules, etc.  Also note that if you simply define a subclass via the normal Perl method of setting @ISA or &quot;use base&quot;, then your subclass will not be included.</div>
<div class="section">
<h1>OTHER EXCEPTION MODULES (try/catch syntax)</h1> If you are interested in adding try/catch/finally syntactic sugar to your code then I recommend you check out U. Arun Kumar's &quot;Error.pm&quot; module, which implements this syntax.  It also includes its own base exception class, &quot;Error::Simple&quot;.<div class="spacer">
</div>
If you would prefer to use the Exception::Class::Base class included with this module, you'll have to add this to your code somewhere:<div class="spacer">
</div>
<br/>
  push @Exception::Class::Base::ISA, 'Error'<br/>
      unless Exception::Class::Base-&gt;isa('Error');<br/>
<div class="spacer">
</div>
It's a hack but apparently it works.</div>
<div class="section">
<h1>SUPPORT</h1> Please submit bugs to the CPAN RT system at http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Exception%3A%3AClass or via email at bug-exception-class@rt.cpan.org.</div>
<div class="section">
<h1>DONATIONS</h1> If you'd like to thank me for the work I've done on this module, please consider making a &quot;donation&quot; to me via PayPal. I spend a lot of free time creating free software, and would appreciate any support you'd care to offer.<div class="spacer">
</div>
Please note that <b>I am not suggesting that you must do this</b> in order for me to continue working on this particular software. I will continue to do so, inasmuch as I have in the past, for as long as it interests me.<div class="spacer">
</div>
Similarly, a donation made in this way will probably not make me work on this software much more, unless I get so many donations that I can consider working on free software full time, which seems unlikely at best.<div class="spacer">
</div>
To donate, log into PayPal and send money to autarch@urth.org or use the button on this page: &lt;http://www.urth.org/~autarch/fs-donation.html&gt;</div>
<div class="section">
<h1>AUTHOR</h1><br/>
  Dave Rolsky &lt;autarch@urth.org&gt;<br/>
</div>
<div class="section">
<h1>COPYRIGHT AND LICENSE</h1> This software is Copyright (c) 2010 by Dave Rolsky.<div class="spacer">
</div>
This is free software, licensed under:<div class="spacer">
</div>
<br/>
  The Artistic License 2.0<br/>
</div>
<table class="foot">
<tr>
<td class="foot-date">
2010-06-26</td>
<td class="foot-os">
perl v5.10.1</td>
</tr>
</table>
</div>
</body>
</html>

