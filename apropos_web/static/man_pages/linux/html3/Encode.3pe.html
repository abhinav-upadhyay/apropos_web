<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Encode(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Encode(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
Encode(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Encode - character encodings</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
    use Encode;<br/>
<div class="subsection">
<h2>Table of Contents</h2> Encode consists of a collection of modules whose details are too big to fit in one document.  This POD itself explains the top-level APIs and general topics at a glance.  For other topics and more details, see the PODs below:<div class="spacer">
</div>
<br/>
  Name                          Description<br/>
  --------------------------------------------------------<br/>
  Encode::Alias         Alias definitions to encodings<br/>
  Encode::Encoding      Encode Implementation Base Class<br/>
  Encode::Supported     List of Supported Encodings<br/>
  Encode::CN            Simplified Chinese Encodings<br/>
  Encode::JP            Japanese Encodings<br/>
  Encode::KR            Korean Encodings<br/>
  Encode::TW            Traditional Chinese Encodings<br/>
  --------------------------------------------------------<br/>
</div>
</div>
<div class="section">
<h1>DESCRIPTION</h1> The &quot;Encode&quot; module provides the interfaces between Perl's strings and the rest of the system.  Perl strings are sequences of  <b>characters</b>.<div class="spacer">
</div>
The repertoire of characters that Perl can represent is at least that defined by the Unicode Consortium. On most platforms the ordinal values of the characters (as returned by &quot;ord(ch)&quot;) is the &quot;Unicode codepoint&quot; for the character (the exceptions are those platforms where the legacy encoding is some variant of EBCDIC rather than a super-set of ASCII - see perlebcdic).<div class="spacer">
</div>
Traditionally, computer data has been moved around in 8-bit chunks often called &quot;bytes&quot;. These chunks are also known as &quot;octets&quot; in networking standards. Perl is widely used to manipulate data of many types - not only strings of characters representing human or computer languages but also &quot;binary&quot; data being the machine's representation of numbers, pixels in an image - or just about anything.<div class="spacer">
</div>
When Perl is processing &quot;binary data&quot;, the programmer wants Perl to process &quot;sequences of bytes&quot;. This is not a problem for Perl - as a byte has 256 possible values, it easily fits in Perl's much larger &quot;logical character&quot;.<div class="subsection">
<h2>TERMINOLOGY</h2><dl>
<dt>
&#8226;</dt>
<dd>
<i>character</i>: a character in the range 0..(2**32-1) (or more). (What Perl's strings are made of.)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
<i>byte</i>: a character in the range 0..255 (A special case of a Perl character.)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
<i>octet</i>: 8 bits of data, with ordinal values 0..255 (Term for bytes passed to or from a non-Perl context, e.g. a disk file.)</dd>
</dl>
</div>
</div>
<div class="section">
<h1>PERL ENCODING API</h1><dl>
<dt>
$octets  = encode(ENCODING, $string [, CHECK])</dt>
<dd>
Encodes a string from Perl's internal form into <i>ENCODING</i> and returns a sequence of octets.  ENCODING can be either a canonical name or an alias.  For encoding names and aliases, see &quot;Defining Aliases&quot;. For CHECK, see &quot;Handling Malformed Data&quot;.<div style="height: 1.00em;">
&#160;</div>
For example, to convert a string from Perl's internal format to iso-8859-1 (also known as Latin1),<div style="height: 1.00em;">
&#160;</div>
<br/>
  $octets = encode(&quot;iso-8859-1&quot;, $string);<br/>
<div style="height: 1.00em;">
&#160;</div>
<b>CAVEAT</b>: When you run &quot;$octets = encode(&quot;utf8&quot;, $string)&quot;, then $octets  <b>may not be equal to</b> $string.  Though they both contain the same data, the UTF8 flag for $octets is  <b>always</b> off.  When you encode anything, UTF8 flag of the result is always off, even when it contains completely valid utf8 string. See &quot;The UTF8 flag&quot; below.<div style="height: 1.00em;">
&#160;</div>
If the $string is &quot;undef&quot; then &quot;undef&quot; is returned.</dd>
</dl>
<dl>
<dt>
$string = decode(ENCODING, $octets [, CHECK])</dt>
<dd>
Decodes a sequence of octets assumed to be in <i>ENCODING</i> into Perl's internal form and returns the resulting string.  As in  <i>encode()</i>, ENCODING can be either a canonical name or an alias. For encoding names and aliases, see &quot;Defining Aliases&quot;.  For CHECK, see &quot;Handling Malformed Data&quot;.<div style="height: 1.00em;">
&#160;</div>
For example, to convert ISO-8859-1 data to a string in Perl's internal format:<div style="height: 1.00em;">
&#160;</div>
<br/>
  $string = decode(&quot;iso-8859-1&quot;, $octets);<br/>
<div style="height: 1.00em;">
&#160;</div>
<b>CAVEAT</b>: When you run &quot;$string = decode(&quot;utf8&quot;, $octets)&quot;, then $string  <b>may not be equal to</b> $octets.  Though they both contain the same data, the UTF8 flag for $string is on unless $octets entirely consists of ASCII data (or EBCDIC on EBCDIC machines).  See &quot;The UTF8 flag&quot; below.<div style="height: 1.00em;">
&#160;</div>
If the $string is &quot;undef&quot; then &quot;undef&quot; is returned.</dd>
</dl>
<dl>
<dt>
[$obj =] find_encoding(ENCODING)</dt>
<dd>
Returns the <i>encoding object</i> corresponding to ENCODING.  Returns undef if no matching ENCODING is find.<div style="height: 1.00em;">
&#160;</div>
This object is what actually does the actual (en|de)coding.<div style="height: 1.00em;">
&#160;</div>
<br/>
  $utf8 = decode($name, $bytes);<br/>
<div style="height: 1.00em;">
&#160;</div>
is in fact<div style="height: 1.00em;">
&#160;</div>
<br/>
  $utf8 = do{<br/>
    $obj = find_encoding($name);<br/>
    croak qq(encoding &quot;$name&quot; not found) unless ref $obj;<br/>
    $obj-&gt;decode($bytes)<br/>
  };<br/>
<div style="height: 1.00em;">
&#160;</div>
with more error checking.<div style="height: 1.00em;">
&#160;</div>
Therefore you can save time by reusing this object as follows;<div style="height: 1.00em;">
&#160;</div>
<br/>
  my $enc = find_encoding(&quot;iso-8859-1&quot;);<br/>
  while(&lt;&gt;){<br/>
     my $utf8 = $enc-&gt;decode($_);<br/>
     # and do someting with $utf8;<br/>
  }<br/>
<div style="height: 1.00em;">
&#160;</div>
Besides &quot;-&gt;decode&quot; and &quot;-&gt;encode&quot;, other methods are available as well.  For instance, &quot;-&gt; name&quot; returns the canonical name of the encoding object.<div style="height: 1.00em;">
&#160;</div>
<br/>
  find_encoding(&quot;latin1&quot;)-&gt;name; # iso-8859-1<br/>
<div style="height: 1.00em;">
&#160;</div>
See Encode::Encoding for details.</dd>
</dl>
<dl>
<dt>
[$length =] from_to($octets, FROM_ENC, TO_ENC [, CHECK])</dt>
<dd>
Converts <b>in-place</b> data between two encodings. The data in $octets must be encoded as octets and not as characters in Perl's internal format. For example, to convert ISO-8859-1 data to Microsoft's CP1250 encoding:<div style="height: 1.00em;">
&#160;</div>
<br/>
  from_to($octets, &quot;iso-8859-1&quot;, &quot;cp1250&quot;);<br/>
<div style="height: 1.00em;">
&#160;</div>
and to convert it back:<div style="height: 1.00em;">
&#160;</div>
<br/>
  from_to($octets, &quot;cp1250&quot;, &quot;iso-8859-1&quot;);<br/>
<div style="height: 1.00em;">
&#160;</div>
Note that because the conversion happens in place, the data to be converted cannot be a string constant; it must be a scalar variable.<div style="height: 1.00em;">
&#160;</div>
<i>from_to()</i> returns the length of the converted string in octets on success,  <i>undef</i> on error.<div style="height: 1.00em;">
&#160;</div>
<b>CAVEAT</b>: The following operations look the same but are not quite so;<div style="height: 1.00em;">
&#160;</div>
<br/>
  from_to($data, &quot;iso-8859-1&quot;, &quot;utf8&quot;); #1<br/>
  $data = decode(&quot;iso-8859-1&quot;, $data);  #2<br/>
<div style="height: 1.00em;">
&#160;</div>
Both #1 and #2 make $data consist of a completely valid UTF-8 string but only #2 turns UTF8 flag on.  #1 is equivalent to<div style="height: 1.00em;">
&#160;</div>
<br/>
  $data = encode(&quot;utf8&quot;, decode(&quot;iso-8859-1&quot;, $data));<br/>
<div style="height: 1.00em;">
&#160;</div>
See &quot;The UTF8 flag&quot; below.<div style="height: 1.00em;">
&#160;</div>
Also note that<div style="height: 1.00em;">
&#160;</div>
<br/>
  from_to($octets, $from, $to, $check);<br/>
<div style="height: 1.00em;">
&#160;</div>
is equivalent to<div style="height: 1.00em;">
&#160;</div>
<br/>
  $octets = encode($to, decode($from, $octets), $check);<br/>
<div style="height: 1.00em;">
&#160;</div>
Yes, it does not respect the $check during decoding.  It is deliberately done that way.  If you need minute control, &quot;decode&quot; then &quot;encode&quot; as follows;<div style="height: 1.00em;">
&#160;</div>
<br/>
  $octets = encode($to, decode($from, $octets, $check_from), $check_to);<br/>
</dd>
</dl>
<dl>
<dt>
$octets = encode_utf8($string);</dt>
<dd>
Equivalent to &quot;$octets = encode(&quot;utf8&quot;, $string);&quot; The characters that comprise $string are encoded in Perl's internal format and the result is returned as a sequence of octets. All possible characters have a UTF-8 representation so this function cannot fail.</dd>
</dl>
<dl>
<dt>
$string = decode_utf8($octets [, CHECK]);</dt>
<dd>
equivalent to &quot;$string = decode(&quot;utf8&quot;, $octets [, CHECK])&quot;. The sequence of octets represented by $octets is decoded from UTF-8 into a sequence of logical characters. Not all sequences of octets form valid UTF-8 encodings, so it is possible for this call to fail.  For CHECK, see &quot;Handling Malformed Data&quot;.</dd>
</dl>
<div class="subsection">
<h2>Listing available encodings</h2><br/>
  use Encode;<br/>
  @list = Encode-&gt;encodings();<br/>
<div class="spacer">
</div>
Returns a list of the canonical names of the available encodings that are loaded.  To get a list of all available encodings including the ones that are not loaded yet, say<div class="spacer">
</div>
<br/>
  @all_encodings = Encode-&gt;encodings(&quot;:all&quot;);<br/>
<div class="spacer">
</div>
Or you can give the name of a specific module.<div class="spacer">
</div>
<br/>
  @with_jp = Encode-&gt;encodings(&quot;Encode::JP&quot;);<br/>
<div class="spacer">
</div>
When &quot;::&quot; is not in the name, &quot;Encode::&quot; is assumed.<div class="spacer">
</div>
<br/>
  @ebcdic = Encode-&gt;encodings(&quot;EBCDIC&quot;);<br/>
<div class="spacer">
</div>
To find out in detail which encodings are supported by this package, see Encode::Supported.</div>
<div class="subsection">
<h2>Defining Aliases</h2> To add a new alias to a given encoding, use:<div class="spacer">
</div>
<br/>
  use Encode;<br/>
  use Encode::Alias;<br/>
  define_alias(newName =&gt; ENCODING);<br/>
<div class="spacer">
</div>
After that, newName can be used as an alias for ENCODING. ENCODING may be either the name of an encoding or an  <i>encoding object</i><div class="spacer">
</div>
But before you do so, make sure the alias is nonexistent with &quot;resolve_alias()&quot;, which returns the canonical name thereof. i.e.<div class="spacer">
</div>
<br/>
  Encode::resolve_alias(&quot;latin1&quot;) eq &quot;iso-8859-1&quot; # true<br/>
  Encode::resolve_alias(&quot;iso-8859-12&quot;)   # false; nonexistent<br/>
  Encode::resolve_alias($name) eq $name  # true if $name is canonical<br/>
<div class="spacer">
</div>
<i>resolve_alias()</i> does not need &quot;use Encode::Alias&quot;; it can be exported via &quot;use Encode qw(resolve_alias)&quot;.<div class="spacer">
</div>
See Encode::Alias for details.</div>
<div class="subsection">
<h2>Finding IANA Character Set Registry names</h2> The canonical name of a given encoding does not necessarily agree with IANA IANA Character Set Registry, commonly seen as &quot;Content-Type: text/plain; charset= <i>whatever</i>&quot;.  For most cases canonical names work but sometimes it does not (notably 'utf-8-strict').<div class="spacer">
</div>
Therefore as of Encode version 2.21, a new method &quot;mime_name()&quot; is added.<div class="spacer">
</div>
<br/>
  use Encode;<br/>
  my $enc = find_encoding('UTF-8');<br/>
  warn $enc-&gt;name;      # utf-8-strict<br/>
  warn $enc-&gt;mime_name; # UTF-8<br/>
<div class="spacer">
</div>
See also:  Encode::Encoding</div>
</div>
<div class="section">
<h1>Encoding via PerlIO</h1> If your perl supports  <i>PerlIO</i> (which is the default), you can use a PerlIO layer to decode and encode directly via a filehandle.  The following two examples are totally identical in their functionality.<div class="spacer">
</div>
<br/>
  # via PerlIO<br/>
  open my $in,  &quot;&lt;:encoding(shiftjis)&quot;, $infile  or die;<br/>
  open my $out, &quot;&gt;:encoding(euc-jp)&quot;,   $outfile or die;<br/>
  while(&lt;$in&gt;){ print $out $_; }<br/>
<br/>
  # via from_to<br/>
  open my $in,  &quot;&lt;&quot;, $infile  or die;<br/>
  open my $out, &quot;&gt;&quot;, $outfile or die;<br/>
  while(&lt;$in&gt;){<br/>
    from_to($_, &quot;shiftjis&quot;, &quot;euc-jp&quot;, 1);<br/>
    print $out $_;<br/>
  }<br/>
<div class="spacer">
</div>
Unfortunately, it may be that encodings are PerlIO-savvy.  You can check if your encoding is supported by PerlIO by calling the &quot;perlio_ok&quot; method.<div class="spacer">
</div>
<br/>
  Encode::perlio_ok(&quot;hz&quot;);             # False<br/>
  find_encoding(&quot;euc-cn&quot;)-&gt;perlio_ok;  # True where PerlIO is available<br/>
<br/>
  use Encode qw(perlio_ok);            # exported upon request<br/>
  perlio_ok(&quot;euc-jp&quot;)<br/>
<div class="spacer">
</div>
Fortunately, all encodings that come with Encode core are PerlIO-savvy except for hz and ISO-2022-kr.  For gory details, see Encode::Encoding and Encode::PerlIO.</div>
<div class="section">
<h1>Handling Malformed Data</h1> The optional  <i>CHECK</i> argument tells Encode what to do when it encounters malformed data.  Without CHECK, Encode::FB_DEFAULT ( == 0 ) is assumed.<div class="spacer">
</div>
As of version 2.12 Encode supports coderef values for CHECK.  See below.<dl>
<dt>
<b>NOTE:</b> Not all encoding support this feature</dt>
<dd>
Some encodings ignore <i>CHECK</i> argument.  For example, Encode::Unicode ignores  <i>CHECK</i> and it always croaks on error.</dd>
</dl>
<div class="spacer">
</div>
Now here is the list of <i>CHECK</i> values available<dl>
<dt>
<i>CHECK</i> = Encode::FB_DEFAULT ( == 0)</dt>
<dd>
If <i>CHECK</i> is 0, (en|de)code will put a <i>substitution character</i> in place of a malformed character.  When you encode, &lt;subchar&gt; will be used.  When you decode the code point 0xFFFD is used.  If the data is supposed to be UTF-8, an optional lexical warning (category utf8) is given.</dd>
</dl>
<dl>
<dt>
<i>CHECK</i> = Encode::FB_CROAK ( == 1)</dt>
<dd>
If <i>CHECK</i> is 1, methods will die on error immediately with an error message.  Therefore, when  <i>CHECK</i> is set to 1,  you should trap the error with eval{} unless you really want to let it die.</dd>
</dl>
<dl>
<dt>
<i>CHECK</i> = Encode::FB_QUIET</dt>
<dd>
If <i>CHECK</i> is set to Encode::FB_QUIET, (en|de)code will immediately return the portion of the data that has been processed so far when an error occurs. The data argument will be overwritten with everything after that point (that is, the unprocessed part of data).  This is handy when you have to call decode repeatedly in the case where your source data may contain partial multi-byte character sequences, (i.e. you are reading with a fixed-width buffer). Here is a sample code that does exactly this:<div style="height: 1.00em;">
&#160;</div>
<br/>
  my $buffer = ''; my $string = '';<br/>
  while(read $fh, $buffer, 256, length($buffer)){<br/>
    $string .= decode($encoding, $buffer, Encode::FB_QUIET);<br/>
    # $buffer now contains the unprocessed partial character<br/>
  }<br/>
</dd>
</dl>
<dl>
<dt>
<i>CHECK</i> = Encode::FB_WARN</dt>
<dd>
This is the same as above, except that it warns on error.  Handy when you are debugging the mode above.</dd>
</dl>
<dl>
<dt>
perlqq mode (<i>CHECK</i> = Encode::FB_PERLQQ)</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
HTML charref mode (<i>CHECK</i> = Encode::FB_HTMLCREF)</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
XML charref mode (<i>CHECK</i> = Encode::FB_XMLCREF)</dt>
<dd>
For encodings that are implemented by Encode::XS, CHECK == Encode::FB_PERLQQ turns (en|de)code into &quot;perlqq&quot; fallback mode.<div style="height: 1.00em;">
&#160;</div>
When you decode, &quot;\x<i>HH</i>&quot; will be inserted for a malformed character, where  <i>HH</i> is the hex representation of the octet  that could not be decoded to utf8.  And when you encode, &quot;\x{ <i>HHHH</i>}&quot; will be inserted, where  <i>HHHH</i> is the Unicode ID of the character that cannot be found in the character repertoire of the encoding.<div style="height: 1.00em;">
&#160;</div>
HTML/XML character reference modes are about the same, in place of &quot;\x{ <i>HHHH</i>}&quot;, HTML uses &quot;&amp;#<i>NNN</i>;&quot; where <i>NNN</i> is a decimal number and XML uses &quot;&amp;#x <i>HHHH</i>;&quot; where <i>HHHH</i> is the hexadecimal number.<div style="height: 1.00em;">
&#160;</div>
In Encode 2.10 or later, &quot;LEAVE_SRC&quot; is also implied.</dd>
</dl>
<dl>
<dt>
The bitmask</dt>
<dd>
These modes are actually set via a bitmask.  Here is how the FB_XX constants are laid out.  You can import the FB_XX constants via &quot;use Encode qw(:fallbacks)&quot;; you can import the generic bitmask constants via &quot;use Encode qw(:fallback_all)&quot;.<div style="height: 1.00em;">
&#160;</div>
<br/>
                     FB_DEFAULT FB_CROAK FB_QUIET FB_WARN  FB_PERLQQ<br/>
 DIE_ON_ERR    0x0001             X<br/>
 WARN_ON_ERR   0x0002                               X<br/>
 RETURN_ON_ERR 0x0004                      X        X<br/>
 LEAVE_SRC     0x0008                                        X<br/>
 PERLQQ        0x0100                                        X<br/>
 HTMLCREF      0x0200<br/>
 XMLCREF       0x0400<br/>
</dd>
</dl>
<dl>
<dt>
Encode::LEAVE_SRC</dt>
<dd>
If the &quot;Encode::LEAVE_SRC&quot; bit is not set, but <i>CHECK</i> is, then the second argument to &quot;encode()&quot; or &quot;decode()&quot; may be assigned to by the functions. If you're not interested in this, then bitwise-or the bitmask with it.</dd>
</dl>
<div class="subsection">
<h2>coderef for CHECK</h2> As of Encode 2.12 CHECK can also be a code reference which takes the ord value of unmapped caharacter as an argument and returns a string that represents the fallback character.  For instance,<div class="spacer">
</div>
<br/>
  $ascii = encode(&quot;ascii&quot;, $utf8, sub{ sprintf &quot;&lt;U+%04X&gt;&quot;, shift });<br/>
<div class="spacer">
</div>
Acts like FB_PERLQQ but &lt;U+<i>XXXX</i>&gt; is used instead of \x{ <i>XXXX</i>}.</div>
</div>
<div class="section">
<h1>Defining Encodings</h1> To define a new encoding, use:<div class="spacer">
</div>
<br/>
    use Encode qw(define_encoding);<br/>
    define_encoding($object, 'canonicalName' [, alias...]);<br/>
<div class="spacer">
</div>
<i>canonicalName</i> will be associated with <i></i><i>$object</i><i></i>.  The object should provide the interface described in Encode::Encoding. If more than two arguments are provided then additional arguments are taken as aliases for  <i></i><i>$object</i><i></i>.<div class="spacer">
</div>
See Encode::Encoding for more details.</div>
<div class="section">
<h1>The UTF8 flag</h1> Before the introduction of Unicode support in perl, The &quot;eq&quot; operator just compared the strings represented by two scalars. Beginning with perl 5.8, &quot;eq&quot; compares two strings with simultaneous consideration of  <i>the UTF8 flag</i>. To explain why we made it so, I will quote page 402 of &quot;Programming Perl, 3rd ed.&quot;<dl>
<dt>
Goal #1:</dt>
<dd>
Old byte-oriented programs should not spontaneously break on the old byte-oriented data they used to work on.</dd>
</dl>
<dl>
<dt>
Goal #2:</dt>
<dd>
Old byte-oriented programs should magically start working on the new character-oriented data when appropriate.</dd>
</dl>
<dl>
<dt>
Goal #3:</dt>
<dd>
Programs should run just as fast in the new character-oriented mode as in the old byte-oriented mode.</dd>
</dl>
<dl>
<dt>
Goal #4:</dt>
<dd>
Perl should remain one language, rather than forking into a byte-oriented Perl and a character-oriented Perl.</dd>
</dl>
<div class="spacer">
</div>
Back when &quot;Programming Perl, 3rd ed.&quot; was written, not even Perl 5.6.0 was born and many features documented in the book remained unimplemented for a long time.  Perl 5.8 corrected this and the introduction of the UTF8 flag is one of them.  You can think of this perl notion as of a byte-oriented mode (UTF8 flag off) and a character-oriented mode (UTF8 flag on).<div class="spacer">
</div>
Here is how Encode takes care of the UTF8 flag.<dl>
<dt>
&#8226;</dt>
<dd>
When you encode, the resulting UTF8 flag is always off.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
When you decode, the resulting UTF8 flag is on unless you can unambiguously represent data.  Here is the definition of dis-ambiguity.<div style="height: 1.00em;">
&#160;</div>
After &quot;$utf8 = decode('foo', $octet);&quot;,<div style="height: 1.00em;">
&#160;</div>
<br/>
  When $octet is...   The UTF8 flag in $utf8 is<br/>
  ---------------------------------------------<br/>
  In ASCII only (or EBCDIC only)            OFF<br/>
  In ISO-8859-1                              ON<br/>
  In any other Encoding                      ON<br/>
  ---------------------------------------------<br/>
<div style="height: 1.00em;">
&#160;</div>
As you see, there is one exception, In ASCII.  That way you can assume Goal #1.  And with Encode Goal #2 is assumed but you still have to be careful in such cases mentioned in  <b>CAVEAT</b> paragraphs.<div style="height: 1.00em;">
&#160;</div>
This UTF8 flag is not visible in perl scripts, exactly for the same reason you cannot (or you  <i>don't have to</i>) see if a scalar contains a string, integer, or floating point number.   But you can still peek and poke these if you will.  See the section below.</dd>
</dl>
<div class="subsection">
<h2>Messing with Perl's Internals</h2> The following API uses parts of Perl's internals in the current implementation.  As such, they are efficient but may change.<dl>
<dt>
is_utf8(STRING [, CHECK])</dt>
<dd>
[INTERNAL] Tests whether the UTF8 flag is turned on in the STRING. If CHECK is true, also checks the data in STRING for being well-formed UTF-8.  Returns true if successful, false otherwise.<div style="height: 1.00em;">
&#160;</div>
As of perl 5.8.1, utf8 also has <i>utf8::is_utf8()</i>.</dd>
</dl>
<dl>
<dt>
_utf8_on(STRING)</dt>
<dd>
[INTERNAL] Turns on the UTF8 flag in STRING.  The data in STRING is  <b>not</b> checked for being well-formed UTF-8.  Do not use unless you  <b>know</b> that the STRING is well-formed UTF-8.  Returns the previous state of the UTF8 flag (so please don't treat the return value as indicating success or failure), or &quot;undef&quot; if STRING is not a string.<div style="height: 1.00em;">
&#160;</div>
This function does not work on tainted values.</dd>
</dl>
<dl>
<dt>
_utf8_off(STRING)</dt>
<dd>
[INTERNAL] Turns off the UTF8 flag in STRING.  Do not use frivolously. Returns the previous state of the UTF8 flag (so please don't treat the return value as indicating success or failure), or &quot;undef&quot; if STRING is not a string.<div style="height: 1.00em;">
&#160;</div>
This function does not work on tainted values.</dd>
</dl>
</div>
</div>
<div class="section">
<h1>UTF-8 vs. utf8 vs. UTF8</h1><br/>
  ....We now view strings not as sequences of bytes, but as sequences<br/>
  of numbers in the range 0 .. 2**32-1 (or in the case of 64-bit<br/>
  computers, 0 .. 2**64-1) -- Programming Perl, 3rd ed.<br/>
<div class="spacer">
</div>
That has been the perl's notion of UTF-8 but official UTF-8 is more strict; Its ranges is much narrower (0 .. 10FFFF), some sequences are not allowed (i.e. Those used in the surrogate pair, 0xFFFE, et al).<div class="spacer">
</div>
Now that is overruled by Larry Wall himself.<div class="spacer">
</div>
<br/>
  From: Larry Wall &lt;larry@wall.org&gt;<br/>
  Date: December 04, 2004 11:51:58 JST<br/>
  To: perl-unicode@perl.org<br/>
  Subject: Re: Make Encode.pm support the real UTF-8<br/>
  Message-Id: &lt;20041204025158.GA28754@wall.org&gt;<br/>
  <br/>
  On Fri, Dec 03, 2004 at 10:12:12PM +0000, Tim Bunce wrote:<br/>
  : I've no problem with 'utf8' being perl's unrestricted uft8 encoding,<br/>
  : but &quot;UTF-8&quot; is the name of the standard and should give the<br/>
  : corresponding behaviour.<br/>
  <br/>
  For what it's worth, that's how I've always kept them straight in my<br/>
  head.<br/>
  <br/>
  Also for what it's worth, Perl 6 will mostly default to strict but<br/>
  make it easy to switch back to lax.<br/>
  <br/>
  Larry<br/>
<div class="spacer">
</div>
Do you copy?  As of Perl 5.8.7, <b>UTF-8</b> means strict, official UTF-8 while  <b>utf8</b> means liberal, lax, version thereof.  And Encode version 2.10 or later thus groks the difference between &quot;UTF-8&quot; and C&quot;utf8&quot;.<div class="spacer">
</div>
<br/>
  encode(&quot;utf8&quot;,  &quot;\x{FFFF_FFFF}&quot;, 1); # okay<br/>
  encode(&quot;UTF-8&quot;, &quot;\x{FFFF_FFFF}&quot;, 1); # croaks<br/>
<div class="spacer">
</div>
&quot;UTF-8&quot; in Encode is actually a canonical name for &quot;utf-8-strict&quot;. Yes, the hyphen between &quot;UTF&quot; and &quot;8&quot; is important.  Without it Encode goes &quot;liberal&quot;<div class="spacer">
</div>
<br/>
  find_encoding(&quot;UTF-8&quot;)-&gt;name # is 'utf-8-strict'<br/>
  find_encoding(&quot;utf-8&quot;)-&gt;name # ditto. names are case insensitive<br/>
  find_encoding(&quot;utf_8&quot;)-&gt;name  # ditto. &quot;_&quot; are treated as &quot;-&quot;<br/>
  find_encoding(&quot;UTF8&quot;)-&gt;name  # is 'utf8'.<br/>
<div class="spacer">
</div>
The UTF8 flag is internally called UTF8, without a hyphen. It indicates whether a string is internally encoded as utf8, also without a hypen.</div>
<div class="section">
<h1>SEE ALSO</h1> Encode::Encoding, Encode::Supported, Encode::PerlIO, encoding, perlebcdic, &quot;open&quot; in perlfunc, perlunicode, perluniintro, perlunifaq, perlunitut utf8, the Perl Unicode Mailing List &lt;perl-unicode@perl.org&gt;</div>
<div class="section">
<h1>MAINTAINER</h1> This project was originated by Nick Ing-Simmons and later maintained by Dan Kogai &lt;dankogai@dan.co.jp&gt;.  See AUTHORS for a full list of people involved.  For any questions, use &lt;perl-unicode@perl.org&gt; so we can all share.<div class="spacer">
</div>
While Dan Kogai retains the copyright as a maintainer, the credit should go to all those involoved.  See AUTHORS for those submitted codes.</div>
<div class="section">
<h1>COPYRIGHT</h1> Copyright 2002-2006 Dan Kogai &lt;dankogai@dan.co.jp&gt;<div class="spacer">
</div>
This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-09-26</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

