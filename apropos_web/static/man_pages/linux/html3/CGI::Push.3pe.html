<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
CGI::Push(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
CGI::Push(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
CGI::Push(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> CGI::Push - Simple Interface to Server Push</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
    use CGI::Push qw(:standard);<br/>
<br/>
    do_push(-next_page=&gt;\&amp;next_page,<br/>
            -last_page=&gt;\&amp;last_page,<br/>
            -delay=&gt;0.5);<br/>
<br/>
    sub next_page {<br/>
        my($q,$counter) = @_;<br/>
        return undef if $counter &gt;= 10;<br/>
        return start_html('Test'),<br/>
               h1('Visible'),&quot;\n&quot;,<br/>
               &quot;This page has been called &quot;, strong($counter),&quot; times&quot;,<br/>
               end_html();<br/>
    }<br/>
<br/>
    sub last_page {<br/>
        my($q,$counter) = @_;<br/>
        return start_html('Done'),<br/>
               h1('Finished'),<br/>
               strong($counter - 1),' iterations.',<br/>
               end_html;<br/>
    }<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> CGI::Push is a subclass of the CGI object created by CGI.pm.  It is specialized for server push operations, which allow you to create animated pages whose content changes at regular intervals.<div class="spacer">
</div>
You provide CGI::Push with a pointer to a subroutine that will draw one page.  Every time your subroutine is called, it generates a new page.  The contents of the page will be transmitted to the browser in such a way that it will replace what was there beforehand.  The technique will work with HTML pages as well as with graphics files, allowing you to create animated GIFs.<div class="spacer">
</div>
Only Netscape Navigator supports server push.  Internet Explorer browsers do not.</div>
<div class="section">
<h1>USING CGI::Push</h1> CGI::Push adds one new method to the standard CGI suite,  <i>do_push()</i>. When you call this method, you pass it a reference to a subroutine that is responsible for drawing each new page, an interval delay, and an optional subroutine for drawing the last page.  Other optional parameters include most of those recognized by the CGI  <i>header()</i> method.<div class="spacer">
</div>
You may call <i>do_push()</i> in the object oriented manner or not, as you prefer:<div class="spacer">
</div>
<br/>
    use CGI::Push;<br/>
    $q = new CGI::Push;<br/>
    $q-&gt;do_push(-next_page=&gt;\&amp;draw_a_page);<br/>
<br/>
        -or-<br/>
<br/>
    use CGI::Push qw(:standard);<br/>
    do_push(-next_page=&gt;\&amp;draw_a_page);<br/>
<div class="spacer">
</div>
Parameters are as follows:<dl>
<dt>
-next_page</dt>
<dd>
<br/>
    do_push(-next_page=&gt;\&amp;my_draw_routine);<br/>
<div style="height: 1.00em;">
&#160;</div>
This required parameter points to a reference to a subroutine responsible for drawing each new page.  The subroutine should expect two parameters consisting of the CGI object and a counter indicating the number of times the subroutine has been called.  It should return the contents of the page as an  <b>array</b> of one or more items to print. It can return a false value (or an empty array) in order to abort the redrawing loop and print out the final page (if any)<div style="height: 1.00em;">
&#160;</div>
<br/>
    sub my_draw_routine {<br/>
        my($q,$counter) = @_;<br/>
        return undef if $counter &gt; 100;<br/>
        return start_html('testing'),<br/>
               h1('testing'),<br/>
               &quot;This page called $counter times&quot;;<br/>
    }<br/>
<div style="height: 1.00em;">
&#160;</div>
You are of course free to refer to create and use global variables within your draw routine in order to achieve special effects.</dd>
</dl>
<dl>
<dt>
-last_page</dt>
<dd>
This optional parameter points to a reference to the subroutine responsible for drawing the last page of the series.  It is called after the -next_page routine returns a false value.  The subroutine itself should have exactly the same calling conventions as the -next_page routine.</dd>
</dl>
<dl>
<dt>
-type</dt>
<dd>
This optional parameter indicates the content type of each page.  It defaults to &quot;text/html&quot;.  Normally the module assumes that each page is of a homogeneous MIME type.  However if you provide either of the magic values &quot;heterogeneous&quot; or &quot;dynamic&quot; (the latter provided for the convenience of those who hate long parameter names), you can specify the MIME type -- and other header fields -- on a per-page basis.  See &quot;heterogeneous pages&quot; for more details.</dd>
</dl>
<dl>
<dt>
-delay</dt>
<dd>
This indicates the delay, in seconds, between frames.  Smaller delays refresh the page faster.  Fractional values are allowed.<div style="height: 1.00em;">
&#160;</div>
<b>If not specified, -delay will default to 1 second</b></dd>
</dl>
<dl>
<dt>
-cookie, -target, -expires, -nph</dt>
<dd>
These have the same meaning as the like-named parameters in  <i>CGI::header()</i>.<div style="height: 1.00em;">
&#160;</div>
If not specified, -nph will default to 1 (as needed for many servers, see below).</dd>
</dl>
<div class="subsection">
<h2>Heterogeneous Pages</h2> Ordinarily all pages displayed by CGI::Push share a common MIME type. However by providing a value of &quot;heterogeneous&quot; or &quot;dynamic&quot; in the  <i>do_push()</i> -type parameter, you can specify the MIME type of each page on a case-by-case basis.<div class="spacer">
</div>
If you use this option, you will be responsible for producing the HTTP header for each page.  Simply modify your draw routine to look like this:<div class="spacer">
</div>
<br/>
    sub my_draw_routine {<br/>
        my($q,$counter) = @_;<br/>
        return header('text/html'),   # note we're producing the header here<br/>
               start_html('testing'),<br/>
               h1('testing'),<br/>
               &quot;This page called $counter times&quot;;<br/>
    }<br/>
<div class="spacer">
</div>
You can add any header fields that you like, but some (cookies and status fields included) may not be interpreted by the browser.  One interesting effect is to display a series of pages, then, after the last page, to redirect the browser to a new URL.  Because  <i>redirect()</i> does b&lt;not&gt; work, the easiest way is with a -refresh header field, as shown below:<div class="spacer">
</div>
<br/>
    sub my_draw_routine {<br/>
        my($q,$counter) = @_;<br/>
        return undef if $counter &gt; 10;<br/>
        return header('text/html'),   # note we're producing the header here<br/>
               start_html('testing'),<br/>
               h1('testing'),<br/>
               &quot;This page called $counter times&quot;;<br/>
    }<br/>
<br/>
    sub my_last_page {<br/>
        return header(-refresh=&gt;'5; URL=http://somewhere.else/finished.html',<br/>
                      -type=&gt;'text/html'),<br/>
               start_html('Moved'),<br/>
               h1('This is the last page'),<br/>
               'Goodbye!'<br/>
               hr,<br/>
               end_html; <br/>
    }<br/>
</div>
<div class="subsection">
<h2>Changing the Page Delay on the Fly</h2> If you would like to control the delay between pages on a page-by-page basis, call  <i>push_delay()</i> from within your draw routine.  <i>push_delay()</i> takes a single numeric argument representing the number of seconds you wish to delay after the current page is displayed and before displaying the next one.  The delay may be fractional.  Without parameters,  <i>push_delay()</i> just returns the current delay.</div>
</div>
<div class="section">
<h1>INSTALLING CGI::Push SCRIPTS</h1> Server push scripts must be installed as no-parsed-header (NPH) scripts in order to work correctly on many servers.  On Unix systems, this is most often accomplished by prefixing the script's name with &quot;nph-&quot;. Recognition of NPH scripts happens automatically with WebSTAR and Microsoft IIS.  Users of other servers should see their documentation for help.<div class="spacer">
</div>
Apache web server from version 1.3b2 on does not need server push scripts installed as NPH scripts: the -nph parameter to  <i>do_push()</i> may be set to a false value to disable the extra headers needed by an NPH script.</div>
<div class="section">
<h1>AUTHOR INFORMATION</h1> Copyright 1995-1998, Lincoln D. Stein.  All rights reserved.<div class="spacer">
</div>
This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.<div class="spacer">
</div>
Address bug reports and comments to: lstein@cshl.org</div>
<div class="section">
<h1>BUGS</h1> This section intentionally left blank.</div>
<div class="section">
<h1>SEE ALSO</h1> CGI::Carp, CGI</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-09-19</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

