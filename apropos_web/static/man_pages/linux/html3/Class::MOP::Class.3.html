<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Class::MOP::Class(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Class::MOP::Class(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
Class::MOP::Class(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Class::MOP::Class - Class Meta Object</div>
<div class="section">
<h1>VERSION</h1> version 2.0401</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
  # assuming that class Foo<br/>
  # has been defined, you can<br/>
<br/>
  # use this for introspection ...<br/>
<br/>
  # add a method to Foo ...<br/>
  Foo-&gt;meta-&gt;add_method( 'bar' =&gt; sub {...} )<br/>
<br/>
  # get a list of all the classes searched<br/>
  # the method dispatcher in the correct order<br/>
  Foo-&gt;meta-&gt;class_precedence_list()<br/>
<br/>
  # remove a method from Foo<br/>
  Foo-&gt;meta-&gt;remove_method('bar');<br/>
<br/>
  # or use this to actually create classes ...<br/>
<br/>
  Class::MOP::Class-&gt;create(<br/>
      'Bar' =&gt; (<br/>
          version      =&gt; '0.01',<br/>
          superclasses =&gt; ['Foo'],<br/>
          attributes   =&gt; [<br/>
              Class::MOP::Attribute-&gt;new('$bar'),<br/>
              Class::MOP::Attribute-&gt;new('$baz'),<br/>
          ],<br/>
          methods =&gt; {<br/>
              calculate_bar =&gt; sub {...},<br/>
              construct_baz =&gt; sub {...}<br/>
          }<br/>
      )<br/>
  );<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> The Class Protocol is the largest and most complex part of the Class::MOP meta-object protocol. It controls the introspection and manipulation of Perl 5 classes, and it can create them as well. The best way to understand what this module can do is to read the documentation for each of its methods.</div>
<div class="section">
<h1>INHERITANCE</h1> &quot;Class::MOP::Class&quot; is a subclass of Class::MOP::Module.</div>
<div class="section">
<h1>METHODS</h1><div class="subsection">
<h2>Class construction</h2> These methods all create new &quot;Class::MOP::Class&quot; objects. These objects can represent existing classes or they can be used to create new classes from scratch.<div class="spacer">
</div>
The metaclass object for a given class is a singleton. If you attempt to create a metaclass for the same class twice, you will just get the existing object.<dl>
<dt>
<b>Class::MOP::Class-&gt;create($package_name, </b><b>%options</b><b>)</b></dt>
<dd>
This method creates a new &quot;Class::MOP::Class&quot; object with the given package name. It accepts a number of options:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
&#8226;</dt>
<dd>
version<div style="height: 1.00em;">
&#160;</div>
An optional version number for the newly created package.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
authority<div style="height: 1.00em;">
&#160;</div>
An optional authority for the newly created package.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
superclasses<div style="height: 1.00em;">
&#160;</div>
An optional array reference of superclass names.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
methods<div style="height: 1.00em;">
&#160;</div>
An optional hash reference of methods for the class. The keys of the hash reference are method names and values are subroutine references.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
attributes<div style="height: 1.00em;">
&#160;</div>
An optional array reference of Class::MOP::Attribute objects.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
meta_name<div style="height: 1.00em;">
&#160;</div>
Specifies the name to install the &quot;meta&quot; method for this class under. If it is not passed, &quot;meta&quot; is assumed, and if &quot;undef&quot; is explicitly given, no meta method will be installed.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
weaken<div style="height: 1.00em;">
&#160;</div>
If true, the metaclass that is stored in the global cache will be a weak reference.<div style="height: 1.00em;">
&#160;</div>
Classes created in this way are destroyed once the metaclass they are attached to goes out of scope, and will be removed from Perl's internal symbol table.<div style="height: 1.00em;">
&#160;</div>
All instances of a class with a weakened metaclass keep a special reference to the metaclass object, which prevents the metaclass from going out of scope while any instances exist.<div style="height: 1.00em;">
&#160;</div>
This only works if the instance is based on a hash reference, however.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
</div>
<dl>
<dt>
<b>Class::MOP::Class-&gt;create_anon_class(%options)</b></dt>
<dd>
This method works just like &quot;Class::MOP::Class-&gt;create&quot; but it creates an &quot;anonymous&quot; class. In fact, the class does have a name, but that name is a unique name generated internally by this module.<div style="height: 1.00em;">
&#160;</div>
It accepts the same &quot;superclasses&quot;, &quot;methods&quot;, and &quot;attributes&quot; parameters that &quot;create&quot; accepts.<div style="height: 1.00em;">
&#160;</div>
Anonymous classes default to &quot;weaken =&gt; 1&quot;, although this can be overridden.</dd>
</dl>
<dl>
<dt>
<b>Class::MOP::Class-&gt;initialize($package_name, </b><b>%options</b><b>)</b></dt>
<dd>
This method will initialize a &quot;Class::MOP::Class&quot; object for the named package. Unlike &quot;create&quot;, this method  <i>will not</i> create a new class.<div style="height: 1.00em;">
&#160;</div>
The purpose of this method is to retrieve a &quot;Class::MOP::Class&quot; object for introspecting an existing class.<div style="height: 1.00em;">
&#160;</div>
If an existing &quot;Class::MOP::Class&quot; object exists for the named package, it will be returned, and any options provided will be ignored!<div style="height: 1.00em;">
&#160;</div>
If the object does not yet exist, it will be created.<div style="height: 1.00em;">
&#160;</div>
The valid options that can be passed to this method are &quot;attribute_metaclass&quot;, &quot;method_metaclass&quot;, &quot;wrapped_method_metaclass&quot;, and &quot;instance_metaclass&quot;. These are all optional, and default to the appropriate class in the &quot;Class::MOP&quot; distribution.</dd>
</dl>
</div>
<div class="subsection">
<h2>Object instance construction and cloning</h2> These methods are all related to creating and/or cloning object instances.<dl>
<dt>
<b></b><b>$metaclass</b><b>-&gt;clone_object($instance, </b><b><i>%params</i></b><b>)</b></dt>
<dd>
This method clones an existing object instance. Any parameters you provide are will override existing attribute values in the object.<div style="height: 1.00em;">
&#160;</div>
This is a convenience method for cloning an object instance, then blessing it into the appropriate package.<div style="height: 1.00em;">
&#160;</div>
You could implement a clone method in your class, using this method:<div style="height: 1.00em;">
&#160;</div>
<br/>
  sub clone {<br/>
      my ($self, %params) = @_;<br/>
      $self-&gt;meta-&gt;clone_object($self, %params);<br/>
  }<br/>
</dd>
</dl>
<dl>
<dt>
<b></b><b>$metaclass</b><b>-&gt;rebless_instance($instance, </b><b><i>%params</i></b><b>)</b></dt>
<dd>
This method changes the class of $instance to the metaclass's class.<div style="height: 1.00em;">
&#160;</div>
You can only rebless an instance into a subclass of its current class. If you pass any additional parameters, these will be treated like constructor parameters and used to initialize the object's attributes. Any existing attributes that are already set will be overwritten.<div style="height: 1.00em;">
&#160;</div>
Before reblessing the instance, this method will call &quot;rebless_instance_away&quot; on the instance's current metaclass. This method will be passed the instance, the new metaclass, and any parameters specified to &quot;rebless_instance&quot;. By default, &quot;rebless_instance_away&quot; does nothing; it is merely a hook.</dd>
</dl>
<dl>
<dt>
<b></b><b>$metaclass</b><b>-&gt;rebless_instance_back($instance)</b></dt>
<dd>
Does the same thing as &quot;rebless_instance&quot;, except that you can only rebless an instance into one of its superclasses. Any attributes that do not exist in the superclass will be deinitialized.<div style="height: 1.00em;">
&#160;</div>
This is a much more dangerous operation than &quot;rebless_instance&quot;, especially when multiple inheritance is involved, so use this carefully!</dd>
</dl>
<dl>
<dt>
<b></b><b>$metaclass</b><b>-&gt;new_object(%params)</b></dt>
<dd>
This method is used to create a new object of the metaclass's class. Any parameters you provide are used to initialize the instance's attributes. A special &quot;__INSTANCE__&quot; key can be passed to provide an already generated instance, rather than having Class::MOP generate it for you. This is mostly useful for using Class::MOP with foreign classes which generate instances using their own constructors.</dd>
</dl>
<dl>
<dt>
<b></b><b>$metaclass</b><b>-&gt;instance_metaclass</b></dt>
<dd>
Returns the class name of the instance metaclass. See Class::MOP::Instance for more information on the instance metaclass.</dd>
</dl>
<dl>
<dt>
<b></b><b>$metaclass</b><b>-&gt;get_meta_instance</b></dt>
<dd>
Returns an instance of the &quot;instance_metaclass&quot; to be used in the construction of a new instance of the class.</dd>
</dl>
</div>
<div class="subsection">
<h2>Informational predicates</h2> These are a few predicate methods for asking information about the class itself.<dl>
<dt>
<b></b><b>$metaclass</b><b>-&gt;is_anon_class</b></dt>
<dd>
This returns true if the class was created by calling &quot;Class::MOP::Class-&gt;create_anon_class&quot;.</dd>
</dl>
<dl>
<dt>
<b></b><b>$metaclass</b><b>-&gt;is_mutable</b></dt>
<dd>
This returns true if the class is still mutable.</dd>
</dl>
<dl>
<dt>
<b></b><b>$metaclass</b><b>-&gt;is_immutable</b></dt>
<dd>
This returns true if the class has been made immutable.</dd>
</dl>
<dl>
<dt>
<b></b><b>$metaclass</b><b>-&gt;is_pristine</b></dt>
<dd>
A class is <i>not</i> pristine if it has non-inherited attributes or if it has any generated methods.</dd>
</dl>
</div>
<div class="subsection">
<h2>Inheritance Relationships</h2><dl>
<dt>
<b></b><b>$metaclass</b><b>-&gt;superclasses(@superclasses)</b></dt>
<dd>
This is a read-write accessor which represents the superclass relationships of the metaclass's class.<div style="height: 1.00em;">
&#160;</div>
This is basically sugar around getting and setting @ISA.</dd>
</dl>
<dl>
<dt>
<b></b><b>$metaclass</b><b>-&gt;class_precedence_list</b></dt>
<dd>
This returns a list of all of the class's ancestor classes. The classes are returned in method dispatch order.</dd>
</dl>
<dl>
<dt>
<b></b><b>$metaclass</b><b>-&gt;linearized_isa</b></dt>
<dd>
This returns a list based on &quot;class_precedence_list&quot; but with all duplicates removed.</dd>
</dl>
<dl>
<dt>
<b></b><b>$metaclass</b><b>-&gt;subclasses</b></dt>
<dd>
This returns a list of all subclasses for this class, even indirect subclasses.</dd>
</dl>
<dl>
<dt>
<b></b><b>$metaclass</b><b>-&gt;direct_subclasses</b></dt>
<dd>
This returns a list of immediate subclasses for this class, which does not include indirect subclasses.</dd>
</dl>
</div>
<div class="subsection">
<h2>Method introspection and creation</h2> These methods allow you to introspect a class's methods, as well as add, remove, or change methods.<div class="spacer">
</div>
Determining what is truly a method in a Perl 5 class requires some heuristics (aka guessing).<div class="spacer">
</div>
Methods defined outside the package with a fully qualified name (&quot;sub Package::name { ... }&quot;) will be included. Similarly, methods named with a fully qualified name using Sub::Name are also included.<div class="spacer">
</div>
However, we attempt to ignore imported functions.<div class="spacer">
</div>
Ultimately, we are using heuristics to determine what truly is a method in a class, and these heuristics may get the wrong answer in some edge cases. However, for most &quot;normal&quot; cases the heuristics work correctly.<dl>
<dt>
<b></b><b>$metaclass</b><b>-&gt;get_method($method_name)</b></dt>
<dd>
This will return a Class::MOP::Method for the specified $method_name. If the class does not have the specified method, it returns &quot;undef&quot;</dd>
</dl>
<dl>
<dt>
<b></b><b>$metaclass</b><b>-&gt;has_method($method_name)</b></dt>
<dd>
Returns a boolean indicating whether or not the class defines the named method. It does not include methods inherited from parent classes.</dd>
</dl>
<dl>
<dt>
<b></b><b>$metaclass</b><b>-&gt;get_method_list</b></dt>
<dd>
This will return a list of method <i>names</i> for all methods defined in this class.</dd>
</dl>
<dl>
<dt>
<b></b><b>$metaclass</b><b>-&gt;add_method($method_name, </b><b><i>$method</i></b><b>)</b></dt>
<dd>
This method takes a method name and a subroutine reference, and adds the method to the class.<div style="height: 1.00em;">
&#160;</div>
The subroutine reference can be a Class::MOP::Method, and you are strongly encouraged to pass a meta method object instead of a code reference. If you do so, that object gets stored as part of the class's method map directly. If not, the meta information will have to be recreated later, and may be incorrect.<div style="height: 1.00em;">
&#160;</div>
If you provide a method object, this method will clone that object if the object's package name does not match the class name. This lets us track the original source of any methods added from other classes (notably Moose roles).</dd>
</dl>
<dl>
<dt>
<b></b><b>$metaclass</b><b>-&gt;remove_method($method_name)</b></dt>
<dd>
Remove the named method from the class. This method returns the Class::MOP::Method object for the method.</dd>
</dl>
<dl>
<dt>
<b></b><b>$metaclass</b><b>-&gt;method_metaclass</b></dt>
<dd>
Returns the class name of the method metaclass, see Class::MOP::Method for more information on the method metaclass.</dd>
</dl>
<dl>
<dt>
<b></b><b>$metaclass</b><b>-&gt;wrapped_method_metaclass</b></dt>
<dd>
Returns the class name of the wrapped method metaclass, see Class::MOP::Method::Wrapped for more information on the wrapped method metaclass.</dd>
</dl>
<dl>
<dt>
<b></b><b>$metaclass</b><b>-&gt;get_all_methods</b></dt>
<dd>
This will traverse the inheritance hierarchy and return a list of all the Class::MOP::Method objects for this class and its parents.</dd>
</dl>
<dl>
<dt>
<b></b><b>$metaclass</b><b>-&gt;find_method_by_name($method_name)</b></dt>
<dd>
This will return a Class::MOP::Method for the specified $method_name. If the class does not have the specified method, it returns &quot;undef&quot;<div style="height: 1.00em;">
&#160;</div>
Unlike &quot;get_method&quot;, this method <i>will</i> look for the named method in superclasses.</dd>
</dl>
<dl>
<dt>
<b></b><b>$metaclass</b><b>-&gt;get_all_method_names</b></dt>
<dd>
This will return a list of method <i>names</i> for all of this class's methods, including inherited methods.</dd>
</dl>
<dl>
<dt>
<b></b><b>$metaclass</b><b>-&gt;find_all_methods_by_name($method_name)</b></dt>
<dd>
This method looks for the named method in the class and all of its parents. It returns every matching method it finds in the inheritance tree, so it returns a list of methods.<div style="height: 1.00em;">
&#160;</div>
Each method is returned as a hash reference with three keys. The keys are &quot;name&quot;, &quot;class&quot;, and &quot;code&quot;. The &quot;code&quot; key has a Class::MOP::Method object as its value.<div style="height: 1.00em;">
&#160;</div>
The list of methods is distinct.</dd>
</dl>
<dl>
<dt>
<b></b><b>$metaclass</b><b>-&gt;find_next_method_by_name($method_name)</b></dt>
<dd>
This method returns the first method in any superclass matching the given name. It is effectively the method that &quot;SUPER::$method_name&quot; would dispatch to.</dd>
</dl>
</div>
<div class="subsection">
<h2>Attribute introspection and creation</h2> Because Perl 5 does not have a core concept of attributes in classes, we can only return information about attributes which have been added via this class's methods. We cannot discover information about attributes which are defined in terms of &quot;regular&quot; Perl 5 methods.<dl>
<dt>
<b></b><b>$metaclass</b><b>-&gt;get_attribute($attribute_name)</b></dt>
<dd>
This will return a Class::MOP::Attribute for the specified $attribute_name. If the class does not have the specified attribute, it returns &quot;undef&quot;.<div style="height: 1.00em;">
&#160;</div>
NOTE that get_attribute does not search superclasses, for that you need to use &quot;find_attribute_by_name&quot;.</dd>
</dl>
<dl>
<dt>
<b></b><b>$metaclass</b><b>-&gt;has_attribute($attribute_name)</b></dt>
<dd>
Returns a boolean indicating whether or not the class defines the named attribute. It does not include attributes inherited from parent classes.</dd>
</dl>
<dl>
<dt>
<b></b><b>$metaclass</b><b>-&gt;get_attribute_list</b></dt>
<dd>
This will return a list of attributes <i>names</i> for all attributes defined in this class.  Note that this operates on the current class only, it does not traverse the inheritance hierarchy.</dd>
</dl>
<dl>
<dt>
<b></b><b>$metaclass</b><b>-&gt;get_all_attributes</b></dt>
<dd>
This will traverse the inheritance hierarchy and return a list of all the Class::MOP::Attribute objects for this class and its parents.</dd>
</dl>
<dl>
<dt>
<b></b><b>$metaclass</b><b>-&gt;find_attribute_by_name($attribute_name)</b></dt>
<dd>
This will return a Class::MOP::Attribute for the specified $attribute_name. If the class does not have the specified attribute, it returns &quot;undef&quot;.<div style="height: 1.00em;">
&#160;</div>
Unlike &quot;get_attribute&quot;, this attribute <i>will</i> look for the named attribute in superclasses.</dd>
</dl>
<dl>
<dt>
<b></b><b>$metaclass</b><b>-&gt;add_attribute(...)</b></dt>
<dd>
This method accepts either an existing Class::MOP::Attribute object or parameters suitable for passing to that class's &quot;new&quot; method.<div style="height: 1.00em;">
&#160;</div>
The attribute provided will be added to the class.<div style="height: 1.00em;">
&#160;</div>
Any accessor methods defined by the attribute will be added to the class when the attribute is added.<div style="height: 1.00em;">
&#160;</div>
If an attribute of the same name already exists, the old attribute will be removed first.</dd>
</dl>
<dl>
<dt>
<b></b><b>$metaclass</b><b>-&gt;remove_attribute($attribute_name)</b></dt>
<dd>
This will remove the named attribute from the class, and Class::MOP::Attribute object.<div style="height: 1.00em;">
&#160;</div>
Removing an attribute also removes any accessor methods defined by the attribute.<div style="height: 1.00em;">
&#160;</div>
However, note that removing an attribute will only affect <i>future</i> object instances created for this class, not existing instances.</dd>
</dl>
<dl>
<dt>
<b></b><b>$metaclass</b><b>-&gt;attribute_metaclass</b></dt>
<dd>
Returns the class name of the attribute metaclass for this class. By default, this is Class::MOP::Attribute.</dd>
</dl>
</div>
<div class="subsection">
<h2>Class Immutability</h2> Making a class immutable &quot;freezes&quot; the class definition. You can no longer call methods which alter the class, such as adding or removing methods or attributes.<div class="spacer">
</div>
Making a class immutable lets us optimize the class by inlining some methods, and also allows us to optimize some methods on the metaclass object itself.<div class="spacer">
</div>
After immutabilization, the metaclass object will cache most informational methods that returns information about methods or attributes. Methods which would alter the class, such as &quot;add_attribute&quot; and &quot;add_method&quot;, will throw an error on an immutable metaclass object.<div class="spacer">
</div>
The immutabilization system in Moose takes much greater advantage of the inlining features than Class::MOP itself does.<dl>
<dt>
<b></b><b>$metaclass</b><b>-&gt;make_immutable(%options)</b></dt>
<dd>
This method will create an immutable transformer and use it to make the class and its metaclass object immutable, and returns true (you should not rely on the details of this value apart from its truth).<div style="height: 1.00em;">
&#160;</div>
This method accepts the following options:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
&#8226;</dt>
<dd>
inline_accessors</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
inline_constructor</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
inline_destructor<div style="height: 1.00em;">
&#160;</div>
These are all booleans indicating whether the specified method(s) should be inlined.<div style="height: 1.00em;">
&#160;</div>
By default, accessors and the constructor are inlined, but not the destructor.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
immutable_trait<div style="height: 1.00em;">
&#160;</div>
The name of a class which will be used as a parent class for the metaclass object being made immutable. This &quot;trait&quot; implements the post-immutability functionality of the metaclass (but not the transformation itself).<div style="height: 1.00em;">
&#160;</div>
This defaults to Class::MOP::Class::Immutable::Trait.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
constructor_name<div style="height: 1.00em;">
&#160;</div>
This is the constructor method name. This defaults to &quot;new&quot;.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
constructor_class<div style="height: 1.00em;">
&#160;</div>
The name of the method metaclass for constructors. It will be used to generate the inlined constructor. This defaults to &quot;Class::MOP::Method::Constructor&quot;.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
replace_constructor<div style="height: 1.00em;">
&#160;</div>
This is a boolean indicating whether an existing constructor should be replaced when inlining a constructor. This defaults to false.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
destructor_class<div style="height: 1.00em;">
&#160;</div>
The name of the method metaclass for destructors. It will be used to generate the inlined destructor. This defaults to &quot;Class::MOP::Method::Denstructor&quot;.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
replace_destructor<div style="height: 1.00em;">
&#160;</div>
This is a boolean indicating whether an existing destructor should be replaced when inlining a destructor. This defaults to false.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
</div>
<dl>
<dt>
<b></b><b>$metaclass</b><b>-&gt;immutable_options</b></dt>
<dd>
Returns a hash of the options used when making the class immutable, including both defaults and anything supplied by the user in the call to &quot;$metaclass-&gt;make_immutable&quot;. This is useful if you need to temporarily make a class mutable and then restore immutability as it was before.</dd>
</dl>
<dl>
<dt>
<b></b><b>$metaclass</b><b>-&gt;make_mutable</b></dt>
<dd>
Calling this method reverse the immutabilization transformation.</dd>
</dl>
</div>
<div class="subsection">
<h2>Method Modifiers</h2> Method modifiers are hooks which allow a method to be wrapped with  <i>before</i>, <i>after</i> and <i>around</i> method modifiers. Every time a method is called, its modifiers are also called.<div class="spacer">
</div>
A class can modify its own methods, as well as methods defined in parent classes.<div class="spacer">
</div>
<i>How method modifiers work?</i><div class="spacer">
</div>
Method modifiers work by wrapping the original method and then replacing it in the class's symbol table. The wrappers will handle calling all the modifiers in the appropriate order and preserving the calling context for the original method.<div class="spacer">
</div>
The return values of &quot;before&quot; and &quot;after&quot; modifiers are ignored. This is because their purpose is  <b>not</b> to filter the input and output of the primary method (this is done with an  <i>around</i> modifier).<div class="spacer">
</div>
This may seem like an odd restriction to some, but doing this allows for simple code to be added at the beginning or end of a method call without altering the function of the wrapped method or placing any extra responsibility on the code of the modifier.<div class="spacer">
</div>
Of course if you have more complex needs, you can use the &quot;around&quot; modifier which allows you to change both the parameters passed to the wrapped method, as well as its return value.<div class="spacer">
</div>
Before and around modifiers are called in last-defined-first-called order, while after modifiers are called in first-defined-first-called order. So the call tree might looks something like this:<div class="spacer">
</div>
<br/>
  before 2<br/>
   before 1<br/>
    around 2<br/>
     around 1<br/>
      primary<br/>
     around 1<br/>
    around 2<br/>
   after 1<br/>
  after 2<br/>
<div class="spacer">
</div>
<i>What is the performance impact?</i><div class="spacer">
</div>
Of course there is a performance cost associated with method modifiers, but we have made every effort to make that cost directly proportional to the number of modifier features you use.<div class="spacer">
</div>
The wrapping method does its best to <b>only</b> do as much work as it absolutely needs to. In order to do this we have moved some of the performance costs to set-up time, where they are easier to amortize.<div class="spacer">
</div>
All this said, our benchmarks have indicated the following:<div class="spacer">
</div>
<br/>
  simple wrapper with no modifiers             100% slower<br/>
  simple wrapper with simple before modifier   400% slower<br/>
  simple wrapper with simple after modifier    450% slower<br/>
  simple wrapper with simple around modifier   500-550% slower<br/>
  simple wrapper with all 3 modifiers          1100% slower<br/>
<div class="spacer">
</div>
These numbers may seem daunting, but you must remember, every feature comes with some cost. To put things in perspective, just doing a simple &quot;AUTOLOAD&quot; which does nothing but extract the name of the method called and return it costs about 400% over a normal method call.<dl>
<dt>
<b></b><b>$metaclass</b><b>-&gt;add_before_method_modifier($method_name, </b><b><i>$code</i></b><b>)</b></dt>
<dd>
This wraps the specified method with the supplied subroutine reference. The modifier will be called as a method itself, and will receive the same arguments as are passed to the method.<div style="height: 1.00em;">
&#160;</div>
When the modifier exits, the wrapped method will be called.<div style="height: 1.00em;">
&#160;</div>
The return value of the modifier will be ignored.</dd>
</dl>
<dl>
<dt>
<b></b><b>$metaclass</b><b>-&gt;add_after_method_modifier($method_name, </b><b><i>$code</i></b><b>)</b></dt>
<dd>
This wraps the specified method with the supplied subroutine reference. The modifier will be called as a method itself, and will receive the same arguments as are passed to the method.<div style="height: 1.00em;">
&#160;</div>
When the wrapped methods exits, the modifier will be called.<div style="height: 1.00em;">
&#160;</div>
The return value of the modifier will be ignored.</dd>
</dl>
<dl>
<dt>
<b></b><b>$metaclass</b><b>-&gt;add_around_method_modifier($method_name, </b><b><i>$code</i></b><b>)</b></dt>
<dd>
This wraps the specified method with the supplied subroutine reference.<div style="height: 1.00em;">
&#160;</div>
The first argument passed to the modifier will be a subroutine reference to the wrapped method. The second argument is the object, and after that come any arguments passed when the method is called.<div style="height: 1.00em;">
&#160;</div>
The around modifier can choose to call the original method, as well as what arguments to pass if it does so.<div style="height: 1.00em;">
&#160;</div>
The return value of the modifier is what will be seen by the caller.</dd>
</dl>
</div>
<div class="subsection">
<h2>Introspection</h2><dl>
<dt>
<b>Class::MOP::Class-&gt;meta</b></dt>
<dd>
This will return a Class::MOP::Class instance for this class.<div style="height: 1.00em;">
&#160;</div>
It should also be noted that Class::MOP will actually bootstrap this module by installing a number of attribute meta-objects into its metaclass.</dd>
</dl>
</div>
</div>
<div class="section">
<h1>AUTHOR</h1> Moose is maintained by the Moose Cabal, along with the help of many contributors. See &quot;CABAL&quot; in Moose and &quot;CONTRIBUTORS&quot; in Moose for details.</div>
<div class="section">
<h1>COPYRIGHT AND LICENSE</h1> This software is copyright (c) 2011 by Infinity Interactive, Inc..<div class="spacer">
</div>
This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5 programming language system itself.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-11-17</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

