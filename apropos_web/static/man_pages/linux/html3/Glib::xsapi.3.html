<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Glib::xsapi(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Glib::xsapi(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
Glib::xsapi(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Glib::xsapi - internal API reference for GPerl.</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
 #include &lt;gperl.h&gt;<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> This is the binding developer's API reference for GPerl, automatically generated from the xs source files.  This header defines the public interface for use when creating new Perl language bindings for GLib-based C libraries.<div class="spacer">
</div>
gperl.h includes for you all the headers needed for writing XSUBs (EXTERN.h, perl.h, and XSUB.h), as well as all of GLib (via glib-object.h).</div>
<div class="section">
<h1>API</h1><div class="subsection">
<h2>Miscellaneous</h2> Various useful utilities defined in Glib.xs.<dl>
<dt>
GPERL_CALL_BOOT(name)</dt>
<dd>
call the boot code of a module by symbol rather than by name.<div style="height: 1.00em;">
&#160;</div>
in a perl extension which uses several xs files but only one pm, you need to bootstrap the other xs files in order to get their functions exported to perl.  if the file has MODULE = Foo::Bar, the boot symbol would be boot_Foo__Bar.</dd>
</dl>
<dl>
<dt>
void _gperl_call_XS (pTHX_ void (*subaddr) (pTHX_ CV *), CV * cv, SV ** mark);</dt>
<dd>
never use this function directly.  see &quot;GPERL_CALL_BOOT&quot;.<div style="height: 1.00em;">
&#160;</div>
for the curious, this calls a perl sub by function pointer rather than by name; call_sv requires that the xsub already be registered, but we need this to call a function which will register xsubs.  this is an evil hack and should not be used outside of the GPERL_CALL_BOOT macro. it's implemented as a function to avoid code size bloat, and exported so that extension modules can pull the same trick.</dd>
</dl>
<dl>
<dt>
gpointer gperl_alloc_temp (int nbytes)</dt>
<dd>
Allocate and return a pointer to an <i>nbytes</i>-long, zero-initialized, temporary buffer that will be reaped at the next garbage collection sweep. This is handy for allocating things that need to be alloc'ed before a croak (since croak doesn't return and give you the chance to free them).  The trick is that the memory is allocated in a mortal perl scalar.  See the perl online manual for notes on using this technique.<div style="height: 1.00em;">
&#160;</div>
Do <b>not</b> under any circumstances attempt to call <i>g_free()</i>, <i>free()</i>, or any other deallocator on this pointer, or you will crash the interpreter.</dd>
</dl>
<dl>
<dt>
gchar *gperl_filename_from_sv (SV *sv)</dt>
<dd>
Return a localized version of the filename in the sv, using g_filename_from_utf8 (and consequently this function might croak). The memory is allocated using gperl_alloc_temp.</dd>
</dl>
<dl>
<dt>
SV *gperl_sv_from_filename (const gchar *filename)</dt>
<dd>
Convert the filename into an utf8 string as used by gtk/glib and perl.</dd>
</dl>
<dl>
<dt>
gboolean gperl_str_eq (const char * a, const char * b);</dt>
<dd>
Compare a pair of ascii strings, considering '-' and '_' to be equivalent. Used for things like enum value nicknames and signal names.</dd>
</dl>
<dl>
<dt>
guint gperl_str_hash (gconstpointer key)</dt>
<dd>
Like <i>g_str_hash()</i>, but considers '-' and '_' to be equivalent.</dd>
</dl>
<dl>
<dt>
GPerlArgv * gperl_argv_new ()</dt>
<dd>
Creates a new Perl argv object whose members can then be passed to functions that request argc and argv style arguments.<div style="height: 1.00em;">
&#160;</div>
If the called function(s) modified argv, you can call gperl_argv_update to update Perl's @ARGV in the same way.<div style="height: 1.00em;">
&#160;</div>
Remember to call gperl_argv_free when you're done.</dd>
</dl>
<dl>
<dt>
void gperl_argv_update (GPerlArgv *pargv)</dt>
<dd>
Updates @ARGV to resemble the stored argv array.</dd>
</dl>
<dl>
<dt>
void gperl_argv_free (GPerlArgv *pargv)</dt>
<dd>
Frees any resources associated with <i>pargv</i>.</dd>
</dl>
<dl>
<dt>
char * gperl_format_variable_for_output (SV * sv)</dt>
<dd>
Formats the variable stored in <i>sv</i> for output in error messages.  Like  <i>SvPV_nolen()</i>, but ellipsizes real strings (i.e., not stringified references) at 20 chars to trim things down for error messages.</dd>
</dl>
<dl>
<dt>
gboolean gperl_sv_is_defined (SV *sv)</dt>
<dd>
Checks the SV <i>sv</i> for definedness just like Perl's <i></i><i>defined()</i><i></i> would do. Most importantly, it correctly handles &quot;magical&quot; SVs, unlike bare  <i>SvOK</i>. It's also NULL-safe.</dd>
</dl>
<dl>
<dt>
void gperl_hv_take_sv (HV *hv, const char *key, size_t key_length, SV *sv)</dt>
<dd>
Tries to store <i>sv</i> in <i>hv</i>.  Decreases <i>sv</i>'s reference count if something goes wrong.</dd>
</dl>
</div>
<div class="subsection">
<h2>GError Exception Objects</h2> GError is a facility for propagating run-time error / exception information around in C, which is a language without native support for exceptions. GError uses a simple error code, usually defined as an enum.  Since the enums will overlap, GError includes the GQuark corresponding to a particular error &quot;domain&quot; to tell you which error codes will be used.  There's also a string containing a specific error message.  The strings are arbitrary, and may be translated, but the domains and codes are definite.<div class="spacer">
</div>
Perl has native support for exceptions, using &quot;eval&quot; as &quot;try&quot;, &quot;croak&quot; or &quot;die&quot; as &quot;throw&quot;, and &quot;if ($@)&quot; as &quot;catch&quot;.  $@ may, in fact, be any scalar, including blessed objects.<div class="spacer">
</div>
So, GPerl maps GLib's GError to Perl exceptions.<div class="spacer">
</div>
Since, as we described above, error messages are not guaranteed to be unique everywhere, we need to support the use of the error domains and codes. The obvious choice here is to use exception objects; however, to support blessed exception objects, we must perform a little bit of black magic in the bindings.   There is no built-in association between an error domain quark and the GType of the corresponding error code enumeration, so the bindings supply both of these when specifying the name of the package into which to bless exceptions of this domain.  All GError-based exceptions derive from Glib::Error, of course, and this base class provides all of the functionality, including stringification.<div class="spacer">
</div>
All you'll really ever need to do is register error domains with &quot;gperl_register_error_domain&quot;, and throw errors with &quot;gperl_croak_gerror&quot;.<dl>
<dt>
void gperl_register_error_domain (GQuark domain, GType error_enum, const char * package)</dt>
<dd>
Tell the bindings to bless GErrors with error-&gt;domain == <i>domain</i> into  <i>package</i>, and use <i>error_enum</i> to find the nicknames for the error codes. This will call &quot;gperl_set_isa&quot; on  <i>package</i> to add &quot;Glib::Error&quot; to  <i>package</i>'s @ISA.<div style="height: 1.00em;">
&#160;</div>
<i>domain</i> may not be 0, and <i>package</i> may not be NULL; what would be the point?   <i>error_enum</i> may be 0, in which case you'll get no fancy stringified error values.</dd>
</dl>
<dl>
<dt>
SV * gperl_sv_from_gerror (GError * error)</dt>
<dd>
You should rarely, if ever, need to call this function.  This is what turns a GError into a Perl object.</dd>
</dl>
<dl>
<dt>
gperl_gerror_from_sv (SV * sv, GError ** error)</dt>
<dd>
You should rarely need this function.  This parses a perl data structure into a GError.  If  <i>sv</i> is undef (or the empty string), sets *<i>error</i> to NULL, otherwise, allocates a new GError with &quot;g_error_new_literal()&quot; and writes through  <i>error</i>; the caller is responsible for calling &quot;g_error_free()&quot;. ( <i>gperl_croak_gerror()</i> does this, for example.)</dd>
</dl>
<dl>
<dt>
void gperl_croak_gerror (const char * ignored, GError * err)</dt>
<dd>
Croak with an exception based on <i>err</i>.  <i>err</i> may not be NULL.  <i>ignored</i> exists for backward compatibility, and is, well, ignored.  This function calls  <i>croak()</i>, which does not return.<div style="height: 1.00em;">
&#160;</div>
Since <i>croak()</i> does not return, this function handles the magic behind not leaking the memory associated with the #GError.  To use this you'd do something like<div style="height: 1.00em;">
&#160;</div>
<br/>
 PREINIT:<br/>
   GError * error = NULL;<br/>
 CODE:<br/>
   if (!funtion_that_can_fail (something, &amp;error))<br/>
      gperl_croak_gerror (NULL, error);<br/>
<div style="height: 1.00em;">
&#160;</div>
It's just that simple!</dd>
</dl>
</div>
<div class="subsection">
<h2>GLog</h2> GLib has a message logging mechanism which it uses for the  <i>g_return_if_fail()</i> assertion macros, etc.; it's really versatile and allows you to set various levels to be fatal and whatnot.  Libraries use these for various types of message reporting.<div class="spacer">
</div>
These functions let you reroute those messages from Perl.  By default, the warning, critical, and message levels go through perl's  <i>warn()</i>, and fatal ones go through  <i>croak()</i>.  [i'm not sure that these get to <i>croak()</i> before GLib  <i>abort()</i>s on them...]<dl>
<dt>
gint gperl_handle_logs_for (const gchar * log_domain)</dt>
<dd>
Route all g_logs for <i>log_domain</i> through gperl's log handling.  You'll have to register domains in each binding submodule, because there's no way we can know about them down here.<div style="height: 1.00em;">
&#160;</div>
And, technically, this traps all the predefined log levels, not any of the ones you (or your library) may define for yourself.</dd>
</dl>
</div>
<div class="subsection">
<h2>GType / GEnum / GFlags</h2><dl>
<dt>
void gperl_register_fundamental (GType gtype, const char * package)</dt>
<dd>
register a mapping between <i>gtype</i> and <i>package</i>.  this is for &quot;fundamental&quot; types which have no other requirements for metadata storage, such as GEnums, GFlags, or real GLib fundamental types like G_TYPE_INT, G_TYPE_FLOAT, etc.</dd>
</dl>
<dl>
<dt>
void gperl_register_fundamental_alias (GType gtype, const char * package)</dt>
<dd>
Makes <i>package</i> an alias for <i>type</i>.  This means that the package name specified by  <i>package</i> will be mapped to <i>type</i> by  <i>gperl_fundamental_type_from_package</i>, but  <i>gperl_fundamental_package_from_type</i> won't map <i>type</i> to <i>package</i>.  This is useful if you want to change the canonical package name of a type while preserving backwards compatibility with code which uses  <i>package</i> to specify  <i>type</i>.<div style="height: 1.00em;">
&#160;</div>
In order for this to make sense, another package name should be registered for  <i>type</i> with <i>gperl_register_fundamental</i> or  <i>gperl_register_fundamental_full</i>.</dd>
</dl>
<dl>
<dt>
GPerlValueWrapperClass</dt>
<dd>
Specifies the vtable that is to be used to convert fundamental types to and from Perl variables.<div style="height: 1.00em;">
&#160;</div>
<br/>
  typedef struct _GPerlValueWrapperClass GPerlValueWrapperClass;<br/>
  struct _GPerlValueWrapperClass {<br/>
          GPerlValueWrapFunc   wrap;<br/>
          GPerlValueUnwrapFunc unwrap;<br/>
  };<br/>
<div style="height: 1.00em;">
&#160;</div>
The members are function pointers, each of which serves a specific purpose:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
GPerlValueWrapFunc</dt>
<dd>
Turns <i>value</i> into an SV.  The caller assumes ownership of the SV.  <i>value</i> is not to be modified.<div style="height: 1.00em;">
&#160;</div>
<br/>
  typedef SV*  (*GPerlValueWrapFunc)   (const GValue * value);<br/>
</dd>
</dl>
<dl>
<dt>
GPerlValueUnwrapFunc</dt>
<dd>
Turns <i>sv</i> into its fundamental representation and stores the result in the pre-configured  <i>value</i>.  <i>value</i> must not be overwritten; instead one of the various &quot;g_value_set_*()&quot; functions must be used or the &quot;value-&gt;data&quot; pointer must be modifed directly.<div style="height: 1.00em;">
&#160;</div>
<br/>
  typedef void (*GPerlValueUnwrapFunc) (GValue       * value,<br/>
                                        SV           * sv);<br/>
</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
</div>
<dl>
<dt>
void gperl_register_fundamental_full (GType gtype, const char * package, GPerlValueWrapperClass * wrapper_class)</dt>
<dd>
Like gperl_register_fundamental, registers a mapping between <i>gtype</i> and  <i>package</i>.  In addition, this also installs the function pointers in  <i>wrapper_class</i> as the handlers for the type.  See GPerlValueWrapperClass.<div style="height: 1.00em;">
&#160;</div>
<i>gperl_register_fundamental_full</i> does not copy the contents of  <i>wrapper_class</i> -- it assumes that <i>wrapper_class</i> is statically allocated and that it will be valid for the whole lifetime of the program.</dd>
</dl>
<dl>
<dt>
GType gperl_fundamental_type_from_package (const char * package)</dt>
<dd>
look up the GType corresponding to a <i>package</i> registered by  <i>gperl_register_fundamental()</i>.</dd>
</dl>
<dl>
<dt>
const char * gperl_fundamental_package_from_type (GType gtype)</dt>
<dd>
look up the package corresponding to a <i>gtype</i> registered by  <i>gperl_register_fundamental()</i>.</dd>
</dl>
<dl>
<dt>
GPerlValueWrapperClass * gperl_fundamental_wrapper_class_from_type (GType gtype)</dt>
<dd>
look up the wrapper class corresponding to a <i>gtype</i> that has previously been registered with  <i>gperl_register_fundamental_full()</i>.</dd>
</dl>
<dl>
<dt>
gboolean gperl_try_convert_enum (GType gtype, SV * sv, gint * val)</dt>
<dd>
return FALSE if <i>sv</i> can't be mapped to a valid member of the registered enum type  <i>gtype</i>; otherwise, return TRUE write the new value to the int pointed to by  <i>val</i>.<div style="height: 1.00em;">
&#160;</div>
you'll need this only in esoteric cases.</dd>
</dl>
<dl>
<dt>
gint gperl_convert_enum (GType type, SV * val)</dt>
<dd>
croak if <i>val</i> is not part of <i>type</i>, otherwise return corresponding value</dd>
</dl>
<dl>
<dt>
SV * gperl_convert_back_enum_pass_unknown (GType type, gint val)</dt>
<dd>
return a scalar containing the nickname of the enum value <i>val</i>, or the integer value of  <i>val</i> if <i>val</i> is not a member of the enum <i>type</i>.</dd>
</dl>
<dl>
<dt>
SV * gperl_convert_back_enum (GType type, gint val)</dt>
<dd>
return a scalar which is the nickname of the enum value val, or croak if val is not a member of the enum.</dd>
</dl>
<dl>
<dt>
gboolean gperl_try_convert_flag (GType type, const char * val_p, gint * val)</dt>
<dd>
like <i>gperl_try_convert_enum()</i>, but for GFlags.</dd>
</dl>
<dl>
<dt>
gint gperl_convert_flag_one (GType type, const char * val)</dt>
<dd>
croak if <i>val</i> is not part of <i>type</i>, otherwise return corresponding value.</dd>
</dl>
<dl>
<dt>
gint gperl_convert_flags (GType type, SV * val)</dt>
<dd>
collapse a list of strings to an integer with all the correct bits set, croak if anything is invalid.</dd>
</dl>
<dl>
<dt>
SV * gperl_convert_back_flags (GType type, gint val)</dt>
<dd>
convert a bitfield to a list of strings.</dd>
</dl>
</div>
<div class="subsection">
<h2>Inheritance management</h2><dl>
<dt>
void gperl_set_isa (const char * child_package, const char * parent_package)</dt>
<dd>
tell perl that <i>child_package</i> inherits <i>parent_package</i>, after whatever else is already there.  equivalent to &quot;push @{$parent_package}::ISA, $child_package;&quot;</dd>
</dl>
<dl>
<dt>
void gperl_prepend_isa (const char * child_package, const char * parent_package)</dt>
<dd>
tell perl that <i>child_package</i> inherits <i>parent_package</i>, but before whatever else is already there.  equivalent to &quot;unshift @{$parent_package}::ISA, $child_package;&quot;</dd>
</dl>
<dl>
<dt>
GType gperl_type_from_package (const char * package)</dt>
<dd>
Look up the GType associated with <i>package</i>, regardless of how it was registered.  Returns 0 if no mapping can be found.</dd>
</dl>
<dl>
<dt>
const char * gperl_package_from_type (GType gtype)</dt>
<dd>
Look up the name of the package associated with <i>gtype</i>, regardless of how it was registered.  Returns NULL if no mapping can be found.</dd>
</dl>
</div>
<div class="subsection">
<h2>Boxed type support for SV</h2> In order to allow GValues to hold perl SVs we need a GBoxed wrapper.<dl>
<dt>
GPERL_TYPE_SV</dt>
<dd>
Evaluates to the GType for SVs.  The bindings register a mapping between GPERL_TYPE_SV and the package 'Glib::Scalar' with  <i>gperl_register_boxed()</i>.</dd>
</dl>
<dl>
<dt>
SV * gperl_sv_copy (SV * sv)</dt>
<dd>
implemented as &quot;newSVsv (sv)&quot;.</dd>
</dl>
<dl>
<dt>
void gperl_sv_free (SV * sv)</dt>
<dd>
implemented as &quot;SvREFCNT_dec (sv)&quot;.</dd>
</dl>
</div>
<div class="subsection">
<h2>UTF-8 strings with gchar</h2> By convention, gchar* is assumed to point to UTF8 string data, and char* points to ascii string data.  Here we define a pair of wrappers for the boilerplate of upgrading Perl strings.  They are implemented as functions rather than macros, because comma expressions in macros are not supported by all compilers.<div class="spacer">
</div>
These functions should be used instead of newSVpv and SvPV_nolen in all cases which deal with gchar* types.<dl>
<dt>
gchar * SvGChar (SV * sv)</dt>
<dd>
extract a UTF8 string from <i>sv</i>.</dd>
</dl>
<dl>
<dt>
SV * newSVGChar (const gchar * str)</dt>
<dd>
copy a UTF8 string into a new SV.  if str is NULL, returns &amp;PL_sv_undef.</dd>
</dl>
</div>
<div class="subsection">
<h2>64 bit integers</h2> On 32 bit machines and even on some 64 bit machines, perl's IV/UV data type can only hold 32 bit values.  The following functions therefore convert 64 bit integers to and from Perl strings if normal IV/UV conversion does not suffice.<dl>
<dt>
gint64 SvGInt64 (SV *sv)</dt>
<dd>
Converts the string in <i>sv</i> to a signed 64 bit integer.  If appropriate, uses &quot;SvIV&quot; instead.</dd>
</dl>
<dl>
<dt>
SV * newSVGInt64 (gint64 value)</dt>
<dd>
Creates a PV from the signed 64 bit integer in <i>value</i>.  If appropriate, uses &quot;newSViv&quot; instead.</dd>
</dl>
<dl>
<dt>
guint64 SvGUInt64 (SV *sv)</dt>
<dd>
Converts the string in <i>sv</i> to an unsigned 64 bit integer.  If appropriate, uses &quot;SvUV&quot; instead.</dd>
</dl>
<dl>
<dt>
SV * newSVGUInt64 (guint64 value)</dt>
<dd>
Creates a PV from the unsigned 64 bit integer in <i>value</i>.  If appropriate, uses &quot;newSVuv&quot; instead.</dd>
</dl>
</div>
<div class="subsection">
<h2>GBoxed</h2><dl>
<dt>
GPerlBoxedWrapperClass</dt>
<dd>
Specifies the vtable of functions to be used for bringing boxed types in and out of perl.  The structure is defined like this:<div style="height: 1.00em;">
&#160;</div>
<br/>
 typedef struct _GPerlBoxedWrapperClass GPerlBoxedWrapperClass;<br/>
 struct _GPerlBoxedWrapperClass {<br/>
          GPerlBoxedWrapFunc    wrap;<br/>
          GPerlBoxedUnwrapFunc  unwrap;<br/>
          GPerlBoxedDestroyFunc destroy;<br/>
 };<br/>
<div style="height: 1.00em;">
&#160;</div>
The members are function pointers, each of which serves a specific purpose:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
GPerlBoxedWrapFunc</dt>
<dd>
turn a boxed pointer into an SV.  gtype is the type of the boxed pointer, and package is the package to which that gtype is registered (the lookup has already been done for you at this point).  if own is true, the wrapper is responsible for freeing the object; if it is false, some other code owns the object and you must NOT free it.<div style="height: 1.00em;">
&#160;</div>
<br/>
 typedef SV*      (*GPerlBoxedWrapFunc)    (GType        gtype,<br/>
                                            const char * package,<br/>
                                            gpointer     boxed,<br/>
                                            gboolean     own);<br/>
</dd>
</dl>
<dl>
<dt>
GPerlBoxedUnwrapFunc</dt>
<dd>
turn an SV into a boxed pointer.  like GPerlBoxedWrapFunc, gtype and package are the registered type pair, already looked up for you (in the process of finding the proper wrapper class).  sv is the sv to unwrap.<div style="height: 1.00em;">
&#160;</div>
<br/>
 typedef gpointer (*GPerlBoxedUnwrapFunc)  (GType        gtype,<br/>
                                            const char * package,<br/>
                                            SV         * sv);<br/>
</dd>
</dl>
<dl>
<dt>
GPerlBoxedDestroyFunc</dt>
<dd>
this will be called by Glib::Boxed::DESTROY, when the wrapper is destroyed. it is a hook that allows you to destroy an object owned by the wrapper; note, however, that you will have had to keep track yourself of whether the object was to be freed.<div style="height: 1.00em;">
&#160;</div>
<br/>
 typedef void     (*GPerlBoxedDestroyFunc) (SV         * sv);<br/>
</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
</div>
<dl>
<dt>
void gperl_register_boxed (GType gtype, const char * package, GPerlBoxedWrapperClass * wrapper_class)</dt>
<dd>
Register a mapping between the GBoxed derivative <i>gtype</i> and <i>package</i>.  The specified,  <i>wrapper_class</i> will be used to wrap and unwrap objects of this type; you may pass NULL to use the default wrapper (the same one returned by  <i>gperl_default_boxed_wrapper_class()</i>).<div style="height: 1.00em;">
&#160;</div>
In normal usage, the standard opaque wrapper supplied by the library is sufficient and correct.  In some cases, however, you want a boxed type to map directly to a native perl type; for example, some struct may be more appropriately represented as a hash in perl.  Since the most necessary place for this conversion to happen is in  <i>gperl_value_from_sv()</i> and  <i>gperl_sv_from_value()</i>, the only reliable and robust way to implement this is a hook into  <i>gperl_get_boxed_check()</i> and <i>gperl_new_boxed()</i>; that is exactly the purpose of  <i>wrapper_class</i>.  See &quot;GPerlBoxedWrapperClass&quot;.<div style="height: 1.00em;">
&#160;</div>
<i>gperl_register_boxed</i> does not copy the contents of <i>wrapper_class</i> -- it assumes that  <i>wrapper_class</i> is statically allocated and that it will be valid for the whole lifetime of the program.</dd>
</dl>
<dl>
<dt>
void gperl_register_boxed_alias (GType gtype, const char * package)</dt>
<dd>
Makes <i>package</i> an alias for <i>type</i>.  This means that the package name specified by  <i>package</i> will be mapped to <i>type</i> by  <i>gperl_boxed_type_from_package</i>, but <i>gperl_boxed_package_from_type</i> won't map  <i>type</i> to <i>package</i>.  This is useful if you want to change the canonical package name of a type while preserving backwards compatibility with code which uses  <i>package</i> to specify <i>type</i>.<div style="height: 1.00em;">
&#160;</div>
In order for this to make sense, another package name should be registered for  <i>type</i> with <i>gperl_register_boxed</i>.</dd>
</dl>
<dl>
<dt>
GType gperl_boxed_type_from_package (const char * package)</dt>
<dd>
Look up the GType associated with package <i>package</i>.  Returns 0 if <i>type</i> is not registered.</dd>
</dl>
<dl>
<dt>
const char * gperl_boxed_package_from_type (GType type)</dt>
<dd>
Look up the package associated with GBoxed derivative <i>type</i>.  Returns NULL if  <i>type</i> is not registered.</dd>
</dl>
<dl>
<dt>
GPerlBoxedWrapperClass * gperl_default_boxed_wrapper_class (void)</dt>
<dd>
get a pointer to the default wrapper class; handy if you want to use the normal wrapper, with minor modifications.  note that you can just pass NULL to  <i>gperl_register_boxed()</i>, so you really only need this in fringe cases.</dd>
</dl>
<dl>
<dt>
SV * gperl_new_boxed (gpointer boxed, GType gtype, gboolean own)</dt>
<dd>
Export a GBoxed derivative to perl, according to whatever GPerlBoxedWrapperClass is registered for  <i>gtype</i>.  In the default implementation, this means wrapping an opaque perl object around the pointer to a small wrapper structure which stores some metadata, such as whether the boxed structure should be destroyed when the wrapper is destroyed (controlled by  <i>own</i>; if the wrapper owns the object, the wrapper is in charge of destroying it's data).</dd>
</dl>
<dl>
<dt>
SV * gperl_new_boxed_copy (gpointer boxed, GType gtype)</dt>
<dd>
Create a new copy of <i>boxed</i> and return an owner wrapper for it.  <i>boxed</i> may not be NULL.  See &quot;gperl_new_boxed&quot;.</dd>
</dl>
<dl>
<dt>
gpointer gperl_get_boxed_check (SV * sv, GType gtype)</dt>
<dd>
Extract the boxed pointer from a wrapper; croaks if the wrapper <i>sv</i> is not blessed into a derivative of the expected  <i>gtype</i>.  Does not allow undef.</dd>
</dl>
</div>
<div class="subsection">
<h2>GObject</h2> To deal with the intricate interaction of the different reference-counting semantics of Perl objects versus GObjects, the bindings create a combined PerlObject+GObject, with the GObject's pointer in magic attached to the Perl object, and the Perl object's pointer in the GObject's user data.  Thus it's not really a &quot;wrapper&quot;, but we refer to it as one, because &quot;combined Perl object + GObject&quot; is a cumbersome and confusing mouthful.<div class="spacer">
</div>
GObjects are represented as blessed hash references.  The GObject user data mechanism is not typesafe, and thus is used only for unsigned integer values; the Perl-level hash is available for any type of user data.  The combined nature of the wrapper means that data stored in the hash will stick around as long as the object is alive.<div class="spacer">
</div>
Since the C pointer is stored in attached magic, the C pointer is not available to the Perl developer via the hash object, so there's no need to worry about breaking it from perl.<div class="spacer">
</div>
Propers go to Marc Lehmann for dreaming most of this up.<dl>
<dt>
void gperl_register_object (GType gtype, const char * package)</dt>
<dd>
tell the GPerl type subsystem what Perl package corresponds with a given GObject by GType.  automagically sets up @ <i>package</i>::ISA for you.<div style="height: 1.00em;">
&#160;</div>
note that @ISA will not be created for gtype until gtype's parent has been registered.  if you are experiencing strange problems with a class' @ISA not being set up, change the order in which you register them.</dd>
</dl>
<dl>
<dt>
void gperl_register_object_alias (GType gtype, const char * package)</dt>
<dd>
Makes <i>package</i> an alias for <i>type</i>.  This means that the package name specified by  <i>package</i> will be mapped to <i>type</i> by  <i>gperl_object_type_from_package</i>, but <i>gperl_object_package_from_type</i> won't map  <i>type</i> to <i>package</i>.  This is useful if you want to change the canonical package name of a type while preserving backwards compatibility with code which uses  <i>package</i> to specify <i>type</i>.<div style="height: 1.00em;">
&#160;</div>
In order for this to make sense, another package name should be registered for  <i>type</i> with <i>gperl_register_object</i>.</dd>
</dl>
<dl>
<dt>
void gperl_register_sink_func (GType gtype, GPerlObjectSinkFunc func)</dt>
<dd>
Tell <i>gperl_new_object()</i> to use <i>func</i> to claim ownership of objects derived from  <i>gtype</i>.<div style="height: 1.00em;">
&#160;</div>
<i>gperl_new_object()</i> always refs a GObject when wrapping it for the first time. To have the Perl wrapper claim ownership of a GObject as part of  <i>gperl_new_object()</i>, you unref the object after ref'ing it. however, different GObject subclasses have different ways to claim ownership; for example, GtkObject simply requires you to call  <i>gtk_object_sink()</i>.  To make this concept generic, this function allows you to register a function to be called when then wrapper should claim ownership of the object.  The  <i>func</i> registered for a given  <i>type</i> will be called on any object for which &quot;g_type_isa (G_TYPE_OBJECT (object), type)&quot; succeeds.<div style="height: 1.00em;">
&#160;</div>
If no sinkfunc is found for an object, <i>g_object_unref()</i> will be used.<div style="height: 1.00em;">
&#160;</div>
Even though GObjects don't need sink funcs, we need to have them in Glib as a hook for upstream objects.  If we create a GtkObject (or any other type of object which uses a different way to claim ownership) via Glib::Object-&gt;new, any upstream wrappers, such as  <i>gtk2perl_new_object()</i>, will  <b>not</b> be called.  Having a sink func facility down here enables us always to do the right thing.</dd>
</dl>
<dl>
<dt>
void gperl_object_set_no_warn_unreg_subclass (GType gtype, gboolean nowarn)</dt>
<dd>
In versions 1.00 through 1.10x of Glib, the bindings required all types to be registered ahead of time.  Upon encountering an unknown type, the bindings would emit a warning to the effect of &quot;unknown type 'Foo'; representing as first known parent type 'Bar'&quot;.  However, for some types, such as GtkStyle or GdkGC, the actual object returned is an instance of a child type of a private implementation (e.g., a theme engine (&quot;BlueCurveStyle&quot;) or gdk backend (&quot;GdkGCX11&quot;)); we neither can nor should have registered names for these types.  Therefore, it is possible to tell the bindings not to warn about these unregistered subclasses, and simply represent them as the parent type.<div style="height: 1.00em;">
&#160;</div>
With 1.12x, the bindings will automatically register unknown classes into the namespace Glib::Object::_Unregistered to avoid possible breakage resulting from unknown ancestors of known children.  To preserve the old registered-as-unregistered behavior, the value installed by this function is used to prevent the _Unregistered mapping for such private backend classes.<div style="height: 1.00em;">
&#160;</div>
Note: this assumes <i>gtype</i> has already been registered with  <i>gperl_register_object()</i>.</dd>
</dl>
<dl>
<dt>
const char * gperl_object_package_from_type (GType gtype)</dt>
<dd>
Get the package corresponding to <i>gtype</i>.  If <i>gtype</i> is not a GObject or GInterface, returns NULL.  If  <i>gtype</i> is not registered to a package name, a new name of the form &quot;Glib::Object::_Unregistered::$c_type_name&quot; will be created, used to register the class, and then returned.</dd>
</dl>
<dl>
<dt>
HV * gperl_object_stash_from_type (GType gtype)</dt>
<dd>
Get the stash corresponding to <i>gtype</i>; returns NULL if <i>gtype</i> is not registered.  The stash is useful for &quot;bless&quot;ing.</dd>
</dl>
<dl>
<dt>
GType gperl_object_type_from_package (const char * package)</dt>
<dd>
Inverse of <i>gperl_object_package_from_type()</i>,  returns 0 if <i>package</i> is not registered.</dd>
</dl>
<dl>
<dt>
SV * gperl_new_object (GObject * object, gboolean own)</dt>
<dd>
Use this function to get the perl part of a GObject.  If <i>object</i> has never been seen by perl before, a new, empty perl object will be created and added to a private key under  <i>object</i>'s qdata.  If  <i>object</i> already has a perl part, a new reference to it will be created. The gobject + perl object together form a combined object that is properly refcounted, i.e. both parts will stay alive as long as at least one of them is alive, and only when both perl object and gobject are no longer referenced will both be freed.<div style="height: 1.00em;">
&#160;</div>
The perl object will be blessed into the package corresponding to the GType returned by calling  <i>G_OBJECT_TYPE()</i> on <i>object</i>; if that class has not been registered via  <i>gperl_register_object()</i>, this function will emit a warning to that effect (with  <i>warn()</i>), and attempt to bless it into the first known class in the object's ancestry.  Since Glib::Object is already registered, you'll get a Glib::Object if you are lazy, and thus this function can fail only if  <i>object</i> isn't descended from GObject, in which case it croaks.  (In reality, if you pass a non-GObject to this function, you'll be lucky if you don't get a segfault, as there's not really a way to trap that.)  In practice these warnings can be unavoidable, so you can use  <i>gperl_object_set_no_warn_unreg_subclass()</i> to quell them on a class-by-class basis.<div style="height: 1.00em;">
&#160;</div>
However, when perl code is calling a GObject constructor (any function which returns a new GObject), call  <i>gperl_new_object()</i> with <i>own</i> set to %TRUE; this will cause the first matching sink function to be called on the GObject to claim ownership of that object, so that it will be destroyed when the perl object goes out of scope. The default sink func is  <i>g_object_unref()</i>; other types should supply the proper function; e.g., GtkObject should use  <i>gtk_object_sink()</i> here.<div style="height: 1.00em;">
&#160;</div>
Returns the blessed perl object, or #&amp;PL_sv_undef if object was #NULL.</dd>
</dl>
<dl>
<dt>
GObject * gperl_get_object (SV * sv)</dt>
<dd>
retrieve the GObject pointer from a Perl object.  Returns NULL if <i>sv</i> is not linked to a GObject.<div style="height: 1.00em;">
&#160;</div>
Note, this one is not safe -- in general you want to use  <i>gperl_get_object_check()</i>.</dd>
</dl>
<dl>
<dt>
GObject * gperl_get_object_check (SV * sv, GType gtype);</dt>
<dd>
croaks if <i>sv</i> is undef or is not blessed into the package corresponding to  <i>gtype</i>.  use this for bringing parameters into xsubs from perl. Returns the same as  <i>gperl_get_object()</i> (provided it doesn't croak first).</dd>
</dl>
<dl>
<dt>
SV * gperl_object_check_type (SV * sv, GType gtype)</dt>
<dd>
Essentially the same as <i>gperl_get_object_check()</i>.<div style="height: 1.00em;">
&#160;</div>
This croaks if the types aren't compatible.</dd>
</dl>
<dl>
<dt>
typedef GObject GObject_noinc</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
typedef GObject GObject_ornull</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
newSVGObject(obj)</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
newSVGObject_noinc(obj)</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
SvGObject(sv)</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
SvGObject_ornull(sv)</dt>
<dd>
</dd>
</dl>
</div>
<div class="subsection">
<h2>GValue</h2> GValue is GLib's generic value container, and it is because of GValue that the run time type handling of GObject parameters and GClosure marshaling can function, and most usages of these functions will be from those two points.<div class="spacer">
</div>
Client code will run into uses for <i>gperl_sv_from_value()</i> and  <i>gperl_value_from_sv()</i> when trying to convert lists of parameters into GValue arrays and the like.<dl>
<dt>
gboolean gperl_value_from_sv (GValue * value, SV * sv)</dt>
<dd>
set a <i>value</i> from a whatever is in <i>sv</i>.  <i>value</i> must be initialized so the code knows what kind of value to coerce out of  <i>sv</i>.<div style="height: 1.00em;">
&#160;</div>
Return value is always TRUE; if the code knows how to perform the conversion, it croaks.  (The return value is for backward compatibility.) In reality, this really ought to always succeed; a failed conversion should be considered a bug or unimplemented code!</dd>
</dl>
<dl>
<dt>
SV * gperl_sv_from_value (const GValue * value)</dt>
<dd>
Coerce whatever is in <i>value</i> into a perl scalar and return it.<div style="height: 1.00em;">
&#160;</div>
Croaks if the code doesn't know how to perform the conversion.</dd>
</dl>
</div>
<div class="subsection">
<h2>GClosure / GPerlClosure</h2> GPerlClosure is a wrapper around the gobject library's GClosure with special handling for marshalling perl subroutines as callbacks. This is specially tuned for use with GSignal and stuff like io watch, timeout, and idle handlers.<div class="spacer">
</div>
For generic callback functions, which need parameters but do not get registered with the type system, this is sometimes overkill.  See GPerlCallback, below.<dl>
<dt>
GClosure * gperl_closure_new (SV * callback, SV * data, gboolean swap)</dt>
<dd>
Create and return a new GPerlClosure.  <i>callback</i> and <i>data</i> will be copied for storage;  <i>callback</i> must not be NULL.  If <i>swap</i> is TRUE, <i>data</i> will be swapped with the instance during invocation (this is used to implement  <i>g_signal_connect_swapped()</i>).<div style="height: 1.00em;">
&#160;</div>
If compiled under a thread-enabled perl, the closure will be created and marshaled in such a way as to ensure that the same interpreter which created the closure will be used to invoke it.</dd>
</dl>
<dl>
<dt>
GClosure * gperl_closure_new_with_marshaller (SV * callback, SV * data, gboolean swap, GClosureMarshal marshaller)</dt>
<dd>
Like &quot;gperl_closure_new&quot;, but uses a caller-supplied marshaller.  This is provided for use in those sticky circumstances when you just can't do it any other way; in general, you want to use the default marshaller, which you get if you provide NULL for  <i>marshaller</i>.<div style="height: 1.00em;">
&#160;</div>
If you use you own marshaller, you need to take care of everything yourself, including swapping the instance and data if &quot;GPERL_CLOSURE_SWAP_DATA (closure)&quot; is true, calling &quot;gperl_run_exception_handlers&quot; if ERRSV is true after invoking the perl sub, and ensuring that you properly use the &quot;marshal_data&quot; parameter as the perl interpreter when PERL_IMPLICIT_CONTEXT is defined.  See the implementation of the default marshaller, &quot;gperl_closure_marshal&quot;, in Glib/GClosure.xs for inspiration.</dd>
</dl>
</div>
<div class="subsection">
<h2>GPerlCallback</h2> generic callback functions usually get invoked directly, and are not passed parameter lists as GValues.  we could very easily wrap up such generic callbacks with something that converts the parameters to GValues and then channels everything through GClosure, but this has two problems:  1) the above implementation of GClosure is tuned to marshalling signal handlers, which always have an instance object, and 2) it's more work than is strictly necessary.<div class="spacer">
</div>
additionally, generic callbacks aren't always kind to the GClosure paradigm.<div class="spacer">
</div>
so, here's GPerlCallback, which is designed specifically to run generic callback functions.  it reads parameters off the C stack and converts them into parameters on the perl stack.  (it uses the GValue to/from SV mechanism to do so, but doesn't allocate any temps on the heap.)  the callback object itself stores the parameter type list.<div class="spacer">
</div>
unfortunately, since the data element is always last, but the number of arguments is not known until we have the callback object, we can't pass gperl_callback_invoke directly to functions requiring a callback; you'll have to write a proxy callback which calls gperl_callback_invoke.<dl>
<dt>
GPerlCallback * gperl_callback_new (SV * func, SV * data, gint n_params, GType param_types[], GType return_type)</dt>
<dd>
Create and return a new GPerlCallback; use gperl_callback_destroy when you are finished with it.<div style="height: 1.00em;">
&#160;</div>
<i>func</i>: perl subroutine to call.  this SV will be copied, so don't worry about reference counts.  must  <b>not</b> be #NULL.<div style="height: 1.00em;">
&#160;</div>
<i>data</i>: scalar to pass to <i>func</i> in addition to all other arguments.  the SV will be copied, so don't worry about reference counts.  may be #NULL.<div style="height: 1.00em;">
&#160;</div>
<i>n_params</i>: the number of elements in <i>param_types</i>.<div style="height: 1.00em;">
&#160;</div>
<i>param_types</i>: the #GType of each argument that should be passed from the invocation to  <i>func</i>.  may be #NULL if <i>n_params</i> is zero, otherwise it must be  <i>n_params</i> elements long or nasty things will happen.  this array will be copied; see  <i>gperl_callback_invoke()</i> for how it is used.<div style="height: 1.00em;">
&#160;</div>
<i>return_type</i>: the #GType of the return value, or 0 if the function has void return.</dd>
</dl>
<dl>
<dt>
void gperl_callback_destroy (GPerlCallback * callback)</dt>
<dd>
Dispose of <i>callback</i>.</dd>
</dl>
<dl>
<dt>
void gperl_callback_invoke (GPerlCallback * callback, GValue * return_value, ...)</dt>
<dd>
Marshall the variadic parameters according to <i>callback</i>'s param_types, and then invoke  <i>callback</i>'s subroutine in scalar context, or void context if the return type is G_TYPE_VOID.  If  <i>return_value</i> is not NULL, then value returned (if any) will be copied into  <i>return_value</i>.<div style="height: 1.00em;">
&#160;</div>
A typical callback handler would look like this:<div style="height: 1.00em;">
&#160;</div>
<br/>
  static gint<br/>
  real_c_callback (Foo * f, Bar * b, int a, gpointer data)<br/>
  {<br/>
          GPerlCallback * callback = (GPerlCallback*)data;<br/>
          GValue return_value = {0,};<br/>
          gint retval;<br/>
          g_value_init (&amp;return_value, callback-&gt;return_type);<br/>
          gperl_callback_invoke (callback, &amp;return_value,<br/>
                                 f, b, a);<br/>
          retval = g_value_get_int (&amp;return_value);<br/>
          g_value_unset (&amp;return_value);<br/>
          return retval;<br/>
  }<br/>
</dd>
</dl>
</div>
<div class="subsection">
<h2>Exception Handling</h2> Like Event, Tk, and most other callback-using, event-based perl modules, Glib traps exceptions that happen in callbacks.  To enable your code to do something about these exceptions, Glib stores a list of exception handlers which will be called on the trapped exceptions.  This is completely distinct from the $SIG{__DIE__} mechanism provided by Perl itself, for various reasons (not the least of which is that the Perl docs and source code say that $SIG{__DIE__} is intended for running as the program is about to exit, and other behaviors may be removed in the future (apparently a source of much debate on p5p)).<dl>
<dt>
int gperl_install_exception_handler (GClosure * closure)</dt>
<dd>
Install a GClosure to be executed when <i>gperl_closure_invoke()</i> traps an exception.  The closure should return boolean (TRUE if the handler should remain installed) and expect to receive a perl scalar.  This scalar will be a private copy of ERRSV ($@) which the handler can mangle to its heart's content.<div style="height: 1.00em;">
&#160;</div>
The return value is an integer id tag that may be passed to  <i>gperl_removed_exception_handler()</i>.</dd>
</dl>
<dl>
<dt>
void gperl_remove_exception_handler (guint tag)</dt>
<dd>
Remove the exception handler identified by <i>tag</i>, as returned by  <i>gperl_install_exception_handler()</i>.  If <i>tag</i> cannot be found, this does nothing.<div style="height: 1.00em;">
&#160;</div>
WARNING:  this function locks a global data structure, so do NOT call it recursively.  also, calling this from within an exception handler will result in a deadlock situation.  if you want to remove your handler just have it return FALSE.</dd>
</dl>
<dl>
<dt>
void gperl_run_exception_handlers (void)</dt>
<dd>
Invoke whatever exception handlers are installed.  You will need this if you have written a custom marshaler.  Uses the value of the global ERRSV.</dd>
</dl>
</div>
<div class="subsection">
<h2>GSignal</h2><dl>
<dt>
void gperl_signal_set_marshaller_for (GType instance_type, char * detailed_signal, GClosureMarshal marshaller)</dt>
<dd>
You need this function only in rare cases, usually as workarounds for bad signal parameter types or to implement writable arguments.  Use the given  <i>marshaller</i> to marshal all handlers for <i>detailed_signal</i> on  <i>instance_type</i>.  &quot;gperl_signal_connect&quot; will look for marshallers registered here, and apply them to the GPerlClosure it creates for the given callback being connected.<div style="height: 1.00em;">
&#160;</div>
Use the helper macros in gperl_marshal.h to help write your marshaller function.  That header, which is installed with the Glib module but not #included through gperl.h, includes commentary and examples which you should follow closely to avoid nasty bugs.  Use the Source, Luke.<div style="height: 1.00em;">
&#160;</div>
WARNING: Bend over backwards and turn your head around 720 degrees before attempting to write a GPerlClosure marshaller without using the macros in gperl_marshal.h.  If you absolutely cannot use those macros, be certain to understand what those macros do so you can get the semantics correct, and keep your code synchronized with them, or you may miss very important bugfixes.</dd>
</dl>
<dl>
<dt>
gulong gperl_signal_connect (SV * instance, char * detailed_signal, SV * callback, SV * data, GConnectFlags flags)</dt>
<dd>
The actual workhorse behind GObject::signal_connect, the binding for g_signal_connect, for use from within XS.  This creates a &quot;GPerlClosure&quot; wrapper for the given  <i>callback</i> and <i>data</i>, and connects that closure to the signal named  <i>detailed_signal</i> on the given GObject <i>instance</i>.  This is only good for named signals.   <i>flags</i> is the same as for <i>g_signal_connect()</i>.  <i>data</i> may be NULL, but <i>callback</i> must not be.<div style="height: 1.00em;">
&#160;</div>
Returns the id of the installed callback.</dd>
</dl>
</div>
</div>
<div class="section">
<h1>SEE ALSO</h1>  <i>perlapi</i>(1), <i>perlguts</i>(1), GLib Reference Manual, <i>Glib</i>(3pm), <i>Glib::devel</i>(3pm).</div>
<div class="section">
<h1>AUTHORS</h1> This file was automatically generated from the source code of the Glib module, which is maintained by the gtk2-perl team.</div>
<div class="section">
<h1>LICENSE</h1> Copyright (C) 2003 by the gtk2-perl team (see the file AUTHORS for the full list)<div class="spacer">
</div>
This library is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.<div class="spacer">
</div>
This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.<div class="spacer">
</div>
You should have received a copy of the GNU Library General Public License along with this library; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307  USA.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-12-05</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

