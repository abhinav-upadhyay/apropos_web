<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
HTTP::Response(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
HTTP::Response(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
HTTP::Response(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> HTTP::Response - HTTP style response message</div>
<div class="section">
<h1>SYNOPSIS</h1> Response objects are returned by the  <i>request()</i> method of the &quot;LWP::UserAgent&quot;:<div class="spacer">
</div>
<br/>
    # ...<br/>
    $response = $ua-&gt;request($request)<br/>
    if ($response-&gt;is_success) {<br/>
        print $response-&gt;decoded_content;<br/>
    }<br/>
    else {<br/>
        print STDERR $response-&gt;status_line, &quot;\n&quot;;<br/>
    }<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> The &quot;HTTP::Response&quot; class encapsulates HTTP style responses.  A response consists of a response line, some headers, and a content body. Note that the LWP library uses HTTP style responses even for non-HTTP protocol schemes.  Instances of this class are usually created and returned by the  <i>request()</i> method of an &quot;LWP::UserAgent&quot; object.<div class="spacer">
</div>
&quot;HTTP::Response&quot; is a subclass of &quot;HTTP::Message&quot; and therefore inherits its methods.  The following additional methods are available:<dl>
<dt>
$r = HTTP::Response-&gt;new( $code )</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$r = HTTP::Response-&gt;new( $code, $msg )</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$r = HTTP::Response-&gt;new( $code, $msg, $header )</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$r = HTTP::Response-&gt;new( $code, $msg, $header, $content )</dt>
<dd>
Constructs a new &quot;HTTP::Response&quot; object describing a response with response code $code and optional message $msg.  The optional $header argument should be a reference to an &quot;HTTP::Headers&quot; object or a plain array reference of key/value pairs.  The optional $content argument should be a string of bytes.  The meaning these arguments are described below.</dd>
</dl>
<dl>
<dt>
$r = HTTP::Response-&gt;parse( $str )</dt>
<dd>
This constructs a new response object by parsing the given string.</dd>
</dl>
<dl>
<dt>
$r-&gt;code</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$r-&gt;code( $code )</dt>
<dd>
This is used to get/set the code attribute.  The code is a 3 digit number that encode the overall outcome of a HTTP response.  The &quot;HTTP::Status&quot; module provide constants that provide mnemonic names for the code attribute.</dd>
</dl>
<dl>
<dt>
$r-&gt;message</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$r-&gt;message( $message )</dt>
<dd>
This is used to get/set the message attribute.  The message is a short human readable single line string that explains the response code.</dd>
</dl>
<dl>
<dt>
$r-&gt;header( $field )</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$r-&gt;header( $field =&gt; $value )</dt>
<dd>
This is used to get/set header values and it is inherited from &quot;HTTP::Headers&quot; via &quot;HTTP::Message&quot;.  See HTTP::Headers for details and other similar methods that can be used to access the headers.</dd>
</dl>
<dl>
<dt>
$r-&gt;content</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$r-&gt;content( $bytes )</dt>
<dd>
This is used to get/set the raw content and it is inherited from the &quot;HTTP::Message&quot; base class.  See HTTP::Message for details and other methods that can be used to access the content.</dd>
</dl>
<dl>
<dt>
$r-&gt;decoded_content( %options )</dt>
<dd>
This will return the content after any &quot;Content-Encoding&quot; and charsets have been decoded.  See HTTP::Message for details.</dd>
</dl>
<dl>
<dt>
$r-&gt;request</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$r-&gt;request( $request )</dt>
<dd>
This is used to get/set the request attribute.  The request attribute is a reference to the the request that caused this response.  It does not have to be the same request passed to the $ua-&gt; <i>request()</i> method, because there might have been redirects and authorization retries in between.</dd>
</dl>
<dl>
<dt>
$r-&gt;previous</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$r-&gt;previous( $response )</dt>
<dd>
This is used to get/set the previous attribute.  The previous attribute is used to link together chains of responses.  You get chains of responses if the first response is redirect or unauthorized. The value is &quot;undef&quot; if this is the first response in a chain.<div style="height: 1.00em;">
&#160;</div>
Note that the method $r-&gt;redirects is provided as a more convenient way to access the response chain.</dd>
</dl>
<dl>
<dt>
$r-&gt;status_line</dt>
<dd>
Returns the string &quot;&lt;code&gt; &lt;message&gt;&quot;.  If the message attribute is not set then the official name of &lt;code&gt; (see HTTP::Status) is substituted.</dd>
</dl>
<dl>
<dt>
$r-&gt;base</dt>
<dd>
Returns the base URI for this response.  The return value will be a reference to a URI object.<div style="height: 1.00em;">
&#160;</div>
The base URI is obtained from one the following sources (in priority order):</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
1.</dt>
<dd>
Embedded in the document content, for instance &lt;BASE HREF=&quot;...&quot;&gt; in HTML documents.</dd>
</dl>
<dl>
<dt>
2.</dt>
<dd>
A &quot;Content-Base:&quot; or a &quot;Content-Location:&quot; header in the response.<div style="height: 1.00em;">
&#160;</div>
For backwards compatibility with older HTTP implementations we will also look for the &quot;Base:&quot; header.</dd>
</dl>
<dl>
<dt>
3.</dt>
<dd>
The URI used to request this response. This might not be the original URI that was passed to $ua-&gt; <i>request()</i> method, because we might have received some redirect responses first.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">
&#160;</div>
If none of these sources provide an absolute URI, undef is returned.<div style="height: 1.00em;">
&#160;</div>
When the LWP protocol modules produce the HTTP::Response object, then any base URI embedded in the document (step 1) will already have initialized the &quot;Content-Base:&quot; header. This means that this method only performs the last 2 steps (the content is not always available either).</div>
<dl>
<dt>
$r-&gt;filename</dt>
<dd>
Returns a filename for this response.  Note that doing sanity checks on the returned filename (eg. removing characters that cannot be used on the target filesystem where the filename would be used, and laundering it for security purposes) are the caller's responsibility; the only related thing done by this method is that it makes a simple attempt to return a plain filename with no preceding path segments.<div style="height: 1.00em;">
&#160;</div>
The filename is obtained from one the following sources (in priority order):</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
1.</dt>
<dd>
A &quot;Content-Disposition:&quot; header in the response.  Proper decoding of RFC 2047 encoded filenames requires the &quot;MIME::QuotedPrint&quot; (for &quot;Q&quot; encoding), &quot;MIME::Base64&quot; (for &quot;B&quot; encoding), and &quot;Encode&quot; modules.</dd>
</dl>
<dl>
<dt>
2.</dt>
<dd>
A &quot;Content-Location:&quot; header in the response.</dd>
</dl>
<dl>
<dt>
3.</dt>
<dd>
The URI used to request this response. This might not be the original URI that was passed to $ua-&gt; <i>request()</i> method, because we might have received some redirect responses first.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">
&#160;</div>
If a filename cannot be derived from any of these sources, undef is returned.</div>
<dl>
<dt>
$r-&gt;as_string</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$r-&gt;as_string( $eol )</dt>
<dd>
Returns a textual representation of the response.</dd>
</dl>
<dl>
<dt>
$r-&gt;is_info</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$r-&gt;is_success</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$r-&gt;is_redirect</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
$r-&gt;is_error</dt>
<dd>
These methods indicate if the response was informational, successful, a redirection, or an error.  See HTTP::Status for the meaning of these.</dd>
</dl>
<dl>
<dt>
$r-&gt;error_as_HTML</dt>
<dd>
Returns a string containing a complete HTML document indicating what error occurred.  This method should only be called when $r-&gt;is_error is TRUE.</dd>
</dl>
<dl>
<dt>
$r-&gt;redirects</dt>
<dd>
Returns the list of redirect responses that lead up to this response by following the $r-&gt;previous chain.  The list order is oldest first.<div style="height: 1.00em;">
&#160;</div>
In scalar context return the number of redirect responses leading up to this one.</dd>
</dl>
<dl>
<dt>
$r-&gt;current_age</dt>
<dd>
Calculates the &quot;current age&quot; of the response as specified by RFC 2616 section 13.2.3.  The age of a response is the time since it was sent by the origin server.  The returned value is a number representing the age in seconds.</dd>
</dl>
<dl>
<dt>
$r-&gt;freshness_lifetime( %opt )</dt>
<dd>
Calculates the &quot;freshness lifetime&quot; of the response as specified by RFC 2616 section 13.2.4.  The &quot;freshness lifetime&quot; is the length of time between the generation of a response and its expiration time. The returned value is the number of seconds until expiry.<div style="height: 1.00em;">
&#160;</div>
If the response does not contain an &quot;Expires&quot; or a &quot;Cache-Control&quot; header, then this function will apply some simple heuristic based on the &quot;Last-Modified&quot; header to determine a suitable lifetime.  The following options might be passed to control the heuristics:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
heuristic_expiry =&gt; $bool</dt>
<dd>
If passed as a FALSE value, don't apply heuristics and just return &quot;undef&quot; when &quot;Expires&quot; or &quot;Cache-Control&quot; is lacking.</dd>
</dl>
<dl>
<dt>
h_lastmod_fraction =&gt; $num</dt>
<dd>
This number represent the fraction of the difference since the &quot;Last-Modified&quot; timestamp to make the expiry time.  The default is 0.10, the suggested typical setting of 10% in RFC 2616.</dd>
</dl>
<dl>
<dt>
h_min =&gt; $sec</dt>
<dd>
This is the lower limit of the heuristic expiry age to use.  The default is 60 (1 minute).</dd>
</dl>
<dl>
<dt>
h_max =&gt; $sec</dt>
<dd>
This is the upper limit of the heuristic expiry age to use.  The default is 86400 (24 hours).</dd>
</dl>
<dl>
<dt>
h_default =&gt; $sec</dt>
<dd>
This is the expiry age to use when nothing else applies.  The default is 3600 (1 hour) or &quot;h_min&quot; if greater.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
</div>
<dl>
<dt>
$r-&gt;is_fresh( %opt )</dt>
<dd>
Returns TRUE if the response is fresh, based on the values of  <i>freshness_lifetime()</i> and <i>current_age()</i>.  If the response is no longer fresh, then it has to be re-fetched or re-validated by the origin server.<div style="height: 1.00em;">
&#160;</div>
Options might be passed to control expiry heuristics, see the description of  <i>freshness_lifetime()</i>.</dd>
</dl>
<dl>
<dt>
$r-&gt;fresh_until( %opt )</dt>
<dd>
Returns the time (seconds since epoch) when this entity is no longer fresh.<div style="height: 1.00em;">
&#160;</div>
Options might be passed to control expiry heuristics, see the description of  <i>freshness_lifetime()</i>.</dd>
</dl>
</div>
<div class="section">
<h1>SEE ALSO</h1> HTTP::Headers, HTTP::Message, HTTP::Status, HTTP::Request</div>
<div class="section">
<h1>COPYRIGHT</h1> Copyright 1995-2004 Gisle Aas.<div class="spacer">
</div>
This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-03-07</td>
<td class="foot-os">
perl v5.12.3</td>
</tr>
</table>
</div>
</body>
</html>

