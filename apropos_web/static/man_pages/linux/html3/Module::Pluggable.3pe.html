<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Module::Pluggable(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Module::Pluggable(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
Module::Pluggable(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Module::Pluggable - automatically give your module the ability to have plugins</div>
<div class="section">
<h1>SYNOPSIS</h1> Simple use Module::Pluggable -<div class="spacer">
</div>
<br/>
    package MyClass;<br/>
    use Module::Pluggable;<br/>
<div class="spacer">
</div>
and then later ...<div class="spacer">
</div>
<br/>
    use MyClass;<br/>
    my $mc = MyClass-&gt;new();<br/>
    # returns the names of all plugins installed under MyClass::Plugin::*<br/>
    my @plugins = $mc-&gt;plugins();<br/>
</div>
<div class="section">
<h1>EXAMPLE</h1> Why would you want to do this? Say you have something that wants to pass an object to a number of different plugins in turn. For example you may want to extract meta-data from every email you get sent and do something with it. Plugins make sense here because then you can keep adding new meta data parsers and all the logic and docs for each one will be self contained and new handlers are easy to add without changing the core code. For that, you might do something like ...<div class="spacer">
</div>
<br/>
    package Email::Examiner;<br/>
<br/>
    use strict;<br/>
    use Email::Simple;<br/>
    use Module::Pluggable require =&gt; 1;<br/>
<br/>
    sub handle_email {<br/>
        my $self  = shift;<br/>
        my $email = shift;<br/>
<br/>
        foreach my $plugin ($self-&gt;plugins) {<br/>
            $plugin-&gt;examine($email);<br/>
        }<br/>
<br/>
        return 1;<br/>
    }<br/>
<div class="spacer">
</div>
.. and all the plugins will get a chance in turn to look at it.<div class="spacer">
</div>
This can be trivally extended so that plugins could save the email somewhere and then no other plugin should try and do that. Simply have it so that the &quot;examine&quot; method returns 1 if it has saved the email somewhere. You might also wnat to be paranoid and check to see if the plugin has an &quot;examine&quot; method.<div class="spacer">
</div>
<br/>
        foreach my $plugin ($self-&gt;plugins) {<br/>
            next unless $plugin-&gt;can('examine');<br/>
            last if     $plugin-&gt;examine($email);<br/>
        }<br/>
<div class="spacer">
</div>
And so on. The sky's the limit.</div>
<div class="section">
<h1>DESCRIPTION</h1> Provides a simple but, hopefully, extensible way of having 'plugins' for your module. Obviously this isn't going to be the be all and end all of solutions but it works for me.<div class="spacer">
</div>
Essentially all it does is export a method into your namespace that looks through a search path for .pm files and turn those into class names.<div class="spacer">
</div>
Optionally it instantiates those classes for you.</div>
<div class="section">
<h1>ADVANCED USAGE</h1> Alternatively, if you don't want to use 'plugins' as the method ...<div class="spacer">
</div>
<br/>
    package MyClass;<br/>
    use Module::Pluggable sub_name =&gt; 'foo';<br/>
<div class="spacer">
</div>
and then later ...<div class="spacer">
</div>
<br/>
    my @plugins = $mc-&gt;foo();<br/>
<div class="spacer">
</div>
Or if you want to look in another namespace<div class="spacer">
</div>
<br/>
    package MyClass;<br/>
    use Module::Pluggable search_path =&gt; ['Acme::MyClass::Plugin', 'MyClass::Extend'];<br/>
<div class="spacer">
</div>
or directory<div class="spacer">
</div>
<br/>
    use Module::Pluggable search_dirs =&gt; ['mylibs/Foo'];<br/>
<div class="spacer">
</div>
Or if you want to instantiate each plugin rather than just return the name<div class="spacer">
</div>
<br/>
    package MyClass;<br/>
    use Module::Pluggable instantiate =&gt; 'new';<br/>
<div class="spacer">
</div>
and then<div class="spacer">
</div>
<br/>
    # whatever is passed to 'plugins' will be passed <br/>
    # to 'new' for each plugin <br/>
    my @plugins = $mc-&gt;plugins(@options);<br/>
<div class="spacer">
</div>
alternatively you can just require the module without instantiating it<div class="spacer">
</div>
<br/>
    package MyClass;<br/>
    use Module::Pluggable require =&gt; 1;<br/>
<div class="spacer">
</div>
since requiring automatically searches inner packages, which may not be desirable, you can turn this off<div class="spacer">
</div>
<br/>
    package MyClass;<br/>
    use Module::Pluggable require =&gt; 1, inner =&gt; 0;<br/>
<div class="spacer">
</div>
You can limit the plugins loaded using the except option, either as a string, array ref or regex<div class="spacer">
</div>
<br/>
    package MyClass;<br/>
    use Module::Pluggable except =&gt; 'MyClass::Plugin::Foo';<br/>
<div class="spacer">
</div>
or<div class="spacer">
</div>
<br/>
    package MyClass;<br/>
    use Module::Pluggable except =&gt; ['MyClass::Plugin::Foo', 'MyClass::Plugin::Bar'];<br/>
<div class="spacer">
</div>
or<div class="spacer">
</div>
<br/>
    package MyClass;<br/>
    use Module::Pluggable except =&gt; qr/^MyClass::Plugin::(Foo|Bar)$/;<br/>
<div class="spacer">
</div>
and similarly for only which will only load plugins which match.<div class="spacer">
</div>
Remember you can use the module more than once<div class="spacer">
</div>
<br/>
    package MyClass;<br/>
    use Module::Pluggable search_path =&gt; 'MyClass::Filters' sub_name =&gt; 'filters';<br/>
    use Module::Pluggable search_path =&gt; 'MyClass::Plugins' sub_name =&gt; 'plugins';<br/>
<div class="spacer">
</div>
and then later ...<div class="spacer">
</div>
<br/>
    my @filters = $self-&gt;filters;<br/>
    my @plugins = $self-&gt;plugins;<br/>
</div>
<div class="section">
<h1>INNER PACKAGES</h1> If you have, for example, a file  <b>lib/Something/Plugin/Foo.pm</b> that contains package definitions for both &quot;Something::Plugin::Foo&quot; and &quot;Something::Plugin::Bar&quot; then as long as you either have either the  <b>require</b> or <b>instantiate</b> option set then we'll also find &quot;Something::Plugin::Bar&quot;. Nifty!</div>
<div class="section">
<h1>OPTIONS</h1> You can pass a hash of options when importing this module.<div class="spacer">
</div>
The options can be ...<div class="subsection">
<h2>sub_name</h2> The name of the subroutine to create in your namespace.<div class="spacer">
</div>
By default this is 'plugins'</div>
<div class="subsection">
<h2>search_path</h2> An array ref of namespaces to look in.</div>
<div class="subsection">
<h2>search_dirs</h2> An array ref of directorys to look in before @INC.</div>
<div class="subsection">
<h2>instantiate</h2> Call this method on the class. In general this will probably be 'new' but it can be whatever you want. Whatever arguments are passed to 'plugins' will be passed to the method.<div class="spacer">
</div>
The default is 'undef' i.e just return the class name.</div>
<div class="subsection">
<h2>require</h2> Just require the class, don't instantiate (overrides 'instantiate');</div>
<div class="subsection">
<h2>inner</h2> If set to 0 will  <b>not</b> search inner packages. If set to 1 will override &quot;require&quot;.</div>
<div class="subsection">
<h2>only</h2> Takes a string, array ref or regex describing the names of the only plugins to return. Whilst this may seem perverse ... well, it is. But it also makes sense. Trust me.</div>
<div class="subsection">
<h2>except</h2> Similar to &quot;only&quot; it takes a description of plugins to exclude from returning. This is slightly less perverse.</div>
<div class="subsection">
<h2>package</h2> This is for use by extension modules which build on &quot;Module::Pluggable&quot;: passing a &quot;package&quot; option allows you to place the plugin method in a different package other than your own.</div>
<div class="subsection">
<h2>file_regex</h2> By default &quot;Module::Pluggable&quot; only looks for  <i>.pm</i> files.<div class="spacer">
</div>
By supplying a new &quot;file_regex&quot; then you can change this behaviour e.g<div class="spacer">
</div>
<br/>
    file_regex =&gt; qr/\.plugin$/<br/>
</div>
<div class="subsection">
<h2>include_editor_junk</h2> By default &quot;Module::Pluggable&quot; ignores files that look like they were left behind by editors. Currently this means files ending in  <i>~</i> (~), the extensions  <i>.swp</i> or <i>.swo</i>, or files beginning with <i>.#</i>.<div class="spacer">
</div>
Setting &quot;include_editor_junk&quot; changes &quot;Module::Pluggable&quot; so it does not ignore any files it finds.</div>
</div>
<div class="section">
<h1>METHODs</h1><div class="subsection">
<h2>search_path</h2> The method &quot;search_path&quot; is exported into you namespace as well. You can call that at any time to change or replace the search_path.<div class="spacer">
</div>
<br/>
    $self-&gt;search_path( add =&gt; &quot;New::Path&quot; ); # add<br/>
    $self-&gt;search_path( new =&gt; &quot;New::Path&quot; ); # replace<br/>
</div>
</div>
<div class="section">
<h1>FUTURE PLANS</h1> This does everything I need and I can't really think of any other features I want to add. Famous last words of course<div class="spacer">
</div>
Recently tried fixed to find inner packages and to make it 'just work' with PAR but there are still some issues.<div class="spacer">
</div>
However suggestions (and patches) are welcome.</div>
<div class="section">
<h1>AUTHOR</h1> Simon Wistow &lt;simon@thegestalt.org&gt;</div>
<div class="section">
<h1>COPYING</h1> Copyright, 2006 Simon Wistow<div class="spacer">
</div>
Distributed under the same terms as Perl itself.</div>
<div class="section">
<h1>BUGS</h1> None known.</div>
<div class="section">
<h1>SEE ALSO</h1> File::Spec, File::Find, File::Basename, Class::Factory::Util, Module::Pluggable::Ordered</div>
<table class="foot">
<tr>
<td class="foot-date">
2010-12-30</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

