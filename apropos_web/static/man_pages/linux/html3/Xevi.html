<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
XEVI(3)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
XEVI(3)</td>
<td class="head-vol">
X FUNCTIONS</td>
<td class="head-rtitle">
XEVI(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> XeviQueryExtension, XeviQueryVersion, XeviGetVisualInfo - X Extended Visual Information functions</div>
<div class="section">
<h1>SYNOPSIS</h1> #include &lt;X11/extensions/XEVI.h&gt;<div style="height: 1.00em;">
&#160;</div>
Bool XeviQueryExtension (Display *dpy);<div class="spacer">
</div>
Bool XeviQueryVersion (Display *dpy,<br/>
    int *major_version_return,<br/>
    int *minor_version_return);<div class="spacer">
</div>
int XeviGetVisualInfo (Display *dpy, VisualID *visual,<br/>
    int n_visual, ExtendedVisualInfo ** evi_return,<br/>
    int * n_info_return);<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> The X11 Extended Visual Information extension (EVI) allows a client to determine information about core X visuals beyond what the core protocol provides.<div style="height: 1.00em;">
&#160;</div>
The EVI application programming library contains the interfaces described below. With the exception of <b>XeviQueryExtension,</b> if any of these routines are called with a display that does not support the extension, the ExtensionErrorHandler (which can be set with <b>XSetExtensionErrorHandler</b> and functions the same way as <b>XSetErrorHandler</b>) will be called and the function will then return.<div class="spacer">
</div>
<b>XeviQueryExtension</b> returns <b>True</b> if the Extended Visual Information extension is available on the given display. A client must call <b>XeviQueryExtension</b> before calling any other EVI function in order to negotiate a compatible protocol version; otherwise the client will get undefined behavior (EVI may or may not work).<div class="spacer">
</div>
<b>XeviQueryVersion</b> returns <b>True</b> if the request succeeded; the values of the major and minor protocol version supported by the server are returned in <i>major_version_return</i> and <i>minor_version_return.</i><div class="spacer">
</div>
<b>XeviGetVisualInfo</b> returns a list of ExtendedVisualInfo structures that describe visual information beyond that supported by the core protocol. This includes layer information relevant for systems supporting overlays and/or underlay planes, and information that allows applications better to determine the level of hardware support for multiple colormaps. XeviGetVisualInfo returns <b>Success</b> if successful, or an X error otherwise. If the argument <i>visual</i> is NULL, then information for all visuals of all screens is returned. Otherwise, it's a pointer to a list of visuals for which extended visual information is desired. <i>n_visual</i> is the number of elements in the array visual. <i>evi_return</i> returns a pointer to a list of ExtendedVisualInfo. When done, the client should free the list using XFree. <i>n_info_return</i> returns the number of elements in the array evi_return.<div class="spacer">
</div>
The <b>ExtendedVisualInfo</b> structure has the following fields:<br/>
<br/>
VisualID	<i>core_visual_id</i>    <br/>
int 	<i>screen</i>	    	<br/>
int 	<i>level</i> 	    	<br/>
unsigned int	<i>transparency_type</i> <br/>
unsigned int	<i>transparency_value</i> <br/>
unsigned int	<i>min_hw_colormaps</i><br/>
unsigned int	<i>max_hw_colormaps</i><br/>
unsigned int	<i>num_colormap_conflicts</i><br/>
VisualID *  	<i>colormap_conflicts</i><br/>
<div class="spacer">
</div>
The combination of <i>core_visual_id</i> and <i>screen</i> number uniquely specify the visual being described.<div class="spacer">
</div>
<i>level</i> returns the level number for the visual, 0 for normal planes, &gt; 0 for overlays, &lt; 0 for underlays.<div class="spacer">
</div>
<i>transparency_type</i> returns the type of transparency supported by the visual. XEVI_TRANSPARENCY_NONE if there are no transparent pixels, XEVI_TRANSPARENCY_PIXEL if the visual supports a transparent pixel, XEVI_TRANSPARENCY_MASK if the visual supports transparent plane(s).<div class="spacer">
</div>
<i>transparency_value</i> returns the pixel/plane value to set for transparency if transparency_type isn't XEVI_TRANSPARENCY_NONE.<div class="spacer">
</div>
<i>min_hw_colormaps</i> and <i>max_hw_colormaps</i> return the minimum and maximum number of hardware colormaps backing up the visual.<div class="spacer">
</div>
<i>num_colormap_conflicts</i> returns the number of elements in <i>colormap_conflicts.</i> This array returns a list of visuals that may cause conflicts in the use of the hardware colormap. For example, if a 12-bit hardware colormap is overloaded to support 8-bit colormaps, the corresponding 8-bit visuals would conflict with the 12-bit visuals.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>ERRORS</h1> <b>XeviGetVisualInfo</b> will return <i>BadValue</i> if passed an illegal visual ID, <i>BadAccess</i> if the X server does not respond, <i>BadAlloc</i> if there is a memory allocation failure.</div>
<table class="foot">
<tr>
<td class="foot-date">
libXext 1.3.0</td>
<td class="foot-os">
X Version 11</td>
</tr>
</table>
</div>
</body>
</html>

