<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
curl_easy_setopt(3)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
curl_easy_setopt(3)</td>
<td class="head-vol">
libcurl Manual</td>
<td class="head-rtitle">
curl_easy_setopt(3)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> curl_easy_setopt - set options for a curl easy handle</div>
<div class="section">
<h1>SYNOPSIS</h1> #include &lt;curl/curl.h&gt;<div style="height: 1.00em;">
&#160;</div>
CURLcode curl_easy_setopt(CURL *handle, CURLoption option, parameter);</div>
<div class="section">
<h1>DESCRIPTION</h1> curl_easy_setopt() is used to tell libcurl how to behave. By using the appropriate options to  <i>curl_easy_setopt</i>, you can change libcurl's behavior.  All options are set with the  <i>option</i> followed by a  <i>parameter</i>. That parameter can be a <b>long</b>, a <b>function pointer</b>, an  <b>object pointer</b> or a <b>curl_off_t</b>, depending on what the specific option expects. Read this manual carefully as bad input values may cause libcurl to behave badly!  You can only set one option in each function call. A typical application uses many curl_easy_setopt() calls in the setup phase.<div style="height: 1.00em;">
&#160;</div>
Options set with this function call are valid for all forthcoming transfers performed using this  <i>handle</i>.  The options are not in any way reset between transfers, so if you want subsequent transfers with different options, you must change them between the transfers. You can optionally reset all options back to internal default with  <i>curl_easy_reset(3)</i>.<div style="height: 1.00em;">
&#160;</div>
Strings passed to libcurl as 'char *' arguments, are copied by the library; thus the string storage associated to the pointer argument may be overwritten after curl_easy_setopt() returns. Exceptions to this rule are described in the option details below.<div style="height: 1.00em;">
&#160;</div>
Before version 7.17.0, strings were not copied. Instead the user was forced keep them available until libcurl no longer needed them.<div style="height: 1.00em;">
&#160;</div>
The <i>handle</i> is the return code from a <i>curl_easy_init(3)</i> or  <i>curl_easy_duphandle(3)</i> call.</div>
<div class="section">
<h1>BEHAVIOR OPTIONS</h1><dl>
<dt>
CURLOPT_VERBOSE</dt>
<dd>
Set the parameter to 1 to get the library to display a lot of verbose information about its operations. Very useful for libcurl and/or protocol debugging and understanding. The verbose information will be sent to stderr, or the stream set with  <i>CURLOPT_STDERR</i>.<div style="height: 1.00em;">
&#160;</div>
You hardly ever want this set in production use, you will almost always want this when you debug/report problems. Another neat option for debugging is the  <i>CURLOPT_DEBUGFUNCTION</i>.</dd>
</dl>
<dl>
<dt>
CURLOPT_HEADER</dt>
<dd>
A parameter set to 1 tells the library to include the header in the body output. This is only relevant for protocols that actually have headers preceding the data (like HTTP).</dd>
</dl>
<dl>
<dt>
CURLOPT_NOPROGRESS</dt>
<dd>
Pass a long. If set to 1, it tells the library to shut off the progress meter completely. It will also present the  <i>CURLOPT_PROGRESSFUNCTION</i> from getting called.<div style="height: 1.00em;">
&#160;</div>
Future versions of libcurl are likely to not have any built-in progress meter at all.</dd>
</dl>
<dl>
<dt>
CURLOPT_NOSIGNAL</dt>
<dd>
Pass a long. If it is 1, libcurl will not use any functions that install signal handlers or any functions that cause signals to be sent to the process. This option is mainly here to allow multi-threaded unix applications to still set/use all timeout options etc, without risking getting signals. (Added in 7.10)<div style="height: 1.00em;">
&#160;</div>
If this option is set and libcurl has been built with the standard name resolver, timeouts will not occur while the name resolve takes place. Consider building libcurl with c-ares support to enable asynchronous DNS lookups, which enables nice timeouts for name resolves without signals.<div style="height: 1.00em;">
&#160;</div>
Setting <i>CURLOPT_NOSIGNAL</i> to 1 makes libcurl NOT ask the system to ignore SIGPIPE signals, which otherwise are sent by the system when trying to send data to a socket which is closed in the other end. libcurl makes an effort to never cause such SIGPIPEs to trigger, but some operating systems have no way to avoid them and even on those that have there are some corner cases when they may still happen, contrary to our desire. In addition, using  <i>CURLAUTH_NTLM_WB</i> authentication could cause a SIGCHLD signal to be raised.</dd>
</dl>
<dl>
<dt>
CURLOPT_WILDCARDMATCH</dt>
<dd>
Set this option to 1 if you want to transfer multiple files according to a file name pattern. The pattern can be specified as part of the  <i>CURLOPT_URL</i> option, using an fnmatch-like pattern (Shell Pattern Matching) in the last part of URL (file name).<div style="height: 1.00em;">
&#160;</div>
By default, libcurl uses its internal wildcard matching implementation. You can provide your own matching function by the  <i>CURLOPT_FNMATCH_FUNCTION</i> option.<div style="height: 1.00em;">
&#160;</div>
This feature is only supported by the FTP download for now.<div style="height: 1.00em;">
&#160;</div>
A brief introduction of its syntax follows:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl>
<dt>
* - ASTERISK</dt>
<dd>
ftp://example.com/some/path/<b>*.txt</b> (for all txt's from the root directory)</dd>
</dl>
</div>
<div style="margin-left: 5.00ex;">
<dl>
<dt>
? - QUESTION MARK</dt>
<dd>
Question mark matches any (exactly one) character.<div style="height: 1.00em;">
&#160;</div>
ftp://example.com/some/path/<b>photo?.jpeg</b></dd>
</dl>
</div>
<div style="margin-left: 5.00ex;">
<dl>
<dt>
[ - BRACKET EXPRESSION</dt>
<dd>
The left bracket opens a bracket expression. The question mark and asterisk have no special meaning in a bracket expression. Each bracket expression ends by the right bracket and matches exactly one character. Some examples follow:<div style="height: 1.00em;">
&#160;</div>
<b>[a-zA-Z0-9]</b> or <b>[f-gF-G]</b> - character interval<div style="height: 1.00em;">
&#160;</div>
<b>[abc]</b> - character enumeration<div style="height: 1.00em;">
&#160;</div>
<b>[^abc]</b> or <b>[!abc]</b> - negation<div style="height: 1.00em;">
&#160;</div>
<b>[[:</b><i>name</i><b>:]]</b> class expression. Supported classes are  <b>alnum</b>,<b>lower</b>, <b>space</b>, <b>alpha</b>, <b>digit</b>, <b>print</b>,  <b>upper</b>, <b>blank</b>, <b>graph</b>, <b>xdigit</b>.<div style="height: 1.00em;">
&#160;</div>
<b>[][-!^]</b> - special case - matches only '-', ']', '[', '!' or '^'. These characters have no special purpose.<div style="height: 1.00em;">
&#160;</div>
<b>[\[\]\\]</b> - escape syntax. Matches '[', ']' or '\'.<div style="height: 1.00em;">
&#160;</div>
Using the rules above, a file name pattern can be constructed:<div style="height: 1.00em;">
&#160;</div>
ftp://example.com/some/path/<b>[a-z[:upper:]\\].jpeg</b></dd>
</dl>
</div>
<div class="spacer">
</div>
(This was added in 7.21.0)</div>
<div class="section">
<h1>CALLBACK OPTIONS</h1><dl>
<dt>
CURLOPT_WRITEFUNCTION</dt>
<dd>
Function pointer that should match the following prototype: <b>size_t</b>  <b>function( char *ptr, size_t size, size_t nmemb, void *userdata);</b> This function gets called by libcurl as soon as there is data received that needs to be saved. The size of the data pointed to by  <i>ptr</i> is <i>size</i> multiplied with  <i>nmemb</i>, it will not be zero terminated. Return the number of bytes actually taken care of. If that amount differs from the amount passed to your function, it'll signal an error to the library. This will abort the transfer and return  <i>CURLE_WRITE_ERROR</i>.<div style="height: 1.00em;">
&#160;</div>
From 7.18.0, the function can return CURL_WRITEFUNC_PAUSE which then will cause writing to this connection to become paused. See  <i>curl_easy_pause(3)</i> for further details.<div style="height: 1.00em;">
&#160;</div>
This function may be called with zero bytes data if the transferred file is empty.<div style="height: 1.00em;">
&#160;</div>
Set this option to NULL to get the internal default function. The internal default function will write the data to the FILE * given with  <i>CURLOPT_WRITEDATA</i>.<div style="height: 1.00em;">
&#160;</div>
Set the <i>userdata</i> argument with the <i>CURLOPT_WRITEDATA</i> option.<div style="height: 1.00em;">
&#160;</div>
The callback function will be passed as much data as possible in all invokes, but you cannot possibly make any assumptions. It may be one byte, it may be thousands. The maximum amount of data that can be passed to the write callback is defined in the curl.h header file: CURL_MAX_WRITE_SIZE.</dd>
</dl>
<dl>
<dt>
CURLOPT_WRITEDATA</dt>
<dd>
Data pointer to pass to the file write function. If you use the  <i>CURLOPT_WRITEFUNCTION</i> option, this is the pointer you'll get as input. If you don't use a callback, you must pass a 'FILE *' as libcurl will pass this to fwrite() when writing data.<div style="height: 1.00em;">
&#160;</div>
The internal <i>CURLOPT_WRITEFUNCTION</i> will write the data to the FILE * given with this option, or to stdout if this option hasn't been set.<div style="height: 1.00em;">
&#160;</div>
If you're using libcurl as a win32 DLL, you <b>MUST</b> use the  <i>CURLOPT_WRITEFUNCTION</i> if you set this option or you will experience crashes.<div style="height: 1.00em;">
&#160;</div>
This option is also known with the older name <i>CURLOPT_FILE</i>, the name  <i>CURLOPT_WRITEDATA</i> was introduced in 7.9.7.</dd>
</dl>
<dl>
<dt>
CURLOPT_READFUNCTION</dt>
<dd>
Function pointer that should match the following prototype: <b>size_t</b>  <b>function( void *ptr, size_t size, size_t nmemb, void *userdata);</b> This function gets called by libcurl as soon as it needs to read data in order to send it to the peer. The data area pointed at by the pointer  <i>ptr</i> may be filled with at most  <i>size</i> multiplied with <i>nmemb</i> number of bytes. Your function must return the actual number of bytes that you stored in that memory area. Returning 0 will signal end-of-file to the library and cause it to stop the current transfer.<div style="height: 1.00em;">
&#160;</div>
If you stop the current transfer by returning 0 &quot;pre-maturely&quot; (i.e before the server expected it, like when you've said you will upload N bytes and you upload less than N bytes), you may experience that the server &quot;hangs&quot; waiting for the rest of the data that won't come.<div style="height: 1.00em;">
&#160;</div>
The read callback may return <i>CURL_READFUNC_ABORT</i> to stop the current operation immediately, resulting in a  <i>CURLE_ABORTED_BY_CALLBACK</i> error code from the transfer (Added in 7.12.1)<div style="height: 1.00em;">
&#160;</div>
From 7.18.0, the function can return CURL_READFUNC_PAUSE which then will cause reading from this connection to become paused. See  <i>curl_easy_pause(3)</i> for further details.<div style="height: 1.00em;">
&#160;</div>
<b>Bugs</b>: when doing TFTP uploads, you must return the exact amount of data that the callback wants, or it will be considered the final packet by the server end and the transfer will end there.<div style="height: 1.00em;">
&#160;</div>
If you set this callback pointer to NULL, or don't set it at all, the default internal read function will be used. It is doing an fread() on the FILE * userdata set with  <i>CURLOPT_READDATA</i>.</dd>
</dl>
<dl>
<dt>
CURLOPT_READDATA</dt>
<dd>
Data pointer to pass to the file read function. If you use the  <i>CURLOPT_READFUNCTION</i> option, this is the pointer you'll get as input. If you don't specify a read callback but instead rely on the default internal read function, this data must be a valid readable FILE *.<div style="height: 1.00em;">
&#160;</div>
If you're using libcurl as a win32 DLL, you MUST use a  <i>CURLOPT_READFUNCTION</i> if you set this option.<div style="height: 1.00em;">
&#160;</div>
This option was also known by the older name <i>CURLOPT_INFILE</i>, the name  <i>CURLOPT_READDATA</i> was introduced in 7.9.7.</dd>
</dl>
<dl>
<dt>
CURLOPT_IOCTLFUNCTION</dt>
<dd>
Function pointer that should match the <i>curl_ioctl_callback</i> prototype found in  <i>&lt;curl/curl.h&gt;</i>. This function gets called by libcurl when something special I/O-related needs to be done that the library can't do by itself. For now, rewinding the read data stream is the only action it can request. The rewinding of the read data stream may be necessary when doing a HTTP PUT or POST with a multi-pass authentication method.  (Option added in 7.12.3).<div style="height: 1.00em;">
&#160;</div>
Use <i>CURLOPT_SEEKFUNCTION</i> instead to provide seeking!</dd>
</dl>
<dl>
<dt>
CURLOPT_IOCTLDATA</dt>
<dd>
Pass a pointer that will be untouched by libcurl and passed as the 3rd argument in the ioctl callback set with  <i>CURLOPT_IOCTLFUNCTION</i>.  (Option added in 7.12.3)</dd>
</dl>
<dl>
<dt>
CURLOPT_SEEKFUNCTION</dt>
<dd>
Function pointer that should match the following prototype: <i>int</i>  <i>function(void *instream, curl_off_t offset, int origin);</i> This function gets called by libcurl to seek to a certain position in the input stream and can be used to fast forward a file in a resumed upload (instead of reading all uploaded bytes with the normal read function/callback). It is also called to rewind a stream when doing a HTTP PUT or POST with a multi-pass authentication method. The function shall work like &quot;fseek&quot; or &quot;lseek&quot; and accepted SEEK_SET, SEEK_CUR and SEEK_END as argument for origin, although (in 7.18.0) libcurl only passes SEEK_SET. The callback must return 0 (CURL_SEEKFUNC_OK) on success, 1 (CURL_SEEKFUNC_FAIL) to cause the upload operation to fail or 2 (CURL_SEEKFUNC_CANTSEEK) to indicate that while the seek failed, libcurl is free to work around the problem if possible. The latter can sometimes be done by instead reading from the input or similar.<div style="height: 1.00em;">
&#160;</div>
If you forward the input arguments directly to &quot;fseek&quot; or &quot;lseek&quot;, note that the data type for  <i>offset</i> is not the same as defined for curl_off_t on many systems! (Option added in 7.18.0)</dd>
</dl>
<dl>
<dt>
CURLOPT_SEEKDATA</dt>
<dd>
Data pointer to pass to the file read function. If you use the  <i>CURLOPT_SEEKFUNCTION</i> option, this is the pointer you'll get as input. If you don't specify a seek callback, NULL is passed. (Option added in 7.18.0)</dd>
</dl>
<dl>
<dt>
CURLOPT_SOCKOPTFUNCTION</dt>
<dd>
Function pointer that should match the <i>curl_sockopt_callback</i> prototype found in  <i>&lt;curl/curl.h&gt;</i>. This function gets called by libcurl after the socket() call but before the connect() call. The callback's  <i>purpose</i> argument identifies the exact purpose for this particular socket, and currently only one value is supported:  <i>CURLSOCKTYPE_IPCXN</i> for the primary connection (meaning the control connection in the FTP case). Future versions of libcurl may support more purposes. It passes the newly created socket descriptor so additional setsockopt() calls can be done at the user's discretion.  Return 0 (zero) from the callback on success. Return 1 from the callback function to signal an unrecoverable error to the library and it will close the socket and return  <i>CURLE_COULDNT_CONNECT</i>.  (Option added in 7.15.6.)<div style="height: 1.00em;">
&#160;</div>
Added in 7.21.5, the callback function may return  <i>CURL_SOCKOPT_ALREADY_CONNECTED</i>, which tells libcurl that the socket is in fact already connected and then libcurl will not attempt to connect it.</dd>
</dl>
<dl>
<dt>
CURLOPT_SOCKOPTDATA</dt>
<dd>
Pass a pointer that will be untouched by libcurl and passed as the first argument in the sockopt callback set with  <i>CURLOPT_SOCKOPTFUNCTION</i>. (Option added in 7.15.6.)</dd>
</dl>
<dl>
<dt>
CURLOPT_OPENSOCKETFUNCTION</dt>
<dd>
Function pointer that should match the <i>curl_opensocket_callback</i> prototype found in  <i>&lt;curl/curl.h&gt;</i>. This function gets called by libcurl instead of the  <i>socket(2)</i> call. The callback's <i>purpose</i> argument identifies the exact purpose for this particular socket, and currently only one value is supported:  <i>CURLSOCKTYPE_IPCXN</i> for the primary connection (meaning the control connection in the FTP case). Future versions of libcurl may support more purposes. It passes the resolved peer address as a  <i>address</i> argument so the callback can modify the address or refuse to connect at all. The callback function should return the socket or  <i>CURL_SOCKET_BAD</i> in case no connection should be established or any error detected. Any additional  <i>setsockopt(2)</i> calls can be done on the socket at the user's discretion.   <i>CURL_SOCKET_BAD</i> return value from the callback function will signal an unrecoverable error to the library and it will return  <i>CURLE_COULDNT_CONNECT</i>.  This return code can be used for IP address blacklisting.  The default behavior is:<br/>
   return socket(addr-&gt;family, addr-&gt;socktype, addr-&gt;protocol);<br/>
(Option added in 7.17.1.)</dd>
</dl>
<dl>
<dt>
CURLOPT_OPENSOCKETDATA</dt>
<dd>
Pass a pointer that will be untouched by libcurl and passed as the first argument in the opensocket callback set with  <i>CURLOPT_OPENSOCKETFUNCTION</i>. (Option added in 7.17.1.)</dd>
</dl>
<dl>
<dt>
CURLOPT_CLOSESOCKETFUNCTION</dt>
<dd>
Function pointer that should match the <i>curl_closesocket_callback</i> prototype found in  <i>&lt;curl/curl.h&gt;</i>. This function gets called by libcurl instead of the  <i>close(3)</i> or <i>closesocket(3)</i> call when sockets are closed (not for any other file descriptors). This is pretty much the reverse to the  <i>CURLOPT_OPENSOCKETFUNCTION</i> option. Return 0 to signal success and 1 if there was an error.  (Option added in 7.21.7)</dd>
</dl>
<dl>
<dt>
CURLOPT_CLOSESOCKETDATA</dt>
<dd>
Pass a pointer that will be untouched by libcurl and passed as the first argument in the opensocket callback set with  <i>CURLOPT_CLOSESOCKETFUNCTION</i>.  (Option added in 7.21.7)</dd>
</dl>
<dl>
<dt>
CURLOPT_PROGRESSFUNCTION</dt>
<dd>
Function pointer that should match the <i>curl_progress_callback</i> prototype found in  <i>&lt;curl/curl.h&gt;</i>. This function gets called by libcurl instead of its internal equivalent with a frequent interval during operation (roughly once per second or sooner) no matter if data is being transfered or not. Unknown/unused argument values passed to the callback will be set to zero (like if you only download data, the upload size will remain 0). Returning a non-zero value from this callback will cause libcurl to abort the transfer and return  <i>CURLE_ABORTED_BY_CALLBACK</i>.<div style="height: 1.00em;">
&#160;</div>
If you transfer data with the multi interface, this function will not be called during periods of idleness unless you call the appropriate libcurl function that performs transfers.<div style="height: 1.00em;">
&#160;</div>
<i>CURLOPT_NOPROGRESS</i> must be set to 0 to make this function actually get called.</dd>
</dl>
<dl>
<dt>
CURLOPT_PROGRESSDATA</dt>
<dd>
Pass a pointer that will be untouched by libcurl and passed as the first argument in the progress callback set with  <i>CURLOPT_PROGRESSFUNCTION</i>.</dd>
</dl>
<dl>
<dt>
CURLOPT_HEADERFUNCTION</dt>
<dd>
Function pointer that should match the following prototype: <i>size_t</i>  <i>function( void *ptr, size_t size, size_t nmemb, void *userdata);</i>. This function gets called by libcurl as soon as it has received header data. The header callback will be called once for each header and only complete header lines are passed on to the callback. Parsing headers is very easy using this. The size of the data pointed to by  <i>ptr</i> is <i>size</i> multiplied with  <i>nmemb</i>. Do not assume that the header line is zero terminated! The pointer named  <i>userdata</i> is the one you set with the  <i>CURLOPT_WRITEHEADER</i> option. The callback function must return the number of bytes actually taken care of. If that amount differs from the amount passed to your function, it'll signal an error to the library. This will abort the transfer and return  <i>CURL_WRITE_ERROR</i>.<div style="height: 1.00em;">
&#160;</div>
If this option is not set, or if it is set to NULL, but  <i>CURLOPT_HEADERDATA</i> (<i>CURLOPT_WRITEHEADER</i>) is set to anything but NULL, the function used to accept response data will be used instead. That is, it will be the function specified with  <i>CURLOPT_WRITEFUNCTION</i>, or if it is not specified or NULL - the default, stream-writing function.<div style="height: 1.00em;">
&#160;</div>
It's important to note that the callback will be invoked for the headers of all responses received after initiating a request and not just the final response. This includes all responses which occur during authentication negotiation. If you need to operate on only the headers from the final response, you will need to collect headers in the callback yourself and use HTTP status lines, for example, to delimit response boundaries.<div style="height: 1.00em;">
&#160;</div>
When a server sends a chunked encoded transfer, it may contain a trailer. That trailer is identical to a HTTP header and if such a trailer is received it is passed to the application using this callback as well. There are several ways to detect it being a trailer and not an ordinary header: 1) it comes after the response-body. 2) it comes after the final header line (CR LF) 3) a Trailer: header among the regular response-headers mention what header(s) to expect in the trailer.</dd>
</dl>
<dl>
<dt>
CURLOPT_WRITEHEADER</dt>
<dd>
(This option is also known as <b>CURLOPT_HEADERDATA</b>) Pass a pointer to be used to write the header part of the received data to. If you don't use  <i>CURLOPT_WRITEFUNCTION</i> or <i>CURLOPT_HEADERFUNCTION</i> to take care of the writing, this must be a valid FILE * as the internal default will then be a plain fwrite(). See also the  <i>CURLOPT_HEADERFUNCTION</i> option above on how to set a custom get-all-headers callback.</dd>
</dl>
<dl>
<dt>
CURLOPT_DEBUGFUNCTION</dt>
<dd>
Function pointer that should match the following prototype: <i>int</i>  <i>curl_debug_callback (CURL *, curl_infotype, char *, size_t, void *);</i>  <i>CURLOPT_DEBUGFUNCTION</i> replaces the standard debug function used when  <i>CURLOPT_VERBOSE </i> is in effect. This callback receives debug information, as specified with the  <b>curl_infotype</b> argument. This function must return 0.  The data pointed to by the char * passed to this function WILL NOT be zero terminated, but will be exactly of the size as told by the size_t argument.<div style="height: 1.00em;">
&#160;</div>
Available curl_infotype values:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl>
<dt>
CURLINFO_TEXT</dt>
<dd>
The data is informational text.</dd>
</dl>
<dl>
<dt>
CURLINFO_HEADER_IN</dt>
<dd>
The data is header (or header-like) data received from the peer.</dd>
</dl>
<dl>
<dt>
CURLINFO_HEADER_OUT</dt>
<dd>
The data is header (or header-like) data sent to the peer.</dd>
</dl>
<dl>
<dt>
CURLINFO_DATA_IN</dt>
<dd>
The data is protocol data received from the peer.</dd>
</dl>
<dl>
<dt>
CURLINFO_DATA_OUT</dt>
<dd>
The data is protocol data sent to the peer.</dd>
</dl>
</div>
<dl>
<dt>
CURLOPT_DEBUGDATA</dt>
<dd>
Pass a pointer to whatever you want passed in to your  <i>CURLOPT_DEBUGFUNCTION</i> in the last void * argument. This pointer is not used by libcurl, it is only passed to the callback.</dd>
</dl>
<dl>
<dt>
CURLOPT_SSL_CTX_FUNCTION</dt>
<dd>
This option does only function for libcurl powered by OpenSSL. If libcurl was built against another SSL library, this functionality is absent.<div style="height: 1.00em;">
&#160;</div>
Function pointer that should match the following prototype: <b>CURLcode</b>  <b>sslctxfun(CURL *curl, void *sslctx, void *parm);</b> This function gets called by libcurl just before the initialization of an SSL connection after having processed all other SSL related options to give a last chance to an application to modify the behaviour of openssl's ssl initialization. The  <i>sslctx</i> parameter is actually a pointer to an openssl <i>SSL_CTX</i>. If an error is returned no attempt to establish a connection is made and the perform operation will return the error code from this callback function.  Set the  <i>parm</i> argument with the <i>CURLOPT_SSL_CTX_DATA</i> option. This option was introduced in 7.11.0.<div style="height: 1.00em;">
&#160;</div>
This function will get called on all new connections made to a server, during the SSL negotiation. The SSL_CTX pointer will be a new one every time.<div style="height: 1.00em;">
&#160;</div>
To use this properly, a non-trivial amount of knowledge of the openssl libraries is necessary. For example, using this function allows you to use openssl callbacks to add additional validation code for certificates, and even to change the actual URI of an HTTPS request (example used in the lib509 test case).  See also the example section for a replacement of the key, certificate and trust file settings.</dd>
</dl>
<dl>
<dt>
CURLOPT_SSL_CTX_DATA</dt>
<dd>
Data pointer to pass to the ssl context callback set by the option  <i>CURLOPT_SSL_CTX_FUNCTION</i>, this is the pointer you'll get as third parameter, otherwise  <b>NULL</b>. (Added in 7.11.0)</dd>
</dl>
<dl>
<dt>
CURLOPT_CONV_TO_NETWORK_FUNCTION</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
CURLOPT_CONV_FROM_NETWORK_FUNCTION</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
CURLOPT_CONV_FROM_UTF8_FUNCTION</dt>
<dd>
Function pointers that should match the following prototype: CURLcode function(char *ptr, size_t length);<div style="height: 1.00em;">
&#160;</div>
These three options apply to non-ASCII platforms only.  They are available only if  <b>CURL_DOES_CONVERSIONS</b> was defined when libcurl was built. When this is the case,  <i>curl_version_info(3)</i> will return the CURL_VERSION_CONV feature bit set.<div style="height: 1.00em;">
&#160;</div>
The data to be converted is in a buffer pointed to by the ptr parameter.  The amount of data to convert is indicated by the length parameter.  The converted data overlays the input data in the buffer pointed to by the ptr parameter. CURLE_OK should be returned upon successful conversion.  A CURLcode return value defined by curl.h, such as CURLE_CONV_FAILED, should be returned if an error was encountered.<div style="height: 1.00em;">
&#160;</div>
<b>CURLOPT_CONV_TO_NETWORK_FUNCTION</b> and  <b>CURLOPT_CONV_FROM_NETWORK_FUNCTION</b> convert between the host encoding and the network encoding.  They are used when commands or ASCII data are sent/received over the network.<div style="height: 1.00em;">
&#160;</div>
<b>CURLOPT_CONV_FROM_UTF8_FUNCTION</b> is called to convert from UTF8 into the host encoding.  It is required only for SSL processing.<div style="height: 1.00em;">
&#160;</div>
If you set a callback pointer to NULL, or don't set it at all, the built-in libcurl iconv functions will be used.  If HAVE_ICONV was not defined when libcurl was built, and no callback has been established, conversion will return the CURLE_CONV_REQD error code.<div style="height: 1.00em;">
&#160;</div>
If HAVE_ICONV is defined, CURL_ICONV_CODESET_OF_HOST must also be defined. For example:<div style="height: 1.00em;">
&#160;</div>
<br/>
 #define CURL_ICONV_CODESET_OF_HOST &quot;IBM-1047&quot;<div style="height: 1.00em;">
&#160;</div>
The iconv code in libcurl will default the network and UTF8 codeset names as follows:<div style="height: 1.00em;">
&#160;</div>
<br/>
 #define CURL_ICONV_CODESET_OF_NETWORK &quot;ISO8859-1&quot;<div style="height: 1.00em;">
&#160;</div>
<br/>
 #define CURL_ICONV_CODESET_FOR_UTF8   &quot;UTF-8&quot;<div style="height: 1.00em;">
&#160;</div>
You will need to override these definitions if they are different on your system.</dd>
</dl>
<dl>
<dt>
CURLOPT_INTERLEAVEFUNCTION</dt>
<dd>
Function pointer that should match the following prototype: <i>size_t</i>  <i>function( void *ptr, size_t size, size_t nmemb, void *userdata)</i>. This function gets called by libcurl as soon as it has received interleaved RTP data. This function gets called for each $ block and therefore contains exactly one upper-layer protocol unit (e.g.  one RTP packet). Curl writes the interleaved header as well as the included data for each call. The first byte is always an ASCII dollar sign. The dollar sign is followed by a one byte channel identifier and then a 2 byte integer length in network byte order. See  <i>RFC 2326 Section 10.12</i> for more information on how RTP interleaving behaves. If unset or set to NULL, curl will use the default write function.<div style="height: 1.00em;">
&#160;</div>
Interleaved RTP poses some challeneges for the client application. Since the stream data is sharing the RTSP control connection, it is critical to service the RTP in a timely fashion. If the RTP data is not handled quickly, subsequent response processing may become unreasonably delayed and the connection may close. The application may use  <i>CURL_RTSPREQ_RECEIVE</i> to service RTP data when no requests are desired. If the application makes a request, (e.g.   <i>CURL_RTSPREQ_PAUSE</i>) then the response handler will process any pending RTP data before marking the request as finished.  (Added in 7.20.0)</dd>
</dl>
<dl>
<dt>
CURLOPT_INTERLEAVEDATA</dt>
<dd>
This is the userdata pointer that will be passed to  <i>CURLOPT_INTERLEAVEFUNCTION</i> when interleaved RTP data is received. (Added in 7.20.0)</dd>
</dl>
<dl>
<dt>
CURLOPT_CHUNK_BGN_FUNCTION</dt>
<dd>
Function pointer that should match the following prototype: <b>long function</b>  <b>(const void *transfer_info, void *ptr, int remains)</b>. This function gets called by libcurl before a part of the stream is going to be transferred (if the transfer supports chunks).<div style="height: 1.00em;">
&#160;</div>
This callback makes sense only when using the <i>CURLOPT_WILDCARDMATCH</i> option for now.<div style="height: 1.00em;">
&#160;</div>
The target of transfer_info parameter is a &quot;feature depended&quot; structure. For the FTP wildcard download, the target is curl_fileinfo structure (see  <i>curl/curl.h</i>).  The parameter ptr is a pointer given by  <i>CURLOPT_CHUNK_DATA</i>. The parameter remains contains number of chunks remaining per the transfer. If the feature is not available, the parameter has zero value.<div style="height: 1.00em;">
&#160;</div>
Return <i>CURL_CHUNK_BGN_FUNC_OK</i> if everything is fine,  <i>CURL_CHUNK_BGN_FUNC_SKIP</i> if you want to skip the concrete chunk or  <i>CURL_CHUNK_BGN_FUNC_FAIL</i> to tell libcurl to stop if some error occurred. (This was added in 7.21.0)</dd>
</dl>
<dl>
<dt>
CURLOPT_CHUNK_END_FUNCTION</dt>
<dd>
Function pointer that should match the following prototype: <b>long</b>  <b>function(void *ptr)</b>. This function gets called by libcurl as soon as a part of the stream has been transferred (or skipped).<div style="height: 1.00em;">
&#160;</div>
Return <i>CURL_CHUNK_END_FUNC_OK</i> if everything is fine or  <b>CURL_CHUNK_END_FUNC_FAIL</b> to tell the lib to stop if some error occurred. (This was added in 7.21.0)</dd>
</dl>
<dl>
<dt>
CURLOPT_CHUNK_DATA</dt>
<dd>
Pass a pointer that will be untouched by libcurl and passed as the ptr argument to the  <i>CURL_CHUNK_BGN_FUNTION</i> and <i>CURL_CHUNK_END_FUNTION</i>. (This was added in 7.21.0)</dd>
</dl>
<dl>
<dt>
CURLOPT_FNMATCH_FUNCTION</dt>
<dd>
Function pointer that should match <b>int function(void *ptr, const char</b>  <b>*pattern, const char *string)</b> prototype (see <i>curl/curl.h</i>). It is used internally for the wildcard matching feature.<div style="height: 1.00em;">
&#160;</div>
Return <i>CURL_FNMATCHFUNC_MATCH</i> if pattern matches the string,  <i>CURL_FNMATCHFUNC_NOMATCH</i> if not or <i>CURL_FNMATCHFUNC_FAIL</i> if an error occurred.  (This was added in 7.21.0)</dd>
</dl>
<dl>
<dt>
CURLOPT_FNMATCH_DATA</dt>
<dd>
Pass a pointer that will be untouched by libcurl and passed as the ptr argument to the  <i>CURL_FNMATCH_FUNCTION</i>. (This was added in 7.21.0)</dd>
</dl>
</div>
<div class="section">
<h1>ERROR OPTIONS</h1><dl>
<dt>
CURLOPT_ERRORBUFFER</dt>
<dd>
Pass a char * to a buffer that the libcurl may store human readable error messages in. This may be more helpful than just the return code from  <i>curl_easy_perform</i>. The buffer must be at least CURL_ERROR_SIZE big. Although this argument is a 'char *', it does not describe an input string. Therefore the (probably undefined) contents of the buffer is NOT copied by the library. You should keep the associated storage available until libcurl no longer needs it. Failing to do so will cause very odd behavior or even crashes. libcurl will need it until you call  <i>curl_easy_cleanup(3)</i> or you set the same option again to use a different pointer.<div style="height: 1.00em;">
&#160;</div>
Use <i>CURLOPT_VERBOSE</i> and <i>CURLOPT_DEBUGFUNCTION</i> to better debug/trace why errors happen.<div style="height: 1.00em;">
&#160;</div>
If the library does not return an error, the buffer may not have been touched. Do not rely on the contents in those cases.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<dl>
<dt>
CURLOPT_STDERR</dt>
<dd>
Pass a FILE * as parameter. Tell libcurl to use this stream instead of stderr when showing the progress meter and displaying  <i>CURLOPT_VERBOSE</i> data.</dd>
</dl>
<dl>
<dt>
CURLOPT_FAILONERROR</dt>
<dd>
A parameter set to 1 tells the library to fail silently if the HTTP code returned is equal to or larger than 400. The default action would be to return the page normally, ignoring that code.<div style="height: 1.00em;">
&#160;</div>
This method is not fail-safe and there are occasions where non-successful response codes will slip through, especially when authentication is involved (response codes 401 and 407).<div style="height: 1.00em;">
&#160;</div>
You might get some amounts of headers transferred before this situation is detected, like when a &quot;100-continue&quot; is received as a response to a POST/PUT and a 401 or 407 is received immediately afterwards.</dd>
</dl>
</div>
<div class="section">
<h1>NETWORK OPTIONS</h1><dl>
<dt>
CURLOPT_URL</dt>
<dd>
The actual URL to deal with. The parameter should be a char * to a zero terminated string.<div style="height: 1.00em;">
&#160;</div>
If the given URL lacks the protocol part (&quot;http://&quot; or &quot;ftp://&quot; etc), it will attempt to guess which protocol to use based on the given host name. If the given protocol of the set URL is not supported, libcurl will return on error ( <i>CURLE_UNSUPPORTED_PROTOCOL</i>) when you call <i>curl_easy_perform(3)</i> or  <i>curl_multi_perform(3)</i>. Use <i>curl_version_info(3)</i> for detailed info on which protocols are supported.<div style="height: 1.00em;">
&#160;</div>
The string given to CURLOPT_URL must be url-encoded and follow RFC 2396 (http://curl.haxx.se/rfc/rfc2396.txt).<div style="height: 1.00em;">
&#160;</div>
Starting with version 7.20.0, the fragment part of the URI will not be send as part of the path, which was the case previously.<div style="height: 1.00em;">
&#160;</div>
<i>CURLOPT_URL</i> is the only option that <b>must</b> be set before  <i>curl_easy_perform(3)</i> is called.<div style="height: 1.00em;">
&#160;</div>
<i>CURLOPT_PROTOCOLS</i> can be used to limit what protocols libcurl will use for this transfer, independent of what libcurl has been compiled to support. That may be useful if you accept the URL from an external source and want to limit the accessibility.</dd>
</dl>
<dl>
<dt>
CURLOPT_PROTOCOLS</dt>
<dd>
Pass a long that holds a bitmask of CURLPROTO_* defines. If used, this bitmask limits what protocols libcurl may use in the transfer. This allows you to have a libcurl built to support a wide range of protocols but still limit specific transfers to only be allowed to use a subset of them. By default libcurl will accept all protocols it supports. See also  <i>CURLOPT_REDIR_PROTOCOLS</i>. (Added in 7.19.4)</dd>
</dl>
<dl>
<dt>
CURLOPT_REDIR_PROTOCOLS</dt>
<dd>
Pass a long that holds a bitmask of CURLPROTO_* defines. If used, this bitmask limits what protocols libcurl may use in a transfer that it follows to in a redirect when  <i>CURLOPT_FOLLOWLOCATION</i> is enabled. This allows you to limit specific transfers to only be allowed to use a subset of protocols in redirections. By default libcurl will allow all protocols except for FILE and SCP. This is a difference compared to pre-7.19.4 versions which unconditionally would follow to all protocols supported. (Added in 7.19.4)</dd>
</dl>
<dl>
<dt>
CURLOPT_PROXY</dt>
<dd>
Set HTTP proxy to use. The parameter should be a char * to a zero terminated string holding the host name or dotted IP address. To specify port number in this string, append :[port] to the end of the host name. The proxy string may be prefixed with [protocol]:// since any such prefix will be ignored. The proxy's port number may optionally be specified with the separate option. If not specified, libcurl will default to using port 1080 for proxies.  <i>CURLOPT_PROXYPORT</i>.<div style="height: 1.00em;">
&#160;</div>
When you tell the library to use an HTTP proxy, libcurl will transparently convert operations to HTTP even if you specify an FTP URL etc. This may have an impact on what other features of the library you can use, such as  <i>CURLOPT_QUOTE</i> and similar FTP specifics that don't work unless you tunnel through the HTTP proxy. Such tunneling is activated with  <i>CURLOPT_HTTPPROXYTUNNEL</i>.<div style="height: 1.00em;">
&#160;</div>
libcurl respects the environment variables <b>http_proxy</b>, <b>ftp_proxy</b>,  <b>all_proxy</b> etc, if any of those are set. The <i>CURLOPT_PROXY</i> option does however override any possibly set environment variables.<div style="height: 1.00em;">
&#160;</div>
Setting the proxy string to &quot;&quot; (an empty string) will explicitly disable the use of a proxy, even if there is an environment variable set for it.<div style="height: 1.00em;">
&#160;</div>
Since 7.14.1, the proxy host string given in environment variables can be specified the exact same way as the proxy can be set with  <i>CURLOPT_PROXY</i>, include protocol prefix (http://) and embedded user + password.<div style="height: 1.00em;">
&#160;</div>
Since 7.21.7, the proxy string may be specified with a protocol:// prefix to specify alternative proxy protocols. Use socks4://, socks4a://, socks5:// or socks5h:// (the last one to enable socks5 and asking the proxy to do the resolving, also known as CURLPROXY_SOCKS5_HOSTNAME type) to request the specific SOCKS version to be used. No protocol specified, http:// and all others will be treated as HTTP proxies.</dd>
</dl>
<dl>
<dt>
CURLOPT_PROXYPORT</dt>
<dd>
Pass a long with this option to set the proxy port to connect to unless it is specified in the proxy string  <i>CURLOPT_PROXY</i>.</dd>
</dl>
<dl>
<dt>
CURLOPT_PROXYTYPE</dt>
<dd>
Pass a long with this option to set type of the proxy. Available options for this are  <i>CURLPROXY_HTTP</i>, <i>CURLPROXY_HTTP_1_0</i> (added in 7.19.4),  <i>CURLPROXY_SOCKS4</i> (added in 7.15.2), <i>CURLPROXY_SOCKS5</i>,  <i>CURLPROXY_SOCKS4A</i> (added in 7.18.0) and <i>CURLPROXY_SOCKS5_HOSTNAME</i> (added in 7.18.0). The HTTP type is default. (Added in 7.10)<div style="height: 1.00em;">
&#160;</div>
If you set <b>CURLOPT_PROXYTYPE</b> to <i>CURLPROXY_HTTP_1_0</i>, it will only affect how libcurl speaks to a proxy when CONNECT is used. The HTTP version used for &quot;regular&quot; HTTP requests is instead controled with  <i>CURLOPT_HTTP_VERSION</i>.</dd>
</dl>
<dl>
<dt>
CURLOPT_NOPROXY</dt>
<dd>
Pass a pointer to a zero terminated string. The should be a comma- separated list of hosts which do not use a proxy, if one is specified.  The only wildcard is a single * character, which matches all hosts, and effectively disables the proxy. Each name in this list is matched as either a domain which contains the hostname, or the hostname itself. For example, local.com would match local.com, local.com:80, and www.local.com, but not www.notlocal.com. (Added in 7.19.4)</dd>
</dl>
<dl>
<dt>
CURLOPT_HTTPPROXYTUNNEL</dt>
<dd>
Set the parameter to 1 to make the library tunnel all operations through a given HTTP proxy. There is a big difference between using a proxy and to tunnel through it. If you don't know what this means, you probably don't want this tunneling option.</dd>
</dl>
<dl>
<dt>
CURLOPT_SOCKS5_GSSAPI_SERVICE</dt>
<dd>
Pass a char * as parameter to a string holding the name of the service. The default service name for a SOCKS5 server is rcmd/server-fqdn. This option allows you to change it. (Added in 7.19.4)</dd>
</dl>
<dl>
<dt>
CURLOPT_SOCKS5_GSSAPI_NEC</dt>
<dd>
Pass a long set to 1 to enable or 0 to disable. As part of the gssapi negotiation a protection mode is negotiated. The rfc1961 says in section 4.3/4.4 it should be protected, but the NEC reference implementation does not. If enabled, this option allows the unprotected exchange of the protection mode negotiation. (Added in 7.19.4).</dd>
</dl>
<dl>
<dt>
CURLOPT_INTERFACE</dt>
<dd>
Pass a char * as parameter. This sets the interface name to use as outgoing network interface. The name can be an interface name, an IP address, or a host name.</dd>
</dl>
<dl>
<dt>
CURLOPT_LOCALPORT</dt>
<dd>
Pass a long. This sets the local port number of the socket used for connection. This can be used in combination with  <i>CURLOPT_INTERFACE</i> and you are recommended to use  <i>CURLOPT_LOCALPORTRANGE</i> as well when this is set. Valid port numbers are 1 - 65535. (Added in 7.15.2)</dd>
</dl>
<dl>
<dt>
CURLOPT_LOCALPORTRANGE</dt>
<dd>
Pass a long. This is the number of attempts libcurl should make to find a working local port number. It starts with the given  <i>CURLOPT_LOCALPORT</i> and adds one to the number for each retry. Setting this to 1 or below will make libcurl do only one try for the exact port number. Port numbers by nature are scarce resources that will be busy at times so setting this value to something too low might cause unnecessary connection setup failures. (Added in 7.15.2)</dd>
</dl>
<dl>
<dt>
CURLOPT_DNS_CACHE_TIMEOUT</dt>
<dd>
Pass a long, this sets the timeout in seconds. Name resolves will be kept in memory for this number of seconds. Set to zero to completely disable caching, or set to -1 to make the cached entries remain forever. By default, libcurl caches this info for 60 seconds.<div style="height: 1.00em;">
&#160;</div>
The name resolve functions of various libc implementations don't re-read name server information unless explicitly told so (for example, by calling  <i>res_init(3)</i>). This may cause libcurl to keep using the older server even if DHCP has updated the server info, and this may look like a DNS cache issue to the casual libcurl-app user.</dd>
</dl>
<dl>
<dt>
CURLOPT_DNS_USE_GLOBAL_CACHE</dt>
<dd>
Pass a long. If the value is 1, it tells curl to use a global DNS cache that will survive between easy handle creations and deletions. This is not thread-safe and this will use a global variable.<div style="height: 1.00em;">
&#160;</div>
<b>WARNING:</b> this option is considered obsolete. Stop using it. Switch over to using the share interface instead! See  <i>CURLOPT_SHARE</i> and  <i>curl_share_init(3)</i>.</dd>
</dl>
<dl>
<dt>
CURLOPT_BUFFERSIZE</dt>
<dd>
Pass a long specifying your preferred size (in bytes) for the receive buffer in libcurl.  The main point of this would be that the write callback gets called more often and with smaller chunks. This is just treated as a request, not an order. You cannot be guaranteed to actually get the given size. (Added in 7.10)<div style="height: 1.00em;">
&#160;</div>
This size is by default set as big as possible (CURL_MAX_WRITE_SIZE), so it only makes sense to use this option if you want it smaller.</dd>
</dl>
<dl>
<dt>
CURLOPT_PORT</dt>
<dd>
Pass a long specifying what remote port number to connect to, instead of the one specified in the URL or the default port for the used protocol.</dd>
</dl>
<dl>
<dt>
CURLOPT_TCP_NODELAY</dt>
<dd>
Pass a long specifying whether the TCP_NODELAY option should be set or cleared (1 = set, 0 = clear). The option is cleared by default. This will have no effect after the connection has been established.<div style="height: 1.00em;">
&#160;</div>
Setting this option will disable TCP's Nagle algorithm. The purpose of this algorithm is to try to minimize the number of small packets on the network (where &quot;small packets&quot; means TCP segments less than the Maximum Segment Size (MSS) for the network).<div style="height: 1.00em;">
&#160;</div>
Maximizing the amount of data sent per TCP segment is good because it amortizes the overhead of the send. However, in some cases (most notably telnet or rlogin) small segments may need to be sent without delay. This is less efficient than sending larger amounts of data at a time, and can contribute to congestion on the network if overdone.</dd>
</dl>
<dl>
<dt>
CURLOPT_ADDRESS_SCOPE</dt>
<dd>
Pass a long specifying the scope_id value to use when connecting to IPv6 link-local or site-local addresses. (Added in 7.19.0)</dd>
</dl>
</div>
<div class="section">
<h1>NAMES and PASSWORDS OPTIONS (Authentication)</h1><dl>
<dt>
CURLOPT_NETRC</dt>
<dd>
This parameter controls the preference of libcurl between using user names and passwords from your  <i>~/.netrc</i> file, relative to user names and passwords in the URL supplied with  <i>CURLOPT_URL</i>.<div style="height: 1.00em;">
&#160;</div>
libcurl uses a user name (and supplied or prompted password) supplied with  <i>CURLOPT_USERPWD</i> in preference to any of the options controlled by this parameter.<div style="height: 1.00em;">
&#160;</div>
Pass a long, set to one of the values described below.</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl>
<dt>
CURL_NETRC_OPTIONAL</dt>
<dd>
The use of your <i>~/.netrc</i> file is optional, and information in the URL is to be preferred.  The file will be scanned for the host and user name (to find the password only) or for the host only, to find the first user name and password after that  <i>machine</i>, which ever information is not specified in the URL.<div style="height: 1.00em;">
&#160;</div>
Undefined values of the option will have this effect.</dd>
</dl>
<dl>
<dt>
CURL_NETRC_IGNORED</dt>
<dd>
The library will ignore the file and use only the information in the URL.<div style="height: 1.00em;">
&#160;</div>
This is the default.</dd>
</dl>
<dl>
<dt>
CURL_NETRC_REQUIRED</dt>
<dd>
This value tells the library that use of the file is required, to ignore the information in the URL, and to search the file for the host only.</dd>
</dl>
</div>
Only machine name, user name and password are taken into account (init macros and similar things aren't supported).<div style="height: 1.00em;">
&#160;</div>
libcurl does not verify that the file has the correct properties set (as the standard Unix ftp client does). It should only be readable by user.<dl>
<dt>
CURLOPT_NETRC_FILE</dt>
<dd>
Pass a char * as parameter, pointing to a zero terminated string containing the full path name to the file you want libcurl to use as .netrc file. If this option is omitted, and  <i>CURLOPT_NETRC</i> is set, libcurl will attempt to find a .netrc file in the current user's home directory. (Added in 7.10.9)</dd>
</dl>
<dl>
<dt>
CURLOPT_USERPWD</dt>
<dd>
Pass a char * as parameter, which should be [user name]:[password] to use for the connection. Use  <i>CURLOPT_HTTPAUTH</i> to decide the authentication method.<div style="height: 1.00em;">
&#160;</div>
When using NTLM, you can set the domain by prepending it to the user name and separating the domain and name with a forward (/) or backward slash (\). Like this: &quot;domain/user:password&quot; or &quot;domain\user:password&quot;. Some HTTP servers (on Windows) support this style even for Basic authentication.<div style="height: 1.00em;">
&#160;</div>
When using HTTP and <i>CURLOPT_FOLLOWLOCATION</i>, libcurl might perform several requests to possibly different hosts. libcurl will only send this user and password information to hosts using the initial host name (unless  <i>CURLOPT_UNRESTRICTED_AUTH</i> is set), so if libcurl follows locations to other hosts it will not send the user and password to those. This is enforced to prevent accidental information leakage.</dd>
</dl>
<dl>
<dt>
CURLOPT_PROXYUSERPWD</dt>
<dd>
Pass a char * as parameter, which should be [user name]:[password] to use for the connection to the HTTP proxy.  Use  <i>CURLOPT_PROXYAUTH</i> to decide the authentication method.</dd>
</dl>
<dl>
<dt>
CURLOPT_USERNAME</dt>
<dd>
Pass a char * as parameter, which should be pointing to the zero terminated user name to use for the transfer.<div style="height: 1.00em;">
&#160;</div>
<b>CURLOPT_USERNAME</b> sets the user name to be used in protocol authentication. You should not use this option together with the (older) CURLOPT_USERPWD option.<div style="height: 1.00em;">
&#160;</div>
In order to specify the password to be used in conjunction with the user name use the  <i>CURLOPT_PASSWORD</i> option.  (Added in 7.19.1)</dd>
</dl>
<dl>
<dt>
CURLOPT_PASSWORD</dt>
<dd>
Pass a char * as parameter, which should be pointing to the zero terminated password to use for the transfer.<div style="height: 1.00em;">
&#160;</div>
The CURLOPT_PASSWORD option should be used in conjunction with the  <i>CURLOPT_USERNAME</i> option. (Added in 7.19.1)</dd>
</dl>
<dl>
<dt>
CURLOPT_PROXYUSERNAME</dt>
<dd>
Pass a char * as parameter, which should be pointing to the zero terminated user name to use for the transfer while connecting to Proxy.<div style="height: 1.00em;">
&#160;</div>
The CURLOPT_PROXYUSERNAME option should be used in same way as the  <i>CURLOPT_PROXYUSERPWD</i> is used.  In comparison to  <i>CURLOPT_PROXYUSERPWD</i> the CURLOPT_PROXYUSERNAME allows the username to contain a colon, like in the following example: &quot;sip:user@example.com&quot;. The CURLOPT_PROXYUSERNAME option is an alternative way to set the user name while connecting to Proxy.  There is no meaning to use it together with the  <i>CURLOPT_PROXYUSERPWD</i> option.<div style="height: 1.00em;">
&#160;</div>
In order to specify the password to be used in conjunction with the user name use the  <i>CURLOPT_PROXYPASSWORD</i> option.  (Added in 7.19.1)</dd>
</dl>
<dl>
<dt>
CURLOPT_PROXYPASSWORD</dt>
<dd>
Pass a char * as parameter, which should be pointing to the zero terminated password to use for the transfer while connecting to Proxy.<div style="height: 1.00em;">
&#160;</div>
The CURLOPT_PROXYPASSWORD option should be used in conjunction with the  <i>CURLOPT_PROXYUSERNAME</i> option. (Added in 7.19.1)</dd>
</dl>
<dl>
<dt>
CURLOPT_HTTPAUTH</dt>
<dd>
Pass a long as parameter, which is set to a bitmask, to tell libcurl which authentication method(s) you want it to use. The available bits are listed below. If more than one bit is set, libcurl will first query the site to see which authentication methods it supports and then pick the best one you allow it to use. For some methods, this will induce an extra network round-trip. Set the actual name and password with the  <i>CURLOPT_USERPWD</i> option or with the  <i>CURLOPT_USERNAME</i> and the <i>CURLOPT_PASSWORD</i> options. (Added in 7.10.6)</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl>
<dt>
CURLAUTH_BASIC</dt>
<dd>
HTTP Basic authentication. This is the default choice, and the only method that is in wide-spread use and supported virtually everywhere. This sends the user name and password over the network in plain text, easily captured by others.</dd>
</dl>
<dl>
<dt>
CURLAUTH_DIGEST</dt>
<dd>
HTTP Digest authentication.  Digest authentication is defined in RFC2617 and is a more secure way to do authentication over public networks than the regular old-fashioned Basic method.</dd>
</dl>
<dl>
<dt>
CURLAUTH_DIGEST_IE</dt>
<dd>
HTTP Digest authentication with an IE flavor.  Digest authentication is defined in RFC2617 and is a more secure way to do authentication over public networks than the regular old-fashioned Basic method. The IE flavor is simply that libcurl will use a special &quot;quirk&quot; that IE is known to have used before version 7 and that some servers require the client to use. (This define was added in 7.19.3)</dd>
</dl>
<dl>
<dt>
CURLAUTH_GSSNEGOTIATE</dt>
<dd>
HTTP GSS-Negotiate authentication. The GSS-Negotiate (also known as plain &quot;Negotiate&quot;) method was designed by Microsoft and is used in their web applications. It is primarily meant as a support for Kerberos5 authentication but may also be used along with other authentication methods. For more information see IETF draft draft-brezak-spnego-http-04.txt.<div style="height: 1.00em;">
&#160;</div>
You need to build libcurl with a suitable GSS-API library for this to work.</dd>
</dl>
<dl>
<dt>
CURLAUTH_NTLM</dt>
<dd>
HTTP NTLM authentication. A proprietary protocol invented and used by Microsoft. It uses a challenge-response and hash concept similar to Digest, to prevent the password from being eavesdropped.<div style="height: 1.00em;">
&#160;</div>
You need to build libcurl with OpenSSL support for this option to work, or build libcurl on Windows.</dd>
</dl>
<dl>
<dt>
CURLAUTH_NTLM_WB</dt>
<dd>
NTLM delegating to winbind helper. Authentication is performed by a separate binary application that is executed when needed. The name of the application is specified at compile time but is typically /usr/bin/ntlm_auth (Added in 7.22.0)<div style="height: 1.00em;">
&#160;</div>
Note that libcurl will fork when necessary to run the winbind application and kill it when complete, calling waitpid() to await its exit when done. On POSIX operating systems, killing the process will cause a SIGCHLD signal to be raised (regardless of whether  <i>CURLOPT_NOSIGNAL</i> is set), which must be handled intelligently by the application. In particular, the application must not unconditionally call wait() in its SIGCHLD signal handler to avoid being subject to a race condition.  This behavior is subject to change in future versions of libcurl.</dd>
</dl>
<dl>
<dt>
CURLAUTH_ANY</dt>
<dd>
This is a convenience macro that sets all bits and thus makes libcurl pick any it finds suitable. libcurl will automatically select the one it finds most secure.</dd>
</dl>
<dl>
<dt>
CURLAUTH_ANYSAFE</dt>
<dd>
This is a convenience macro that sets all bits except Basic and thus makes libcurl pick any it finds suitable. libcurl will automatically select the one it finds most secure.</dd>
</dl>
<dl>
<dt>
CURLAUTH_ONLY</dt>
<dd>
This is a meta symbol. Or this value together with a single specific auth value to force libcurl to probe for un-restricted auth and if not, only that single auth algorithm is acceptable. (Added in 7.21.3)</dd>
</dl>
</div>
<dl>
<dt>
CURLOPT_TLSAUTH_TYPE</dt>
<dd>
Pass a long as parameter, which is set to a bitmask, to tell libcurl which authentication method(s) you want it to use for TLS authentication.</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl>
<dt>
CURLOPT_TLSAUTH_SRP</dt>
<dd>
TLS-SRP authentication. Secure Remote Password authentication for TLS is defined in RFC 5054 and provides mutual authentication if both sides have a shared secret. To use TLS-SRP, you must also set the  <i>CURLOPT_TLSAUTH_USERNAME</i> and <i>CURLOPT_TLSAUTH_PASSWORD</i> options.<div style="height: 1.00em;">
&#160;</div>
You need to build libcurl with GnuTLS or OpenSSL with TLS-SRP support for this to work. (Added in 7.21.4)</dd>
</dl>
</div>
<dl>
<dt>
CURLOPT_TLSAUTH_USERNAME</dt>
<dd>
Pass a char * as parameter, which should point to the zero-terminated username to use for the TLS authentication method specified with the  <i>CURLOPT_TLSAUTH_TYPE</i> option. Requires that the  <i>CURLOPT_TLS_PASSWORD</i> option also be set. (Added in 7.21.4)</dd>
</dl>
<dl>
<dt>
CURLOPT_TLSAUTH_PASSWORD</dt>
<dd>
Pass a char * as parameter, which should point to the zero-terminated password to use for the TLS authentication method specified with the  <i>CURLOPT_TLSAUTH_TYPE</i> option. Requires that the  <i>CURLOPT_TLS_USERNAME</i> option also be set. (Added in 7.21.4)</dd>
</dl>
<dl>
<dt>
CURLOPT_PROXYAUTH</dt>
<dd>
Pass a long as parameter, which is set to a bitmask, to tell libcurl which authentication method(s) you want it to use for your proxy authentication.  If more than one bit is set, libcurl will first query the site to see what authentication methods it supports and then pick the best one you allow it to use. For some methods, this will induce an extra network round-trip. Set the actual name and password with the  <i>CURLOPT_PROXYUSERPWD</i> option. The bitmask can be constructed by or'ing together the bits listed above for the  <i>CURLOPT_HTTPAUTH</i> option. As of this writing, only Basic, Digest and NTLM work. (Added in 7.10.7)</dd>
</dl>
</div>
<div class="section">
<h1>HTTP OPTIONS</h1><dl>
<dt>
CURLOPT_AUTOREFERER</dt>
<dd>
Pass a parameter set to 1 to enable this. When enabled, libcurl will automatically set the Referer: field in requests where it follows a Location: redirect.</dd>
</dl>
<dl>
<dt>
CURLOPT_ACCEPT_ENCODING</dt>
<dd>
Sets the contents of the Accept-Encoding: header sent in an HTTP request, and enables decoding of a response when a Content-Encoding: header is received. Three encodings are supported:  <i>identity</i>, which does nothing,  <i>deflate</i> which requests the server to compress its response using the zlib algorithm, and  <i>gzip</i> which requests the gzip algorithm.  If a zero-length string is set, then an Accept-Encoding: header containing all supported encodings is sent.<div style="height: 1.00em;">
&#160;</div>
This is a request, not an order; the server may or may not do it.  This option must be set (to any non-NULL value) or else any unsolicited encoding done by the server is ignored. See the special file lib/README.encoding for details.<div style="height: 1.00em;">
&#160;</div>
(This option was called CURLOPT_ENCODING before 7.21.6)</dd>
</dl>
<dl>
<dt>
CURLOPT_TRANSFER_ENCODING</dt>
<dd>
Adds a request for compressed Transfer Encoding in the outgoing HTTP request. If the server supports this and so desires, it can respond with the HTTP resonse sent using a compressed Transfer-Encoding that will be automatically uncompressed by libcurl on receival.<div style="height: 1.00em;">
&#160;</div>
Transfer-Encoding differs slightly from the Content-Encoding you ask for with  <b>CURLOPT_ACCEPT_ENCODING</b> in that a Transfer-Encoding is strictly meant to be for the transfer and thus MUST be decoded before the data arrives in the client. Traditionally, Transfer-Encoding has been much less used and supported by both HTTP clients and HTTP servers.<div style="height: 1.00em;">
&#160;</div>
(Added in 7.21.6)</dd>
</dl>
<dl>
<dt>
CURLOPT_FOLLOWLOCATION</dt>
<dd>
A parameter set to 1 tells the library to follow any Location: header that the server sends as part of an HTTP header.<div style="height: 1.00em;">
&#160;</div>
This means that the library will re-send the same request on the new location and follow new Location: headers all the way until no more such headers are returned.  <i>CURLOPT_MAXREDIRS</i> can be used to limit the number of redirects libcurl will follow.<div style="height: 1.00em;">
&#160;</div>
Since 7.19.4, libcurl can limit what protocols it will automatically follow. The accepted protocols are set with  <i>CURLOPT_REDIR_PROTOCOLS</i> and it excludes the FILE protocol by default.</dd>
</dl>
<dl>
<dt>
CURLOPT_UNRESTRICTED_AUTH</dt>
<dd>
A parameter set to 1 tells the library it can continue to send authentication (user+password) when following locations, even when hostname changed. This option is meaningful only when setting  <i>CURLOPT_FOLLOWLOCATION</i>.</dd>
</dl>
<dl>
<dt>
CURLOPT_MAXREDIRS</dt>
<dd>
Pass a long. The set number will be the redirection limit. If that many redirections have been followed, the next redirect will cause an error ( <i>CURLE_TOO_MANY_REDIRECTS</i>). This option only makes sense if the  <i>CURLOPT_FOLLOWLOCATION</i> is used at the same time. Added in 7.15.1: Setting the limit to 0 will make libcurl refuse any redirect. Set it to -1 for an infinite number of redirects (which is the default)</dd>
</dl>
<dl>
<dt>
CURLOPT_POSTREDIR</dt>
<dd>
Pass a bitmask to control how libcurl acts on redirects after POSTs that get a 301 or 302 response back.  A parameter with bit 0 set (value  <b>CURL_REDIR_POST_301</b>) tells the library to respect RFC 2616/10.3.2 and not convert POST requests into GET requests when following a 301 redirection. Setting bit 1 (value CURL_REDIR_POST_302) makes libcurl maintain the request method after a 302 redirect. CURL_REDIR_POST_ALL is a convenience define that sets both bits.<div style="height: 1.00em;">
&#160;</div>
The non-RFC behaviour is ubiquitous in web browsers, so the library does the conversion by default to maintain consistency. However, a server may require a POST to remain a POST after such a redirection. This option is meaningful only when setting  <i>CURLOPT_FOLLOWLOCATION</i>.  (Added in 7.17.1) (This option was known as CURLOPT_POST301 up to 7.19.0 as it only supported the 301 way before then)</dd>
</dl>
<dl>
<dt>
CURLOPT_PUT</dt>
<dd>
A parameter set to 1 tells the library to use HTTP PUT to transfer data. The data should be set with  <i>CURLOPT_READDATA</i> and <i>CURLOPT_INFILESIZE</i>.<div style="height: 1.00em;">
&#160;</div>
This option is deprecated and starting with version 7.12.1 you should instead use  <i>CURLOPT_UPLOAD</i>.</dd>
</dl>
<dl>
<dt>
CURLOPT_POST</dt>
<dd>
A parameter set to 1 tells the library to do a regular HTTP post. This will also make the library use a &quot;Content-Type: application/x-www-form-urlencoded&quot; header. (This is by far the most commonly used POST method).<div style="height: 1.00em;">
&#160;</div>
Use one of <i>CURLOPT_POSTFIELDS</i> or <i>CURLOPT_COPYPOSTFIELDS</i> options to specify what data to post and  <i>CURLOPT_POSTFIELDSIZE</i> or  <i>CURLOPT_POSTFIELDSIZE_LARGE</i> to set the data size.<div style="height: 1.00em;">
&#160;</div>
Optionally, you can provide data to POST using the <i>CURLOPT_READFUNCTION</i> and  <i>CURLOPT_READDATA</i> options but then you must make sure to not set  <i>CURLOPT_POSTFIELDS</i> to anything but NULL. When providing data with a callback, you must transmit it using chunked transfer-encoding or you must set the size of the data with the  <i>CURLOPT_POSTFIELDSIZE</i> or  <i>CURLOPT_POSTFIELDSIZE_LARGE</i> option. To enable chunked encoding, you simply pass in the appropriate Transfer-Encoding header, see the post-callback.c example.<div style="height: 1.00em;">
&#160;</div>
You can override the default POST Content-Type: header by setting your own with  <i>CURLOPT_HTTPHEADER</i>.<div style="height: 1.00em;">
&#160;</div>
Using POST with HTTP 1.1 implies the use of a &quot;Expect: 100-continue&quot; header. You can disable this header with  <i>CURLOPT_HTTPHEADER</i> as usual.<div style="height: 1.00em;">
&#160;</div>
If you use POST to a HTTP 1.1 server, you can send data without knowing the size before starting the POST if you use chunked encoding. You enable this by adding a header like &quot;Transfer-Encoding: chunked&quot; with  <i>CURLOPT_HTTPHEADER</i>. With HTTP 1.0 or without chunked transfer, you must specify the size in the request.<div style="height: 1.00em;">
&#160;</div>
When setting <i>CURLOPT_POST</i> to 1, it will automatically set  <i>CURLOPT_NOBODY</i> to 0 (since 7.14.1).<div style="height: 1.00em;">
&#160;</div>
If you issue a POST request and then want to make a HEAD or GET using the same re-used handle, you must explicitly set the new request type using  <i>CURLOPT_NOBODY</i> or <i>CURLOPT_HTTPGET</i> or similar.</dd>
</dl>
<dl>
<dt>
CURLOPT_POSTFIELDS</dt>
<dd>
Pass a void * as parameter, which should be the full data to post in an HTTP POST operation. You must make sure that the data is formatted the way you want the server to receive it. libcurl will not convert or encode it for you. Most web servers will assume this data to be url-encoded.<div style="height: 1.00em;">
&#160;</div>
The pointed data are NOT copied by the library: as a consequence, they must be preserved by the calling application until the transfer finishes.<div style="height: 1.00em;">
&#160;</div>
This POST is a normal application/x-www-form-urlencoded kind (and libcurl will set that Content-Type by default when this option is used), which is the most commonly used one by HTML forms. See also the  <i>CURLOPT_POST</i>. Using  <i>CURLOPT_POSTFIELDS</i> implies <i>CURLOPT_POST</i>.<div style="height: 1.00em;">
&#160;</div>
If you want to do a zero-byte POST, you need to set  <i>CURLOPT_POSTFIELDSIZE</i> explicitly to zero, as simply setting  <i>CURLOPT_POSTFIELDS</i> to NULL or &quot;&quot; just effectively disables the sending of the specified string. libcurl will instead assume that you'll send the POST data using the read callback!<div style="height: 1.00em;">
&#160;</div>
Using POST with HTTP 1.1 implies the use of a &quot;Expect: 100-continue&quot; header. You can disable this header with  <i>CURLOPT_HTTPHEADER</i> as usual.<div style="height: 1.00em;">
&#160;</div>
To make multipart/formdata posts (aka RFC2388-posts), check out the  <i>CURLOPT_HTTPPOST</i> option.</dd>
</dl>
<dl>
<dt>
CURLOPT_POSTFIELDSIZE</dt>
<dd>
If you want to post data to the server without letting libcurl do a strlen() to measure the data size, this option must be used. When this option is used you can post fully binary data, which otherwise is likely to fail. If this size is set to -1, the library will use strlen() to get the size.</dd>
</dl>
<dl>
<dt>
CURLOPT_POSTFIELDSIZE_LARGE</dt>
<dd>
Pass a curl_off_t as parameter. Use this to set the size of the  <i>CURLOPT_POSTFIELDS</i> data to prevent libcurl from doing strlen() on the data to figure out the size. This is the large file version of the  <i>CURLOPT_POSTFIELDSIZE</i> option. (Added in 7.11.1)</dd>
</dl>
<dl>
<dt>
CURLOPT_COPYPOSTFIELDS</dt>
<dd>
Pass a char * as parameter, which should be the full data to post in an HTTP POST operation. It behaves as the  <i>CURLOPT_POSTFIELDS</i> option, but the original data are copied by the library, allowing the application to overwrite the original data after setting this option.<div style="height: 1.00em;">
&#160;</div>
Because data are copied, care must be taken when using this option in conjunction with  <i>CURLOPT_POSTFIELDSIZE</i> or  <i>CURLOPT_POSTFIELDSIZE_LARGE</i>: If the size has not been set prior to  <i>CURLOPT_COPYPOSTFIELDS</i>, the data are assumed to be a NUL-terminated string; else the stored size informs the library about the data byte count to copy. In any case, the size must not be changed after  <i>CURLOPT_COPYPOSTFIELDS</i>, unless another <i>CURLOPT_POSTFIELDS</i> or  <i>CURLOPT_COPYPOSTFIELDS</i> option is issued. (Added in 7.17.1)</dd>
</dl>
<dl>
<dt>
CURLOPT_HTTPPOST</dt>
<dd>
Tells libcurl you want a multipart/formdata HTTP POST to be made and you instruct what data to pass on to the server.  Pass a pointer to a linked list of curl_httppost structs as parameter.  The easiest way to create such a list, is to use  <i>curl_formadd(3)</i> as documented. The data in this list must remain intact until you close this curl handle again with  <i>curl_easy_cleanup(3)</i>.<div style="height: 1.00em;">
&#160;</div>
Using POST with HTTP 1.1 implies the use of a &quot;Expect: 100-continue&quot; header. You can disable this header with  <i>CURLOPT_HTTPHEADER</i> as usual.<div style="height: 1.00em;">
&#160;</div>
When setting <i>CURLOPT_HTTPPOST</i>, it will automatically set  <i>CURLOPT_NOBODY</i> to 0 (since 7.14.1).</dd>
</dl>
<dl>
<dt>
CURLOPT_REFERER</dt>
<dd>
Pass a pointer to a zero terminated string as parameter. It will be used to set the Referer: header in the http request sent to the remote server. This can be used to fool servers or scripts. You can also set any custom header with  <i>CURLOPT_HTTPHEADER</i>.</dd>
</dl>
<dl>
<dt>
CURLOPT_USERAGENT</dt>
<dd>
Pass a pointer to a zero terminated string as parameter. It will be used to set the User-Agent: header in the http request sent to the remote server. This can be used to fool servers or scripts. You can also set any custom header with  <i>CURLOPT_HTTPHEADER</i>.</dd>
</dl>
<dl>
<dt>
CURLOPT_HTTPHEADER</dt>
<dd>
Pass a pointer to a linked list of HTTP headers to pass to the server in your HTTP request. The linked list should be a fully valid list of  <b>struct</b>  <b>curl_slist</b> structs properly filled in. Use <i>curl_slist_append(3)</i> to create the list and  <i>curl_slist_free_all(3)</i> to clean up an entire list. If you add a header that is otherwise generated and used by libcurl internally, your added one will be used instead. If you add a header with no content as in 'Accept:' (no data on the right side of the colon), the internally used header will get disabled. Thus, using this option you can add new headers, replace internal headers and remove internal headers. To add a header with no content, make the content be two quotes: &quot;&quot;. The headers included in the linked list must not be CRLF-terminated, because curl adds CRLF after each header item. Failure to comply with this will result in strange bugs because the server will most likely ignore part of the headers you specified.<div style="height: 1.00em;">
&#160;</div>
The first line in a request (containing the method, usually a GET or POST) is not a header and cannot be replaced using this option. Only the lines following the request-line are headers. Adding this method line in this list of headers will only cause your request to send an invalid header.<div style="height: 1.00em;">
&#160;</div>
Pass a NULL to this to reset back to no custom headers.<div style="height: 1.00em;">
&#160;</div>
The most commonly replaced headers have &quot;shortcuts&quot; in the options  <i>CURLOPT_COOKIE</i>, <i>CURLOPT_USERAGENT</i> and <i>CURLOPT_REFERER</i>.</dd>
</dl>
<dl>
<dt>
CURLOPT_HTTP200ALIASES</dt>
<dd>
Pass a pointer to a linked list of aliases to be treated as valid HTTP 200 responses.  Some servers respond with a custom header response line.  For example, IceCast servers respond with &quot;ICY 200 OK&quot;.  By including this string in your list of aliases, the response will be treated as a valid HTTP header line such as &quot;HTTP/1.0 200 OK&quot;. (Added in 7.10.3)<div style="height: 1.00em;">
&#160;</div>
The linked list should be a fully valid list of struct curl_slist structs, and be properly filled in.  Use  <i>curl_slist_append(3)</i> to create the list and  <i>curl_slist_free_all(3)</i> to clean up an entire list.<div style="height: 1.00em;">
&#160;</div>
The alias itself is not parsed for any version strings. Before libcurl 7.16.3, Libcurl used the value set by option  <i>CURLOPT_HTTP_VERSION</i>, but starting with 7.16.3 the protocol is assumed to match HTTP 1.0 when an alias matched.</dd>
</dl>
<dl>
<dt>
CURLOPT_COOKIE</dt>
<dd>
Pass a pointer to a zero terminated string as parameter. It will be used to set a cookie in the http request. The format of the string should be NAME=CONTENTS, where NAME is the cookie name and CONTENTS is what the cookie should contain.<div style="height: 1.00em;">
&#160;</div>
If you need to set multiple cookies, you need to set them all using a single option and thus you need to concatenate them all in one single string. Set multiple cookies in one string like this: &quot;name1=content1; name2=content2;&quot; etc.<div style="height: 1.00em;">
&#160;</div>
This option sets the cookie header explicitly in the outgoing request(s). If multiple requests are done due to authentication, followed redirections or similar, they will all get this cookie passed on.<div style="height: 1.00em;">
&#160;</div>
Using this option multiple times will only make the latest string override the previous ones.</dd>
</dl>
<dl>
<dt>
CURLOPT_COOKIEFILE</dt>
<dd>
Pass a pointer to a zero terminated string as parameter. It should contain the name of your file holding cookie data to read. The cookie data may be in Netscape / Mozilla cookie data format or just regular HTTP-style headers dumped to a file.<div style="height: 1.00em;">
&#160;</div>
Given an empty or non-existing file or by passing the empty string (&quot;&quot;), this option will enable cookies for this curl handle, making it understand and parse received cookies and then use matching cookies in future requests.<div style="height: 1.00em;">
&#160;</div>
If you use this option multiple times, you just add more files to read. Subsequent files will add more cookies.</dd>
</dl>
<dl>
<dt>
CURLOPT_COOKIEJAR</dt>
<dd>
Pass a file name as char *, zero terminated. This will make libcurl write all internally known cookies to the specified file when  <i>curl_easy_cleanup(3)</i> is called. If no cookies are known, no file will be created. Specify &quot;-&quot; to instead have the cookies written to stdout. Using this option also enables cookies for this session, so if you for example follow a location it will make matching cookies get sent accordingly.<div style="height: 1.00em;">
&#160;</div>
If the cookie jar file can't be created or written to (when the  <i>curl_easy_cleanup(3)</i> is called), libcurl will not and cannot report an error for this. Using  <i>CURLOPT_VERBOSE</i> or <i>CURLOPT_DEBUGFUNCTION</i> will get a warning to display, but that is the only visible feedback you get about this possibly lethal situation.</dd>
</dl>
<dl>
<dt>
CURLOPT_COOKIESESSION</dt>
<dd>
Pass a long set to 1 to mark this as a new cookie &quot;session&quot;. It will force libcurl to ignore all cookies it is about to load that are &quot;session cookies&quot; from the previous session. By default, libcurl always stores and loads all cookies, independent if they are session cookies or not. Session cookies are cookies without expiry date and they are meant to be alive and existing for this &quot;session&quot; only.</dd>
</dl>
<dl>
<dt>
CURLOPT_COOKIELIST</dt>
<dd>
Pass a char * to a cookie string. Cookie can be either in Netscape / Mozilla format or just regular HTTP-style header (Set-Cookie: ...) format. If cURL cookie engine was not enabled it will enable its cookie engine.  Passing a magic string &quot;ALL&quot; will erase all cookies known by cURL. (Added in 7.14.1) Passing the special string &quot;SESS&quot; will only erase all session cookies known by cURL. (Added in 7.15.4) Passing the special string &quot;FLUSH&quot; will write all cookies known by cURL to the file specified by  <i>CURLOPT_COOKIEJAR</i>. (Added in 7.17.1)</dd>
</dl>
<dl>
<dt>
CURLOPT_HTTPGET</dt>
<dd>
Pass a long. If the long is 1, this forces the HTTP request to get back to GET. Usable if a POST, HEAD, PUT, or a custom request has been used previously using the same curl handle.<div style="height: 1.00em;">
&#160;</div>
When setting <i>CURLOPT_HTTPGET</i> to 1, it will automatically set  <i>CURLOPT_NOBODY</i> to 0 (since 7.14.1).</dd>
</dl>
<dl>
<dt>
CURLOPT_HTTP_VERSION</dt>
<dd>
Pass a long, set to one of the values described below. They force libcurl to use the specific HTTP versions. This is not sensible to do unless you have a good reason.</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl>
<dt>
CURL_HTTP_VERSION_NONE</dt>
<dd>
We don't care about what version the library uses. libcurl will use whatever it thinks fit.</dd>
</dl>
<dl>
<dt>
CURL_HTTP_VERSION_1_0</dt>
<dd>
Enforce HTTP 1.0 requests.</dd>
</dl>
<dl>
<dt>
CURL_HTTP_VERSION_1_1</dt>
<dd>
Enforce HTTP 1.1 requests.</dd>
</dl>
</div>
<dl>
<dt>
CURLOPT_IGNORE_CONTENT_LENGTH</dt>
<dd>
Ignore the Content-Length header. This is useful for Apache 1.x (and similar servers) which will report incorrect content length for files over 2 gigabytes. If this option is used, curl will not be able to accurately report progress, and will simply stop the download when the server ends the connection. (added in 7.14.1)</dd>
</dl>
<dl>
<dt>
CURLOPT_HTTP_CONTENT_DECODING</dt>
<dd>
Pass a long to tell libcurl how to act on content decoding. If set to zero, content decoding will be disabled. If set to 1 it is enabled. Libcurl has no default content decoding but requires you to use  <i>CURLOPT_ENCODING</i> for that. (added in 7.16.2)</dd>
</dl>
<dl>
<dt>
CURLOPT_HTTP_TRANSFER_DECODING</dt>
<dd>
Pass a long to tell libcurl how to act on transfer decoding. If set to zero, transfer decoding will be disabled, if set to 1 it is enabled (default). libcurl does chunked transfer decoding by default unless this option is set to zero. (added in 7.16.2)</dd>
</dl>
</div>
<div class="section">
<h1>SMTP OPTIONS</h1><dl>
<dt>
CURLOPT_MAIL_FROM</dt>
<dd>
Pass a pointer to a zero terminated string as parameter. It will be used to specify the sender address in a mail when sending an SMTP mail with libcurl.<div style="height: 1.00em;">
&#160;</div>
An originator email address in SMTP lingo is specified within angle brackets (&lt;&gt;) which libcurl will not add for you before version 7.21.4. Failing to provide such brackets may cause the server to reject your mail.<div style="height: 1.00em;">
&#160;</div>
(Added in 7.20.0)</dd>
</dl>
<dl>
<dt>
CURLOPT_MAIL_RCPT</dt>
<dd>
Pass a pointer to a linked list of recipients to pass to the server in your SMTP mail request.  The linked list should be a fully valid list of  <b>struct</b>  <b>curl_slist</b> structs properly filled in. Use <i>curl_slist_append(3)</i> to create the list and  <i>curl_slist_free_all(3)</i> to clean up an entire list.<div style="height: 1.00em;">
&#160;</div>
Each recipient in SMTP lingo is specified with angle brackets (&lt;&gt;), but should you not use an angle bracket as first letter libcurl will assume you provide a single email address only and enclose that with angle brackets for you.<div style="height: 1.00em;">
&#160;</div>
(Added in 7.20.0)</dd>
</dl>
</div>
<div class="section">
<h1>TFTP OPTIONS</h1><dl>
<dt>
CURLOPT_TFTP_BLKSIZE</dt>
<dd>
Specify block size to use for TFTP data transmission. Valid range as per RFC 2348 is 8-65464 bytes. The default of 512 bytes will be used if this option is not specified. The specified block size will only be used pending support by the remote server. If the server does not return an option acknowledgement or returns an option acknowledgement with no blksize, the default of 512 bytes will be used. (added in 7.19.4)</dd>
</dl>
</div>
<div class="section">
<h1>FTP OPTIONS</h1><dl>
<dt>
CURLOPT_FTPPORT</dt>
<dd>
Pass a pointer to a zero terminated string as parameter. It will be used to get the IP address to use for the FTP PORT instruction. The PORT instruction tells the remote server to connect to our specified IP address. The string may be a plain IP address, a host name, a network interface name (under Unix) or just a '-' symbol to let the library use your system's default IP address. Default FTP operations are passive, and thus won't use PORT.<div style="height: 1.00em;">
&#160;</div>
The address can be followed by a ':' to specify a port, optionally followed by a '-' to specify a port range.  If the port specified is 0, the operating system will pick a free port.  If a range is provided and all ports in the range are not available, libcurl will report CURLE_FTP_PORT_FAILED for the handle.  Invalid port/range settings are ignored.  IPv6 addresses followed by a port or portrange have to be in brackets.  IPv6 addresses without port/range specifier can be in brackets.  (added in 7.19.5)<div style="height: 1.00em;">
&#160;</div>
Examples with specified ports:<div style="height: 1.00em;">
&#160;</div>
<br/>
  eth0:0<br/>
  192.168.1.2:32000-33000<br/>
  curl.se:32123<br/>
  [::1]:1234-4567<br/>
<div style="height: 1.00em;">
&#160;</div>
You disable PORT again and go back to using the passive version by setting this option to NULL.</dd>
</dl>
<dl>
<dt>
CURLOPT_QUOTE</dt>
<dd>
Pass a pointer to a linked list of FTP or SFTP commands to pass to the server prior to your FTP request. This will be done before any other commands are issued (even before the CWD command for FTP). The linked list should be a fully valid list of 'struct curl_slist' structs properly filled in with text strings. Use  <i>curl_slist_append(3)</i> to append strings (commands) to the list, and clear the entire list afterwards with  <i>curl_slist_free_all(3)</i>. Disable this operation again by setting a NULL to this option. When speaking to a FTP server, prefix the command with an asterisk (*) to make libcurl continue even if the command fails as by default libcurl will stop at first failure.<div style="height: 1.00em;">
&#160;</div>
The set of valid FTP commands depends on the server (see RFC959 for a list of mandatory commands).<div style="height: 1.00em;">
&#160;</div>
The valid SFTP commands are: chgrp, chmod, chown, ln, mkdir, pwd, rename, rm, rmdir, symlink (see <b>curl</b>(1)) (SFTP support added in 7.16.3)</dd>
</dl>
<dl>
<dt>
CURLOPT_POSTQUOTE</dt>
<dd>
Pass a pointer to a linked list of FTP or SFTP commands to pass to the server after your FTP transfer request. The commands will only be run if no error occurred. The linked list should be a fully valid list of struct curl_slist structs properly filled in as described for  <i>CURLOPT_QUOTE</i>. Disable this operation again by setting a NULL to this option.</dd>
</dl>
<dl>
<dt>
CURLOPT_PREQUOTE</dt>
<dd>
Pass a pointer to a linked list of FTP commands to pass to the server after the transfer type is set. The linked list should be a fully valid list of struct curl_slist structs properly filled in as described for  <i>CURLOPT_QUOTE</i>. Disable this operation again by setting a NULL to this option. Before version 7.15.6, if you also set  <i>CURLOPT_NOBODY</i> to 1, this option didn't work.</dd>
</dl>
<dl>
<dt>
CURLOPT_DIRLISTONLY</dt>
<dd>
A parameter set to 1 tells the library to just list the names of files in a directory, instead of doing a full directory listing that would include file sizes, dates etc. This works for FTP and SFTP URLs.<div style="height: 1.00em;">
&#160;</div>
This causes an FTP NLST command to be sent on an FTP server.  Beware that some FTP servers list only files in their response to NLST; they might not include subdirectories and symbolic links.<div style="height: 1.00em;">
&#160;</div>
Setting this option to 1 also implies a directory listing even if the URL doesn't end with a slash, which otherwise is necessary.<div style="height: 1.00em;">
&#160;</div>
Do NOT use this option if you also use <i>CURLOPT_WILDCARDMATCH</i> as it will effectively break that feature then.<div style="height: 1.00em;">
&#160;</div>
(This option was known as CURLOPT_FTPLISTONLY up to 7.16.4)</dd>
</dl>
<dl>
<dt>
CURLOPT_APPEND</dt>
<dd>
A parameter set to 1 tells the library to append to the remote file instead of overwrite it. This is only useful when uploading to an FTP site.<div style="height: 1.00em;">
&#160;</div>
(This option was known as CURLOPT_FTPAPPEND up to 7.16.4)</dd>
</dl>
<dl>
<dt>
CURLOPT_FTP_USE_EPRT</dt>
<dd>
Pass a long. If the value is 1, it tells curl to use the EPRT (and LPRT) command when doing active FTP downloads (which is enabled by  <i>CURLOPT_FTPPORT</i>). Using EPRT means that it will first attempt to use EPRT and then LPRT before using PORT, but if you pass zero to this option, it will not try using EPRT or LPRT, only plain PORT. (Added in 7.10.5)<div style="height: 1.00em;">
&#160;</div>
If the server is an IPv6 host, this option will have no effect as of 7.12.3.</dd>
</dl>
<dl>
<dt>
CURLOPT_FTP_USE_EPSV</dt>
<dd>
Pass a long. If the value is 1, it tells curl to use the EPSV command when doing passive FTP downloads (which it always does by default). Using EPSV means that it will first attempt to use EPSV before using PASV, but if you pass zero to this option, it will not try using EPSV, only plain PASV.<div style="height: 1.00em;">
&#160;</div>
If the server is an IPv6 host, this option will have no effect as of 7.12.3.</dd>
</dl>
<dl>
<dt>
CURLOPT_FTP_USE_PRET</dt>
<dd>
Pass a long. If the value is 1, it tells curl to send a PRET command before PASV (and EPSV). Certain FTP servers, mainly drftpd, require this non-standard command for directory listings as well as up and downloads in PASV mode. Has no effect when using the active FTP transfers mode.  (Added in 7.20.0)</dd>
</dl>
<dl>
<dt>
CURLOPT_FTP_CREATE_MISSING_DIRS</dt>
<dd>
Pass a long. If the value is 1, curl will attempt to create any remote directory that it fails to CWD into. CWD is the command that changes working directory. (Added in 7.10.7)<div style="height: 1.00em;">
&#160;</div>
This setting also applies to SFTP-connections. curl will attempt to create the remote directory if it can't obtain a handle to the target-location. The creation will fail if a file of the same name as the directory to create already exists or lack of permissions prevents creation. (Added in 7.16.3)<div style="height: 1.00em;">
&#160;</div>
Starting with 7.19.4, you can also set this value to 2, which will make libcurl retry the CWD command again if the subsequent MKD command fails. This is especially useful if you're doing many simultanoes connections against the same server and they all have this option enabled, as then CWD may first fail but then another connection does MKD before this connection and thus MKD fails but trying CWD works! 7.19.4 also introduced the  <i>CURLFTP_CREATE_DIR</i> and  <i>CURLFTP_CREATE_DIR_RETRY</i> enum names for these arguments.<div style="height: 1.00em;">
&#160;</div>
Before version 7.19.4, libcurl will simply ignore arguments set to 2 and act as if 1 was selected.</dd>
</dl>
<dl>
<dt>
CURLOPT_FTP_RESPONSE_TIMEOUT</dt>
<dd>
Pass a long.  Causes curl to set a timeout period (in seconds) on the amount of time that the server is allowed to take in order to generate a response message for a command before the session is considered hung.  While curl is waiting for a response, this value overrides  <i>CURLOPT_TIMEOUT</i>. It is recommended that if used in conjunction with  <i>CURLOPT_TIMEOUT</i>, you set  <i>CURLOPT_FTP_RESPONSE_TIMEOUT</i> to a value smaller than  <i>CURLOPT_TIMEOUT</i>.  (Added in 7.10.8)</dd>
</dl>
<dl>
<dt>
CURLOPT_FTP_ALTERNATIVE_TO_USER</dt>
<dd>
Pass a char * as parameter, pointing to a string which will be used to authenticate if the usual FTP &quot;USER user&quot; and &quot;PASS password&quot; negotiation fails. This is currently only known to be required when connecting to Tumbleweed's Secure Transport FTPS server using client certificates for authentication. (Added in 7.15.5)</dd>
</dl>
<dl>
<dt>
CURLOPT_FTP_SKIP_PASV_IP</dt>
<dd>
Pass a long. If set to 1, it instructs libcurl to not use the IP address the server suggests in its 227-response to libcurl's PASV command when libcurl connects the data connection. Instead libcurl will re-use the same IP address it already uses for the control connection. But it will use the port number from the 227-response. (Added in 7.14.2)<div style="height: 1.00em;">
&#160;</div>
This option has no effect if PORT, EPRT or EPSV is used instead of PASV.</dd>
</dl>
<dl>
<dt>
CURLOPT_FTPSSLAUTH</dt>
<dd>
Pass a long using one of the values from below, to alter how libcurl issues &quot;AUTH TLS&quot; or &quot;AUTH SSL&quot; when FTP over SSL is activated (see  <i>CURLOPT_USE_SSL</i>). (Added in 7.12.2)</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl>
<dt>
CURLFTPAUTH_DEFAULT</dt>
<dd>
Allow libcurl to decide.</dd>
</dl>
<dl>
<dt>
CURLFTPAUTH_SSL</dt>
<dd>
Try &quot;AUTH SSL&quot; first, and only if that fails try &quot;AUTH TLS&quot;.</dd>
</dl>
<dl>
<dt>
CURLFTPAUTH_TLS</dt>
<dd>
Try &quot;AUTH TLS&quot; first, and only if that fails try &quot;AUTH SSL&quot;.</dd>
</dl>
</div>
<dl>
<dt>
CURLOPT_FTP_SSL_CCC</dt>
<dd>
If enabled, this option makes libcurl use CCC (Clear Command Channel). It shuts down the SSL/TLS layer after authenticating. The rest of the control channel communication will be unencrypted. This allows NAT routers to follow the FTP transaction. Pass a long using one of the values below. (Added in 7.16.1)</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl>
<dt>
CURLFTPSSL_CCC_NONE</dt>
<dd>
Don't attempt to use CCC.</dd>
</dl>
<dl>
<dt>
CURLFTPSSL_CCC_PASSIVE</dt>
<dd>
Do not initiate the shutdown, but wait for the server to do it. Do not send a reply.</dd>
</dl>
<dl>
<dt>
CURLFTPSSL_CCC_ACTIVE</dt>
<dd>
Initiate the shutdown and wait for a reply.</dd>
</dl>
</div>
<dl>
<dt>
CURLOPT_FTP_ACCOUNT</dt>
<dd>
Pass a pointer to a zero-terminated string (or NULL to disable). When an FTP server asks for &quot;account data&quot; after user name and password has been provided, this data is sent off using the ACCT command. (Added in 7.13.0)</dd>
</dl>
<dl>
<dt>
CURLOPT_FTP_FILEMETHOD</dt>
<dd>
Pass a long that should have one of the following values. This option controls what method libcurl should use to reach a file on a FTP(S) server. The argument should be one of the following alternatives:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl>
<dt>
CURLFTPMETHOD_MULTICWD</dt>
<dd>
libcurl does a single CWD operation for each path part in the given URL. For deep hierarchies this means many commands. This is how RFC1738 says it should be done. This is the default but the slowest behavior.</dd>
</dl>
<dl>
<dt>
CURLFTPMETHOD_NOCWD</dt>
<dd>
libcurl does no CWD at all. libcurl will do SIZE, RETR, STOR etc and give a full path to the server for all these commands. This is the fastest behavior.</dd>
</dl>
<dl>
<dt>
CURLFTPMETHOD_SINGLECWD</dt>
<dd>
libcurl does one CWD with the full target directory and then operates on the file &quot;normally&quot; (like in the multicwd case). This is somewhat more standards compliant than 'nocwd' but without the full penalty of 'multicwd'.</dd>
</dl>
</div>
(Added in 7.15.1)</div>
<div class="section">
<h1>RTSP OPTIONS</h1><dl>
<dt>
CURLOPT_RTSP_REQUEST</dt>
<dd>
Tell libcurl what kind of RTSP request to make. Pass one of the following RTSP enum values. Unless noted otherwise, commands require the Session ID to be initialized. (Added in 7.20.0)</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl>
<dt>
CURL_RTSPREQ_OPTIONS</dt>
<dd>
Used to retrieve the available methods of the server. The application is responsbile for parsing and obeying the response.  <b>(The session ID is not</b>  <b>needed for this method.)</b>  (Added in 7.20.0)</dd>
</dl>
<dl>
<dt>
CURL_RTSPREQ_DESCRIBE</dt>
<dd>
Used to get the low level description of a stream. The application should note what formats it understands in the  <i>'Accept:'</i> header. Unless set manually, libcurl will automatically fill in  <i>'Accept:</i>  <i>application/sdp'</i>. Time-condition headers will be added to Describe requests if the  <i>CURLOPT_TIMECONDITION</i> option is active. <b>(The session ID is not</b>  <b>needed for this method)</b>  (Added in 7.20.0)</dd>
</dl>
<dl>
<dt>
CURL_RTSPREQ_ANNOUNCE</dt>
<dd>
When sent by a client, this method changes the description of the session. For example, if a client is using the server to record a meeting, the client can use Announce to inform the server of all the meta-information about the session.  ANNOUNCE acts like an HTTP PUT or POST just like  <i>CURL_RTSPREQ_SET_PARAMETER</i> (Added in 7.20.0)</dd>
</dl>
<dl>
<dt>
CURL_RTSPREQ_SETUP</dt>
<dd>
Setup is used to initialize the transport layer for the session. The application must set the desired Transport options for a session by using the  <i>CURLOPT_RTSP_TRANSPORT</i> option prior to calling setup. If no session ID is currently set with  <i>CURLOPT_RTSP_SESSION_ID</i>, libcurl will extract and use the session ID in the response to this request.  <b>(The session ID is not</b>  <b>needed for this method).</b>  (Added in 7.20.0)</dd>
</dl>
<dl>
<dt>
CURL_RTSPREQ_PLAY</dt>
<dd>
Send a Play command to the server. Use the <i>CURLOPT_RANGE</i> option to modify the playback time (e.g. 'npt=10-15').  (Added in 7.20.0)</dd>
</dl>
<dl>
<dt>
CURL_RTSPREQ_PAUSE</dt>
<dd>
Send a Pause command to the server. Use the <i>CURLOPT_RANGE</i> option with a single value to indicate when the stream should be halted. (e.g. npt='25') (Added in 7.20.0)</dd>
</dl>
<dl>
<dt>
CURL_RTSPREQ_TEARDOWN</dt>
<dd>
This command terminates an RTSP session. Simply closing a connection does not terminate the RTSP session since it is valid to control an RTSP session over different connections.  (Added in 7.20.0)</dd>
</dl>
<dl>
<dt>
CURL_RTSPREQ_GET_PARAMETER</dt>
<dd>
Retrieve a parameter from the server. By default, libcurl will automatically include a  <i>Content-Type: text/parameters</i> header on all non-empty requests unless a custom one is set. GET_PARAMETER acts just like an HTTP PUT or POST (see  <i>CURL_RTSPREQ_SET_PARAMETER</i>). Applications wishing to send a heartbeat message (e.g. in the presence of a server-specified timeout) should send use an empty GET_PARAMETER request. (Added in 7.20.0)</dd>
</dl>
<dl>
<dt>
CURL_RTSPREQ_SET_PARAMETER</dt>
<dd>
Set a parameter on the server. By default, libcurl will automatically include a  <i>Content-Type: text/parameters</i> header unless a custom one is set. The interaction with SET_PARAMTER is much like an HTTP PUT or POST. An application may either use  <i>CURLOPT_UPLOAD</i> with <i>CURLOPT_READDATA</i> like an HTTP PUT, or it may use  <i>CURLOPT_POSTFIELDS</i> like an HTTP POST. No chunked transfers are allowed, so the application must set the  <i>CURLOPT_INFILESIZE</i> in the former and <i>CURLOPT_POSTFIELDSIZE</i> in the latter. Also, there is no use of multi-part POSTs within RTSP. (Added in 7.20.0)</dd>
</dl>
<dl>
<dt>
CURL_RTSPREQ_RECORD</dt>
<dd>
Used to tell the server to record a session. Use the <i>CURLOPT_RANGE</i> option to modify the record time. (Added in 7.20.0)</dd>
</dl>
<dl>
<dt>
CURL_RTSPREQ_RECEIVE</dt>
<dd>
This is a special request because it does not send any data to the server. The application may call this function in order to receive interleaved RTP data. It will return after processing one read buffer of data in order to give the application a chance to run. (Added in 7.20.0)</dd>
</dl>
</div>
<dl>
<dt>
CURLOPT_RTSP_SESSION_ID</dt>
<dd>
Pass a char * as a parameter to set the value of the current RTSP Session ID for the handle. Useful for resuming an in-progress session. Once this value is set to any non-NULL value, libcurl will return  <i>CURLE_RTSP_SESSION_ERROR</i> if ID received from the server does not match. If unset (or set to NULL), libcurl will automatically set the ID the first time the server sets it in a response. (Added in 7.20.0)</dd>
</dl>
<dl>
<dt>
CURLOPT_RTSP_STREAM_URI</dt>
<dd>
Set the stream URI to operate on by passing a char * . For example, a single session may be controlling  <i>rtsp://foo/twister/audio</i> and  <i>rtsp://foo/twister/video</i> and the application can switch to the appropriate stream using this option. If unset, libcurl will default to operating on generic server options by passing '*' in the place of the RTSP Stream URI. This option is distinct from  <i>CURLOPT_URL</i>. When working with RTSP, the  <i>CURLOPT_STREAM_URI</i> indicates what URL to send to the server in the request header while the  <i>CURLOPT_URL</i> indicates where to make the connection to.  (e.g. the  <i>CURLOPT_URL</i> for the above examples might be set to  <i>rtsp://foo/twister</i> (Added in 7.20.0)</dd>
</dl>
<dl>
<dt>
CURLOPT_RTSP_TRANSPORT</dt>
<dd>
Pass a char * to tell libcurl what to pass for the Transport: header for this RTSP session. This is mainly a convenience method to avoid needing to set a custom Transport: header for every SETUP request. The application must set a Transport: header before issuing a SETUP request. (Added in 7.20.0)</dd>
</dl>
<dl>
<dt>
CURLOPT_RTSP_HEADER</dt>
<dd>
This option is simply an alias for <i>CURLOPT_HTTP_HEADER</i>. Use this to replace the standard headers that RTSP and HTTP share. It is also valid to use the shortcuts such as  <i>CURLOPT_USERAGENT</i>. (Added in 7.20.0)</dd>
</dl>
<dl>
<dt>
CURLOPT_RTSP_CLIENT_CSEQ</dt>
<dd>
Manually set the the CSEQ number to issue for the next RTSP request. Useful if the application is resuming a previously broken connection. The CSEQ will increment from this new number henceforth. (Added in 7.20.0)</dd>
</dl>
<dl>
<dt>
CURLOPT_RTSP_SERVER_CSEQ</dt>
<dd>
Manually set the CSEQ number to expect for the next RTSP Server-&gt;Client request.  At the moment, this feature (listening for Server requests) is unimplemented. (Added in 7.20.0)</dd>
</dl>
</div>
<div class="section">
<h1>PROTOCOL OPTIONS</h1><dl>
<dt>
CURLOPT_TRANSFERTEXT</dt>
<dd>
A parameter set to 1 tells the library to use ASCII mode for FTP transfers, instead of the default binary transfer. For win32 systems it does not set the stdout to binary mode. This option can be usable when transferring text data between systems with different views on certain characters, such as newlines or similar.<div style="height: 1.00em;">
&#160;</div>
libcurl does not do a complete ASCII conversion when doing ASCII transfers over FTP. This is a known limitation/flaw that nobody has rectified. libcurl simply sets the mode to ASCII and performs a standard transfer.</dd>
</dl>
<dl>
<dt>
CURLOPT_PROXY_TRANSFER_MODE</dt>
<dd>
Pass a long. If the value is set to 1 (one), it tells libcurl to set the transfer mode (binary or ASCII) for FTP transfers done via an HTTP proxy, by appending ;type=a or ;type=i to the URL. Without this setting, or it being set to 0 (zero, the default),  <i>CURLOPT_TRANSFERTEXT</i> has no effect when doing FTP via a proxy. Beware that not all proxies support this feature.  (Added in 7.18.0)</dd>
</dl>
<dl>
<dt>
CURLOPT_CRLF</dt>
<dd>
Pass a long. If the value is set to 1 (one), libcurl converts Unix newlines to CRLF newlines on transfers. Disable this option again by setting the value to 0 (zero).</dd>
</dl>
<dl>
<dt>
CURLOPT_RANGE</dt>
<dd>
Pass a char * as parameter, which should contain the specified range you want. It should be in the format &quot;X-Y&quot;, where X or Y may be left out. HTTP transfers also support several intervals, separated with commas as in  <i>&quot;X-Y,N-M&quot;</i>. Using this kind of multiple intervals will cause the HTTP server to send the response document in pieces (using standard MIME separation techniques). For RTSP, the formatting of a range should follow RFC 2326 Section 12.29. For RTSP, byte ranges are  <b>not</b> permitted. Instead, ranges should be given in npt, utc, or smpte formats.<div style="height: 1.00em;">
&#160;</div>
Pass a NULL to this option to disable the use of ranges.<div style="height: 1.00em;">
&#160;</div>
Ranges work on HTTP, FTP, FILE (since 7.18.0), and RTSP (since 7.20.0) transfers only.</dd>
</dl>
<dl>
<dt>
CURLOPT_RESUME_FROM</dt>
<dd>
Pass a long as parameter. It contains the offset in number of bytes that you want the transfer to start from. Set this option to 0 to make the transfer start from the beginning (effectively disabling resume). For FTP, set this option to -1 to make the transfer start from the end of the target file (useful to continue an interrupted upload).<div style="height: 1.00em;">
&#160;</div>
When doing uploads with FTP, the resume position is where in the local/source file libcurl should try to resume the upload from and it will then append the source file to the remote target file.</dd>
</dl>
<dl>
<dt>
CURLOPT_RESUME_FROM_LARGE</dt>
<dd>
Pass a curl_off_t as parameter. It contains the offset in number of bytes that you want the transfer to start from. (Added in 7.11.0)</dd>
</dl>
<dl>
<dt>
CURLOPT_CUSTOMREQUEST</dt>
<dd>
Pass a pointer to a zero terminated string as parameter. It will be used instead of GET or HEAD when doing an HTTP request, or instead of LIST or NLST when doing a FTP directory listing. This is useful for doing DELETE or other more or less obscure HTTP requests. Don't do this at will, make sure your server supports the command first.<div style="height: 1.00em;">
&#160;</div>
When you change the request method by setting <b>CURLOPT_CUSTOMREQUEST</b> to something, you don't actually change how libcurl behaves or acts in regards to the particular request method, it will only change the actual string sent in the request.<div style="height: 1.00em;">
&#160;</div>
For example: if you tell libcurl to do a HEAD request, but then change the request to a &quot;GET&quot; with  <b>CURLOPT_CUSTOMREQUEST</b> you'll still see libcurl act as if it sent a HEAD even when it does send a GET.<div style="height: 1.00em;">
&#160;</div>
To switch to a proper HEAD, use <i>CURLOPT_NOBODY</i>, to switch to a proper POST, use  <i>CURLOPT_POST</i> or <i>CURLOPT_POSTFIELDS</i> and so on.<div style="height: 1.00em;">
&#160;</div>
Restore to the internal default by setting this to NULL.<div style="height: 1.00em;">
&#160;</div>
Many people have wrongly used this option to replace the entire request with their own, including multiple headers and POST contents. While that might work in many cases, it will cause libcurl to send invalid requests and it could possibly confuse the remote server badly. Use  <i>CURLOPT_POST</i> and  <i>CURLOPT_POSTFIELDS</i> to set POST data. Use <i>CURLOPT_HTTPHEADER</i> to replace or extend the set of headers sent by libcurl. Use  <i>CURLOPT_HTTP_VERSION</i> to change HTTP version.</dd>
</dl>
<dl>
<dt>
CURLOPT_FILETIME</dt>
<dd>
Pass a long. If it is 1, libcurl will attempt to get the modification date of the remote document in this operation. This requires that the remote server sends the time or replies to a time querying command. The  <i>curl_easy_getinfo(3)</i> function with the <i>CURLINFO_FILETIME</i> argument can be used after a transfer to extract the received time (if any).</dd>
</dl>
<dl>
<dt>
CURLOPT_NOBODY</dt>
<dd>
A parameter set to 1 tells the library to not include the body-part in the output. This is only relevant for protocols that have separate header and body parts. On HTTP(S) servers, this will make libcurl do a HEAD request.<div style="height: 1.00em;">
&#160;</div>
To change request to GET, you should use <i>CURLOPT_HTTPGET</i>. Change request to POST with  <i>CURLOPT_POST</i> etc.</dd>
</dl>
<dl>
<dt>
CURLOPT_INFILESIZE</dt>
<dd>
When uploading a file to a remote site, this option should be used to tell libcurl what the expected size of the infile is. This value should be passed as a long. See also  <i>CURLOPT_INFILESIZE_LARGE</i>.<div style="height: 1.00em;">
&#160;</div>
For uploading using SCP, this option or <i>CURLOPT_INFILESIZE_LARGE</i> is mandatory.<div style="height: 1.00em;">
&#160;</div>
This option does not limit how much data libcurl will actually send, as that is controlled entirely by what the read callback returns.</dd>
</dl>
<dl>
<dt>
CURLOPT_INFILESIZE_LARGE</dt>
<dd>
When uploading a file to a remote site, this option should be used to tell libcurl what the expected size of the infile is.  This value should be passed as a curl_off_t. (Added in 7.11.0)<div style="height: 1.00em;">
&#160;</div>
For uploading using SCP, this option or <i>CURLOPT_INFILESIZE</i> is mandatory.<div style="height: 1.00em;">
&#160;</div>
This option does not limit how much data libcurl will actually send, as that is controlled entirely by what the read callback returns.</dd>
</dl>
<dl>
<dt>
CURLOPT_UPLOAD</dt>
<dd>
A parameter set to 1 tells the library to prepare for an upload. The  <i>CURLOPT_READDATA</i> and <i>CURLOPT_INFILESIZE</i> or  <i>CURLOPT_INFILESIZE_LARGE</i> options are also interesting for uploads. If the protocol is HTTP, uploading means using the PUT request unless you tell libcurl otherwise.<div style="height: 1.00em;">
&#160;</div>
Using PUT with HTTP 1.1 implies the use of a &quot;Expect: 100-continue&quot; header. You can disable this header with  <i>CURLOPT_HTTPHEADER</i> as usual.<div style="height: 1.00em;">
&#160;</div>
If you use PUT to a HTTP 1.1 server, you can upload data without knowing the size before starting the transfer if you use chunked encoding. You enable this by adding a header like &quot;Transfer-Encoding: chunked&quot; with  <i>CURLOPT_HTTPHEADER</i>. With HTTP 1.0 or without chunked transfer, you must specify the size.</dd>
</dl>
<dl>
<dt>
CURLOPT_MAXFILESIZE</dt>
<dd>
Pass a long as parameter. This allows you to specify the maximum size (in bytes) of a file to download. If the file requested is larger than this value, the transfer will not start and CURLE_FILESIZE_EXCEEDED will be returned.<div style="height: 1.00em;">
&#160;</div>
The file size is not always known prior to download, and for such files this option has no effect even if the file transfer ends up being larger than this given limit. This concerns both FTP and HTTP transfers.</dd>
</dl>
<dl>
<dt>
CURLOPT_MAXFILESIZE_LARGE</dt>
<dd>
Pass a curl_off_t as parameter. This allows you to specify the maximum size (in bytes) of a file to download. If the file requested is larger than this value, the transfer will not start and  <i>CURLE_FILESIZE_EXCEEDED</i> will be returned. (Added in 7.11.0)<div style="height: 1.00em;">
&#160;</div>
The file size is not always known prior to download, and for such files this option has no effect even if the file transfer ends up being larger than this given limit. This concerns both FTP and HTTP transfers.</dd>
</dl>
<dl>
<dt>
CURLOPT_TIMECONDITION</dt>
<dd>
Pass a long as parameter. This defines how the <i>CURLOPT_TIMEVALUE</i> time value is treated. You can set this parameter to  <i>CURL_TIMECOND_IFMODSINCE</i> or  <i>CURL_TIMECOND_IFUNMODSINCE</i>. This feature applies to HTTP, FTP, RTSP, and FILE.<div style="height: 1.00em;">
&#160;</div>
The last modification time of a file is not always known and in such instances this feature will have no effect even if the given time condition would not have been met.  <i>curl_easy_getinfo(3)</i> with the  <i>CURLINFO_CONDITION_UNMET</i> option can be used after a transfer to learn if a zero-byte successful &quot;transfer&quot; was due to this condition not matching.</dd>
</dl>
<dl>
<dt>
CURLOPT_TIMEVALUE</dt>
<dd>
Pass a long as parameter. This should be the time in seconds since 1 Jan 1970, and the time will be used in a condition as specified with  <i>CURLOPT_TIMECONDITION</i>.</dd>
</dl>
</div>
<div class="section">
<h1>CONNECTION OPTIONS</h1><dl>
<dt>
CURLOPT_TIMEOUT</dt>
<dd>
Pass a long as parameter containing the maximum time in seconds that you allow the libcurl transfer operation to take. Normally, name lookups can take a considerable time and limiting operations to less than a few minutes risk aborting perfectly normal operations. This option will cause curl to use the SIGALRM to enable time-outing system calls.<div style="height: 1.00em;">
&#160;</div>
In unix-like systems, this might cause signals to be used unless  <i>CURLOPT_NOSIGNAL</i> is set.</dd>
</dl>
<dl>
<dt>
CURLOPT_TIMEOUT_MS</dt>
<dd>
Like <i>CURLOPT_TIMEOUT</i> but takes number of milliseconds instead. If libcurl is built to use the standard system name resolver, that portion of the transfer will still use full-second resolution for timeouts with a minimum timeout allowed of one second. (Added in 7.16.2)</dd>
</dl>
<dl>
<dt>
CURLOPT_LOW_SPEED_LIMIT</dt>
<dd>
Pass a long as parameter. It contains the transfer speed in bytes per second that the transfer should be below during  <i>CURLOPT_LOW_SPEED_TIME</i> seconds for the library to consider it too slow and abort.</dd>
</dl>
<dl>
<dt>
CURLOPT_LOW_SPEED_TIME</dt>
<dd>
Pass a long as parameter. It contains the time in seconds that the transfer should be below the  <i>CURLOPT_LOW_SPEED_LIMIT</i> for the library to consider it too slow and abort.</dd>
</dl>
<dl>
<dt>
CURLOPT_MAX_SEND_SPEED_LARGE</dt>
<dd>
Pass a curl_off_t as parameter.  If an upload exceeds this speed (counted in bytes per second) on cumulative average during the transfer, the transfer will pause to keep the average rate less than or equal to the parameter value. Defaults to unlimited speed. (Added in 7.15.5)</dd>
</dl>
<dl>
<dt>
CURLOPT_MAX_RECV_SPEED_LARGE</dt>
<dd>
Pass a curl_off_t as parameter.  If a download exceeds this speed (counted in bytes per second) on cumulative average during the transfer, the transfer will pause to keep the average rate less than or equal to the parameter value. Defaults to unlimited speed. (Added in 7.15.5)</dd>
</dl>
<dl>
<dt>
CURLOPT_MAXCONNECTS</dt>
<dd>
Pass a long. The set number will be the persistent connection cache size. The set amount will be the maximum amount of simultaneously open connections that libcurl may cache in this easy handle. Default is 5, and there isn't much point in changing this value unless you are perfectly aware of how this works and changes libcurl's behaviour. This concerns connections using any of the protocols that support persistent connections.<div style="height: 1.00em;">
&#160;</div>
When reaching the maximum limit, curl closes the oldest one in the cache to prevent increasing the number of open connections.<div style="height: 1.00em;">
&#160;</div>
If you already have performed transfers with this curl handle, setting a smaller MAXCONNECTS than before may cause open connections to get closed unnecessarily.<div style="height: 1.00em;">
&#160;</div>
If you add this easy handle to a multi handle, this setting is not acknowledged, and you must instead use  <i>curl_multi_setopt(3)</i> and the  <i>CURLMOPT_MAXCONNECTS</i> option.</dd>
</dl>
<dl>
<dt>
CURLOPT_CLOSEPOLICY</dt>
<dd>
(Obsolete) This option does nothing.</dd>
</dl>
<dl>
<dt>
CURLOPT_FRESH_CONNECT</dt>
<dd>
Pass a long. Set to 1 to make the next transfer use a new (fresh) connection by force. If the connection cache is full before this connection, one of the existing connections will be closed as according to the selected or default policy. This option should be used with caution and only if you understand what it does. Set this to 0 to have libcurl attempt re-using an existing connection (default behavior).</dd>
</dl>
<dl>
<dt>
CURLOPT_FORBID_REUSE</dt>
<dd>
Pass a long. Set to 1 to make the next transfer explicitly close the connection when done. Normally, libcurl keeps all connections alive when done with one transfer in case a succeeding one follows that can re-use them. This option should be used with caution and only if you understand what it does. Set to 0 to have libcurl keep the connection open for possible later re-use (default behavior).</dd>
</dl>
<dl>
<dt>
CURLOPT_CONNECTTIMEOUT</dt>
<dd>
Pass a long. It should contain the maximum time in seconds that you allow the connection to the server to take.  This only limits the connection phase, once it has connected, this option is of no more use. Set to zero to disable connection timeout (it will then only timeout on the system's internal timeouts). See also the  <i>CURLOPT_TIMEOUT</i> option.<div style="height: 1.00em;">
&#160;</div>
In unix-like systems, this might cause signals to be used unless  <i>CURLOPT_NOSIGNAL</i> is set.</dd>
</dl>
<dl>
<dt>
CURLOPT_CONNECTTIMEOUT_MS</dt>
<dd>
Like <i>CURLOPT_CONNECTTIMEOUT</i> but takes the number of milliseconds instead. If libcurl is built to use the standard system name resolver, that portion of the connect will still use full-second resolution for timeouts with a minimum timeout allowed of one second. (Added in 7.16.2)</dd>
</dl>
<dl>
<dt>
CURLOPT_IPRESOLVE</dt>
<dd>
Allows an application to select what kind of IP addresses to use when resolving host names. This is only interesting when using host names that resolve addresses using more than one version of IP. The allowed values are:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl>
<dt>
CURL_IPRESOLVE_WHATEVER</dt>
<dd>
Default, resolves addresses to all IP versions that your system allows.</dd>
</dl>
<dl>
<dt>
CURL_IPRESOLVE_V4</dt>
<dd>
Resolve to IPv4 addresses.</dd>
</dl>
<dl>
<dt>
CURL_IPRESOLVE_V6</dt>
<dd>
Resolve to IPv6 addresses.</dd>
</dl>
</div>
<dl>
<dt>
CURLOPT_CONNECT_ONLY</dt>
<dd>
Pass a long. If the parameter equals 1, it tells the library to perform all the required proxy authentication and connection setup, but no data transfer. This option is useful only on HTTP URLs.<div style="height: 1.00em;">
&#160;</div>
This option is useful with the <i>CURLINFO_LASTSOCKET</i> option to  <i>curl_easy_getinfo(3)</i>. The library can set up the connection and then the application can obtain the most recently used socket for special data transfers. (Added in 7.15.2)</dd>
</dl>
<dl>
<dt>
CURLOPT_USE_SSL</dt>
<dd>
Pass a long using one of the values from below, to make libcurl use your desired level of SSL for the transfer. (Added in 7.11.0)<div style="height: 1.00em;">
&#160;</div>
This is for enabling SSL/TLS when you use FTP, SMTP, POP3, IMAP etc.<div style="height: 1.00em;">
&#160;</div>
(This option was known as CURLOPT_FTP_SSL up to 7.16.4, and the constants were known as CURLFTPSSL_*)</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl>
<dt>
CURLUSESSL_NONE</dt>
<dd>
Don't attempt to use SSL.</dd>
</dl>
<dl>
<dt>
CURLUSESSL_TRY</dt>
<dd>
Try using SSL, proceed as normal otherwise.</dd>
</dl>
<dl>
<dt>
CURLUSESSL_CONTROL</dt>
<dd>
Require SSL for the control connection or fail with <i>CURLE_USE_SSL_FAILED</i>.</dd>
</dl>
<dl>
<dt>
CURLUSESSL_ALL</dt>
<dd>
Require SSL for all communication or fail with <i>CURLE_USE_SSL_FAILED</i>.</dd>
</dl>
</div>
<dl>
<dt>
CURLOPT_RESOLVE</dt>
<dd>
Pass a pointer to a linked list of strings with host name resolve information to use for requests with this handle. The linked list should be a fully valid list of  <b>struct curl_slist</b> structs properly filled in. Use  <i>curl_slist_append(3)</i> to create the list and <i>curl_slist_free_all(3)</i> to clean up an entire list.<div style="height: 1.00em;">
&#160;</div>
Each single name resolve string should be written using the format HOST:PORT:ADDRESS where HOST is the name libcurl will try to resolve, PORT is the port number of the service where libcurl wants to connect to the HOST and ADDRESS is the numerical IP address. If libcurl is built to support IPv6, ADDRESS can of course be either IPv4 or IPv6 style addressing.<div style="height: 1.00em;">
&#160;</div>
This option effectively pre-populates the DNS cache with entries for the host+port pair so redirects and everything that operations against the HOST+PORT will instead use your provided ADDRESS.<div style="height: 1.00em;">
&#160;</div>
You can remove names from the DNS cache again, to stop providing these fake resolves, by including a string in the linked list that uses the format &quot;-HOST:PORT&quot;. The host name must be prefixed with a dash, and the host name and port number must exactly match what was already added previously.<div style="height: 1.00em;">
&#160;</div>
(Added in 7.21.3)</dd>
</dl>
</div>
<div class="section">
<h1>SSL and SECURITY OPTIONS</h1><dl>
<dt>
CURLOPT_SSLCERT</dt>
<dd>
Pass a pointer to a zero terminated string as parameter. The string should be the file name of your certificate. The default format is &quot;PEM&quot; and can be changed with  <i>CURLOPT_SSLCERTTYPE</i>.<div style="height: 1.00em;">
&#160;</div>
With NSS this can also be the nickname of the certificate you wish to authenticate with. If you want to use a file from the current directory, please precede it with &quot;./&quot; prefix, in order to avoid confusion with a nickname.</dd>
</dl>
<dl>
<dt>
CURLOPT_SSLCERTTYPE</dt>
<dd>
Pass a pointer to a zero terminated string as parameter. The string should be the format of your certificate. Supported formats are &quot;PEM&quot; and &quot;DER&quot;.  (Added in 7.9.3)</dd>
</dl>
<dl>
<dt>
CURLOPT_SSLKEY</dt>
<dd>
Pass a pointer to a zero terminated string as parameter. The string should be the file name of your private key. The default format is &quot;PEM&quot; and can be changed with  <i>CURLOPT_SSLKEYTYPE</i>.</dd>
</dl>
<dl>
<dt>
CURLOPT_SSLKEYTYPE</dt>
<dd>
Pass a pointer to a zero terminated string as parameter. The string should be the format of your private key. Supported formats are &quot;PEM&quot;, &quot;DER&quot; and &quot;ENG&quot;.<div style="height: 1.00em;">
&#160;</div>
The format &quot;ENG&quot; enables you to load the private key from a crypto engine. In this case  <i>CURLOPT_SSLKEY</i> is used as an identifier passed to the engine. You have to set the crypto engine with  <i>CURLOPT_SSLENGINE</i>. &quot;DER&quot; format key file currently does not work because of a bug in OpenSSL.</dd>
</dl>
<dl>
<dt>
CURLOPT_KEYPASSWD</dt>
<dd>
Pass a pointer to a zero terminated string as parameter. It will be used as the password required to use the  <i>CURLOPT_SSLKEY</i> or  <i>CURLOPT_SSH_PRIVATE_KEYFILE</i> private key. You never needed a pass phrase to load a certificate but you need one to load your private key.<div style="height: 1.00em;">
&#160;</div>
(This option was known as CURLOPT_SSLKEYPASSWD up to 7.16.4 and CURLOPT_SSLCERTPASSWD up to 7.9.2)</dd>
</dl>
<dl>
<dt>
CURLOPT_SSLENGINE</dt>
<dd>
Pass a pointer to a zero terminated string as parameter. It will be used as the identifier for the crypto engine you want to use for your private key.<div style="height: 1.00em;">
&#160;</div>
If the crypto device cannot be loaded, <i>CURLE_SSL_ENGINE_NOTFOUND</i> is returned.</dd>
</dl>
<dl>
<dt>
CURLOPT_SSLENGINE_DEFAULT</dt>
<dd>
Sets the actual crypto engine as the default for (asymmetric) crypto operations.<div style="height: 1.00em;">
&#160;</div>
If the crypto device cannot be set, <i>CURLE_SSL_ENGINE_SETFAILED</i> is returned.<div style="height: 1.00em;">
&#160;</div>
Even though this option doesn't need any parameter, in some configurations  <i>curl_easy_setopt</i> might be defined as a macro taking exactly three arguments. Therefore, it's recommended to pass 1 as parameter to this option.</dd>
</dl>
<dl>
<dt>
CURLOPT_SSLVERSION</dt>
<dd>
Pass a long as parameter to control what version of SSL/TLS to attempt to use. The available options are:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl>
<dt>
CURL_SSLVERSION_DEFAULT</dt>
<dd>
The default action. This will attempt to figure out the remote SSL protocol version, i.e. either SSLv3 or TLSv1 (but not SSLv2, which became disabled by default with 7.18.1).</dd>
</dl>
<dl>
<dt>
CURL_SSLVERSION_TLSv1</dt>
<dd>
Force TLSv1</dd>
</dl>
<dl>
<dt>
CURL_SSLVERSION_SSLv2</dt>
<dd>
Force SSLv2</dd>
</dl>
<dl>
<dt>
CURL_SSLVERSION_SSLv3</dt>
<dd>
Force SSLv3</dd>
</dl>
</div>
<dl>
<dt>
CURLOPT_SSL_VERIFYPEER</dt>
<dd>
Pass a long as parameter. By default, curl assumes a value of 1.<div style="height: 1.00em;">
&#160;</div>
This option determines whether curl verifies the authenticity of the peer's certificate. A value of 1 means curl verifies; 0 (zero) means it doesn't.<div style="height: 1.00em;">
&#160;</div>
When negotiating an SSL connection, the server sends a certificate indicating its identity.  Curl verifies whether the certificate is authentic, i.e. that you can trust that the server is who the certificate says it is.  This trust is based on a chain of digital signatures, rooted in certification authority (CA) certificates you supply.  curl uses a default bundle of CA certificates (the path for that is determined at build time) and you can specify alternate certificates with the  <i>CURLOPT_CAINFO</i> option or the <i>CURLOPT_CAPATH</i> option.<div style="height: 1.00em;">
&#160;</div>
When <i>CURLOPT_SSL_VERIFYPEER</i> is nonzero, and the verification fails to prove that the certificate is authentic, the connection fails.  When the option is zero, the peer certificate verification succeeds regardless.<div style="height: 1.00em;">
&#160;</div>
Authenticating the certificate is not by itself very useful.  You typically want to ensure that the server, as authentically identified by its certificate, is the server you mean to be talking to.  Use  <i>CURLOPT_SSL_VERIFYHOST</i> to control that. The check that the host name in the certificate is valid for the host name you're connecting to is done independently of the  <i>CURLOPT_SSL_VERIFYPEER</i> option.</dd>
</dl>
<dl>
<dt>
CURLOPT_CAINFO</dt>
<dd>
Pass a char * to a zero terminated string naming a file holding one or more certificates to verify the peer with.  This makes sense only when used in combination with the  <i>CURLOPT_SSL_VERIFYPEER</i> option.  If  <i>CURLOPT_SSL_VERIFYPEER</i> is zero, <i>CURLOPT_CAINFO</i> need not even indicate an accessible file.<div style="height: 1.00em;">
&#160;</div>
This option is by default set to the system path where libcurl's cacert bundle is assumed to be stored, as established at build time.<div style="height: 1.00em;">
&#160;</div>
When built against NSS, this is the directory that the NSS certificate database resides in.</dd>
</dl>
<dl>
<dt>
CURLOPT_ISSUERCERT</dt>
<dd>
Pass a char * to a zero terminated string naming a file holding a CA certificate in PEM format. If the option is set, an additional check against the peer certificate is performed to verify the issuer is indeed the one associated with the certificate provided by the option. This additional check is useful in multi-level PKI where one needs to enforce that the peer certificate is from a specific branch of the tree.<div style="height: 1.00em;">
&#160;</div>
This option makes sense only when used in combination with the  <i>CURLOPT_SSL_VERIFYPEER</i> option. Otherwise, the result of the check is not considered as failure.<div style="height: 1.00em;">
&#160;</div>
A specific error code (CURLE_SSL_ISSUER_ERROR) is defined with the option, which is returned if the setup of the SSL/TLS session has failed due to a mismatch with the issuer of peer certificate ( <i>CURLOPT_SSL_VERIFYPEER</i> has to be set too for the check to fail). (Added in 7.19.0)</dd>
</dl>
<dl>
<dt>
CURLOPT_CAPATH</dt>
<dd>
Pass a char * to a zero terminated string naming a directory holding multiple CA certificates to verify the peer with. If libcurl is built against OpenSSL, the certificate directory must be prepared using the openssl c_rehash utility. This makes sense only when used in combination with the  <i>CURLOPT_SSL_VERIFYPEER</i> option.  If <i>CURLOPT_SSL_VERIFYPEER</i> is zero,  <i>CURLOPT_CAPATH</i> need not even indicate an accessible path.  The  <i>CURLOPT_CAPATH</i> function apparently does not work in Windows due to some limitation in openssl. This option is OpenSSL-specific and does nothing if libcurl is built to use GnuTLS. NSS-powered libcurl provides the option only for backward compatibility.</dd>
</dl>
<dl>
<dt>
CURLOPT_CRLFILE</dt>
<dd>
Pass a char * to a zero terminated string naming a file with the concatenation of CRL (in PEM format) to use in the certificate validation that occurs during the SSL exchange.<div style="height: 1.00em;">
&#160;</div>
When curl is built to use NSS or GnuTLS, there is no way to influence the use of CRL passed to help in the verification process. When libcurl is built with OpenSSL support, X509_V_FLAG_CRL_CHECK and X509_V_FLAG_CRL_CHECK_ALL are both set, requiring CRL check against all the elements of the certificate chain if a CRL file is passed.<div style="height: 1.00em;">
&#160;</div>
This option makes sense only when used in combination with the  <i>CURLOPT_SSL_VERIFYPEER</i> option.<div style="height: 1.00em;">
&#160;</div>
A specific error code (CURLE_SSL_CRL_BADFILE) is defined with the option. It is returned when the SSL exchange fails because the CRL file cannot be loaded. A failure in certificate verification due to a revocation information found in the CRL does not trigger this specific error. (Added in 7.19.0)</dd>
</dl>
<dl>
<dt>
CURLOPT_SSL_VERIFYHOST</dt>
<dd>
Pass a long as parameter.<div style="height: 1.00em;">
&#160;</div>
This option determines whether libcurl verifies that the server cert is for the server it is known as.<div style="height: 1.00em;">
&#160;</div>
When negotiating a SSL connection, the server sends a certificate indicating its identity.<div style="height: 1.00em;">
&#160;</div>
When <i>CURLOPT_SSL_VERIFYHOST</i> is 2, that certificate must indicate that the server is the server to which you meant to connect, or the connection fails.<div style="height: 1.00em;">
&#160;</div>
Curl considers the server the intended one when the Common Name field or a Subject Alternate Name field in the certificate matches the host name in the URL to which you told Curl to connect.<div style="height: 1.00em;">
&#160;</div>
When the value is 1, the certificate must contain a Common Name field, but it doesn't matter what name it says.  (This is not ordinarily a useful setting).<div style="height: 1.00em;">
&#160;</div>
When the value is 0, the connection succeeds regardless of the names in the certificate.<div style="height: 1.00em;">
&#160;</div>
The default value for this option is 2.<div style="height: 1.00em;">
&#160;</div>
This option controls checking the server's certificate's claimed identity. The server could be lying.  To control lying, see  <i>CURLOPT_SSL_VERIFYPEER</i>.  If libcurl is built against NSS and  <i>CURLOPT_SSL_VERIFYPEER</i> is zero, <i>CURLOPT_SSL_VERIFYHOST</i> is ignored.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<dl>
<dt>
CURLOPT_CERTINFO</dt>
<dd>
Pass a long set to 1 to enable libcurl's certificate chain info gatherer. With this enabled, libcurl (if built with OpenSSL) will extract lots of information and data about the certificates in the certificate chain used in the SSL connection. This data is then possible to extract after a transfer using  <i>curl_easy_getinfo(3)</i> and its option <i>CURLINFO_CERTINFO</i>. (Added in 7.19.1)</dd>
</dl>
<dl>
<dt>
CURLOPT_RANDOM_FILE</dt>
<dd>
Pass a char * to a zero terminated file name. The file will be used to read from to seed the random engine for SSL. The more random the specified file is, the more secure the SSL connection will become.</dd>
</dl>
<dl>
<dt>
CURLOPT_EGDSOCKET</dt>
<dd>
Pass a char * to the zero terminated path name to the Entropy Gathering Daemon socket. It will be used to seed the random engine for SSL.</dd>
</dl>
<dl>
<dt>
CURLOPT_SSL_CIPHER_LIST</dt>
<dd>
Pass a char *, pointing to a zero terminated string holding the list of ciphers to use for the SSL connection. The list must be syntactically correct, it consists of one or more cipher strings separated by colons. Commas or spaces are also acceptable separators but colons are normally used, !, - and + can be used as operators.<div style="height: 1.00em;">
&#160;</div>
For OpenSSL and GnuTLS valid examples of cipher lists include 'RC4-SHA', &#180;SHA1+DES&#180;, 'TLSv1' and 'DEFAULT'. The default list is normally set when you compile OpenSSL.<div style="height: 1.00em;">
&#160;</div>
You'll find more details about cipher lists on this URL:  <i>http://www.openssl.org/docs/apps/ciphers.html</i><div style="height: 1.00em;">
&#160;</div>
For NSS, valid examples of cipher lists include 'rsa_rc4_128_md5', &#180;rsa_aes_128_sha&#180;, etc. With NSS you don't add/remove ciphers. If one uses this option then all known ciphers are disabled and only those passed in are enabled.<div style="height: 1.00em;">
&#160;</div>
You'll find more details about the NSS cipher lists on this URL:  <i>http://directory.fedora.redhat.com/docs/mod_nss.html#Directives</i><div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<dl>
<dt>
CURLOPT_SSL_SESSIONID_CACHE</dt>
<dd>
Pass a long set to 0 to disable libcurl's use of SSL session-ID caching. Set this to 1 to enable it. By default all transfers are done using the cache. While nothing ever should get hurt by attempting to reuse SSL session-IDs, there seem to be broken SSL implementations in the wild that may require you to disable this in order for you to succeed. (Added in 7.16.0)</dd>
</dl>
<dl>
<dt>
CURLOPT_KRBLEVEL</dt>
<dd>
Pass a char * as parameter. Set the kerberos security level for FTP; this also enables kerberos awareness.  This is a string, 'clear', 'safe', 'confidential' or 'private'.  If the string is set but doesn't match one of these, 'private' will be used. Set the string to NULL to disable kerberos support for FTP.<div style="height: 1.00em;">
&#160;</div>
(This option was known as CURLOPT_KRB4LEVEL up to 7.16.3)</dd>
</dl>
<dl>
<dt>
CURLOPT_GSSAPI_DELEGATION</dt>
<dd>
Set the parameter to CURLGSSAPI_DELEGATION_FLAG to allow unconditional GSSAPI credential delegation.  The delegation is disabled by default since 7.21.7. Set the parameter to CURLGSSAPI_DELEGATION_POLICY_FLAG to delegate only if the OK-AS-DELEGATE flag is set in the service ticket in case this feature is supported by the GSSAPI implementation and the definition of GSS_C_DELEG_POLICY_FLAG was available at compile-time. (Added in 7.22.0)</dd>
</dl>
</div>
<div class="section">
<h1>SSH OPTIONS</h1><dl>
<dt>
CURLOPT_SSH_AUTH_TYPES</dt>
<dd>
Pass a long set to a bitmask consisting of one or more of CURLSSH_AUTH_PUBLICKEY, CURLSSH_AUTH_PASSWORD, CURLSSH_AUTH_HOST, CURLSSH_AUTH_KEYBOARD. Set CURLSSH_AUTH_ANY to let libcurl pick one. (Added in 7.16.1)</dd>
</dl>
<dl>
<dt>
CURLOPT_SSH_HOST_PUBLIC_KEY_MD5</dt>
<dd>
Pass a char * pointing to a string containing 32 hexadecimal digits. The string should be the 128 bit MD5 checksum of the remote host's public key, and libcurl will reject the connection to the host unless the md5sums match. This option is only for SCP and SFTP transfers. (Added in 7.17.1)</dd>
</dl>
<dl>
<dt>
CURLOPT_SSH_PUBLIC_KEYFILE</dt>
<dd>
Pass a char * pointing to a file name for your public key. If not used, libcurl defaults to  <b>$HOME/.ssh/id_dsa.pub</b> if the HOME environment variable is set, and just &quot;id_dsa.pub&quot; in the current directory if HOME is not set.  (Added in 7.16.1)</dd>
</dl>
<dl>
<dt>
CURLOPT_SSH_PRIVATE_KEYFILE</dt>
<dd>
Pass a char * pointing to a file name for your private key. If not used, libcurl defaults to  <b>$HOME/.ssh/id_dsa</b> if the HOME environment variable is set, and just &quot;id_dsa&quot; in the current directory if HOME is not set.  If the file is password-protected, set the password with  <i>CURLOPT_KEYPASSWD</i>. (Added in 7.16.1)</dd>
</dl>
<dl>
<dt>
CURLOPT_SSH_KNOWNHOSTS</dt>
<dd>
Pass a pointer to a zero terminated string holding the file name of the known_host file to use.  The known_hosts file should use the OpenSSH file format as supported by libssh2. If this file is specified, libcurl will only accept connections with hosts that are known and present in that file, with a matching public key. Use  <i>CURLOPT_SSH_KEYFUNCTION</i> to alter the default behavior on host and key (mis)matching. (Added in 7.19.6)</dd>
</dl>
<dl>
<dt>
CURLOPT_SSH_KEYFUNCTION</dt>
<dd>
Pass a pointer to a curl_sshkeycallback function. It gets called when the known_host matching has been done, to allow the application to act and decide for libcurl how to proceed. The callback will only be called if  <i>CURLOPT_SSH_KNOWNHOSTS</i> is also set.<div style="height: 1.00em;">
&#160;</div>
The curl_sshkeycallback function gets passed the CURL handle, the key from the known_hosts file, the key from the remote site, info from libcurl on the matching status and a custom pointer (set with  <i>CURLOPT_SSH_KEYDATA</i>). It MUST return one of the following return codes to tell libcurl how to act:</dd>
</dl>
<div style="margin-left: 5.00ex;">
<dl>
<dt>
CURLKHSTAT_FINE_ADD_TO_FILE</dt>
<dd>
The host+key is accepted and libcurl will append it to the known_hosts file before continuing with the connection. This will also add the host+key combo to the known_host pool kept in memory if it wasn't already present there. The adding of data to the file is done by completely replacing the file with a new copy, so the permissions of the file must allow this.</dd>
</dl>
<dl>
<dt>
CURLKHSTAT_FINE</dt>
<dd>
The host+key is accepted libcurl will continue with the connection. This will also add the host+key combo to the known_host pool kept in memory if it wasn't already present there.</dd>
</dl>
<dl>
<dt>
CURLKHSTAT_REJECT</dt>
<dd>
The host+key is rejected. libcurl will deny the connection to continue and it will be closed.</dd>
</dl>
<dl>
<dt>
CURLKHSTAT_DEFER</dt>
<dd>
The host+key is rejected, but the SSH connection is asked to be kept alive. This feature could be used when the app wants to somehow return back and act on the host+key situation and then retry without needing the overhead of setting it up from scratch again.</dd>
</dl>
</div>
<br/>
 (Added in 7.19.6)<dl>
<dt>
CURLOPT_SSH_KEYDATA</dt>
<dd>
Pass a void * as parameter. This pointer will be passed along verbatim to the callback set with  <i>CURLOPT_SSH_KEYFUNCTION</i>. (Added in 7.19.6)</dd>
</dl>
</div>
<div class="section">
<h1>OTHER OPTIONS</h1><dl>
<dt>
CURLOPT_PRIVATE</dt>
<dd>
Pass a void * as parameter, pointing to data that should be associated with this curl handle.  The pointer can subsequently be retrieved using  <i>curl_easy_getinfo(3)</i> with the CURLINFO_PRIVATE option. libcurl itself does nothing with this data. (Added in 7.10.3)</dd>
</dl>
<dl>
<dt>
CURLOPT_SHARE</dt>
<dd>
Pass a share handle as a parameter. The share handle must have been created by a previous call to  <i>curl_share_init(3)</i>. Setting this option, will make this curl handle use the data from the shared handle instead of keeping the data to itself. This enables several curl handles to share data. If the curl handles are used simultaneously in multiple threads, you  <b>MUST</b> use the locking methods in the share handle. See  <i>curl_share_setopt(3)</i> for details.<div style="height: 1.00em;">
&#160;</div>
If you add a share that is set to share cookies, your easy handle will use that cookie cache and get the cookie engine enabled. If you unshare an object that was using cookies (or change to another object that doesn't share cookies), the easy handle will get its cookie engine disabled.<div style="height: 1.00em;">
&#160;</div>
Data that the share object is not set to share will be dealt with the usual way, as if no share was used.</dd>
</dl>
<dl>
<dt>
CURLOPT_NEW_FILE_PERMS</dt>
<dd>
Pass a long as a parameter, containing the value of the permissions that will be assigned to newly created files on the remote server.  The default value is  <i>0644</i>, but any valid value can be used.  The only protocols that can use this are  <i>sftp://</i>, <i>scp://</i>, and <i>file://</i>. (Added in 7.16.4)</dd>
</dl>
<dl>
<dt>
CURLOPT_NEW_DIRECTORY_PERMS</dt>
<dd>
Pass a long as a parameter, containing the value of the permissions that will be assigned to newly created directories on the remote server.  The default value is  <i>0755</i>, but any valid value can be used.  The only protocols that can use this are  <i>sftp://</i>, <i>scp://</i>, and <i>file://</i>. (Added in 7.16.4)</dd>
</dl>
</div>
<div class="section">
<h1>TELNET OPTIONS</h1><dl>
<dt>
CURLOPT_TELNETOPTIONS</dt>
<dd>
Provide a pointer to a curl_slist with variables to pass to the telnet negotiations. The variables should be in the format &lt;option=value&gt;. libcurl supports the options 'TTYPE', 'XDISPLOC' and 'NEW_ENV'. See the TELNET standard for details.</dd>
</dl>
</div>
<div class="section">
<h1>RETURN VALUE</h1> CURLE_OK (zero) means that the option was set properly, non-zero means an error occurred as  <i>&lt;curl/curl.h&gt;</i> defines. See the <i>libcurl-errors(3)</i> man page for the full list with descriptions.<div style="height: 1.00em;">
&#160;</div>
If you try to set an option that libcurl doesn't know about, perhaps because the library is too old to support it or the option was removed in a recent version, this function will return  <i>CURLE_FAILED_INIT</i>.</div>
<div class="section">
<h1>SEE ALSO</h1> <b>curl_easy_init</b>(3), <b>curl_easy_cleanup</b>(3), <b>curl_easy_reset</b>(3)</div>
<table class="foot">
<tr>
<td class="foot-date">
1 Jan 2010</td>
<td class="foot-os">
libcurl 7.20.0</td>
</tr>
</table>
</div>
</body>
</html>

