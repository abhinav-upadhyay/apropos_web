<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
re(3perl)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
re(3perl)</td>
<td class="head-vol">
Perl Programmers Reference Guide</td>
<td class="head-rtitle">
re(3perl)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> re - Perl pragma to alter regular expression behaviour</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
    use re 'taint';<br/>
    ($x) = ($^X =~ /^(.*)$/s);     # $x is tainted here<br/>
<br/>
    $pat = '(?{ $foo = 1 })';<br/>
    use re 'eval';<br/>
    /foo${pat}bar/;                # won't fail (when not under -T switch)<br/>
<br/>
    {<br/>
        no re 'taint';             # the default<br/>
        ($x) = ($^X =~ /^(.*)$/s); # $x is not tainted here<br/>
<br/>
        no re 'eval';              # the default<br/>
        /foo${pat}bar/;            # disallowed (with or without -T switch)<br/>
    }<br/>
<br/>
    use re '/ix';<br/>
    &quot;FOO&quot; =~ / foo /; # /ix implied<br/>
    no re '/x';<br/>
    &quot;FOO&quot; =~ /foo/; # just /i implied<br/>
<br/>
    use re 'debug';                # output debugging info during<br/>
    /^(.*)$/s;                     #     compile and run time<br/>
<br/>
<br/>
    use re 'debugcolor';           # same as 'debug', but with colored output<br/>
    ...<br/>
<br/>
    use re qw(Debug All);          # Finer tuned debugging options.<br/>
    use re qw(Debug More);<br/>
    no re qw(Debug ALL);           # Turn of all re debugging in this scope<br/>
<br/>
    use re qw(is_regexp regexp_pattern); # import utility functions<br/>
    my ($pat,$mods)=regexp_pattern(qr/foo/i);<br/>
    if (is_regexp($obj)) { <br/>
        print &quot;Got regexp: &quot;,<br/>
            scalar regexp_pattern($obj); # just as perl would stringify it<br/>
    }                                    # but no hassle with blessed re's.<br/>
<div class="spacer">
</div>
(We use $^X in these examples because it's tainted by default.)</div>
<div class="section">
<h1>DESCRIPTION</h1><div class="subsection">
<h2>'taint' mode</h2> When &quot;use re 'taint'&quot; is in effect, and a tainted string is the target of a regexp, the regexp memories (or values returned by the m// operator in list context) are tainted.  This feature is useful when regexp operations on tainted data aren't meant to extract safe substrings, but to perform other transformations.</div>
<div class="subsection">
<h2>'eval' mode</h2> When &quot;use re 'eval'&quot; is in effect, a regexp is allowed to contain &quot;(?{ ... })&quot; zero-width assertions and &quot;(??{ ... })&quot; postponed subexpressions, even if the regular expression contains variable interpolation.  That is normally disallowed, since it is a potential security risk.  Note that this pragma is ignored when the regular expression is obtained from tainted data, i.e.  evaluation is always disallowed with tainted regular expressions.  See &quot;(?{ code })&quot; in perlre and &quot;(??{ code })&quot; in perlre.<div class="spacer">
</div>
For the purpose of this pragma, interpolation of precompiled regular expressions (i.e., the result of &quot;qr//&quot;) is  <i>not</i> considered variable interpolation.  Thus:<div class="spacer">
</div>
<br/>
    /foo${pat}bar/<br/>
<div class="spacer">
</div>
<i>is</i> allowed if $pat is a precompiled regular expression, even if $pat contains &quot;(?{ ... })&quot; assertions or &quot;(??{ ... })&quot; subexpressions.</div>
<div class="subsection">
<h2>'/flags' mode</h2> When &quot;use re '/flags'&quot; is specified, the given flags are automatically added to every regular expression till the end of the lexical scope.<div class="spacer">
</div>
&quot;no re '/flags'&quot; will turn off the effect of &quot;use re '/flags'&quot; for the given flags.<div class="spacer">
</div>
For example, if you want all your regular expressions to have /msx on by default, simply put<div class="spacer">
</div>
<br/>
    use re '/msx';<br/>
<div class="spacer">
</div>
at the top of your code.<div class="spacer">
</div>
The character set /adul flags cancel each other out. So, in this example,<div class="spacer">
</div>
<br/>
    use re &quot;/u&quot;;<br/>
    &quot;ss&quot; =~ /\xdf/;<br/>
    use re &quot;/d&quot;;<br/>
    &quot;ss&quot; =~ /\xdf/;<br/>
<div class="spacer">
</div>
the second &quot;use re&quot; does an implicit &quot;no re '/u'&quot;.<div class="spacer">
</div>
Turning on one of the character set flags with &quot;use re&quot; takes precedence over the &quot;locale&quot; pragma and the 'unicode_strings' &quot;feature&quot;, for regular expressions. Turning off one of these flags when it is active reverts to the behaviour specified by whatever other pragmata are in scope. For example:<div class="spacer">
</div>
<br/>
    use feature &quot;unicode_strings&quot;;<br/>
    no re &quot;/u&quot;; # does nothing<br/>
    use re &quot;/l&quot;;<br/>
    no re &quot;/l&quot;; # reverts to unicode_strings behaviour<br/>
</div>
<div class="subsection">
<h2>'debug' mode</h2> When &quot;use re 'debug'&quot; is in effect, perl emits debugging messages when compiling and using regular expressions.  The output is the same as that obtained by running a &quot;-DDEBUGGING&quot;-enabled perl interpreter with the  <b>-Dr</b> switch. It may be quite voluminous depending on the complexity of the match.  Using &quot;debugcolor&quot; instead of &quot;debug&quot; enables a form of output that can be used to get a colorful display on terminals that understand termcap color sequences.  Set $ENV{PERL_RE_TC} to a comma-separated list of &quot;termcap&quot; properties to use for highlighting strings on/off, pre-point part on/off. See &quot;Debugging Regular Expressions&quot; in perldebug for additional info.<div class="spacer">
</div>
As of 5.9.5 the directive &quot;use re 'debug'&quot; and its equivalents are lexically scoped, as the other directives are.  However they have both compile-time and run-time effects.<div class="spacer">
</div>
See &quot;Pragmatic Modules&quot; in perlmodlib.</div>
<div class="subsection">
<h2>'Debug' mode</h2> Similarly &quot;use re 'Debug'&quot; produces debugging output, the difference being that it allows the fine tuning of what debugging output will be emitted. Options are divided into three groups, those related to compilation, those related to execution and those related to special purposes. The options are as follows:<dl>
<dt>
Compile related options</dt>
<dd>
</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
COMPILE</dt>
<dd>
Turns on all compile related debug options.</dd>
</dl>
<dl>
<dt>
PARSE</dt>
<dd>
Turns on debug output related to the process of parsing the pattern.</dd>
</dl>
<dl>
<dt>
OPTIMISE</dt>
<dd>
Enables output related to the optimisation phase of compilation.</dd>
</dl>
<dl>
<dt>
TRIEC</dt>
<dd>
Detailed info about trie compilation.</dd>
</dl>
<dl>
<dt>
DUMP</dt>
<dd>
Dump the final program out after it is compiled and optimised.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
</div>
<dl>
<dt>
Execute related options</dt>
<dd>
</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
EXECUTE</dt>
<dd>
Turns on all execute related debug options.</dd>
</dl>
<dl>
<dt>
MATCH</dt>
<dd>
Turns on debugging of the main matching loop.</dd>
</dl>
<dl>
<dt>
TRIEE</dt>
<dd>
Extra debugging of how tries execute.</dd>
</dl>
<dl>
<dt>
INTUIT</dt>
<dd>
Enable debugging of start point optimisations.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
</div>
<dl>
<dt>
Extra debugging options</dt>
<dd>
</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
EXTRA</dt>
<dd>
Turns on all &quot;extra&quot; debugging options.</dd>
</dl>
<dl>
<dt>
BUFFERS</dt>
<dd>
Enable debugging the capture group storage during match. Warning, this can potentially produce extremely large output.</dd>
</dl>
<dl>
<dt>
TRIEM</dt>
<dd>
Enable enhanced TRIE debugging. Enhances both TRIEE and TRIEC.</dd>
</dl>
<dl>
<dt>
STATE</dt>
<dd>
Enable debugging of states in the engine.</dd>
</dl>
<dl>
<dt>
STACK</dt>
<dd>
Enable debugging of the recursion stack in the engine. Enabling or disabling this option automatically does the same for debugging states as well. This output from this can be quite large.</dd>
</dl>
<dl>
<dt>
OPTIMISEM</dt>
<dd>
Enable enhanced optimisation debugging and start point optimisations. Probably not useful except when debugging the regexp engine itself.</dd>
</dl>
<dl>
<dt>
OFFSETS</dt>
<dd>
Dump offset information. This can be used to see how regops correlate to the pattern. Output format is<div style="height: 1.00em;">
&#160;</div>
<br/>
   NODENUM:POSITION[LENGTH]<br/>
<div style="height: 1.00em;">
&#160;</div>
Where 1 is the position of the first char in the string. Note that position can be 0, or larger than the actual length of the pattern, likewise length can be zero.</dd>
</dl>
<dl>
<dt>
OFFSETSDBG</dt>
<dd>
Enable debugging of offsets information. This emits copious amounts of trace information and doesn't mesh well with other debug options.<div style="height: 1.00em;">
&#160;</div>
Almost definitely only useful to people hacking on the offsets part of the debug engine.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
</div>
<dl>
<dt>
Other useful flags</dt>
<dd>
These are useful shortcuts to save on the typing.</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
ALL</dt>
<dd>
Enable all options at once except OFFSETS, OFFSETSDBG and BUFFERS</dd>
</dl>
<dl>
<dt>
All</dt>
<dd>
Enable DUMP and all execute options. Equivalent to:<div style="height: 1.00em;">
&#160;</div>
<br/>
  use re 'debug';<br/>
</dd>
</dl>
<dl>
<dt>
MORE</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
More</dt>
<dd>
Enable TRIEM and all execute compile and execute options.</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
</div>
<div class="spacer">
</div>
As of 5.9.5 the directive &quot;use re 'debug'&quot; and its equivalents are lexically scoped, as the other directives are.  However they have both compile-time and run-time effects.</div>
<div class="subsection">
<h2>Exportable Functions</h2> As of perl 5.9.5 're' debug contains a number of utility functions that may be optionally exported into the caller's namespace. They are listed below.<dl>
<dt>
is_regexp($ref)</dt>
<dd>
Returns true if the argument is a compiled regular expression as returned by &quot;qr//&quot;, false if it is not.<div style="height: 1.00em;">
&#160;</div>
This function will not be confused by overloading or blessing. In internals terms, this extracts the regexp pointer out of the PERL_MAGIC_qr structure so it cannot be fooled.</dd>
</dl>
<dl>
<dt>
regexp_pattern($ref)</dt>
<dd>
If the argument is a compiled regular expression as returned by &quot;qr//&quot;, then this function returns the pattern.<div style="height: 1.00em;">
&#160;</div>
In list context it returns a two element list, the first element containing the pattern and the second containing the modifiers used when the pattern was compiled.<div style="height: 1.00em;">
&#160;</div>
<br/>
  my ($pat, $mods) = regexp_pattern($ref);<br/>
<div style="height: 1.00em;">
&#160;</div>
In scalar context it returns the same as perl would when stringifying a raw &quot;qr//&quot; with the same pattern inside.  If the argument is not a compiled reference then this routine returns false but defined in scalar context, and the empty list in list context. Thus the following<div style="height: 1.00em;">
&#160;</div>
<br/>
    if (regexp_pattern($ref) eq '(?^i:foo)')<br/>
<div style="height: 1.00em;">
&#160;</div>
will be warning free regardless of what $ref actually is.<div style="height: 1.00em;">
&#160;</div>
Like &quot;is_regexp&quot; this function will not be confused by overloading or blessing of the object.</dd>
</dl>
<dl>
<dt>
regmust($ref)</dt>
<dd>
If the argument is a compiled regular expression as returned by &quot;qr//&quot;, then this function returns what the optimiser considers to be the longest anchored fixed string and longest floating fixed string in the pattern.<div style="height: 1.00em;">
&#160;</div>
A <i>fixed string</i> is defined as being a substring that must appear for the pattern to match. An  <i>anchored fixed string</i> is a fixed string that must appear at a particular offset from the beginning of the match. A  <i>floating</i>  <i>fixed string</i> is defined as a fixed string that can appear at any point in a range of positions relative to the start of the match. For example,<div style="height: 1.00em;">
&#160;</div>
<br/>
    my $qr = qr/here .* there/x;<br/>
    my ($anchored, $floating) = regmust($qr);<br/>
    print &quot;anchored:'$anchored'\nfloating:'$floating'\n&quot;;<br/>
<div style="height: 1.00em;">
&#160;</div>
results in<div style="height: 1.00em;">
&#160;</div>
<br/>
    anchored:'here'<br/>
    floating:'there'<br/>
<div style="height: 1.00em;">
&#160;</div>
Because the &quot;here&quot; is before the &quot;.*&quot; in the pattern, its position can be determined exactly. That's not true, however, for the &quot;there&quot;; it could appear at any point after where the anchored string appeared. Perl uses both for its optimisations, prefering the longer, or, if they are equal, the floating.<div style="height: 1.00em;">
&#160;</div>
<b>NOTE:</b> This may not necessarily be the definitive longest anchored and floating string. This will be what the optimiser of the Perl that you are using thinks is the longest. If you believe that the result is wrong please report it via the perlbug utility.</dd>
</dl>
<dl>
<dt>
regname($name,$all)</dt>
<dd>
Returns the contents of a named buffer of the last successful match. If $all is true, then returns an array ref containing one entry per buffer, otherwise returns the first defined buffer.</dd>
</dl>
<dl>
<dt>
regnames($all)</dt>
<dd>
Returns a list of all of the named buffers defined in the last successful match. If $all is true, then it returns all names defined, if not it returns only names which were involved in the match.</dd>
</dl>
<dl>
<dt>
<i>regnames_count()</i></dt>
<dd>
Returns the number of distinct names defined in the pattern used for the last successful match.<div style="height: 1.00em;">
&#160;</div>
<b>Note:</b> this result is always the actual number of distinct named buffers defined, it may not actually match that which is returned by &quot;regnames()&quot; and related routines when those routines have not been called with the $all parameter set.</dd>
</dl>
</div>
</div>
<div class="section">
<h1>SEE ALSO</h1> &quot;Pragmatic Modules&quot; in perlmodlib.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-09-19</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

