<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Moose::Manual::FAQ(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Moose::Manual::FAQ(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
Moose::Manual::FAQ(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Moose::Manual::FAQ - Frequently asked questions about Moose</div>
<div class="section">
<h1>VERSION</h1> version 2.0401</div>
<div class="section">
<h1>FREQUENTLY ASKED QUESTIONS</h1><div class="subsection">
<h2>Module Stability</h2>  <i>Is Moose &quot;production ready&quot;?</i><div class="spacer">
</div>
Yes! Many sites with household names are using Moose to build high-traffic services. Countless others are using Moose in production. See &lt;http://www.iinteractive.com/moose/about.html#organizations&gt; for a partial list.<div class="spacer">
</div>
As of this writing, Moose is a dependency of several hundred CPAN modules. &lt;http://cpants.perl.org/dist/used_by/Moose&gt;<div class="spacer">
</div>
<i>Is Moose's API stable?</i><div class="spacer">
</div>
Yes. The sugary API, the one 95% of users will interact with, is  <b>very stable</b>. Any changes will be <b>100% backwards compatible</b>.<div class="spacer">
</div>
The meta API is less set in stone. We reserve the right to tweak parts of it to improve efficiency or consistency. This will not be done lightly. We do perform deprecation cycles. We  <i>really</i> do not like making ourselves look bad by breaking your code. Submitting test cases is the best way to ensure that your code is not inadvertently broken by refactoring.<div class="spacer">
</div>
<i>I heard Moose is slow, is this true?</i><div class="spacer">
</div>
Again, this one is tricky, so Yes <i>and</i> No.<div class="spacer">
</div>
Firstly, <i>nothing</i> in life is free, and some Moose features do cost more than others. It is also the policy of Moose to  <b>only charge you</b>  <b>for the features you use</b>, and to do our absolute best to not place any extra burdens on the execution of your code for features you are not using. Of course using Moose itself does involve some overhead, but it is mostly compile time. At this point we do have some options available for getting the speed you need.<div class="spacer">
</div>
Currently we provide the option of making your classes immutable as a means of boosting speed. This will mean a slightly larger compile time cost, but the runtime speed increase (especially in object construction) is pretty significant. This can be done with the following code:<div class="spacer">
</div>
<br/>
  MyClass-&gt;meta-&gt;make_immutable();<br/>
</div>
<div class="subsection">
<h2>Constructors</h2>  <i>How do I write custom constructors with Moose?</i><div class="spacer">
</div>
Ideally, you should never write your own &quot;new&quot; method, and should use Moose's other features to handle your specific object construction needs. Here are a few scenarios, and the Moose way to solve them;<div class="spacer">
</div>
If you need to call initialization code post instance construction, then use the &quot;BUILD&quot; method. This feature is taken directly from Perl 6. Every &quot;BUILD&quot; method in your inheritance chain is called (in the correct order) immediately after the instance is constructed.  This allows you to ensure that all your superclasses are initialized properly as well. This is the best approach to take (when possible) because it makes subclassing your class much easier.<div class="spacer">
</div>
If you need to affect the constructor's parameters prior to the instance actually being constructed, you have a number of options.<div class="spacer">
</div>
To change the parameter processing as a whole, you can use the &quot;BUILDARGS&quot; method. The default implementation accepts key/value pairs or a hash reference. You can override it to take positional args, or any other format<div class="spacer">
</div>
To change the handling of individual parameters, there are  <i>coercions</i> (See the Moose::Cookbook::Basics::Recipe5 for a complete example and explanation of coercions). With coercions it is possible to morph argument values into the correct expected types. This approach is the most flexible and robust, but does have a slightly higher learning curve.<div class="spacer">
</div>
<i>How do I make non-Moose constructors work with Moose?</i><div class="spacer">
</div>
Usually the correct approach to subclassing a non-Moose class is delegation.  Moose makes this easy using the &quot;handles&quot; keyword, coercions, and &quot;lazy_build&quot;, so subclassing is often not the ideal route.<div class="spacer">
</div>
That said, if you really need to inherit from a non-Moose class, see Moose::Cookbook::Basics::Recipe11 for an example of how to do it, or take a look at &quot;MooseX::NonMoose&quot; in Moose::Manual::MooseX.</div>
<div class="subsection">
<h2>Accessors</h2>  <i>How do I tell Moose to use get/set accessors?</i><div class="spacer">
</div>
The easiest way to accomplish this is to use the &quot;reader&quot; and &quot;writer&quot; attribute options:<div class="spacer">
</div>
<br/>
  has 'bar' =&gt; (<br/>
      isa    =&gt; 'Baz',<br/>
      reader =&gt; 'get_bar',<br/>
      writer =&gt; 'set_bar',<br/>
  );<br/>
<div class="spacer">
</div>
Moose will still take advantage of type constraints, triggers, etc. when creating these methods.<div class="spacer">
</div>
If you do not like this much typing, and wish it to be a default for your classes, please see MooseX::FollowPBP. This extension will allow you to write:<div class="spacer">
</div>
<br/>
  has 'bar' =&gt; (<br/>
      isa =&gt; 'Baz',<br/>
      is  =&gt; 'rw',<br/>
  );<br/>
<div class="spacer">
</div>
Moose will create separate &quot;get_bar&quot; and &quot;set_bar&quot; methods instead of a single &quot;bar&quot; method.<div class="spacer">
</div>
If you like &quot;bar&quot; and &quot;set_bar&quot;, see MooseX::SemiAffordanceAccessor.<div class="spacer">
</div>
NOTE: This <b>cannot</b> be set globally in Moose, as that would break other classes which are built with Moose. You can still save on typing by defining a new MyApp::Moose that exports Moose's sugar and then turns on MooseX::FollowPBP. See Moose::Cookbook::Extending::Recipe4.<div class="spacer">
</div>
<i>How can I inflate/deflate values in accessors?</i><div class="spacer">
</div>
Well, the first question to ask is if you actually need both inflate and deflate.<div class="spacer">
</div>
If you only need to inflate, then we suggest using coercions. Here is some basic sample code for inflating a DateTime object:<div class="spacer">
</div>
<br/>
  class_type 'DateTime';<br/>
<br/>
  coerce 'DateTime'<br/>
      =&gt; from 'Str'<br/>
      =&gt; via { DateTime::Format::MySQL-&gt;parse_datetime($_) };<br/>
<br/>
  has 'timestamp' =&gt; (is =&gt; 'rw', isa =&gt; 'DateTime', coerce =&gt; 1);<br/>
<div class="spacer">
</div>
This creates a custom type for DateTime objects, then attaches a coercion to that type. The &quot;timestamp&quot; attribute is then told to expect a &quot;DateTime&quot; type, and to try to coerce it. When a &quot;Str&quot; type is given to the &quot;timestamp&quot; accessor, it will attempt to coerce the value into a &quot;DateTime&quot; object using the code in found in the &quot;via&quot; block.<div class="spacer">
</div>
For a more comprehensive example of using coercions, see the Moose::Cookbook::Basics::Recipe5.<div class="spacer">
</div>
If you need to deflate your attribute's value, the current best practice is to add an &quot;around&quot; modifier to your accessor:<div class="spacer">
</div>
<br/>
  # a timestamp which stores as<br/>
  # seconds from the epoch<br/>
  has 'timestamp' =&gt; (is =&gt; 'rw', isa =&gt; 'Int');<br/>
<br/>
  around 'timestamp' =&gt; sub {<br/>
      my $next = shift;<br/>
      my $self = shift;<br/>
<br/>
      return $self-&gt;$next unless @_;<br/>
<br/>
      # assume we get a DateTime object ...<br/>
      my $timestamp = shift;<br/>
      return $self-&gt;$next( $timestamp-&gt;epoch );<br/>
  };<br/>
<div class="spacer">
</div>
It is also possible to do deflation using coercion, but this tends to get quite complex and require many subtypes. An example of this is outside the scope of this document, ask on #moose or send a mail to the list.<div class="spacer">
</div>
Still another option is to write a custom attribute metaclass, which is also outside the scope of this document, but we would be happy to explain it on #moose or the mailing list.</div>
<div class="subsection">
<h2>Method Modifiers</h2>  <i>How can I affect the values in </i><i>@_</i><i> using </i><i>&quot;before&quot;</i><i>?</i><div class="spacer">
</div>
You can't, actually: &quot;before&quot; only runs before the main method, and it cannot easily affect the method's execution.<div class="spacer">
</div>
You similarly can't use &quot;after&quot; to affect the return value of a method.<div class="spacer">
</div>
We limit &quot;before&quot; and &quot;after&quot; because this lets you write more concise code. You do not have to worry about passing @_ to the original method, or forwarding its return value (being careful to preserve context).<div class="spacer">
</div>
The &quot;around&quot; method modifier has neither of these limitations, but is a little more verbose.<div class="spacer">
</div>
Alternatively, the MooseX::Mangle extension provides the &quot;mangle_args&quot; function, which does allow you to affect @_.<div class="spacer">
</div>
<i>Can I use </i><i>&quot;before&quot;</i><i> to stop execution of a method?</i><div class="spacer">
</div>
Yes, but only if you throw an exception. If this is too drastic a measure then we suggest using &quot;around&quot; instead. The &quot;around&quot; method modifier is the only modifier which can gracefully prevent execution of the main method. Here is an example:<div class="spacer">
</div>
<br/>
    around 'baz' =&gt; sub {<br/>
        my $next = shift;<br/>
        my ($self, %options) = @_;<br/>
        unless ($options-&gt;{bar} eq 'foo') {<br/>
            return 'bar';<br/>
        }<br/>
        $self-&gt;$next(%options);<br/>
    };<br/>
<div class="spacer">
</div>
By choosing not to call the $next method, you can stop the execution of the main method.<div class="spacer">
</div>
Alternatively, the MooseX::Mangle extension provides the &quot;guard&quot; function, which will conditionally prevent execution of the original method.<div class="spacer">
</div>
<i>Why can't I see return values in an </i><i>&quot;after&quot;</i><i> modifier?</i><div class="spacer">
</div>
As with the &quot;before&quot; modifier, the &quot;after&quot; modifier is simply called  <i>after</i> the main method. It is passed the original contents of @_ and  <b>not</b> the return values of the main method.<div class="spacer">
</div>
Again, the arguments are too lengthy as to why this has to be. And as with &quot;before&quot; I recommend using an &quot;around&quot; modifier instead.  Here is some sample code:<div class="spacer">
</div>
<br/>
  around 'foo' =&gt; sub {<br/>
      my $next = shift;<br/>
      my ($self, @args) = @_;<br/>
      my @rv = $next-&gt;($self, @args);<br/>
      # do something silly with the return values<br/>
      return reverse @rv;<br/>
  };<br/>
<div class="spacer">
</div>
Alternatively, the MooseX::Mangle extension provides the &quot;mangle_return&quot; function, which allows modifying the return values of the original method.</div>
<div class="subsection">
<h2>Type Constraints</h2>  <i>How can I provide a custom error message for a type constraint?</i><div class="spacer">
</div>
Use the &quot;message&quot; option when building the subtype:<div class="spacer">
</div>
<br/>
  subtype 'NaturalLessThanTen'<br/>
      =&gt; as 'Natural'<br/>
      =&gt; where { $_ &lt; 10 }<br/>
      =&gt; message { &quot;This number ($_) is not less than ten!&quot; };<br/>
<div class="spacer">
</div>
This &quot;message&quot; block will be called when a value fails to pass the &quot;NaturalLessThanTen&quot; constraint check.<div class="spacer">
</div>
<i>Can I turn off type constraint checking?</i><div class="spacer">
</div>
Not yet. This option may come in a future release.<div class="spacer">
</div>
<i>My coercions stopped working with recent Moose, why did you break it?</i><div class="spacer">
</div>
Moose 0.76 fixed a case where coercions were being applied even if the original constraint passed. This has caused some edge cases to fail where people were doing something like<div class="spacer">
</div>
<br/>
    subtype 'Address', as 'Str';<br/>
    coerce 'Address', from 'Str', via { get_address($_) };<br/>
<div class="spacer">
</div>
This is not what they intended, because the type constraint &quot;Address&quot; is too loose in this case. It is saying that all strings are Addresses, which is obviously not the case. The solution is to provide a &quot;where&quot; clause that properly restricts the type constraint:<div class="spacer">
</div>
<br/>
    subtype 'Address', as 'Str', where { looks_like_address($_) };<br/>
<div class="spacer">
</div>
This will allow the coercion to apply only to strings that fail to look like an Address.</div>
<div class="subsection">
<h2>Roles</h2>  <i>Why is BUILD not called for my composed roles?</i><div class="spacer">
</div>
&quot;BUILD&quot; is never called in composed roles. The primary reason is that roles are  <b>not</b> order sensitive. Roles are composed in such a way that the order of composition does not matter (for information on the deeper theory of this read the original traits papers here &lt;http://www.iam.unibe.ch/~scg/Research/Traits/&gt;).<div class="spacer">
</div>
Because roles are essentially unordered, it would be impossible to determine the order in which to execute the &quot;BUILD&quot; methods.<div class="spacer">
</div>
As for alternate solutions, there are a couple.<dl>
<dt>
&#8226;</dt>
<dd>
Using a combination of lazy and default in your attributes to defer initialization (see the Binary Tree example in the cookbook for a good example of lazy/default usage Moose::Cookbook::Basics::Recipe3)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Use attribute triggers, which fire after an attribute is set, to facilitate initialization. These are described in the Moose docs, and examples can be found in the test suite.</dd>
</dl>
<div class="spacer">
</div>
In general, roles should not <i>require</i> initialization; they should either provide sane defaults or should be documented as needing specific initialization. One such way to &quot;document&quot; this is to have a separate attribute initializer which is required for the role. Here is an example of how to do this:<div class="spacer">
</div>
<br/>
  package My::Role;<br/>
  use Moose::Role;<br/>
<br/>
  has 'height' =&gt; (<br/>
      is      =&gt; 'rw',<br/>
      isa     =&gt; 'Int',<br/>
      lazy    =&gt; 1,<br/>
      default =&gt; sub {<br/>
          my $self = shift;<br/>
          $self-&gt;init_height;<br/>
      }<br/>
  );<br/>
<br/>
  requires 'init_height';<br/>
<div class="spacer">
</div>
In this example, the role will not compose successfully unless the class provides a &quot;init_height&quot; method.<div class="spacer">
</div>
If none of those solutions work, then it is possible that a role is not the best tool for the job, and you really should be using classes. Or, at the very least, you should reduce the amount of functionality in your role so that it does not require initialization.<div class="spacer">
</div>
<i>What are traits, and how are they different from roles?</i><div class="spacer">
</div>
In Moose, a trait is almost exactly the same thing as a role, except that traits typically register themselves, which allows you to refer to them by a short name (&quot;Big&quot; vs &quot;MyApp::Role::Big&quot;).<div class="spacer">
</div>
In Moose-speak, a <i>Role</i> is usually composed into a <i>class</i> at compile time, whereas a  <i>Trait</i> is usually composed into an instance of a class at runtime to add or modify the behavior of  <b>just that</b>  <b>instance</b>.<div class="spacer">
</div>
Outside the context of Moose, traits and roles generally mean exactly the same thing. The original paper called them traits, but Perl 6 will call them roles.<div class="spacer">
</div>
<i>Can an attribute-generated method (e.g. an accessor) satisfy requires?</i><div class="spacer">
</div>
Yes, just be sure to consume the role <i>after</i> declaring your attribute.  &quot;Required Attributes&quot; in Moose::Manual::Roles provides an example:<div class="spacer">
</div>
<br/>
  package Breakable;<br/>
  use Moose::Role;<br/>
  requires 'stress';<br/>
<br/>
  package Car;<br/>
  use Moose;<br/>
  has 'stress' =&gt; ( is  =&gt; 'rw', isa =&gt; 'Int' );<br/>
  with 'Breakable';<br/>
<div class="spacer">
</div>
If you mistakenly consume the &quot;Breakable&quot; role before declaring your &quot;stress&quot; attribute, you would see an error like this:<div class="spacer">
</div>
<br/>
  'Breakable' requires the method 'stress' to be implemented by 'Car' at...<br/>
</div>
<div class="subsection">
<h2>Moose and Subroutine Attributes</h2>  <i>Why don't subroutine attributes I inherited from a superclass work?</i><div class="spacer">
</div>
Currently when subclassing a module is done at runtime with the &quot;extends&quot; keyword, but attributes are checked at compile time by Perl. To make attributes work, you must place &quot;extends&quot; in a &quot;BEGIN&quot; block so that the attribute handlers will be available at compile time, like this:<div class="spacer">
</div>
<br/>
  BEGIN { extends qw/Foo/ }<br/>
<div class="spacer">
</div>
Note that we're talking about Perl's subroutine attributes here, not Moose attributes:<div class="spacer">
</div>
<br/>
  sub foo : Bar(27) { ... }<br/>
</div>
</div>
<div class="section">
<h1>AUTHOR</h1> Moose is maintained by the Moose Cabal, along with the help of many contributors. See &quot;CABAL&quot; in Moose and &quot;CONTRIBUTORS&quot; in Moose for details.</div>
<div class="section">
<h1>COPYRIGHT AND LICENSE</h1> This software is copyright (c) 2011 by Infinity Interactive, Inc..<div class="spacer">
</div>
This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5 programming language system itself.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-11-17</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

