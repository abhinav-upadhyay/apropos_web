<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Class::Method::Modifiers(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Class::Method::Modifiers(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
Class::Method::Modifiers(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Class::Method::Modifiers - provides Moose-like method modifiers</div>
<div class="section">
<h1>SYNOPSIS</h1><br/>
    package Child;<br/>
    use parent 'Parent';<br/>
    use Class::Method::Modifiers;<br/>
<br/>
    sub new_method { }<br/>
<br/>
    before 'old_method' =&gt; sub {<br/>
        carp &quot;old_method is deprecated, use new_method&quot;;<br/>
    };<br/>
<br/>
    around 'other_method' =&gt; sub {<br/>
        my $orig = shift;<br/>
        my $ret = $orig-&gt;(@_);<br/>
        return $ret =~ /\d/ ? $ret : lc $ret;<br/>
    };<br/>
<br/>
    after 'private', 'protected' =&gt; sub {<br/>
        debug &quot;finished calling a dangerous method&quot;;<br/>
    };<br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> Method modifiers are a convenient feature from the CLOS (Common Lisp Object System) world.<div class="spacer">
</div>
In its most basic form, a method modifier is just a method that calls &quot;$self-&gt;SUPER::foo(@_)&quot;. I for one have trouble remembering that exact invocation, so my classes seldom re-dispatch to their base classes. Very bad!<div class="spacer">
</div>
&quot;Class::Method::Modifiers&quot; provides three modifiers: &quot;before&quot;, &quot;around&quot;, and &quot;after&quot;. &quot;before&quot; and &quot;after&quot; are run just before and after the method they modify, but can not really affect that original method. &quot;around&quot; is run in place of the original method, with a hook to easily call that original method. See the &quot;MODIFIERS&quot; section for more details on how the particular modifiers work.<div class="spacer">
</div>
One clear benefit of using &quot;Class::Method::Modifiers&quot; is that you can define multiple modifiers in a single namespace. These separate modifiers don't need to know about each other. This makes top-down design easy. Have a base class that provides the skeleton methods of each operation, and have plugins modify those methods to flesh out the specifics.<div class="spacer">
</div>
Parent classes need not know about &quot;Class::Method::Modifiers&quot;. This means you should be able to modify methods in  <i>any</i> subclass. See Term::VT102::ZeroBased for an example of subclassing with CMM.<div class="spacer">
</div>
In short, &quot;Class::Method::Modifiers&quot; solves the problem of making sure you call &quot;$self-&gt;SUPER::foo(@_)&quot;, and provides a cleaner interface for it.<div class="spacer">
</div>
As of version 1.00, &quot;Class::Method::Modifiers&quot; is faster in some cases than Moose. See &quot;benchmark/method_modifiers.pl&quot; in the Moose distribution.</div>
<div class="section">
<h1>MODIFIERS</h1><div class="subsection">
<h2>before method(s) =&gt; sub { ... }</h2> &quot;before&quot; is called before the method it is modifying. Its return value is totally ignored. It receives the same @_ as the the method it is modifying would have received. You can modify the @_ the original method will receive by changing $_[0] and friends (or by changing anything inside a reference). This is a feature!</div>
<div class="subsection">
<h2>after method(s) =&gt; sub { ... }</h2> &quot;after&quot; is called after the method it is modifying. Its return value is totally ignored. It receives the same @_ as the the method it is modifying received, mostly. The original method can modify @_ (such as by changing $_[0] or references) and &quot;after&quot; will see the modified version. If you don't like this behavior, specify both a &quot;before&quot; and &quot;after&quot;, and copy the @_ during &quot;before&quot; for &quot;after&quot; to use.</div>
<div class="subsection">
<h2>around method(s) =&gt; sub { ... }</h2> &quot;around&quot; is called instead of the method it is modifying. The method you're overriding is passed in as the first argument (called $orig by convention). Watch out for contextual return values of $orig.<div class="spacer">
</div>
You can use &quot;around&quot; to:<dl>
<dt>
Pass $orig a different @_</dt>
<dd>
<br/>
    around 'method' =&gt; sub {<br/>
        my $orig = shift;<br/>
        my $self = shift;<br/>
        $orig-&gt;($self, reverse @_);<br/>
    };<br/>
</dd>
</dl>
<dl>
<dt>
Munge the return value of $orig</dt>
<dd>
<br/>
    around 'method' =&gt; sub {<br/>
        my $orig = shift;<br/>
        ucfirst $orig-&gt;(@_);<br/>
    };<br/>
</dd>
</dl>
<dl>
<dt>
Avoid calling $orig -- conditionally</dt>
<dd>
<br/>
    around 'method' =&gt; sub {<br/>
        my $orig = shift;<br/>
        return $orig-&gt;(@_) if time() % 2;<br/>
        return &quot;no dice, captain&quot;;<br/>
    };<br/>
</dd>
</dl>
</div>
<div class="subsection">
<h2>install_modifier $package, $type, @names, sub { ... }</h2> &quot;install_modifier&quot; is like &quot;before&quot;, &quot;after&quot;, and &quot;around&quot; but it also lets you dynamically select the modifier type ('before', 'after', 'around') and package that the method modifiers are installed into. This expert-level function is exported only when you ask for it specifically, or for &quot;:all&quot;.</div>
</div>
<div class="section">
<h1>NOTES</h1> All three normal modifiers; &quot;before&quot;, &quot;after&quot;, and &quot;around&quot;; are exported into your namespace by default. You may &quot;use Class::Method::Modifiers ()&quot; to avoid thrashing your namespace. I may steal more features from Moose, namely &quot;super&quot;, &quot;override&quot;, &quot;inner&quot;, &quot;augment&quot;, and whatever the Moose folks come up with next.<div class="spacer">
</div>
Note that the syntax and semantics for these modifiers is directly borrowed from Moose (the implementations, however, are not).<div class="spacer">
</div>
Class::Trigger shares a few similarities with &quot;Class::Method::Modifiers&quot;, and they even have some overlap in purpose -- both can be used to implement highly pluggable applications. The difference is that Class::Trigger provides a mechanism for easily letting parent classes to invoke hooks defined by other code. &quot;Class::Method::Modifiers&quot; provides a way of overriding/augmenting methods safely, and the parent class need not know about it.</div>
<div class="section">
<h1>CAVEATS</h1> It is erroneous to modify a method that doesn't exist in your class's inheritance hierarchy. If this occurs, an exception will be thrown when the modifier is defined.<div class="spacer">
</div>
It doesn't yet play well with &quot;caller&quot;. There are some todo tests for this. Don't get your hopes up though!</div>
<div class="section">
<h1>VERSION</h1> This module was bumped to 1.00 following a complete reimplementation, to indicate breaking backwards compatibility. The &quot;guard&quot; modifier was removed, and the internals are completely different.<div class="spacer">
</div>
The new version is a few times faster with half the code. It's now even faster than Moose.<div class="spacer">
</div>
Any code that just used modifiers should not change in behavior, except to become more correct. And, of course, faster. :)</div>
<div class="section">
<h1>SEE ALSO</h1> Class::Method::Modifiers::Fast Moose, Class::Trigger, Class::MOP::Method::Wrapped, MRO::Compat, CLOS</div>
<div class="section">
<h1>AUTHOR</h1> Shawn M Moore, &quot;sartak@gmail.com&quot;</div>
<div class="section">
<h1>ACKNOWLEDGEMENTS</h1> Thanks to Stevan Little for Moose, I would never have known about method modifiers otherwise.<div class="spacer">
</div>
Thanks to Matt Trout and Stevan Little for their advice.</div>
<div class="section">
<h1>COPYRIGHT AND LICENSE</h1> Copyright 2007-2009 Shawn M Moore.<div class="spacer">
</div>
This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-10-15</td>
<td class="foot-os">
perl v5.12.4</td>
</tr>
</table>
</div>
</body>
</html>

