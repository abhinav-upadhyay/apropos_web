<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
Config::Model::Manual::ModelCreationIntroduction(3pm)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
Config::Model::Manual::ModelCreationIntroduction(3pm)</td>
<td class="head-vol">
User Contributed Perl Documentation</td>
<td class="head-rtitle">
Config::Model::Manual::ModelCreationIntroduction(3pm)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> Config::Model::Manual::ModelCreationIntroduction - Introduction to model creation with Config::Model</div>
<div class="section">
<h1>VERSION</h1> version 2.005</div>
<div class="section">
<h1>Introduction</h1> This page describes how to write a simple configuration model. Creation of more complex models are described in Creating a model with advanced features.<div class="spacer">
</div>
A tutorial is available in Creating a model from config file documentation.<div class="spacer">
</div>
Note that this document will show a lot of Perl data structure to highlight the content of a model. A Perl data structure is very similar to a JSON structure. The only thing you need to know are:<dl>
<dt>
&#8226;</dt>
<dd>
Curly braces &quot;{ ... }&quot; contain a dictionary of key, value pairs (a &quot;hash&quot; in Perl land))</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Square brackets &quot;[ ... ]&quot; contain a list of items (&quot;array&quot; or &quot;list&quot; in Perl land)</dd>
</dl>
</div>
<div class="section">
<h1>Some definitions</h1><dl>
<dt>
configuration file</dt>
<dd>
Text file where configuration data are stored. This configuration file will be used by an application -- the  <i>target application</i></dd>
</dl>
<dl>
<dt>
configuration tree</dt>
<dd>
The semantic content of the configuration file stored in a tree representation</dd>
</dl>
<dl>
<dt>
configuration model</dt>
<dd>
Structure and constraints of the configuration tree. Like a schema for the configuration tree</dd>
</dl>
<dl>
<dt>
target application</dt>
<dd>
The application that will use the configuration file</dd>
</dl>
<dl>
<dt>
end user</dt>
<dd>
User of the target application</dd>
</dl>
<dl>
<dt>
application developer</dt>
<dd>
Target application developer</dd>
</dl>
<dl>
<dt>
model developer</dt>
<dd>
People developing the configuration model. Not necessarily the application developer</dd>
</dl>
</div>
<div class="section">
<h1>What is a configuration tree?</h1> Most configuration files are actually organized mostly as a tree structure. Depending on the syntax of the file, this structure may be obvious to see (e.g. for XML, Apache) or not so obvious (&quot;Xorg&quot; syntax, INI syntax).<div class="spacer">
</div>
For some files like &quot;approx.conf&quot; or &quot;adduser.conf&quot;, this tree structure is quite flat.  It looks much like a rake than a tree, but still, it's a tree.<div class="spacer">
</div>
For instance, this &quot;approx.conf&quot;:<div class="spacer">
</div>
<br/>
 $pdiffs     1<br/>
 $max_wait   14<br/>
 debian     http://ftp.fr.debian.org/debian<br/>
<div class="spacer">
</div>
can have this tree representation:<div class="spacer">
</div>
<br/>
 root<br/>
 |--pdiff=1<br/>
 |--max_wait=14<br/>
 `--distrib(debian)=http://ftp.fr.debian.org/debian<br/>
<div class="spacer">
</div>
Other configuration files like &quot;apache2.conf&quot; or &quot;xorg.conf&quot; have a structure that look more like a tree.<div class="spacer">
</div>
For instance, consider this &quot;xorg.conf&quot; snippet:<div class="spacer">
</div>
<br/>
 Section &quot;Device&quot;<br/>
    Identifier     &quot;Device0&quot;<br/>
    Driver         &quot;nvidia&quot;<br/>
 EndSection<br/>
 <br/>
 Section &quot;Screen&quot;<br/>
    Identifier     &quot;Screen0&quot;<br/>
    Device         &quot;Device0&quot;<br/>
    Option         &quot;AllowGLXWithComposite&quot; &quot;True&quot;<br/>
    Option         &quot;DynamicTwinView&quot; &quot;True&quot;<br/>
    SubSection     &quot;Display&quot;<br/>
        Depth       24<br/>
    EndSubSection<br/>
 EndSection<br/>
<div class="spacer">
</div>
Knowing that Xorg.conf can have several Device or Screen sections identified by their &quot;Identifiers&quot;, the configuration can be represented in this tree as:<div class="spacer">
</div>
<br/>
 root<br/>
 |--Device(Device0)<br/>
 |  `--Driver=nvidia<br/>
 `--Screen(Screen0)<br/>
    |--Device=Device0<br/>
    |--Option<br/>
    |  |--AllowGLXWithComposite=True<br/>
    |  `--DynamicTwinView=True<br/>
    `--Display<br/>
       `--Depth=24<br/>
<div class="spacer">
</div>
Some will argue that some &quot;Xorg&quot; parameter refer to others (i.e.&quot;Device&quot; and &quot;Monitor&quot; value in &quot;Screen&quot; section) and so they cannot be represented as a tree. That's right, there are some more complex relations that are added to the tree structure. This will be covered in more details when dealing with complex models.<div class="spacer">
</div>
In some other case, the structure of a tree is not fixed. For instance, &quot;Device&quot; options in &quot;Xorg.conf&quot; are different depending on the value of the &quot;Device Driver&quot;. In this case, the structure of the configuration tree must be adapted (morphed) depending on a parameter value.<div class="spacer">
</div>
Just like XML data can have Schema to validate their content, the configuration tree structure needs to have its own schema to validate its content. Since the tree structure cannot be represented as a static tree without reference, XML like schema are not enough to validate configuration data.<div class="spacer">
</div>
Config::Model provides a kind of schema for configuration data that takes care of the cross references mentioned above and of the dynamic nature of the configuration tree required for &quot;Xorg&quot; (and others).</div>
<div class="section">
<h1>What is a model?</h1> A configuration model defines the configuration tree structure:<dl>
<dt>
&#8226;</dt>
<dd>
A model defines one or more configuration class</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
At least one class is required to define the configuration tree root</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Each class contains several elements. An element can be:</dd>
</dl>
<div style="margin-left: 4.00ex;">
<dl>
<dt>
&#8226;</dt>
<dd>
A leaf to represent one configuration parameter</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
A list of hash of leaves to represent several parameter</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
A node to hold a node of a configuration tree</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
A list or hash of nodes</dd>
</dl>
</div>
<div style="margin-left: 4.00ex;">
</div>
<div class="spacer">
</div>
These basic relations enable to define the main parts of a configuration tree.<div class="spacer">
</div>
If we refer to the &quot;approx.conf&quot; example mentioned above, one only class is required (let's say the &quot;Approx&quot; class). This class will contain (see approx.conf man page):<dl>
<dt>
&#8226;</dt>
<dd>
A boolean leaf for &quot;pdiff&quot; (1 if not specified)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
An integer leaf for &quot;max_wait&quot; (10 seconds unless specified otherwise)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
A hash of string leaves for &quot;distrib&quot; (no default).</dd>
</dl>
<div class="spacer">
</div>
In terms of models, the model will be stored this way by Config::Model:<div class="spacer">
</div>
<br/>
 {<br/>
  'name' =&gt; 'Approx',<br/>
  'element' <br/>
  =&gt; [<br/>
      'pdiffs'       , { type =&gt; 'leaf', value_type =&gt; 'boolean', upstream_default =&gt; '1'      },<br/>
      'max_wait'     , { type =&gt; 'leaf', value_type =&gt; 'integer', upstream_default =&gt; '10'     },<br/>
      'distributions', { type =&gt; 'hash', index_type =&gt; 'string' ,<br/>
                         cargo =&gt; { value_type =&gt; 'uniline', type =&gt; 'leaf',},<br/>
                       }<br/>
      ]<br/>
 }<br/>
<div class="spacer">
</div>
The &quot;Xorg&quot; example will lead to a slightly more complex model with several classes:<dl>
<dt>
&#8226;</dt>
<dd>
&quot;Xorg&quot; (root class)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;Xorg::Device&quot;</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;Xorg::Screen&quot;</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;Xorg::Screen::Option&quot; for the Screen options</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;Xorg::Screen::Display&quot; for the&quot;Display&quot; subsection</dd>
</dl>
<div class="spacer">
</div>
The root class will be declared this way:<div class="spacer">
</div>
<br/>
 {<br/>
  name =&gt; 'Xorg',<br/>
  element =&gt; [<br/>
              Device =&gt; {<br/>
                         type =&gt; 'hash',<br/>
                         index_type =&gt; 'string'<br/>
                         cargo =&gt; {<br/>
                                    type =&gt; 'node',<br/>
                                    config_class_name =&gt; 'Xorg::Device'<br/>
                                  },<br/>
                        },<br/>
              Screen =&gt; {<br/>
                         type =&gt; 'hash',<br/>
                         index_type =&gt; 'string'<br/>
                         cargo =&gt; {<br/>
                                   type =&gt; 'node',<br/>
                                   config_class_name =&gt; 'Xorg::Screen'<br/>
                                  },<br/>
                        },<br/>
           ]<br/>
 }<br/>
<div class="spacer">
</div>
The&quot;Xorg::Screen&quot; class will be:<div class="spacer">
</div>
<br/>
 {<br/>
  name =&gt; 'Xorg::Screen',<br/>
  element =&gt; [<br/>
               Device =&gt; {<br/>
                           type' =&gt; 'leaf',<br/>
                           value_type =&gt; 'uniline',<br/>
                         },<br/>
               Display =&gt; {<br/>
                            type =&gt; 'hash',<br/>
                            index_type =&gt; 'integer'<br/>
                            cargo =&gt; {<br/>
                                       type =&gt; 'node',<br/>
                                       config_class_name =&gt; 'Xorg::Screen::Display'<br/>
                                     },<br/>
                          }<br/>
              Option =&gt; {<br/>
                          type =&gt; 'node',<br/>
                          config_class_name =&gt; 'Xorg::Screen::Option'<br/>
                        },<br/>
              ]<br/>
  }<br/>
<div class="spacer">
</div>
It's now time to detail how the elements of a class are constructed.</div>
<div class="section">
<h1>Model analysis</h1> To define the configuration classes that will be required, you will have to read the documentation of the target application to :<dl>
<dt>
&#8226;</dt>
<dd>
Find the structure of the configuration tree</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Identify configuration parameters, their constraints and relations</dd>
</dl>
<div class="spacer">
</div>
Last but not least, you will also have to find several valid examples. These examples be used as non-regression tests and verify that the documentation was understood.</div>
<div class="section">
<h1>Model declaration</h1><div class="subsection">
<h2>Configuration class declaration</h2> In summary, configuration documentation is translated in a format usable by Config::Model:<dl>
<dt>
&#8226;</dt>
<dd>
The structure is translated into configuration classes</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Configuration parameters are translated into elements</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Constraints are translated into element attributes</dd>
</dl>
<div class="spacer">
</div>
All models files must be written in a specific directory. For instance, for model &quot;Xorg&quot;, you must create &quot;./lib/Config/Model/models/Xorg.pl&quot;. Other classes like &quot;Xorg::Screen&quot; can be stored in their own file &quot;./lib/Config/Model/models/Xorg/Screen.pl&quot; or included in &quot;Xorg.pl&quot;<div class="spacer">
</div>
A model file is a Perl file containing an array for hash ref. Each Hash ref contains a class declaration:<div class="spacer">
</div>
<br/>
 [ { name =&gt; 'Xorg', ... } , { name =&gt; 'Xorg::Screen', ... } ] ;<br/>
<div class="spacer">
</div>
A class can have the following parameters:<dl>
<dt>
&#8226;</dt>
<dd>
name: mandatory name of the class</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
class_description: Description of the configuration class.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
generated_by: Mention with a descriptive string if this class was generated by a program. This parameter is currently reserved for &quot;Config::Model::Itself&quot; model editor.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
include: Include element description from another class.</dd>
</dl>
<div class="spacer">
</div>
For more details, see &quot;Configuration_Model&quot; in Config::Model.<div class="spacer">
</div>
For instance:<div class="spacer">
</div>
<br/>
 $ cat lib/Config/Model/models/Xorg.pl<br/>
 [<br/>
   {<br/>
     name =&gt; 'Xorg',<br/>
     class_description =&gt; 'Top level Xorg configuration.',<br/>
     include =&gt; [ 'Xorg::ConfigDir'],<br/>
     element =&gt; [<br/>
                 Files =&gt; {<br/>
                           type =&gt; 'node',<br/>
                           description =&gt; 'File pathnames',<br/>
                           config_class_name =&gt; 'Xorg::Files'<br/>
                          },<br/>
                 # snip<br/>
                ]<br/>
   },<br/>
   {<br/>
     name =&gt; 'Xorg::DRI',<br/>
     element =&gt; [<br/>
                 Mode =&gt; {<br/>
                          type =&gt; 'leaf',<br/>
                          value_type =&gt; 'uniline',<br/>
                          description =&gt; 'DRI mode, usually set to 0666'<br/>
                         }<br/>
                ]<br/>
   }<br/>
 ];<br/>
</div>
<div class="subsection">
<h2>Configuration class declaration (easier way)</h2> Since writing a data structure is not fun (even with Perl), you are encouraged to use the model editor provided by config-model-edit from Config::Model::Itself module. You will get this type of GUI shown on the right with the command &quot;config-model-edit -model Xorg&quot;</div>
<div class="subsection">
<h2>Common attributes for all elements</h2> This first set of attributes will help the user by providing guidance (with &quot;level&quot; and &quot;status&quot; and &quot;experience&quot;) and documentation (&quot;summary&quot; and &quot;description&quot;).<div class="spacer">
</div>
All elements (simple or complex) can have the following attributes:<dl>
<dt>
&#8226;</dt>
<dd>
&quot;description&quot;: full length description of the attribute</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;summary&quot;: one line summary of the above description</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;level&quot;: is &quot;important&quot;, &quot;normal&quot; or &quot;hidden&quot;. The level is used to set how configuration data is presented to the user in browsing mode. Important elements will be shown to the user no matter what. hidden elements will be explained with the warp notion.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;status&quot;: is &quot;obsolete&quot;, &quot;deprecated&quot; or &quot;standard&quot; (default). Using a deprecated element will issue a warning. Using an obsolete element will raise an exception.</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
&quot;experience&quot;: By using the experience parameter, you can change the experience level of each element. Possible experience levels are &quot;master&quot;, &quot;advanced&quot; and &quot;beginner&quot; (default).</dd>
</dl>
<div class="spacer">
</div>
See &quot;Configuration_class&quot; in Config::Model for details.</div>
<div class="subsection">
<h2>Simple leaf elements</h2> Simple leaf elements will be used most often for configuration files. A leaf element will represent a specific configuration parameter.<div class="spacer">
</div>
In more details, a leaf element have the following attributes (See &quot;Value_model_declaration&quot; in Config::Model::Value doc):<dl>
<dt>
type</dt>
<dd>
Set to &quot;leaf&quot; (mandatory)</dd>
</dl>
<dl>
<dt>
value_type</dt>
<dd>
Either &quot;boolean&quot;, &quot;integer&quot;, &quot;number&quot;, &quot;enum&quot;, &quot;string&quot;, &quot;uniline&quot; (i.e. a string without &quot;\n&quot;) (mandatory)</dd>
</dl>
<dl>
<dt>
min</dt>
<dd>
Minimum value (for &quot;integer&quot; or &quot;number&quot;)</dd>
</dl>
<dl>
<dt>
&lt;max</dt>
<dd>
Maximum value (for &quot;integer&quot; or &quot;number&quot;)</dd>
</dl>
<dl>
<dt>
choice</dt>
<dd>
Possible values for an enum</dd>
</dl>
<dl>
<dt>
mandatory</dt>
<dd>
Whether the value is mandatory or not</dd>
</dl>
<dl>
<dt>
default</dt>
<dd>
Default value that must be written in the configuration file</dd>
</dl>
<dl>
<dt>
upstream_default</dt>
<dd>
Default value that is known by the target application and thus does not need to be written in the configuration file.</dd>
</dl>
<div class="spacer">
</div>
To know which attributes to use, you will have to read the documentation of the target application.<div class="spacer">
</div>
For instance, &quot;AddressFamily&quot; parameter (<i>sshd_config</i>(5)) is specified with:  <i>Specifies which address family should be used by </i><i>sshd</i><i>(8).</i>  <i>Valid arguments are &quot;any&quot;, &quot;inet&quot; (use IPv4 only), or &quot;inet6&quot; (use</i>  <i>IPv6 only).  The default is &quot;any&quot;.</i><div class="spacer">
</div>
For Config::Model, &quot;AddressFamily&quot; is a type &quot;leaf&quot; element, value_type &quot;enum&quot; and the application will use &quot;any&quot; if this parameter is left blank in &quot;sshd_config&quot; file.<div class="spacer">
</div>
Thus the model of this element will be :<div class="spacer">
</div>
<br/>
 AddressFamily =&gt; {<br/>
   type             =&gt; 'leaf',<br/>
   value_type       =&gt; 'enum',<br/>
   upstream_default =&gt; 'any',<br/>
   description      =&gt; 'Specifies which address family should be used by sshd(8).',<br/>
   choice           =&gt; [ 'any', 'inet', 'inet6' ]<br/>
 }<br/>
</div>
<div class="subsection">
<h2>Simple list or hash element</h2> Some configuration parameters are in fact a list or a hash of parameters. For instance, &quot;approx.conf&quot; can feature a list of remote repositories:<div class="spacer">
</div>
<br/>
 # remote repositories<br/>
 debian     http://ftp.fr.debian.org/debian<br/>
 multimedia http://www.debian-multimedia.org<br/>
<div class="spacer">
</div>
These repositories must be stored as a hash where the key will be  <i>debian</i> or <i>multimedia</i> and the associated value will a URL. But this hash must have something which is not explicit in &quot;approx.conf&quot; file: a parameter name. Approx man page mentions that:  <i>The name/value pairs [not beginning with '$' are used to map distribution names to remote repositories.</i>. So let's use &quot;distribution&quot; as a parameter name.<div class="spacer">
</div>
The example will be stored this way in the configuration tree:<div class="spacer">
</div>
<br/>
 root<br/>
 |--distrib(debian)=http://ftp.fr.debian.org/debian<br/>
 `--distrib(multimedia)=http://www.debian-multimedia.org<br/>
<div class="spacer">
</div>
The model will need to declare that &quot;distrib&quot; is:<dl>
<dt>
&#8226;</dt>
<dd>
a type &quot;hash&quot; parameter</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
the hash key is a string</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
the values of the hash are of type &quot;leaf&quot; and value_type &quot;uniline&quot;</dd>
</dl>
<div class="spacer">
</div>
<br/>
 distribution =&gt; {<br/>
                   type =&gt; 'hash',<br/>
                   index_type =&gt; 'string',<br/>
                   cargo =&gt; {<br/>
                              type =&gt; 'leaf',<br/>
                              value_type =&gt; 'uniline',<br/>
                            },<br/>
                   summary =&gt; 'remote repositories',<br/>
                   description =&gt; 'The other name/value pairs are ...',<br/>
                 }<br/>
<div class="spacer">
</div>
For more details on list and hash elements, see hash or list model declaration man page.</div>
<div class="subsection">
<h2>node element</h2> A node element is necessary if the configuration file has more than a list of variable. In this case, the tree is deeper than a rake and a node element if necessary to provide a new node within the tree.<div class="spacer">
</div>
In the Xorg example above, the options of &quot;Xorg::Screen&quot; need their own sub-branch in the tree:<div class="spacer">
</div>
<br/>
 Screen(Screen0)<br/>
   `--Option<br/>
      |--AllowGLXWithComposite=True<br/>
      `--DynamicTwinView=True<br/>
<div class="spacer">
</div>
For this, a new dedicated class is necessary&gt;Xorg::Screen::Option&gt; (see its declaration above). This new class must be tied to the Screen class with a node element.<div class="spacer">
</div>
A node element has the following parameters:<dl>
<dt>
&#8226;</dt>
<dd>
type (set to &quot;node&quot;)</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
the name of the configuration class name (&gt;config_class_name&gt;)</dd>
</dl>
<div class="spacer">
</div>
So the &quot;Option&quot; node element is declared with:<div class="spacer">
</div>
<br/>
 Option =&gt; {<br/>
             type =&gt; 'node',<br/>
             config_class_name =&gt; 'Xorg::Screen::Option'<br/>
           },<br/>
</div>
<div class="subsection">
<h2>Hash or list of nodes</h2> Some configuration files can feature a set of rather complex configuration entities. For instance &quot;Xorg.pl&quot; can feature several Screen or Device definitions. These definitions are identified by the &quot;Identifier&quot; parameter:<div class="spacer">
</div>
<br/>
 Section &quot;Device&quot;<br/>
   Identifier     &quot;Device0&quot;<br/>
   Driver         &quot;nvidia&quot;<br/>
   BusID          &quot;PCI:3:0:1&quot;<br/>
 EndSection<br/>
 <br/>
 Section &quot;Screen&quot;<br/>
   Identifier     &quot;Screen0&quot;<br/>
   Device         &quot;Device0&quot;<br/>
   DefaultDepth    24<br/>
 EndSection<br/>
<div class="spacer">
</div>
The Xorg configuration tree will feature 2 elements (Screen and Device) that will use the Identifier parameters as hash keys:<div class="spacer">
</div>
<br/>
 root<br/>
 |--Device(Device0)<br/>
 |  |--Driver=nvidia<br/>
 |  `--BusId=PCI:3:0:1<br/>
 `--Screen(Screen0)<br/>
    |--Device=Device0<br/>
    `--DefaultDepth=24<br/>
<div class="spacer">
</div>
And the Xorg model must define these 2 parameters as &quot;hash&quot;. The cargo of this hash will of type &quot;node&quot; and will refer to 2 different configuration classes, one for &quot;Device&quot; (&quot;Xorg::Device&quot;) and one for &quot;Screen&quot; (&quot;Xorg::Screen&quot;):<div class="spacer">
</div>
<br/>
 {<br/>
 name =&gt; 'Xorg',<br/>
 element =&gt; [<br/>
             Device =&gt; {<br/>
                        type =&gt; 'hash',<br/>
                        index_type =&gt; 'string'<br/>
                        cargo =&gt; {<br/>
                                   type =&gt; 'node',<br/>
                                   config_class_name =&gt; 'Xorg::Device'<br/>
                                 },<br/>
                       },<br/>
             Screen =&gt; {<br/>
                        type =&gt; 'hash',<br/>
                        index_type =&gt; 'string'<br/>
                        cargo =&gt; {<br/>
                                  type =&gt; 'node',<br/>
                                  config_class_name =&gt; 'Xorg::Screen'<br/>
                                 },<br/>
                       },<br/>
          ]<br/>
 }<br/>
</div>
</div>
<div class="section">
<h1>Configuration wizard</h1> Both Perl/Tk and Curses interfaces feature a configuration wizard generated from a configuration model.<div class="spacer">
</div>
The wizard works by exploring the configuration tree and stopping on each  <i>important</i> element and on each error (mostly missing mandatory parameter). The exploration will also respect the &quot;experience&quot; parameter. I.e. a wizard run with &quot;master&quot; experience (see Option-&gt;Experience menu in the Perl/Tk interface) will show more parameters than running the interface with &quot;beginner&quot; experience.<div class="spacer">
</div>
When designing a model, you will have to think about each element:<dl>
<dt>
&#8226;</dt>
<dd>
The expertise required to tinker with this parameter and set &quot;experience&quot; to the right level, either master, advanced or beginner (default).</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
The importance level of the parameter (important, normal or hidden). &quot;level&quot; is used to set how configuration data is presented to the user in wizard and browsing mode. Important elements will be shown in the wizard. hidden elements will be explained with the warp notion in Creating a model with advanced features.</dd>
</dl>
</div>
<div class="section">
<h1>Reading configuration files</h1> Once the model is specified, Config::Model can generate a nice user interface, but there's still no way to load or write the configuration file.<div class="spacer">
</div>
For Config::Model to read the file, the model designer must declare in the model how to read the file (the read backend).<div class="spacer">
</div>
The read method can use one or more of the following mechanisms:<dl>
<dt>
&#8226;</dt>
<dd>
Built-in, e.g Perl file, INI file...</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
A plugin, i.e. a Perl &quot;Config::Model::Backend::*&quot; class like &quot;Config::Model::Backend::Augeas&quot;</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
A custom class where a read call-back must be provided</dd>
</dl>
<div class="spacer">
</div>
For more details, see Config::Model::AutoRead.<div class="spacer">
</div>
The name of the backend parameter must be specified in all cases.<div class="subsection">
<h2>Using built-in read mechanism</h2> &quot;Config::Model&quot; comes with 3 read/write built in mechanisms:<dl>
<dt>
perl_file</dt>
<dd>
A perl data structure (like the ones produced by Data::Dumper). See Config::Model::DumpAsData for details.</dd>
</dl>
<dl>
<dt>
ini_file</dt>
<dd>
Windows INI file (note that only simple tree structure can use this backend)</dd>
</dl>
<dl>
<dt>
cds_file</dt>
<dd>
Config::Model own serialization format (a bit like YAML). See Config::Model::Dumper for details.</dd>
</dl>
<div class="spacer">
</div>
With the backend name, the following parameters must be defined:<dl>
<dt>
config_dir</dt>
<dd>
The configuration directory</dd>
</dl>
<dl>
<dt>
file</dt>
<dd>
Config file name (optional). defaults to &quot;&lt;config_class_name&gt;.[pl|ini|cds]&quot;</dd>
</dl>
<div class="spacer">
</div>
<br/>
   read_config  =&gt; [ { backend    =&gt; 'cds_file' , <br/>
                       config_dir =&gt; '/etc/cfg_dir',<br/>
                       file       =&gt; 'cfg_file.cds', # optional<br/>
                   } ],<br/>
<div class="spacer">
</div>
See &quot;Built-in_backend&quot; in Config::Model::AutoRead.pm for details<div class="spacer">
</div>
Note that these parameters can also be set with the graphical configuration model editor.</div>
<div class="subsection">
<h2>Using a plugin read mechanism</h2> A plugin backend class can also be specified with:<div class="spacer">
</div>
<br/>
  read_config  =&gt; [ { backend    =&gt; 'foo' , <br/>
                      config_dir =&gt; '/etc/cfg_dir'<br/>
                  } ]<br/>
<div class="spacer">
</div>
In this case, Config::Model will try to load &quot;Config::Model::Backend::Foo&quot;. (The class name is constructed with &quot;ucfirst($backend_name)&quot;)<div class="spacer">
</div>
&quot;read_config&quot; can also have custom parameters that will passed verbatim to &quot;Config::Model::Backend::Foo&quot; methods:<div class="spacer">
</div>
<br/>
  read_config  =&gt; [ { backend    =&gt; 'foo' , <br/>
                      config_dir =&gt; '/etc/cfg_dir',<br/>
                      my_param   =&gt; 'my_value',<br/>
                  } ]<br/>
<div class="spacer">
</div>
This &quot;Config::Model::Backend::Foo&quot; class is expected to provide the following methods:<dl>
<dt>
new</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
read</dt>
<dd>
</dd>
</dl>
<dl>
<dt>
write</dt>
<dd>
</dd>
</dl>
<div class="spacer">
</div>
Their signatures are explained in Config::Model::AutoRead doc on plugin backends</div>
<div class="subsection">
<h2>Using a custom class</h2> In case the plugin mechanism is not possible, a class with an arbitrary name can be specified:<div class="spacer">
</div>
<br/>
    read_config  =&gt; [ { backend =&gt; 'custom' , <br/>
                        class =&gt; 'MyRead',<br/>
                        config_dir =&gt; '/etc/foo', # optional<br/>
                        file =&gt; 'foo.conf',       # optional<br/>
                    } ]<br/>
<div class="spacer">
</div>
Even the read method can have an arbitrary name by specifying a &quot;function&quot; parameters.<div class="spacer">
</div>
For more details on available parameters on custom backends, see Config::Model::AutoRead doc on custom backends</div>
<div class="subsection">
<h2>Using several read mechanisms</h2> Several read mechanism can be specified to enable:<dl>
<dt>
&#8226;</dt>
<dd>
Migration from one syntax to another</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Usage of different libraries (e.g. Augeas &lt;http://augeas.net&gt; or pure Perl backend)</dd>
</dl>
<div class="spacer">
</div>
For instance, to try Augeas and fall back on a custom class in case of problem, specify:<div class="spacer">
</div>
<br/>
  read_config =&gt; [ {<br/>
                     save =&gt; 'backup',<br/>
                     file =&gt; 'sshd_config',<br/>
                     backend =&gt; 'augeas',<br/>
                     config_dir =&gt; '/etc/ssh'<br/>
                   },<br/>
                   {<br/>
                     function =&gt; 'sshd_read',<br/>
                     backend =&gt; 'custom',<br/>
                     class =&gt; 'Config::Model::OpenSsh',<br/>
                     config_dir =&gt; '/etc/ssh'<br/>
                 } ],<br/>
<div class="spacer">
</div>
Both specifications are tried in order. If Augeas backend fails (e.g. Augeas is not installed), the custom backend will be used.<div class="spacer">
</div>
An exception will be raised if both methods fails. This behavior is correct for &quot;OpenSsh&quot;, but it can be a problem if you want to use Config::Model to create a configuration file from scratch. In this case you will also have to specify the &quot;auto_create&quot; parameter:<div class="spacer">
</div>
<br/>
 read_config =&gt; [ { backend =&gt; 'custom' , <br/>
                    class =&gt; 'ProcessRead' ,<br/>
                    config_dir =&gt; '/etc/foo',<br/>
                    file  =&gt; 'foo.conf',<br/>
                    auto_create =&gt; 1,<br/>
                } ],<br/>
</div>
</div>
<div class="section">
<h1>Writing configuration files</h1> Read and write specifications were designed to be very similar. Most of the times, the &quot;read&quot; and &quot;write&quot; specification will be identical. In this case, there's no need to enter them: the data specified in the &quot;read&quot; specification will be used to write the configuration file.<div class="spacer">
</div>
Here's an example:<div class="spacer">
</div>
<br/>
  write_config =&gt; [ { backend =&gt; 'custom', <br/>
                      class =&gt; 'NewFormat' <br/>
                      function =&gt; 'my_write',<br/>
                    } <br/>
                  ],<br/>
<div class="spacer">
</div>
Several &quot;write&quot; specification can be used. They are tried in order, until the first succeeds.<div class="spacer">
</div>
For more information, see write specification doc</div>
<div class="section">
<h1>Syntax migration example</h1> By combining multiple read specification with &quot;'one&quot;' write specification, a configuration file can be migrated from old to new syntax. The following example will migrate a configuration file from a custom syntax to a perl data file:<div class="spacer">
</div>
<br/>
 { <br/>
  name =&gt; 'Example',<br/>
  element =&gt; [ ... ] ,<br/>
  read_config  =&gt; [ { backend =&gt; 'perl_file', <br/>
                      config_dir =&gt; '/etc/my_cfg/' <br/>
                    } , <br/>
                    { backend =&gt; 'custom', <br/>
                      class =&gt; 'Bar' <br/>
                    }, <br/>
                  ],<br/>
  write_config =&gt; [ { backend =&gt; 'perl_file', <br/>
                      config_dir =&gt; '/etc/my_cfg/' <br/>
                    }<br/>
                  ],<br/>
 }<br/>
<div class="spacer">
</div>
How does this work ? Here's the sequence:<dl>
<dt>
1.</dt>
<dd>
Configuration is stored in old file &quot;/etc/my_cfg/bar.conf&quot;</dd>
</dl>
<dl>
<dt>
2.</dt>
<dd>
Config::Model tries to read the config with &quot;perl_file&quot; read backend and looks for &quot;/etc/my_cfg/example.pl&quot;. This file is not found so the read fails.</dd>
</dl>
<dl>
<dt>
3.</dt>
<dd>
Config::Model tries the second backend which succeeds and load configuration data in the configuration tree</dd>
</dl>
<dl>
<dt>
4.</dt>
<dd>
Config::Model writes data back from configuration tree using &quot;write_config&quot; backend which writes &quot;/etc/my_cfg/example.pl&quot;</dd>
</dl>
<dl>
<dt>
5.</dt>
<dd>
At the next invocation, the first &quot;read&quot; backend will successfully read the perl configuration file. The old file is left alone and can be removed later by the system admin.</dd>
</dl>
<div class="spacer">
</div>
Thanks to this mechanism, this operation is idempotent so it can safely be scripted in package scriplets.</div>
<div class="section">
<h1>SEE ALSO</h1><dl>
<dt>
&#8226;</dt>
<dd>
More complex models: Config::Model::Manual::ModelCreationAdvanced</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Config::Model::Manual::ModelForUpgrade: Writing a model for configuration upgrades</dd>
</dl>
<dl>
<dt>
&#8226;</dt>
<dd>
Configuration upgrades within Debian packages &lt;http://wiki.debian.org/PackageConfigUpgrade&gt;</dd>
</dl>
</div>
<div class="section">
<h1>Feedback welcome</h1> Feel free to send comments and suggestion about this page at<div class="spacer">
</div>
<br/>
 config-model-users at lists dot sourceforge dot net.<br/>
</div>
<div class="section">
<h1>AUTHORS</h1> Dominique Dumont &lt;ddumont at cpan.org&gt;</div>
<table class="foot">
<tr>
<td class="foot-date">
2012-02-24</td>
<td class="foot-os">
perl v5.14.2</td>
</tr>
</table>
</div>
</body>
</html>

