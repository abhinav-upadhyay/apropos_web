<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
DMSETUP(8)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
DMSETUP(8)</td>
<td class="head-vol">
MAINTENANCE COMMANDS</td>
<td class="head-rtitle">
DMSETUP(8)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> dmsetup - low level logical volume management</div>
<div class="section">
<h1>SYNOPSIS</h1> <b>dmsetup help</b> <i>[-c|-C|--columns]</i><div style="height: 0.00em;">
&#160;</div>
<b>dmsetup create</b> <i>device_name [-u uuid] [--notable | --table &lt;table&gt; | table_file]</i><div style="height: 0.00em;">
&#160;</div>
<b>dmsetup remove</b> <i>[-f|--force] device_name</i><div style="height: 0.00em;">
&#160;</div>
<b>dmsetup remove_all</b> <i>[-f|--force]</i><div style="height: 0.00em;">
&#160;</div>
<b>dmsetup suspend</b> <i>[--nolockfs] [--noflush] device_name</i><div style="height: 0.00em;">
&#160;</div>
<b>dmsetup resume</b> <i>device_name</i><div style="height: 0.00em;">
&#160;</div>
<b>dmsetup load</b> <i>device_name [--table &lt;table&gt; | table_file]</i><div style="height: 0.00em;">
&#160;</div>
<b>dmsetup clear</b> <i>device_name</i><div style="height: 0.00em;">
&#160;</div>
<b>dmsetup reload</b> <i>device_name [--table &lt;table&gt; | table_file]</i><div style="height: 0.00em;">
&#160;</div>
<b>dmsetup rename</b> <i>device_name new_name</i><div style="height: 0.00em;">
&#160;</div>
<b>dmsetup message</b> <i>device_name sector message</i><div style="height: 0.00em;">
&#160;</div>
<b>dmsetup ls</b> <i>[--target target_type] [--exec command] [--tree [-o options]]</i><div style="height: 0.00em;">
&#160;</div>
<b>dmsetup info</b> <i>[device_name]</i><div style="height: 0.00em;">
&#160;</div>
<b>dmsetup info -c|-C|--columns</b> <i>[--noheadings] [--separator separator] [-o fields] [-O|--sort sort_fields]</i> <i>[device_name]</i><div style="height: 0.00em;">
&#160;</div>
<b>dmsetup deps</b> <i>[device_name]</i><div style="height: 0.00em;">
&#160;</div>
<b>dmsetup status</b> <i>[--target target_type]</i> <i>[device_name]</i><div style="height: 0.00em;">
&#160;</div>
<b>dmsetup table</b> <i>[--target target_type] [--showkeys]</i> <i>[device_name]</i><div style="height: 0.00em;">
&#160;</div>
<b>dmsetup wait</b> <i>device_name</i> <i>[event_nr]</i><div style="height: 0.00em;">
&#160;</div>
<b>dmsetup mknodes</b> <i>[device_name]</i><div style="height: 0.00em;">
&#160;</div>
<b>dmsetup udevcreatecookie</b><div style="height: 0.00em;">
&#160;</div>
<b>dmsetup udevreleasecookie</b> <i>[cookie]</i><div style="height: 0.00em;">
&#160;</div>
<b>dmsetup udevflags</b> <i>cookie</i><div style="height: 0.00em;">
&#160;</div>
<b>dmsetup udevcomplete</b> <i>cookie</i><div style="height: 0.00em;">
&#160;</div>
<b>dmsetup udevcomplete_all</b><div style="height: 0.00em;">
&#160;</div>
<b>dmsetup udevcookies</b><div style="height: 0.00em;">
&#160;</div>
<b>dmsetup targets</b><div style="height: 0.00em;">
&#160;</div>
<b>dmsetup version</b><div style="height: 0.00em;">
&#160;</div>
<b>dmsetup setgeometry</b> <i>device_name cyl head sect start</i><div style="height: 0.00em;">
&#160;</div>
<b>dmsetup splitname</b> <i>device_name</i> <i>[subsystem]</i><div style="height: 0.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
<b>devmap_name</b> <i>major minor</i><div style="height: 0.00em;">
&#160;</div>
<b>devmap_name</b> <i>major:minor</i></div>
<div class="section">
<h1>DESCRIPTION</h1> dmsetup manages logical devices that use the device-mapper driver. Devices are created by loading a table that specifies a target for each sector (512 bytes) in the logical device.<div style="height: 1.00em;">
&#160;</div>
The first argument to dmsetup is a command. The second argument is the logical device name or uuid.<div style="height: 1.00em;">
&#160;</div>
Invoking the command as <b>devmap_name</b> is equivalent to<div style="height: 0.00em;">
&#160;</div>
<b>dmsetup info -c --noheadings -j </b><i>major</i><b> -m </b><i>minor</i><b>.</b></div>
<div class="section">
<h1>OPTIONS</h1><dl>
<dt>
<b>-c|-C|--columns</b></dt>
<dd>
<div style="height: 0.00em;">
&#160;</div>
Display output in columns rather than as Field: Value lines.</dd>
</dl>
<dl>
<dt>
<b>-h|--help</b></dt>
<dd>
<div style="height: 0.00em;">
&#160;</div>
Outputs a summary of the commands available, optionally including the list of report fields (synonym with  <b>help</b> command).</dd>
</dl>
<dl>
<dt>
<b>--inactive</b></dt>
<dd>
<div style="height: 0.00em;">
&#160;</div>
When returning any table information from the kernel report on the inactive table instead of the live table. Requires kernel driver version 4.16.0 or above.</dd>
</dl>
<dl>
<dt>
<b>-j|--major&#160;</b><i>major</i></dt>
<dd>
<div style="height: 0.00em;">
&#160;</div>
Specify the major number.</dd>
</dl>
<dl>
<dt>
<b>-m|--minor&#160;</b><i>minor</i></dt>
<dd>
<div style="height: 0.00em;">
&#160;</div>
Specify the minor number.</dd>
</dl>
<dl>
<dt>
<b>-n|--noheadings</b></dt>
<dd>
<div style="height: 0.00em;">
&#160;</div>
Suppress the headings line when using columnar output.</dd>
</dl>
<dl>
<dt>
<b>--noopencount</b></dt>
<dd>
<div style="height: 0.00em;">
&#160;</div>
Tell the kernel not to supply the open reference count for the device.</dd>
</dl>
<dl>
<dt>
<b>--notable</b></dt>
<dd>
<div style="height: 0.00em;">
&#160;</div>
When creating a device, don't load any table.</dd>
</dl>
<dl>
<dt>
<b>--udevcookie&#160;</b><i>cookie</i></dt>
<dd>
<div style="height: 0.00em;">
&#160;</div>
Use cookie for udev synchronisation.</dd>
</dl>
<dl>
<dt>
<b>--noudevrules</b></dt>
<dd>
Do not allow udev to manage nodes for devices in device-mapper directory.<div style="height: 0.00em;">
&#160;</div>
</dd>
</dl>
<dl>
<dt>
<b>--noudevsync</b></dt>
<dd>
Do not synchronise with udev when creating, renaming or removing devices.<div style="height: 0.00em;">
&#160;</div>
</dd>
</dl>
<dl>
<dt>
<b>-o|--options</b></dt>
<dd>
<div style="height: 0.00em;">
&#160;</div>
Specify which fields to display.</dd>
</dl>
<dl>
<dt>
<b>-r|--readonly</b></dt>
<dd>
<div style="height: 0.00em;">
&#160;</div>
Set the table being loaded read-only.</dd>
</dl>
<dl>
<dt>
<b>--readahead&#160;[+]&lt;sectors&gt;|auto|none</b></dt>
<dd>
<div style="height: 0.00em;">
&#160;</div>
Specify read ahead size in units of sectors. The default value is &quot;auto&quot; which allows the kernel to choose a suitable value automatically.  The + prefix lets you specify a minimum value which will not be used if it is smaller than the value chosen by the kernel. &quot;None&quot; is equivalent to specifying zero.</dd>
</dl>
<dl>
<dt>
<b>--table&#160;&lt;table&gt;</b></dt>
<dd>
<div style="height: 0.00em;">
&#160;</div>
Specify a one-line table directly on the command line.</dd>
</dl>
<dl>
<dt>
<b>-u|--uuid</b></dt>
<dd>
<div style="height: 0.00em;">
&#160;</div>
Specify the uuid.</dd>
</dl>
<dl>
<dt>
<b>-y|--yes</b></dt>
<dd>
<div style="height: 0.00em;">
&#160;</div>
Answer yes to all prompts automatically.</dd>
</dl>
<dl>
<dt>
<b>-v|--verbose&#160;[-v|--verbose]</b></dt>
<dd>
<div style="height: 0.00em;">
&#160;</div>
Produce additional output.</dd>
</dl>
<dl>
<dt>
<b>--version</b></dt>
<dd>
<div style="height: 0.00em;">
&#160;</div>
Display the library and kernel driver version.</dd>
</dl>
</div>
<div class="section">
<h1>COMMANDS</h1><dl>
<dt>
<b>create</b></dt>
<dd>
<i>device_name [-u uuid] [--notable | --table &lt;table&gt; | table_file]</i><div style="height: 0.00em;">
&#160;</div>
Creates a device with the given name. If table_file or &lt;table&gt; is supplied, the table is loaded and made live. Otherwise a table is read from standard input unless --notable is used. The optional uuid can be used in place of device_name in subsequent dmsetup commands. If successful a device will appear as /dev/device-mapper/&lt;device-name&gt;. See below for information on the table format.</dd>
</dl>
<dl>
<dt>
<b>deps</b></dt>
<dd>
<i>[device_name]</i><div style="height: 0.00em;">
&#160;</div>
Outputs a list of (major, minor) pairs for devices referenced by the live table for the specified device.</dd>
</dl>
<dl>
<dt>
<b>help</b></dt>
<dd>
<i>[-c|-C|--columns]</i><div style="height: 0.00em;">
&#160;</div>
Outputs a summary of the commands available, optionally including the list of report fields.</dd>
</dl>
<dl>
<dt>
<b>info</b></dt>
<dd>
<i>[device_name]</i><div style="height: 0.00em;">
&#160;</div>
Outputs some brief information about the device in the form:<div style="height: 0.00em;">
&#160;</div>
<br/>
    State: SUSPENDED|ACTIVE, READ-ONLY<div style="height: 0.00em;">
&#160;</div>
<br/>
    Tables present: LIVE and/or INACTIVE<div style="height: 0.00em;">
&#160;</div>
<br/>
    Open reference count<div style="height: 0.00em;">
&#160;</div>
<br/>
    Last event sequence number (used by <b>wait</b>)<div style="height: 0.00em;">
&#160;</div>
<br/>
    Major and minor device number<div style="height: 0.00em;">
&#160;</div>
<br/>
    Number of targets in the live table<div style="height: 0.00em;">
&#160;</div>
<br/>
    UUID</dd>
</dl>
<dl>
<dt>
<b>info</b></dt>
<dd>
<i>-c|-C|--columns</i> <i>[--noheadings] [--separator separator] [-o fields] [-O|--sort sort_fields]</i> <i>[device_name]</i><div style="height: 0.00em;">
&#160;</div>
Output you can customise. Fields are comma-separated and chosen from the following list: name, major, minor, attr, open, segments, events, uuid. Attributes are: (L)ive, (I)nactive, (s)uspended, (r)ead-only, read-(w)rite. Precede the list with '+' to append to the default selection of columns instead of replacing it. Precede any sort_field with - for a reverse sort on that column.</dd>
</dl>
<dl>
<dt>
<b>ls</b></dt>
<dd>
<i>[--target target_type]</i> <i>[--exec command]</i> <i>[--tree [-o options]]</i><div style="height: 0.00em;">
&#160;</div>
List device names.  Optionally only list devices that have at least one target of the specified type.  Optionally execute a command for each device.  The device name is appended to the supplied command. --tree displays dependencies between devices as a tree. It accepts a comma-separate list of options. Some specify the information displayed against each node: device/nodevice; active, open, rw, uuid. Others specify how the tree is displayed: ascii, utf, vt100; compact, inverted, notrunc.</dd>
</dl>
<dl>
<dt>
<b>load|reload</b></dt>
<dd>
<i>device_name [--table &lt;table&gt; | table_file]</i><div style="height: 0.00em;">
&#160;</div>
Loads &lt;table&gt; or table_file into the inactive table slot for device_name. If neither is supplied, reads a table from standard input.</dd>
</dl>
<dl>
<dt>
<b>message</b></dt>
<dd>
<i>device_name sector message</i><div style="height: 0.00em;">
&#160;</div>
Send message to target. If sector not needed use 0.</dd>
</dl>
<dl>
<dt>
<b>mknodes</b></dt>
<dd>
<i>[device_name]</i><div style="height: 0.00em;">
&#160;</div>
Ensure that the node in /dev/mapper for device_name is correct. If no device_name is supplied, ensure that all nodes in /dev/mapper correspond to mapped devices currently loaded by the device-mapper kernel driver, adding, changing or removing nodes as necessary.</dd>
</dl>
<dl>
<dt>
<b>remove</b></dt>
<dd>
<i>[-f|--force] device_name</i><div style="height: 0.00em;">
&#160;</div>
Removes a device.  It will no longer be visible to dmsetup. Open devices cannot be removed except with older kernels that contain a version of device-mapper prior to 4.8.0. In this case the device will be deleted when its open_count drops to zero.  From version 4.8.0 onwards, if a device can't be removed because an uninterruptible process is waiting for I/O to return from it, adding --force will replace the table with one that fails all I/O, which might allow the process to be killed.</dd>
</dl>
<dl>
<dt>
<b>remove_all</b></dt>
<dd>
<i>[-f|--force]</i><div style="height: 0.00em;">
&#160;</div>
Attempts to remove all device definitions i.e. reset the driver. Use with care!  From version 4.8.0 onwards, if devices can't be removed because uninterruptible processes are waiting for I/O to return from them, adding --force will replace the table with one that fails all I/O, which might allow the process to be killed.  This also runs  <b>mknodes</b> afterwards.</dd>
</dl>
<dl>
<dt>
<b>rename</b></dt>
<dd>
<i>device_name new_name</i><div style="height: 0.00em;">
&#160;</div>
Renames a device.</dd>
</dl>
<dl>
<dt>
<b>resume</b></dt>
<dd>
<i>device_name</i><div style="height: 0.00em;">
&#160;</div>
Un-suspends a device. If an inactive table has been loaded, it becomes live. Postponed I/O then gets re-queued for processing.</dd>
</dl>
<dl>
<dt>
<b>setgeometry</b></dt>
<dd>
<i>device_name cyl head sect start</i><div style="height: 0.00em;">
&#160;</div>
Sets the device geometry to C/H/S.</dd>
</dl>
<dl>
<dt>
<b>splitname</b></dt>
<dd>
<i>device_name</i> <i>[subsystem]</i><div style="height: 0.00em;">
&#160;</div>
Splits given device name into subsystem constituents. Default subsystem is LVM.</dd>
</dl>
<dl>
<dt>
<b>status</b></dt>
<dd>
<i>[--target target_type]</i> <i>[device_name]</i><div style="height: 0.00em;">
&#160;</div>
Outputs status information for each of the device's targets. With --target, only information relating to the specified target type is displayed.</dd>
</dl>
<dl>
<dt>
<b>suspend</b></dt>
<dd>
<i>[--nolockfs] [--noflush]</i> <i>device_name</i><div style="height: 0.00em;">
&#160;</div>
Suspends a device.  Any I/O that has already been mapped by the device but has not yet completed will be flushed.  Any further I/O to that device will be postponed for as long as the device is suspended. If there's a filesystem on the device which supports the operation, an attempt will be made to sync it first unless --nolockfs is specified. Some targets such as recent (October 2006) versions of multipath may support the --noflush option.  This lets outstanding I/O that has not yet reached the device to remain unflushed.</dd>
</dl>
<dl>
<dt>
<b>table</b></dt>
<dd>
<i>[--target target_type] [--showkeys]</i> <i>[device_name]</i><div style="height: 0.00em;">
&#160;</div>
Outputs the current table for the device in a format that can be fed back in using the create or load commands. With --target, only information relating to the specified target type is displayed. Encryption keys are suppressed in the table output for the crypt target unless the --showkeys parameter is supplied.</dd>
</dl>
<dl>
<dt>
<b>targets</b></dt>
<dd>
<div style="height: 0.00em;">
&#160;</div>
Displays the names and versions of the currently-loaded targets.<div style="height: 0.00em;">
&#160;</div>
</dd>
</dl>
<dl>
<dt>
<b>udevcreatecookie</b></dt>
<dd>
<div style="height: 0.00em;">
&#160;</div>
Creates a new cookie to synchronize actions with udev processing. The output is a cookie value. Normally we don't need to create cookies since dmsetup creates and destroys them for each action automatically. However, we can generate one explicitly to group several actions together and use only one cookie instead. We can define a cookie to use for each relevant command by using --udevcookie option. Alternatively, we can export this value into the environment of the dmsetup process as DM_UDEV_COOKIE variable and it will be used automatically with all subsequent commands until it is unset. Invoking this command will create system-wide semaphore that needs to be cleaned up explicitly by calling udevreleasecookie command.<div style="height: 0.00em;">
&#160;</div>
</dd>
</dl>
<dl>
<dt>
<b>udevreleasecookie</b></dt>
<dd>
<i>[cookie]</i><div style="height: 0.00em;">
&#160;</div>
Waits for all pending udev processing bound to given cookie value and clean up the cookie with underlying semaphore. If the cookie is not given directly, the command will try to use a value defined by DM_UDEV_COOKIE environment variable.<div style="height: 0.00em;">
&#160;</div>
</dd>
</dl>
<dl>
<dt>
<b>udevflags</b></dt>
<dd>
<i>cookie</i><div style="height: 0.00em;">
&#160;</div>
Parses given cookie value and extracts any udev control flags encoded. The output is in environment key format that is suitable for use in udev rules. If the flag has its symbolic name assigned then the ouput is DM_UDEV_FLAG_&lt;flag_name&gt;='1', DM_UDEV_FLAG&lt;flag_position&gt;='1' otherwise. Subsystem udev flags don't have symbolic names assigned and these ones are always reported as DM_SUBSYSTEM_UDEV_FLAG&lt;flag_position&gt;='1'. There are 16 udev flags altogether.<div style="height: 0.00em;">
&#160;</div>
</dd>
</dl>
<dl>
<dt>
<b>udevcomplete</b></dt>
<dd>
<i>cookie</i><div style="height: 0.00em;">
&#160;</div>
Wake any processes that are waiting for udev to complete processing the specified cookie.<div style="height: 0.00em;">
&#160;</div>
</dd>
</dl>
<dl>
<dt>
<b>udevcomplete_all</b></dt>
<dd>
Remove all cookies. Any process waiting on a cookie will be resumed immediately.<div style="height: 0.00em;">
&#160;</div>
</dd>
</dl>
<dl>
<dt>
<b>udevcookies</b></dt>
<dd>
List all existing cookies. Cookies are system-wide semaphores with keys prefixed by two predefined bytes (0x0D4D).<div style="height: 0.00em;">
&#160;</div>
</dd>
</dl>
<dl>
<dt>
<b>version</b></dt>
<dd>
<div style="height: 0.00em;">
&#160;</div>
Outputs version information.</dd>
</dl>
<dl>
<dt>
<b>wait</b></dt>
<dd>
<i>device_name</i> <i>[event_nr]</i><div style="height: 0.00em;">
&#160;</div>
Sleeps until the event counter for device_name exceeds event_nr. Use -v to see the event number returned. To wait until the next event is triggered, use  <b>info</b> to find the last event number.</dd>
</dl>
</div>
<div class="section">
<h1>TABLE FORMAT</h1> Each line of the table specifies a single target and is of the form:<div style="height: 0.00em;">
&#160;</div>
<br/>
    logical_start_sector num_sectors target_type target_args<div style="height: 0.00em;">
&#160;</div>
<div style="height: 0.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
There are currently three simple target types available together with more complex optional ones that implement snapshots and mirrors.<div style="height: 1.00em;">
&#160;</div>
<dl>
<dt>
<b>linear</b></dt>
<dd>
<i>destination_device start_sector</i><div style="height: 0.00em;">
&#160;</div>
The traditional linear mapping.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<dl>
<dt>
<b>striped</b></dt>
<dd>
<i>num_stripes chunk_size [destination start_sector]+</i><div style="height: 0.00em;">
&#160;</div>
Creates a striped area.<div style="height: 0.00em;">
&#160;</div>
e.g. striped 2 32 /dev/hda1 0 /dev/hdb1 0 will map the first chunk (16k) as follows:<div style="height: 0.00em;">
&#160;</div>
<br/>
    LV chunk 1 -&gt; hda1, chunk 1<div style="height: 0.00em;">
&#160;</div>
<br/>
    LV chunk 2 -&gt; hdb1, chunk 1<div style="height: 0.00em;">
&#160;</div>
<br/>
    LV chunk 3 -&gt; hda1, chunk 2<div style="height: 0.00em;">
&#160;</div>
<br/>
    LV chunk 4 -&gt; hdb1, chunk 2<div style="height: 0.00em;">
&#160;</div>
<br/>
    etc.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<dl>
<dt>
<b>error</b></dt>
<dd>
<div style="height: 0.00em;">
&#160;</div>
Errors any I/O that goes to this area.  Useful for testing or for creating devices with holes in them.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
</div>
<div class="section">
<h1>EXAMPLES</h1> # A table to join two disks together<div style="height: 0.00em;">
&#160;</div>
<div style="height: 0.00em;">
&#160;</div>
0 1028160 linear /dev/hda 0<div style="height: 0.00em;">
&#160;</div>
1028160 3903762 linear /dev/hdb 0<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
# A table to stripe across the two disks,<div style="height: 0.00em;">
&#160;</div>
# and add the spare space from<div style="height: 0.00em;">
&#160;</div>
# hdb to the back of the volume<div style="height: 1.00em;">
&#160;</div>
0 2056320 striped 2 32 /dev/hda 0 /dev/hdb 0<div style="height: 0.00em;">
&#160;</div>
2056320 2875602 linear /dev/hdb 1028160<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>ENVIRONMENT VARIABLES</h1><dl>
<dt>
<b>DM_DEV_DIR</b></dt>
<dd>
The device directory name. Defaults to &quot;/dev&quot; and must be an absolute path.</dd>
</dl>
<dl>
<dt>
<b>DM_UDEV_COOKIE</b></dt>
<dd>
A cookie to use for all relevant commands to synchronize with udev processing. It is an alternative to using --udevcookie option.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
</div>
<div class="section">
<h1>AUTHORS</h1> Original version: Joe Thornber (thornber@sistina.com)<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>SEE ALSO</h1> Device-mapper resource page: http://sources.redhat.com/dm/</div>
<table class="foot">
<tr>
<td class="foot-date">
Apr 06 2006</td>
<td class="foot-os">
Linux</td>
</tr>
</table>
</div>
</body>
</html>

