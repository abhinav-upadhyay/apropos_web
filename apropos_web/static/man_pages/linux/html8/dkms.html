<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
DKMS(8)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
DKMS(8)</td>
<td class="head-vol">
System Manager's Manual</td>
<td class="head-rtitle">
DKMS(8)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> dkms - Dynamic Kernel Module Support</div>
<div class="section">
<h1>SYNOPSIS</h1> [<span class="opt"><b>action</b>]</span> [<span class="opt"><b>options</b>]</span> [<span class="opt"><b>module/module-version</b>]</span> [<span class="opt"><b>/path/to/source-tree</b>]</span> [<span class="opt"><b>/path/to/tarball.tar</b>]</span> [<span class="opt"><b>/path/to/driver.rpm</b>]</span></div>
<div class="section">
<h1>DESCRIPTION</h1> <b>dkms</b> is a framework which allows kernel modules to be dynamically built for each kernel on your system in a simplified and organized fashion.</div>
<div class="section">
<h1>ACTIONS</h1> [<span class="opt"><b>module/module-version</b>]</span> [<span class="opt"><b>/path/to/source-tree</b>]</span> [<span class="opt"><b>/path/to/tarball.tar</b>]</span><dl>
<dt>
<div class="spacer">
</div>
</dt>
<dd>
Adds a module/module-version combination to the tree for builds and installs. If module/module-version, -m module/module-version, or -m module&#160;-v version are passed as options, this command requires source in <i>/usr/src/&lt;module&gt;-&lt;module-version&gt;/</i> as well as a properly formatted <i>dkms.conf</i> file. If <i>/path/to/source-tree</i> is passed as an option, and source-tree contains a <i>dkms.conf</i> file, it will copy <i>/path/to/source-tree</i> to <i>/usr/src/module-module-version.</i> If <i>/path/to/tarball.tar</i> is passed, this command behaves like the <b>ldtarball</b> command. [<span class="opt"><b>module/module-version</b>]</span> [<span class="opt"><b>-k</b> <i>kernel/arch</i>]</span> [<span class="opt"><b>--all</b>]</span></dd>
</dl>
<dl>
<dt>
<div class="spacer">
</div>
</dt>
<dd>
Removes a module/version or module/version/kernel/arch combination from the tree.  If the module is currently installed, it first uninstalls it and if applicable, will replace it with its original_module.  Use the <b>--all</b> option in order to remove all instances for every kernel at once. [<span class="opt"><b>module/module-version</b>]</span> [<span class="opt"><b>-k</b> <i>kernel/arch</i>]</span></dd>
</dl>
<dl>
<dt>
<div class="spacer">
</div>
</dt>
<dd>
Builds the specified module/version combo for the specified kernel/arch. If the <i>-k</i> option is not specified it builds for the currently running kernel and arch..  All builds occur in the directory <i>/var/lib/dkms/&lt;module&gt;/&lt;module-version&gt;/build/.</i> If the module/module-version combo has not been added, dkms will try to add it, and in that case <b>build</b> can take the same arguments that <b>add</b> can. [<span class="opt"><b>module/module-version</b>]</span> [<span class="opt"><b>-k</b> <i>kernel/arch</i>]</span> [<span class="opt"><b>/path/to/driver.rpm</b>]</span></dd>
</dl>
<dl>
<dt>
<div class="spacer">
</div>
</dt>
<dd>
Installs a built module/version combo onto the kernel it was built for. If the kernel option is not specified it assumes the currently running kernel. If the module has not been built, dkms will try to build it. If the module has not been added, dkms will try to add it.  In both cases, the <b>install</b> command can then take the same arguments as the <b>build</b> or <b>add</b> commands. If you pass a .rpm file, dkms will try to install that file with <b>rpm -Uvh</b> , and it will perform an <b>autoinstall</b> action to mesure that everything is built for your kernel if the RPM installed sucessfully. [<span class="opt"><b>module/module-version</b>]</span> [<span class="opt"><b>-k</b> <i>kernel/arch</i>]</span></dd>
</dl>
<dl>
<dt>
<div class="spacer">
</div>
</dt>
<dd>
Uninstalls an installed module/module-version combo from the kernel/arch passed in the -k option, or the current kernel if the -k option was not passed. upon.  After uninstall completion, the driver will be left in the built state. To completely remove a driver, the remove action should be utilized. [<span class="opt"><b>--templatekernel</b> <i>kernel/arch</i>]</span> [<span class="opt"><b>-k</b> <i>kernel/arch</i>]</span></dd>
</dl>
<dl>
<dt>
<div class="spacer">
</div>
</dt>
<dd>
Match installs modules onto the specified kernel by looking at the configuration of the specified <b>templatekernel.</b> Every module that is installed on the <b>templatekernel</b> within <b>dkms</b> is then installed on that specified kernel. [<span class="opt"><b>-d</b> <i>distro</i>]</span> [<span class="opt"><b>-r</b> <i>release</i>]</span> [<span class="opt"><b>--media</b> <i>mediatype</i>]</span> [<span class="opt"><b>-k</b> <i>kernel/arch</i>]</span> [<span class="opt"><b>module/version</b>]</span></dd>
</dl>
<dl>
<dt>
<div class="spacer">
</div>
</dt>
<dd>
Creates a floppy driver disk image for use when updated drivers are needed to install an OS.  Currently, the supported distributions are redhat, suse and UnitedLinux. For Red Hat driver disks, necessary driver disk files are looked for in the redhat_driver_disk subdirectory of your module source directory.  You must specify the distro while using this action.  Driver disks can be made for single kernels or can be made to support multiple kernels.  To create a driver disk image with modules for multiple kernels, just specify multiple -k parameters on the command line (-k kernel1/arch1 -k kernel2/arch2).<div style="height: 1.00em;">
&#160;</div>
Red Hat began supporting multi-arched driver disks in RHEL3.  To force creation of a driver disk with arch information, specify <b>-d redhat2</b> or if you specify multiple architectures on the command-line and use <b>-d redhat</b> , DKMS will create a version 2 driver disk.  By specifying <b>-d redhat1</b> , you can force a version 1 driver disk image.<div style="height: 1.00em;">
&#160;</div>
Note that redhat1 driver disks actually supported multiple architectures when the second arch was i386 and the kernel module was for the BOOT kernel.  DKMS allows for this, and as such you can create a redhat1 style driver disk if the only other arch is i386 and the kernel name ends in BOOT.<div style="height: 1.00em;">
&#160;</div>
Red Hat introduced DDv3 starting with RHEL6. To create Red Hat DDv3, specify <b>-d redhat3</b> and specify the specfile to use with <i>--spec=specfile.</i> If no specfile is specified, DKMS will use <i>/etc/dkms/template-dkms-redhat-kmod.spec</i><div style="height: 1.00em;">
&#160;</div>
See <i>http://people.redhat.com/dledford</i> for more information on the Red Hat driver disk standards and which files are necessary to make a driver disk.<div style="height: 1.00em;">
&#160;</div>
Fedora Core 5 and higher, RHEL5 and higher require DKMS version 2.0.14 or higher to generate a proper driver disk image.<div style="height: 1.00em;">
&#160;</div>
For suse/UnitedLinux driver disks, /usr/share/YaST2/modules/Vendor.ycp will also be copied to the driver disk; no other files are needed. However, for these distros, you must specify a -r release. For SuSE 9.1, it would be -d suse -r 9.1. For SLES9, it would be -d suse -r sles9.<div style="height: 1.00em;">
&#160;</div>
By default the disk image it creates is 1440 (k) in size.  This can be overridden by specifying a different <b>--size ####</b> which should should be given as a number in kilobytes divisible by 20.<div style="height: 1.00em;">
&#160;</div>
You may have more content than will fit on a floppy.  Therefore, DKMS can now generate image files of different types. <b>--media floppy (default)</b> to generate a floppy disk image, or <b>--media iso</b> to generate a CD-ROM ISO file, or <b>--media tar</b> to generate a tar file.<div style="height: 1.00em;">
&#160;</div>
You may copy the floppy or ISO image file to a USB key to be used with OS installer. [<span class="opt"><b>module/module-version</b>]</span> [<span class="opt"><b>-k</b> <i>kernel/arch</i>]</span> [<span class="opt"><b>--archive</b> <i>/path/to/tarball.tar</i>]</span> [<span class="opt"><b>--source-only</b>]</span> [<span class="opt"><b>--binaries-only</b>]</span></dd>
</dl>
<dl>
<dt>
<div class="spacer">
</div>
</dt>
<dd>
Creates a tarball archive for the specified module/version of all files in the DKMS tree for that module/version combination.  This includes the source and any built modules for kernels in the tree (as specified). Otherwise, you can specify a singular kernel to archive only, or multiple kernels to archive (-k kernel1/arch1 -k kernel2/arch2).  Optionally, you can use <b>--archive</b> to specify the file that you would like to save this tarball to.  You can also specify <b>--binaries-only</b> if you want the resultant tarball not to include the module source.  Likewise, <b>--source-only</b> can be used to specify that no prebuilt binaries should be included in the tarball. In general, <b>mktarball</b> is great for systems management purposes as you can build your driver on just one system and then use <b>ldtarball</b> on all of your other systems to get the same built modules loaded without having to wait for anything to compile.</dd>
</dl>
<dl>
<dt>
<div class="spacer">
</div>
</dt>
<dd>
This takes a tarball made from the <b>mktarball</b> command and loads it into your DKMS tree.  This will leave any newly added modules in the built state and <b>dkms install</b> should then be called to install any of them.  If files already exist where <b>ldtarball</b> is attempting to place them, it will warn and not copy over them.  The <b>--force</b> option should be used to override this. [<span class="opt"><b>module/module-version</b>]</span> [<span class="opt"><b>-k</b> <i>kernel/arch</i>]</span> [<span class="opt"><b>--source-only</b>]</span> [<span class="opt"><b>--binaries-only</b>]</span></dd>
</dl>
<dl>
<dt>
<div class="spacer">
</div>
</dt>
<dd>
This action allows you to create an RPM package for a specified module / version. It uses a template .spec file found in <i>/etc/dkms/template-dkms-mkrpm.spec</i> as the basis for the RPM.  Alternatively, if DKMS finds a file called <i>/usr/src/&lt;module&gt;-&lt;module-version&gt;/&lt;module&gt;-dkms-mkrpm.spec</i> it will use that .spec file instead.  In general, a DKMS tarball is placed inside the contents of this RPM, and the RPM itself calls various DKMS commands to load this tarball, build and install modules on the end user's system.  If you do not want your RPM to contain any prebuilt binaries, be sure to specify <b>--source-only</b> in the mkrpm command.</dd>
</dl>
<dl>
<dt>
[<span class="opt"><b>module/module-version</b>]</span></dt>
<dd>
[<span class="opt"><b>-k</b> <i>kernel/arch</i>]</span> [<span class="opt"><b>--binaries-only</b>]</span> [<span class="opt"><b>--source-only</b>]</span></dd>
</dl>
<dl>
<dt>
<div class="spacer">
</div>
</dt>
<dd>
This action allows you to create a debian binary package for a specified module / version. It uses a template debian directory found in <i>/etc/dkms/template-dkms-mkdeb</i> as the basis for the package. Alternatively, if DKMS finds a file called <i>/usr/src/&lt;module&gt;-&lt;module-version&gt;/&lt;module&gt;-dkms-mkdeb</i> it will use that folder instead. In general, a DKMS tarball is placed inside the contents of this package, and the package itself calls various DKMS commands to load this tarball, build and install modules on the end user's system.  If you do not want your debian package to contain any prebuilt binaries, be sure to specify <b>--source-only</b> in the mkdeb command. [<span class="opt"><b>module/module-version</b>]</span> [<span class="opt"><b>-k</b> <i>kernel/arch</i>]</span> [<span class="opt"><b>--binaries-only</b>]</span> [<span class="opt"><b>--source-only</b>]</span></dd>
</dl>
<dl>
<dt>
<div class="spacer">
</div>
</dt>
<dd>
This action allows you to create a debian source package for a specified module / version. It will create a .tar.gz, and a .dsc.  All options supported by <b>mkdeb</b> are supported by it.  The main difference in it's usage is that it will look in <i>/etc/dkms/template-dkms-mkdsc</i> as the basis for the package. Alternatively, if DKMS finds a file called <i>/usr/src/&lt;module&gt;-&lt;module-version&gt;/&lt;module&gt;-dkms-mkdsc</i> it will use that folder instead. If you do not want your debian source package to contain any prebuilt binaries, be sure to specify <b>--source-only</b> in the mkdsc command. [<span class="opt"><b>module/module-version</b>]</span> [<span class="opt"><b>--spec</b> <i>specfile</i>]</span></dd>
</dl>
<dl>
<dt>
<div class="spacer">
</div>
</dt>
<dd>
This action allows you to create an Kernel Module Package source RPM for a specified module / version. It uses the .spec file specified by <i>--spec=specfile</i> else <i>$module-kmp.spec</i> as the basis for the RPM.  The generated source RPM may then be built using SuSE's build.rpm or Fedora/RHEL's mock chroot environments.  See http://kerneldrivers.org/ for more details on KMPs. [<span class="opt"><b>module/module-version</b>]</span> [<span class="opt"><b>-k</b> <i>kernel/arch</i>]</span></dd>
</dl>
<dl>
<dt>
<div class="spacer">
</div>
</dt>
<dd>
Returns the current status of modules, versions and kernels within the tree as well as whether they have been added, built or installed. Status can be shown for just a certain module, a certain kernel, a module/version combination or a module/version/kernel combination.</dd>
</dl>
<dl>
<dt>
<div class="spacer">
</div>
</dt>
<dd>
Attempt to install the latest revision of all modules that have been installed for other kernel revisions. dkms_autoinstaller is a stub that uses this action to perform its work.</dd>
</dl>
</div>
<div class="section">
<h1>OPTIONS</h1><dl>
<dt>
<b>-m &lt;module&gt;/&lt;module-version&gt;</b></dt>
<dd>
The name of the module and module version you wnat to operate on. The <b>-m</b> part of this option is optional, and can be omitted in virtually all circumstances.</dd>
</dl>
<dl>
<dt>
<b>-v &lt;module-version&gt;</b></dt>
<dd>
The version of the module to execute the specified action upon.  This option only has to be specified if you pass a <b>-m</b> option without a &lt;module-version&gt; component of its own.</dd>
</dl>
<dl>
<dt>
<b>-k &lt;kernel-version&gt;/&lt;arch&gt;</b></dt>
<dd>
The kernel and arch to perform the action upon.  You can specify multiple kernel version/arch pairs on the command line by repeating the -k argument with a different kernel version and arch. However, not all actions support multiple kernel versions (it will error out in this case). The arch part can be omitted, and DKMS will assume you want it to be the arch of the currently running system.</dd>
</dl>
<dl>
<dt>
<b>-a, --arch</b></dt>
<dd>
The system architecture to perform the action upon.  It is optional if you pass it as part of the <b>-k</b> option. If not specified, it assumes the arch of the currently running system (`uname -m`).  You can specify multiple arch parameters on the same command line by repeating the -a argument with a different arch name.  When multiple architectures are specified, there must be a 1:1 relationship between -k arguments to -a arguments.  DKMS will then assume the first -a argument aligns with the first -k kernel and so on for the second, third, etc.<div style="height: 1.00em;">
&#160;</div>
For example, if you were to specify: -k kernel1 -k kernel2 -a i386 -k kernel3 -a i686 -a x86_64, DKMS would process this as: kernel1-i386, kernel2-i686, kernel3-x86_64.</dd>
</dl>
<dl>
<dt>
<b>-q, --quiet</b></dt>
<dd>
Quiet.</dd>
</dl>
<dl>
<dt>
<b>-V, --version</b></dt>
<dd>
Prints the currently installed version of dkms and exits.</dd>
</dl>
<dl>
<dt>
<b>-c &lt;dkms.conf-location&gt;</b></dt>
<dd>
The location of the <i>dkms.conf</i> file.  This is needed for the add action and if not specified, it is assumed to be located in <i>/usr/src/&lt;module&gt;-&lt;module-version&gt;/.</i> See below for more information on the format of <i>dkms.conf.</i></dd>
</dl>
<dl>
<dt>
<b>-d, --distro</b></dt>
<dd>
The distribution being used.  This is only currently needed for <b>mkdriverdisk.</b> The supported distros are <b>redhat,</b> <b>suse</b> and <b>UnitedLinux.</b> See the sections on <b>mkdriverdisk</b> and <b>mkkmp</b> for more information.</dd>
</dl>
<dl>
<dt>
<b>-r, --release</b></dt>
<dd>
The release being used.  This is only currently used for <b>mkdriverdisk</b> and is only used for suse or UnitedLinux distros (eg. -r 9.1).  It is used in the internal makeup of the driverdisk.</dd>
</dl>
<dl>
<dt>
<b>--size</b></dt>
<dd>
The size of the driver disk image to be created.  By default, this value is set at 1440.  Any different size should be given as an integer value only, should be divisible by 20 and should represent the number of kilobytes of the image size you desire.</dd>
</dl>
<dl>
<dt>
<b>--config &lt;kernel-.config-location&gt;</b></dt>
<dd>
During a <b>build</b> this option is used to specify an alternate location for the kernel .config file which was used to compile that kernel.  Normally, <b>dkms</b> uses the Red Hat standard location and config filenames located in <i>/usr/src/linux-&lt;kernel&gt;/configs/.</i> If the config for the kernel that you are building a module for is not located here or does not have the expected name in this location, you will need to tell <b>dkms</b> where the necessary .config can be found so that your kernel can be properly prepared for the module build.</dd>
</dl>
<dl>
<dt>
<b>--archive &lt;tarball-location&gt;</b></dt>
<dd>
This option is used during a <b>ldtarball</b> action to specify the location of the tarball you wish to load into your DKMS tree.  You only have to specify the <b>--archive</b> part of this option if &lt;tarball-location&gt; does not already exist as a file.</dd>
</dl>
<dl>
<dt>
<b>--templatekernel &lt;kernel-version&gt;</b></dt>
<dd>
This option is required for the action: <b>match.</b> Match will look at the templatekernel specified and install all of the same module/version combinations on the other kernel.</dd>
</dl>
<dl>
<dt>
<b>--force</b></dt>
<dd>
This option can be used in conjunction with <b>ldtarball</b> to force copying over of extant files.</dd>
</dl>
<dl>
<dt>
<b>--binaries-only</b></dt>
<dd>
This option can be used in conjunction with <b>mktarball</b> in order to create a DKMS tarball which does not contain the source for the module within it.  This can be helpful in reducing the size of the tarball if you know that the system which this tarball will be loaded upon already has the source installed.  In order to load a tarball made as binaries-only <b>you must</b> have the module source in that systems DKMS tree.  If you do not, DKMS <b>will refuse</b> to load a binaries-only tarball.</dd>
</dl>
<dl>
<dt>
<b>--source-only</b></dt>
<dd>
This option can be used in conjunction with <b>mktarball</b> or <b>mkrpm</b> or <b>mkdeb</b> in order to create a DKMS tarball which does not contain any prebuilt kernel module binaries within it.  This is helpful if you simply want to easily tar up your source but don't want anything prebuilt within it.  Likewise, if you are using <b>mkrpm</b> but do not want the RPM you create to have any prebuilt modules within it, passing this option will keep its internal DKMS tarball from containing any prebuilt modules.</dd>
</dl>
<dl>
<dt>
<b>--all</b></dt>
<dd>
This option can be used to automatically specify all relevant kernels/arches for a module/module-version.  This is useful for things like <b>remove</b> , <b>mktarball</b> , etc.  This saves the trouble of having to actually specify -k kernel1 -a arch1 -k kernel2 -a arch2 for every kernel you have built your module for.</dd>
</dl>
<dl>
<dt>
<b>--no-prepare-kernel</b></dt>
<dd>
This option keeps DKMS from first preparing your kernel before building a module for it.  Generally, this option should not be used so as to ensure that modules are compiled correctly.</dd>
</dl>
<dl>
<dt>
<b>--no-clean-kernel</b></dt>
<dd>
This option keeps DKMS from cleaning your kernel source tree after a build.</dd>
</dl>
<dl>
<dt>
<b>--kernelsourcedir &lt;kernel-source-directory-location&gt;</b></dt>
<dd>
Using this option you can specify the location of your kernel source directory.  Most likely you will not need to set this if your kernel source is accessible via <i>/lib/modules/$kernel_version/build.</i></dd>
</dl>
<dl>
<dt>
<b>--directive &lt;&quot;cli-directive=cli-value&quot;&gt;</b></dt>
<dd>
Using this option, you can specify additional directives from the command line.  The <b>--directive</b> option can be used multiple times on the same command-line to specify multiple additional command line directives.</dd>
</dl>
<dl>
<dt>
<b>--rpm_safe_upgrade</b></dt>
<dd>
This flag should be used when packaging DKMS enabled modules in RPMs.  It should be specified during both the <b>add</b> and <b>remove</b> actions in the RPM spec to ensure that DKMS and RPM behave correctly in all scenarios when upgrading between various versions of a dkms enabled module RPM package.  See the sample.spec file for an example or read more in the section below on Creating RPMs Which Utilize DKMS.</dd>
</dl>
<dl>
<dt>
<b>--spec specfile</b></dt>
<dd>
This option is used by the <b>mkkmp</b> action to specify which RPM spec file to use when generating the KMP. <i>specfile</i> will be sought in the module source directory.</dd>
</dl>
<dl>
<dt>
<b>--dkmstree path/to/place</b></dt>
<dd>
Provides a destination tree for building and installing modules to.  Useful in cases that you don't want to contaminate a system when using solely for building.</dd>
</dl>
<dl>
<dt>
<b>--sourcetree path/to/place</b></dt>
<dd>
Provides a location to build a DKMS package from.  Useful for systems that you may not have root access, but would still like to be able to build DKMS packages.</dd>
</dl>
<dl>
<dt>
<b>--installtree path/to/place</b></dt>
<dd>
Provides a location to place modules when a <i>dkms install</i> command is issued.</dd>
</dl>
<dl>
<dt>
<b>--legacy-postinst=[0|1]</b></dt>
<dd>
Includes a legacy postinstall script so that a DEB or RPM built by DKMS can be used on versions prior than DKMS 2.1.  This option currently defaults to 1.</dd>
</dl>
<dl>
<dt>
<b>--dkmsframework path/to/file</b></dt>
<dd>
A supplemental configuration file to the system-wide dkms framework, typically located in /etc/dkms/framework.conf.  All option that are normally provided on a command line can be provided in this file.</dd>
</dl>
</div>
<div class="section">
<h1>ORIGINAL MODULES</h1> During the first install of a module for a &lt;kernelversion&gt;, <b>dkms</b> will search <i>/lib/modules/&lt;kernelversion&gt;</i> for a pre-existing module of the same name. If one is found, it will automatically be saved as an &quot;original_module&quot; so that if the newer module is later removed, <b>dkms</b> will put the original module back in its place.  Currently, DKMS searches for these original modules with first preference going to modules located in <i>/lib/modules/&lt;kernelversion&gt;/updates/</i> followed by <b>$DEST_MODULE_LOCATION</b> (as specified in <i>dkms.conf</i> ).  If one cannot be found in either location, a find will be used to locate one for that kernel. If none are found, then during a later uninstall, your kernel will not have that module replaced.<div style="height: 1.00em;">
&#160;</div>
If more than one is found, then the first one located (by preference indicated above) will be considered the &quot;original_module&quot;.  As well, all copies of the same-named module will be removed from your kernel tree and placed into <i>/var/lib/dkms/&lt;module&gt;/original_module/$kernelver/collisions</i> so that they can be *manually* accessible later. DKMS will never actually do anything with the modules found underneath the /collisions directory, and they will be stored there until you manually delete them.</div>
<div class="section">
<h1>DKMS.CONF</h1> When performing an <b>add</b> , a proper <i>dkms.conf</i> file must be found.  A properly formatted conf file is essential for communicating to <b>dkms</b> how and where the module should be installed.  While not all the directives are required, providing as many as possible helps to limit any ambiguity.  Note that the <i>dkms.conf</i> is really only a shell-script of variable definitions which are then sourced in by the <b>dkms</b> executable (of the format, DIRECTIVE=&quot;directive text goes here&quot;).  As well, the directives are case-sensitive and should be given in <b>ALL CAPS.</b><div style="height: 1.00em;">
&#160;</div>
It is important to understand that many of the DKMS directives are arrays whose index values are tied together.  These array associations can be considered families, and there are currently four such families of directive arrays.  MAKE[#] and MAKE_MATCH[#] make up one family.  PATCH[#] and PATCH_MATCH[#] make up the second family.  The third  and largest family consists of BUILT_MODULE_NAME[#], BUILT_MODULE_LOCATION[#], DEST_MODULE_NAME[#], DEST_MODULE_LOCATION[#], MODULES_CONF_ALIAS_TYPE[#], MODULES_CONF_OBSOLETES[#], MODULES_CONF_OBSOLETE_ONLY[#] and STRIP[#].  The fourth family is made up of only MODULES_CONF[#].  When indexing these arrays when creating your dkms.conf, each family should start at index value 0.<dl>
<dt>
<b>MAKE[#]=</b></dt>
<dd>
The MAKE directive array tells DKMS which make command should be used for building your module. The default make command should be put into <b>MAKE[0].</b> Other entries in the MAKE array will only be used if their corresponding entry in <b>MAKE_MATCH[#]</b> matches, as a regular expression (using egrep), the kernel that the module is being built for. Note that if no value is placed in <b>MAKE_MATCH[#]</b> for any <b>MAKE[#]</b> where # &gt; 0, then that <b>MAKE</b> directive is ignored. <b>MAKE_MATCH[0]</b> is optional and if it is populated, it will be used to determine if MAKE[0] should be used to build the module for that kernel.  If multiple <b>MAKE_MATCH</b> directives match against the kernel being built for, the last matching <b>MAKE[#]</b> will be used to build your module. If no MAKE directive is specified or if no MAKE_MATCH matches the kernel being built for, DKMS will attempt to use a generic MAKE command to build your module.<div style="height: 1.00em;">
&#160;</div>
KERNELRELEASE will be automatically appended to MAKE[#].  If you want to suppress this behavior, you can quote the make command: 'make'.</dd>
</dl>
<dl>
<dt>
<b>MAKE_MATCH[#]=</b></dt>
<dd>
See the above entry on <b>MAKE[#]</b> directives.  This array should be populated with regular expressions which, when matched against the kernel being built for, will tell <b>DKMS</b> to use the corresponding make command in the <b>MAKE[#]</b> directive array to build your module.</dd>
</dl>
<dl>
<dt>
<b>BUILT_MODULE_NAME[#]=</b></dt>
<dd>
This directive gives the name of the module just after it is built.  If your DKMS module package contains more than one module to install, this is a <b>required</b> directive for all of the modules.  This directive should explicitly not contain any trailing &quot;.o&quot; or &quot;.ko&quot;. Note that for each module within a dkms package, the numeric value of <b>#</b> must be the same for each of BUILT_MODULE_NAME, BUILT_MODULE_LOCATION, DEST_MODULE_NAME and DEST_MODULE_LOCATION and that the numbering should start at 0 (eg. BUILT_MODULE_NAME[0]=&quot;qla2200&quot; BUILT_MODULE_NAME[1]=&quot;qla2300&quot;).</dd>
</dl>
<dl>
<dt>
<b>BUILT_MODULE_LOCATION[#]=</b></dt>
<dd>
This directive tells DKMS where to find your built module after it has been built.  This pathname should be given relative to the root directory of your source files (where your dkms.conf file can be found).  If unset, DKMS expects to find your <b>BUILT_MODULE_NAME[#]</b> in the root directory of your source files. Note that for each module within a dkms package, the numeric value of <b>#</b> must be the same for each of BUILT_MODULE_NAME, BUILT_MODULE_LOCATION, DEST_MODULE_NAME and DEST_MODULE_LOCATION and that the numbering should start at 0 (eg. BUILT_MODULE_LOCATION[0]=&quot;some/dir/&quot; BUILT_MODULE_LOCATION[1]=&quot;other/dir/&quot;).</dd>
</dl>
<dl>
<dt>
<b>DEST_MODULE_NAME[#]=</b></dt>
<dd>
This directive can be used to specify the name of the module as it should be installed.  This will rename the module from <b>BUILT_MODULE_NAME[#]</b> to <b>DEST_MODULE_NAME[#].</b> This directive should explicitly not contain any trailing &quot;.o&quot; or &quot;.ko&quot;.  If unset, it is assumed to be the same value as <b>BUILT_MODULE_NAME[#].</b> Note that for each module within a dkms package, the numeric value of <b>#</b> must be the same for each of BUILT_MODULE_NAME, BUILT_MODULE_LOCATION, DEST_MODULE_NAME and DEST_MODULE_LOCATION and that the numbering should start at 0 (eg. DEST_MODULE_NAME[0]=&quot;qla2200_6x&quot; DEST_MODULE_NAME[1]=&quot;qla2300_6x&quot;).</dd>
</dl>
<dl>
<dt>
<b>DEST_MODULE_LOCATION[#]=</b></dt>
<dd>
This directive specifies the destination where a module should be installed to, once compiled.  It also is used for finding original_modules.  This is a <b>required</b> directive, except as noted below. This directive must start with the text &quot;/kernel&quot; which is in reference to /lib/modules/&lt;kernelversion&gt;/kernel. Note that for each module within a dkms package, the numeric value of <b>#</b> must be the same for each of BUILT_MODULE_NAME, BUILT_MODULE_LOCATION, DEST_MODULE_NAME and DEST_MODULE_LOCATION and that the numbering should start at 0 (eg. DEST_MODULE_LOCATION[0]=&quot;/kernel/drivers/something/&quot; DEST_MODULE_LOCATION[1]=&quot;/kernel/drivers/other/&quot;).<div style="height: 1.00em;">
&#160;</div>
DEST_MODULE_LOCATION is ignored on Fedora Core 6 and higher, Red Hat Enterprise Linux 5 and higher, Novell SuSE Linux Enterprise Server 10 and higher, Novell SuSE Linux 10.0 and higher, and Ubuntu. Instead, the proper distribution-specific directory is used.</dd>
</dl>
<dl>
<dt>
<b>MODULES_CONF_ALIAS_TYPE[#]=</b></dt>
<dd>
This directive array specifies how your modules should be aliased in <i>/etc/modules.conf</i> when your module is installed.  This is done in an intelligent fashion so if DKMS detects an already existing reference in modules.conf, it won't add a new line.  If it is not detected, it will add it to the modules.conf as the last alias number for that alias type (eg. if MODULES_CONF_ALIAS_TYPE=&quot;scsi_hostadapter&quot;, no alias currently exists for that module and the last scsi_hostadapter reference is 6, then your module will be added as &quot;scsi_hostadapter7&quot;).  Common values for this directive include: <b>scsi_hostadapter</b> , <b>sound-slot-</b> and <b>eth.</b> Note that the numeric value of <b>#</b> is tied to the index of BUILD_MODULE_NAME, BUILT_MODULE_LOCATION, DEST_MODULE_NAME and DEST_MODULE_LOCATION.  The index is also tied to MODULES_CONF_OBSOLETES.</dd>
</dl>
<dl>
<dt>
<b>MODULES_CONF_OBSOLETES[#]=</b></dt>
<dd>
This directive array tells DKMS what modules.conf alias references are obsoleted by the module you are installing.  If your module obsoletes more than one module, this directive should be a comma-delimited list of those modules that are obsoleted (eg. for megaraid2, MODULES_CONF_OBSOLETES[0]=&quot;megaraid,megaraid_2002&quot;). When you are installing your module, DKMS ensures that any entries in <i>/etc/modules.conf</i> with the same <b>MODULES_CONF_ALIAS_TYPE</b> are changed over to the new module name.  When you are uninstalling your module, depending on the modules in your <i>/lib/modules</i> tree, DKMS will take different actions. If you kernel has an original_module, then modules.conf will not be touched and the non-obsolete reference will remain.  If the kernel does not have an original_module but does have one of the obsolete modules, it will replace those references with the first obsolete module name in the comma-delimited list that is also in that kernel (thus, your obsolete list should be prioritized from left to right).  If no original_module or obsolete modules are found within the kernel, the alias entry is removed all-together. Note that the numeric value of <b>#</b> is tied to the index of BUILD_MODULE_NAME, BUILT_MODULE_LOCATION, DEST_MODULE_NAME and DEST_MODULE_LOCATION.  The index is also tied to MODULES_CONF_ALIAS_TYPE.</dd>
</dl>
<dl>
<dt>
<b>MODULES_CONF_OBSOLETE_ONLY[#]=</b></dt>
<dd>
If set to <b>yes</b> , this directive will tell DKMS to only modify <i>/etc/modules.conf</i> if it finds within it an obsolete reference as specified in the corresponding value of <b>MODULES_CONF_OBSOLETES[#]</b> array directive.</dd>
</dl>
<dl>
<dt>
<b>STRIP[#]=</b></dt>
<dd>
By default strip is considered to be &quot;yes&quot;.  If set to &quot;no&quot;, DKMS will not run strip -g against your built module to remove debug symbols from it.</dd>
</dl>
<dl>
<dt>
<b>PACKAGE_NAME=</b></dt>
<dd>
This directive is used to give the name associated with the entire package of modules.  This is the same name that is used with the <b>-m</b> option when building, adding, etc. and may not necessarily be the same as the MODULE_NAME.  This directive must be present in every dkms.conf.</dd>
</dl>
<dl>
<dt>
<b>PACKAGE_VERSION=</b></dt>
<dd>
This directive is used to give the version associated with the entire package of modules being installed within that dkms package.  This directive must be present in every dkms.conf.</dd>
</dl>
<dl>
<dt>
<b>CLEAN=</b></dt>
<dd>
CLEAN specifies the make clean command to be used to clean up both before and after building the module.  If unset, it is assumed to be &quot;make clean&quot;.</dd>
</dl>
<dl>
<dt>
<b>REMAKE_INITRD=</b></dt>
<dd>
This directive specifies whether your initrd should be remade after the module is installed onto the kernel.  Any text after the first character is ignored and if the first character is not a &quot;y&quot; or a &quot;Y&quot;, it is assumed that REMAKE_INITRD=&quot;no&quot;.</dd>
</dl>
<dl>
<dt>
<b>UDEV_TRIGGER=</b></dt>
<dd>
This optional directive specifies, if the udev daemon will be get a trigger event after the module is installed for your currently running kernel. Because this udev trigger might have some unfriendly side effects on some Linux Systems, you can now disable this trigger, if your driver does not need it anyway. UDEV_TRIGGER=yes is assumed as the default, although this directive may not be given. This ensures backward compatibility to older DKMS releases. Any text after the first character is ignored and if the first character is not a &quot;n&quot; or a &quot;N&quot;, it is assumed that UDEV_TRIGGER=&quot;yes&quot;.</dd>
</dl>
<dl>
<dt>
<b>MODULES_CONF[#]=</b></dt>
<dd>
This directive array specifies what static configuration text lines need to be added into <i>/etc/modules.conf</i> for your module. See the section on MODULES.CONF CHANGES for more information regarding the implications of modifying <i>/etc/modules.conf</i></dd>
</dl>
<dl>
<dt>
<b>OBSOLETE_BY=</b></dt>
<dd>
This directive allows you to specify a kernel version that obsoletes the necessity for this particular DKMS module.  This can be specified as a particular upstream kernel or an ABI bump of a kernel.  For example, &quot;2.6.24&quot; would be an upstream kernel and &quot;2.6.24-16&quot; would represent an ABI bump for a kernel.  Both are valid in this area.<div style="height: 1.00em;">
&#160;</div>
Please avoid the use of <b>OBSOLETE_BY</b> wherever possible.  It's use indicates a lack of proper module versioning using <b>MODULE_VERSION()</b> tags in the module source itself.  It is better to fix the <b>MODULE_VERSION()</b> tags than use <b>OBSOLETE_BY.</b> This also introduces a implicit distribution/version dependency on the package, as the value of <b>OBSOLETE_BY</b> is meaningful only in the context of a single distribution/version.<div style="height: 1.00em;">
&#160;</div>
If you feel you must use it, please use as such in dkms.conf:<div style="height: 1.00em;">
&#160;</div>
<br/>
 ubuntu_804=&quot;Ubuntu<br/>
 8.04&quot;<br/>
 if [ -x /usr/bin/lsb_release ]; then<br/>
   if [ &quot;$(/usr/bin/lsb_release -sir)&quot; == &quot;${ubuntu_804}&quot; ]; then<br/>
     OBSOLETE_BY=&quot;2.6.25&quot;<br/>
   fi<br/>
 fi<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<dl>
<dt>
<b>PATCH[#]=</b></dt>
<dd>
Use the PATCH directive array to specify patches which should be applied to your source before a build occurs. All patches are expected to be in -p1 format and are applied with the patch -p1 command. Each directive should specify the filename of the patch to apply, and all patches must be located in the patches subdirectory of your source directory ( <i>/usr/src/&lt;module&gt;-&lt;module-version&gt;/patches/</i> ).  If any patch fails to apply, the build will be halted and the rejections can be inspected in <i>/var/lib/dkms/&lt;module&gt;/&lt;module-version&gt;/build/.</i> If a PATCH should only be applied conditionally, the <b>PATCH_MATCH[#]</b> array should be used, and a corresponding regular expression should be placed in <b>PATCH_MATCH[#]</b> which will alert dkms to only use that <b>PATCH[#]</b> if the regular expression matches the kernel which the module is currently being built for.</dd>
</dl>
<dl>
<dt>
<b>PATCH_MATCH[#]=</b></dt>
<dd>
See the above description for <b>PATCH[#]</b> directives. If you only want a patch applied in certain scenarios, the <b>PATCH_MATCH</b> array should be utilized by giving a regular expression which matches the kernels you intend the corresponding <b>PATCH[#]</b> to be applied to before building that module.</dd>
</dl>
<dl>
<dt>
<b>AUTOINSTALL=</b></dt>
<dd>
If this directive is set to <b>yes</b> then the service <i>/etc/rc.d/init.d/dkms_autoinstaller</i> will automatically try to install this module on any kernel you boot into.  See the section on <b>dkms_autoinstaller</b> for more information.</dd>
</dl>
<dl>
<dt>
<b>BUILD_EXCLUSIVE_KERNEL=</b></dt>
<dd>
This optional directive allows you to specify a regular expression which defines the subset of kernels which DKMS is allowed to build your module for.  If the kernel being built for does not match against this regular expression, the dkms build will error out.  For example, if you set it as =&quot;^2.4.*&quot;, your module would not be built for 2.6 kernels.</dd>
</dl>
<dl>
<dt>
<b>BUILD_EXCLUSIVE_ARCH=</b></dt>
<dd>
This optional directive functions very similarly to <b>BUILD_EXCLUSIVE_KERNEL</b> except that it matches against the kernel architecture.  For example, if you set it to =&quot;i.86&quot;, your module would not be built for ia32e, x86_64, amd64, s390, etc.</dd>
</dl>
<dl>
<dt>
<b>POST_ADD=</b></dt>
<dd>
The name of the script to be run after an <b>add</b> is performed.  The path should be given relative to the root directory of your source.</dd>
</dl>
<dl>
<dt>
<b>POST_BUILD=</b></dt>
<dd>
The name of the script to be run after a <b>build</b> is performed. The path should be given relative to the root directory of your source.</dd>
</dl>
<dl>
<dt>
<b>POST_INSTALL=</b></dt>
<dd>
The name of the script to be run after an <b>install</b> is performed. The path should be given relative to the root directory of your source.</dd>
</dl>
<dl>
<dt>
<b>POST_REMOVE=</b></dt>
<dd>
The name of the script to be run after a <b>remove</b> is performed. The path should be given relative to the root directory of your source.</dd>
</dl>
<dl>
<dt>
<b>PRE_BUILD=</b></dt>
<dd>
The name of the script to be run before a <b>build</b> is performed. The path should be given relative to the root directory of your source.</dd>
</dl>
<dl>
<dt>
<b>PRE_INSTALL=</b></dt>
<dd>
The name of the script to be run before an <b>install</b> is performed. The path should be given relative to the root directory of your source.  If the script exits with a non-zero value, the install will be aborted.  This is typically used to perform a custom version comparison.</dd>
</dl>
</div>
<div class="section">
<h1>DKMS.CONF VARIABLES</h1> Within your <i>dkms.conf</i> file, you can use certain variables which will be replaced at run-time with their values.<dl>
<dt>
<b>$kernelver</b></dt>
<dd>
This variable can be used within a directive definition and during use, the actual kernel version in question will be substituted in its place.  This is especially useful in MAKE commands when specifying which INCLUDE statements should be used when compiling your module (eg. MAKE=&quot;make all INCLUDEDIR=/lib/modules/${kernelver}/build/include&quot;).</dd>
</dl>
<dl>
<dt>
<b>$dkms_tree</b></dt>
<dd>
See the section on /etc/dkms/framework.conf for more information.  This variable represents the location of the DKMS tree on the local system.  By default this is <i>/var/lib/dkms</i> , but this value should not be hard-coded into a dkms.conf in the event that the local user has changed it on their system.</dd>
</dl>
<dl>
<dt>
<b>$source_tree</b></dt>
<dd>
See the section on /etc/dkms/framework.conf for more information.  This variable represents the location where DKMS keeps source on the local system.  By default this is <i>/usr/src</i> , but this value should not be hard-coded into a dkms.conf in the event that the local user has changed it on their system.</dd>
</dl>
<dl>
<dt>
<b>$kernel_source_dir</b></dt>
<dd>
This variable holds the value of the location of your kernel source directory.  Usually, this will be <i>/lib/modules/$kernelver/build</i> , unless otherwise specified with the <b>--kernelsourcedir</b> option.</dd>
</dl>
</div>
<div class="section">
<h1>DKMS.CONF OVERRIDES</h1> You can override the module-provided <i>dkms.conf</i> files. Every time after a  dkms.conf file is read, dkms will look for and read the following files in order:<div style="height: 1.00em;">
&#160;</div>
<i>/etc/dkms/&lt;module&gt;.confp</i> <i>/etc/dkms/&lt;module&gt;-&lt;module-version&gt;.confp</i> <i>/etc/dkms/&lt;module&gt;-&lt;module-version&gt;-&lt;kernel&gt;.confp</i> <i>/etc/dkms/&lt;module&gt;-&lt;module-version&gt;-&lt;kernel&gt;-&lt;arch&gt;.conf</i><div style="height: 1.00em;">
&#160;</div>
You can use these files to override settings in the module-provided dkms.conf files.</div>
<div class="section">
<h1>/etc/dkms/framework.conf</h1> This configuration file controls how the overall DKMS framework handles.  It is sourced in every time the dkms command is run.  Mainly it can currently be used to set different default values for the variables. <b>$dkms_tree</b> , <b>$source_tree</b> and <b>$install_tree</b> which control where DKMS looks for its framework.  Note that these variables can also be manipulated on the command line with --dkmstree, --sourcetree and --installtree options.</div>
<div class="section">
<h1>dkms_autoinstaller</h1> This boot-time service automatically installs any module which has <b>AUTOINSTALL=&quot;yes&quot;</b> set in its <b>dkms.conf</b> file.  The service works quite simply and if multiple versions of a module are in your system's DKMS tree, it will not do anything and instead explain that manual intervention is required.</div>
<div class="section">
<h1>MODULES.CONF / MODPROBE.CONF CHANGES</h1> Changes that your module will make to <i>/etc/modules.conf</i> or <i>/etc/modprobe.conf</i> should be specified with the <b>MODULES_CONF_ALIAS_TYPE[#]</b> , the <b>MODULES_CONF_OBSOLETES[#]</b> and the <b>MODULES_CONF[#]</b> directive arrays.  These arrays should also be used even if your distro uses <i>/etc/sysconfig/kernel</i> to track kernel modules.<div style="height: 1.00em;">
&#160;</div>
When the first module is installed upon the first kernel within the user's system, these entries in <b>MODULES_CONF[#]</b> are automatically added to <i>/etc/modules.conf</i> and if <b>REMAKE_INITRD</b> is specified, then the user's initrd is then remade.  Subsequently, as your modules are then later removed from the user's system, until the final module/version combination is removed from the final kernel version, those references in <i>modules.conf</i> will remain.  Once the last module/version combination is removed, those references are then removed.<div style="height: 1.00em;">
&#160;</div>
As modules/versions are removed and initrds are remade, one of three things will happen if you have specified a <b>MODULES_CONF_ALIAS_TYPE.</b> If no original_module exists for that kernel, and no <b>MODULES_CONF_OBSOLETES</b> modules are found in that kernel too, the <i>modules.conf</i> alias references will temporarily be removed so that the initrd will successfully remake.  Once the initrd is remade, however; those references are then automatically put back into <i>modules.conf</i> (unless you are removing the last instance of the module on the last kernel). However, if no original_module exists, but there is an OBSOLETE module found within that kernel, the alias reference is temporarily shifted to point to the OBSOLETE module so that the initrd can be remade.  After it is remade, it then automatically puts back the alias reference (unless you are removing the last instance of the module on the last kernel).  Lastly, if an original_module does exist for the kernel version, then <i>modules.conf</i> is not touched and all references persist (even if you are removing the last instance of the module on the last kernel).<div style="height: 1.00em;">
&#160;</div>
Certain module installations might not only require adding references to <i>modules.conf</i> but also require removing conflicting references that might exist in the user's system.  If this is the case, the <b>MODULES_CONF_OBSOLETES[#]</b> directive should be utilized to remove these references.  More information about this directive can be found in the <b>DKMS.CONF</b> section of this man page.<div style="height: 1.00em;">
&#160;</div>
Note that the end state of your modules.conf file very much depends on what kernel modules exist in the final kernel you remove your DKMS module from.  This is an imperfect system caused by the fact that there is only one modules.conf file for every kernel on your system even though various kernels use different modules.  In a perfect world, there would be one modules.conf file for every kernel (just like System.map).</div>
<div class="section">
<h1>CREATING RPMS WHICH UTILIZE DKMS</h1> See the <i>sample.spec</i> file packaged with <b>DKMS</b> as an example for what your RPM spec file might look like. Creating RPMs which utilize <b>dkms</b> is a fairly straight-forward process.  The RPM need only to install the source into <i>/usr/src/&lt;module&gt;-&lt;module-version&gt;/</i> and then employ <b>dkms</b> itself to do all the work of installation.  As such, the RPM should first untar the source into this directory.  From here, within the RPM <i>.spec</i> file, a <b>dkms add</b> should be called (remember to use the --rpm_safe_upgrade flag during the add) followed by a <b>dkms build</b> followed by a <b>dkms install.</b> Your <i>dkms.conf</i> file should be placed within the <i>/usr/src/&lt;module&gt;-&lt;module-version&gt;/</i> directory.<div style="height: 1.00em;">
&#160;</div>
Under the removal parts of the <i>.spec</i> file, all that needs to be called is a: dkms remove -m &lt;module&gt; -v &lt;module-version&gt; --all --rpm_safe_upgrade. Use of the <b>--rpm_safe_upgrade</b> flag is imperative for making sure DKMS and RPM play nicely together in all scenarios of using the -Uvh flag with RPM to upgrade dkms enabled packages.  It will only function if used during both the add <b>and</b> remove actions within the same RPM spec file. Its use makes sure that when upgrading between different releases of an RPM for the same &lt;module-version&gt;, DKMS does not do anything dumb (eg. it ensures a smooth upgrade from megaraid-2.09-5.noarch.rpm to megaraid-2.09-6.noarch.rpm).<div style="height: 1.00em;">
&#160;</div>
It should be noted that a binary RPM which contains source is not a traditional practice. However, given the benefits of <b>dkms</b> it hopefully will become so.  As the RPM created which utilizes <b>dkms</b> is not architecture specific, <b>BuildArch: noarch</b> should be specified in the <i>.spec</i> file to indicate that the package can work regardless of the system architecture.  Also note that DKMS RPM upgrades (-U option) will automatically work because of the structure of the <b>dkms</b> tree.<div style="height: 1.00em;">
&#160;</div>
Lastly, as a matter of convention, you should name your RPM: &lt;package&gt;-&lt;version&gt;-&lt;rpm-version&gt;dkms.noarch.rpm.  The word <b>dkms</b> as part of the rpm-version signifies that the RPM works within the DKMS framework.</div>
<div class="section">
<h1>AUTHOR</h1> Gary Lerhaupt</div>
<div class="section">
<h1>WEBPAGE</h1> <i>http://linux.dell.com/dkms</i></div>
<div class="section">
<h1>WHITE-PAPERS</h1> <i>http://linux.dell.com/dkms/dkms-ols2004.pdf</i><div style="height: 1.00em;">
&#160;</div>
<i>http://www.dell.com/downloads/global/power/1q04-ler.pdf</i><div style="height: 1.00em;">
&#160;</div>
<i>http://www.linuxjournal.com/article.php?sid=6896</i></div>
<div class="section">
<h1>MAILING-LIST</h1> dkms-devel@dell.com <i>http://lists.us.dell.com/mailman/listinfo/dkms-devel</i></div>
<div class="section">
<h1>REFERENCES</h1> Kernel Module Packages <i>http://kerneldrivers.org</i><div style="height: 1.00em;">
&#160;</div>
Novell Kernel Module Packages <i>http://www.suse.de/~agruen/KMPM</i><div style="height: 1.00em;">
&#160;</div>
Fedora Kernel Module Packages <i>http://fedoraproject.org/wiki/Extras/KernelModuleProposal</i></div>
<table class="foot">
<tr>
<td class="foot-date">
June 2008</td>
<td class="foot-os">
Version 2.0.20</td>
</tr>
</table>
</div>
</body>
</html>

