<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
ARPD(8)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
ARPD(8)</td>
<td class="head-vol">
System Manager's Manual</td>
<td class="head-rtitle">
ARPD(8)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> arpd - userspace arp daemon.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>SYNOPSIS</h1> Usage: arpd [ -lkh? ] [ -a N ] [ -b dbase ] [ -B number ] [ -f file ] [ -n time ] [ -R rate ] [ interfaces ]<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>DESCRIPTION</h1> The <b>arpd</b> daemon collects gratuitous ARP information, saving it on local disk and feeding it to kernel on demand to avoid redundant broadcasting due to limited size of kernel ARP cache.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>OPTIONS</h1><dl>
<dt>
-h -?</dt>
<dd>
Print help</dd>
</dl>
<dl>
<dt>
-l</dt>
<dd>
Dump arpd database to stdout and exit. Output consists of three columns: interface index, IP address and MAC address. Negative entries for dead hosts are also shown, in this case MAC address is replaced by word FAILED followed by colon and time when the fact that host is dead was proven the last time.</dd>
</dl>
<dl>
<dt>
-f &lt;FILE&gt;</dt>
<dd>
Read and load arpd database from FILE in text format similar dumped by option -l. Exit after load, probably listing resulting database, if option -l is also given. If FILE is -, stdin is read to get ARP table.</dd>
</dl>
<dl>
<dt>
-b &lt;DATABASE&gt;</dt>
<dd>
location of database file. Default location is /var/lib/arpd/arpd.db</dd>
</dl>
<dl>
<dt>
-a &lt;NUMBER&gt;</dt>
<dd>
arpd not only passively listens ARP on wire, but also send brodcast queries itself. NUMBER is number of such queries to make before destination is considered as dead. When arpd is started as kernel helper (i.e. with app_solicit enabled in sysctl or even with option -k) without this option and still did not learn enough information, you can observe 1 second gaps in service. Not fatal, but not good.</dd>
</dl>
<dl>
<dt>
-k</dt>
<dd>
Suppress sending broadcast queries by kernel. It takes sense together with option -a.</dd>
</dl>
<dl>
<dt>
-n &lt;TIME&gt;</dt>
<dd>
Timeout of negative cache. When resolution fails arpd suppresses further attempts to resolve for this period. It makes sense only together with option -k This timeout should not be too much longer than boot time of a typical host not supporting gratuitous ARP. Default value is 60 seconds.</dd>
</dl>
<dl>
<dt>
-R &lt;RATE&gt;</dt>
<dd>
Maximal steady rate of broadcasts sent by arpd in packets per second. Default value is 1.</dd>
</dl>
<dl>
<dt>
-B &lt;NUMBER&gt;</dt>
<dd>
Number of broadcasts sent by &lt;tt/arpd/ back to back. Default value is 3. Together with option &lt;tt/-R/ this option allows to police broadcasting not to exceed B+R*T over any interval of time T.</dd>
</dl>
<div class="spacer">
</div>
&lt;INTERFACE&gt; is the name of networking interface to watch. If no interfaces given, arpd monitors all the interfaces. In this case arpd does not adjust sysctl parameters, it is supposed user does this himself after arpd is started.<div class="spacer">
</div>
Signals<div style="height: 0.00em;">
&#160;</div>
arpd exits gracefully syncing database and restoring adjusted sysctl parameters, when receives SIGINT or SIGTERM. SIGHUP syncs database to disk. SIGUSR1 sends some statistics to syslog. Effect of another signals is undefined, they may corrupt database and leave sysctl praameters in an unpredictable state.<div class="spacer">
</div>
Note<div style="height: 0.00em;">
&#160;</div>
In order for arpd to be able to serve as ARP resolver, kernel must be compiled with the option CONFIG_ARPD and, in the case when interface list in not given on command line, variable app_solicit on interfaces of interest should be in /proc/sys/net/ipv4/neigh/*. If this is not made arpd still collects gratuitous ARP information in its database.</div>
<div class="section">
<h1>EXAMPLES</h1><dl>
<dt>
arpd -b /var/tmp/arpd.db</dt>
<dd>
Start arpd to collect gratuitous ARP, but not messing with kernel functionality.</dd>
</dl>
<dl>
<dt>
killall arpd ; arpd -l -b /var/tmp/arpd.db</dt>
<dd>
Look at result after some time.</dd>
</dl>
<dl>
<dt>
arpd -b /var/tmp/arpd.db -a 1 eth0 eth1</dt>
<dd>
Enable kernel helper, leaving leading role to kernel.</dd>
</dl>
<dl>
<dt>
arpd -b /var/tmp/arpd.db -a 3 -k eth0 eth1</dt>
<dd>
Completely replace kernel resolution on interfaces eth0 and eth1. In this case kernel still does unicast probing to validate entries, but all the broadcast activity is suppressed and made under authority of arpd.</dd>
</dl>
<div class="spacer">
</div>
This is mode which arpd is supposed to work normally. It is not default just to prevent occasional enabling of too aggressive mode occasionally.</div>
<table class="foot">
<tr>
<td class="foot-date">
28 June, 2007</td>
<td class="foot-os">
</td>
</tr>
</table>
</div>
</body>
</html>

