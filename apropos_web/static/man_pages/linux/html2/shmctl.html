<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
SHMCTL(2)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
SHMCTL(2)</td>
<td class="head-vol">
Linux Programmer's Manual</td>
<td class="head-rtitle">
SHMCTL(2)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> shmctl - shared memory control</div>
<div class="section">
<h1>SYNOPSIS</h1> <b>#include &lt;sys/ipc.h&gt;</b><div style="height: 0.00em;">
&#160;</div>
<b>#include &lt;sys/shm.h&gt;</b><div style="height: 1.00em;">
&#160;</div>
<b>int shmctl(int </b><i>shmid</i><b>, int </b><i>cmd</i><b>, struct shmid_ds *</b><i>buf</i><b>);</b></div>
<div class="section">
<h1>DESCRIPTION</h1> <b>shmctl</b>() performs the control operation specified by <i>cmd</i> on the shared memory segment whose identifier is given in <i>shmid</i>.<div class="spacer">
</div>
The <i>buf</i> argument is a pointer to a  <i>shmid_ds</i> structure, defined in  <i>&lt;sys/shm.h&gt;</i> as follows:<div class="spacer">
</div>
<br/>
<br/>
struct shmid_ds {<br/>
    struct ipc_perm shm_perm;    /* Ownership and permissions */<br/>
    size_t          shm_segsz;   /* Size of segment (bytes) */<br/>
    time_t          shm_atime;   /* Last attach time */<br/>
    time_t          shm_dtime;   /* Last detach time */<br/>
    time_t          shm_ctime;   /* Last change time */<br/>
    pid_t           shm_cpid;    /* PID of creator */<br/>
    pid_t           shm_lpid;    /* PID of last shmat(2)/shmdt(2) */<br/>
    shmatt_t        shm_nattch;  /* No. of current attaches */<br/>
    ...<br/>
};<br/>
<br/>
<div class="spacer">
</div>
The <i>ipc_perm</i> structure is defined in  <i>&lt;sys/ipc.h&gt;</i> as follows (the highlighted fields are settable using <b>IPC_SET</b>):<div class="spacer">
</div>
<br/>
<br/>
struct ipc_perm {<br/>
    key_t          __key;    /* Key supplied to shmget(2) */<br/>
    uid_t          <b>uid</b>;      /* Effective UID of owner */<br/>
    gid_t          <b>gid</b>;      /* Effective GID of owner */<br/>
    uid_t          cuid;     /* Effective UID of creator */<br/>
    gid_t          cgid;     /* Effective GID of creator */<br/>
    unsigned short <b>mode</b>;     /* <b>Permissions</b> + SHM_DEST and<br/>
                                SHM_LOCKED flags */<br/>
    unsigned short __seq;    /* Sequence number */<br/>
};<br/>
<br/>
<div class="spacer">
</div>
Valid values for <i>cmd</i> are:<div style="height: 0.00em;">
&#160;</div>
<dl>
<dt>
<b>IPC_STAT</b></dt>
<dd>
Copy information from the kernel data structure associated with <i>shmid</i> into the <i>shmid_ds</i> structure pointed to by  <i>buf</i>. The caller must have read permission on the shared memory segment.</dd>
</dl>
<dl>
<dt>
<b>IPC_SET</b></dt>
<dd>
Write the values of some members of the <i>shmid_ds</i> structure pointed to by <i>buf</i> to the kernel data structure associated with this shared memory segment, updating also its <i>shm_ctime</i> member. The following fields can be changed:  <i>shm_perm.uid</i>, <i>shm_perm.gid</i>, and (the least significant 9 bits of)  <i>shm_perm.mode</i>. The effective UID of the calling process must match the owner (<i>shm_perm.uid</i>) or creator (<i>shm_perm.cuid</i>) of the shared memory segment, or the caller must be privileged.</dd>
</dl>
<dl>
<dt>
<b>IPC_RMID</b></dt>
<dd>
Mark the segment to be destroyed. The segment will only actually be destroyed after the last process detaches it (i.e., when the <i>shm_nattch</i> member of the associated structure <i>shmid_ds</i> is zero). The caller must be the owner or creator, or be privileged. If a segment has been marked for destruction, then the (nonstandard) <b>SHM_DEST</b> flag of the <i>shm_perm.mode</i> field in the associated data structure retrieved by <b>IPC_STAT</b> will be set.</dd>
</dl>
<div class="spacer">
</div>
The caller <i>must</i> ensure that a segment is eventually destroyed; otherwise its pages that were faulted in will remain in memory or swap.<dl>
<dt>
<b>IPC_INFO</b> (Linux-specific)</dt>
<dd>
Returns information about system-wide shared memory limits and parameters in the structure pointed to by <i>buf</i>. This structure is of type <i>shminfo</i> (thus, a cast is required), defined in <i>&lt;sys/shm.h&gt;</i> if the <b>_GNU_SOURCE</b> feature test macro is defined:<br/>
<div class="spacer">
</div>
<br/>
struct  shminfo {<br/>
    unsigned long shmmax; /* Maximum segment size */<br/>
    unsigned long shmmin; /* Minimum segment size;<br/>
                             always 1 */<br/>
    unsigned long shmmni; /* Maximum number of segments */<br/>
    unsigned long shmseg; /* Maximum number of segments<br/>
                             that a process can attach;<br/>
                             unused within kernel */<br/>
    unsigned long shmall; /* Maximum number of pages of<br/>
                             shared memory, system-wide */<br/>
};<div class="spacer">
</div>
<br/>
<br/>
The <i>shmmni</i>, <i>shmmax</i>, and <i>shmall</i> settings can be changed via <i>/proc</i> files of the same name; see <b>proc</b>(5) for details.</dd>
</dl>
<dl>
<dt>
<b>SHM_INFO</b> (Linux-specific)</dt>
<dd>
Returns a <i>shm_info</i> structure whose fields contain information about system resources consumed by shared memory. This structure is defined in <i>&lt;sys/shm.h&gt;</i> if the <b>_GNU_SOURCE</b> feature test macro is defined:<br/>
<div class="spacer">
</div>
<br/>
struct shm_info {<br/>
    int           used_ids; /* # of currently existing<br/>
                               segments */<br/>
    unsigned long shm_tot;  /* Total number of shared<br/>
                               memory pages */<br/>
    unsigned long shm_rss;  /* # of resident shared<br/>
                               memory pages */<br/>
    unsigned long shm_swp;  /* # of swapped shared<br/>
                               memory pages */<br/>
    unsigned long swap_attempts;<br/>
                            /* Unused since Linux 2.4 */<br/>
    unsigned long swap_successes;<br/>
                            /* Unused since Linux 2.4 */<br/>
};<br/>
<br/>
</dd>
</dl>
<dl>
<dt>
<b>SHM_STAT</b> (Linux-specific)</dt>
<dd>
Returns a <i>shmid_ds</i> structure as for <b>IPC_STAT</b>. However, the <i>shmid</i> argument is not a segment identifier, but instead an index into the kernel's internal array that maintains information about all shared memory segments on the system.</dd>
</dl>
<div class="spacer">
</div>
The caller can prevent or allow swapping of a shared memory segment with the following  <i>cmd</i> values:<div style="height: 0.00em;">
&#160;</div>
<dl>
<dt>
<b>SHM_LOCK</b> (Linux-specific)</dt>
<dd>
Prevent swapping of the shared memory segment. The caller must fault in any pages that are required to be present after locking is enabled. If a segment has been locked, then the (nonstandard) <b>SHM_LOCKED</b> flag of the <i>shm_perm.mode</i> field in the associated data structure retrieved by <b>IPC_STAT</b> will be set.</dd>
</dl>
<dl>
<dt>
<b>SHM_UNLOCK</b> (Linux-specific)</dt>
<dd>
Unlock the segment, allowing it to be swapped out.</dd>
</dl>
<div class="spacer">
</div>
In kernels before 2.6.10, only a privileged process could employ <b>SHM_LOCK</b> and <b>SHM_UNLOCK</b>. Since kernel 2.6.10, an unprivileged process can employ these operations if its effective UID matches the owner or creator UID of the segment, and (for <b>SHM_LOCK</b>) the amount of memory to be locked falls within the <b>RLIMIT_MEMLOCK</b> resource limit (see <b>setrlimit</b>(2)).</div>
<div class="section">
<h1>RETURN VALUE</h1> A successful <b>IPC_INFO</b> or <b>SHM_INFO</b> operation returns the index of the highest used entry in the kernel's internal array recording information about all shared memory segments. (This information can be used with repeated <b>SHM_STAT</b> operations to obtain information about all shared memory segments on the system.) A successful <b>SHM_STAT</b> operation returns the identifier of the shared memory segment whose index was given in <i>shmid</i>. Other operations return 0 on success.<div style="height: 1.00em;">
&#160;</div>
On error, -1 is returned, and <i>errno</i> is set appropriately.</div>
<div class="section">
<h1>ERRORS</h1><dl>
<dt>
<b>EACCES</b></dt>
<dd>
<b>IPC_STAT</b> or <b>SHM_STAT</b> is requested and  <i>shm_perm.mode</i> does not allow read access for <i>shmid</i>, and the calling process does not have the <b>CAP_IPC_OWNER</b> capability.</dd>
</dl>
<dl>
<dt>
<b>EFAULT</b></dt>
<dd>
The argument <i>cmd</i> has value <b>IPC_SET</b> or <b>IPC_STAT</b> but the address pointed to by <i>buf</i> isn't accessible.</dd>
</dl>
<dl>
<dt>
<b>EIDRM</b></dt>
<dd>
<i>shmid</i> points to a removed identifier.</dd>
</dl>
<dl>
<dt>
<b>EINVAL</b></dt>
<dd>
<i>shmid</i> is not a valid identifier, or <i>cmd</i> is not a valid command. Or: for a <b>SHM_STAT</b> operation, the index value specified in <i>shmid</i> referred to an array slot that is currently unused.</dd>
</dl>
<dl>
<dt>
<b>ENOMEM</b></dt>
<dd>
(In kernels since 2.6.9), <b>SHM_LOCK</b> was specified and the size of the to-be-locked segment would mean that the total bytes in locked shared memory segments would exceed the limit for the real user ID of the calling process. This limit is defined by the <b>RLIMIT_MEMLOCK</b> soft resource limit (see <b>setrlimit</b>(2)).</dd>
</dl>
<dl>
<dt>
<b>EOVERFLOW</b></dt>
<dd>
<b>IPC_STAT</b> is attempted, and the GID or UID value is too large to be stored in the structure pointed to by <i>buf</i>.</dd>
</dl>
<dl>
<dt>
<b>EPERM</b></dt>
<dd>
<b>IPC_SET</b> or <b>IPC_RMID</b> is attempted, and the effective user ID of the calling process is not that of the creator (found in <i>shm_perm.cuid</i>), or the owner (found in <i>shm_perm.uid</i>), and the process was not privileged (Linux: did not have the <b>CAP_SYS_ADMIN</b> capability).<div style="height: 1.00em;">
&#160;</div>
Or (in kernels before 2.6.9), <b>SHM_LOCK</b> or <b>SHM_UNLOCK</b> was specified, but the process was not privileged (Linux: did not have the <b>CAP_IPC_LOCK</b> capability). (Since Linux 2.6.9, this error can also occur if the <b>RLIMIT_MEMLOCK</b> is 0 and the caller is not privileged.)</dd>
</dl>
</div>
<div class="section">
<h1>CONFORMING TO</h1> SVr4, POSIX.1-2001.</div>
<div class="section">
<h1>NOTES</h1> The <b>IPC_INFO</b>, <b>SHM_STAT</b> and <b>SHM_INFO</b> operations are used by the <b>ipcs</b>(1) program to provide information on allocated resources. In the future these may modified or moved to a /proc file system interface.<div style="height: 1.00em;">
&#160;</div>
Linux permits a process to attach (<b>shmat</b>(2)) a shared memory segment that has already been marked for deletion using <i>shmctl(IPC_RMID)</i>. This feature is not available on other UNIX implementations; portable applications should avoid relying on it.<div style="height: 1.00em;">
&#160;</div>
Various fields in a <i>struct shmid_ds</i> were typed as <i>short</i> under Linux 2.2 and have become <i>long</i> under Linux 2.4. To take advantage of this, a recompilation under glibc-2.1.91 or later should suffice. (The kernel distinguishes old and new calls by an <b>IPC_64</b> flag in <i>cmd</i>.)</div>
<div class="section">
<h1>SEE ALSO</h1> <b>mlock</b>(2), <b>setrlimit</b>(2), <b>shmget</b>(2), <b>shmop</b>(2), <b>capabilities</b>(7), <b>svipc</b>(7)</div>
<div class="section">
<h1>COLOPHON</h1> This page is part of release 3.35 of the Linux <i>man-pages</i> project. A description of the project, and information about reporting bugs, can be found at http://man7.org/linux/man-pages/.</div>
<table class="foot">
<tr>
<td class="foot-date">
2008-08-07</td>
<td class="foot-os">
Linux</td>
</tr>
</table>
</div>
</body>
</html>

