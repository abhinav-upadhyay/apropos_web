<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
CLOCK_GETRES(2)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
CLOCK_GETRES(2)</td>
<td class="head-vol">
Linux Programmer's Manual</td>
<td class="head-rtitle">
CLOCK_GETRES(2)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> clock_getres, clock_gettime, clock_settime - clock and time functions</div>
<div class="section">
<h1>SYNOPSIS</h1> <b>#include &lt;time.h&gt;</b><div style="height: 1.00em;">
&#160;</div>
<b>int clock_getres(clockid_t </b><i>clk_id</i><b>, struct timespec *</b><i>res</i><b>);</b><div style="height: 1.00em;">
&#160;</div>
<b>int clock_gettime(clockid_t </b><i>clk_id</i><b>, struct timespec *</b><i>tp</i><b>);</b><div style="height: 1.00em;">
&#160;</div>
<b>int clock_settime(clockid_t </b><i>clk_id</i><b>, const struct timespec *</b><i>tp</i><b>);</b><div style="height: 1.00em;">
&#160;</div>
Link with <i>-lrt</i>.<div style="height: 1.00em;">
&#160;</div>
<br/>
Feature Test Macro Requirements for glibc (see <b>feature_test_macros</b>(7)):<br/>
<div style="height: 1.00em;">
&#160;</div>
<b>clock_getres</b>(), <b>clock_gettime</b>(), <b>clock_settime</b>():<div style="margin-left: 5.00ex;">
_POSIX_C_SOURCE&#160;&gt;=&#160;199309L</div>
</div>
<div class="section">
<h1>DESCRIPTION</h1> The function <b>clock_getres</b>() finds the resolution (precision) of the specified clock <i>clk_id</i>, and, if <i>res</i> is non-NULL, stores it in the  <i>struct timespec</i> pointed to by <i>res</i>. The resolution of clocks depends on the implementation and cannot be configured by a particular process. If the time value pointed to by the argument <i>tp</i> of <b>clock_settime</b>() is not a multiple of <i>res</i>, then it is truncated to a multiple of <i>res</i>.<div class="spacer">
</div>
The functions <b>clock_gettime</b>() and <b>clock_settime</b>() retrieve and set the time of the specified clock <i>clk_id</i>.<div class="spacer">
</div>
The <i>res</i> and <i>tp</i> arguments are <i>timespec</i> structures, as specified in <i>&lt;time.h&gt;</i>:<div style="height: 1.00em;">
&#160;</div>
<br/>
<br/>
struct timespec {<br/>
    time_t   tv_sec;        /* seconds */<br/>
    long     tv_nsec;       /* nanoseconds */<br/>
};<br/>
<br/>
<div class="spacer">
</div>
The <i>clk_id</i> argument is the identifier of the particular clock on which to act. A clock may be system-wide and hence visible for all processes, or per-process if it measures time only within a single process.<div class="spacer">
</div>
All implementations support the system-wide real-time clock, which is identified by <b>CLOCK_REALTIME</b>. Its time represents seconds and nanoseconds since the Epoch. When its time is changed, timers for a relative interval are unaffected, but timers for an absolute point in time are affected.<div class="spacer">
</div>
More clocks may be implemented. The interpretation of the corresponding time values and the effect on timers is unspecified.<div class="spacer">
</div>
Sufficiently recent versions of glibc and the Linux kernel support the following clocks:<dl>
<dt>
<b>CLOCK_REALTIME</b></dt>
<dd>
System-wide real-time clock. Setting this clock requires appropriate privileges.</dd>
</dl>
<dl>
<dt>
<b>CLOCK_MONOTONIC</b></dt>
<dd>
Clock that cannot be set and represents monotonic time since some unspecified starting point.</dd>
</dl>
<dl>
<dt>
<b>CLOCK_MONOTONIC_RAW</b> (since Linux 2.6.28; Linux-specific)</dt>
<dd>
Similar to <b>CLOCK_MONOTONIC</b>, but provides access to a raw hardware-based time that is not subject to NTP adjustments.</dd>
</dl>
<dl>
<dt>
<b>CLOCK_PROCESS_CPUTIME_ID</b></dt>
<dd>
High-resolution per-process timer from the CPU.</dd>
</dl>
<dl>
<dt>
<b>CLOCK_THREAD_CPUTIME_ID</b></dt>
<dd>
Thread-specific CPU-time clock.</dd>
</dl>
</div>
<div class="section">
<h1>RETURN VALUE</h1> <b>clock_gettime</b>(), <b>clock_settime</b>() and <b>clock_getres</b>() return 0 for success, or -1 for failure (in which case <i>errno</i> is set appropriately).</div>
<div class="section">
<h1>ERRORS</h1><dl>
<dt>
<b>EFAULT</b></dt>
<dd>
<i>tp</i> points outside the accessible address space.</dd>
</dl>
<dl>
<dt>
<b>EINVAL</b></dt>
<dd>
The <i>clk_id</i> specified is not supported on this system.</dd>
</dl>
<dl>
<dt>
<b>EPERM</b></dt>
<dd>
<b>clock_settime</b>() does not have permission to set the clock indicated.</dd>
</dl>
</div>
<div class="section">
<h1>CONFORMING TO</h1> SUSv2, POSIX.1-2001.</div>
<div class="section">
<h1>AVAILABILITY</h1> On POSIX systems on which these functions are available, the symbol <b>_POSIX_TIMERS</b> is defined in  <i>&lt;unistd.h&gt;</i> to a value greater than 0. The symbols <b>_POSIX_MONOTONIC_CLOCK</b>, <b>_POSIX_CPUTIME</b>, <b>_POSIX_THREAD_CPUTIME</b> indicate that <b>CLOCK_MONOTONIC</b>, <b>CLOCK_PROCESS_CPUTIME_ID</b>, <b>CLOCK_THREAD_CPUTIME_ID</b> are available. (See also <b>sysconf</b>(3).)</div>
<div class="section">
<h1>NOTES</h1><div class="subsection">
<h2>Note for SMP systems</h2> The <b>CLOCK_PROCESS_CPUTIME_ID</b> and <b>CLOCK_THREAD_CPUTIME_ID</b> clocks are realized on many platforms using timers from the CPUs (TSC on i386, AR.ITC on Itanium). These registers may differ between CPUs and as a consequence these clocks may return <b>bogus results</b> if a process is migrated to another CPU.<div class="spacer">
</div>
If the CPUs in an SMP system have different clock sources then there is no way to maintain a correlation between the timer registers since each CPU will run at a slightly different frequency. If that is the case then <i>clock_getcpuclockid(0)</i> will return <b>ENOENT</b> to signify this condition. The two clocks will then only be useful if it can be ensured that a process stays on a certain CPU.<div class="spacer">
</div>
The processors in an SMP system do not start all at exactly the same time and therefore the timer registers are typically running at an offset. Some architectures include code that attempts to limit these offsets on bootup. However, the code cannot guarantee to accurately tune the offsets. Glibc contains no provisions to deal with these offsets (unlike the Linux Kernel). Typically these offsets are small and therefore the effects may be negligible in most cases.</div>
</div>
<div class="section">
<h1>BUGS</h1> According to POSIX.1-2001, a process with &quot;appropriate privileges&quot; may set the <b>CLOCK_PROCESS_CPUTIME_ID</b> and <b>CLOCK_THREAD_CPUTIME_ID</b> clocks using <b>clock_settime</b>(). On Linux, these clocks are not settable (i.e., no process has &quot;appropriate privileges&quot;).</div>
<div class="section">
<h1>SEE ALSO</h1> <b>date</b>(1), <b>adjtimex</b>(2), <b>gettimeofday</b>(2), <b>settimeofday</b>(2), <b>time</b>(2), <b>clock_getcpuclockid</b>(3), <b>ctime</b>(3), <b>ftime</b>(3), <b>pthread_getcpuclockid</b>(3), <b>sysconf</b>(3), <b>time</b>(7)</div>
<div class="section">
<h1>COLOPHON</h1> This page is part of release 3.35 of the Linux <i>man-pages</i> project. A description of the project, and information about reporting bugs, can be found at http://man7.org/linux/man-pages/.</div>
<table class="foot">
<tr>
<td class="foot-date">
2010-02-03</td>
<td class="foot-os">
</td>
</tr>
</table>
</div>
</body>
</html>

