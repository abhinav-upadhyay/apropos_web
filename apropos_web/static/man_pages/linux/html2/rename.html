<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
RENAME(2)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
RENAME(2)</td>
<td class="head-vol">
Linux Programmer's Manual</td>
<td class="head-rtitle">
RENAME(2)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> rename - change the name or location of a file</div>
<div class="section">
<h1>SYNOPSIS</h1> <b>#include &lt;stdio.h&gt;</b><div style="height: 1.00em;">
&#160;</div>
<b>int rename(const char *</b><i>oldpath</i><b>, const char *</b><i>newpath</i><b>);</b></div>
<div class="section">
<h1>DESCRIPTION</h1> <b>rename</b>() renames a file, moving it between directories if required. Any other hard links to the file (as created using <b>link</b>(2)) are unaffected. Open file descriptors for <i>oldpath</i> are also unaffected.<div style="height: 1.00em;">
&#160;</div>
If <i>newpath</i> already exists it will be atomically replaced (subject to a few conditions; see ERRORS below), so that there is no point at which another process attempting to access <i>newpath</i> will find it missing.<div style="height: 1.00em;">
&#160;</div>
If <i>oldpath</i> and <i>newpath</i> are existing hard links referring to the same file, then <b>rename</b>() does nothing, and returns a success status.<div style="height: 1.00em;">
&#160;</div>
If <i>newpath</i> exists but the operation fails for some reason <b>rename</b>() guarantees to leave an instance of <i>newpath</i> in place.<div style="height: 1.00em;">
&#160;</div>
<i>oldpath</i> can specify a directory. In this case, <i>newpath</i> must either not exist, or it must specify an empty directory.<div style="height: 1.00em;">
&#160;</div>
However, when overwriting there will probably be a window in which both <i>oldpath</i> and <i>newpath</i> refer to the file being renamed.<div style="height: 1.00em;">
&#160;</div>
If <i>oldpath</i> refers to a symbolic link the link is renamed; if <i>newpath</i> refers to a symbolic link the link will be overwritten.</div>
<div class="section">
<h1>RETURN VALUE</h1> On success, zero is returned. On error, -1 is returned, and <i>errno</i> is set appropriately.</div>
<div class="section">
<h1>ERRORS</h1><dl>
<dt>
<b>EACCES</b></dt>
<dd>
Write permission is denied for the directory containing <i>oldpath</i> or <i>newpath</i>, or, search permission is denied for one of the directories in the path prefix of <i>oldpath</i> or <i>newpath</i>, or <i>oldpath</i> is a directory and does not allow write permission (needed to update the <i>..</i> entry). (See also <b>path_resolution</b>(7).)</dd>
</dl>
<dl>
<dt>
<b>EBUSY</b></dt>
<dd>
The rename fails because <i>oldpath</i> or <i>newpath</i> is a directory that is in use by some process (perhaps as current working directory, or as root directory, or because it was open for reading) or is in use by the system (for example as mount point), while the system considers this an error. (Note that there is no requirement to return <b>EBUSY</b> in such cases&#8212;there is nothing wrong with doing the rename anyway&#8212;but it is allowed to return <b>EBUSY</b> if the system cannot otherwise handle such situations.)</dd>
</dl>
<dl>
<dt>
<b>EFAULT</b></dt>
<dd>
<i>oldpath</i> or <i>newpath</i> points outside your accessible address space.</dd>
</dl>
<dl>
<dt>
<b>EINVAL</b></dt>
<dd>
The new pathname contained a path prefix of the old, or, more generally, an attempt was made to make a directory a subdirectory of itself.</dd>
</dl>
<dl>
<dt>
<b>EISDIR</b></dt>
<dd>
<i>newpath</i> is an existing directory, but <i>oldpath</i> is not a directory.</dd>
</dl>
<dl>
<dt>
<b>ELOOP</b></dt>
<dd>
Too many symbolic links were encountered in resolving <i>oldpath</i> or <i>newpath</i>.</dd>
</dl>
<dl>
<dt>
<b>EMLINK</b></dt>
<dd>
<i>oldpath</i> already has the maximum number of links to it, or it was a directory and the directory containing <i>newpath</i> has the maximum number of links.</dd>
</dl>
<dl>
<dt>
<b>ENAMETOOLONG</b></dt>
<dd>
<i>oldpath</i> or <i>newpath</i> was too long.</dd>
</dl>
<dl>
<dt>
<b>ENOENT</b></dt>
<dd>
The link named by <i>oldpath</i> does not exist; or, a directory component in <i>newpath</i> does not exist; or, <i>oldpath</i> or <i>newpath</i> is an empty string.</dd>
</dl>
<dl>
<dt>
<b>ENOMEM</b></dt>
<dd>
Insufficient kernel memory was available.</dd>
</dl>
<dl>
<dt>
<b>ENOSPC</b></dt>
<dd>
The device containing the file has no room for the new directory entry.</dd>
</dl>
<dl>
<dt>
<b>ENOTDIR</b></dt>
<dd>
A component used as a directory in <i>oldpath</i> or <i>newpath</i> is not, in fact, a directory. Or, <i>oldpath</i> is a directory, and <i>newpath</i> exists but is not a directory.</dd>
</dl>
<dl>
<dt>
<b>ENOTEMPTY</b> or <b>EEXIST</b></dt>
<dd>
<i>newpath</i> is a nonempty directory, that is, contains entries other than &quot;.&quot; and &quot;..&quot;.</dd>
</dl>
<dl>
<dt>
<b>EPERM</b> or <b>EACCES</b></dt>
<dd>
The directory containing <i>oldpath</i> has the sticky bit (<b>S_ISVTX</b>) set and the process's effective user ID is neither the user ID of the file to be deleted nor that of the directory containing it, and the process is not privileged (Linux: does not have the <b>CAP_FOWNER</b> capability); or <i>newpath</i> is an existing file and the directory containing it has the sticky bit set and the process's effective user ID is neither the user ID of the file to be replaced nor that of the directory containing it, and the process is not privileged (Linux: does not have the <b>CAP_FOWNER</b> capability); or the file system containing <i>pathname</i> does not support renaming of the type requested.</dd>
</dl>
<dl>
<dt>
<b>EROFS</b></dt>
<dd>
The file is on a read-only file system.</dd>
</dl>
<dl>
<dt>
<b>EXDEV</b></dt>
<dd>
<i>oldpath</i> and <i>newpath</i> are not on the same mounted file system. (Linux permits a file system to be mounted at multiple points, but <b>rename</b>() does not work across different mount points, even if the same file system is mounted on both.)</dd>
</dl>
</div>
<div class="section">
<h1>CONFORMING TO</h1> 4.3BSD, C89, C99, POSIX.1-2001.</div>
<div class="section">
<h1>BUGS</h1> On NFS file systems, you can not assume that if the operation failed the file was not renamed. If the server does the rename operation and then crashes, the retransmitted RPC which will be processed when the server is up again causes a failure. The application is expected to deal with this. See <b>link</b>(2) for a similar problem.</div>
<div class="section">
<h1>SEE ALSO</h1> <b>mv</b>(1), <b>chmod</b>(2), <b>link</b>(2), <b>renameat</b>(2), <b>symlink</b>(2), <b>unlink</b>(2), <b>path_resolution</b>(7), <b>symlink</b>(7)</div>
<div class="section">
<h1>COLOPHON</h1> This page is part of release 3.35 of the Linux <i>man-pages</i> project. A description of the project, and information about reporting bugs, can be found at http://man7.org/linux/man-pages/.</div>
<table class="foot">
<tr>
<td class="foot-date">
2009-03-30</td>
<td class="foot-os">
Linux</td>
</tr>
</table>
</div>
</body>
</html>

