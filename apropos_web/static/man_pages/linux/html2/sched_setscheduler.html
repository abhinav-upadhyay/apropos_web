<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
SCHED_SETSCHEDULER(2)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
SCHED_SETSCHEDULER(2)</td>
<td class="head-vol">
Linux Programmer's Manual</td>
<td class="head-rtitle">
SCHED_SETSCHEDULER(2)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> sched_setscheduler, sched_getscheduler - set and get scheduling policy/parameters</div>
<div class="section">
<h1>SYNOPSIS</h1> <b>#include &lt;sched.h&gt;</b><div style="height: 1.00em;">
&#160;</div>
<br/>
<b>int sched_setscheduler(pid_t </b><i>pid</i><b>, int </b><i>policy</i><b>,</b><div style="height: 0.00em;">
&#160;</div>
<br/>
<b>                       const struct sched_param *</b><i>param</i><b>);</b><div style="height: 1.00em;">
&#160;</div>
<br/>
<b>int sched_getscheduler(pid_t </b><i>pid</i><b>);</b><div style="height: 1.00em;">
&#160;</div>
<br/>
<b>struct sched_param {</b><br/>
<b>    ...</b><br/>
<b>    int </b><i>sched_priority</i><b>;</b><br/>
<b>    ...</b><br/>
<b>};</b><br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> <b>sched_setscheduler</b>() sets both the scheduling policy and the associated parameters for the process whose ID is specified in  <i>pid</i>. If  <i>pid</i> equals zero, the scheduling policy and parameters of the calling process will be set. The interpretation of the argument  <i>param</i> depends on the selected policy. Currently, Linux supports the following &quot;normal&quot; (i.e., non-real-time) scheduling policies:<dl>
<dt>
<b>SCHED_OTHER</b></dt>
<dd>
the standard round-robin time-sharing policy;</dd>
</dl>
<dl>
<dt>
<b>SCHED_BATCH</b></dt>
<dd>
for &quot;batch&quot; style execution of processes; and</dd>
</dl>
<dl>
<dt>
<b>SCHED_IDLE</b></dt>
<dd>
for running <i>very</i> low priority background jobs.</dd>
</dl>
<div class="spacer">
</div>
The following &quot;real-time&quot; policies are also supported, for special time-critical applications that need precise control over the way in which runnable processes are selected for execution:<dl>
<dt>
<b>SCHED_FIFO</b></dt>
<dd>
a first-in, first-out policy; and</dd>
</dl>
<dl>
<dt>
<b>SCHED_RR</b></dt>
<dd>
a round-robin policy.</dd>
</dl>
<div class="spacer">
</div>
The semantics of each of these policies are detailed below.<div style="height: 1.00em;">
&#160;</div>
<b>sched_getscheduler</b>() queries the scheduling policy currently applied to the process identified by  <i>pid</i>. If  <i>pid</i> equals zero, the policy of the calling process will be retrieved.<div class="subsection">
<h2>Scheduling Policies</h2> The scheduler is the kernel component that decides which runnable process will be executed by the CPU next. Each process has an associated scheduling policy and a  <i>static</i> scheduling priority,  <i>sched_priority</i>; these are the settings that are modified by <b>sched_setscheduler</b>(). The scheduler makes it decisions based on knowledge of the scheduling policy and static priority of all processes on the system.<div style="height: 1.00em;">
&#160;</div>
For processes scheduled under one of the normal scheduling policies ( <b>SCHED_OTHER</b>, <b>SCHED_IDLE</b>, <b>SCHED_BATCH</b>),  <i>sched_priority</i> is not used in scheduling decisions (it must be specified as 0).<div style="height: 1.00em;">
&#160;</div>
Processes scheduled under one of the real-time policies ( <b>SCHED_FIFO</b>, <b>SCHED_RR</b>) have a  <i>sched_priority</i> value in the range 1 (low) to 99 (high). (As the numbers imply, real-time processes always have higher priority than normal processes.) Note well: POSIX.1-2001 only requires an implementation to support a minimum 32 distinct priority levels for the real-time policies, and some systems supply just this minimum. Portable programs should use <b>sched_get_priority_min</b>(2) and <b>sched_get_priority_max</b>(2) to find the range of priorities supported for a particular policy.<div style="height: 1.00em;">
&#160;</div>
Conceptually, the scheduler maintains a list of runnable processes for each possible  <i>sched_priority</i> value. In order to determine which process runs next, the scheduler looks for the nonempty list with the highest static priority and selects the process at the head of this list.<div style="height: 1.00em;">
&#160;</div>
A process's scheduling policy determines where it will be inserted into the list of processes with equal static priority and how it will move inside this list.<div style="height: 1.00em;">
&#160;</div>
All scheduling is preemptive: if a process with a higher static priority becomes ready to run, the currently running process will be preempted and returned to the wait list for its static priority level. The scheduling policy only determines the ordering within the list of runnable processes with equal static priority.</div>
<div class="subsection">
<h2>SCHED_FIFO: First In-First Out scheduling</h2>  <b>SCHED_FIFO</b> can only be used with static priorities higher than 0, which means that when a  <b>SCHED_FIFO</b> processes becomes runnable, it will always immediately preempt any currently running  <b>SCHED_OTHER</b>, <b>SCHED_BATCH</b>, or <b>SCHED_IDLE</b> process.  <b>SCHED_FIFO</b> is a simple scheduling algorithm without time slicing. For processes scheduled under the  <b>SCHED_FIFO</b> policy, the following rules apply:<dl>
<dt>
*</dt>
<dd>
A <b>SCHED_FIFO</b> process that has been preempted by another process of higher priority will stay at the head of the list for its priority and will resume execution as soon as all processes of higher priority are blocked again.</dd>
</dl>
<dl>
<dt>
*</dt>
<dd>
When a <b>SCHED_FIFO</b> process becomes runnable, it will be inserted at the end of the list for its priority.</dd>
</dl>
<dl>
<dt>
*</dt>
<dd>
A call to <b>sched_setscheduler</b>() or <b>sched_setparam</b>(2) will put the  <b>SCHED_FIFO</b> (or <b>SCHED_RR</b>) process identified by  <i>pid</i> at the start of the list if it was runnable. As a consequence, it may preempt the currently running process if it has the same priority. (POSIX.1-2001 specifies that the process should go to the end of the list.)</dd>
</dl>
<dl>
<dt>
*</dt>
<dd>
A process calling <b>sched_yield</b>(2) will be put at the end of the list.</dd>
</dl>
<div class="spacer">
</div>
No other events will move a process scheduled under the  <b>SCHED_FIFO</b> policy in the wait list of runnable processes with equal static priority.<div style="height: 1.00em;">
&#160;</div>
A <b>SCHED_FIFO</b> process runs until either it is blocked by an I/O request, it is preempted by a higher priority process, or it calls <b>sched_yield</b>(2).</div>
<div class="subsection">
<h2>SCHED_RR: Round Robin scheduling</h2>  <b>SCHED_RR</b> is a simple enhancement of <b>SCHED_FIFO</b>. Everything described above for  <b>SCHED_FIFO</b> also applies to <b>SCHED_RR</b>, except that each process is only allowed to run for a maximum time quantum. If a  <b>SCHED_RR</b> process has been running for a time period equal to or longer than the time quantum, it will be put at the end of the list for its priority. A  <b>SCHED_RR</b> process that has been preempted by a higher priority process and subsequently resumes execution as a running process will complete the unexpired portion of its round robin time quantum. The length of the time quantum can be retrieved using <b>sched_rr_get_interval</b>(2).</div>
<div class="subsection">
<h2>SCHED_OTHER: Default Linux time-sharing scheduling</h2>  <b>SCHED_OTHER</b> can only be used at static priority 0.  <b>SCHED_OTHER</b> is the standard Linux time-sharing scheduler that is intended for all processes that do not require the special real-time mechanisms. The process to run is chosen from the static priority 0 list based on a  <i>dynamic</i> priority that is determined only inside this list. The dynamic priority is based on the nice value (set by <b>nice</b>(2) or <b>setpriority</b>(2)) and increased for each time quantum the process is ready to run, but denied to run by the scheduler. This ensures fair progress among all  <b>SCHED_OTHER</b> processes.</div>
<div class="subsection">
<h2>SCHED_BATCH: Scheduling batch processes</h2> (Since Linux 2.6.16.)  <b>SCHED_BATCH</b> can only be used at static priority 0. This policy is similar to  <b>SCHED_OTHER</b> in that it schedules the process according to its dynamic priority (based on the nice value). The difference is that this policy will cause the scheduler to always assume that the process is CPU-intensive. Consequently, the scheduler will apply a small scheduling penalty with respect to wakeup behaviour, so that this process is mildly disfavored in scheduling decisions.<div style="height: 1.00em;">
&#160;</div>
This policy is useful for workloads that are noninteractive, but do not want to lower their nice value, and for workloads that want a deterministic scheduling policy without interactivity causing extra preemptions (between the workload's tasks).</div>
<div class="subsection">
<h2>SCHED_IDLE: Scheduling very low priority jobs</h2> (Since Linux 2.6.23.)  <b>SCHED_IDLE</b> can only be used at static priority 0; the process nice value has no influence for this policy.<div style="height: 1.00em;">
&#160;</div>
This policy is intended for running jobs at extremely low priority (lower even than a +19 nice value with the <b>SCHED_OTHER</b> or <b>SCHED_BATCH</b> policies).</div>
<div class="subsection">
<h2>Resetting scheduling policy for child processes</h2> Since Linux 2.6.32, the <b>SCHED_RESET_ON_FORK</b> flag can be ORed in <i>policy</i> when calling <b>sched_setscheduler</b>(). As a result of including this flag, children created by <b>fork</b>(2) do not inherit privileged scheduling policies. This feature is intended for media-playback applications, and can be used to prevent applications evading the <b>RLIMIT_RTTIME</b> resource limit (see <b>getrlimit</b>(2)) by creating multiple child processes.<div style="height: 1.00em;">
&#160;</div>
More precisely, if the <b>SCHED_RESET_ON_FORK</b> flag is specified, the following rules apply for subsequently created children:<dl>
<dt>
*</dt>
<dd>
If the calling process has a scheduling policy of <b>SCHED_FIFO</b> or <b>SCHED_RR</b>, the policy is reset to <b>SCHED_OTHER</b> in child processes.</dd>
</dl>
<dl>
<dt>
*</dt>
<dd>
If the calling process has a negative nice value, the nice value is reset to zero in child processes.</dd>
</dl>
<div class="spacer">
</div>
After the <b>SCHED_RESET_ON_FORK</b> flag has been enabled, it can only be reset if the process has the <b>CAP_SYS_NICE</b> capability. This flag is disabled in child processes created by <b>fork</b>(2).<div style="height: 1.00em;">
&#160;</div>
The <b>SCHED_RESET_ON_FORK</b> flag is visible in the policy value returned by <b>sched_getscheduler</b>()</div>
<div class="subsection">
<h2>Privileges and resource limits</h2> In Linux kernels before 2.6.12, only privileged (<b>CAP_SYS_NICE</b>) processes can set a nonzero static priority (i.e., set a real-time scheduling policy). The only change that an unprivileged process can make is to set the <b>SCHED_OTHER</b> policy, and this can only be done if the effective user ID of the caller of <b>sched_setscheduler</b>() matches the real or effective user ID of the target process (i.e., the process specified by <i>pid</i>) whose policy is being changed.<div style="height: 1.00em;">
&#160;</div>
Since Linux 2.6.12, the <b>RLIMIT_RTPRIO</b> resource limit defines a ceiling on an unprivileged process's static priority for the <b>SCHED_RR</b> and <b>SCHED_FIFO</b> policies. The rules for changing scheduling policy and priority are as follows:<dl>
<dt>
*</dt>
<dd>
If an unprivileged process has a nonzero <b>RLIMIT_RTPRIO</b> soft limit, then it can change its scheduling policy and priority, subject to the restriction that the priority cannot be set to a value higher than the maximum of its current priority and its <b>RLIMIT_RTPRIO</b> soft limit.</dd>
</dl>
<dl>
<dt>
*</dt>
<dd>
If the <b>RLIMIT_RTPRIO</b> soft limit is 0, then the only permitted changes are to lower the priority, or to switch to a non-real-time policy.</dd>
</dl>
<dl>
<dt>
*</dt>
<dd>
Subject to the same rules, another unprivileged process can also make these changes, as long as the effective user ID of the process making the change matches the real or effective user ID of the target process.</dd>
</dl>
<dl>
<dt>
*</dt>
<dd>
Special rules apply for the <b>SCHED_IDLE</b>. In Linux kernels before 2.6.39, an unprivileged process operating under this policy cannot change its policy, regardless of the value of its <b>RLIMIT_RTPRIO</b> resource limit. In Linux kernels since 2.6.39, an unprivileged process can switch to either the <b>SCHED_BATCH</b> or the <b>SCHED_NORMAL</b> policy so long as its nice value falls within the range permitted by its <b>RLIMIT_NICE</b> resource limit (see <b>getrlimit</b>(2)).</dd>
</dl>
<div class="spacer">
</div>
Privileged (<b>CAP_SYS_NICE</b>) processes ignore the <b>RLIMIT_RTPRIO</b> limit; as with older kernels, they can make arbitrary changes to scheduling policy and priority. See <b>getrlimit</b>(2) for further information on <b>RLIMIT_RTPRIO</b>.</div>
<div class="subsection">
<h2>Response time</h2> A blocked high priority process waiting for the I/O has a certain response time before it is scheduled again. The device driver writer can greatly reduce this response time by using a &quot;slow interrupt&quot; interrupt handler.</div>
<div class="subsection">
<h2>Miscellaneous</h2> Child processes inherit the scheduling policy and parameters across a <b>fork</b>(2). The scheduling policy and parameters are preserved across <b>execve</b>(2).<div style="height: 1.00em;">
&#160;</div>
Memory locking is usually needed for real-time processes to avoid paging delays; this can be done with <b>mlock</b>(2) or <b>mlockall</b>(2).<div style="height: 1.00em;">
&#160;</div>
Since a nonblocking infinite loop in a process scheduled under  <b>SCHED_FIFO</b> or <b>SCHED_RR</b> will block all processes with lower priority forever, a software developer should always keep available on the console a shell scheduled under a higher static priority than the tested application. This will allow an emergency kill of tested real-time applications that do not block or terminate as expected. See also the description of the <b>RLIMIT_RTTIME</b> resource limit in <b>getrlimit</b>(2).<div style="height: 1.00em;">
&#160;</div>
POSIX systems on which <b>sched_setscheduler</b>() and <b>sched_getscheduler</b>() are available define <b>_POSIX_PRIORITY_SCHEDULING</b> in  <i>&lt;unistd.h&gt;</i>.</div>
</div>
<div class="section">
<h1>RETURN VALUE</h1> On success, <b>sched_setscheduler</b>() returns zero. On success, <b>sched_getscheduler</b>() returns the policy for the process (a nonnegative integer). On error, -1 is returned, and <i>errno</i> is set appropriately.</div>
<div class="section">
<h1>ERRORS</h1><dl>
<dt>
<b>EINVAL</b></dt>
<dd>
The scheduling <i>policy</i> is not one of the recognized policies,  <i>param</i> is NULL, or  <i>param</i> does not make sense for the <i>policy</i>.</dd>
</dl>
<dl>
<dt>
<b>EPERM</b></dt>
<dd>
The calling process does not have appropriate privileges.</dd>
</dl>
<dl>
<dt>
<b>ESRCH</b></dt>
<dd>
The process whose ID is <i>pid</i> could not be found.</dd>
</dl>
</div>
<div class="section">
<h1>CONFORMING TO</h1> POSIX.1-2001 (but see BUGS below). The  <b>SCHED_BATCH</b> and <b>SCHED_IDLE</b> policies are Linux-specific.</div>
<div class="section">
<h1>NOTES</h1> POSIX.1 does not detail the permissions that an unprivileged process requires in order to call <b>sched_setscheduler</b>(), and details vary across systems. For example, the Solaris 7 manual page says that the real or effective user ID of the calling process must match the real user ID or the save set-user-ID of the target process.<div class="spacer">
</div>
Originally, Standard Linux was intended as a general-purpose operating system being able to handle background processes, interactive applications, and less demanding real-time applications (applications that need to usually meet timing deadlines). Although the Linux kernel 2.6 allowed for kernel preemption and the newly introduced O(1) scheduler ensures that the time needed to schedule is fixed and deterministic irrespective of the number of active tasks, true real-time computing was not possible up to kernel version 2.6.17.<div class="subsection">
<h2>Real-time features in the mainline Linux kernel</h2> From kernel version 2.6.18 onward, however, Linux is gradually becoming equipped with real-time capabilities, most of which are derived from the former <i>realtime-preempt</i> patches developed by Ingo Molnar, Thomas Gleixner, Steven Rostedt, and others. Until the patches have been completely merged into the mainline kernel (this is expected to be around kernel version 2.6.30), they must be installed to achieve the best real-time performance. These patches are named:<br/>
<div class="spacer">
</div>
<br/>
patch-<i>kernelversion</i>-rt<i>patchversion</i><br/>
<br/>
<div class="spacer">
</div>
and can be downloaded from <i>http://www.kernel.org/pub/linux/kernel/projects/rt/</i>.<div style="height: 1.00em;">
&#160;</div>
Without the patches and prior to their full inclusion into the mainline kernel, the kernel configuration offers only the three preemption classes <b>CONFIG_PREEMPT_NONE</b>, <b>CONFIG_PREEMPT_VOLUNTARY</b>, and <b>CONFIG_PREEMPT_DESKTOP</b> which respectively provide no, some, and considerable reduction of the worst-case scheduling latency.<div style="height: 1.00em;">
&#160;</div>
With the patches applied or after their full inclusion into the mainline kernel, the additional configuration item <b>CONFIG_PREEMPT_RT</b> becomes available. If this is selected, Linux is transformed into a regular real-time operating system. The FIFO and RR scheduling policies that can be selected using <b>sched_setscheduler</b>() are then used to run a process with true real-time priority and a minimum worst-case scheduling latency.</div>
</div>
<div class="section">
<h1>BUGS</h1> POSIX says that on success, <b>sched_setscheduler</b>() should return the previous scheduling policy. Linux <b>sched_setscheduler</b>() does not conform to this requirement, since it always returns 0 on success.</div>
<div class="section">
<h1>SEE ALSO</h1> <b>getpriority</b>(2), <b>mlock</b>(2), <b>mlockall</b>(2), <b>munlock</b>(2), <b>munlockall</b>(2), <b>nice</b>(2), <b>sched_get_priority_max</b>(2), <b>sched_get_priority_min</b>(2), <b>sched_getaffinity</b>(2), <b>sched_getparam</b>(2), <b>sched_rr_get_interval</b>(2), <b>sched_setaffinity</b>(2), <b>sched_setparam</b>(2), <b>sched_yield</b>(2), <b>setpriority</b>(2), <b>capabilities</b>(7), <b>cpuset</b>(7)<div class="spacer">
</div>
<i>Programming for the real world - POSIX.4</i> by Bill O. Gallmeister, O'Reilly &amp; Associates, Inc., ISBN 1-56592-074-0<div class="spacer">
</div>
The kernel source file <i>Documentation/scheduler/sched-rt-group.txt</i> (since kernel 2.6.25).</div>
<div class="section">
<h1>COLOPHON</h1> This page is part of release 3.35 of the Linux <i>man-pages</i> project. A description of the project, and information about reporting bugs, can be found at http://man7.org/linux/man-pages/.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-09-19</td>
<td class="foot-os">
Linux</td>
</tr>
</table>
</div>
</body>
</html>

