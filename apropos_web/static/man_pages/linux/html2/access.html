<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
ACCESS(2)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
ACCESS(2)</td>
<td class="head-vol">
Linux Programmer's Manual</td>
<td class="head-rtitle">
ACCESS(2)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> access - check real user's permissions for a file</div>
<div class="section">
<h1>SYNOPSIS</h1> <b>#include &lt;unistd.h&gt;</b><div style="height: 1.00em;">
&#160;</div>
<br/>
<b>int access(const char *</b><i>pathname</i><b>, int </b><i>mode</i><b>);</b><br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> <b>access</b>() checks whether the calling process can access the file <i>pathname</i>. If <i>pathname</i> is a symbolic link, it is dereferenced.<div style="height: 1.00em;">
&#160;</div>
The <i>mode</i> specifies the accessibility check(s) to be performed, and is either the value <b>F_OK</b>, or a mask consisting of the bitwise OR of one or more of <b>R_OK</b>, <b>W_OK</b>, and <b>X_OK</b>. <b>F_OK</b> tests for the existence of the file. <b>R_OK</b>, <b>W_OK</b>, and <b>X_OK</b> test whether the file exists and grants read, write, and execute permissions, respectively.<div style="height: 1.00em;">
&#160;</div>
The check is done using the calling process's <i>real</i> UID and GID, rather than the effective IDs as is done when actually attempting an operation (e.g., <b>open</b>(2)) on the file. This allows set-user-ID programs to easily determine the invoking user's authority.<div style="height: 1.00em;">
&#160;</div>
If the calling process is privileged (i.e., its real UID is zero), then an <b>X_OK</b> check is successful for a regular file if execute permission is enabled for any of the file owner, group, or other.</div>
<div class="section">
<h1>RETURN VALUE</h1> On success (all requested permissions granted), zero is returned. On error (at least one bit in <i>mode</i> asked for a permission that is denied, or some other error occurred), -1 is returned, and <i>errno</i> is set appropriately.</div>
<div class="section">
<h1>ERRORS</h1> <b>access</b>() shall fail if:<dl>
<dt>
<b>EACCES</b></dt>
<dd>
The requested access would be denied to the file, or search permission is denied for one of the directories in the path prefix of <i>pathname</i>. (See also <b>path_resolution</b>(7).)</dd>
</dl>
<dl>
<dt>
<b>ELOOP</b></dt>
<dd>
Too many symbolic links were encountered in resolving <i>pathname</i>.</dd>
</dl>
<dl>
<dt>
<b>ENAMETOOLONG</b></dt>
<dd>
<i>pathname</i> is too long.</dd>
</dl>
<dl>
<dt>
<b>ENOENT</b></dt>
<dd>
A component of <i>pathname</i> does not exist or is a dangling symbolic link.</dd>
</dl>
<dl>
<dt>
<b>ENOTDIR</b></dt>
<dd>
A component used as a directory in <i>pathname</i> is not, in fact, a directory.</dd>
</dl>
<dl>
<dt>
<b>EROFS</b></dt>
<dd>
Write permission was requested for a file on a read-only file system.</dd>
</dl>
<div class="spacer">
</div>
<b>access</b>() may fail if:<dl>
<dt>
<b>EFAULT</b></dt>
<dd>
<i>pathname</i> points outside your accessible address space.</dd>
</dl>
<dl>
<dt>
<b>EINVAL</b></dt>
<dd>
<i>mode</i> was incorrectly specified.</dd>
</dl>
<dl>
<dt>
<b>EIO</b></dt>
<dd>
An I/O error occurred.</dd>
</dl>
<dl>
<dt>
<b>ENOMEM</b></dt>
<dd>
Insufficient kernel memory was available.</dd>
</dl>
<dl>
<dt>
<b>ETXTBSY</b></dt>
<dd>
Write access was requested to an executable which is being executed.</dd>
</dl>
</div>
<div class="section">
<h1>CONFORMING TO</h1> SVr4, 4.3BSD, POSIX.1-2001.</div>
<div class="section">
<h1>NOTES</h1> <b>Warning</b>: Using <b>access</b>() to check if a user is authorized to, for example, open a file before actually doing so using <b>open</b>(2) creates a security hole, because the user might exploit the short time interval between checking and opening the file to manipulate it. <b>For this reason, the use of this system call should be avoided</b>. (In the example just described, a safer alternative would be to temporarily switch the process's effective user ID to the real ID and then call <b>open</b>(2).)<div class="spacer">
</div>
<b>access</b>() always dereferences symbolic links. If you need to check the permissions on a symbolic link, use <b>faccessat(2)</b> with the flag <b>AT_SYMLINK_NOFOLLOW</b>.<div class="spacer">
</div>
<b>access</b>() returns an error if any of the access types in <i>mode</i> is denied, even if some of the other access types in <i>mode</i> are permitted.<div class="spacer">
</div>
If the calling process has appropriate privileges (i.e., is superuser), POSIX.1-2001 permits an implementation to indicate success for an <b>X_OK</b> check even if none of the execute file permission bits are set. Linux does not do this.<div class="spacer">
</div>
A file is only accessible if the permissions on each of the directories in the path prefix of <i>pathname</i> grant search (i.e., execute) access. If any directory is inaccessible, then the <b>access</b>() call will fail, regardless of the permissions on the file itself.<div class="spacer">
</div>
Only access bits are checked, not the file type or contents. Therefore, if a directory is found to be writable, it probably means that files can be created in the directory, and not that the directory can be written as a file. Similarly, a DOS file may be found to be &quot;executable,&quot; but the <b>execve</b>(2) call will still fail.<div class="spacer">
</div>
<b>access</b>() may not work correctly on NFS file systems with UID mapping enabled, because UID mapping is done on the server and hidden from the client, which checks permissions.</div>
<div class="section">
<h1>BUGS</h1> In kernel 2.4 (and earlier) there is some strangeness in the handling of <b>X_OK</b> tests for superuser. If all categories of execute permission are disabled for a nondirectory file, then the only <b>access</b>() test that returns -1 is when <i>mode</i> is specified as just <b>X_OK</b>; if <b>R_OK</b> or <b>W_OK</b> is also specified in <i>mode</i>, then <b>access</b>() returns 0 for such files. Early 2.6 kernels (up to and including 2.6.3) also behaved in the same way as kernel 2.4.<div style="height: 1.00em;">
&#160;</div>
In kernels before 2.6.20, <b>access</b>() ignored the effect of the <b>MS_NOEXEC</b> flag if it was used to <b>mount</b>(2) the underlying file system. Since kernel 2.6.20, <b>access</b>() honors this flag.</div>
<div class="section">
<h1>SEE ALSO</h1> <b>chmod</b>(2), <b>chown</b>(2), <b>faccessat</b>(2), <b>open</b>(2), <b>setgid</b>(2), <b>setuid</b>(2), <b>stat</b>(2), <b>euidaccess</b>(3), <b>credentials</b>(7), <b>path_resolution</b>(7)</div>
<div class="section">
<h1>COLOPHON</h1> This page is part of release 3.35 of the Linux <i>man-pages</i> project. A description of the project, and information about reporting bugs, can be found at http://man7.org/linux/man-pages/.</div>
<table class="foot">
<tr>
<td class="foot-date">
2010-10-24</td>
<td class="foot-os">
Linux</td>
</tr>
</table>
</div>
</body>
</html>

