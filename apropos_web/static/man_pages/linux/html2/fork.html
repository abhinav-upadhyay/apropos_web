<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
FORK(2)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
FORK(2)</td>
<td class="head-vol">
Linux Programmer's Manual</td>
<td class="head-rtitle">
FORK(2)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> fork - create a child process</div>
<div class="section">
<h1>SYNOPSIS</h1> <b>#include &lt;unistd.h&gt;</b><div style="height: 1.00em;">
&#160;</div>
<b>pid_t fork(void);</b></div>
<div class="section">
<h1>DESCRIPTION</h1> <b>fork</b>() creates a new process by duplicating the calling process. The new process, referred to as the  <i>child</i>, is an exact duplicate of the calling process, referred to as the  <i>parent</i>, except for the following points:<dl>
<dt>
*</dt>
<dd>
The child has its own unique process ID, and this PID does not match the ID of any existing process group (<b>setpgid</b>(2)).</dd>
</dl>
<dl>
<dt>
*</dt>
<dd>
The child's parent process ID is the same as the parent's process ID.</dd>
</dl>
<dl>
<dt>
*</dt>
<dd>
The child does not inherit its parent's memory locks (<b>mlock</b>(2), <b>mlockall</b>(2)).</dd>
</dl>
<dl>
<dt>
*</dt>
<dd>
Process resource utilizations (<b>getrusage</b>(2)) and CPU time counters (<b>times</b>(2)) are reset to zero in the child.</dd>
</dl>
<dl>
<dt>
*</dt>
<dd>
The child's set of pending signals is initially empty (<b>sigpending</b>(2)).</dd>
</dl>
<dl>
<dt>
*</dt>
<dd>
The child does not inherit semaphore adjustments from its parent (<b>semop</b>(2)).</dd>
</dl>
<dl>
<dt>
*</dt>
<dd>
The child does not inherit record locks from its parent (<b>fcntl</b>(2)).</dd>
</dl>
<dl>
<dt>
*</dt>
<dd>
The child does not inherit timers from its parent (<b>setitimer</b>(2), <b>alarm</b>(2), <b>timer_create</b>(2)).</dd>
</dl>
<dl>
<dt>
*</dt>
<dd>
The child does not inherit outstanding asynchronous I/O operations from its parent (<b>aio_read</b>(3), <b>aio_write</b>(3)), nor does it inherit any asynchronous I/O contexts from its parent (see <b>io_setup</b>(2)).</dd>
</dl>
<div class="spacer">
</div>
The process attributes in the preceding list are all specified in POSIX.1-2001. The parent and child also differ with respect to the following Linux-specific process attributes:<dl>
<dt>
*</dt>
<dd>
The child does not inherit directory change notifications (dnotify) from its parent (see the description of <b>F_NOTIFY</b> in <b>fcntl</b>(2)).</dd>
</dl>
<dl>
<dt>
*</dt>
<dd>
The <b>prctl</b>(2) <b>PR_SET_PDEATHSIG</b> setting is reset so that the child does not receive a signal when its parent terminates.</dd>
</dl>
<dl>
<dt>
*</dt>
<dd>
Memory mappings that have been marked with the <b>madvise</b>(2) <b>MADV_DONTFORK</b> flag are not inherited across a <b>fork</b>().</dd>
</dl>
<dl>
<dt>
*</dt>
<dd>
The termination signal of the child is always <b>SIGCHLD</b> (see <b>clone</b>(2)).</dd>
</dl>
<div class="spacer">
</div>
Note the following further points:<dl>
<dt>
*</dt>
<dd>
The child process is created with a single thread&#8212;the one that called <b>fork</b>(). The entire virtual address space of the parent is replicated in the child, including the states of mutexes, condition variables, and other pthreads objects; the use of <b>pthread_atfork</b>(3) may be helpful for dealing with problems that this can cause.</dd>
</dl>
<dl>
<dt>
*</dt>
<dd>
The child inherits copies of the parent's set of open file descriptors. Each file descriptor in the child refers to the same open file description (see <b>open</b>(2)) as the corresponding file descriptor in the parent. This means that the two descriptors share open file status flags, current file offset, and signal-driven I/O attributes (see the description of <b>F_SETOWN</b> and <b>F_SETSIG</b> in <b>fcntl</b>(2)).</dd>
</dl>
<dl>
<dt>
*</dt>
<dd>
The child inherits copies of the parent's set of open message queue descriptors (see <b>mq_overview</b>(7)). Each descriptor in the child refers to the same open message queue description as the corresponding descriptor in the parent. This means that the two descriptors share the same flags (<i>mq_flags</i>).</dd>
</dl>
<dl>
<dt>
*</dt>
<dd>
The child inherits copies of the parent's set of open directory streams (see <b>opendir</b>(3)). POSIX.1-2001 says that the corresponding directory streams in the parent and child <i>may</i> share the directory stream positioning; on Linux/glibc they do not.</dd>
</dl>
</div>
<div class="section">
<h1>RETURN VALUE</h1> On success, the PID of the child process is returned in the parent, and 0 is returned in the child. On failure, -1 is returned in the parent, no child process is created, and <i>errno</i> is set appropriately.</div>
<div class="section">
<h1>ERRORS</h1><dl>
<dt>
<b>EAGAIN</b></dt>
<dd>
<b>fork</b>() cannot allocate sufficient memory to copy the parent's page tables and allocate a task structure for the child.</dd>
</dl>
<dl>
<dt>
<b>EAGAIN</b></dt>
<dd>
It was not possible to create a new process because the caller's <b>RLIMIT_NPROC</b> resource limit was encountered. To exceed this limit, the process must have either the <b>CAP_SYS_ADMIN</b> or the <b>CAP_SYS_RESOURCE</b> capability.</dd>
</dl>
<dl>
<dt>
<b>ENOMEM</b></dt>
<dd>
<b>fork</b>() failed to allocate the necessary kernel structures because memory is tight.</dd>
</dl>
</div>
<div class="section">
<h1>CONFORMING TO</h1> SVr4, 4.3BSD, POSIX.1-2001.</div>
<div class="section">
<h1>NOTES</h1> Under Linux, <b>fork</b>() is implemented using copy-on-write pages, so the only penalty that it incurs is the time and memory required to duplicate the parent's page tables, and to create a unique task structure for the child.<div style="height: 1.00em;">
&#160;</div>
Since version 2.3.3, rather than invoking the kernel's <b>fork</b>() system call, the glibc <b>fork</b>() wrapper that is provided as part of the NPTL threading implementation invokes <b>clone</b>(2) with flags that provide the same effect as the traditional system call. The glibc wrapper invokes any fork handlers that have been established using <b>pthread_atfork</b>(3).</div>
<div class="section">
<h1>EXAMPLE</h1> See <b>pipe</b>(2) and <b>wait</b>(2).</div>
<div class="section">
<h1>SEE ALSO</h1> <b>clone</b>(2), <b>execve</b>(2), <b>setrlimit</b>(2), <b>unshare</b>(2), <b>vfork</b>(2), <b>wait</b>(2), <b>daemon</b>(3), <b>capabilities</b>(7), <b>credentials</b>(7)</div>
<div class="section">
<h1>COLOPHON</h1> This page is part of release 3.35 of the Linux <i>man-pages</i> project. A description of the project, and information about reporting bugs, can be found at http://man7.org/linux/man-pages/.</div>
<table class="foot">
<tr>
<td class="foot-date">
2009-04-27</td>
<td class="foot-os">
Linux</td>
</tr>
</table>
</div>
</body>
</html>

