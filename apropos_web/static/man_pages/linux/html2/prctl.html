<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
PRCTL(2)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
PRCTL(2)</td>
<td class="head-vol">
Linux Programmer's Manual</td>
<td class="head-rtitle">
PRCTL(2)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> prctl - operations on a process</div>
<div class="section">
<h1>SYNOPSIS</h1> <b>#include &lt;sys/prctl.h&gt;</b><div style="height: 1.00em;">
&#160;</div>
<br/>
<b>int prctl(int </b><i>option</i><b>, unsigned long </b><i>arg2</i><b>, unsigned long </b><i>arg3</i><b>,</b><br/>
<b>          unsigned long </b><i>arg4</i><b>, unsigned long </b><i>arg5</i><b>);</b><br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> <b>prctl</b>() is called with a first argument describing what to do (with values defined in  <i>&lt;linux/prctl.h&gt;</i>), and further arguments with a significance depending on the first one. The first argument can be:<dl>
<dt>
<b>PR_CAPBSET_READ</b> (since Linux 2.6.25)</dt>
<dd>
Return (as the function result) 1 if the capability specified in <i>arg2</i> is in the calling thread's capability bounding set, or 0 if it is not. (The capability constants are defined in <i>&lt;linux/capability.h&gt;</i>.) The capability bounding set dictates whether the process can receive the capability through a file's permitted capability set on a subsequent call to <b>execve</b>(2).<div style="height: 1.00em;">
&#160;</div>
If the capability specified in <i>arg2</i> is not valid, then the call fails with the error <b>EINVAL</b>.</dd>
</dl>
<dl>
<dt>
<b>PR_CAPBSET_DROP</b> (since Linux 2.6.25)</dt>
<dd>
If the calling thread has the <b>CAP_SETPCAP</b> capability, then drop the capability specified by <i>arg2</i> from the calling thread's capability bounding set. Any children of the calling thread will inherit the newly reduced bounding set.<div style="height: 1.00em;">
&#160;</div>
The call fails with the error: <b>EPERM</b> if the calling thread does not have the <b>CAP_SETPCAP</b>; <b>EINVAL</b> if <i>arg2</i> does not represent a valid capability; or <b>EINVAL</b> if file capabilities are not enabled in the kernel, in which case bounding sets are not supported.</dd>
</dl>
<dl>
<dt>
<b>PR_SET_DUMPABLE</b> (since Linux 2.3.20)</dt>
<dd>
Set the state of the flag determining whether core dumps are produced for this process upon delivery of a signal whose default behavior is to produce a core dump. (Normally this flag is set for a process by default, but it is cleared when a set-user-ID or set-group-ID program is executed and also by various system calls that manipulate process UIDs and GIDs). In kernels up to and including 2.6.12, <i>arg2</i> must be either 0 (process is not dumpable) or 1 (process is dumpable). Between kernels 2.6.13 and 2.6.17, the value 2 was also permitted, which caused any binary which normally would not be dumped to be dumped readable by root only; for security reasons, this feature has been removed. (See also the description of <i>/proc/sys/fs/suid_dumpable</i> in <b>proc</b>(5).) Processes that are not dumpable can not be attached via <b>ptrace(2)</b> <b>PTRACE_ATTACH</b>.</dd>
</dl>
<dl>
<dt>
<b>PR_GET_DUMPABLE</b> (since Linux 2.3.20)</dt>
<dd>
Return (as the function result) the current state of the calling process's dumpable flag.</dd>
</dl>
<dl>
<dt>
<b>PR_SET_ENDIAN</b> (since Linux 2.6.18, PowerPC only)</dt>
<dd>
Set the endian-ness of the calling process to the value given in  <i>arg2</i>, which should be one of the following: <b>PR_ENDIAN_BIG</b>, <b>PR_ENDIAN_LITTLE</b>, or <b>PR_ENDIAN_PPC_LITTLE</b> (PowerPC pseudo little endian).</dd>
</dl>
<dl>
<dt>
<b>PR_GET_ENDIAN</b> (since Linux 2.6.18, PowerPC only)</dt>
<dd>
Return the endian-ness of the calling process, in the location pointed to by <i>(int&#160;*) arg2</i>.</dd>
</dl>
<dl>
<dt>
<b>PR_SET_FPEMU</b> (since Linux 2.4.18, 2.5.9, only on ia64)</dt>
<dd>
Set floating-point emulation control bits to <i>arg2</i>. Pass  <b>PR_FPEMU_NOPRINT</b> to silently emulate fp operations accesses, or  <b>PR_FPEMU_SIGFPE</b> to not emulate fp operations and send <b>SIGFPE</b> instead.</dd>
</dl>
<dl>
<dt>
<b>PR_GET_FPEMU</b> (since Linux 2.4.18, 2.5.9, only on ia64)</dt>
<dd>
Return floating-point emulation control bits, in the location pointed to by <i>(int&#160;*) arg2</i>.</dd>
</dl>
<dl>
<dt>
<b>PR_SET_FPEXC</b> (since Linux 2.4.21, 2.5.32, only on PowerPC)</dt>
<dd>
Set floating-point exception mode to <i>arg2</i>. Pass  <b>PR_FP_EXC_SW_ENABLE</b> to use FPEXC for FP exception enables,  <b>PR_FP_EXC_DIV</b> for floating-point divide by zero,  <b>PR_FP_EXC_OVF</b> for floating-point overflow,  <b>PR_FP_EXC_UND</b> for floating-point underflow,  <b>PR_FP_EXC_RES</b> for floating-point inexact result,  <b>PR_FP_EXC_INV</b> for floating-point invalid operation,  <b>PR_FP_EXC_DISABLED</b> for FP exceptions disabled,  <b>PR_FP_EXC_NONRECOV</b> for async nonrecoverable exception mode,  <b>PR_FP_EXC_ASYNC</b> for async recoverable exception mode,  <b>PR_FP_EXC_PRECISE</b> for precise exception mode.</dd>
</dl>
<dl>
<dt>
<b>PR_GET_FPEXC</b> (since Linux 2.4.21, 2.5.32, only on PowerPC)</dt>
<dd>
Return floating-point exception mode, in the location pointed to by <i>(int&#160;*) arg2</i>.</dd>
</dl>
<dl>
<dt>
<b>PR_SET_KEEPCAPS</b> (since Linux 2.2.18)</dt>
<dd>
Set the state of the thread's &quot;keep capabilities&quot; flag, which determines whether the threads's permitted capability set is cleared when a change is made to the threads's user IDs such that the threads's real UID, effective UID, and saved set-user-ID all become nonzero when at least one of them previously had the value 0. By default, the permitted capability set is cleared when such a change is made; setting the &quot;keep capabilities&quot; flag prevents it from being cleared. <i>arg2</i> must be either 0 (permitted capabilities are cleared) or 1 (permitted capabilities are kept). (A thread's <i>effective</i> capability set is always cleared when such a credential change is made, regardless of the setting of the &quot;keep capabilities&quot; flag.) The &quot;keep capabilities&quot; value will be reset to 0 on subsequent calls to <b>execve</b>(2).</dd>
</dl>
<dl>
<dt>
<b>PR_GET_KEEPCAPS</b> (since Linux 2.2.18)</dt>
<dd>
Return (as the function result) the current state of the calling threads's &quot;keep capabilities&quot; flag.</dd>
</dl>
<dl>
<dt>
<b>PR_SET_NAME</b> (since Linux 2.6.9)</dt>
<dd>
Set the process name for the calling process, using the value in the location pointed to by <i>(char&#160;*) arg2</i>. The name can be up to 16 bytes long, and should be null-terminated if it contains fewer bytes.</dd>
</dl>
<dl>
<dt>
<b>PR_GET_NAME</b> (since Linux 2.6.11)</dt>
<dd>
Return the process name for the calling process, in the buffer pointed to by <i>(char&#160;*) arg2</i>. The buffer should allow space for up to 16 bytes; the returned string will be null-terminated if it is shorter than that.</dd>
</dl>
<dl>
<dt>
<b>PR_SET_PDEATHSIG</b> (since Linux 2.1.57)</dt>
<dd>
Set the parent process death signal of the calling process to  <i>arg2</i> (either a signal value in the range 1..maxsig, or 0 to clear). This is the signal that the calling process will get when its parent dies. This value is cleared for the child of a <b>fork</b>(2).</dd>
</dl>
<dl>
<dt>
<b>PR_GET_PDEATHSIG</b> (since Linux 2.3.15)</dt>
<dd>
Return the current value of the parent process death signal, in the location pointed to by <i>(int&#160;*) arg2</i>.</dd>
</dl>
<dl>
<dt>
<b>PR_SET_PTRACER</b> (since Ubuntu 10.10)</dt>
<dd>
Sets the top of the process tree that is allowed to use PTRACE on the calling process, assuming other requirements are met (matching uid, wasn't setuid, etc). The allowed process id is specified in  <i>arg2</i> (or 0 to clear). For more details, see  <i>/etc/sysctl.d/10-ptrace.conf</i>.</dd>
</dl>
<dl>
<dt>
<b>PR_SET_SECCOMP</b> (since Linux 2.6.23)</dt>
<dd>
Set the secure computing mode for the calling thread. In the current implementation, <i>arg2</i> must be 1. After the secure computing mode has been set to 1, the only system calls that the thread is permitted to make are <b>read</b>(2), <b>write</b>(2), <b>_exit</b>(2), and <b>sigreturn</b>(2). Other system calls result in the delivery of a <b>SIGKILL</b> signal. Secure computing mode is useful for number-crunching applications that may need to execute untrusted byte code, perhaps obtained by reading from a pipe or socket. This operation is only available if the kernel is configured with CONFIG_SECCOMP enabled.</dd>
</dl>
<dl>
<dt>
<b>PR_GET_SECCOMP</b> (since Linux 2.6.23)</dt>
<dd>
Return the secure computing mode of the calling thread. Not very useful for the current implementation (mode equals 1), but may be useful for other possible future modes: if the caller is not in secure computing mode, this operation returns 0; if the caller is in secure computing mode, then the <b>prctl</b>() call will cause a <b>SIGKILL</b> signal to be sent to the process. This operation is only available if the kernel is configured with CONFIG_SECCOMP enabled.</dd>
</dl>
<dl>
<dt>
<b>PR_SET_SECUREBITS</b> (since Linux 2.6.26)</dt>
<dd>
Set the &quot;securebits&quot; flags of the calling thread to the value supplied in <i>arg2</i>. See <b>capabilities</b>(7).</dd>
</dl>
<dl>
<dt>
<b>PR_GET_SECUREBITS</b> (since Linux 2.6.26)</dt>
<dd>
Return (as the function result) the &quot;securebits&quot; flags of the calling thread. See <b>capabilities</b>(7).</dd>
</dl>
<dl>
<dt>
<b>PR_SET_TIMING</b> (since Linux 2.6.0-test4)</dt>
<dd>
Set whether to use (normal, traditional) statistical process timing or accurate timestamp-based process timing, by passing <b>PR_TIMING_STATISTICAL</b> or <b>PR_TIMING_TIMESTAMP</b> to  <i>arg2</i>. <b>PR_TIMING_TIMESTAMP</b> is not currently implemented (attempting to set this mode will yield the error <b>EINVAL</b>).</dd>
</dl>
<dl>
<dt>
<b>PR_GET_TIMING</b> (since Linux 2.6.0-test4)</dt>
<dd>
Return (as the function result) which process timing method is currently in use.</dd>
</dl>
<dl>
<dt>
<b>PR_SET_TSC</b> (since Linux 2.6.26, x86 only)</dt>
<dd>
Set the state of the flag determining whether the timestamp counter can be read by the process. Pass <b>PR_TSC_ENABLE</b> to <i>arg2</i> to allow it to be read, or <b>PR_TSC_SIGSEGV</b> to generate a <b>SIGSEGV</b> when the process tries to read the timestamp counter.</dd>
</dl>
<dl>
<dt>
<b>PR_GET_TSC</b> (since Linux 2.6.26, x86 only)</dt>
<dd>
Return the state of the flag determining whether the timestamp counter can be read, in the location pointed to by <i>(int&#160;*) arg2</i>.</dd>
</dl>
<dl>
<dt>
<b>PR_SET_UNALIGN</b></dt>
<dd>
(Only on: ia64, since Linux 2.3.48; parisc, since Linux 2.6.15; PowerPC, since Linux 2.6.18; Alpha, since Linux 2.6.22) Set unaligned access control bits to  <i>arg2</i>. Pass  <b>PR_UNALIGN_NOPRINT</b> to silently fix up unaligned user accesses, or  <b>PR_UNALIGN_SIGBUS</b> to generate <b>SIGBUS</b> on unaligned user access.</dd>
</dl>
<dl>
<dt>
<b>PR_GET_UNALIGN</b></dt>
<dd>
(see <b>PR_SET_UNALIGN</b> for information on versions and architectures) Return unaligned access control bits, in the location pointed to by <i>(int&#160;*) arg2</i>.</dd>
</dl>
<dl>
<dt>
<b>PR_MCE_KILL</b> (since Linux 2.6.32)</dt>
<dd>
Set the machine check memory corruption kill policy for the current thread. If <i>arg2</i> is <b>PR_MCE_KILL_CLEAR</b>, clear the thread memory corruption kill policy and use the system-wide default. (The system-wide default is defined by <i>/proc/sys/vm/memory_failure_early_kill</i>; see <b>proc</b>(5).) If <i>arg2</i> is <b>PR_MCE_KILL_SET</b>, use a thread-specific memory corruption kill policy. In this case, <i>arg3</i> defines whether the policy is <i>early kill</i> (<b>PR_MCE_KILL_EARLY</b>), <i>late kill</i> (<b>PR_MCE_KILL_LATE</b>), or the system-wide default (<b>PR_MCE_KILL_DEFAULT</b>). Early kill means that the thread receives a <b>SIGBUS</b> signal as soon as hardware memory corruption is detected inside its address space. In late kill mode, the process is only killed when it accesses a corrupted page. See <b>sigaction</b>(2) for more information on the <b>SIGBUS</b> signal. The policy is inherited by children. The remaining unused <b>prctl</b>() arguments must be zero for future compatibility.</dd>
</dl>
<dl>
<dt>
<b>PR_MCE_KILL_GET</b> (since Linux 2.6.32)</dt>
<dd>
Return the current per-process machine check kill policy. All unused <b>prctl</b>() arguments must be zero.</dd>
</dl>
</div>
<div class="section">
<h1>RETURN VALUE</h1> On success, <b>PR_GET_DUMPABLE</b>, <b>PR_GET_KEEPCAPS</b>, <b>PR_CAPBSET_READ</b>, <b>PR_GET_TIMING</b>, <b>PR_GET_SECUREBITS</b>, <b>PR_MCE_KILL_GET</b>, and (if it returns) <b>PR_GET_SECCOMP</b> return the nonnegative values described above. All other <i>option</i> values return 0 on success. On error, -1 is returned, and <i>errno</i> is set appropriately.</div>
<div class="section">
<h1>ERRORS</h1><dl>
<dt>
<b>EFAULT</b></dt>
<dd>
<i>arg2</i> is an invalid address.</dd>
</dl>
<dl>
<dt>
<b>EINVAL</b></dt>
<dd>
The value of <i>option</i> is not recognized.</dd>
</dl>
<dl>
<dt>
<b>EINVAL</b></dt>
<dd>
<i>option</i> is <b>PR_MCE_KILL</b> or <b>PR_MCE_KILL_GET</b>, and unused <b>prctl</b>() arguments were not specified as zero.</dd>
</dl>
<dl>
<dt>
<b>EINVAL</b></dt>
<dd>
<i>arg2</i> is not valid value for this <i>option</i>.</dd>
</dl>
<dl>
<dt>
<b>EINVAL</b></dt>
<dd>
<i>option</i> is <b>PR_SET_SECCOMP</b> or <b>PR_SET_SECCOMP</b>, and the kernel was not configured with <b>CONFIG_SECCOMP</b>.</dd>
</dl>
<dl>
<dt>
<b>EPERM</b></dt>
<dd>
<i>option</i> is <b>PR_SET_SECUREBITS</b>, and the caller does not have the <b>CAP_SETPCAP</b> capability, or tried to unset a &quot;locked&quot; flag, or tried to set a flag whose corresponding locked flag was set (see <b>capabilities</b>(7)).</dd>
</dl>
<dl>
<dt>
<b>EPERM</b></dt>
<dd>
<i>option</i> is <b>PR_SET_KEEPCAPS</b>, and the callers's <b>SECURE_KEEP_CAPS_LOCKED</b> flag is set (see <b>capabilities</b>(7)).</dd>
</dl>
<dl>
<dt>
<b>EPERM</b></dt>
<dd>
<i>option</i> is <b>PR_CAPBSET_DROP</b>, and the caller does not have the <b>CAP_SETPCAP</b> capability.</dd>
</dl>
</div>
<div class="section">
<h1>VERSIONS</h1> The <b>prctl</b>() system call was introduced in Linux 2.1.57.</div>
<div class="section">
<h1>CONFORMING TO</h1> This call is Linux-specific. IRIX has a <b>prctl</b>() system call (also introduced in Linux 2.1.44 as irix_prctl on the MIPS architecture), with prototype<div style="height: 1.00em;">
&#160;</div>
<b>ptrdiff_t prctl(int </b><i>option</i><b>, int </b><i>arg2</i><b>, int </b><i>arg3</i><b>);</b><div style="height: 1.00em;">
&#160;</div>
and options to get the maximum number of processes per user, get the maximum number of processors the calling process can use, find out whether a specified process is currently blocked, get or set the maximum stack size, etc.</div>
<div class="section">
<h1>SEE ALSO</h1> <b>signal</b>(2), <b>core</b>(5)</div>
<div class="section">
<h1>COLOPHON</h1> This page is part of release 3.35 of the Linux <i>man-pages</i> project. A description of the project, and information about reporting bugs, can be found at http://man7.org/linux/man-pages/.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-09-17</td>
<td class="foot-os">
Linux</td>
</tr>
</table>
</div>
</body>
</html>

