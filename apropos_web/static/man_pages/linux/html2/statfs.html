<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
STATFS(2)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
STATFS(2)</td>
<td class="head-vol">
Linux Programmer's Manual</td>
<td class="head-rtitle">
STATFS(2)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> statfs, fstatfs - get file system statistics</div>
<div class="section">
<h1>SYNOPSIS</h1> <b>#include &lt;sys/vfs.h&gt;    </b>/* or &lt;sys/statfs.h&gt; */<div style="height: 1.00em;">
&#160;</div>
<b>int statfs(const char *</b><i>path</i><b>, struct statfs *</b><i>buf</i><b>);</b><div style="height: 0.00em;">
&#160;</div>
<b>int fstatfs(int </b><i>fd</i><b>, struct statfs *</b><i>buf</i><b>);</b></div>
<div class="section">
<h1>DESCRIPTION</h1> The function <b>statfs</b>() returns information about a mounted file system. <i>path</i> is the pathname of any file within the mounted file system. <i>buf</i> is a pointer to a <i>statfs</i> structure defined approximately as follows:<div style="height: 1.00em;">
&#160;</div>
<br/>
<br/>
#if __WORDSIZE == 32		/* System word size */<br/>
# define __SWORD_TYPE           int<br/>
#else /* __WORDSIZE == 64 */<br/>
# define __SWORD_TYPE		long int<br/>
#endif<div class="spacer">
</div>
<br/>
struct statfs {<br/>
    __SWORD_TYPE f_type;    /* type of file system (see below) */<br/>
    __SWORD_TYPE f_bsize;   /* optimal transfer block size */<br/>
    fsblkcnt_t   f_blocks;  /* total data blocks in file system */<br/>
    fsblkcnt_t   f_bfree;   /* free blocks in fs */<br/>
    fsblkcnt_t   f_bavail;  /* free blocks available to<br/>
                               unprivileged user */<br/>
    fsfilcnt_t   f_files;   /* total file nodes in file system */<br/>
    fsfilcnt_t   f_ffree;   /* free file nodes in fs */<br/>
    fsid_t       f_fsid;    /* file system id */<br/>
    __SWORD_TYPE f_namelen; /* maximum length of filenames */<br/>
    __SWORD_TYPE f_frsize;  /* fragment size (since Linux 2.6) */<br/>
    __SWORD_TYPE f_spare[5];<br/>
};<div class="spacer">
</div>
<br/>
File system types:<div class="spacer">
</div>
<br/>
   ADFS_SUPER_MAGIC      0xadf5<br/>
   AFFS_SUPER_MAGIC      0xADFF<br/>
   BEFS_SUPER_MAGIC      0x42465331<br/>
   BFS_MAGIC             0x1BADFACE<br/>
   CIFS_MAGIC_NUMBER     0xFF534D42<br/>
   CODA_SUPER_MAGIC      0x73757245<br/>
   COH_SUPER_MAGIC       0x012FF7B7<br/>
   CRAMFS_MAGIC          0x28cd3d45<br/>
   DEVFS_SUPER_MAGIC     0x1373<br/>
   EFS_SUPER_MAGIC       0x00414A53<br/>
   EXT_SUPER_MAGIC       0x137D<br/>
   EXT2_OLD_SUPER_MAGIC  0xEF51<br/>
   EXT2_SUPER_MAGIC      0xEF53<br/>
   EXT3_SUPER_MAGIC      0xEF53<br/>
   EXT4_SUPER_MAGIC      0xEF53<br/>
   HFS_SUPER_MAGIC       0x4244<br/>
   HPFS_SUPER_MAGIC      0xF995E849<br/>
   HUGETLBFS_MAGIC       0x958458f6<br/>
   ISOFS_SUPER_MAGIC     0x9660<br/>
   JFFS2_SUPER_MAGIC     0x72b6<br/>
   JFS_SUPER_MAGIC       0x3153464a<br/>
   MINIX_SUPER_MAGIC     0x137F /* orig. minix */<br/>
   MINIX_SUPER_MAGIC2    0x138F /* 30 char minix */<br/>
   MINIX2_SUPER_MAGIC    0x2468 /* minix V2 */<br/>
   MINIX2_SUPER_MAGIC2   0x2478 /* minix V2, 30 char names */<br/>
   MSDOS_SUPER_MAGIC     0x4d44<br/>
   NCP_SUPER_MAGIC       0x564c<br/>
   NFS_SUPER_MAGIC       0x6969<br/>
   NTFS_SB_MAGIC         0x5346544e<br/>
   OPENPROM_SUPER_MAGIC  0x9fa1<br/>
   PROC_SUPER_MAGIC      0x9fa0<br/>
   QNX4_SUPER_MAGIC      0x002f<br/>
   REISERFS_SUPER_MAGIC  0x52654973<br/>
   ROMFS_MAGIC           0x7275<br/>
   SMB_SUPER_MAGIC       0x517B<br/>
   SYSV2_SUPER_MAGIC     0x012FF7B6<br/>
   SYSV4_SUPER_MAGIC     0x012FF7B5<br/>
   TMPFS_MAGIC           0x01021994<br/>
   UDF_SUPER_MAGIC       0x15013346<br/>
   UFS_MAGIC             0x00011954<br/>
   USBDEVICE_SUPER_MAGIC 0x9fa2<br/>
   VXFS_SUPER_MAGIC      0xa501FCF5<br/>
   XENIX_SUPER_MAGIC     0x012FF7B4<br/>
   XFS_SUPER_MAGIC       0x58465342<br/>
   _XIAFS_SUPER_MAGIC    0x012FD16D<br/>
<br/>
<div class="spacer">
</div>
Nobody knows what <i>f_fsid</i> is supposed to contain (but see below).<div class="spacer">
</div>
Fields that are undefined for a particular file system are set to 0. <b>fstatfs</b>() returns the same information about an open file referenced by descriptor <i>fd</i>.</div>
<div class="section">
<h1>RETURN VALUE</h1> On success, zero is returned. On error, -1 is returned, and <i>errno</i> is set appropriately.</div>
<div class="section">
<h1>ERRORS</h1><dl>
<dt>
<b>EACCES</b></dt>
<dd>
(<b>statfs</b>()) Search permission is denied for a component of the path prefix of <i>path</i>. (See also <b>path_resolution</b>(7).)</dd>
</dl>
<dl>
<dt>
<b>EBADF</b></dt>
<dd>
(<b>fstatfs</b>()) <i>fd</i> is not a valid open file descriptor.</dd>
</dl>
<dl>
<dt>
<b>EFAULT</b></dt>
<dd>
<i>buf</i> or <i>path</i> points to an invalid address.</dd>
</dl>
<dl>
<dt>
<b>EINTR</b></dt>
<dd>
This call was interrupted by a signal.</dd>
</dl>
<dl>
<dt>
<b>EIO</b></dt>
<dd>
An I/O error occurred while reading from the file system.</dd>
</dl>
<dl>
<dt>
<b>ELOOP</b></dt>
<dd>
(<b>statfs</b>()) Too many symbolic links were encountered in translating <i>path</i>.</dd>
</dl>
<dl>
<dt>
<b>ENAMETOOLONG</b></dt>
<dd>
(<b>statfs</b>()) <i>path</i> is too long.</dd>
</dl>
<dl>
<dt>
<b>ENOENT</b></dt>
<dd>
(<b>statfs</b>()) The file referred to by <i>path</i> does not exist.</dd>
</dl>
<dl>
<dt>
<b>ENOMEM</b></dt>
<dd>
Insufficient kernel memory was available.</dd>
</dl>
<dl>
<dt>
<b>ENOSYS</b></dt>
<dd>
The file system does not support this call.</dd>
</dl>
<dl>
<dt>
<b>ENOTDIR</b></dt>
<dd>
(<b>statfs</b>()) A component of the path prefix of <i>path</i> is not a directory.</dd>
</dl>
<dl>
<dt>
<b>EOVERFLOW</b></dt>
<dd>
Some values were too large to be represented in the returned struct.</dd>
</dl>
</div>
<div class="section">
<h1>CONFORMING TO</h1> Linux-specific. The Linux <b>statfs</b>() was inspired by the 4.4BSD one (but they do not use the same structure).</div>
<div class="section">
<h1>NOTES</h1> The original Linux <b>statfs</b>() and <b>fstatfs</b>() system calls were not designed with extremely large file sizes in mind. Subsequently, Linux 2.6 added new <b>statfs64</b>() and <b>fstatfs64</b>() system calls that employ a new structure, <i>statfs64</i>. The new structure contains the same fields as the original <i>statfs</i> structure, but the sizes of various fields are increased, to accommodate large file sizes. The glibc <b>statfs</b>() and <b>fstatfs</b>() wrapper functions transparently deal with the kernel differences.<div style="height: 1.00em;">
&#160;</div>
Some systems only have <i>&lt;sys/vfs.h&gt;</i>, other systems also have  <i>&lt;sys/statfs.h&gt;</i>, where the former includes the latter. So it seems including the former is the best choice.<div style="height: 1.00em;">
&#160;</div>
LSB has deprecated the library calls <b>statfs</b>() and <b>fstatfs</b>() and tells us to use <b>statvfs</b>(2) and <b>fstatvfs</b>(2) instead.<div class="subsection">
<h2>The f_fsid field</h2> Solaris, Irix and POSIX have a system call <b>statvfs</b>(2) that returns a <i>struct statvfs</i> (defined in <i>&lt;sys/statvfs.h&gt;</i>) containing an <i>unsigned long</i> <i>f_fsid</i>. Linux, SunOS, HP-UX, 4.4BSD have a system call <b>statfs</b>() that returns a <i>struct statfs</i> (defined in <i>&lt;sys/vfs.h&gt;</i>) containing a <i>fsid_t</i> <i>f_fsid</i>, where <i>fsid_t</i> is defined as <i>struct { int val[2]; }</i>. The same holds for FreeBSD, except that it uses the include file <i>&lt;sys/mount.h&gt;</i>.<div style="height: 1.00em;">
&#160;</div>
The general idea is that <i>f_fsid</i> contains some random stuff such that the pair (<i>f_fsid</i>,<i>ino</i>) uniquely determines a file. Some operating systems use (a variation on) the device number, or the device number combined with the file-system type. Several OSes restrict giving out the <i>f_fsid</i> field to the superuser only (and zero it for unprivileged users), because this field is used in the filehandle of the file system when NFS-exported, and giving it out is a security concern.<div class="spacer">
</div>
Under some operating systems the <i>fsid</i> can be used as second argument to the <b>sysfs</b>(2) system call.</div>
</div>
<div class="section">
<h1>SEE ALSO</h1> <b>stat</b>(2), <b>statvfs</b>(2), <b>path_resolution</b>(7)</div>
<div class="section">
<h1>COLOPHON</h1> This page is part of release 3.35 of the Linux <i>man-pages</i> project. A description of the project, and information about reporting bugs, can be found at http://man7.org/linux/man-pages/.</div>
<table class="foot">
<tr>
<td class="foot-date">
2010-11-21</td>
<td class="foot-os">
Linux</td>
</tr>
</table>
</div>
</body>
</html>

