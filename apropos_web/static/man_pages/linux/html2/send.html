<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
SEND(2)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
SEND(2)</td>
<td class="head-vol">
Linux Programmer's Manual</td>
<td class="head-rtitle">
SEND(2)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> send, sendto, sendmsg - send a message on a socket</div>
<div class="section">
<h1>SYNOPSIS</h1> <b>#include &lt;sys/types.h&gt;</b> <b>#include &lt;sys/socket.h&gt;</b><div style="height: 1.00em;">
&#160;</div>
<br/>
<b>ssize_t send(int </b><i>sockfd</i><b>, const void *</b><i>buf</i><b>, size_t </b><i>len</i><b>, int </b><i>flags</i><b>);</b><div class="spacer">
</div>
<br/>
<b>ssize_t sendto(int </b><i>sockfd</i><b>, const void *</b><i>buf</i><b>, size_t </b><i>len</i><b>, int </b><i>flags</i><b>,</b><br/>
<b>               const struct sockaddr *</b><i>dest_addr</i><b>, socklen_t </b><i>addrlen</i><b>);</b><div class="spacer">
</div>
<br/>
<b>ssize_t sendmsg(int </b><i>sockfd</i><b>, const struct msghdr *</b><i>msg</i><b>, int </b><i>flags</i><b>);</b><br/>
</div>
<div class="section">
<h1>DESCRIPTION</h1> The system calls <b>send</b>(), <b>sendto</b>(), and <b>sendmsg</b>() are used to transmit a message to another socket.<div class="spacer">
</div>
The <b>send</b>() call may be used only when the socket is in a <i>connected</i> state (so that the intended recipient is known). The only difference between <b>send</b>() and <b>write</b>(2) is the presence of <i>flags</i>. With a zero <i>flags</i> argument, <b>send</b>() is equivalent to <b>write</b>(2). Also, the following call<div style="height: 1.00em;">
&#160;</div>
<br/>
    send(sockfd, buf, len, flags);<div style="height: 1.00em;">
&#160;</div>
is equivalent to<div style="height: 1.00em;">
&#160;</div>
<br/>
    sendto(sockfd, buf, len, flags, NULL, 0);<div class="spacer">
</div>
The argument <i>sockfd</i> is the file descriptor of the sending socket.<div class="spacer">
</div>
If <b>sendto</b>() is used on a connection-mode (<b>SOCK_STREAM</b>, <b>SOCK_SEQPACKET</b>) socket, the arguments <i>dest_addr</i> and <i>addrlen</i> are ignored (and the error <b>EISCONN</b> may be returned when they are not NULL and 0), and the error <b>ENOTCONN</b> is returned when the socket was not actually connected. Otherwise, the address of the target is given by <i>dest_addr</i> with <i>addrlen</i> specifying its size. For <b>sendmsg</b>(), the address of the target is given by <i>msg.msg_name</i>, with <i>msg.msg_namelen</i> specifying its size.<div class="spacer">
</div>
For <b>send</b>() and <b>sendto</b>(), the message is found in <i>buf</i> and has length <i>len</i>. For <b>sendmsg</b>(), the message is pointed to by the elements of the array <i>msg.msg_iov</i>. The <b>sendmsg</b>() call also allows sending ancillary data (also known as control information).<div class="spacer">
</div>
If the message is too long to pass atomically through the underlying protocol, the error <b>EMSGSIZE</b> is returned, and the message is not transmitted.<div class="spacer">
</div>
No indication of failure to deliver is implicit in a <b>send</b>(). Locally detected errors are indicated by a return value of -1.<div class="spacer">
</div>
When the message does not fit into the send buffer of the socket, <b>send</b>() normally blocks, unless the socket has been placed in nonblocking I/O mode. In nonblocking mode it would fail with the error <b>EAGAIN</b> or <b>EWOULDBLOCK</b> in this case. The <b>select</b>(2) call may be used to determine when it is possible to send more data.<div class="spacer">
</div>
The <i>flags</i> argument is the bitwise OR of zero or more of the following flags.<dl>
<dt>
<b>MSG_CONFIRM</b> (Since Linux 2.3.15)</dt>
<dd>
Tell the link layer that forward progress happened: you got a successful reply from the other side. If the link layer doesn't get this it will regularly reprobe the neighbor (e.g., via a unicast ARP). Only valid on <b>SOCK_DGRAM</b> and <b>SOCK_RAW</b> sockets and currently only implemented for IPv4 and IPv6. See <b>arp</b>(7) for details.</dd>
</dl>
<dl>
<dt>
<b>MSG_DONTROUTE</b></dt>
<dd>
Don't use a gateway to send out the packet, only send to hosts on directly connected networks. This is usually used only by diagnostic or routing programs. This is only defined for protocol families that route; packet sockets don't.</dd>
</dl>
<dl>
<dt>
<b>MSG_DONTWAIT</b> (since Linux 2.2)</dt>
<dd>
Enables nonblocking operation; if the operation would block, <b>EAGAIN</b> or <b>EWOULDBLOCK</b> is returned (this can also be enabled using the <b>O_NONBLOCK</b> flag with the <b>F_SETFL</b> <b>fcntl</b>(2)).</dd>
</dl>
<dl>
<dt>
<b>MSG_EOR</b> (since Linux 2.2)</dt>
<dd>
Terminates a record (when this notion is supported, as for sockets of type <b>SOCK_SEQPACKET</b>).</dd>
</dl>
<dl>
<dt>
<b>MSG_MORE</b> (Since Linux 2.4.4)</dt>
<dd>
The caller has more data to send. This flag is used with TCP sockets to obtain the same effect as the <b>TCP_CORK</b> socket option (see <b>tcp</b>(7)), with the difference that this flag can be set on a per-call basis.<div style="height: 1.00em;">
&#160;</div>
Since Linux 2.6, this flag is also supported for UDP sockets, and informs the kernel to package all of the data sent in calls with this flag set into a single datagram which is only transmitted when a call is performed that does not specify this flag. (See also the <b>UDP_CORK</b> socket option described in <b>udp</b>(7).)</dd>
</dl>
<dl>
<dt>
<b>MSG_NOSIGNAL</b> (since Linux 2.2)</dt>
<dd>
Requests not to send <b>SIGPIPE</b> on errors on stream oriented sockets when the other end breaks the connection. The <b>EPIPE</b> error is still returned.</dd>
</dl>
<dl>
<dt>
<b>MSG_OOB</b></dt>
<dd>
Sends <i>out-of-band</i> data on sockets that support this notion (e.g., of type <b>SOCK_STREAM</b>); the underlying protocol must also support <i>out-of-band</i> data.</dd>
</dl>
<div class="spacer">
</div>
The definition of the <i>msghdr</i> structure follows. See <b>recv</b>(2) and below for an exact description of its fields.<br/>
<div class="spacer">
</div>
<br/>
struct msghdr {<br/>
    void         *msg_name;       /* optional address */<br/>
    socklen_t     msg_namelen;    /* size of address */<br/>
    struct iovec *msg_iov;        /* scatter/gather array */<br/>
    size_t        msg_iovlen;     /* # elements in msg_iov */<br/>
    void         *msg_control;    /* ancillary data, see below */<br/>
    size_t        msg_controllen; /* ancillary data buffer len */<br/>
    int           msg_flags;      /* flags on received message */<br/>
};<br/>
<br/>
<div class="spacer">
</div>
You may send control information using the <i>msg_control</i> and <i>msg_controllen</i> members. The maximum control buffer length the kernel can process is limited per socket by the value in <i>/proc/sys/net/core/optmem_max</i>; see <b>socket</b>(7).</div>
<div class="section">
<h1>RETURN VALUE</h1> On success, these calls return the number of characters sent. On error, -1 is returned, and <i>errno</i> is set appropriately.</div>
<div class="section">
<h1>ERRORS</h1> These are some standard errors generated by the socket layer. Additional errors may be generated and returned from the underlying protocol modules; see their respective manual pages.<dl>
<dt>
<b>EACCES</b></dt>
<dd>
(For UNIX domain sockets, which are identified by pathname) Write permission is denied on the destination socket file, or search permission is denied for one of the directories the path prefix. (See <b>path_resolution</b>(7).)</dd>
</dl>
<dl>
<dt>
<b>EAGAIN</b> or <b>EWOULDBLOCK</b></dt>
<dd>
The socket is marked nonblocking and the requested operation would block. POSIX.1-2001 allows either error to be returned for this case, and does not require these constants to have the same value, so a portable application should check for both possibilities.</dd>
</dl>
<dl>
<dt>
<b>EBADF</b></dt>
<dd>
An invalid descriptor was specified.</dd>
</dl>
<dl>
<dt>
<b>ECONNRESET</b></dt>
<dd>
Connection reset by peer.</dd>
</dl>
<dl>
<dt>
<b>EDESTADDRREQ</b></dt>
<dd>
The socket is not connection-mode, and no peer address is set.</dd>
</dl>
<dl>
<dt>
<b>EFAULT</b></dt>
<dd>
An invalid user space address was specified for an argument.</dd>
</dl>
<dl>
<dt>
<b>EINTR</b></dt>
<dd>
A signal occurred before any data was transmitted; see <b>signal</b>(7).</dd>
</dl>
<dl>
<dt>
<b>EINVAL</b></dt>
<dd>
Invalid argument passed.</dd>
</dl>
<dl>
<dt>
<b>EISCONN</b></dt>
<dd>
The connection-mode socket was connected already but a recipient was specified. (Now either this error is returned, or the recipient specification is ignored.)</dd>
</dl>
<dl>
<dt>
<b>EMSGSIZE</b></dt>
<dd>
The socket type requires that message be sent atomically, and the size of the message to be sent made this impossible.</dd>
</dl>
<dl>
<dt>
<b>ENOBUFS</b></dt>
<dd>
The output queue for a network interface was full. This generally indicates that the interface has stopped sending, but may be caused by transient congestion. (Normally, this does not occur in Linux. Packets are just silently dropped when a device queue overflows.)</dd>
</dl>
<dl>
<dt>
<b>ENOMEM</b></dt>
<dd>
No memory available.</dd>
</dl>
<dl>
<dt>
<b>ENOTCONN</b></dt>
<dd>
The socket is not connected, and no target has been given.</dd>
</dl>
<dl>
<dt>
<b>ENOTSOCK</b></dt>
<dd>
The argument <i>sockfd</i> is not a socket.</dd>
</dl>
<dl>
<dt>
<b>EOPNOTSUPP</b></dt>
<dd>
Some bit in the <i>flags</i> argument is inappropriate for the socket type.</dd>
</dl>
<dl>
<dt>
<b>EPIPE</b></dt>
<dd>
The local end has been shut down on a connection oriented socket. In this case the process will also receive a <b>SIGPIPE</b> unless <b>MSG_NOSIGNAL</b> is set.</dd>
</dl>
</div>
<div class="section">
<h1>CONFORMING TO</h1> 4.4BSD, SVr4, POSIX.1-2001. These function calls appeared in 4.2BSD.<div class="spacer">
</div>
POSIX.1-2001 only describes the <b>MSG_OOB</b> and <b>MSG_EOR</b> flags. POSIX.1-2008 adds a specification of <b>MSG_NOSIGNAL</b>. The <b>MSG_CONFIRM</b> flag is a Linux extension.</div>
<div class="section">
<h1>NOTES</h1> The prototypes given above follow the Single UNIX Specification, as glibc2 also does; the <i>flags</i> argument was  <i>int</i> in 4.x BSD, but <i>unsigned int</i> in libc4 and libc5; the <i>len</i> argument was  <i>int</i> in 4.x BSD and libc4, but <i>size_t</i> in libc5; the <i>addrlen</i> argument was  <i>int</i> in 4.x BSD and libc4 and libc5. See also <b>accept</b>(2).<div style="height: 1.00em;">
&#160;</div>
According to POSIX.1-2001, the <i>msg_controllen</i> field of the <i>msghdr</i> structure should be typed as <i>socklen_t</i>, but glibc currently types it as <i>size_t</i>.</div>
<div class="section">
<h1>BUGS</h1> Linux may return <b>EPIPE</b> instead of <b>ENOTCONN</b>.</div>
<div class="section">
<h1>EXAMPLE</h1> An example of the use of <b>sendto</b>() is shown in <b>getaddrinfo</b>(3).</div>
<div class="section">
<h1>SEE ALSO</h1> <b>fcntl</b>(2), <b>getsockopt</b>(2), <b>recv</b>(2), <b>select</b>(2), <b>sendfile</b>(2), <b>shutdown</b>(2), <b>socket</b>(2), <b>write</b>(2), <b>cmsg</b>(3), <b>ip</b>(7), <b>socket</b>(7), <b>tcp</b>(7), <b>udp</b>(7)</div>
<div class="section">
<h1>COLOPHON</h1> This page is part of release 3.35 of the Linux <i>man-pages</i> project. A description of the project, and information about reporting bugs, can be found at http://man7.org/linux/man-pages/.</div>
<table class="foot">
<tr>
<td class="foot-date">
2011-10-01</td>
<td class="foot-os">
Linux</td>
</tr>
</table>
</div>
</body>
</html>

