<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
PTHREAD_MUTEX_LOCK(3P)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
PTHREAD_MUTEX_LOCK(3P)</td>
<td class="head-vol">
POSIX Programmer's Manual</td>
<td class="head-rtitle">
PTHREAD_MUTEX_LOCK(3P)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>PROLOG</h1> This manual page is part of the POSIX Programmer's Manual. The Linux implementation of this interface may differ (consult the corresponding Linux manual page for details of Linux behavior), or the interface may not be implemented on Linux.</div>
<div class="section">
<h1>NAME</h1> pthread_mutex_lock, pthread_mutex_trylock, pthread_mutex_unlock - lock and unlock a mutex</div>
<div class="section">
<h1>SYNOPSIS</h1>  <b>#include &lt;pthread.h&gt;</b><div style="height: 0.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
int pthread_mutex_lock(pthread_mutex_t *<b></b><i>mutex</i><b></b><b>);</b><div style="height: 0.00em;">
&#160;</div>
int pthread_mutex_trylock(pthread_mutex_t *<b></b><i>mutex</i><b></b><b>);</b><div style="height: 0.00em;">
&#160;</div>
int pthread_mutex_unlock(pthread_mutex_t *<b></b><i>mutex</i><b></b><b>); </b><b></b>  <b></b><b></b><div style="height: 0.00em;">
&#160;</div>
<b></b></div>
<div class="section">
<h1>DESCRIPTION</h1> The mutex object referenced by  <i>mutex</i> shall be locked by calling  <i>pthread_mutex_lock</i>(). If the mutex is already locked, the calling thread shall block until the mutex becomes available. This operation shall return with the mutex object referenced by  <i>mutex</i> in the locked state with the calling thread as its owner.<div class="spacer">
</div>
If the mutex type is PTHREAD_MUTEX_NORMAL, deadlock detection shall not be provided. Attempting to relock the mutex causes deadlock. If a thread attempts to unlock a mutex that it has not locked or a mutex which is unlocked, undefined behavior results.<div class="spacer">
</div>
If the mutex type is PTHREAD_MUTEX_ERRORCHECK, then error checking shall be provided. If a thread attempts to relock a mutex that it has already locked, an error shall be returned. If a thread attempts to unlock a mutex that it has not locked or a mutex which is unlocked, an error shall be returned.<div class="spacer">
</div>
If the mutex type is PTHREAD_MUTEX_RECURSIVE, then the mutex shall maintain the concept of a lock count. When a thread successfully acquires a mutex for the first time, the lock count shall be set to one. Every time a thread relocks this mutex, the lock count shall be incremented by one. Each time the thread unlocks the mutex, the lock count shall be decremented by one. When the lock count reaches zero, the mutex shall become available for other threads to acquire. If a thread attempts to unlock a mutex that it has not locked or a mutex which is unlocked, an error shall be returned.<div class="spacer">
</div>
If the mutex type is PTHREAD_MUTEX_DEFAULT, attempting to recursively lock the mutex results in undefined behavior. Attempting to unlock the mutex if it was not locked by the calling thread results in undefined behavior. Attempting to unlock the mutex if it is not locked results in undefined behavior.<div class="spacer">
</div>
The <i>pthread_mutex_trylock</i>() function shall be equivalent to  <i>pthread_mutex_lock</i>(), except that if the mutex object referenced by  <i>mutex</i> is currently locked (by any thread, including the current thread), the call shall return immediately. If the mutex type is PTHREAD_MUTEX_RECURSIVE and the mutex is currently owned by the calling thread, the mutex lock count shall be incremented by one and the  <i>pthread_mutex_trylock</i>() function shall immediately return success.<div class="spacer">
</div>
The <i>pthread_mutex_unlock</i>() function shall release the mutex object referenced by  <i>mutex</i>.  The manner in which a mutex is released is dependent upon the mutex's type attribute. If there are threads blocked on the mutex object referenced by  <i>mutex</i> when  <i>pthread_mutex_unlock</i>() is called, resulting in the mutex becoming available, the scheduling policy shall determine which thread shall acquire the mutex.<div class="spacer">
</div>
(In the case of PTHREAD_MUTEX_RECURSIVE mutexes, the mutex shall become available when the count reaches zero and the calling thread no longer has any locks on this mutex.)<div class="spacer">
</div>
If a signal is delivered to a thread waiting for a mutex, upon return from the signal handler the thread shall resume waiting for the mutex as if it was not interrupted.</div>
<div class="section">
<h1>RETURN VALUE</h1> If successful, the  <i>pthread_mutex_lock</i>() and <i>pthread_mutex_unlock</i>() functions shall return zero; otherwise, an error number shall be returned to indicate the error.<div class="spacer">
</div>
The <i>pthread_mutex_trylock</i>() function shall return zero if a lock on the mutex object referenced by  <i>mutex</i> is acquired. Otherwise, an error number is returned to indicate the error.</div>
<div class="section">
<h1>ERRORS</h1> The  <i>pthread_mutex_lock</i>() and <i>pthread_mutex_trylock</i>() functions shall fail if:<dl>
<dt>
<b>EINVAL</b></dt>
<dd>
The <i>mutex</i> was created with the protocol attribute having the value PTHREAD_PRIO_PROTECT and the calling thread's priority is higher than the mutex's current priority ceiling.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<div class="spacer">
</div>
The <i>pthread_mutex_trylock</i>() function shall fail if:<dl>
<dt>
<b>EBUSY</b></dt>
<dd>
The <i>mutex</i> could not be acquired because it was already locked.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<div class="spacer">
</div>
The <i>pthread_mutex_lock</i>(), <i>pthread_mutex_trylock</i>(), and  <i>pthread_mutex_unlock</i>() functions may fail if:<dl>
<dt>
<b>EINVAL</b></dt>
<dd>
The value specified by <i>mutex</i> does not refer to an initialized mutex object.</dd>
</dl>
<dl>
<dt>
<b>EAGAIN</b></dt>
<dd>
The mutex could not be acquired because the maximum number of recursive locks for  <i>mutex</i> has been exceeded.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<div class="spacer">
</div>
The <i>pthread_mutex_lock</i>() function may fail if:<dl>
<dt>
<b>EDEADLK</b></dt>
<dd>
The current thread already owns the mutex.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<div class="spacer">
</div>
The <i>pthread_mutex_unlock</i>() function may fail if:<dl>
<dt>
<b>EPERM</b></dt>
<dd>
The current thread does not own the mutex.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<div class="spacer">
</div>
These functions shall not return an error code of [EINTR].<div class="spacer">
</div>
<i>The following sections are informative.</i></div>
<div class="section">
<h1>EXAMPLES</h1> None.</div>
<div class="section">
<h1>APPLICATION USAGE</h1> None.</div>
<div class="section">
<h1>RATIONALE</h1> Mutex objects are intended to serve as a low-level primitive from which other thread synchronization functions can be built. As such, the implementation of mutexes should be as efficient as possible, and this has ramifications on the features available at the interface.<div class="spacer">
</div>
The mutex functions and the particular default settings of the mutex attributes have been motivated by the desire to not preclude fast, inlined implementations of mutex locking and unlocking.<div class="spacer">
</div>
For example, deadlocking on a double-lock is explicitly allowed behavior in order to avoid requiring more overhead in the basic mechanism than is absolutely necessary. (More &quot;friendly&quot; mutexes that detect deadlock or that allow multiple locking by the same thread are easily constructed by the user via the other mechanisms provided. For example,  <i>pthread_self</i>() can be used to record mutex ownership.) Implementations might also choose to provide such extended features as options via special mutex attributes.<div class="spacer">
</div>
Since most attributes only need to be checked when a thread is going to be blocked, the use of attributes does not slow the (common) mutex-locking case.<div class="spacer">
</div>
Likewise, while being able to extract the thread ID of the owner of a mutex might be desirable, it would require storing the current thread ID when each mutex is locked, and this could incur unacceptable levels of overhead. Similar arguments apply to a  <i>mutex_tryunlock</i> operation.</div>
<div class="section">
<h1>FUTURE DIRECTIONS</h1> None.</div>
<div class="section">
<h1>SEE ALSO</h1>  <i>pthread_mutex_destroy</i>(), <i>pthread_mutex_timedlock</i>(), the Base Definitions volume of IEEE&#160;Std&#160;1003.1-2001,  <i>&lt;pthread.h&gt;</i></div>
<div class="section">
<h1>COPYRIGHT</h1> Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1, 2003 Edition, Standard for Information Technology -- Portable Operating System Interface (POSIX), The Open Group Base Specifications Issue 6, Copyright (C) 2001-2003 by the Institute of Electrical and Electronics Engineers, Inc and The Open Group. In the event of any discrepancy between this version and the original IEEE and The Open Group Standard, the original IEEE and The Open Group Standard is the referee document. The original Standard can be obtained online at http://www.opengroup.org/unix/online.html .</div>
<table class="foot">
<tr>
<td class="foot-date">
2003</td>
<td class="foot-os">
IEEE/The Open Group</td>
</tr>
</table>
</div>
</body>
</html>

