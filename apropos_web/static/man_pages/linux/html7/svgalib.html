<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
svgalib(7)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
svgalib(7)</td>
<td class="head-vol">
Svgalib User Manual</td>
<td class="head-rtitle">
svgalib(7)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> svgalib - a low level graphics library for linux</div>
<div class="section">
<h1>TABLE OF CONTENTS</h1> <b>0.</b> Introduction<div style="height: 0.00em;">
&#160;</div>
<b>1.</b> Installation<div style="height: 0.00em;">
&#160;</div>
<b>2.</b> How to use svgalib<div style="height: 0.00em;">
&#160;</div>
<b>3.</b> Description of svgalib functions<div style="height: 0.00em;">
&#160;</div>
<b>4.</b> Overview of supported SVGA chipsets and modes<div style="height: 0.00em;">
&#160;</div>
<b>5.</b> Detailed comments on certain device drivers<div style="height: 0.00em;">
&#160;</div>
<b>6.</b> Goals<div style="height: 0.00em;">
&#160;</div>
<b>7.</b> References (location of latest version, apps etc.)<div style="height: 0.00em;">
&#160;</div>
<b>8.</b> Known bugs<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>0. INTRODUCTION</h1> This is a low level graphics library for Linux, originally based on VGAlib 1.2 by Tommy Frandsen. VGAlib supported a number of standard VGA graphics modes, as well as Tseng ET4000 high resolution 256-color modes. As of now, support for many more chipsets has been added. See section <b>4 Overview of supported SVGA chipsets and modes</b><div style="height: 1.00em;">
&#160;</div>
It supports transparent virtual console switching, that is, you can switch consoles to and from text and graphics mode consoles using alt-[function key]. Also, svgalib corrects most of VGAlib's textmode corruption behaviour by catching <b>SIGSEGV</b>, <b>SIGFPE</b>, <b>SIGILL</b>, and other fatal signals and ensuring that a program is running in the currently visible virtual console before setting a graphics mode.<div style="height: 1.00em;">
&#160;</div>
Note right here that <b>SIGUSR1</b> and <b>SIGUSR2</b> are used to manage console switching internally in <b>svgalib</b>. You can not use them in your programs. If your program needs to use one of those signals, svgalib can be compiled to use other signals, by editing libvga.h<div style="height: 1.00em;">
&#160;</div>
This version includes code to hunt for a free virtual console on its own in case you are not starting the program from one (but instead over a network or modem login, from within <b>screen</b>(1) or an <b>xterm</b>(1)). Provided there is a free console, this succeeds if you are root or if the svgalib calling user own the current console. This is to avoid people not using the console being able to fiddle with it. On graceful exit the program returns to the console from which it was started. Otherwise it remains in text mode at the VC which svgalib allocated to allow you to see any error messages. In any case, any I/O the svgalib makes in text mode (after calling <b>vga_init</b>(3)) will also take place at this new console.<div style="height: 1.00em;">
&#160;</div>
Alas, some games misuse their suid root privilege and run as full root process. svgalib cannot detect this and allows Joe Blow User to open a new VC on the console. If this annoys you, <b>ROOT_VC_SHORTCUT</b> in <i>Makefile.cfg</i> allows you to disable allocating a new VC for root (except when he owns the current console) when you compile svgalib. This is the default.<div style="height: 1.00em;">
&#160;</div>
When the library is used by a program at run-time, first the chipset is detected and the appropriate driver is used. This means that a graphics program will work on any card that is supported by svgalib, if the mode it uses is supported by the chipset driver for that card. The library is upwardly compatible with VGAlib.<div style="height: 1.00em;">
&#160;</div>
The set of drawing functions provided by svgalib itself is limited (unchanged from VGAlib) and unoptimized; you can however use <b>vga_setpage</b>(3) and <b>vga_getgraphmem</b>(3) (which points to the 64K VGA framebuffer) in a program or graphics library. A fast external framebuffer graphics library for linear and banked 1, 2, 3 and 4 bytes per pixel modes is included (it also indirectly supports planar VGA modes). It is documented in <b>vgagl</b>(7).<div style="height: 1.00em;">
&#160;</div>
One obvious application of the library is a picture viewer. Several are available, along with animation viewers. See the <b>7. References</b> at the end of this document.<div style="height: 1.00em;">
&#160;</div>
I have added a simple VGA textmode font restoration utility (<b>restorefont</b>(1)) which may help if you suffer from XFree86 textmode font corruption. It can also be used to change the textmode font. It comes with some other textmode utilities: <b>restoretextmode</b>(1) (which saves/restores textmode registers), <b>restorepalette</b>(1), and the script <b>textmode</b>(1). If you run the <b>savetextmode</b>(1) script to save textmode information to <i>/tmp</i>, you'll be able to restore textmode by running the <b>textmode</b>(1) script.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>1. INSTALLATION</h1> Installation is easy in general but there are many options and things you should keep in mind. This document however assumes that <b>svgalib</b> is already installed.<div style="height: 1.00em;">
&#160;</div>
If you need information on installation see <i>0-INSTALL</i> which comes with the svgalib distribution.<div style="height: 1.00em;">
&#160;</div>
However, even after installation of the library you might need to configure svgalib using the file <i>/etc/vga/libvga.config</i>. Checkout section <b>4 Overview of supported SVGA chipsets and modes</b> and <b>libvga.config</b>(5) for information.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>2. HOW TO USE SVGALIB</h1> For basic svgalib usage (no mouse, no raw keyboard) add <b>#include &lt;vga.h&gt;</b> at the beginning your program. Use <b>vga_init</b>(3) as your first <b>svgalib</b> call. This will give up root privileges right after initialization, making setuid-root binaries relatively safe.<div style="height: 1.00em;">
&#160;</div>
The function <b>vga_getdefaultmode</b>(3) checks the environment variable <b>SVGALIB_DEFAULT_MODE</b> for a default mode, and returns the corresponding mode number. The environment string can either be a mode number or a mode name as in (<b>G640x480x2</b>, <b>G640x480x16</b>, <b>G640x480x256 </b>,<b><div class="spacer">
</div>
</b><b>G640x480x32K</b>, <b>G640x480x64K</b>, <b>G640x480x16M</b>). As an example, to set the default graphics mode to 640x480, 256 colors, use:<div style="height: 1.00em;">
&#160;</div>
<b>export SVGALIB_DEFAULT_MODE=G640x480x256</b><div style="height: 1.00em;">
&#160;</div>
on the <b>bash(1)</b> command line. If a program needs just a linear VGA/SVGA resolution (as required by <b>vgagl</b>(7)), only modes where <b>bytesperpixel</b> in the <b>vga_modeinfo</b> structure returned by <b>vga_getmodeinfo</b>(3) is greater or equal to 1 should be accepted (this is 0 for tweaked planar 256-color VGA modes).<div style="height: 1.00em;">
&#160;</div>
Use <b>vga_setmode(</b><i>graphicsmode</i><b>)</b> to set a graphics mode. Use <b>vga_setmode(TEXT)</b> to restore textmode before program exit.<div style="height: 1.00em;">
&#160;</div>
Programs that use svgalib must <b>#include&lt;vga.h&gt;</b>; if they also use the external graphics library <b>vgagl</b>(7), you must also <b>#include&lt;vgagl.h&gt;</b>. Linking must be done with <b>-lvga</b> (and <b>-lvgagl</b> before <b>-lvga</b>, if <b>vgagl</b>(7) is used). You can save binary space by removing the unused chipset drivers in <i>Makefile.cfg</i> if you only use specific chipsets. However this reduces the flexibility of svgalib and has a significant effect only when you use the static libraries. You should better use the shared libraries and these will load only the really used parts anyway.<div style="height: 1.00em;">
&#160;</div>
Functions in the <b>vgagl</b>(7) library have the prefix <b>gl_</b>. Please see <b>vgagl</b>(7) for details.<div style="height: 1.00em;">
&#160;</div>
There are demos with sources available which will also help to get you started, in recommended order of interest: <b>vgatest</b>(6), <b>keytest</b>(6), <b>mousetest</b>(6), <b>eventtest</b>(6), <b>forktest</b>(6), <b>bg_test</b>(6), <b>scrolltest</b>(6), <b>speedtest</b>(6), <b>fun</b>(6), <b>spin</b>(6), <b>testlinear</b>(6), <b>lineart</b>(6), <b>testgl</b>(6), <b>accel</b>(6), <b>testaccel</b>(6), <b>plane</b>(6), and  <b>wrapdemo</b>(6).<div style="height: 1.00em;">
&#160;</div>
Debugging your programs will turn out to be rather difficult, because the svgalib application can not restore textmode when it returns to the debugger.<div style="height: 1.00em;">
&#160;</div>
Happy are the users with a serial terminal, X-station, or another way to log into the machine from network. These can use<div style="height: 1.00em;">
&#160;</div>
<b>textmode &lt;/dev/tty</b><i>N</i><div style="height: 1.00em;">
&#160;</div>
on the console where the program runs and continue.<div style="height: 1.00em;">
&#160;</div>
However, the <b>vga_flip</b>(3) function allows you to switch to textmode by entering a call to it blindly into your debugger when your program stops in graphics mode. <b>vga_flip</b>(3) is not very robust though. You shall not call it when svgalib is not yet initialized or in textmode.<div style="height: 1.00em;">
&#160;</div>
Before continuing your program, you must then call <b>vga_flip</b>(3) again to return to graphics mode. If the program will not make any screen accesses or svgalib calls before it returns to the debugger, you can omit that, of course.<div style="height: 1.00em;">
&#160;</div>
This will only work if your program and the debugger run in the same virtual linux console.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>3. DESCRIPTION OF SVGALIB FUNCTIONS</h1> Each function has its own section 3 manual page. For a list of <b>vgagl</b> functions see <b>vgagl</b>(7).<div style="height: 1.00em;">
&#160;</div>
<div class="subsection">
<h2>Initialization</h2><dl>
<dt>
<b>vga_init</b>(3)</dt>
<dd>
- initialize svgalib library.</dd>
</dl>
<dl>
<dt>
<b>vga_disabledriverreport</b>(3)</dt>
<dd>
- makes svgalib not emit any startup messages.</dd>
</dl>
<dl>
<dt>
<b>vga_claimvideomemory</b>(3)</dt>
<dd>
- declare the amount of video memory used.</dd>
</dl>
<dl>
<dt>
<b>vga_safety_fork</b>(3)</dt>
<dd>
- start a parallel process to restore the console at a crash.</dd>
</dl>
<dl>
<dt>
<b>vga_setchipset</b>(3)</dt>
<dd>
- force chipset.</dd>
</dl>
<dl>
<dt>
<b>vga_setchipsetandfeatures</b>(3)</dt>
<dd>
- force chipset and optional parameters.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
</div>
<div class="subsection">
<h2>Inquire hardware configuration</h2><dl>
<dt>
<b>vga_getmousetype</b>(3)</dt>
<dd>
- returns the mouse type configured.</dd>
</dl>
<dl>
<dt>
<b>vga_getcurrentchipset</b>(3)</dt>
<dd>
- returns the current SVGA chipset.</dd>
</dl>
<dl>
<dt>
<b>vga_getmonitortype</b>(3)</dt>
<dd>
- returns the monitor type configured.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
</div>
<div class="subsection">
<h2>Setting video modes</h2><dl>
<dt>
<b>vga_setmode</b>(3)</dt>
<dd>
- sets a video mode.</dd>
</dl>
<dl>
<dt>
<b>vga_setdisplaystart</b>(3)</dt>
<dd>
- set the display start address.</dd>
</dl>
<dl>
<dt>
<b>vga_setlogicalwidth</b>(3)</dt>
<dd>
- set the logical scanline width.</dd>
</dl>
<dl>
<dt>
<b>vga_setlinearaddressing</b>(3)</dt>
<dd>
- switch to linear addressing mode.</dd>
</dl>
<dl>
<dt>
<b>vga_setmodeX</b>(3)</dt>
<dd>
- try to set Mode X-like memory organization .</dd>
</dl>
<dl>
<dt>
<b>vga_ext_set</b>(3)</dt>
<dd>
- set and query several extended features.</dd>
</dl>
<dl>
<dt>
<b>vga_screenoff</b>(3), <b>vga_screenon</b>(3)</dt>
<dd>
- turn generation of the video signal on or off.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
</div>
<div class="subsection">
<h2>Get video mode information</h2><dl>
<dt>
<b>vga_getxdim</b>(3), <b>vga_getydim</b>(3), <b>vga_getcolors</b>(3)</dt>
<dd>
- return the current screen resolution.</dd>
</dl>
<dl>
<dt>
<b>vga_white</b>(3)</dt>
<dd>
- return the color white in the current screen resolution.</dd>
</dl>
<dl>
<dt>
<b>vga_getcurrentmode</b>(3)</dt>
<dd>
- returns the current video mode.</dd>
</dl>
<dl>
<dt>
<b>vga_hasmode</b>(3)</dt>
<dd>
- returns if a video mode is supported.</dd>
</dl>
<dl>
<dt>
<b>vga_getmodeinfo</b>(3)</dt>
<dd>
- returns pointer to mode information structure for a mode.</dd>
</dl>
<dl>
<dt>
<b>vga_getdefaultmode</b>(3)</dt>
<dd>
- returns the default graphics mode number.</dd>
</dl>
<dl>
<dt>
<b>vga_lastmodenumber</b>(3)</dt>
<dd>
- returns the last video mode number.</dd>
</dl>
<dl>
<dt>
<b>vga_getmodename</b>(3)</dt>
<dd>
- return a name for the given video mode.</dd>
</dl>
<dl>
<dt>
<b>vga_getmodenumber</b>(3)</dt>
<dd>
- return a number for the given video mode.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
</div>
<div class="subsection">
<h2>Drawing primitives</h2><dl>
<dt>
<b>vga_clear</b>(3)</dt>
<dd>
- clear the screen.</dd>
</dl>
<dl>
<dt>
<b>vga_setcolor</b>(3)</dt>
<dd>
- set the current color.</dd>
</dl>
<dl>
<dt>
<b>vga_setrgbcolor</b>(3)</dt>
<dd>
- set the current color.</dd>
</dl>
<dl>
<dt>
<b>vga_setegacolor</b>(3)</dt>
<dd>
- set the current color.</dd>
</dl>
<dl>
<dt>
<b>vga_drawpixel</b>(3)</dt>
<dd>
- draw a pixel on the screen.</dd>
</dl>
<dl>
<dt>
<b>vga_drawscanline</b>(3)</dt>
<dd>
- draw a horizontal line of pixels.</dd>
</dl>
<dl>
<dt>
<b>vga_drawscansegment</b>(3)</dt>
<dd>
- draw a horizontal line of pixels.</dd>
</dl>
<dl>
<dt>
<b>vga_drawline</b>(3)</dt>
<dd>
- draw a line on the screen.</dd>
</dl>
<dl>
<dt>
<b>vga_getpixel</b>(3)</dt>
<dd>
- get a pixels value from the screen.</dd>
</dl>
<dl>
<dt>
<b>vga_getscansegment</b>(3)</dt>
<dd>
- get a list of consecutive pixel values.</dd>
</dl>
<dl>
<dt>
<b>vga_waitretrace</b>(3)</dt>
<dd>
- wait for vertical retrace.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
</div>
<div class="subsection">
<h2>Basic (non raw) keyboard I/O</h2><dl>
<dt>
<b>vga_getch</b>(3)</dt>
<dd>
- wait for a key.</dd>
</dl>
<dl>
<dt>
<b>vga_getkey</b>(3)</dt>
<dd>
- read a character from the keyboard without waiting.</dd>
</dl>
<dl>
<dt>
<b>vga_waitevent</b>(3)</dt>
<dd>
- wait for various I/O events.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
</div>
<div class="subsection">
<h2>Direct VGA memory access</h2><dl>
<dt>
<b>vga_setpage</b>(3)</dt>
<dd>
- set the 64K SVGA page number.</dd>
</dl>
<dl>
<dt>
<b>vga_setreadpage</b>(3)</dt>
<dd>
- set the 64K SVGA page number.</dd>
</dl>
<dl>
<dt>
<b>vga_setwritepage</b>(3)</dt>
<dd>
- set the 64K SVGA page number.</dd>
</dl>
<dl>
<dt>
<b>vga_getgraphmem</b>(3)</dt>
<dd>
- returns the address of the VGA memory.</dd>
</dl>
<dl>
<dt>
<b>vga_copytoplanar256</b>(3)</dt>
<dd>
- copy linear pixmap into Mode X video memory.</dd>
</dl>
<dl>
<dt>
<b>vga_copytoplanar16</b>(3)</dt>
<dd>
- copy linear pixmap into VGA 16 color mode video memory.</dd>
</dl>
<dl>
<dt>
<b>vga_copytoplane</b>(3)</dt>
<dd>
- copy linear pixmap to some planes of VGA 16 color mode video memory.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
</div>
<div class="subsection">
<h2>Manage color lookup tables</h2><dl>
<dt>
<b>vga_setpalette</b>(3)</dt>
<dd>
- set a color in the color lookup table.</dd>
</dl>
<dl>
<dt>
<b>vga_getpalette</b>(3)</dt>
<dd>
- get a color in the color lookup table.</dd>
</dl>
<dl>
<dt>
<b>vga_setpalvec</b>(3)</dt>
<dd>
- sets colors in the color lookup table.</dd>
</dl>
<dl>
<dt>
<b>vga_getpalvec</b>(3)</dt>
<dd>
- gets colors from the color lookup table.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
</div>
<div class="subsection">
<h2>Mouse handling</h2><dl>
<dt>
<b>vga_setmousesupport</b>(3)</dt>
<dd>
- enable mouse support.</dd>
</dl>
<dl>
<dt>
<b>mouse_init</b>(3), <b>mouse_init_return_fd</b>(3)</dt>
<dd>
- specifically initialize a mouse.</dd>
</dl>
<dl>
<dt>
<b>mouse_close</b>(3)</dt>
<dd>
- explicitly close a mouse.</dd>
</dl>
<dl>
<dt>
<b>mouse_update</b>(3)</dt>
<dd>
- updates the mouse state.</dd>
</dl>
<dl>
<dt>
<b>mouse_waitforupdate</b>(3)</dt>
<dd>
- wait for an mouse update.</dd>
</dl>
<dl>
<dt>
<b>mouse_setscale</b>(3)</dt>
<dd>
- sets a mouse scale factor.</dd>
</dl>
<dl>
<dt>
<b>mouse_setwrap</b>(3)</dt>
<dd>
- set what happens at the mouse boundaries.</dd>
</dl>
<dl>
<dt>
<b>mouse_setxrange</b>(3), <b>mouse_setyrange</b>(3)</dt>
<dd>
- define the boundaries for the mouse cursor.</dd>
</dl>
<dl>
<dt>
<b>mouse_getx</b>(3), <b>mouse_gety</b>(3), <b>mouse_getbutton</b>(3)</dt>
<dd>
- query the mouse state.</dd>
</dl>
<dl>
<dt>
<b>mouse_setposition</b>(3)</dt>
<dd>
- set the current mouse position.</dd>
</dl>
<dl>
<dt>
<b>mouse_getposition_6d</b>(3), <b>mouse_setposition_6d</b>(3), <b>mouse_setrange_6d</b>(3)</dt>
<dd>
- provide an interface to 3d mice.</dd>
</dl>
<dl>
<dt>
<b>mouse_seteventhandler</b>(3), <b>mouse_setdefaulteventhandler</b>(3)</dt>
<dd>
- set a mouse event handler.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
</div>
<div class="subsection">
<h2>Raw keyboard handling</h2><dl>
<dt>
<b>keyboard_init</b>(3), <b>keyboard_init_return_fd</b>(3)</dt>
<dd>
- initialize the keyboard to raw mode.</dd>
</dl>
<dl>
<dt>
<b>keyboard_close</b>(3)</dt>
<dd>
- return the keyboard to normal operation from raw mode.</dd>
</dl>
<dl>
<dt>
<b>keyboard_update</b>(3), <b>keyboard_waitforupdate</b>(3)</dt>
<dd>
- process raw keyboard events.</dd>
</dl>
<dl>
<dt>
<b>keyboard_translatekeys</b>(3)</dt>
<dd>
- modify scancode mappings in raw keyboard mode.</dd>
</dl>
<dl>
<dt>
<b>keyboard_keypressed</b>(3)</dt>
<dd>
- check if a key is pressed when in raw keyboard mode.</dd>
</dl>
<dl>
<dt>
<b>keyboard_getstate</b>(3)</dt>
<dd>
- get a pointer to a buffer holding the state of all keys in raw keyboard mode.</dd>
</dl>
<dl>
<dt>
<b>keyboard_clearstate</b>(3)</dt>
<dd>
- reset the state of all keys when in raw keyboard mode.</dd>
</dl>
<dl>
<dt>
<b>keyboard_seteventhandler</b>(3), <b>keyboard_setdefaulteventhandler</b>(3)</dt>
<dd>
- define an event handler for keyboard events in raw mode.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
</div>
<div class="subsection">
<h2>Joystick handling</h2><dl>
<dt>
<b>joystick_init</b>(3)</dt>
<dd>
- initialize and calibrate joysticks.</dd>
</dl>
<dl>
<dt>
<b>joystick_close</b>(3)</dt>
<dd>
- close a joystick device.</dd>
</dl>
<dl>
<dt>
<b>joystick_update</b>(3)</dt>
<dd>
- query and process joystick state changes.</dd>
</dl>
<dl>
<dt>
<b>joystick_sethandler</b>(3), <b>joystick_setdefaulthandler</b>(3)</dt>
<dd>
- define own joystick even handler.</dd>
</dl>
<dl>
<dt>
<b>joystick_getnumaxes</b>(3), <b>joystick_getnumbuttons</b>(3)</dt>
<dd>
- query the capabilities of a joystick.</dd>
</dl>
<dl>
<dt>
<b>joystick_getaxis</b>(3), <b>joystick_getbutton</b>(3)</dt>
<dd>
- query the state of a joystick.</dd>
</dl>
<dl>
<dt>
<b>joystick_button1|2|3|4</b>(3), <b>joystick_getb1|2|3|4</b>(3), <b>joystick_x|y|z</b>(3), <b>joystick_getx|y|z</b>(3)</dt>
<dd>
- convenience macros to query the joystick position.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
</div>
<div class="subsection">
<h2>Accelerator interface (new style)</h2><dl>
<dt>
<b>vga_accel</b>(3)</dt>
<dd>
- calls the graphics accelerator.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
</div>
<div class="subsection">
<h2>Accelerator interface (old style)</h2><dl>
<dt>
<b>vga_bitblt</b>(3)</dt>
<dd>
- copy pixmap on screen using an accelerator.</dd>
</dl>
<dl>
<dt>
<b>vga_fillblt</b>(3)</dt>
<dd>
- fill rectangular area in video memory with a single color.</dd>
</dl>
<dl>
<dt>
<b>vga_hlinelistblt</b>(3)</dt>
<dd>
- draw horizontal scan lines.</dd>
</dl>
<dl>
<dt>
<b>vga_imageblt</b>(3)</dt>
<dd>
- copy a rectangular pixmap from system memory to video memory.</dd>
</dl>
<dl>
<dt>
<b>vga_blitwait</b>(3)</dt>
<dd>
- wait for any accelerator operation to finish.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
</div>
<div class="subsection">
<h2>Controlling VC switches</h2><dl>
<dt>
<b>vga_lockvc</b>(3)</dt>
<dd>
- disables virtual console switching for safety.</dd>
</dl>
<dl>
<dt>
<b>vga_unlockvc</b>(3)</dt>
<dd>
- re-enables virtual console switching.</dd>
</dl>
<dl>
<dt>
<b>vga_oktowrite</b>(3)</dt>
<dd>
- indicates whether the program has direct access to the SVGA.</dd>
</dl>
<dl>
<dt>
<b>vga_runinbackground</b>(3)</dt>
<dd>
- enable running of the program while there is no VGA access.</dd>
</dl>
<dl>
<dt>
<b>vga_runinbackground_version</b>(3)</dt>
<dd>
- returns the version of the current background support.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
</div>
<div class="subsection">
<h2>Debugging aids</h2><dl>
<dt>
<b>vga_dumpregs</b>(3)</dt>
<dd>
- dump the contents of the SVGA registers.</dd>
</dl>
<dl>
<dt>
<b>vga_gettextfont</b>(3), <b>vga_puttextfont</b>(3)</dt>
<dd>
- get/set the font used in text mode.</dd>
</dl>
<dl>
<dt>
<b>vga_gettextmoderegs</b>(3), <b>vga_settextmoderegs</b>(3)</dt>
<dd>
- get/set the vga state used in text mode.</dd>
</dl>
<dl>
<dt>
<b>vga_flip</b>(3)</dt>
<dd>
- toggle between text and graphics mode.</dd>
</dl>
<dl>
<dt>
<b>vga_setflipchar</b>(3)</dt>
<dd>
- set the character causing a vga_flip().</dd>
</dl>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
</div>
<div class="section">
<h1>4. OVERVIEW OF SUPPORTED SVGA CHIPSETS AND MODES</h1><div class="subsection">
<h2>VGA and compatibles</h2> 320x200x256, and the series of 16-color and non-standard planar 256 color modes supported by VGAlib, as well as 720x348x2.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>ALI2301</h2> Supports 640x480x256, 800x600x256, 1024x768x256 SVGA modes<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>AT3D (AT25)</h2> Also known as Promotion at25. Popular as the 2D part of a voodoo rush card. As of this writing there are a few known problems with this driver. Read below.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>ARK Logic ARK1000PV/2000PV</h2> Full support, limited RAMDAC support. Only ARK1000PV tested. Supports Clocks and Ramdac lines in config file.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>ATI SVGA (VGA Wonder and friends)</h2> This is no real driver. I do not support any new modes. However it saves additional card setup and thus allows use of the plain VGA modes even when you are using non standard text modes. It is possible to enforce use of this driver even on ATI Mach32 but not very useful.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>ATI Mach32</h2> The driver by Michael Weller supports all ATI BIOS-defined modes and more... It hits the best out of your card. Some modes may not have nice default timings but it uses the ATI's EEPROM for custom config or allows to specify modes in <b>libvga.config</b>(5). Some problems may occur with quite some third party cards (usually on board) Mach32 based controllers as they do not completely conform to the Mach32 data sheets. Check out <b>svgalib.mach32</b>(7) (and <b>libvga.config</b>(5)).<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>ATI Mach64 (rage)</h2> A driver for ATi Mach64 based cards with internal DAC.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>Chips and Technologies chipsets 65525, 65535, 65546, 65548, 65550, and 65554 (usually in laptops).</h2> This server was written using the SVGALIB patch from Sergio and Angelo Masci as a starting point. This version of the code resembled the XFree server code that was used up to XFree 3.1.2. As such it was incapable of programming the clocks, using linear addressing, Hi-Color, True-Color modes or the hardware acceleration. All of these features have since been added to the code. The 64200 and 64300 chips are unsupported, however these chips are very similar to the 6554x chips which are supported.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>Cirrus Logic GD542x/3x</h2> All the modes, including 256 color, 32K/64K color, 16M color (3 bytes per pixel) and 32-bit pixel 16M color modes (5434). Some bitblt functions are supported. The driver doesn't work with mode dumps, but uses a SVGA abstraction with mode timings like the X drivers.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>Genoa(?) GVGA6400 cards.</h2> Supported.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>Hercules Stingray 64/Video</h2> Is supported as an ARK2000PV<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>NV3 driver for the Riva128.</h2> This driver was written by Matan Ziv-Av and is derived from the XFree86 driver by David J. Mckay. It lacks 24bit modes (can the card do them at all?), acceleration support and pageflipping in threeDKit is broken.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>Oak Technologies OTI-037/67/77/87</h2> Driver by Christopher Wiles; includes 32K color modes for OTI-087.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>S3</h2> The driver is not complete, but should work on a number of cards/RAMDACs, and 640x480x256 should work on most card. The best support is for a 801/805 with AT&amp;T20C490-compatible RAMDAC, and S3-864 + SDAC.  All 256/32K/64K/16M works for them (within the bounds of video memory &amp; ramdac restrictions).<div style="height: 1.00em;">
&#160;</div>
The supported cards include S3 Virge and S3 Trio64 cards.<div style="height: 1.00em;">
&#160;</div>
None of the acceleration function is supported yet.<div style="height: 1.00em;">
&#160;</div>
The chip level code should work with the 964/868/968, but most likely the card they come on would use an unsupported ramdac/clock chip.  Support for these chips is slowly being added.<div style="height: 1.00em;">
&#160;</div>
Clocks and Ramdac lines in <b>libvga.config</b>(5) supported.<div style="height: 1.00em;">
&#160;</div>
The maximum pixel clock (in MHz) of the ramdac can be set using a <b>Dacspeed</b> line in the config file. A reasonable default is assumed if the <b>Dacspeed</b> line is omitted. <b>Clocks</b> should be the same as in XFree86. Supported ramdac IDs: <b>Sierra32K</b>, <b>SC15025</b>, <b>SDAC</b>, <b>GenDAC</b>, <b>ATT20C490</b>, <b>ATT20C498</b>, <b>IBMRGB52x</b>.<div style="height: 1.00em;">
&#160;</div>
Example:<div style="height: 0.00em;">
&#160;</div>
<b>Clocks 25.175 28.3 40 70 50 75 36 44.9 0 118 77 31.5 110 65 72 93.5</b><div style="height: 0.00em;">
&#160;</div>
<b>Ramdac att20c490</b><div style="height: 0.00em;">
&#160;</div>
<b>DacSpeed 85</b><div style="height: 1.00em;">
&#160;</div>
Also supported, at least in combination with the SC15025/26A ramdac, is the ICD 2061A clock chip. Since it cannot be autodetected you need to define it in the config file using a <b>Clockchip</b> line. As there is no way to read the current settings out of the 2061, you have the option to specify the frequency used when switching back to text mode as second argument in the <b>Clockchip</b> line.<div style="height: 1.00em;">
&#160;</div>
This is especially required if your text mode is an 132 column mode, since these modes use a clock from the clock chip, while 80 column modes use a fixed clock of 25 MHz. The text mode frequency defaults to 40 MHz, if omitted.<div style="height: 1.00em;">
&#160;</div>
Example:<div style="height: 0.00em;">
&#160;</div>
<b>ClockChip icd2061a 40.0</b><div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>Trident TVGA 8900C/9000 (and possibly also 8800CS/8900A/B) and also TVGA 9440</h2> Derived from tvgalib by Toomas Losin. TVGA 9440 support by ARK &lt;ark@lhq.com, root@ark.dyn.ml.or&gt;.<div style="height: 1.00em;">
&#160;</div>
Supports 640x480x256, 800x600x256, 1024x768x256 (interlaced and non-interlaced) Might be useful to add 16-color modes (for those equipped with a 512K TVGA9000) for the 8900 and 9000 cards.<div style="height: 1.00em;">
&#160;</div>
320x200x{32K, 64K, 16M}, 640x480x{256, 32K, 64K, 16M}, 800x600x{256, 32K, 64K, 16M}, 1024x768x{16, 256}, 800x600x{16, 256, 32K, 64K} modes are supported for the TVGA 9440.<div style="height: 1.00em;">
&#160;</div>
Autodetection can be forced with a:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<b>chipset TVGA</b> <i>memory flags</i></div>
<div style="height: 1.00em;">
&#160;</div>
line in the config file.<div style="height: 1.00em;">
&#160;</div>
<i>memory</i> is the amount of VGA memory in KB, <i>flags</i> is composed of three bits:<div style="margin-left: 5.00ex;">
<dl>
<dt>
<b>bit2 = false, bit1 = false</b></dt>
<dd>
force 8900.</dd>
</dl>
<dl>
<dt>
<b>bit2 = false, bit1 = true</b></dt>
<dd>
force 9440.</dd>
</dl>
<dl>
<dt>
<b>bit2 = true, bit1 = false</b></dt>
<dd>
force 9680.</dd>
</dl>
<dl>
<dt>
<b>bit0 = true</b></dt>
<dd>
force noninterlaced.</dd>
</dl>
<dl>
<dt>
<b>bit0 = false</b></dt>
<dd>
force interlaced which only matters on 8900's with at least 1M since there is no 512K interlaced mode on the 8900 or any of the other cards.</dd>
</dl>
</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>Tseng ET4000/ET4000W32(i/p)</h2> Derived from VGAlib; not the same register values. ET4000 register values are not compatible; see <b>svgalib.et4000</b>(7).<div style="height: 1.00em;">
&#160;</div>
Make sure the colors are right in hicolor mode; the vgatest program should draw the same color bars for 256 and hicolor modes (the DAC type is defined at compilation in <i>et4000.regs</i> or the dynamic registers file). ET4000/W32 based cards usually have an AT&amp;T or Sierra 15025/6 DAC. With recent W32p based cards, you might have some luck with the AT&amp;T DAC type. If the high resolution modes don't work, you can try dumping the registers in DOS using the program in the <i>et4000/</i> directory and putting them in a file (<i>/etc/vga/libvga.et4000</i> is parsed at runtime if <b>DYNAMIC</b> is defined in <i>Makefile.cfg</i> at compilation (this is default)).<div style="height: 1.00em;">
&#160;</div>
Supported modes are 640x480x256, 800x600x256, 1024x768x256, 640x480x32K, 800x600x32K, 640x480x16M, etc.<div style="height: 1.00em;">
&#160;</div>
Reports of ET4000/W32i/p functionality are welcome.<div style="height: 1.00em;">
&#160;</div>
There may be a problem with the way the hicolor DAC register is handled; dumped registers may use one of two timing methods, with the value written to the register for a particular DAC for a hicolor mode (in vgahico.c) being correct for just one of the these methods. As a consequence some dumped resolutions may work while others don't.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>Tseng ET6000</h2> Most modes of which the card is capable are supported.  The 8 15 16 24 and 32 bit modes are supported.<div style="height: 1.00em;">
&#160;</div>
The ET6000 has a built in DAC and there is no problem coming from that area. The ET6000 is capable of acceleration, but this as well as sprites are not yet implemented in the driver.<div style="height: 1.00em;">
&#160;</div>
The driver now uses modelines in libvga.config for user defined modes. It is sometimes useful to add a modeline for a resolution which does not display well.  For example, the G400x600 is too far to the right of the screen using standard modes.  This is corrected by including in <b>libvga.config</b> the line<div style="height: 1.00em;">
&#160;</div>
Modeline &quot;400x600@72&quot;  25.000 400  440  488  520   600  639  644  666<div style="height: 1.00em;">
&#160;</div>
More examples are given below.<div style="height: 1.00em;">
&#160;</div>
This driver was provided by Don Secrest.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>VESA</h2> Please read README.vesa and README.lrmi in doc subdirectory of the standard distribution.<div style="height: 1.00em;">
&#160;</div>
Go figure! I turned off autodetection in the release, as a broken bios will be called too, maybe crashing the machine. Enforce <b>VESA</b> mode by putting a <b>chipset VESA</b> in the end of your <i>libvga.config</i>(5).<div style="height: 1.00em;">
&#160;</div>
Note that it will leave protected mode and call the cards bios opening the door to many hazards.<div style="height: 1.00em;">
&#160;</div>
</div>
</div>
<div class="section">
<h1>5. DETAILED COMMENTS ON CERTAIN DEVICE DRIVERS</h1> This section contains detailed information by the authors on certain chipsets.<div style="height: 1.00em;">
&#160;</div>
<div class="subsection">
<h2>AT3D (AT25)</h2> Also known as Promotion at25. Popular as the 2D part of a voodoo rush card.<div style="height: 1.00em;">
&#160;</div>
I have written a driver for this chipset, based on the XF86 driver for this chipset.<div style="height: 1.00em;">
&#160;</div>
The programs that work with this driver include all the programs in the demos directory, zgv and dvisvga (tmview).<div style="height: 1.00em;">
&#160;</div>
I believe it should be easy to make it work on AT24, AT6422.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>ATI Mach32</h2> Please see <b>svgalib.mach32</b>(7).<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>ATI Mach64</h2> The rage.c driver works only on mach64 based cards with internal DAC. The driver might misdetect the base frequency the card uses, so if when setting any svgalib modes the screen blanks, or complains about out of bound frequencies, or the display is unsynced, then try adding the option <b>RageDoubleClock</b> to the config file.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>Chips and Technologies chipsets 65525, 65535, 65546, 65548, 65550, and 65554 (usually in laptops).</h2> Please see <b>svgalib.chips</b>(7).<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>Tseng ET4000/ET4000W32(i/p)</h2> Please see <b>svgalib.et4000</b>(7).<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>Tseng ET6000</h2> I have only 2 Mbytes of memory on my ET6000 card, so I am not able to get all possible modes running. I haven't even tried to do all of the modes which I am capable of doing, but I am confident that I can manage more modes when I have time. I have enough modes working to make the card useful, so I felt it was worth while to add the driver to svgalib now.<div style="height: 1.00em;">
&#160;</div>
Linear graphics is working on this card, both with and without BACKGROUND enabled, and vga_runinbackground works.<div style="height: 1.00em;">
&#160;</div>
I decided it was best to quit working on more modes and try to get acceleration and sprites working.<div style="height: 1.00em;">
&#160;</div>
My et6000 card is on a PCI bus.  The card will run on a vesa bus, but since I don't have one on my machine I couldn't develop vesa bus handling.  I quit if the bus is a vesa bus.<div style="height: 1.00em;">
&#160;</div>
I check for an et6000 card, which can be unequivocally identified. The et4000 driver does not properly identify et4000 cards. It thinks the et6000 card is an et4000, but can only run it in vga modes.<div style="height: 1.00em;">
&#160;</div>
I have found the following four modelines to be useful in <b>libvga.config</b> or in <b>~/.svgalibrc</b> for proper display of some modes.<div style="height: 1.00em;">
&#160;</div>
<div style="height: 0.00em;">
&#160;</div>
Modeline &quot;512x384@79&quot; 25.175 512 560 592 640  384 428 436 494<div style="height: 0.00em;">
&#160;</div>
Modeline &quot;400x300@72&quot; 25.000 400 456 472 520  300 319 332 350 DOUBLESCAN<div style="height: 0.00em;">
&#160;</div>
Modeline &quot;512x480@71&quot; 25.175 512 584 600 656  480 500 510 550<div style="height: 0.00em;">
&#160;</div>
Modeline &quot;400x600@72&quot; 25.000 400 440 488 520  600 639 644 666<div style="height: 1.00em;">
&#160;</div>
Don Secrest &lt;secrest@uiuc.edu&gt; Aug 21, 1999<div style="height: 1.00em;">
&#160;</div>
<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>Oak Technologies OTI-037/67/77/87</h2> First a few comments of me (Michael Weller &lt;eowmob@exp-math.uni-essen.de&gt;):<div style="height: 1.00em;">
&#160;</div>
As of this writing (1.2.8) fixes were made to the oak driver by Frodo Looijaard &lt;frodol@dds.nl&gt; to reenable OTI-067 support. It is unknown right now if they might have broken OTI-087 support. The author of the '87 support Christopher Wiles &lt;wileyc@moscow.com&gt; owns no longer an OTI-087 card and can thus no longer give optimal support to this driver. Thus you might be better off contacting me or Frodo for questions. If you are a knowledgeable OTI-087 user and experience problems you are welcome to provide fixes. No user of a OTI-087 is currently known to me, so if you are able to fix problems with the driver please do so (and contact me) as noone else can.<div style="height: 1.00em;">
&#160;</div>
Michael.<div style="height: 1.00em;">
&#160;</div>
Now back to the original Oak information:<div style="height: 1.00em;">
&#160;</div>
The original OTI driver, which supported the OTI-067/77 at 640x480x256, has been augmented with the following features:<div style="height: 1.00em;">
&#160;</div>
<dl>
<dt>
<b>1)</b></dt>
<dd>
Supported resolutions/colors have been expanded to 640x480x32K, 800x600x256/32K, 1024x768x256, and 1280x1024x16.</dd>
</dl>
<dl>
<dt>
<b>2)</b></dt>
<dd>
The OTI-087 (all variants) is now supported.  Video memory is correctly recognized.</dd>
</dl>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
The driver as it exists now is somewhat schizoid.  As the '87 incorporates a completely different set of extended registers, I found it necessary to split its routines from the others.  Further, I did not have access to either a '67 or a '77 for testing the new resolutions.  If using them causes your monitor/video card to fry, your dog to bite you, and so forth, I warned you.  The driver works on my '87, and that's all I guarantee.  Period.<div style="height: 1.00em;">
&#160;</div>
Heh.  Now, if someone wants to try them out ... let me know if they work.<div style="height: 1.00em;">
&#160;</div>
New from last release:<div style="height: 1.00em;">
&#160;</div>
32K modes now work for 640x480 and 800x600.  I found that the Sierra DAC information in VGADOC3.ZIP is, well, wrong.  But, then again, the information for the '87 was wrong also.<div style="height: 1.00em;">
&#160;</div>
64K modes <b>do not</b> work.  I can't even get Oak's BIOS to enter those modes.<div style="height: 1.00em;">
&#160;</div>
I have included a 1280x1024x16 mode, but I haven't tested it.  My monitor can't handle that resolution.  According to the documentation, with 2 megs the '87 should be able to do an interlaced 1280x1024x256 ... again, I couldn't get the BIOS to do the mode.  I haven't 2 megs anyway, so there it sits.<div style="height: 1.00em;">
&#160;</div>
I have included routines for entering and leaving linear mode.  They <b>should</b> work, but they don't.  It looks like a pointer to the frame buffer is not being passed to SVGALIB.  I've been fighting with this one for a month.  If anyone wants to play with this, let me know if it can be make to work.  I've got exams that I need to pass.<div style="height: 1.00em;">
&#160;</div>
Tidbit: I pulled the extended register info out of the video BIOS.  When the information thus obtained failed to work, I procured the OTI-087 data book.  It appears that Oak's video BIOS sets various modes incorrectly (e.g. setting 8-bit color as 4, wrong dot clock frequencies, etc.).  Sort of makes me wonder ...<div style="height: 1.00em;">
&#160;</div>
Christopher M. Wiles (a0017097@wsuaix.csc.wsu.edu)<div style="height: 0.00em;">
&#160;</div>
12 September 1994<div style="height: 1.00em;">
&#160;</div>
</div>
</div>
<div class="section">
<h1>6. GOALS</h1> I think the ability to use a VGA/SVGA graphics resolution in one virtual	console, and being able to switch to any other virtual console and back makes a fairly useful implementation of graphics modes in the Linux console.<div style="height: 1.00em;">
&#160;</div>
Programs that use <b>svgalib</b> must be setuid root. I don't know how desirable it is to have this changed; direct port access can hardly be done without. Root privileges can now be given up right after initialization. I noticed some unimplemented stuff in the kernel header files that may be useful, although doing all register I/O via the kernel would incur a significant context-switching overhead. An alternative might be to have a pseudo <i>/dev/vga</i> device that yields the required permissions when opened, the device being readable by programs in group vga.<div style="height: 1.00em;">
&#160;</div>
It is important that textmode is restored properly and reliably; it is fairly reliable at the moment, but fast console switching back and forth between two consoles running graphics can give problems. Wild virtual console switching also sometimes corrupts the contents of the textmode screen buffer (not the textmode registers or font). Also if a program crashes it may write into the area where the saved textmode registers are stored, causing textmode not be restored correctly. It would be a good idea to somehow store this information in a 'safe' area (say a kernel buffer). Note that the <b>vga_safety_fork</b>(3) thing has the same idea.<div style="height: 1.00em;">
&#160;</div>
Currently, programs that are in graphics mode are suspended while not in the current virtual console. Would it be a good idea to let them run in the background, virtualizing framebuffer actions (this should not be too hard for linear banked SVGA modes)? It would be nice to have, say, a raytracer with a real-time display run in the background (although just using a separate real-time viewing program is much more elegant).<div style="height: 1.00em;">
&#160;</div>
Anyone wanting to rewrite it all in a cleaner way (something with loadable kernel modules shouldn't hurt performance with linear framebuffer/vgagl type applications) is encouraged.<div style="height: 1.00em;">
&#160;</div>
Also, if anyone feels really strongly about a low-resource and truecolor supporting graphical window environment with cut-and-paste, I believe it would be surprisingly little work to come up with a simple but very useful client-server system with shmem, the most useful applications being fairly trivial to write (e.g. shell window,	bitmap viewer).	And many X apps would port trivially.<div style="height: 1.00em;">
&#160;</div>
This is old information, please be sure to read <b>svgalib.faq</b>(7) if you are interested in further goals.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>7. REFERENCES</h1> The latest version of svgalib can be found on <i>sunsite.unc.edu</i> in <i>/pub/Linux/libs/graphics</i> or <i>tsx-11.mit.edu</i> in <i>/pub/linux/sources/libs</i> as <i>svgalib-X.X.X.tar.gz</i>. As of this writing the latest version is <i>svgalib-1.4.1.tar.gz</i>. There are countless mirrors of these ftp servers in the world. Certainly a server close to you will carry it.<div style="height: 1.00em;">
&#160;</div>
The original VGAlib is on <i>tsx-11.mit.edu</i>, <i>pub/linux/sources/libs/vgalib12.tar.Z</i>. <i>tvgalib-1.0.tar.Z</i> is in the same directory.<div style="height: 1.00em;">
&#160;</div>
SLS has long been distributing an old version of VGAlib. Slackware keeps a fairly up-to-date version of svgalib, but it may be installed in different directories from what svgalib likes to do by default. The current svgalib install tries to remove most of this. It also removes <i>/usr/bin/setmclk</i> and <i>/usr/bin/convfont</i>, which is a security risk if setuid-root. Actually the recent makefiles try to do a really good job to cleanup the mess which some distributions make.<div style="height: 1.00em;">
&#160;</div>
If you want to recompile the a.out shared library, you will need the DLL 'tools' package (found on <i>tsx-11.mit.edu</i>, <i>GCC</i> dir). To make it work with recent ELF compiler's you actually need to hand patch it. You should probably not try to compile it. Compiling the ELF library is deadly simple.<div style="height: 1.00em;">
&#160;</div>
And here is a list of other references which is horribly outdated. There are many more svgalib applications as well as the directories might have changed. However, these will give you a start point and names to hunt for on CD's or in ftp archives.<div style="height: 1.00em;">
&#160;</div>
<div class="subsection">
<h2>Viewers (in /pub/Linux/apps/graphics/viewers on sunsite.unc.edu):</h2><dl>
<dt>
<b>spic</b></dt>
<dd>
Picture viewer; JPG/PPM/GIF; truecolor; scrolling.</dd>
</dl>
<dl>
<dt>
<b>zgv</b></dt>
<dd>
Full-featured viewer with nice file selector.</dd>
</dl>
<dl>
<dt>
<b>see-jpeg</b></dt>
<dd>
Shows picture as it is being built up.</dd>
</dl>
<dl>
<dt>
<b>mpeg-linux</b></dt>
<dd>
svgalib port of the Berkeley MPEG decoder (mpeg_play); it also includes an X binary.</dd>
</dl>
<dl>
<dt>
<b>flip</b></dt>
<dd>
FLI/FLC player (supports SVGA-resolution).</dd>
</dl>
</div>
<div class="subsection">
<h2>Games (in /pub/Linux/games on sunsite.unc.edu):</h2><dl>
<dt>
<b>bdash</b></dt>
<dd>
B*lderdash clone with sound.</dd>
</dl>
<dl>
<dt>
<b>sasteroids</b></dt>
<dd>
Very smooth arcade asteroids game.</dd>
</dl>
<dl>
<dt>
<b>yatzy</b></dt>
<dd>
Neat mouse controlled dice game.</dd>
</dl>
<dl>
<dt>
<b>vga_cardgames</b></dt>
<dd>
Collection of graphical card games.</dd>
</dl>
<dl>
<dt>
<b>vga_gamespack</b></dt>
<dd>
Connect4, othello and mines.</dd>
</dl>
<dl>
<dt>
<b>wt</b></dt>
<dd>
Free state-of-the-art Doom-like engine.</dd>
</dl>
<dl>
<dt>
<b>Maelstrom</b></dt>
<dd>
A very nice asteroids style game port from Mac.</dd>
</dl>
<dl>
<dt>
<b>Koules</b></dt>
<dd>
A game. (I've no idea what it looks like)</dd>
</dl>
</div>
<div class="subsection">
<h2>Docs</h2> In the vga directory of the <b>SIMTEL MSDOS</b> collection, there is a package called <i>vgadoc3</i> which is a collection of VGA/SVGA register information.<div style="height: 1.00em;">
&#160;</div>
The XFree86 driver sources distributed with the link-kit may be helpful.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="subsection">
<h2>Miscellaneous</h2> There's an alternative RAW-mode keyboard library by Russell Marks for use with <b>svgalib</b> on <i>sunsite.unc.edu</i>.<div style="height: 1.00em;">
&#160;</div>
<b>LIBGRX</b>, the extensive framebuffer library by Csaba Biegl distributed with <b>DJGPP</b>, has been ported to Linux. Contact Hartmut Schirmer (phc27@rz.uni-kiel.d400.de, subject prefix &quot;HARTMUT:&quot;). A more up-to-date port by Daniel Jackson (djackson@icomp.intel.com) is on <i>sunsite.unc.edu</i>.<div style="height: 1.00em;">
&#160;</div>
The vgalib ghostscript device driver sources can be found on <i>sunsite.unc.edu</i>, <i>/pub/Linux/apps/graphics</i>. Ghostscript patches from Slackware: <i>ftp.cdrom.com</i>, <i>/pub/linux/misc</i>. <b>gnuplot</b> patches are on <i>sunsite.unc.edu</i>.<div style="height: 1.00em;">
&#160;</div>
Mitch D'Souza has written font functions that work in 16 color modes and can use VGA textmode (codepage format) fonts; these can be found in his <b>g3fax</b> package in <i>sunsite.unc.edu</i>. These functions may go into a later version of <b>svgalib</b>.<div style="height: 1.00em;">
&#160;</div>
</div>
</div>
<div class="section">
<h1>8. KNOWN BUGS</h1> This section is most probably outdated, none of these problems are no longer reported.<div style="height: 1.00em;">
&#160;</div>
Using a 132 column textmode may cause graphics modes to fail. Try using something like 80x28.<div style="height: 1.00em;">
&#160;</div>
The console switching doesn't preserve some registers that may be used to draw in planar VGA modes.<div style="height: 1.00em;">
&#160;</div>
Wild console switching can cause the text screen to be corrupted, especially when switching between two graphics consoles.<div style="height: 1.00em;">
&#160;</div>
On ET4000, having run XFree86 may cause high resolution modes to fail (this is more XFree86's fault).<div style="height: 1.00em;">
&#160;</div>
The Trident probing routine in the XFree86 server may cause standard VGA modes to fail after exiting X on a Cirrus. Try putting a 'Chipset' line in your Xconfig to avoid the Trident probe, or use the link kit to build a server without the Trident driver. Saving and restoring the textmode registers with savetextmode/textmode (restoretextmode) should also work. [Note: svgalib now resets the particular extended register, but only if the Cirrus driver is used (i.e. the chipset is not forced to VGA)] [This is fixed in XFree86 v2.1]<div style="height: 1.00em;">
&#160;</div>
Some Paradise VGA cards may not work even in standard VGA modes. Can anyone confirm this?<div style="height: 1.00em;">
&#160;</div>
Piping data into a graphics program has problems. I am not sure why. A pity, since zcatting a 5Mb FLC file into flip on a 4Mb machine would be fun.<div style="height: 1.00em;">
&#160;</div>
The <b>tseng3.exe</b> DOS program include as source in the svgalib distribution doesn't recognize any modes on some ET4000 cards. Also ET4000 cards with a Acumos/Cirrus DAC may only work correctly in 64K color mode.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>FILES</h1> <i>/etc/vga/libvga.config</i><div style="height: 0.00em;">
&#160;</div>
<i>/etc/vga/libvga.et4000</i><div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>SEE ALSO</h1> <b>svgalib.et4000</b>(7), <b>svgalib.chips</b>(7), <b>svgalib.mach32</b>(7), <b>vgagl</b>(7), <b>libvga.config</b>(5), <b>3d</b>(6), <b>accel</b>(6), <b>bg_test</b>(6), <b>eventtest</b>(6), <b>forktest</b>(6), <b>fun</b>(6), <b>keytest</b>(6), <b>lineart</b>(5), <b>mousetest</b>(6), <b>joytest</b>(6), <b>mjoytest</b>(6), <b>scrolltest</b>(6), <b>speedtest</b>(6), <b>spin</b>(6), <b>testaccel</b>(6), <b>testgl</b>(6), <b>testlinear</b>(6), <b>vgatest</b>(6), <b>plane</b>(6), <b>wrapdemo</b>(6), <b>convfont</b>(1), <b>dumpreg</b>(1), <b>fix132x43</b>(1), <b>restorefont</b>(1), <b>restorepalette</b>(1), <b>restoretextmode</b>(1), <b>runx</b>(1), <b>savetextmode</b>(1), <b>setmclk</b>(1), <b>textmode</b>(1), <b>mach32info</b>(1).<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>AUTHOR</h1> There are many authors of svgalib. This page was edited by Michael Weller &lt;eowmob@exp-math.uni-essen.de&gt;. The original documentation and most of <b>svgalib</b> was done by Harm Hanemaayer &lt;H.Hanemaayer@inter.nl.net&gt; though.</div>
<table class="foot">
<tr>
<td class="foot-date">
16 December 1999</td>
<td class="foot-os">
Svgalib 1.4.1</td>
</tr>
</table>
</div>
</body>
</html>

