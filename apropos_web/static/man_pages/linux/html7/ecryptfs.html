<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
ecryptfs(7)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
ecryptfs(7)</td>
<td class="head-vol">
eCryptfs</td>
<td class="head-rtitle">
ecryptfs(7)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> eCryptfs - an enterprise-class cryptographic filesystem for linux<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>SYNOPSIS</h1> <b>mount -t ecryptfs [SRC DIR] [DST DIR] -o [OPTIONS]</b><div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>DESCRIPTION</h1> eCryptfs is a POSIX-compliant enterprise-class stacked cryptographic filesystem for Linux. It is derived from Erez Zadok's Cryptfs, implemented through the FiST framework for generating stacked filesystems. eCryptfs extends Cryptfs to provide advanced key management and policy features.  eCryptfs stores cryptographic metadata in the header of each file written, so that encrypted files can be copied between hosts; the file will be decryptable with the proper key, and there is no need to keep track of any additional information aside from what is already in the encrypted file itself. Think of eCryptfs as a sort of &quot;gnupgfs.&quot;<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>OPTIONS</h1> KERNEL OPTIONS<div style="height: 1.00em;">
&#160;</div>
	Parameters that apply to the eCryptfs kernel module.<div style="height: 1.00em;">
&#160;</div>
<dl>
<dt>
<b>ecryptfs_sig=(fekek_sig)</b></dt>
<dd>
Specify the signature of the mount wide authentication token. The authentication token must be in the kernel keyring before the mount is performed. ecryptfs-manager or the eCryptfs mount helper can be used to construct the authentication token and add it to the keyring prior to mounting.</dd>
</dl>
<dl>
<dt>
<b>ecryptfs_fnek_sig=(fnek_sig)</b></dt>
<dd>
Specify the signature of the mount wide authentication token used for filename crypto. The authentication must be in the kernel keyring before mounting.</dd>
</dl>
<dl>
<dt>
<b>ecryptfs_cipher=(cipher)</b></dt>
<dd>
Specify the symmetric cipher to be used on a per file basis</dd>
</dl>
<dl>
<dt>
<b>ecryptfs_key_bytes=(key_bytes)</b></dt>
<dd>
Specify the keysize to be used with the selected cipher. If the cipher only has one keysize the keysize does not need to be specified.</dd>
</dl>
<dl>
<dt>
<b>ecryptfs_passthrough</b></dt>
<dd>
Allows for non-eCryptfs files to be read and written from within an eCryptfs mount. This option is turned off by default.</dd>
</dl>
<dl>
<dt>
<b>no_sig_cache</b></dt>
<dd>
Do not check the mount key signature against the values in the user's ~/.ecryptfs/sig-cache.txt file. This is useful for such things as non-interactive setup scripts, so that the mount helper does not stop and prompt the user in the event that the key sig is not in the cache.</dd>
</dl>
<dl>
<dt>
<b>ecryptfs_encrypted_view</b></dt>
<dd>
This option provides a unified encrypted file format of the eCryptfs files in the lower mount point.  Currently, it is only useful if the lower mount point contains files with the metadata stored in the extended attribute.  Upon a file read in the upper mount point, the encrypted version of the file will be presented with the metadata in the file header instead of the xattr.  Files cannot be opened for writing when this option is enabled.</dd>
</dl>
<dl>
<dt>
<b>ecryptfs_xattr</b></dt>
<dd>
Store the metadata in the extended attribute of the lower files rather than the header region of the lower files.</dd>
</dl>
<dl>
<dt>
<b>verbose</b></dt>
<dd>
Log ecryptfs information to /var/log/messages.  Do not run eCryptfs in verbose-mode unless you are doing so for the sole purpose of development, since secret values will be written out to the system log in that case.</dd>
</dl>
<dl>
<dt>
<div style="height: 1.00em;">
&#160;</div>
MOUNT HELPER OPTIONS</dt>
<dd>
<div style="height: 1.00em;">
&#160;</div>
Parameters that apply to the eCryptfs mount helper.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<dl>
<dt>
<b>key=(keytype):[KEY MODULE OPTIONS]</b></dt>
<dd>
Specify the type of key to be used when mounting eCryptfs.</dd>
</dl>
<dl>
<dt>
<b>ecryptfs_enable_filename_crypto=(y/N)</b></dt>
<dd>
Specify whether filename encryption should be enabled. If not, the mount helper will not prompt the user for the filename encryption key signature.</dd>
</dl>
<dl>
<dt>
<b>verbosity=0/1</b></dt>
<dd>
If verbosity=1, the mount helper will ask you for missing values (default).  Otherwise, if verbosity=0, it will not ask for missing values and will fail if required values are omitted.</dd>
</dl>
<dl>
<dt>
<div style="height: 1.00em;">
&#160;</div>
KEY MODULE OPTIONS</dt>
<dd>
<div style="height: 1.00em;">
&#160;</div>
Parameters that apply to individual key modules have the alias for the key module in the prefix of the parameter name. Key modules are pluggable, and which key modules are available on any given system is dependent upon whatever happens to be installed in /usr/lib*/ecryptfs/. By default, this includes, at a minimum, &quot;passphrase&quot; and &quot;openssl.&quot;<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<dl>
<dt>
<b>passphrase_passwd=(passphrase)</b></dt>
<dd>
The actual password is passphrase. Since the password is visible to utilities (like ps under Unix) this form should only be used where security is not important.</dd>
</dl>
<dl>
<dt>
<b>passphrase_passwd_file=(filename)</b></dt>
<dd>
The password should be specified in a file with passwd=(passphrase). It is highly reccomended that the file be stored on a secure medium such as a personal usb key.</dd>
</dl>
<dl>
<dt>
<b>passphrase_passwd_fd=(file descriptor)</b></dt>
<dd>
The password is specified through the specified file descriptor.</dd>
</dl>
<dl>
<dt>
<b>passphrase_salt=(hex value)</b></dt>
<dd>
The salt should be specified as a 16 digit hex value.</dd>
</dl>
<dl>
<dt>
<b>openssl_keyfile=(filename)</b></dt>
<dd>
The filename should be the filename of a file containing an RSA SSL key.</dd>
</dl>
<dl>
<dt>
<b>openssl_passwd_file=(filename)</b></dt>
<dd>
The password should be specified in a file with openssl_passwd=(openssl-password). It is highly reccomended that the file be stored on a secure medium such as a personal usb key.</dd>
</dl>
<dl>
<dt>
<b>openssl_passwd_fd=(file descriptor)</b></dt>
<dd>
The password is specified through the specified file descriptor.</dd>
</dl>
<dl>
<dt>
<b>openssl_passwd=(password)</b></dt>
<dd>
The password can be specified on the command line. Since the password is visible in the process list, it is highly recommended to use this option only for testing purposes.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
</div>
<div class="section">
<h1>EXAMPLE</h1><div style="height: 1.00em;">
&#160;</div>
The following command will layover mount eCryptfs on /secret with a passphrase contained in a file stored on secure media mounted at /mnt/usb/.<div style="height: 1.00em;">
&#160;</div>
<b>mount -t ecryptfs -o key=passphrase:passphrase_passwd_file=/mnt/usb/file.txt /secret /secret</b><div style="height: 1.00em;">
&#160;</div>
<div class="spacer">
</div>
<div style="height: 1.00em;">
&#160;</div>
Where file.txt contains the contents  <b>&quot;passphrase_passwd=[passphrase]&quot;</b>.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>SEE ALSO</h1><dl>
<dt>
<b>mount</b>(8)</dt>
<dd>
<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<dl>
<dt>
<i>/usr/share/doc/ecryptfs-utils/ecryptfs-faq.html</i></dt>
<dd>
<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<dl>
<dt>
<i>http://launchpad.net/ecryptfs/</i></dt>
<dd>
<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
</div>
<div class="section">
<h1>NOTES</h1> Do not run eCryptfs in verbose-mode unless you are doing so for the sole purpose of development, since secret values will be written out to the system log in that case. Make certain that your eCryptfs mount covers all locations where your applications may write sensitive data. In addition, use dm-crypt to encrypt your swap space with a random key on boot, or see  <b>ecryptfs-setup-swap</b>(1).<div style="height: 1.00em;">
&#160;</div>
Passphrases have a maximum length of 64 characters.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>BUGS</h1> Please post bug reports to the eCryptfs bug tracker on Launchpad.net: https://bugs.launchpad.net/ecryptfs/+filebug.<div style="height: 1.00em;">
&#160;</div>
For kernel bugs, please follow the procedure detailed in Documentation/oops-tracing.txt to help us figure out what is happening.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>AUTHOR</h1> This manpage was (re-)written by Dustin Kirkland &lt;kirkland@ubuntu.com&gt; for Ubuntu systems (but may be used by others).  Permission is granted to copy, distribute and/or modify this document under the terms of the GNU General Public License, Version 2 or any later version published by the Free Software Foundation.<div style="height: 1.00em;">
&#160;</div>
On Debian systems, the complete text of the GNU General Public License can be found in /usr/share/common-licenses/GPL.</div>
<table class="foot">
<tr>
<td class="foot-date">
2009-03-24</td>
<td class="foot-os">
ecryptfs-utils</td>
</tr>
</table>
</div>
</body>
</html>

