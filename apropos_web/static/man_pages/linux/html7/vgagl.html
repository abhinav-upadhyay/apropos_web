<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
vgagl(7)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
vgagl(7)</td>
<td class="head-vol">
Svgalib User Manual</td>
<td class="head-rtitle">
vgagl(7)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> vgagl - a fast framebuffer-level graphics library based on svgalib</div>
<div class="section">
<h1>TABLE OF CONTENTS</h1> <b>0.</b> Introduction<div style="height: 0.00em;">
&#160;</div>
<b>1.</b> How to use vgagl<div style="height: 0.00em;">
&#160;</div>
<b>2.</b> Description of vgagl functions<div style="height: 0.00em;">
&#160;</div>
<b>3.</b> Macros defined in vgagl.h<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>0. INTRODUCTION</h1> This is a fast framebuffer-level graphics library for linear 1, 2, 3 and 4 byte-per-pixel modes (256-color, hicolor, truecolor). It uses a limited number of functions from svgalib (libvga) for low-level hardware communication (the library is included in the svgalib shared image).<div style="height: 1.00em;">
&#160;</div>
In particular, <b>svgalib</b>(7) maps the 64K VGA frame buffer window, and this library directly addresses the buffer. For SVGA modes that use more than 64K of screen memory, SVGA paging is required when writing to the physical screen; this is done automatically for most functions (at a certain cost).<div style="height: 1.00em;">
&#160;</div>
Alternatively, any number of virtual screens of any type in system memory can be used, which can then be copied to the physical screen. There is also support for 4 bytes per pixel framebuffers (and copying them to a 3 bytes per pixel context), and limited planar 256 color mode support (copyscreen, aligned putbox).<div style="height: 1.00em;">
&#160;</div>
The planar 256 color modes (available on all VGA cards) can now be used with a virtual screen, which is copied to the physical screen (with optional page-flipping).<div style="height: 1.00em;">
&#160;</div>
Bitmaps are raw, with one (or more) bytes per pixel (like pixmaps in X), stored in row-major order. They are usually manipulated with the getbox and putbox functions.<div style="height: 1.00em;">
&#160;</div>
<b>vgagl</b> does also make use of the graphic cards accelerator (if it is supported) in some situations.<div style="height: 1.00em;">
&#160;</div>
A graphics context is just a structure that holds the size of the associated graphics screen, how it is organized, clipping status etc. You can define a custom virtual (system memory) graphics context of any size with the setcontextvirtual function. All operations work on the current context.<div style="height: 1.00em;">
&#160;</div>
Any questions, bug-reports, additions, suggestions etc. are welcome.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>1. HOW TO USE VGAGL</h1> Programs that use <b>vgagl</b> must <b>#include &lt;vgagl.h&gt;</b>. Linking must be done with <b>-lvgagl -lvga</b>.<div style="height: 1.00em;">
&#160;</div>
Functions in the <b>vgagl</b> library have the prefix <b>gl_*</b>. To initialize <b>vgagl</b>, the graphics context must be set. Example:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<b>vga_setmode(G320x200x256);</b><div style="height: 0.00em;">
&#160;</div>
<b>gl_setcontextvga(G320x200x256);</b></div>
<div style="height: 1.00em;">
&#160;</div>
In this example, the context is set to the physical screen. The context can be saved (only the screen type, not the contents) into a variable, e.g.<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<b>GraphicsContext physicalscreen;</b><div style="height: 0.00em;">
&#160;</div>
<b>gl_getcontext(&amp;physicalscreen).</b></div>
<div style="height: 1.00em;">
&#160;</div>
To define a virtual screen in system memory, use <b>gl_setcontextvgavirtual</b>(3):<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<b>gl_setcontextvgavirtual(G320x200x256)</b></div>
<div style="height: 1.00em;">
&#160;</div>
which allocates space for a screen identical to 320x200x256 graphics mode, and makes this virtual screen the current graphics context.<div style="height: 1.00em;">
&#160;</div>
The virtual screen can now be copied to the physical screen as follows:<div style="height: 1.00em;">
&#160;</div>
<div style="margin-left: 5.00ex;">
<b>gl_copyscreen(&amp;physicalscreen);</b></div>
<div style="height: 1.00em;">
&#160;</div>
Note that with a virtual screen in system memory, it is possible to add fast X-Window support to a program, using MITSHM to copy the framebuffer to the screen window.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>2. DESCRIPTION OF VGAGL FUNCTIONS</h1><div class="subsection">
<h2>Context management</h2><dl>
<dt>
<b>gl_getcontext</b>(3), <b>currentcontext</b>(3)</dt>
<dd>
get the current graphics contents..</dd>
</dl>
<dl>
<dt>
<b>gl_setcontext</b>(3)</dt>
<dd>
set a previously saved context.</dd>
</dl>
<dl>
<dt>
<b>gl_setcontextvga</b>(3)</dt>
<dd>
set the context to the physical screen.</dd>
</dl>
<dl>
<dt>
<b>gl_setcontextvgavirtual</b>(3)</dt>
<dd>
set the context to a virtual mode.</dd>
</dl>
<dl>
<dt>
<b>gl_setcontextvirtual</b>(3)</dt>
<dd>
define a virtual context.</dd>
</dl>
<dl>
<dt>
<b>gl_allocatecontext</b>(3)</dt>
<dd>
allocate a graphics context.</dd>
</dl>
<dl>
<dt>
<b>gl_freecontext</b>(3)</dt>
<dd>
free a virtual screen.</dd>
</dl>
<dl>
<dt>
<b>gl_setcontextwidth</b>(3), <b>gl_setcontextheight</b>(3)</dt>
<dd>
set the dimension of a context.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
</div>
<div class="subsection">
<h2>Drawing primitives</h2><dl>
<dt>
<b>gl_clearscreen</b>(3)</dt>
<dd>
clear the screen.</dd>
</dl>
<dl>
<dt>
<b>gl_rgbcolor</b>(3)</dt>
<dd>
return pixel value corresponding to an rgb color.</dd>
</dl>
<dl>
<dt>
<b>gl_setpixel</b>(3), <b>gl_setpixelrgb</b>(3)</dt>
<dd>
draw a pixel.</dd>
</dl>
<dl>
<dt>
<b>gl_getpixel</b>(3)</dt>
<dd>
return the color of a pixel.</dd>
</dl>
<dl>
<dt>
<b>gl_getpixelrgb</b>(3)</dt>
<dd>
store color components of a pixel.</dd>
</dl>
<dl>
<dt>
<b>gl_hline</b>(3)</dt>
<dd>
draw a horizontal line.</dd>
</dl>
<dl>
<dt>
<b>gl_line</b>(3)</dt>
<dd>
draw a line.</dd>
</dl>
<dl>
<dt>
<b>gl_circle</b>(3)</dt>
<dd>
draw a circle.</dd>
</dl>
<dl>
<dt>
<b>gl_fillbox</b>(3)</dt>
<dd>
fill a rectangular area.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
</div>
<div class="subsection">
<h2>Copying of screen buffers and page flipping</h2><dl>
<dt>
<b>gl_copyscreen</b>(3)</dt>
<dd>
copy the screen contents of contexts.</dd>
</dl>
<dl>
<dt>
<b>gl_setscreenoffset</b>(3)</dt>
<dd>
set a memory offset for copyscreen.</dd>
</dl>
<dl>
<dt>
<b>gl_setdisplaystart</b>(3)</dt>
<dd>
set the start of the screen are displayed.</dd>
</dl>
<dl>
<dt>
<b>gl_enablepageflipping</b>(3)</dt>
<dd>
enables automatic page flipping.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
</div>
<div class="subsection">
<h2>Clipping</h2><dl>
<dt>
<b>gl_disableclipping</b>(3)</dt>
<dd>
disables clipping.</dd>
</dl>
<dl>
<dt>
<b>gl_enableclipping</b>(3)</dt>
<dd>
enables clipping.</dd>
</dl>
<dl>
<dt>
<b>gl_setclippingwindow</b>(3)</dt>
<dd>
set the clipping window.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
</div>
<div class="subsection">
<h2>Text drawing primitives</h2><dl>
<dt>
<b>gl_setfont</b>(3)</dt>
<dd>
set the text font to be used.</dd>
</dl>
<dl>
<dt>
<b>gl_setfontcolors</b>(3)</dt>
<dd>
set the font colors.</dd>
</dl>
<dl>
<dt>
<b>gl_expandfont</b>(3)</dt>
<dd>
expand a packed pixel font.</dd>
</dl>
<dl>
<dt>
<b>gl_colorfont</b>(3)</dt>
<dd>
change the color of a font.</dd>
</dl>
<dl>
<dt>
<b>gl_setwritemode</b>(3)</dt>
<dd>
set the font writemode flags.</dd>
</dl>
<dl>
<dt>
<b>gl_write</b>(3), <b>gl_writen</b>(3)</dt>
<dd>
write a text string.</dd>
</dl>
<dl>
<dt>
<b>gl_printf</b>(3)</dt>
<dd>
formatted output to the graphics screen.</dd>
</dl>
<dl>
<dt>
<b>gl_font8x8</b>(3)</dt>
<dd>
a packed 8x8 pixel font.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
</div>
<div class="subsection">
<h2>Pix- and Bitmap drawing</h2><dl>
<dt>
<b>gl_getbox</b>(3)</dt>
<dd>
copy a rectangular pixmap from the screen to a buffer.</dd>
</dl>
<dl>
<dt>
<b>gl_copybox</b>(3)</dt>
<dd>
copy a rectangular screen area.</dd>
</dl>
<dl>
<dt>
<b>gl_copyboxfromcontext</b>(3)</dt>
<dd>
copy rectangular area from another context.</dd>
</dl>
<dl>
<dt>
<b>gl_copyboxtocontext</b>(3)</dt>
<dd>
copy a rectangular area to another context.</dd>
</dl>
<dl>
<dt>
<b>gl_putbox</b>(3)</dt>
<dd>
copy a pixmap to a rectangular area.</dd>
</dl>
<dl>
<dt>
<b>gl_putboxpart</b>(3)</dt>
<dd>
copy a partial pixmap to a rectangular area.</dd>
</dl>
<dl>
<dt>
<b>gl_putboxmask</b>(3)</dt>
<dd>
copy a masked  pixmap to a rectangular area.</dd>
</dl>
<dl>
<dt>
<b>gl_putboxmaskcompiled</b>(3)</dt>
<dd>
copy a compiled masked pixmap to a rectangular area.</dd>
</dl>
<dl>
<dt>
<b>gl_compileboxmask</b>(3)</dt>
<dd>
compress a masked bitmap.</dd>
</dl>
<dl>
<dt>
<b>gl_compiledboxmasksize</b>(3)</dt>
<dd>
compute the size of a compiled masked box.</dd>
</dl>
<dl>
<dt>
<b>gl_scalebox</b>(3)</dt>
<dd>
scale a pixmap.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
</div>
<div class="subsection">
<h2>Palette handling</h2><dl>
<dt>
<b>gl_getpalettecolor</b>(3), <b>gl_getpalettecolors</b>(3), <b>gl_getpalette</b>(3)</dt>
<dd>
read the color palette.</dd>
</dl>
<dl>
<dt>
<b>gl_setpalettecolor</b>(3), <b>gl_setpalettecolors</b>(3), <b>gl_setpalette</b>(3)</dt>
<dd>
set the color palette.</dd>
</dl>
<dl>
<dt>
<b>gl_setrgbpalette</b>(3)</dt>
<dd>
set a 256-color RGB palette.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
</div>
<div class="subsection">
<h2>Triangle primitives from threeDkit</h2><dl>
<dt>
<b>gl_striangle</b>(3)</dt>
<dd>
draw a solid colored triangle.</dd>
</dl>
<dl>
<dt>
<b>gl_triangle</b>(3)</dt>
<dd>
draw a triangle with interpolated colors.</dd>
</dl>
<dl>
<dt>
<b>gl_swtriangle</b>(3)</dt>
<dd>
draw a solid pixmap mapped on a triangle.</dd>
</dl>
<dl>
<dt>
<b>gl_wtriangle</b>(3)</dt>
<dd>
draw a shadowed pixmap mapped on a triangle.</dd>
</dl>
<dl>
<dt>
<b>gl_trisetcolorlookup</b>(3), <b>gl_trigetcolorlookup</b>(3)</dt>
<dd>
manages a color lookup table for shadowing.</dd>
</dl>
<dl>
<dt>
<b>gl_trisetdrawpoint</b>(3)</dt>
<dd>
set a triangle drawing function.</dd>
</dl>
</div>
</div>
<div class="section">
<h1>3. MACROS DEFINED IN VGAGL.H:</h1><dl>
<dt>
<b>WIDTH</b></dt>
<dd>
The width in pixels of the current graphics context.</dd>
</dl>
<dl>
<dt>
<b>HEIGHT</b></dt>
<dd>
Height in pixels.</dd>
</dl>
<dl>
<dt>
<b>BYTESPERPIXEL</b></dt>
<dd>
Number of bytes per pixel (1, 2, 3 or 4).</dd>
</dl>
<dl>
<dt>
<b>BYTEWIDTH</b></dt>
<dd>
Width of a scanline in bytes.</dd>
</dl>
<dl>
<dt>
<b>COLORS</b></dt>
<dd>
Number of colors.</dd>
</dl>
<dl>
<dt>
<b>BITSPERPIXEL</b></dt>
<dd>
Number of significant color bits.</dd>
</dl>
<dl>
<dt>
<b>VBUF</b></dt>
<dd>
Address of the framebuffer.</dd>
</dl>
<dl>
<dt>
<b>__clip</b></dt>
<dd>
Clipping flag.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<dl>
<dt>
<b>__clipx1</b></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<b>__clipy1</b></dt>
<dd>
Top-left corner of clipping window.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
<dl>
<dt>
<b>__clipx2</b></dt>
<dd>
</dd>
</dl>
<dl>
<dt>
<b>__clipy2</b></dt>
<dd>
Bottom-right corner of clipping window.<div style="height: 1.00em;">
&#160;</div>
</dd>
</dl>
</div>
<div class="section">
<h1>BUGS</h1> For three bytes per pixel (true color) modes, it is possible that pixels cross a SVGA segment boundary. This should be correctly handled	by most functions, but you never know. It can be avoided by using a logical scanline length that is a divisor of 65536 (a power of 2), like 1024 (as opposed to 960) for 320x200 and 2048 (1920) for 640x480. For 800x600, this is impractical (4096 as opposed to 2400 doesn't fit in 2MB). Alternatively, avoid those functions by using a virtual screen.<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>SEE ALSO</h1> <b>svgalib</b>(7), <b>libvga.config</b>(5), <b>testgl</b>(6), <b>threedkit</b>(7), <b>currentcontext</b>(3), <b>gl_allocatecontext</b>(3), <b>gl_circle</b>(3), <b>gl_clearscreen</b>(3), <b>gl_colorfont</b>(3), <b>gl_compileboxmask</b>(3), <b>gl_compiledboxmasksize</b>(3), <b>gl_copybox</b>(3), <b>gl_copyboxfromcontext</b>(3), <b>gl_copyboxtocontext</b>(3), <b>gl_copyscreen</b>(3), <b>gl_disableclipping</b>(3), <b>gl_enableclipping</b>(3), <b>gl_enablepageflipping</b>(3), <b>gl_expandfont</b>(3), <b>gl_fillbox</b>(3), <b>gl_font8x8</b>(3), <b>gl_freecontext</b>(3), <b>gl_getbox</b>(3), <b>gl_getcontext</b>(3), <b>gl_getpalette</b>(3), <b>gl_getpalettecolor</b>(3), <b>gl_getpalettecolors</b>(3), <b>gl_getpixel</b>(3), <b>gl_getpixelrgb</b>(3), <b>gl_hline</b>(3), <b>gl_line</b>(3), <b>gl_putbox</b>(3), <b>gl_putboxmask</b>(3), <b>gl_putboxmaskcompiled</b>(3), <b>gl_putboxpart</b>(3), <b>gl_rgbcolor</b>(3), <b>gl_scalebox</b>(3), <b>gl_setclippingwindow</b>(3), <b>gl_setcontext</b>(3), <b>gl_setcontextheight</b>(3), <b>gl_setcontextvga</b>(3), <b>gl_setcontextvgavirtual</b>(3), <b>gl_setcontextvirtual</b>(3), <b>gl_setcontextwidth</b>(3), <b>gl_setdisplaystart</b>(3), <b>gl_setfont</b>(3), <b>gl_setfontcolors</b>(3), <b>gl_setpalette</b>(3), <b>gl_setpalettecolor</b>(3), <b>gl_setpalettecolors</b>(3), <b>gl_setpixel</b>(3), <b>gl_setpixelrgb</b>(3), <b>gl_setrgbpalette</b>(3), <b>gl_setscreenoffset</b>(3), <b>gl_setwritemode</b>(3), <b>gl_striangle</b>(3), <b>gl_swtriangle</b>(3), <b>gl_triangle</b>(3), <b>gl_trigetcolorlookup</b>(3), <b>gl_trisetcolorlookup</b>(3), <b>gl_trisetdrawpoint</b>(3), <b>gl_write</b>(3), <b>gl_writen</b>(3), <b>gl_wtriangle</b>(3).<div style="height: 1.00em;">
&#160;</div>
</div>
<div class="section">
<h1>AUTHOR</h1> There are many authors of svgalib. This page was edited by Michael Weller &lt;eowmob@exp-math.uni-essen.de&gt;. The original documentation and most of <b>vgagl</b> was done by Harm Hanemaayer &lt;H.Hanemaayer@inter.nl.net&gt; though.</div>
<table class="foot">
<tr>
<td class="foot-date">
2 Aug 1997</td>
<td class="foot-os">
Svgalib (&gt;= 1.2.11)</td>
</tr>
</table>
</div>
</body>
</html>

