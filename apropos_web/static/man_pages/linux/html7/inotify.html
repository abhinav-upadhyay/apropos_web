<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
INOTIFY(7)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
INOTIFY(7)</td>
<td class="head-vol">
Linux Programmer's Manual</td>
<td class="head-rtitle">
INOTIFY(7)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> inotify - monitoring file system events</div>
<div class="section">
<h1>DESCRIPTION</h1> The <i>inotify</i> API provides a mechanism for monitoring file system events. Inotify can be used to monitor individual files, or to monitor directories. When a directory is monitored, inotify will return events for the directory itself, and for files inside the directory.<div style="height: 1.00em;">
&#160;</div>
The following system calls are used with this API: <b>inotify_init</b>(2) (or <b>inotify_init1</b>(2)), <b>inotify_add_watch</b>(2), <b>inotify_rm_watch</b>(2), <b>read</b>(2), and <b>close</b>(2).<div style="height: 1.00em;">
&#160;</div>
<b>inotify_init</b>(2) creates an inotify instance and returns a file descriptor referring to the inotify instance. The more recent <b>inotify_init1</b>(2) is like <b>inotify_init</b>(2), but provides some extra functionality.<div style="height: 1.00em;">
&#160;</div>
<b>inotify_add_watch</b>(2) manipulates the &quot;watch list&quot; associated with an inotify instance. Each item (&quot;watch&quot;) in the watch list specifies the pathname of a file or directory, along with some set of events that the kernel should monitor for the file referred to by that pathname. <b>inotify_add_watch</b>(2) either creates a new watch item, or modifies an existing watch. Each watch has a unique &quot;watch descriptor&quot;, an integer returned by <b>inotify_add_watch</b>(2) when the watch is created.<div style="height: 1.00em;">
&#160;</div>
<b>inotify_rm_watch</b>(2) removes an item from an inotify watch list.<div style="height: 1.00em;">
&#160;</div>
When all file descriptors referring to an inotify instance have been closed, the underlying object and its resources are freed for reuse by the kernel; all associated watches are automatically freed.<div style="height: 1.00em;">
&#160;</div>
To determine what events have occurred, an application <b>read</b>(2)s from the inotify file descriptor. If no events have so far occurred, then, assuming a blocking file descriptor, <b>read</b>(2) will block until at least one event occurs (unless interrupted by a signal, in which case the call fails with the error <b>EINTR</b>; see <b>signal</b>(7)).<div style="height: 1.00em;">
&#160;</div>
Each successful <b>read</b>(2) returns a buffer containing one or more of the following structures:<br/>
<div class="spacer">
</div>
<br/>
struct inotify_event {<br/>
    int      wd;       /* Watch descriptor */<br/>
    uint32_t mask;     /* Mask of events */<br/>
    uint32_t cookie;   /* Unique cookie associating related<br/>
                          events (for rename(2)) */<br/>
    uint32_t len;      /* Size of <i>name</i> field */<br/>
    char     name[];   /* Optional null-terminated name */<br/>
};<br/>
<br/>
<div style="height: 1.00em;">
&#160;</div>
<i>wd</i> identifies the watch for which this event occurs. It is one of the watch descriptors returned by a previous call to <b>inotify_add_watch</b>(2).<div style="height: 1.00em;">
&#160;</div>
<i>mask</i> contains bits that describe the event that occurred (see below).<div style="height: 1.00em;">
&#160;</div>
<i>cookie</i> is a unique integer that connects related events. Currently this is only used for rename events, and allows the resulting pair of <b>IN_MOVE_FROM</b> and <b>IN_MOVE_TO</b> events to be connected by the application.<div style="height: 1.00em;">
&#160;</div>
The <i>name</i> field is only present when an event is returned for a file inside a watched directory; it identifies the file pathname relative to the watched directory. This pathname is null-terminated, and may include further null bytes to align subsequent reads to a suitable address boundary.<div style="height: 1.00em;">
&#160;</div>
The <i>len</i> field counts all of the bytes in <i>name</i>, including the null bytes; the length of each <i>inotify_event</i> structure is thus <i>sizeof(inotify_event)+len</i>.<div style="height: 1.00em;">
&#160;</div>
The behavior when the buffer given to <b>read</b>(2) is too small to return information about the next event depends on the kernel version: in kernels before 2.6.21, <b>read</b>(2) returns 0; since kernel 2.6.21, <b>read</b>(2) fails with the error <b>EINVAL</b>.<div class="subsection">
<h2>inotify events</h2> The <b>inotify_add_watch</b>(2) <i>mask</i> argument and the <i>mask</i> field of the <i>inotify_event</i> structure returned when <b>read</b>(2)ing an inotify file descriptor are both bit masks identifying inotify events. The following bits can be specified in <i>mask</i> when calling <b>inotify_add_watch</b>(2) and may be returned in the <i>mask</i> field returned by <b>read</b>(2):<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">
&#160;</div>
<dl>
<dt>
<b>IN_ACCESS</b></dt>
<dd>
File was accessed (read) (*).</dd>
</dl>
<dl>
<dt>
<b>IN_ATTRIB</b></dt>
<dd>
Metadata changed, e.g., permissions, timestamps, extended attributes, link count (since Linux 2.6.25), UID, GID, etc. (*).</dd>
</dl>
<dl>
<dt>
<b>IN_CLOSE_WRITE</b></dt>
<dd>
File opened for writing was closed (*).</dd>
</dl>
<dl>
<dt>
<b>IN_CLOSE_NOWRITE</b></dt>
<dd>
File not opened for writing was closed (*).</dd>
</dl>
<dl>
<dt>
<b>IN_CREATE</b></dt>
<dd>
File/directory created in watched directory (*).</dd>
</dl>
<dl>
<dt>
<b>IN_DELETE</b></dt>
<dd>
File/directory deleted from watched directory (*).</dd>
</dl>
<dl>
<dt>
<b>IN_DELETE_SELF</b></dt>
<dd>
Watched file/directory was itself deleted.</dd>
</dl>
<dl>
<dt>
<b>IN_MODIFY</b></dt>
<dd>
File was modified (*).</dd>
</dl>
<dl>
<dt>
<b>IN_MOVE_SELF</b></dt>
<dd>
Watched file/directory was itself moved.</dd>
</dl>
<dl>
<dt>
<b>IN_MOVED_FROM</b></dt>
<dd>
File moved out of watched directory (*).</dd>
</dl>
<dl>
<dt>
<b>IN_MOVED_TO</b></dt>
<dd>
File moved into watched directory (*).</dd>
</dl>
<dl>
<dt>
<b>IN_OPEN</b></dt>
<dd>
File was opened (*).</dd>
</dl>
</div>
<div class="spacer">
</div>
When monitoring a directory, the events marked with an asterisk (*) above can occur for files in the directory, in which case the <i>name</i> field in the returned <i>inotify_event</i> structure identifies the name of the file within the directory.<div class="spacer">
</div>
The <b>IN_ALL_EVENTS</b> macro is defined as a bit mask of all of the above events. This macro can be used as the <i>mask</i> argument when calling <b>inotify_add_watch</b>(2).<div style="height: 1.00em;">
&#160;</div>
Two additional convenience macros are <b>IN_MOVE</b>, which equates to IN_MOVED_FROM|IN_MOVED_TO, and <b>IN_CLOSE</b>, which equates to IN_CLOSE_WRITE|IN_CLOSE_NOWRITE.<div class="spacer">
</div>
The following further bits can be specified in <i>mask</i> when calling <b>inotify_add_watch</b>(2):<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">
&#160;</div>
<dl>
<dt>
<b>IN_DONT_FOLLOW</b> (since Linux 2.6.15)</dt>
<dd>
Don't dereference <i>pathname</i> if it is a symbolic link.</dd>
</dl>
<dl>
<dt>
<b>IN_EXCL_UNLINK</b> (since Linux 2.6.36)</dt>
<dd>
By default, when watching events on the children of a directory, events are generated for children even after they have been unlinked from the directory. This can result in large numbers of uninteresting events for some applications (e.g., if watching <i>/tmp</i>, in which many applications create temporary files whose names are immediately unlinked). Specifying <b>IN_EXCL_UNLINK</b> changes the default behavior, so that events are not generated for children after they have been unlinked from the watched directory.</dd>
</dl>
<dl>
<dt>
<b>IN_MASK_ADD</b></dt>
<dd>
Add (OR) events to watch mask for this pathname if it already exists (instead of replacing mask).</dd>
</dl>
<dl>
<dt>
<b>IN_ONESHOT</b></dt>
<dd>
Monitor <i>pathname</i> for one event, then remove from watch list.</dd>
</dl>
<dl>
<dt>
<b>IN_ONLYDIR</b> (since Linux 2.6.15)</dt>
<dd>
Only watch <i>pathname</i> if it is a directory.</dd>
</dl>
</div>
<div class="spacer">
</div>
The following bits may be set in the <i>mask</i> field returned by <b>read</b>(2):<div style="margin-left: 4.00ex;">
<div style="height: 1.00em;">
&#160;</div>
<dl>
<dt>
<b>IN_IGNORED</b></dt>
<dd>
Watch was removed explicitly (<b>inotify_rm_watch</b>(2)) or automatically (file was deleted, or file system was unmounted).</dd>
</dl>
<dl>
<dt>
<b>IN_ISDIR</b></dt>
<dd>
Subject of this event is a directory.</dd>
</dl>
<dl>
<dt>
<b>IN_Q_OVERFLOW</b></dt>
<dd>
Event queue overflowed (<i>wd</i> is -1 for this event).</dd>
</dl>
<dl>
<dt>
<b>IN_UNMOUNT</b></dt>
<dd>
File system containing watched object was unmounted.</dd>
</dl>
</div>
</div>
<div class="subsection">
<h2>/proc interfaces</h2> The following interfaces can be used to limit the amount of kernel memory consumed by inotify:<dl>
<dt>
<i>/proc/sys/fs/inotify/max_queued_events</i></dt>
<dd>
The value in this file is used when an application calls <b>inotify_init</b>(2) to set an upper limit on the number of events that can be queued to the corresponding inotify instance. Events in excess of this limit are dropped, but an <b>IN_Q_OVERFLOW</b> event is always generated.</dd>
</dl>
<dl>
<dt>
<i>/proc/sys/fs/inotify/max_user_instances</i></dt>
<dd>
This specifies an upper limit on the number of inotify instances that can be created per real user ID.</dd>
</dl>
<dl>
<dt>
<i>/proc/sys/fs/inotify/max_user_watches</i></dt>
<dd>
This specifies an upper limit on the number of watches that can be created per real user ID.</dd>
</dl>
</div>
</div>
<div class="section">
<h1>VERSIONS</h1> Inotify was merged into the 2.6.13 Linux kernel. The required library interfaces were added to glibc in version 2.4. (<b>IN_DONT_FOLLOW</b>, <b>IN_MASK_ADD</b>, and <b>IN_ONLYDIR</b> were only added in version 2.5.)</div>
<div class="section">
<h1>CONFORMING TO</h1> The inotify API is Linux-specific.</div>
<div class="section">
<h1>NOTES</h1> Inotify file descriptors can be monitored using <b>select</b>(2), <b>poll</b>(2), and <b>epoll</b>(7). When an event is available, the file descriptor indicates as readable.<div style="height: 1.00em;">
&#160;</div>
Since Linux 2.6.25, signal-driven I/O notification is available for inotify file descriptors; see the discussion of <b>F_SETFL</b> (for setting the <b>O_ASYNC</b> flag), <b>F_SETOWN</b>, and <b>F_SETSIG</b> in <b>fcntl</b>(2). The <i>siginfo_t</i> structure (described in <b>sigaction</b>(2)) that is passed to the signal handler has the following fields set: <i>si_fd</i> is set to the inotify file descriptor number; <i>si_signo</i> is set to the signal number; <i>si_code</i> is set to <b>POLL_IN</b>; and <b>POLLIN</b> is set in <i>si_band</i>.<div style="height: 1.00em;">
&#160;</div>
If successive output inotify events produced on the inotify file descriptor are identical (same <i>wd</i>, <i>mask</i>, <i>cookie</i>, and <i>name</i>) then they are coalesced into a single event if the older event has not yet been read (but see BUGS).<div style="height: 1.00em;">
&#160;</div>
The events returned by reading from an inotify file descriptor form an ordered queue. Thus, for example, it is guaranteed that when renaming from one directory to another, events will be produced in the correct order on the inotify file descriptor.<div style="height: 1.00em;">
&#160;</div>
The <b>FIONREAD</b> <b>ioctl</b>(2) returns the number of bytes available to read from an inotify file descriptor.<div class="subsection">
<h2>Limitations and caveats</h2> Inotify monitoring of directories is not recursive: to monitor subdirectories under a directory, additional watches must be created. This can take a significant amount time for large directory trees.<div style="height: 1.00em;">
&#160;</div>
The inotify API provides no information about the user or process that triggered the inotify event.<div style="height: 1.00em;">
&#160;</div>
Note that the event queue can overflow. In this case, events are lost. Robust applications should handle the possibility of lost events gracefully.<div style="height: 1.00em;">
&#160;</div>
The inotify API identifies affected files by filename. However, by the time an application processes an inotify event, the filename may already have been deleted or renamed.<div style="height: 1.00em;">
&#160;</div>
If monitoring an entire directory subtree, and a new subdirectory is created in that tree, be aware that by the time you create a watch for the new subdirectory, new files may already have been created in the subdirectory. Therefore, you may want to scan the contents of the subdirectory immediately after adding the watch.</div>
</div>
<div class="section">
<h1>BUGS</h1> In kernels before 2.6.16, the <b>IN_ONESHOT</b> <i>mask</i> flag does not work.<div style="height: 1.00em;">
&#160;</div>
Before kernel 2.6.25, the kernel code that was intended to coalesce successive identical events (i.e., the two most recent events could potentially be coalesced if the older had not yet been read) instead checked if the most recent event could be coalesced with the <i>oldest</i> unread event.</div>
<div class="section">
<h1>SEE ALSO</h1> <b>inotify_add_watch</b>(2), <b>inotify_init</b>(2), <b>inotify_init1</b>(2), <b>inotify_rm_watch</b>(2), <b>read</b>(2), <b>stat</b>(2), <i>Documentation/filesystems/inotify.txt</i>.</div>
<div class="section">
<h1>COLOPHON</h1> This page is part of release 3.35 of the Linux <i>man-pages</i> project. A description of the project, and information about reporting bugs, can be found at http://man7.org/linux/man-pages/.</div>
<table class="foot">
<tr>
<td class="foot-date">
2010-11-12</td>
<td class="foot-os">
Linux</td>
</tr>
</table>
</div>
</body>
</html>

