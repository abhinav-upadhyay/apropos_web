<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<style>
table.head, table.foot { width: 100%; }
td.head-rtitle, td.foot-os { text-align: right; }
td.head-vol { text-align: center; }
table.foot td { width: 50%; }
table.head td { width: 33%; }
div.spacer { margin: 1em 0; }
</style>
<link rel="stylesheet" href="/static/man_pages/linux/style.css" type="text/css" media="all"/>
<title>
BOOT(7)</title>
</head>
<body>
<div class="mandoc">
<table class="head">
<tbody>
<tr>
<td class="head-ltitle">
BOOT(7)</td>
<td class="head-vol">
Linux Programmer's Manual</td>
<td class="head-rtitle">
BOOT(7)</td>
</tr>
</tbody>
</table>
<div class="section">
<h1>NAME</h1> boot-scripts - General description of boot sequence</div>
<div class="section">
<h1>DESCRIPTION</h1> The boot sequence varies in details among systems but can be roughly divided to the following steps: (i) hardware boot, (ii) OS loader, (iii) kernel startup, (iv) init and inittab, (v) boot scripts. We will describe each of these in more detail below.<div class="subsection">
<h2>Hardware-boot</h2> After power-on or hard reset, control is given to a program stored on read-only memory (normally PROM). In PC we usually call this program the  <b>BIOS</b>.<div style="height: 1.00em;">
&#160;</div>
This program normally makes a basic self-test of the machine and accesses nonvolatile memory to read further parameters. This memory in the PC is battery-backed CMOS memory, so most people refer to it as the  <b>CMOS</b>, although outside of the PC world, it is usually called  <b>nvram</b> (nonvolatile ram).<div style="height: 1.00em;">
&#160;</div>
The parameters stored in the nvram vary between systems, but as a minimum, the hardware boot program should know what is the boot device, or which devices to probe as possible boot devices.<div style="height: 1.00em;">
&#160;</div>
Then the hardware boot stage accesses the boot device, loads the OS Loader, which is located on a fixed position on the boot device, and transfers control to it.<dl>
<dt>
Note:</dt>
<dd>
We do not cover here booting from network. Those who want to investigate this subject may want to research: DHCP, TFTP, PXE, Etherboot.</dd>
</dl>
</div>
<div class="subsection">
<h2>OS Loader</h2> In PC, the OS Loader is located in the first sector of the boot device - this is the  <b>MBR</b> (Master Boot Record).<div style="height: 1.00em;">
&#160;</div>
In most systems, this primary loader is very limited due to various constraints. Even on non-PC systems there are some limitations to the size and complexity of this loader, but the size limitation of the PC MBR (512 bytes including the partition table) makes it almost impossible to squeeze a full OS Loader into it.<div style="height: 1.00em;">
&#160;</div>
Therefore, most operating systems make the primary loader call a secondary OS loader which may be located on a specified disk partition.<div style="height: 1.00em;">
&#160;</div>
In Linux the OS loader is normally <b>lilo</b>(8) or <b>grub</b>(8). Both of them may install either as secondary loaders (where the DOS installed MBR points to them), or as a two part loader where they provide special MBR containing the bootstrap code to load the second part of the loader from the root partition.<div style="height: 1.00em;">
&#160;</div>
The main job of the OS Loader is to locate the kernel on the disk, load it and run it. Most OS loaders allow interactive use, to enable specification of alternative kernel (maybe a backup in case the last compiled one isn't functioning) and to pass optional parameters to the kernel.</div>
<div class="subsection">
<h2>Kernel Startup</h2> When the kernel is loaded, it initializes the devices (via their drivers), starts the swapper (it is a &quot;kernel process&quot;, called kswapd in modern Linux kernels), and mounts the root file system (/).<div style="height: 1.00em;">
&#160;</div>
Some of the parameters that may be passed to the kernel relate to these activities (e.g: You can override the default root file system). For further information on Linux kernel parameters read <b>bootparam</b>(7).<div style="height: 1.00em;">
&#160;</div>
Only then the kernel creates the first (user land) process which is numbered 1. This process executes the program <i>/sbin/init</i>, passing any parameters that weren't handled by the kernel already.</div>
<div class="subsection">
<h2>init and inittab</h2> When init starts it reads <i>/etc/inittab</i> for further instructions. This file defines what should be run in different  <i>run-levels</i>.<div style="height: 1.00em;">
&#160;</div>
This gives the system administrator an easy management scheme, where each run-level is associated with a set of services (e.g:  <b>S</b> is <i>single-user</i>, on <b>2</b> most network services start, etc.). The administrator may change the current run-level via <b>init</b>(8) and query the current run-level via <b>runlevel</b>(8).<div style="height: 1.00em;">
&#160;</div>
However, since it is not convenient to manage individual services by editing this file, inittab only bootstraps a set of scripts that actually start/stop the individual services.</div>
<div class="subsection">
<h2>Boot Scripts</h2><dl>
<dt>
Note:</dt>
<dd>
The following description applies to System V release 4-based systems, which currently covers most commercial UNIX systems (Solaris, HP-UX, Irix, Tru64) as well as the major Linux distributions (Red Hat, Debian, Mandriva, SUSE, Ubuntu). Some systems (Slackware Linux, FreeBSD, OpenBSD) have a somewhat different scheme of boot scripts.</dd>
</dl>
<div class="spacer">
</div>
For each managed service (mail, nfs server, cron, etc.) there is a single startup script located in a specific directory (<i>/etc/init.d</i> in most versions of Linux). Each of these scripts accepts as a single argument the word &quot;start&quot; -- causing it to start the service, or the word &quot;stop&quot; -- causing it to stop the service. The script may optionally accept other &quot;convenience&quot; parameters (e.g: &quot;restart&quot;, to stop and then start, &quot;status&quot; do display the service status). Running the script without parameters displays the possible arguments.</div>
<div class="subsection">
<h2>Sequencing Directories</h2> To make specific scripts start/stop at specific run-levels and in specific order, there are  <i>sequencing directories</i>. These are normally in  <i>/etc/rc[0-6S].d</i>. In each of these directories there are links (usually symbolic) to the scripts in the  <i>/etc/init.d</i> directory.<div style="height: 1.00em;">
&#160;</div>
A primary script (usually <i>/etc/rc</i>) is called from <b>inittab</b>(5) and calls the services scripts via the links in the sequencing directories. All links with names that begin with 'S' are being called with the argument &quot;start&quot; (thereby starting the service). All links with names that begin with 'K' are being called with the argument &quot;stop&quot; (thereby stopping the service).<div style="height: 1.00em;">
&#160;</div>
To define the starting or stopping order within the same run-level, the names of the links contain order-numbers. Also, to make the names clearer, they usually end with the name of the service they refer to. Example: the link  <i>/etc/rc2.d/S80sendmail</i> starts the sendmail service on runlevel 2. This happens after  <i>/etc/rc2.d/S12syslog</i> is run but before  <i>/etc/rc2.d/S90xfs</i> is run.<div style="height: 1.00em;">
&#160;</div>
To manage the boot order and run-levels, we have to manage these links. However, on many versions of Linux, there are tools to help with this task (e.g: <b>chkconfig</b>(8)).</div>
<div class="subsection">
<h2>Boot Configuration</h2> Usually the daemons started may optionally receive command-line options and parameters. To allow system administrators to change these parameters without editing the boot scripts themselves, configuration files are used. These are located in a specific directory ( <i>/etc/sysconfig</i> on Red Hat systems) and are used by the boot scripts.<div style="height: 1.00em;">
&#160;</div>
In older UNIX systems, these files contained the actual command line options for the daemons, but in modern Linux systems (and also in HP-UX), these files just contain shell variables. The boot scripts in  <i>/etc/init.d</i>  <b>source</b> the configuration files, and then use the variable values.</div>
</div>
<div class="section">
<h1>FILES</h1> <i>/etc/init.d/</i>, <i>/etc/rc[S0-6].d/</i>, <i>/etc/sysconfig/</i></div>
<div class="section">
<h1>SEE ALSO</h1> <b>inittab</b>(5), <b>bootparam</b>(7), <b>init</b>(8), <b>runlevel</b>(8), <b>shutdown</b>(8)</div>
<div class="section">
<h1>COLOPHON</h1> This page is part of release 3.35 of the Linux <i>man-pages</i> project. A description of the project, and information about reporting bugs, can be found at http://man7.org/linux/man-pages/.</div>
<table class="foot">
<tr>
<td class="foot-date">
2010-09-19</td>
<td class="foot-os">
Linux</td>
</tr>
</table>
</div>
</body>
</html>

